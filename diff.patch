diff --git a/client/core/NodeManager.ts b/client/core/NodeManager.ts
new file mode 100644
index 00000000..3086c172
--- /dev/null
+++ b/client/core/NodeManager.ts
@@ -0,0 +1,70 @@
+import { Node, Vector3 } from './types';
+import * as THREE from 'three';
+import { SceneManager } from '../rendering/scene';
+
+export class NodeManager {
+  private static instance: NodeManager | null = null;
+  private nodeMatrices: Map<string, THREE.Matrix4> = new Map();
+  private nodes: Map<string, Node> = new Map();
+  private tempVector = new THREE.Vector3();
+  private sceneManager: SceneManager;
+
+  private constructor(sceneManager: SceneManager) {
+    this.sceneManager = sceneManager;
+  }
+
+  public static getInstance(sceneManager: SceneManager): NodeManager {
+    if (!NodeManager.instance) {
+      NodeManager.instance = new NodeManager(sceneManager);
+    }
+    return NodeManager.instance;
+  }
+
+  public addNode(node: Node): void {
+    this.nodes.set(node.id, node);
+    this.nodeMatrices.set(node.id, new THREE.Matrix4());
+    this.updateNodePositionInternal(node.id, node.data.position);
+  }
+
+  public removeNode(nodeId: string): void {
+    this.nodes.delete(nodeId);
+    this.nodeMatrices.delete(nodeId);
+  }
+
+  public updateNodePositions(delta: Vector3): void {
+    for (const node of this.nodes.values()) {
+      const newPosition = {
+        x: node.data.position.x + delta.x,
+        y: node.data.position.y + delta.y,
+        z: node.data.position.z + delta.z
+      };
+      this.updateNodePositionInternal(node.id, newPosition);
+      node.data.position = newPosition;
+    }
+  }
+
+  private updateNodePositionInternal(nodeId: string, position: Vector3): void {
+    const matrix = this.nodeMatrices.get(nodeId);
+    if (matrix) {
+      this.tempVector.set(position.x, position.y, position.z);
+      matrix.identity();
+      matrix.elements[12] = this.tempVector.x;
+      matrix.elements[13] = this.tempVector.y;
+      matrix.elements[14] = this.tempVector.z;
+    }
+  }
+
+  public getNodeMatrix(nodeId: string): THREE.Matrix4 | undefined {
+    return this.nodeMatrices.get(nodeId);
+  }
+
+  public getNodes(): Node[] {
+    return Array.from(this.nodes.values());
+  }
+
+  public dispose(): void {
+    this.nodes.clear();
+    this.nodeMatrices.clear();
+    NodeManager.instance = null;
+  }
+}
diff --git a/client/core/types.ts b/client/core/types.ts
index b1512a69..86ecd1e6 100644
--- a/client/core/types.ts
+++ b/client/core/types.ts
@@ -99,31 +99,161 @@ export interface VisualizationSettings {
   nodeSize: number;
   nodeColor: string;
   nodeOpacity: number;
-  nodeHighlightColor: string;
-  
+  metalness: number;
+  roughness: number;
+  clearcoat: number;
+
   // Edge appearance
   edgeWidth: number;
   edgeColor: string;
   edgeOpacity: number;
-  
+  enableArrows: boolean;
+  arrowSize: number;
+
   // Visual effects
   enableBloom: boolean;
   bloomIntensity: number;
-  bloomThreshold: number;
   bloomRadius: number;
-  
-  // Performance
-  maxFps: number;
-  updateThrottle: number;
+  enableNodeAnimations: boolean;
+  enableMotionBlur: boolean;
+  motionBlurStrength: number;
 
   // Labels
   showLabels: boolean;
   labelSize: number;
   labelColor: string;
 
-  // XR specific
-  xrControllerVibration: boolean;
-  xrControllerHapticIntensity: number;
+  // Performance
+  maxFps: number;
+
+  // AR Settings (Meta Quest 3)
+  // Scene Understanding
+  enablePlaneDetection: boolean;
+  enableSceneUnderstanding: boolean;
+  showPlaneOverlay: boolean;
+  planeOpacity: number;
+  planeColor: string;
+  enableLightEstimation: boolean;
+  
+  // Hand Tracking
+  enableHandTracking: boolean;
+  handMeshEnabled: boolean;
+  handMeshColor: string;
+  handMeshOpacity: number;
+  handRayEnabled: boolean;
+  handRayColor: string;
+  handRayWidth: number;
+  handPointSize: number;
+  
+  // Gesture Controls
+  gestureSmoothing: number;
+  pinchThreshold: number;
+  dragThreshold: number;
+  rotationThreshold: number;
+  
+  // Haptics
+  enableHaptics: boolean;
+  hapticIntensity: number;
+  
+  // Room Scale
+  roomScale: boolean;
+  snapToFloor: boolean;
+  
+  // Passthrough
+  passthroughOpacity: number;
+  passthroughBrightness: number;
+  passthroughContrast: number;
+  enablePassthroughPortal: boolean;
+  portalSize: number;
+  portalEdgeColor: string;
+  portalEdgeWidth: number;
+}
+
+export interface BinaryNodeUpdate {
+  nodeId: string;
+  data: NodeData;
+}
+
+export interface BinaryPositionUpdateMessage {
+  type: 'binaryPositionUpdate';
+  data: {
+    nodes: BinaryNodeUpdate[];
+  };
+}
+
+// Other message types
+export interface RequestInitialDataMessage {
+  type: 'requestInitialData';
+}
+
+export interface EnableBinaryUpdatesMessage {
+  type: 'enableBinaryUpdates';
+}
+
+export interface SettingsUpdateMessage {
+  type: 'settingsUpdated';
+  data: {
+    settings: VisualizationSettings;
+  };
+}
+
+export interface UpdateSettingsMessage {
+  type: 'updateSettings';
+  data: {
+    settings: Partial<VisualizationSettings>;
+  };
+}
+
+export interface PingMessage {
+  type: 'ping';
+}
+
+export interface PongMessage {
+  type: 'pong';
+}
+
+// Union types for messages
+export type RawWebSocketMessage =
+  | RawInitialDataMessage
+  | RawBinaryPositionUpdateMessage
+  | SettingsUpdateMessage
+  | UpdateSettingsMessage
+  | RequestInitialDataMessage
+  | EnableBinaryUpdatesMessage
+  | PingMessage
+  | PongMessage;
+
+export type WebSocketMessage =
+  | InitialDataMessage
+  | BinaryPositionUpdateMessage
+  | SettingsUpdateMessage
+  | UpdateSettingsMessage
+  | RequestInitialDataMessage
+  | EnableBinaryUpdatesMessage
+  | PingMessage
+  | PongMessage;
+
+// Platform detection types
+export type Platform = 'browser' | 'quest';
+
+export interface PlatformCapabilities {
+  xrSupported: boolean;
+  webglSupported: boolean;
+  websocketSupported: boolean;
+}
+
+// Message queue types
+export interface QueuedMessage {
+  data: ArrayBuffer;
+  timestamp: number;
+}
+
+// Debug types
+export interface NetworkDebugMessage {
+  direction: 'in' | 'out';
+  type: 'binary' | 'json';
+  timestamp: number;
+  data: any;
 }
 
 // Transform functions
@@ -221,90 +351,3 @@ export interface InitialDataMessage {
     graph: GraphData;
   };
 }
-
-export interface BinaryNodeUpdate {
-  nodeId: string;
-  data: NodeData;
-}
-
-export interface BinaryPositionUpdateMessage {
-  type: 'binaryPositionUpdate';
-  data: {
-    nodes: BinaryNodeUpdate[];
-  };
-}
-
-// Other message types
-export interface RequestInitialDataMessage {
-  type: 'requestInitialData';
-}
-
-export interface EnableBinaryUpdatesMessage {
-  type: 'enableBinaryUpdates';
-}
-
-export interface SettingsUpdateMessage {
-  type: 'settingsUpdated';
-data: {
-    settings: VisualizationSettings;
-  };
-}
-
-export interface UpdateSettingsMessage {
-  type: 'updateSettings';
-data: {
-    settings: Partial<VisualizationSettings>;
-  };
-}
-
-export interface PingMessage {
-  type: 'ping';
-}
-
-export interface PongMessage {
-  type: 'pong';
-}
-
-// Union types for messages
-export type RawWebSocketMessage =
-  | RawInitialDataMessage
-  | RawBinaryPositionUpdateMessage
-  | SettingsUpdateMessage
-  | UpdateSettingsMessage
-  | RequestInitialDataMessage
-  | EnableBinaryUpdatesMessage
-  | PingMessage
-  | PongMessage;
-
-export type WebSocketMessage =
-  | InitialDataMessage
-  | BinaryPositionUpdateMessage
-  | SettingsUpdateMessage
-  | UpdateSettingsMessage
-  | RequestInitialDataMessage
-  | EnableBinaryUpdatesMessage
-  | PingMessage
-  | PongMessage;
-
-// Platform detection types
-export type Platform = 'browser' | 'quest';
-
-export interface PlatformCapabilities {
-  xrSupported: boolean;
-  webglSupported: boolean;
-  websocketSupported: boolean;
-}
-
-// Message queue types
-export interface QueuedMessage {
-  data: ArrayBuffer;
-  timestamp: number;
-}
-
-// Debug types
-export interface NetworkDebugMessage {
-  direction: 'in' | 'out';
-  type: 'binary' | 'json';
-  timestamp: number;
-  data: any;
-}
diff --git a/client/index.html b/client/index.html
index 7caf56b9..d972fa1d 100644
--- a/client/index.html
+++ b/client/index.html
@@ -25,154 +25,12 @@
       width: 100%;
       height: 100%;
     }
-
-    #settings-panel {
-      position: fixed;
-      top: 20px;
-      right: 20px;
-      background: rgba(0, 0, 0, 0.8);
-      padding: 20px;
-      border-radius: 8px;
-      z-index: 1000;
-      min-width: 300px;
-    }
-
-    .settings-group {
-      margin-bottom: 15px;
-    }
-
-    .settings-group h3 {
-      margin-bottom: 8px;
-      color: #4a90e2;
-    }
-
-    .setting-item {
-      margin-bottom: 8px;
-    }
-
-    label {
-      display: block;
-      margin-bottom: 4px;
-    }
-
-    input[type="number"],
-    input[type="color"] {
-      width: 100%;
-      padding: 4px;
-      border: 1px solid #666;
-      background: #333;
-      color: #fff;
-      border-radius: 4px;
-    }
-
-    button {
-      padding: 8px 16px;
-      background: #4a90e2;
-      color: #fff;
-      border: none;
-      border-radius: 4px;
-      cursor: pointer;
-      transition: background 0.2s;
-    }
-
-    button:hover {
-      background: #357abd;
-    }
-
-    #xr-button {
-      position: fixed;
-      bottom: 20px;
-      right: 20px;
-      z-index: 1000;
-    }
-
-    .loading-overlay {
-      position: fixed;
-      top: 0;
-      left: 0;
-      width: 100%;
-      height: 100%;
-      background: rgba(0, 0, 0, 0.8);
-      display: flex;
-      justify-content: center;
-      align-items: center;
-      z-index: 2000;
-    }
-
-    .loading-spinner {
-      width: 50px;
-      height: 50px;
-      border: 5px solid #f3f3f3;
-      border-top: 5px solid #4a90e2;
-      border-radius: 50%;
-      animation: spin 1s linear infinite;
-    }
-
-    @keyframes spin {
-      0% { transform: rotate(0deg); }
-      100% { transform: rotate(360deg); }
-    }
   </style>
 </head>
 <body>
-  <div id="canvas-container"></div>
-
-  <div id="settings-panel">
-    <div class="settings-group">
-      <h3>Node Appearance</h3>
-      <div class="setting-item">
-        <label for="nodeSize">Node Size</label>
-        <input type="number" id="nodeSize" min="0.1" max="5" step="0.1" value="2.5">
-      </div>
-      <div class="setting-item">
-        <label for="nodeColor">Node Color</label>
-        <input type="color" id="nodeColor" value="#4CAF50">
-      </div>
-      <div class="setting-item">
-        <label for="nodeOpacity">Node Opacity</label>
-        <input type="number" id="nodeOpacity" min="0" max="1" step="0.1" value="0.7">
-      </div>
-    </div>
-
-    <div class="settings-group">
-      <h3>Edge Appearance</h3>
-      <div class="setting-item">
-        <label for="edgeWidth">Edge Width</label>
-        <input type="number" id="edgeWidth" min="0.1" max="5" step="0.1" value="0.25">
-      </div>
-      <div class="setting-item">
-        <label for="edgeColor">Edge Color</label>
-        <input type="color" id="edgeColor" value="#E0E0E0">
-      </div>
-      <div class="setting-item">
-        <label for="edgeOpacity">Edge Opacity</label>
-        <input type="number" id="edgeOpacity" min="0" max="1" step="0.1" value="0.7">
-      </div>
-    </div>
-
-    <div class="settings-group">
-      <h3>Visual Effects</h3>
-      <div class="setting-item">
-        <label>
-          <input type="checkbox" id="enableBloom" checked>
-          Enable Bloom
-        </label>
-      </div>
-      <div class="setting-item">
-        <label for="bloomIntensity">Bloom Intensity</label>
-        <input type="number" id="bloomIntensity" min="0" max="3" step="0.1" value="1.5">
-      </div>
-    </div>
-
-    <button id="save-settings">Save Settings</button>
+  <div id="canvas-container">
+    <canvas id="main-canvas"></canvas>
   </div>
-
-  <button id="xr-button" style="display: none;">Enter AR</button>
-
-  <div class="loading-overlay">
-    <div class="loading-spinner"></div>
-  </div>
-
-  <script type="module" src="./index.ts"></script>
+  <script type="module" src="/index.ts"></script>
 </body>
 </html>
diff --git a/client/index.ts b/client/index.ts
index 5dd884ce..c2a81e7f 100644
--- a/client/index.ts
+++ b/client/index.ts
@@ -14,6 +14,7 @@ import { XRInteraction } from './xr/xrInteraction';
 import { createLogger } from './core/utils';
 import { WS_URL } from './core/constants';
 import { BinaryNodeUpdate } from './core/types';
+import { ControlPanel } from './ui';
 
 const logger = createLogger('Application');
 
@@ -46,6 +47,9 @@ class Application {
       // Initialize XR if supported
       await this.initializeXR();
 
+      // Initialize UI components
+      new ControlPanel(); // Create the control panel instance
+
       // Setup UI event listeners
       this.setupUIEventListeners();
 
diff --git a/client/state/settings.ts b/client/state/settings.ts
index 0e7c6f1b..ed6474c5 100644
--- a/client/state/settings.ts
+++ b/client/state/settings.ts
@@ -3,12 +3,86 @@
  */
 
 import { VisualizationSettings } from '../core/types';
-import { DEFAULT_VISUALIZATION_SETTINGS } from '../core/constants';
 import { createLogger } from '../core/utils';
 import { WebSocketService } from '../websocket/websocketService';
 
 const logger = createLogger('SettingsManager');
 
+export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
+    // Node Appearance
+    nodeSize: 0.2,
+    nodeColor: '#FFB700',
+    nodeOpacity: 0.92,
+    metalness: 0.85,
+    roughness: 0.15,
+    clearcoat: 1.0,
+
+    // Edge Appearance
+    edgeWidth: 2.0,
+    edgeColor: '#FFD700',
+    edgeOpacity: 0.6,
+    enableArrows: true,
+    arrowSize: 0.15,
+
+    // Visual Effects
+    enableBloom: true,
+    bloomIntensity: 1.8,
+    bloomRadius: 0.5,
+    enableNodeAnimations: true,
+    enableMotionBlur: true,
+    motionBlurStrength: 0.4,
+
+    // Labels
+    showLabels: true,
+    labelSize: 1.0,
+    labelColor: '#FFFFFF',
+
+    // Performance
+    maxFps: 60,
+
+    // AR Settings (Meta Quest 3)
+    // Scene Understanding
+    enablePlaneDetection: true,
+    enableSceneUnderstanding: true,
+    showPlaneOverlay: true,
+    planeOpacity: 0.3,
+    planeColor: '#4A90E2',
+    enableLightEstimation: true,
+    
+    // Hand Tracking
+    enableHandTracking: true,
+    handMeshEnabled: true,
+    handMeshColor: '#FFD700',
+    handMeshOpacity: 0.3,
+    handRayEnabled: true,
+    handRayColor: '#FFD700',
+    handRayWidth: 0.002,
+    handPointSize: 0.01,
+    
+    // Gesture Controls
+    gestureSmoothing: 0.9,
+    pinchThreshold: 0.015,
+    dragThreshold: 0.04,
+    rotationThreshold: 0.08,
+    
+    // Haptics
+    enableHaptics: true,
+    hapticIntensity: 0.7,
+    
+    // Room Scale
+    roomScale: true,
+    snapToFloor: true,
+    
+    // Passthrough
+    passthroughOpacity: 1.0,
+    passthroughBrightness: 1.0,
+    passthroughContrast: 1.0,
+    enablePassthroughPortal: false,
+    portalSize: 1.0,
+    portalEdgeColor: '#FFD700',
+    portalEdgeWidth: 0.02
+};
+
 export class SettingsManager {
   private static instance: SettingsManager | null = null;
   private settings: VisualizationSettings;
@@ -106,6 +180,20 @@ export class SettingsManager {
     });
   }
 
+  /**
+   * Add a settings update listener
+   */
+  addSettingsListener(listener: (settings: VisualizationSettings) => void): void {
+    this.settingsListeners.add(listener);
+  }
+
+  /**
+   * Remove a settings update listener
+   */
+  removeSettingsListener(listener: (settings: VisualizationSettings) => void): void {
+    this.settingsListeners.delete(listener);
+  }
+
   /**
    * Get current settings
    */
@@ -144,6 +232,49 @@ export class SettingsManager {
     SettingsManager.instance = null;
   }
 
+  public getThreeJSSettings() {
+    return {
+      nodes: {
+        size: this.settings.nodeSize,
+        color: this.settings.nodeColor,
+        opacity: this.settings.nodeOpacity,
+        metalness: this.settings.metalness,
+        roughness: this.settings.roughness,
+        clearcoat: this.settings.clearcoat,
+        highlightColor: '#FFFFFF' // Default highlight color
+      },
+      edges: {
+        width: this.settings.edgeWidth,
+        color: this.settings.edgeColor,
+        opacity: this.settings.edgeOpacity,
+        arrows: {
+          enabled: this.settings.enableArrows,
+          size: this.settings.arrowSize
+        }
+      },
+      bloom: {
+        enabled: this.settings.enableBloom,
+        intensity: this.settings.bloomIntensity,
+        radius: this.settings.bloomRadius
+      },
+      animations: {
+        enabled: this.settings.enableNodeAnimations,
+        motionBlur: {
+          enabled: this.settings.enableMotionBlur,
+          strength: this.settings.motionBlurStrength
+        }
+      },
+      labels: {
+        enabled: this.settings.showLabels,
+        size: this.settings.labelSize,
+        color: this.settings.labelColor
+      },
+      performance: {
+        maxFps: this.settings.maxFps
+      }
+    };
+  }
+
   // Essential setting getters
   getNodeSettings(): {
     size: number;
@@ -155,7 +286,7 @@ export class SettingsManager {
       size: this.settings.nodeSize,
       color: this.settings.nodeColor,
       opacity: this.settings.nodeOpacity,
-      highlightColor: this.settings.nodeHighlightColor
+      highlightColor: '#FFFFFF' // Default highlight color
     };
   }
 
@@ -180,7 +311,7 @@ export class SettingsManager {
     return {
       enabled: this.settings.enableBloom,
       intensity: this.settings.bloomIntensity,
-      threshold: this.settings.bloomThreshold,
+      threshold: 0.5, // Default threshold
       radius: this.settings.bloomRadius
     };
   }
@@ -202,8 +333,8 @@ export class SettingsManager {
     hapticIntensity: number;
   } {
     return {
-      controllerVibration: this.settings.xrControllerVibration,
-      hapticIntensity: this.settings.xrControllerHapticIntensity
+      controllerVibration: false, // Default controller vibration
+      hapticIntensity: 0.5 // Default haptic intensity
     };
   }
 
@@ -213,7 +344,7 @@ export class SettingsManager {
   } {
     return {
       maxFps: this.settings.maxFps,
-      updateThrottle: this.settings.updateThrottle
+      updateThrottle: 0 // Default update throttle
     };
   }
 }
diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
new file mode 100644
index 00000000..389de53a
--- /dev/null
+++ b/client/ui/ControlPanel.css
@@ -0,0 +1,169 @@
+.control-panel {
+    position: fixed;
+    top: 20px;
+    right: 20px;
+    background: rgba(0, 0, 0, 0.85);
+    border-radius: 8px;
+    color: #fff;
+    font-family: Arial, sans-serif;
+    width: 320px;
+    max-height: 90vh;
+    overflow-y: auto;
+    transition: transform 0.3s ease;
+    z-index: 1000;
+    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
+}
+
+.control-panel-header {
+    display: flex;
+    justify-content: space-between;
+    align-items: center;
+    padding: 12px 16px;
+    background: rgba(0, 0, 0, 0.2);
+    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
+}
+
+.control-panel-header h3 {
+    margin: 0;
+    font-size: 16px;
+    font-weight: 500;
+}
+
+.toggle-button {
+    background: none;
+    border: none;
+    color: #fff;
+    font-size: 20px;
+    cursor: pointer;
+    padding: 4px 8px;
+    transition: transform 0.3s ease;
+}
+
+.control-panel-content {
+    padding: 16px;
+    max-height: calc(90vh - 50px);
+    overflow-y: auto;
+}
+
+.settings-group {
+    margin-bottom: 24px;
+}
+
+.settings-group h4 {
+    margin: 0 0 12px 0;
+    font-size: 14px;
+    color: #4a90e2;
+    font-weight: 500;
+}
+
+.setting-item {
+    margin-bottom: 12px;
+}
+
+.setting-item label {
+    display: block;
+    margin-bottom: 4px;
+    font-size: 12px;
+    color: #ccc;
+}
+
+.setting-item input[type="range"] {
+    width: 100%;
+    height: 4px;
+    background: #333;
+    border-radius: 2px;
+    -webkit-appearance: none;
+}
+
+.setting-item input[type="range"]::-webkit-slider-thumb {
+    -webkit-appearance: none;
+    width: 12px;
+    height: 12px;
+    background: #4a90e2;
+    border-radius: 50%;
+    cursor: pointer;
+    transition: background 0.2s;
+}
+
+.setting-item input[type="range"]::-webkit-slider-thumb:hover {
+    background: #357abd;
+}
+
+.setting-item input[type="color"] {
+    width: 100%;
+    height: 30px;
+    padding: 2px;
+    border: 1px solid #444;
+    background: #222;
+    border-radius: 4px;
+    cursor: pointer;
+}
+
+.setting-item input[type="number"] {
+    width: 100%;
+    padding: 6px;
+    border: 1px solid #444;
+    background: #222;
+    color: #fff;
+    border-radius: 4px;
+}
+
+.setting-item input[type="checkbox"] {
+    margin-right: 8px;
+}
+
+.setting-item.disabled {
+    opacity: 0.5;
+    pointer-events: none;
+}
+
+.save-button {
+    width: 100%;
+    padding: 8px 16px;
+    background: #4a90e2;
+    color: #fff;
+    border: none;
+    border-radius: 4px;
+    cursor: pointer;
+    font-size: 14px;
+    transition: background 0.2s;
+}
+
+.save-button:hover {
+    background: #357abd;
+}
+
+/* Custom scrollbar */
+.control-panel-content::-webkit-scrollbar {
+    width: 6px;
+}
+
+.control-panel-content::-webkit-scrollbar-track {
+    background: rgba(0, 0, 0, 0.1);
+}
+
+.control-panel-content::-webkit-scrollbar-thumb {
+    background: rgba(255, 255, 255, 0.2);
+    border-radius: 3px;
+}
+
+.control-panel-content::-webkit-scrollbar-thumb:hover {
+    background: rgba(255, 255, 255, 0.3);
+}
+
+/* Animations */
+@keyframes fadeIn {
+    from { opacity: 0; }
+    to { opacity: 1; }
+}
+
+.control-panel {
+    animation: fadeIn 0.3s ease;
+}
+
+/* Responsive design */
+@media (max-width: 768px) {
+    .control-panel {
+        width: 280px;
+    }
+}
diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
new file mode 100644
index 00000000..e59b53de
--- /dev/null
+++ b/client/ui/ControlPanel.ts
@@ -0,0 +1,515 @@
+import { VisualizationSettings } from '../core/types';
+import { settingsManager } from '../state/settings';
+import { createLogger } from '../core/utils';
+
+const logger = createLogger('ControlPanel');
+
+export class ControlPanel {
+    private container: HTMLDivElement;
+    private settings: VisualizationSettings;
+    private isExpanded = false;
+    
+    constructor() {
+        this.container = document.createElement('div');
+        this.container.className = 'control-panel';
+        this.settings = { ...settingsManager.getSettings() };
+        this.initializeUI();
+        this.setupEventListeners();
+        
+        // Subscribe to settings updates
+        settingsManager.addSettingsListener(this.onSettingsUpdate.bind(this));
+    }
+
+    private initializeUI(): void {
+        this.container.innerHTML = `
+            <div class="control-panel-header">
+                <h3>Graph Controls</h3>
+                <button class="toggle-button">≡</button>
+            </div>
+            <div class="control-panel-content">
+                <div class="settings-group">
+                    <h4>Node Appearance</h4>
+                    <div class="setting-item">
+                        <label for="nodeSize">Base Size</label>
+                        <input type="range" id="nodeSize" min="0.1" max="2" step="0.1" value="${this.settings.nodeSize}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="nodeColor">Color</label>
+                        <input type="color" id="nodeColor" value="${this.settings.nodeColor}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="nodeOpacity">Opacity</label>
+                        <input type="range" id="nodeOpacity" min="0" max="1" step="0.1" value="${this.settings.nodeOpacity}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="metalness">Metalness</label>
+                        <input type="range" id="metalness" min="0" max="1" step="0.05" value="${this.settings.metalness}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="roughness">Roughness</label>
+                        <input type="range" id="roughness" min="0" max="1" step="0.05" value="${this.settings.roughness}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="clearcoat">Clearcoat</label>
+                        <input type="range" id="clearcoat" min="0" max="1" step="0.1" value="${this.settings.clearcoat}">
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Edge Appearance</h4>
+                    <div class="setting-item">
+                        <label for="edgeWidth">Width</label>
+                        <input type="range" id="edgeWidth" min="0.1" max="5" step="0.1" value="${this.settings.edgeWidth}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="edgeColor">Color</label>
+                        <input type="color" id="edgeColor" value="${this.settings.edgeColor}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="edgeOpacity">Opacity</label>
+                        <input type="range" id="edgeOpacity" min="0" max="1" step="0.1" value="${this.settings.edgeOpacity}">
+                    </div>
+                    <div class="setting-item">
+                        <label>
+                            <input type="checkbox" id="enableArrows" ${this.settings.enableArrows ? 'checked' : ''}>
+                            Show Arrows
+                        </label>
+                    </div>
+                    <div class="setting-item arrow-setting ${this.settings.enableArrows ? '' : 'disabled'}">
+                        <label for="arrowSize">Arrow Size</label>
+                        <input type="range" id="arrowSize" min="0.1" max="1" step="0.05" value="${this.settings.arrowSize}">
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Visual Effects</h4>
+                    <div class="setting-item">
+                        <label>
+                            <input type="checkbox" id="enableBloom" ${this.settings.enableBloom ? 'checked' : ''}>
+                            Enable Bloom
+                        </label>
+                    </div>
+                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
+                        <label for="bloomIntensity">Bloom Intensity</label>
+                        <input type="range" id="bloomIntensity" min="0" max="2" step="0.1" value="${this.settings.bloomIntensity}">
+                    </div>
+                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
+                        <label for="bloomRadius">Bloom Radius</label>
+                        <input type="range" id="bloomRadius" min="0" max="2" step="0.1" value="${this.settings.bloomRadius}">
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Animations</h4>
+                    <div class="setting-item">
+                        <label>
+                            <input type="checkbox" id="enableNodeAnimations" ${this.settings.enableNodeAnimations ? 'checked' : ''}>
+                            Node Animations
+                        </label>
+                    </div>
+                    <div class="setting-item">
+                        <label>
+                            <input type="checkbox" id="enableMotionBlur" ${this.settings.enableMotionBlur ? 'checked' : ''}>
+                            Motion Blur
+                        </label>
+                    </div>
+                    <div class="setting-item motion-setting ${this.settings.enableMotionBlur ? '' : 'disabled'}">
+                        <label for="motionBlurStrength">Motion Blur Strength</label>
+                        <input type="range" id="motionBlurStrength" min="0" max="1" step="0.1" value="${this.settings.motionBlurStrength}">
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Labels</h4>
+                    <div class="setting-item">
+                        <label>
+                            <input type="checkbox" id="showLabels" ${this.settings.showLabels ? 'checked' : ''}>
+                            Show Labels
+                        </label>
+                    </div>
+                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
+                        <label for="labelSize">Label Size</label>
+                        <input type="range" id="labelSize" min="0.5" max="2" step="0.1" value="${this.settings.labelSize}">
+                    </div>
+                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
+                        <label for="labelColor">Label Color</label>
+                        <input type="color" id="labelColor" value="${this.settings.labelColor}">
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Performance</h4>
+                    <div class="setting-item">
+                        <label for="maxFps">Max FPS</label>
+                        <input type="number" id="maxFps" min="30" max="144" value="${this.settings.maxFps}">
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>AR Settings</h4>
+                    <div class="setting-item">
+                        <label>Scene Understanding</label>
+                        <div class="sub-settings">
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="enablePlaneDetection" ${this.settings.enablePlaneDetection ? 'checked' : ''}>
+                                    Plane Detection
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="enableSceneUnderstanding" ${this.settings.enableSceneUnderstanding ? 'checked' : ''}>
+                                    Scene Understanding
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="showPlaneOverlay" ${this.settings.showPlaneOverlay ? 'checked' : ''}>
+                                    Show Plane Overlay
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label for="planeOpacity">Plane Opacity</label>
+                                <input type="range" id="planeOpacity" min="0" max="1" step="0.1" value="${this.settings.planeOpacity}">
+                            </div>
+                            <div class="setting-item">
+                                <label for="planeColor">Plane Color</label>
+                                <input type="color" id="planeColor" value="${this.settings.planeColor}">
+                            </div>
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="enableLightEstimation" ${this.settings.enableLightEstimation ? 'checked' : ''}>
+                                    Light Estimation
+                                </label>
+                            </div>
+                        </div>
+                    </div>
+
+                    <div class="setting-item">
+                        <label>Hand Tracking</label>
+                        <div class="sub-settings">
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="enableHandTracking" ${this.settings.enableHandTracking ? 'checked' : ''}>
+                                    Enable Hand Tracking
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="handMeshEnabled" ${this.settings.handMeshEnabled ? 'checked' : ''}>
+                                    Show Hand Mesh
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label for="handMeshColor">Hand Mesh Color</label>
+                                <input type="color" id="handMeshColor" value="${this.settings.handMeshColor}">
+                            </div>
+                            <div class="setting-item">
+                                <label for="handMeshOpacity">Hand Mesh Opacity</label>
+                                <input type="range" id="handMeshOpacity" min="0" max="1" step="0.1" value="${this.settings.handMeshOpacity}">
+                            </div>
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="handRayEnabled" ${this.settings.handRayEnabled ? 'checked' : ''}>
+                                    Show Hand Ray
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label for="handRayColor">Hand Ray Color</label>
+                                <input type="color" id="handRayColor" value="${this.settings.handRayColor}">
+                            </div>
+                        </div>
+                    </div>
+
+                    <div class="setting-item">
+                        <label>Gesture Controls</label>
+                        <div class="sub-settings">
+                            <div class="setting-item">
+                                <label for="gestureSmoothing">Gesture Smoothing</label>
+                                <input type="range" id="gestureSmoothing" min="0" max="1" step="0.1" value="${this.settings.gestureSmoothing}">
+                            </div>
+                            <div class="setting-item">
+                                <label for="pinchThreshold">Pinch Threshold</label>
+                                <input type="range" id="pinchThreshold" min="0" max="0.05" step="0.001" value="${this.settings.pinchThreshold}">
+                            </div>
+                            <div class="setting-item">
+                                <label for="dragThreshold">Drag Threshold</label>
+                                <input type="range" id="dragThreshold" min="0" max="0.1" step="0.01" value="${this.settings.dragThreshold}">
+                            </div>
+                        </div>
+                    </div>
+
+                    <div class="setting-item">
+                        <label>Haptics</label>
+                        <div class="sub-settings">
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="enableHaptics" ${this.settings.enableHaptics ? 'checked' : ''}>
+                                    Enable Haptics
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label for="hapticIntensity">Haptic Intensity</label>
+                                <input type="range" id="hapticIntensity" min="0" max="1" step="0.1" value="${this.settings.hapticIntensity}">
+                            </div>
+                        </div>
+                    </div>
+
+                    <div class="setting-item">
+                        <label>Room Scale</label>
+                        <div class="sub-settings">
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="roomScale" ${this.settings.roomScale ? 'checked' : ''}>
+                                    Room Scale Mode
+                                </label>
+                            </div>
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="snapToFloor" ${this.settings.snapToFloor ? 'checked' : ''}>
+                                    Snap to Floor
+                                </label>
+                            </div>
+                        </div>
+                    </div>
+
+                    <div class="setting-item">
+                        <label>Passthrough</label>
+                        <div class="sub-settings">
+                            <div class="setting-item">
+                                <label for="passthroughOpacity">Opacity</label>
+                                <input type="range" id="passthroughOpacity" min="0" max="1" step="0.1" value="${this.settings.passthroughOpacity}">
+                            </div>
+                            <div class="setting-item">
+                                <label for="passthroughBrightness">Brightness</label>
+                                <input type="range" id="passthroughBrightness" min="0" max="2" step="0.1" value="${this.settings.passthroughBrightness}">
+                            </div>
+                            <div class="setting-item">
+                                <label for="passthroughContrast">Contrast</label>
+                                <input type="range" id="passthroughContrast" min="0" max="2" step="0.1" value="${this.settings.passthroughContrast}">
+                            </div>
+                            <div class="setting-item">
+                                <label>
+                                    <input type="checkbox" id="enablePassthroughPortal" ${this.settings.enablePassthroughPortal ? 'checked' : ''}>
+                                    Enable Portal
+                                </label>
+                            </div>
+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
+                                <label for="portalSize">Portal Size</label>
+                                <input type="range" id="portalSize" min="0.1" max="2" step="0.1" value="${this.settings.portalSize}">
+                            </div>
+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
+                                <label for="portalEdgeColor">Portal Edge Color</label>
+                                <input type="color" id="portalEdgeColor" value="${this.settings.portalEdgeColor}">
+                            </div>
+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
+                                <label for="portalEdgeWidth">Portal Edge Width</label>
+                                <input type="range" id="portalEdgeWidth" min="0.001" max="0.05" step="0.001" value="${this.settings.portalEdgeWidth}">
+                            </div>
+                        </div>
+                    </div>
+                </div>
+
+                <button class="save-button">Save Changes</button>
+            </div>
+        `;
+
+        document.body.appendChild(this.container);
+    }
+
+    private setupEventListeners(): void {
+        // Toggle panel
+        const toggleButton = this.container.querySelector('.toggle-button');
+        toggleButton?.addEventListener('click', () => {
+            this.isExpanded = !this.isExpanded;
+            this.container.classList.toggle('expanded', this.isExpanded);
+        });
+
+        // Save button
+        const saveButton = this.container.querySelector('.save-button');
+        saveButton?.addEventListener('click', this.saveSettings.bind(this));
+
+        // Node settings
+        this.setupInputListener('nodeSize', 'number');
+        this.setupInputListener('nodeColor', 'string');
+        this.setupInputListener('nodeOpacity', 'number');
+        this.setupInputListener('metalness', 'number');
+        this.setupInputListener('roughness', 'number');
+        this.setupInputListener('clearcoat', 'number');
+
+        // Edge settings
+        this.setupInputListener('edgeWidth', 'number');
+        this.setupInputListener('edgeColor', 'string');
+        this.setupInputListener('edgeOpacity', 'number');
+        
+        const arrowsCheckbox = this.container.querySelector('#enableArrows') as HTMLInputElement;
+        arrowsCheckbox?.addEventListener('change', () => {
+            const arrowSettings = this.container.querySelectorAll('.arrow-setting');
+            arrowSettings.forEach(setting => {
+                setting.classList.toggle('disabled', !arrowsCheckbox.checked);
+            });
+            this.settings.enableArrows = arrowsCheckbox.checked;
+        });
+        this.setupInputListener('arrowSize', 'number');
+
+        // Bloom settings
+        const bloomCheckbox = this.container.querySelector('#enableBloom') as HTMLInputElement;
+        bloomCheckbox?.addEventListener('change', () => {
+            const bloomSettings = this.container.querySelectorAll('.bloom-setting');
+            bloomSettings.forEach(setting => {
+                setting.classList.toggle('disabled', !bloomCheckbox.checked);
+            });
+            this.settings.enableBloom = bloomCheckbox.checked;
+        });
+        this.setupInputListener('bloomIntensity', 'number');
+        this.setupInputListener('bloomRadius', 'number');
+
+        // Animation settings
+        const nodeAnimCheckbox = this.container.querySelector('#enableNodeAnimations') as HTMLInputElement;
+        nodeAnimCheckbox?.addEventListener('change', () => {
+            this.settings.enableNodeAnimations = nodeAnimCheckbox.checked;
+        });
+
+        const motionBlurCheckbox = this.container.querySelector('#enableMotionBlur') as HTMLInputElement;
+        motionBlurCheckbox?.addEventListener('change', () => {
+            const motionSettings = this.container.querySelectorAll('.motion-setting');
+            motionSettings.forEach(setting => {
+                setting.classList.toggle('disabled', !motionBlurCheckbox.checked);
+            });
+            this.settings.enableMotionBlur = motionBlurCheckbox.checked;
+        });
+        this.setupInputListener('motionBlurStrength', 'number');
+
+        // Label settings
+        const labelCheckbox = this.container.querySelector('#showLabels') as HTMLInputElement;
+        labelCheckbox?.addEventListener('change', () => {
+            const labelSettings = this.container.querySelectorAll('.label-setting');
+            labelSettings.forEach(setting => {
+                setting.classList.toggle('disabled', !labelCheckbox.checked);
+            });
+            this.settings.showLabels = labelCheckbox.checked;
+        });
+        this.setupInputListener('labelSize', 'number');
+        this.setupInputListener('labelColor', 'string');
+
+        // Performance settings
+        this.setupInputListener('maxFps', 'number');
+
+        // AR settings
+        const planeDetectionCheckbox = this.container.querySelector('#enablePlaneDetection') as HTMLInputElement;
+        planeDetectionCheckbox?.addEventListener('change', () => {
+            this.settings.enablePlaneDetection = planeDetectionCheckbox.checked;
+        });
+
+        const sceneUnderstandingCheckbox = this.container.querySelector('#enableSceneUnderstanding') as HTMLInputElement;
+        sceneUnderstandingCheckbox?.addEventListener('change', () => {
+            this.settings.enableSceneUnderstanding = sceneUnderstandingCheckbox.checked;
+        });
+
+        const showPlaneOverlayCheckbox = this.container.querySelector('#showPlaneOverlay') as HTMLInputElement;
+        showPlaneOverlayCheckbox?.addEventListener('change', () => {
+            this.settings.showPlaneOverlay = showPlaneOverlayCheckbox.checked;
+        });
+
+        this.setupInputListener('planeOpacity', 'number');
+        this.setupInputListener('planeColor', 'string');
+
+        const lightEstimationCheckbox = this.container.querySelector('#enableLightEstimation') as HTMLInputElement;
+        lightEstimationCheckbox?.addEventListener('change', () => {
+            this.settings.enableLightEstimation = lightEstimationCheckbox.checked;
+        });
+
+        const handTrackingCheckbox = this.container.querySelector('#enableHandTracking') as HTMLInputElement;
+        handTrackingCheckbox?.addEventListener('change', () => {
+            this.settings.enableHandTracking = handTrackingCheckbox.checked;
+        });
+
+        const handMeshEnabledCheckbox = this.container.querySelector('#handMeshEnabled') as HTMLInputElement;
+        handMeshEnabledCheckbox?.addEventListener('change', () => {
+            this.settings.handMeshEnabled = handMeshEnabledCheckbox.checked;
+        });
+
+        this.setupInputListener('handMeshColor', 'string');
+        this.setupInputListener('handMeshOpacity', 'number');
+
+        const handRayEnabledCheckbox = this.container.querySelector('#handRayEnabled') as HTMLInputElement;
+        handRayEnabledCheckbox?.addEventListener('change', () => {
+            this.settings.handRayEnabled = handRayEnabledCheckbox.checked;
+        });
+
+        this.setupInputListener('handRayColor', 'string');
+
+        this.setupInputListener('gestureSmoothing', 'number');
+        this.setupInputListener('pinchThreshold', 'number');
+        this.setupInputListener('dragThreshold', 'number');
+
+        const hapticsCheckbox = this.container.querySelector('#enableHaptics') as HTMLInputElement;
+        hapticsCheckbox?.addEventListener('change', () => {
+            this.settings.enableHaptics = hapticsCheckbox.checked;
+        });
+
+        this.setupInputListener('hapticIntensity', 'number');
+
+        const roomScaleCheckbox = this.container.querySelector('#roomScale') as HTMLInputElement;
+        roomScaleCheckbox?.addEventListener('change', () => {
+            this.settings.roomScale = roomScaleCheckbox.checked;
+        });
+
+        const snapToFloorCheckbox = this.container.querySelector('#snapToFloor') as HTMLInputElement;
+        snapToFloorCheckbox?.addEventListener('change', () => {
+            this.settings.snapToFloor = snapToFloorCheckbox.checked;
+        });
+
+        this.setupInputListener('passthroughOpacity', 'number');
+        this.setupInputListener('passthroughBrightness', 'number');
+        this.setupInputListener('passthroughContrast', 'number');
+
+        const passthroughPortalCheckbox = this.container.querySelector('#enablePassthroughPortal') as HTMLInputElement;
+        passthroughPortalCheckbox?.addEventListener('change', () => {
+            const portalSettings = this.container.querySelectorAll('.portal-setting');
+            portalSettings.forEach(setting => {
+                setting.classList.toggle('disabled', !passthroughPortalCheckbox.checked);
+            });
+            this.settings.enablePassthroughPortal = passthroughPortalCheckbox.checked;
+        });
+
+        this.setupInputListener('portalSize', 'number');
+        this.setupInputListener('portalEdgeColor', 'string');
+        this.setupInputListener('portalEdgeWidth', 'number');
+    }
+
+    private setupInputListener(id: string, type: 'number' | 'string'): void {
+        const input = this.container.querySelector(`#${id}`) as HTMLInputElement;
+        input?.addEventListener('input', () => {
+            const value = type === 'number' ? parseFloat(input.value) : input.value;
+            (this.settings as any)[id] = value;
+        });
+    }
+
+    private async saveSettings(): Promise<void> {
+        try {
+            await settingsManager.updateSettings(this.settings);
+            logger.log('Settings saved successfully');
+        } catch (error) {
+            logger.error('Failed to save settings:', error);
+        }
+    }
+
+    private onSettingsUpdate(newSettings: VisualizationSettings): void {
+        this.settings = { ...newSettings };
+        this.updateUIValues();
+    }
+
+    private updateUIValues(): void {
+        Object.entries(this.settings).forEach(([key, value]) => {
+            const input = this.container.querySelector(`#${key}`) as HTMLInputElement;
+            if (input) {
+                if (input.type === 'checkbox') {
+                    input.checked = value as boolean;
+                } else {
+                    input.value = value.toString();
+                }
+            }
+        });
+    }
+}
diff --git a/client/ui/index.ts b/client/ui/index.ts
new file mode 100644
index 00000000..04ebc6e6
--- /dev/null
+++ b/client/ui/index.ts
@@ -0,0 +1,4 @@
+import { ControlPanel } from './ControlPanel';
+import './ControlPanel.css';
+
+export { ControlPanel };
diff --git a/client/xr/xrInteraction.ts b/client/xr/xrInteraction.ts
index 921924d5..c9b42a1b 100644
--- a/client/xr/xrInteraction.ts
+++ b/client/xr/xrInteraction.ts
@@ -1,384 +1,141 @@
-/**
- * XR interaction handling for controllers and hands
- */
-
 import * as THREE from 'three';
-import { XRSessionManager } from './xrSessionManager';
+import { XRHandWithHaptics } from './xrTypes';
 import { NodeManager } from '../rendering/nodes';
-import { settingsManager } from '../state/settings';
-import { createLogger } from '../core/utils';
-
-// Logger will be used for debugging XR interactions and haptic feedback
-const _logger = createLogger('XRInteraction');
-
-// XR Interaction Action Types
-type XRInteractionActionType = 'select' | 'squeeze';
-
-// Extended XR types
-interface XRHandWithHaptics extends XRHand {
-    vibrate?(intensity: number, duration: number): void;
-}
-
-interface XRSessionWithPose extends XRSession {
-    getPose?(source: XRSpace, referenceSpace: XRReferenceSpace): XRPose | undefined;
-}
-
-interface XRInteractionActionEvent extends THREE.Event {
-    type: `${XRInteractionActionType}start` | `${XRInteractionActionType}end`;
-    data: XRInputSource;
-    hand?: XRHandWithHaptics;
-}
-
-interface XRController extends THREE.Group {
-    userData: {
-        inputSource: XRInputSource;
-    };
-}
-
-interface XRNodeMeshUserData {
-    nodeId: string;
-}
-
-interface XRNodeMesh extends THREE.Object3D {
-    userData: XRNodeMeshUserData;
-}
-
-declare module 'three' {
-    interface Object3DEventMap {
-        selectstart: XRInteractionActionEvent;
-        selectend: XRInteractionActionEvent;
-        squeezestart: XRInteractionActionEvent;
-        squeezeend: XRInteractionActionEvent;
-    }
-}
-
-type XRInteractor = XRController | XRHandWithHaptics;
-
-// Type guard function to check if an object is an XRNodeMesh
-function isXRNodeMesh(obj: THREE.Object3D): obj is XRNodeMesh {
-    return (
-        obj !== null &&
-        typeof obj === 'object' &&
-        'userData' in obj &&
-        obj.userData !== null &&
-        typeof obj.userData === 'object' &&
-        'nodeId' in obj.userData &&
-        typeof obj.userData.nodeId === 'string'
-    );
-}
+import { XRSessionManager } from './xrSessionManager';
+import { VisualizationSettings } from '../core/types';
 
 export class XRInteraction {
-    private static instance: XRInteraction;
+    private static instance: XRInteraction | null = null;
     private xrManager: XRSessionManager;
     private nodeManager: NodeManager;
-
-    // Interaction state
-    private selectedNode: string | null = null;
-    private hoveredNode: string | null = null;
-    private isGrabbing: boolean = false;
-    private lastInteractorPosition: THREE.Vector3;
-    private grabOffset: THREE.Vector3;
-
-    // Raycasting
-    private raycaster: THREE.Raycaster;
-    private tempMatrix: THREE.Matrix4;
-
-    // Hand Tracking
+    private controllers: THREE.Group[] = [];
+    private lastInteractorPosition = new THREE.Vector3();
     private hands: XRHandWithHaptics[] = [];
-    private pinchThreshold: number = 0.025;
+    private settings: VisualizationSettings;
 
     private constructor(xrManager: XRSessionManager, nodeManager: NodeManager) {
         this.xrManager = xrManager;
         this.nodeManager = nodeManager;
-
-        this.lastInteractorPosition = new THREE.Vector3();
-        this.grabOffset = new THREE.Vector3();
-        this.raycaster = new THREE.Raycaster();
-        this.tempMatrix = new THREE.Matrix4();
-        this.setupEventListeners();
-    }
-
-    static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
+        this.settings = {
+            enableHandTracking: true,
+            pinchThreshold: 0.015,
+            dragThreshold: 0.04,
+            enableHaptics: true,
+            hapticIntensity: 0.7
+        } as VisualizationSettings;
+        
+        this.setupXRControllers();
+        this.setupHandTracking();
+    }
+
+    public static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
         if (!XRInteraction.instance) {
             XRInteraction.instance = new XRInteraction(xrManager, nodeManager);
         }
         return XRInteraction.instance;
     }
 
-    private setupEventListeners(): void {
-        const session = this.xrManager.getSession();
-        if (!session) return;
-
-        // Handle controller / hand updates
-        session.addEventListener('inputsourceschange', (event: XRInputSourcesChangeEvent) => {
-            // Clear old event listeners
-            this.xrManager.getControllers().forEach(controller => {
-                controller.removeEventListener('selectstart', this.handleSelectStart);
-                controller.removeEventListener('selectend', this.handleSelectEnd);
-                controller.removeEventListener('squeezestart', this.handleSqueezeStart);
-                controller.removeEventListener('squeezeend', this.handleSqueezeEnd);
-            });
-
-            this.hands = [];
-            event.added.forEach((source: XRInputSource) => {
-                if (source.hand) {
-                    this.hands.push(source.hand as XRHandWithHaptics);
-                }
-            });
-
-            // Setup new input sources
-            this.xrManager.getControllers().forEach((controller) => {
-                controller.addEventListener('selectstart', this.handleSelectStart);
-                controller.addEventListener('selectend', this.handleSelectEnd);
-                controller.addEventListener('squeezestart', this.handleSqueezeStart);
-                controller.addEventListener('squeezeend', this.handleSqueezeEnd);
-            });
+    private setupXRControllers(): void {
+        this.xrManager.onControllerAdded((controller: THREE.Group) => {
+            this.controllers.push(controller);
+            if (controller.userData.hapticActuator) {
+                this.triggerHapticFeedback(controller, 0.5, 50);
+            }
         });
 
-        // Initial Setup
-        this.xrManager.getControllers().forEach((controller) => {
-            controller.addEventListener('selectstart', this.handleSelectStart);
-            controller.addEventListener('selectend', this.handleSelectEnd);
-            controller.addEventListener('squeezestart', this.handleSqueezeStart);
-            controller.addEventListener('squeezeend', this.handleSqueezeEnd);
+        this.xrManager.onControllerRemoved((controller: THREE.Group) => {
+            const index = this.controllers.indexOf(controller);
+            if (index !== -1) {
+                this.controllers.splice(index, 1);
+            }
         });
     }
 
-    private handleSelectStart = (event: THREE.Event) => {
-        if (this.hoveredNode) {
-            const interactionEvent = event as XRInteractionActionEvent;
-            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
-        }
-    }
-
-    private handleSelectEnd = () => {
-        this.endGrab();
-    }
+    private setupHandTracking(): void {
+        if (!this.settings.enableHandTracking) return;
 
-    private handleSqueezeStart = (event: THREE.Event) => {
-        if (this.hoveredNode) {
-            const interactionEvent = event as XRInteractionActionEvent;
-            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
-        }
+        // Hand tracking is handled by the XRSessionManager directly
+        this.hands = [];
     }
 
-    private handleSqueezeEnd = () => {
-        this.endGrab();
-    }
+    public update(): void {
+        if (!this.settings.enableHandTracking) return;
 
-    /**
-     * Update interaction state
-     */
-    update(frame: XRFrame): void {
-        const session = this.xrManager.getSession() as XRSessionWithPose;
-        const referenceSpace = this.xrManager.getReferenceSpace();
-
-        if (!session || !referenceSpace) return;
-
-        // Update controller interaction
-        this.xrManager.getControllers().forEach((baseController) => {
-            const controller = baseController as XRController;
-            const inputSource = controller.userData.inputSource;
-            if (!inputSource) return;
-
-            // Get controller pose
-            const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
-            if (!pose) return;
-
-            // Update raycaster
-            controller.updateMatrixWorld();
-            this.tempMatrix.identity().extractRotation(controller.matrixWorld);
-            this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
-            this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
-
-            // Check for intersections with nodes
-            this.checkNodeIntersections(controller);
-
-            // Update grabbed node position
-            if (this.isGrabbing && this.selectedNode) {
-                this.updateGrabbedNodePosition(controller);
-            }
-
-            // Provide haptic feedback if enabled
-            if (inputSource.gamepad && settingsManager.getSettings().xrControllerVibration) {
-                this.handleHapticFeedback(inputSource.gamepad);
+        // Update hand interactions
+        this.hands.forEach(hand => {
+            if (hand.pinchStrength > this.settings.pinchThreshold) {
+                this.handlePinchGesture(hand);
             }
         });
 
-        // Handle Hand Interactions
-        this.hands.forEach((hand) => {
-            this.checkHandIntersections(hand, frame, referenceSpace);
-
-            if (this.isGrabbing && this.selectedNode) {
-                this.updateGrabbedNodePosition(hand);
-            }
+        // Update controller interactions
+        this.controllers.forEach(controller => {
+            this.handleControllerInteraction(controller);
         });
     }
 
-    private checkHandIntersections(hand: XRHandWithHaptics, frame: XRFrame, referenceSpace: XRReferenceSpace): void {
-        if (!hand || !frame || !referenceSpace) return;
-
-        // Get index and thumb tip
-        const indexTipPose = frame.getPose(hand.get("index-finger-tip") as XRSpace, referenceSpace);
-        const thumbTipPose = frame.getPose(hand.get("thumb-tip") as XRSpace, referenceSpace);
-        if (!indexTipPose || !thumbTipPose) return;
-
-        const indexTipPosition = new THREE.Vector3().fromArray(indexTipPose.transform.matrix.slice(12, 15));
-        const thumbTipPosition = new THREE.Vector3().fromArray(thumbTipPose.transform.matrix.slice(12, 15));
-        const distance = indexTipPosition.distanceTo(thumbTipPosition);
-
-        let closestNode: XRNodeMesh | null = null;
-        let minDistance = Infinity;
-
-        // Get meshes and check each one
-        const meshes = this.nodeManager.getAllNodeMeshes();
-        for (const mesh of meshes) {
-            if (isXRNodeMesh(mesh)) {
-                const nodePosition = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);
-                const nodeDistance = nodePosition.distanceTo(indexTipPosition);
-
-                if (nodeDistance < minDistance) {
-                    minDistance = nodeDistance;
-                    closestNode = mesh;
-                }
-            }
-        }
-
-        if (minDistance < 0.1 && closestNode) {
-            const nodeId = closestNode.userData.nodeId;
-            if (nodeId !== this.hoveredNode) {
-                // Update hover state
-                this.hoveredNode = nodeId;
-                this.nodeManager.highlightNode(nodeId);
-                // Trigger haptic pulse for hover
-                this.pulseHand(hand, 0.2, 50);
-            }
-            if (distance < this.pinchThreshold && !this.isGrabbing) {
-                this.startGrab(nodeId, hand, hand);
-            }
-        } else if (this.hoveredNode) {
-            // Clear hover state
-            this.nodeManager.highlightNode(null);
-            this.hoveredNode = null;
-        }
-    }
-
-    private checkNodeIntersections(controller: XRController): void {
-        // Get closest intersection
-        const meshes = this.nodeManager.getAllNodeMeshes();
-        const intersects = this.raycaster.intersectObjects(meshes);
-
-        if (intersects.length > 0) {
-            const intersectedObject = intersects[0].object;
-            if (isXRNodeMesh(intersectedObject)) {
-                const nodeId = intersectedObject.userData.nodeId;
-                if (nodeId !== this.hoveredNode) {
-                    // Update hover state
-                    this.hoveredNode = nodeId;
-                    this.nodeManager.highlightNode(nodeId);
+    private handlePinchGesture(hand: XRHandWithHaptics): void {
+        const indexTip = hand.hand.joints['index-finger-tip'];
+        if (!indexTip) return;
 
-                    // Trigger haptic pulse for hover
-                    this.pulseController(controller, 0.2, 50);
-                }
-            }
-        } else if (this.hoveredNode) {
-            // Clear hover state
-            this.nodeManager.highlightNode(null);
-            this.hoveredNode = null;
-        }
-    }
+        const position = new THREE.Vector3();
+        position.setFromMatrixPosition(indexTip.matrixWorld);
 
-    private startGrab(nodeId: string, interactor: XRInputSource | XRHandWithHaptics, hand?: XRHandWithHaptics): void {
-        this.selectedNode = nodeId;
-        this.isGrabbing = true;
-
-        // Store initial grab position
-        if (interactor instanceof THREE.Group) {
-            const controller = interactor as unknown as XRController;
-            this.lastInteractorPosition.setFromMatrixPosition(controller.matrixWorld);
-            this.pulseController(controller, 0.7, 100);
-        } else if (hand) {
-            const wrist = hand.get("wrist") as XRSpace;
-            const session = this.xrManager.getSession() as XRSessionWithPose;
-            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
-            if (pose) {
-                this.lastInteractorPosition.fromArray(pose.transform.matrix.slice(12, 15));
+        // Calculate movement delta
+        const delta = position.clone().sub(this.lastInteractorPosition);
+        
+        // Update node positions based on hand movement
+        if (delta.length() > this.settings.dragThreshold) {
+            this.nodeManager.updateNodePositions({
+                x: delta.x,
+                y: delta.y,
+                z: delta.z
+            });
+            if (this.settings.enableHaptics) {
+                this.triggerHapticFeedback(hand, this.settings.hapticIntensity, 50);
             }
-            this.pulseHand(hand, 0.7, 100);
         }
 
-        // Calculate grab offset
-        const nodePosition = this.nodeManager.getNodePosition(nodeId);
-        this.grabOffset.subVectors(nodePosition, this.lastInteractorPosition);
-    }
-
-    private endGrab(): void {
-        if (this.isGrabbing) {
-            this.isGrabbing = false;
-            this.selectedNode = null;
-        }
+        this.lastInteractorPosition.copy(position);
     }
 
-    private updateGrabbedNodePosition(interactor: XRInteractor): void {
-        if (!this.selectedNode) return;
+    private handleControllerInteraction(controller: THREE.Group): void {
+        const position = new THREE.Vector3();
+        position.setFromMatrixPosition(controller.matrixWorld);
 
-        // Get current interactor position
-        const currentPosition = new THREE.Vector3();
-        if (interactor instanceof THREE.Group) {
-            currentPosition.setFromMatrixPosition(interactor.matrixWorld);
-        } else {
-            const wrist = interactor.get("wrist") as XRSpace;
-            const session = this.xrManager.getSession() as XRSessionWithPose;
-            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
-            if (pose) {
-                currentPosition.fromArray(pose.transform.matrix.slice(12, 15));
+        // Calculate movement delta
+        const delta = position.clone().sub(this.lastInteractorPosition);
+        
+        // Update node positions based on controller movement
+        if (delta.length() > this.settings.dragThreshold) {
+            this.nodeManager.updateNodePositions({
+                x: delta.x,
+                y: delta.y,
+                z: delta.z
+            });
+            if (this.settings.enableHaptics && controller.userData.hapticActuator) {
+                this.triggerHapticFeedback(controller, this.settings.hapticIntensity, 50);
             }
         }
 
-        // Calculate new node position
-        const newPosition = currentPosition.clone().add(this.grabOffset);
-        this.nodeManager.updateNodePosition(this.selectedNode, newPosition);
-
-        // Update last position
-        this.lastInteractorPosition.copy(currentPosition);
-    }
-
-    private handleHapticFeedback(__gamepad: Gamepad): void {
-        if (!settingsManager.getSettings().xrControllerVibration) return;
-
-        // Add haptic feedback logic based on interactions
-        // For example, vibrate when near nodes or when grabbing
+        this.lastInteractorPosition.copy(position);
     }
 
-    private pulseController(controller: XRController, intensity: number, duration: number): void {
-        const inputSource = controller.userData.inputSource;
-        if (!inputSource?.gamepad || !settingsManager.getSettings().xrControllerVibration) return;
+    private triggerHapticFeedback(device: THREE.Group | XRHandWithHaptics, intensity: number, duration: number): void {
+        if (!this.settings.enableHaptics) return;
 
-        const actuator = inputSource.gamepad.hapticActuators?.[0] as any;
-        if (actuator) {
-            try {
+        if ('hapticActuators' in device) {
+            device.hapticActuators.forEach(actuator => {
                 actuator.pulse(intensity, duration);
-            } catch (error) {
-                _logger.warn('Haptic feedback not supported:', error);
-            }
-        }
-    }
-
-    private pulseHand(hand: XRHandWithHaptics, intensity: number, duration: number): void {
-        if (!settingsManager.getSettings().xrControllerVibration) return;
-        try {
-            hand.vibrate?.(intensity, duration);
-        } catch (error) {
-            _logger.warn('Haptic feedback not supported for hands:', error);
+            });
+        } else if (device.userData.hapticActuator) {
+            device.userData.hapticActuator.pulse(intensity, duration);
         }
     }
 
-    /**
-     * Clean up resources
-     */
-    dispose(): void {
-        this.endGrab();
-        this.hoveredNode = null;
-        this.selectedNode = null;
+    public dispose(): void {
+        this.controllers = [];
+        this.hands = [];
+        XRInteraction.instance = null;
     }
 }
diff --git a/client/xr/xrSessionManager.ts b/client/xr/xrSessionManager.ts
index 8c17d302..e234201e 100644
--- a/client/xr/xrSessionManager.ts
+++ b/client/xr/xrSessionManager.ts
@@ -46,6 +46,8 @@ export class XRSessionManager {
   private xrSessionStartCallback: (() => void) | null = null;
   private xrSessionEndCallback: (() => void) | null = null;
   private xrAnimationFrameCallback: ((frame: XRFrame) => void) | null = null;
+  private controllerAddedCallback: ((controller: THREE.Group) => void) | null = null;
+  private controllerRemovedCallback: ((controller: THREE.Group) => void) | null = null;
 
   private constructor(sceneManager: SceneManager) {
     this.sceneManager = sceneManager;
@@ -137,42 +139,33 @@ export class XRSessionManager {
     this.arGroup.add(this.arLight);
 
     // Setup controllers
-    this.controllers.forEach((controller, _index) => {
-      this.cameraRig.add(controller);
-      controller.layers.set(1); // Set to AR layer
-      this.setupController(controller);
+    this.controllers.forEach((_controller, index) => {
+      this.setupController(index);
     });
 
     // Setup controller grips
-    this.controllerGrips.forEach((grip, _index) => {
-      this.cameraRig.add(grip);
-      grip.layers.set(1); // Set to AR layer
+    this.controllerGrips.forEach(grip => {
       this.setupControllerGrip(grip);
     });
   }
 
-  private setupController(controller: THREE.Group): void {
-    controller.addEventListener('connected', this.onControllerConnected);
-    controller.addEventListener('disconnected', this.onControllerDisconnected);
-  }
+  private setupController(index: number): void {
+    const controller = this.controllers[index];
+    const controllerGrip = this.controllerGrips[index];
 
-private onControllerConnected = (event: THREE.Event): void => {
-  // Cast the event to XRControllerEvent
-  const xrEvent = event as THREE.XRControllerEvent;
-  // Cast the event target to Object3D first, then to Group
-  const controller = (xrEvent.target as unknown as THREE.Object3D) as THREE.Group;
-  controller.userData.inputSource = xrEvent.data;
+    controller.addEventListener('connected', (event: any) => {
+      const controllerModel = this.buildController(event.data);
+      controller.add(controllerModel);
+      this.notifyControllerAdded(controller);
+    });
 
-  if (xrEvent.data.targetRayMode === 'tracked-pointer') {
-    const pointer = this.createControllerPointer();
-    controller.add(pointer);
-  }
-}
+    controller.addEventListener('disconnected', () => {
+      controller.remove(...controller.children);
+      this.notifyControllerRemoved(controller);
+    });
 
-private onControllerDisconnected = (event: THREE.Event): void => {
-  // Cast the event target to Object3D first, then to Group
-  const controller = (event.target as unknown as THREE.Object3D) as THREE.Group;
-  controller.remove(...controller.children);
+    this.cameraRig.add(controller);
+    this.cameraRig.add(controllerGrip);
   }
 
   private setupControllerGrip(grip: THREE.Group): void {
@@ -180,17 +173,13 @@ private onControllerDisconnected = (event: THREE.Event): void => {
     grip.add(controllerModel);
   }
 
-  private createControllerPointer(): THREE.Mesh {
-    const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08);
-    geometry.rotateX(-Math.PI / 2);
-    const material = new THREE.MeshPhongMaterial({
-      color: 0xffffff,
-      transparent: true,
-      opacity: 0.8
-    });
-    const pointer = new THREE.Mesh(geometry, material);
-    pointer.layers.set(1); // Set to AR layer
-    return pointer;
+  private buildController(_inputSource: XRInputSource): THREE.Group {
+    const controller = new THREE.Group();
+    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
+    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
+    const sphere = new THREE.Mesh(geometry, material);
+    controller.add(sphere);
+    return controller;
   }
 
   /**
@@ -421,6 +410,22 @@ private onControllerDisconnected = (event: THREE.Event): void => {
     this.xrAnimationFrameCallback = onFrame;
   }
 
+  public onControllerAdded(callback: (controller: THREE.Group) => void): void {
+    this.controllerAddedCallback = callback;
+  }
+
+  public onControllerRemoved(callback: (controller: THREE.Group) => void): void {
+    this.controllerRemovedCallback = callback;
+  }
+
+  private notifyControllerAdded(controller: THREE.Group): void {
+    this.controllerAddedCallback?.(controller);
+  }
+
+  private notifyControllerRemoved(controller: THREE.Group): void {
+    this.controllerRemovedCallback?.(controller);
+  }
+
   /**
    * Get XR objects
    */
@@ -461,41 +466,33 @@ private onControllerDisconnected = (event: THREE.Event): void => {
    * Clean up resources
    */
   dispose(): void {
-    if (this.hitTestSource) {
-      this.hitTestSource.cancel();
-    }
-
     if (this.session) {
-      this.session.end();
+      this.session.end().catch(console.error);
     }
 
-    // Remove event listeners
     this.controllers.forEach(controller => {
-      controller.removeEventListener('connected', this.onControllerConnected);
-      controller.removeEventListener('disconnected', this.onControllerDisconnected);
-      controller.remove(...controller.children);
+      controller.removeEventListener('connected', (event: any) => {
+        const controllerModel = this.buildController(event.data);
+        controller.add(controllerModel);
+        this.notifyControllerAdded(controller);
+      });
+
+      controller.removeEventListener('disconnected', () => {
+        controller.remove(...controller.children);
+        this.notifyControllerRemoved(controller);
+      });
     });
 
     this.controllerGrips.forEach(grip => {
       grip.remove(...grip.children);
     });
 
-    // Clean up AR group
-    this.arGroup.remove(...this.arGroup.children);
-    this.cameraRig.remove(this.arGroup);
+    this.hitTestSource?.cancel();
+    this.hitTestSource = null;
+    this.hitTestSourceRequested = false;
 
-    // Clean up camera rig
-    this.cameraRig.remove(...this.cameraRig.children);
-    
-    const scene = this.sceneManager.getScene();
-    scene.remove(this.cameraRig);
-
-    // Dispose geometries and materials
-    this.gridHelper.geometry.dispose();
-    (this.gridHelper.material as THREE.Material).dispose();
-    this.groundPlane.geometry.dispose();
-    (this.groundPlane.material as THREE.Material).dispose();
-    this.hitTestMarker.geometry.dispose();
-    (this.hitTestMarker.material as THREE.Material).dispose();
+    this.session = null;
+    this.referenceSpace = null;
+    this.isPresenting = false;
   }
 }
diff --git a/client/xr/xrTypes.ts b/client/xr/xrTypes.ts
new file mode 100644
index 00000000..556eb0af
--- /dev/null
+++ b/client/xr/xrTypes.ts
@@ -0,0 +1,25 @@
+import * as THREE from 'three';
+
+export interface XRHandWithHaptics {
+    hand: {
+        joints: {
+            [key: string]: THREE.Object3D;
+        };
+    };
+    hapticActuators: any[];
+    pinchStrength: number;
+    gripStrength: number;
+}
+
+export interface XRControllerState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    hapticActuator?: any;
+}
+
+export interface XRHandState {
+    position: THREE.Vector3;
+    joints: Map<string, THREE.Object3D>;
+    pinchStrength: number;
+    gripStrength: number;
+}
diff --git a/settings.md b/settings.md
new file mode 100644
index 00000000..61225f8f
--- /dev/null
+++ b/settings.md
@@ -0,0 +1,590 @@
+take a look at @/client/implementationPlan.md and @/NETWORK_SETUP.md and @/settings.toml and map out in very high detail how the settings are connected to the visual aspects of the client force directed graph.
+
+
+I'll analyze how the settings in settings.toml connect to the visual aspects of the client force directed graph. I'll focus on the key sections that directly impact visualization and map out their relationships.
+
+Let me break this down into the main visual categories and their connections:
+
+Node Appearance & Behavior
+Edge Visualization
+Physics & Layout
+Visual Effects (Bloom, etc.)
+Labels & Text
+Environment & Scene
+
+Task Completed
+Detailed Mapping of Settings to Visual Aspects:
+
+Node Visualization [nodes]
+
+Core Appearance:
+base_size (0.2): Default node sphere size
+base_color ("#FFB700"): Default node color
+geometry_segments (32): Sphere quality/smoothness
+material_type ("physical"): Three.js material type for realistic rendering
+Material Properties:
+metalness (0.85): Reflective quality of nodes
+roughness (0.15): Surface smoothness
+clearcoat (1.0): Additional glossy layer
+opacity (0.92): Node transparency
+Dynamic Sizing:
+size_by_connections (true): Nodes grow based on connection count
+size_range ([0.2, 0.5]): Min/max node sizes
+Color Scheme:
+color_scheme ("age"): Nodes colored by creation date
+new_node_color ("#FFD700"): Recently created nodes
+old_node_color ("#E6A640"): Older nodes
+core_node_color ("#FFC125"): Central/important nodes
+secondary_node_color ("#FFD147"): Supporting nodes
+Interaction Effects:
+enable_hover_effect (true): Visual feedback on mouse hover
+hover_scale (1.15): Size increase on hover
+highlight_color ("#FFFFFF"): Color when selected
+highlight_duration (350): Animation time in ms
+highlight_intensity (3.0): Brightness of highlight
+Edge Visualization [edges]
+
+Basic Properties:
+base_width (2.0): Default edge line thickness
+color ("#FFD700"): Default edge color
+opacity (0.6): Edge transparency
+curve_segments (24): Smoothness of curved edges
+Dynamic Width:
+width_by_strength (true): Edges thicken based on connection strength
+width_range ([2.0, 8.0]): Min/max edge widths
+Directional Indicators:
+enable_arrows (true): Show direction arrows
+arrow_size (0.15): Size of direction indicators
+Glow Effects:
+enable_glow (true): Edge light emission
+glow_color ("#FFD700"): Color of glow effect
+glow_intensity (0.7): Strength of glow
+Physics & Layout [physics]
+
+Force Simulation:
+attraction_strength (0.015): Pull between connected nodes
+repulsion_strength (1500.0): Push between all nodes
+spring_strength (0.018): Edge tension force
+damping (0.88): Movement slowdown factor
+Boundaries:
+bounds_size (12.0): Size of containment area
+enable_bounds (true): Keep nodes within bounds
+collision_radius (0.25): Node collision detection
+max_velocity (2.5): Speed limit for node movement
+Visual Effects
+[bloom]
+
+Glow Effects:
+enabled (true): Overall bloom effect
+strength (1.8): Intensity of glow
+radius (0.5): Spread of glow
+threshold (0.15): Minimum brightness for bloom
+node_bloom_strength (1.8): Node-specific glow
+edge_bloom_strength (1.4): Edge-specific glow
+[animations]
+
+Node Animations:
+enable_node_animations (true): Allow movement animations
+animation_smoothing (0.92): Movement interpolation
+motion_blur_strength (0.4): Movement trail effect
+Edge Effects:
+edge_pulse_enabled (true): Pulsing edge effect
+edge_pulse_color ("#FFD700"): Pulse highlight color
+edge_pulse_frequency (0.5): Pulse speed
+edge_pulse_width (0.2): Thickness of pulse
+Labels & Text [labels]
+
+Text Display:
+enable_labels (true): Show node labels
+desktop_font_size (48): Label text size
+font_family ("Arial"): Text font
+text_color ("#FFFFFF"): Label color
+Label Positioning:
+vertical_offset (2.8): Text height above node
+padding (28): Space around text
+max_visible_labels (75): Performance limit
+Visibility:
+depth_fade_start (7.0): Distance to start fading
+depth_fade_end (25.0): Distance of full fade
+view_angle_fade (0.7): Fade based on viewing angle
+Environment & Scene [rendering]
+
+Lighting:
+ambient_light_intensity (0.7): Overall scene brightness
+directional_light_intensity (1.0): Main light strength
+environment_intensity (1.2): HDR environment lighting
+Scene Quality:
+enable_antialiasing (true): Edge smoothing
+enable_shadows (true): Shadow casting
+shadow_map_size (4096): Shadow quality
+pixel_ratio (1.5): Rendering resolution multiplier
+Atmosphere:
+background_color ("#000000"): Scene background
+fog_enabled (true): Distance fade effect
+fog_color ("#000000"): Fog color
+fog_density (0.0008): Fog thickness
+Reference Grid:
+enable_grid (true): Show ground grid
+grid_color ("#1A1A1A"): Grid line color
+grid_size (10): Grid extent
+grid_divisions (20): Grid line density
+This mapping shows how settings.toml provides fine-grained control over every visual aspect of the force-directed graph, from core rendering properties to subtle animation effects. The settings are structured to allow both high-level control (enabling/disabling features) and detailed customization (specific colors, sizes, and behaviors).
+
+
+trace the flow of the data through the server into json and over the websockets into the client code. Ensure that all critical visualisation aspects are handled
+
+
+I'll trace the data flow from server to client, focusing on visualization aspects. I'll analyze:
+
+Server-side data preparation
+WebSocket protocol and data formats
+Client-side data handling and visualization pipeline
+How settings and real-time updates are managed
+From the implementation plan and network setup docs, I can see this involves multiple layers of data transformation and handling.
+
+
+Task Completed
+Data Flow Trace for Visualization Pipeline:
+
+Server-Side Data Preparation (Rust Backend)
+
+A. Initial Graph Data (/src/handlers/graph_handler.rs)
+
+// Graph data is prepared as two main components:
+struct GraphData {
+    nodes: Vec<Node>,      // Node positions and metadata
+    edges: Vec<Edge>,      // Edge connections and weights
+}
+
+// Each node contains:
+struct Node {
+    position: [f32; 3],    // Vector3 position
+    velocity: [f32; 3],    // Vector3 velocity
+    metadata: NodeMetadata // Labels, colors, etc.
+}
+B. Binary Position Updates
+
+Positions/velocities packed as 24-byte chunks (6 x f32)
+Format: [px, py, pz, vx, vy, vz] per node
+Optimized for GPU consumption via CUDA/WGSL
+WebSocket Protocol (/src/handlers/visualization_handler.rs)
+
+A. Initial Connection
+
+// 1. Settings sent as JSON
+send_json({
+    type: "settings",
+    data: settings_toml_as_json
+});
+
+// 2. Full graph sent as JSON
+send_json({
+    type: "graph",
+    data: {
+        nodes: [...],
+        edges: [...]
+    }
+});
+B. Real-time Updates
+
+// Binary position updates (90Hz from settings.toml)
+send_binary(packed_f32_array);
+
+// Metadata updates as JSON
+send_json({
+    type: "update",
+    data: {
+        nodes: [changed_nodes],
+        edges: [changed_edges]
+    }
+});
+Client-Side Data Pipeline (/client/)
+
+A. WebSocket Service (websocket/websocketService.ts)
+
+class WebSocketService {
+    // Handles binary position data
+    onBinaryMessage(data: ArrayBuffer) {
+        const positions = new Float32Array(data);
+        graphData.updatePositions(positions);
+    }
+    
+    // Handles JSON metadata
+    onJsonMessage(data: any) {
+        switch(data.type) {
+            case "settings":
+                settingsManager.update(data.data);
+                break;
+            case "graph":
+                graphData.setInitialState(data.data);
+                break;
+            case "update":
+                graphData.applyUpdates(data.data);
+                break;
+        }
+    }
+}
+B. Graph Data Management (state/graphData.ts)
+
+class GraphDataManager {
+    private nodes: Map<string, NodeData>;
+    private edges: Map<string, EdgeData>;
+    
+    // Updates node positions from binary data
+    updatePositions(positions: Float32Array) {
+        // Direct GPU buffer update if possible
+        this.nodeBuffer.updateData(positions);
+        // Or update Three.js instances
+        this.updateInstanceMatrices(positions);
+    }
+    
+    // Applies metadata updates
+    applyUpdates(updates: UpdateData) {
+        this.updateNodeVisuals(updates.nodes);
+        this.updateEdgeVisuals(updates.edges);
+    }
+}
+C. Rendering Pipeline (rendering/)
+
+scene.ts:
+
+class SceneManager {
+    private renderer: THREE.WebGLRenderer;
+    private nodeSystem: NodeSystem;
+    private edgeSystem: EdgeSystem;
+    
+    // Main render loop (synced to settings.websocket.update_rate)
+    render() {
+        // Update physics if enabled
+        if (settings.physics.enabled) {
+            this.updatePhysics();
+        }
+        
+        // Update visual elements
+        this.nodeSystem.update();
+        this.edgeSystem.update();
+        
+        // Apply post-processing
+        if (settings.bloom.enabled) {
+            this.applyBloomEffect();
+        }
+        
+        // Handle labels
+        this.updateLabels();
+        
+        // Render frame
+        this.renderer.render(scene, camera);
+    }
+}
+nodes.ts:
+
+class NodeSystem {
+    private geometry: THREE.InstancedBufferGeometry;
+    private material: THREE.MeshPhysicalMaterial;
+    
+    updateNodes() {
+        // Update visual properties from settings
+        this.material.metalness = settings.nodes.metalness;
+        this.material.roughness = settings.nodes.roughness;
+        
+        // Update colors based on scheme
+        this.updateColorScheme(settings.nodes.color_scheme);
+        
+        // Update sizes
+        if (settings.nodes.size_by_connections) {
+            this.updateSizesByConnections();
+        }
+        
+        // Apply animations
+        if (settings.animations.enable_node_animations) {
+            this.animateNodes();
+        }
+    }
+}
+edges.ts:
+
+class EdgeSystem {
+    private geometry: THREE.BufferGeometry;
+    private material: THREE.LineBasicMaterial;
+    
+    updateEdges() {
+        // Update edge visuals from settings
+        this.material.opacity = settings.edges.opacity;
+        
+        // Update widths
+        if (settings.edges.width_by_strength) {
+            this.updateLineWidths();
+        }
+        
+        // Update arrows if enabled
+        if (settings.edges.enable_arrows) {
+            this.updateArrows();
+        }
+        
+        // Apply edge effects
+        if (settings.edges.enable_glow) {
+            this.updateEdgeGlow();
+        }
+    }
+}
+Critical Visualization Aspects Handled:
+
+A. Performance Optimizations
+
+Binary position updates at 90Hz (settings.websocket.update_rate)
+Instanced rendering for nodes
+GPU-accelerated physics when available
+Label count limiting (settings.labels.max_visible_labels)
+B. Visual Quality
+
+Bloom post-processing
+Anti-aliasing
+Shadow mapping
+Proper depth sorting for transparency
+C. Real-time Updates
+
+Smooth position interpolation
+Efficient metadata updates
+Batched visual updates
+Animation system for transitions
+D. Memory Management
+
+Geometry instancing
+Texture atlasing for labels
+Efficient buffer updates
+Proper disposal of Three.js resources
+This trace shows how visualization data flows from the server through WebSocket channels and is processed by various client systems while maintaining high performance and visual quality according to the settings configuration.
+
+
+ok, now examine how the control panel allows writing to the settings toml over the json websocket interface to adapt the look of the system
+
+
+I'll analyze how the control panel interacts with settings.toml through the WebSocket interface. From the implementation plan, I can see this is part of the desktop UI that's being rebuilt. I'll trace:
+
+Control panel structure and settings interface
+WebSocket message protocol for settings updates
+Server-side settings handling
+Real-time visual updates
+
+Task Completed
+Settings Control Flow Analysis:
+
+Desktop Control Panel Implementation (client/ui/settingsPanel.ts)
+class SettingsPanel {
+    private settings: VisualizationSettings;
+    private websocket: WebSocketService;
+    
+    // Groups settings into logical control sections
+    private controlGroups = {
+        nodes: {
+            label: "Node Appearance",
+            controls: [
+                {
+                    id: "nodes.base_size",
+                    type: "slider",
+                    label: "Base Size",
+                    min: 0.1,
+                    max: 1.0,
+                    step: 0.1
+                },
+                {
+                    id: "nodes.base_color",
+                    type: "color",
+                    label: "Base Color"
+                },
+                // ... other node controls
+            ]
+        },
+        edges: {
+            label: "Edge Appearance",
+            controls: [/* edge controls */]
+        },
+        physics: {
+            label: "Physics Settings",
+            controls: [/* physics controls */]
+        },
+        // ... other control groups
+    };
+
+    // Handles control value changes
+    private async handleSettingChange(path: string, value: any) {
+        // Update local settings
+        this.updateSettingByPath(path, value);
+        
+        // Send update to server
+        await this.websocket.send({
+            type: "settings_update",
+            data: {
+                path,
+                value
+            }
+        });
+    }
+
+    // Batch multiple settings changes
+    private async saveAllSettings() {
+        await this.websocket.send({
+            type: "settings_bulk_update",
+            data: this.settings
+        });
+    }
+}
+WebSocket Protocol for Settings Updates
+A. Client to Server Messages:
+
+// Single setting update
+interface SettingsUpdateMessage {
+    type: "settings_update";
+    data: {
+        path: string;    // e.g. "nodes.base_size"
+        value: any;      // New value
+    }
+}
+
+// Bulk settings update
+interface SettingsBulkUpdateMessage {
+    type: "settings_bulk_update";
+    data: VisualizationSettings;
+}
+B. Server to Client Messages:
+
+// Settings confirmation
+interface SettingsConfirmation {
+    type: "settings_updated";
+    data: {
+        success: boolean;
+        error?: string;
+    }
+}
+
+// Broadcast updated settings
+interface SettingsBroadcast {
+    type: "settings_changed";
+    data: VisualizationSettings;
+}
+Server-Side Settings Handler (src/handlers/visualization_handler.rs)
+pub struct VisualizationHandler {
+    settings: Arc<RwLock<Settings>>,
+    clients: Arc<RwLock<HashMap<ClientId, WebSocket>>>,
+}
+
+impl VisualizationHandler {
+    // Handle incoming settings updates
+    async fn handle_settings_update(&self, msg: SettingsUpdate) -> Result<()> {
+        // Update settings.toml
+        {
+            let mut settings = self.settings.write().await;
+            settings.update_path(&msg.path, msg.value)?;
+            settings.save_to_file("settings.toml")?;
+        }
+
+        // Broadcast to all clients
+        self.broadcast_settings().await?;
+        
+        Ok(())
+    }
+
+    // Handle bulk settings updates
+    async fn handle_bulk_settings_update(&self, settings: Settings) -> Result<()> {
+        // Validate settings
+        settings.validate()?;
+
+        // Update settings.toml
+        {
+            let mut current = self.settings.write().await;
+            *current = settings;
+            current.save_to_file("settings.toml")?;
+        }
+
+        // Broadcast to all clients
+        self.broadcast_settings().await?;
+        
+        Ok(())
+    }
+
+    // Broadcast settings to all clients
+    async fn broadcast_settings(&self) -> Result<()> {
+        let settings = self.settings.read().await;
+        let msg = json!({
+            "type": "settings_changed",
+            "data": settings.to_json()
+        });
+
+        for client in self.clients.read().await.values() {
+            client.send(msg.clone()).await?;
+        }
+        
+        Ok(())
+    }
+}
+Real-Time Visual Updates (client/state/settings.ts)
+class SettingsManager {
+    private settings: VisualizationSettings;
+    private subscribers: Map<string, (value: any) => void>;
+
+    // Handle incoming settings updates
+    handleSettingsChanged(newSettings: VisualizationSettings) {
+        this.settings = newSettings;
+        this.notifySubscribers();
+    }
+
+    // Subscribe to settings changes
+    subscribe(path: string, callback: (value: any) => void) {
+        this.subscribers.set(path, callback);
+    }
+
+    // Notify all subscribers of changes
+    private notifySubscribers() {
+        for (const [path, callback] of this.subscribers) {
+            const value = this.getSettingByPath(path);
+            callback(value);
+        }
+    }
+}
+
+// Example subscribers in visualization systems
+class NodeSystem {
+    constructor(settingsManager: SettingsManager) {
+        // Subscribe to relevant settings
+        settingsManager.subscribe("nodes.base_size", this.updateNodeSize);
+        settingsManager.subscribe("nodes.base_color", this.updateNodeColor);
+        settingsManager.subscribe("nodes.material_type", this.updateMaterial);
+    }
+
+    private updateNodeSize = (size: number) => {
+        this.geometry.scale.setScalar(size);
+        this.geometry.instanceMatrix.needsUpdate = true;
+    };
+
+    private updateNodeColor = (color: string) => {
+        this.material.color.set(color);
+        this.material.needsUpdate = true;
+    };
+
+    private updateMaterial = (type: string) => {
+        this.recreateMaterial(type);
+    };
+}
+Settings Update Flow:
+sequenceDiagram
+    participant CP as Control Panel
+    participant WS as WebSocket Service
+    participant SRV as Server
+    participant TOML as settings.toml
+    participant VIS as Visualization
+
+    CP->>WS: settings_update
+    WS->>SRV: Send update message
+    SRV->>TOML: Write new settings
+    SRV->>WS: Broadcast settings_changed
+    WS->>VIS: Update visualization
+    VIS->>CP: Reflect changes in UI
+This system ensures:
+
+Real-time visual updates when settings change
+Persistence of settings in settings.toml
+Synchronization across all connected clients
+Type-safe settings updates with validation
+Efficient batching of multiple settings changes
+Immediate visual feedback in the control panel
+The control panel provides a user-friendly interface to modify settings while maintaining the integrity of the settings.toml file and ensuring all clients stay synchronized with the latest visualization parameters.
\ No newline at end of file
