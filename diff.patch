diff --git a/.DS_Store b/.DS_Store
new file mode 100755
index 00000000..4db94312
Binary files /dev/null and b/.DS_Store differ
diff --git a/.cargo/audit.toml b/.cargo/audit.toml
new file mode 100644
index 00000000..58b85856
--- /dev/null
+++ b/.cargo/audit.toml
@@ -0,0 +1,19 @@
+# This file allows us to acknowledge vulnerabilities in transitive dependencies
+# that are difficult to upgrade without breaking changes
+
+[advisories]
+# Ignore the following advisories:
+# RUSTSEC-2024-0421: 'idna' accepts Punycode labels that do not produce any non-ASCII when decoded
+#   - This is a transitive dependency through nostr-sdk. Unable to upgrade without breaking changes.
+# RUSTSEC-2025-0012: backoff is unmaintained
+#   - Required by async-openai and our code doesn't use it directly. No viable alternatives.
+# RUSTSEC-2024-0384: instant is unmaintained but required by multiple dependencies
+# RUSTSEC-2024-0436: paste is unmaintained but required by simba/nalgebra
+# RUSTSEC-2024-0320: yaml-rust is unmaintained but required by config
+ignore = [
+    "RUSTSEC-2024-0421",
+    "RUSTSEC-2025-0012",
+    "RUSTSEC-2024-0384",
+    "RUSTSEC-2024-0436",
+    "RUSTSEC-2024-0320"
+]
\ No newline at end of file
diff --git a/.dockerignore b/.dockerignore
new file mode 100755
index 00000000..c6481f06
--- /dev/null
+++ b/.dockerignore
@@ -0,0 +1,30 @@
+# Git
+.git
+.gitignore
+.pmpm-store
+
+# Rust
+target/
+
+# Node.js
+node_modules/
+npm-debug.log
+
+# IDEs and editors
+.vscode/
+.idea/
+*.swp
+*.swo
+
+# OS generated files
+.DS_Store
+Thumbs.db
+
+# Test files
+tests/
+
+# Environment variables
+.env
+
+# Cloudflared
+config.yml
\ No newline at end of file
diff --git a/.env_template b/.env_template
new file mode 100755
index 00000000..2deb6750
--- /dev/null
+++ b/.env_template
@@ -0,0 +1,62 @@
+# Environment Configuration
+
+# Server Configuration
+RUST_LOG=info                        # Log level (debug, info, warn, error)
+BIND_ADDRESS=0.0.0.0                 # Server bind address
+DEBUG_MODE=true                     # When true, only processes Debug Test Page.md
+
+# CUDA Configuration
+CUDA_ARCH=86                         # GPU Architecture (89 for Ada/A6000)
+
+# Cloudflare Tunnel Configuration
+TUNNEL_TOKEN=
+TUNNEL_ID=
+
+# Network Configuration
+DOMAIN=www.visionflow.info          # Production domain
+
+# GitHub Configuration
+GITHUB_TOKEN=
+GITHUB_OWNER=
+GITHUB_REPO=
+GITHUB_PATH=/pages
+GITHUB_VERSION=
+GITHUB_RATE_LIMIT=
+
+# RAGFlow Configuration
+RAGFLOW_API_KEY=
+RAGFLOW_API_BASE_URL=http://ragflowe-server/v1/
+RAGFLOW_TIMEOUT=30
+RAGFLOW_MAX_RETRIES=3
+
+# Perplexity API Configuration
+PERPLEXITY_API_KEY=
+PERPLEXITY_MODEL=llama-3.1-sonar-small-128k-online
+PERPLEXITY_API_URL=https://api.perplexity.ai/chat/completions
+PERPLEXITY_MAX_TOKENS=4096
+PERPLEXITY_TEMPERATURE=0.5
+PERPLEXITY_TOP_P=0.9
+PERPLEXITY_PRESENCE_PENALTY=0.0
+PERPLEXITY_FREQUENCY_PENALTY=1.0
+PERPLEXITY_TIMEOUT=30
+PERPLEXITY_RATE_LIMIT=100
+
+# OpenAI Configuration
+OPENAI_API_KEY=
+OPENAI_BASE_URL=wss://api.openai.com/v1/realtime
+OPENAI_TIMEOUT=30
+OPENAI_RATE_LIMIT=100
+
+# Authentication Configuration
+# Base access control - comma-separated list of Nostr public keys
+APPROVED_PUBKEYS=                    # Public keys with basic access to the system
+
+# Role-based access control
+POWER_USER_PUBKEYS=                  # Public keys with power user privileges (can modify server settings)
+SETTINGS_SYNC_ENABLED_PUBKEYS=       # Public keys allowed to sync settings (power users automatically have this)
+
+# Feature-specific access control
+PERPLEXITY_ENABLED_PUBKEYS=         # Public keys with access to Perplexity API features
+OPENAI_ENABLED_PUBKEYS=             # Public keys with access to OpenAI features
+RAGFLOW_ENABLED_PUBKEYS=            # Public keys with access to RAGFlow features
+
diff --git a/.eslintrc.json b/.eslintrc.json
new file mode 100644
index 00000000..ad959c06
--- /dev/null
+++ b/.eslintrc.json
@@ -0,0 +1,29 @@
+{
+  "root": true,
+  "env": {
+    "browser": true,
+    "es2021": true,
+    "node": true,
+    "worker": true
+  },
+  "extends": [
+    "eslint:recommended",
+    "plugin:@typescript-eslint/recommended"
+  ],
+  "rules": {
+    "no-console": ["error", {
+      "allow": ["info", "warn", "error", "debug"]
+    }],
+    "@typescript-eslint/no-explicit-any": "warn",
+    "@typescript-eslint/explicit-function-return-type": "off",
+    "@typescript-eslint/no-unused-vars": ["warn", {
+      "argsIgnorePattern": "^_",
+      "varsIgnorePattern": "^_"
+    }]
+  },
+  "ignorePatterns": [
+    "dist",
+    "node_modules",
+    "*.js"
+  ]
+}
diff --git a/.gitignore b/.gitignore
new file mode 100755
index 00000000..ec1c60c3
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,118 @@
+# Logs
+logs
+*.log
+npm-debug.log*
+yarn-debug.log*
+yarn-error.log*
+pnpm-debug.log*
+lerna-debug.log*
+debug_log.txt
+
+# Dependencies
+node_modules
+.pnpm-store/
+.npm
+.yarn
+/featureclient/
+
+# Build output
+dist
+dist-ssr
+*.local
+build
+out
+/codebase.txt
+
+# Data directories
+data/markdown/
+data/runtime/
+data/public/dist/
+data/metadata/metadata.json
+data/metadata/layout.json
+data/metadata/graph.json
+
+# Documentation and assets
+docs/*.gif
+docs/*.png
+*.mp4
+*.webm
+*.mov
+*.wav
+*.mp3
+*.glb
+*.gltf
+*.hdr
+*.exr
+
+# Editor directories and files
+.vscode/*
+!.vscode/extensions.json
+!.vscode/settings.json
+.idea
+*.suo
+*.ntvs*
+*.njsproj
+*.sln
+*.sw?
+.DS_Store
+*.pem
+
+# Environment and configuration
+.env
+.env.*
+!.env.example
+!.env_template
+settings.local.toml
+certs
+
+# TypeScript
+*.tsbuildinfo
+auto-imports.d.ts
+components.d.ts
+
+# Testing and coverage
+coverage
+.nyc_output
+
+# Cache and temporary
+.cache
+.temp
+.eslintcache
+.stylelintcache
+*.tmp
+*.temp
+.tmp
+.temp
+
+# Rust/Cargo
+target/
+**/*.rs.bk
+Cargo.lock
+
+# Platform and deployment
+.vercel
+.netlify
+.cloudflare
+
+# Debug and profiling
+chrome-profiler-events*.json
+speed-measure-plugin*.json
+
+# Generated files
+generated
+optimized-output.gif
+
+# Docker
+.docker/
+docker-compose.override.yml
+
+# AI and tools
+.aider*
+.hypothesis/
+__pycache__/
+*.pyc
+
+# Project specific
+scripts/local/
+client/visualization/effects/custom/
+.qodo
diff --git a/.prettierrc b/.prettierrc
new file mode 100644
index 00000000..9cd4d463
--- /dev/null
+++ b/.prettierrc
@@ -0,0 +1,18 @@
+{
+  "semi": true,
+  "tabWidth": 2,
+  "printWidth": 100,
+  "singleQuote": true,
+  "trailingComma": "es5",
+  "bracketSpacing": true,
+  "arrowParens": "avoid",
+  "endOfLine": "lf",
+  "overrides": [
+    {
+      "files": "*.ts",
+      "options": {
+        "parser": "typescript"
+      }
+    }
+  ]
+}
diff --git a/Cargo.lock b/Cargo.lock
new file mode 100644
index 00000000..fc3debc9
--- /dev/null
+++ b/Cargo.lock
@@ -0,0 +1,4038 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "actix"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cba56612922b907719d4a01cf11c8d5b458e7d3dba946d0435f20f58d6795ed2"
+dependencies = [
+ "actix-macros",
+ "actix-rt",
+ "actix_derive",
+ "bitflags 2.9.0",
+ "bytes",
+ "crossbeam-channel",
+ "futures-core",
+ "futures-sink",
+ "futures-task",
+ "futures-util",
+ "log",
+ "once_cell",
+ "parking_lot",
+ "pin-project-lite",
+ "smallvec",
+ "tokio",
+ "tokio-util",
+]
+
+[[package]]
+name = "actix-codec"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f7b0a21988c1bf877cf4759ef5ddaac04c1c9fe808c9142ecb78ba97d97a28a"
+dependencies = [
+ "bitflags 2.9.0",
+ "bytes",
+ "futures-core",
+ "futures-sink",
+ "memchr",
+ "pin-project-lite",
+ "tokio",
+ "tokio-util",
+ "tracing",
+]
+
+[[package]]
+name = "actix-cors"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f9e772b3bcafe335042b5db010ab7c09013dad6eac4915c91d8d50902769f331"
+dependencies = [
+ "actix-utils",
+ "actix-web",
+ "derive_more 0.99.19",
+ "futures-util",
+ "log",
+ "once_cell",
+ "smallvec",
+]
+
+[[package]]
+name = "actix-files"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf0bdd6ff79de7c9a021f5d9ea79ce23e108d8bfc9b49b5b4a2cf6fad5a35212"
+dependencies = [
+ "actix-http",
+ "actix-service",
+ "actix-utils",
+ "actix-web",
+ "bitflags 2.9.0",
+ "bytes",
+ "derive_more 0.99.19",
+ "futures-core",
+ "http-range",
+ "log",
+ "mime",
+ "mime_guess",
+ "percent-encoding",
+ "pin-project-lite",
+ "v_htmlescape",
+]
+
+[[package]]
+name = "actix-http"
+version = "3.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fa882656b67966045e4152c634051e70346939fced7117d5f0b52146a7c74c9"
+dependencies = [
+ "actix-codec",
+ "actix-rt",
+ "actix-service",
+ "actix-utils",
+ "base64 0.22.1",
+ "bitflags 2.9.0",
+ "brotli",
+ "bytes",
+ "bytestring",
+ "derive_more 2.0.1",
+ "encoding_rs",
+ "flate2",
+ "foldhash",
+ "futures-core",
+ "h2",
+ "http 0.2.12",
+ "httparse",
+ "httpdate",
+ "itoa",
+ "language-tags",
+ "local-channel",
+ "mime",
+ "percent-encoding",
+ "pin-project-lite",
+ "rand 0.9.0",
+ "sha1",
+ "smallvec",
+ "tokio",
+ "tokio-util",
+ "tracing",
+ "zstd",
+]
+
+[[package]]
+name = "actix-macros"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e01ed3140b2f8d422c68afa1ed2e85d996ea619c988ac834d255db32138655cb"
+dependencies = [
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "actix-router"
+version = "0.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13d324164c51f63867b57e73ba5936ea151b8a41a1d23d1031eeb9f70d0236f8"
+dependencies = [
+ "bytestring",
+ "cfg-if",
+ "http 0.2.12",
+ "regex",
+ "regex-lite",
+ "serde",
+ "tracing",
+]
+
+[[package]]
+name = "actix-rt"
+version = "2.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24eda4e2a6e042aa4e55ac438a2ae052d3b5da0ecf83d7411e1a368946925208"
+dependencies = [
+ "futures-core",
+ "tokio",
+]
+
+[[package]]
+name = "actix-server"
+version = "2.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6398974fd4284f4768af07965701efbbb5fdc0616bff20cade1bb14b77675e24"
+dependencies = [
+ "actix-rt",
+ "actix-service",
+ "actix-utils",
+ "futures-core",
+ "futures-util",
+ "mio",
+ "socket2",
+ "tokio",
+ "tracing",
+]
+
+[[package]]
+name = "actix-service"
+version = "2.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e46f36bf0e5af44bdc4bdb36fbbd421aa98c79a9bce724e1edeb3894e10dc7f"
+dependencies = [
+ "futures-core",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "actix-utils"
+version = "3.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88a1dcdff1466e3c2488e1cb5c36a71822750ad43839937f85d2f4d9f8b705d8"
+dependencies = [
+ "local-waker",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "actix-web"
+version = "4.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43a6556ddebb638c2358714d853257ed226ece6023ef9364f23f0c70737ea984"
+dependencies = [
+ "actix-codec",
+ "actix-http",
+ "actix-macros",
+ "actix-router",
+ "actix-rt",
+ "actix-server",
+ "actix-service",
+ "actix-utils",
+ "actix-web-codegen",
+ "ahash 0.8.11",
+ "bytes",
+ "bytestring",
+ "cfg-if",
+ "cookie",
+ "derive_more 0.99.19",
+ "encoding_rs",
+ "futures-core",
+ "futures-util",
+ "itoa",
+ "language-tags",
+ "log",
+ "mime",
+ "once_cell",
+ "pin-project-lite",
+ "regex",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "smallvec",
+ "socket2",
+ "time",
+ "url",
+]
+
+[[package]]
+name = "actix-web-actors"
+version = "4.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "420b001bb709d8510c3e2659dae046e54509ff9528018d09c78381e765a1f9fa"
+dependencies = [
+ "actix",
+ "actix-codec",
+ "actix-http",
+ "actix-web",
+ "bytes",
+ "bytestring",
+ "futures-core",
+ "pin-project-lite",
+ "tokio",
+ "tokio-util",
+]
+
+[[package]]
+name = "actix-web-codegen"
+version = "4.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f591380e2e68490b5dfaf1dd1aa0ebe78d84ba7067078512b4ea6e4492d622b8"
+dependencies = [
+ "actix-router",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "actix_derive"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6ac1e58cded18cb28ddc17143c4dea5345b3ad575e14f32f66e4054a56eb271"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "addr2line"
+version = "0.24.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
+dependencies = [
+ "gimli",
+]
+
+[[package]]
+name = "adler2"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"
+
+[[package]]
+name = "aes"
+version = "0.8.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b169f7a6d4742236a0a00c541b845991d0ac43e546831af1249753ab4c3aa3a0"
+dependencies = [
+ "cfg-if",
+ "cipher",
+ "cpufeatures",
+]
+
+[[package]]
+name = "ahash"
+version = "0.7.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9"
+dependencies = [
+ "getrandom 0.2.15",
+ "once_cell",
+ "version_check",
+]
+
+[[package]]
+name = "ahash"
+version = "0.8.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
+dependencies = [
+ "cfg-if",
+ "getrandom 0.2.15",
+ "once_cell",
+ "version_check",
+ "zerocopy 0.7.35",
+]
+
+[[package]]
+name = "aho-corasick"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "alloc-no-stdlib"
+version = "2.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc7bb162ec39d46ab1ca8c77bf72e890535becd1751bb45f64c597edb4c8c6b3"
+
+[[package]]
+name = "alloc-stdlib"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
+dependencies = [
+ "alloc-no-stdlib",
+]
+
+[[package]]
+name = "android-tzdata"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
+
+[[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "anyhow"
+version = "1.0.97"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dcfed56ad506cb2c684a14971b8861fdc3baaaae314b9e5f9bb532cbe3ba7a4f"
+
+[[package]]
+name = "approx"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cab112f0a86d568ea0e627cc1d6be74a1e9cd55214684db5561995f6dad897c6"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "async-convert"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d416feee97712e43152cd42874de162b8f9b77295b1c85e5d92725cc8310bae"
+dependencies = [
+ "async-trait",
+]
+
+[[package]]
+name = "async-openai"
+version = "0.14.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7e1df052c2bd7b241fc828bc2fda74ce9a7ef05e0a593c37275aaaba52caf49d"
+dependencies = [
+ "async-convert",
+ "backoff",
+ "base64 0.21.7",
+ "derive_builder",
+ "futures",
+ "rand 0.8.5",
+ "reqwest",
+ "reqwest-eventsource",
+ "serde",
+ "serde_json",
+ "thiserror 1.0.69",
+ "tokio",
+ "tokio-stream",
+ "tokio-util",
+ "tracing",
+]
+
+[[package]]
+name = "async-stream"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b5a71a6f37880a80d1d7f19efd781e4b5de42c88f0722cc13bcb6cc2cfe8476"
+dependencies = [
+ "async-stream-impl",
+ "futures-core",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "async-stream-impl"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c7c24de15d275a1ecfd47a380fb4d5ec9bfe0933f309ed5e705b775596a3574d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "async-trait"
+version = "0.1.87"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d556ec1359574147ec0c4fc5eb525f3f23263a592b1a9c07e0a75b427de55c97"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "async-utility"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3716c0d3970fe92d79a8f4cda2caf91113574505dff5b18e455e549d4b078e98"
+dependencies = [
+ "futures-util",
+ "gloo-timers",
+ "tokio",
+ "wasm-bindgen-futures",
+]
+
+[[package]]
+name = "async_io_stream"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6d7b9decdf35d8908a7e3ef02f64c5e9b1695e230154c0e8de3969142d9b94c"
+dependencies = [
+ "futures",
+ "pharos",
+ "rustc_version",
+]
+
+[[package]]
+name = "autocfg"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
+
+[[package]]
+name = "backoff"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b62ddb9cb1ec0a098ad4bbf9344d0713fa193ae1a80af55febcff2627b6a00c1"
+dependencies = [
+ "futures-core",
+ "getrandom 0.2.15",
+ "instant",
+ "pin-project-lite",
+ "rand 0.8.5",
+ "tokio",
+]
+
+[[package]]
+name = "backtrace"
+version = "0.3.74"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a"
+dependencies = [
+ "addr2line",
+ "cfg-if",
+ "libc",
+ "miniz_oxide",
+ "object",
+ "rustc-demangle",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "base64"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"
+
+[[package]]
+name = "base64"
+version = "0.21.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
+
+[[package]]
+name = "base64"
+version = "0.22.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"
+
+[[package]]
+name = "bech32"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d86b93f97252c47b41663388e6d155714a9d0c398b99f1005cbc5f978b29f445"
+
+[[package]]
+name = "bip39"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33415e24172c1b7d6066f6d999545375ab8e1d95421d6784bdfff9496f292387"
+dependencies = [
+ "bitcoin_hashes 0.13.0",
+ "serde",
+ "unicode-normalization",
+]
+
+[[package]]
+name = "bitcoin"
+version = "0.30.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1945a5048598e4189e239d3f809b19bdad4845c4b2ba400d304d2dcf26d2c462"
+dependencies = [
+ "bech32",
+ "bitcoin-private",
+ "bitcoin_hashes 0.12.0",
+ "hex_lit",
+ "secp256k1",
+ "serde",
+]
+
+[[package]]
+name = "bitcoin-internals"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9425c3bf7089c983facbae04de54513cce73b41c7f9ff8c845b54e7bc64ebbfb"
+
+[[package]]
+name = "bitcoin-private"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "73290177011694f38ec25e165d0387ab7ea749a4b81cd4c80dae5988229f7a57"
+
+[[package]]
+name = "bitcoin_hashes"
+version = "0.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5d7066118b13d4b20b23645932dfb3a81ce7e29f95726c2036fa33cd7b092501"
+dependencies = [
+ "bitcoin-private",
+ "serde",
+]
+
+[[package]]
+name = "bitcoin_hashes"
+version = "0.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1930a4dabfebb8d7d9992db18ebe3ae2876f0a305fab206fd168df931ede293b"
+dependencies = [
+ "bitcoin-internals",
+ "hex-conservative",
+]
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
+[[package]]
+name = "bitflags"
+version = "2.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c8214115b7bf84099f1309324e63141d4c5d7cc26862f97a0a857dbefe165bd"
+
+[[package]]
+name = "block-buffer"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
+name = "block-padding"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8894febbff9f758034a5b8e12d87918f56dfc64a8e1fe757d65e29041538d93"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
+name = "brotli"
+version = "7.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc97b8f16f944bba54f0433f07e30be199b6dc2bd25937444bbad560bcea29bd"
+dependencies = [
+ "alloc-no-stdlib",
+ "alloc-stdlib",
+ "brotli-decompressor",
+]
+
+[[package]]
+name = "brotli-decompressor"
+version = "4.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74fa05ad7d803d413eb8380983b092cbbaf9a85f151b871360e7b00cd7060b37"
+dependencies = [
+ "alloc-no-stdlib",
+ "alloc-stdlib",
+]
+
+[[package]]
+name = "bumpalo"
+version = "3.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf"
+
+[[package]]
+name = "bytemuck"
+version = "1.22.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6b1fc10dbac614ebc03540c9dbd60e83887fda27794998c6528f1782047d540"
+dependencies = [
+ "bytemuck_derive",
+]
+
+[[package]]
+name = "bytemuck_derive"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3fa76293b4f7bb636ab88fd78228235b5248b4d05cc589aed610f954af5d7c7a"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "byteorder"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"
+
+[[package]]
+name = "bytes"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"
+
+[[package]]
+name = "bytestring"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e465647ae23b2823b0753f50decb2d5a86d2bb2cac04788fafd1f80e45378e5f"
+dependencies = [
+ "bytes",
+]
+
+[[package]]
+name = "cbc"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26b52a9543ae338f279b96b0b9fed9c8093744685043739079ce85cd58f289a6"
+dependencies = [
+ "cipher",
+]
+
+[[package]]
+name = "cc"
+version = "1.2.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "be714c154be609ec7f5dad223a33bf1482fff90472de28f7362806e6d4832b8c"
+dependencies = [
+ "jobserver",
+ "libc",
+ "shlex",
+]
+
+[[package]]
+name = "cfg-if"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+
+[[package]]
+name = "chacha20"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c3613f74bd2eac03dad61bd53dbe620703d4371614fe0bc3b9f04dd36fe4e818"
+dependencies = [
+ "cfg-if",
+ "cipher",
+ "cpufeatures",
+]
+
+[[package]]
+name = "chrono"
+version = "0.4.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a7964611d71df112cb1730f2ee67324fcf4d0fc6606acbbe9bfe06df124637c"
+dependencies = [
+ "android-tzdata",
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "serde",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
+name = "cipher"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
+dependencies = [
+ "crypto-common",
+ "inout",
+]
+
+[[package]]
+name = "config"
+version = "0.13.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23738e11972c7643e4ec947840fc463b6a571afcd3e735bdfce7d03c7a784aca"
+dependencies = [
+ "async-trait",
+ "json5",
+ "lazy_static",
+ "nom",
+ "pathdiff",
+ "ron",
+ "rust-ini",
+ "serde",
+ "serde_json",
+ "toml 0.5.11",
+ "yaml-rust",
+]
+
+[[package]]
+name = "convert_case"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"
+
+[[package]]
+name = "cookie"
+version = "0.16.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e859cd57d0710d9e06c381b550c06e76992472a8c6d527aecd2fc673dcc231fb"
+dependencies = [
+ "percent-encoding",
+ "time",
+ "version_check",
+]
+
+[[package]]
+name = "core-foundation"
+version = "0.9.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
+name = "cpufeatures"
+version = "0.2.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "crc32fast"
+version = "1.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "crossbeam-channel"
+version = "0.5.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06ba6d68e24814cb8de6bb986db8222d3a027d15872cabc0d18817bc3c0e4471"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-deque"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
+dependencies = [
+ "crossbeam-epoch",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-epoch"
+version = "0.9.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-utils"
+version = "0.8.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"
+
+[[package]]
+name = "crypto-common"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
+dependencies = [
+ "generic-array",
+ "typenum",
+]
+
+[[package]]
+name = "cudarc"
+version = "0.11.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a5bd4d1eee570c3b2ac64ed114125517dd1e541d88dd28fc259f1de4dba8d60"
+dependencies = [
+ "libloading",
+]
+
+[[package]]
+name = "darling"
+version = "0.14.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b750cb3417fd1b327431a470f388520309479ab0bf5e323505daf0290cd3850"
+dependencies = [
+ "darling_core",
+ "darling_macro",
+]
+
+[[package]]
+name = "darling_core"
+version = "0.14.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "109c1ca6e6b7f82cc233a97004ea8ed7ca123a9af07a8230878fcfda9b158bf0"
+dependencies = [
+ "fnv",
+ "ident_case",
+ "proc-macro2",
+ "quote",
+ "strsim",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "darling_macro"
+version = "0.14.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4aab4dbc9f7611d8b55048a3a16d2d010c2c8334e46304b40ac1cc14bf3b48e"
+dependencies = [
+ "darling_core",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "data-encoding"
+version = "2.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "575f75dfd25738df5b91b8e43e14d44bda14637a58fae779fd2b064f8bf3e010"
+
+[[package]]
+name = "deranged"
+version = "0.3.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b42b6fa04a440b495c8b04d0e71b707c585f83cb9cb28cf8cd0d976c315e31b4"
+dependencies = [
+ "powerfmt",
+]
+
+[[package]]
+name = "derive_builder"
+version = "0.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8d67778784b508018359cbc8696edb3db78160bab2c2a28ba7f56ef6932997f8"
+dependencies = [
+ "derive_builder_macro",
+]
+
+[[package]]
+name = "derive_builder_core"
+version = "0.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c11bdc11a0c47bc7d37d582b5285da6849c96681023680b906673c5707af7b0f"
+dependencies = [
+ "darling",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "derive_builder_macro"
+version = "0.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ebcda35c7a396850a55ffeac740804b40ffec779b98fffbb1738f4033f0ee79e"
+dependencies = [
+ "derive_builder_core",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "derive_more"
+version = "0.99.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3da29a38df43d6f156149c9b43ded5e018ddff2a855cf2cfd62e8cd7d079c69f"
+dependencies = [
+ "convert_case",
+ "proc-macro2",
+ "quote",
+ "rustc_version",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "derive_more"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "093242cf7570c207c83073cf82f79706fe7b8317e98620a47d5be7c3d8497678"
+dependencies = [
+ "derive_more-impl",
+]
+
+[[package]]
+name = "derive_more-impl"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bda628edc44c4bb645fbe0f758797143e4e07926f7ebf4e9bdfbd3d2ce621df3"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+ "unicode-xid",
+]
+
+[[package]]
+name = "diff"
+version = "0.1.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8"
+
+[[package]]
+name = "difflib"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6184e33543162437515c2e2b48714794e37845ec9851711914eec9d308f6ebe8"
+
+[[package]]
+name = "digest"
+version = "0.10.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
+dependencies = [
+ "block-buffer",
+ "crypto-common",
+]
+
+[[package]]
+name = "displaydoc"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "dlv-list"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0688c2a7f92e427f44895cd63841bff7b29f8d7a1648b9e7e07a4a365b2e1257"
+
+[[package]]
+name = "dotenvy"
+version = "0.15.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1aaf95b3e5c8f23aa320147307562d361db0ae0d51242340f558153b4eb2439b"
+
+[[package]]
+name = "downcast"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1435fa1053d8b2fbbe9be7e97eca7f33d37b28409959813daefc1446a14247f1"
+
+[[package]]
+name = "either"
+version = "1.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
+
+[[package]]
+name = "encoding_rs"
+version = "0.8.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "equivalent"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
+
+[[package]]
+name = "errno"
+version = "0.3.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d"
+dependencies = [
+ "libc",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "eventsource-stream"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74fef4569247a5f429d9156b9d0a2599914385dd189c539334c625d8099d90ab"
+dependencies = [
+ "futures-core",
+ "nom",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "fastrand"
+version = "2.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"
+
+[[package]]
+name = "flate2"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11faaf5a5236997af9848be0bef4db95824b1d534ebc64d0f0c6cf3e67bd38dc"
+dependencies = [
+ "crc32fast",
+ "miniz_oxide",
+]
+
+[[package]]
+name = "float-cmp"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "98de4bbd547a563b716d8dfa9aad1cb19bfab00f4fa09a6a4ed21dbcf44ce9c4"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "fnv"
+version = "1.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
+
+[[package]]
+name = "foldhash"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a0d2fde1f7b3d48b8395d5f2de76c18a528bd6a9cdde438df747bfcba3e05d6f"
+
+[[package]]
+name = "foreign-types"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
+dependencies = [
+ "foreign-types-shared",
+]
+
+[[package]]
+name = "foreign-types-shared"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"
+
+[[package]]
+name = "form_urlencoded"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
+dependencies = [
+ "percent-encoding",
+]
+
+[[package]]
+name = "fragile"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c2141d6d6c8512188a7891b4b01590a45f6dac67afb4f255c4124dbb86d4eaa"
+
+[[package]]
+name = "futures"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
+dependencies = [
+ "futures-channel",
+ "futures-core",
+ "futures-executor",
+ "futures-io",
+ "futures-sink",
+ "futures-task",
+ "futures-util",
+]
+
+[[package]]
+name = "futures-channel"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
+dependencies = [
+ "futures-core",
+ "futures-sink",
+]
+
+[[package]]
+name = "futures-core"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"
+
+[[package]]
+name = "futures-executor"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
+dependencies = [
+ "futures-core",
+ "futures-task",
+ "futures-util",
+]
+
+[[package]]
+name = "futures-io"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"
+
+[[package]]
+name = "futures-macro"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "futures-sink"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"
+
+[[package]]
+name = "futures-task"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"
+
+[[package]]
+name = "futures-timer"
+version = "3.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f288b0a4f20f9a56b5d1da57e2227c661b7b16168e2f72365f57b63326e29b24"
+
+[[package]]
+name = "futures-util"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
+dependencies = [
+ "futures-channel",
+ "futures-core",
+ "futures-io",
+ "futures-macro",
+ "futures-sink",
+ "futures-task",
+ "memchr",
+ "pin-project-lite",
+ "pin-utils",
+ "slab",
+]
+
+[[package]]
+name = "generic-array"
+version = "0.14.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
+dependencies = [
+ "typenum",
+ "version_check",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "libc",
+ "wasi 0.11.0+wasi-snapshot-preview1",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43a49c392881ce6d5c3b8cb70f98717b7c07aabbdff06687b9030dbfbe2725f8"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "wasi 0.13.3+wasi-0.2.2",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "gimli"
+version = "0.31.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"
+
+[[package]]
+name = "glam"
+version = "0.24.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b5418c17512bdf42730f9032c74e1ae39afc408745ebb2acf72fbc4691c17945"
+
+[[package]]
+name = "gloo-timers"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b995a66bb87bebce9a0f4a95aed01daca4872c050bfcb21653361c03bc35e5c"
+dependencies = [
+ "futures-channel",
+ "futures-core",
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "h2"
+version = "0.3.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "81fe527a889e1532da5c525686d96d4c2e74cdd345badf8dfef9f6b39dd5f5e8"
+dependencies = [
+ "bytes",
+ "fnv",
+ "futures-core",
+ "futures-sink",
+ "futures-util",
+ "http 0.2.12",
+ "indexmap",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tracing",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
+dependencies = [
+ "ahash 0.7.8",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.15.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
+
+[[package]]
+name = "hex-conservative"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "212ab92002354b4819390025006c897e8140934349e8635c9b077f47b4dcbd20"
+
+[[package]]
+name = "hex_lit"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3011d1213f159867b13cfd6ac92d2cd5f1345762c63be3554e84092d85a50bbd"
+
+[[package]]
+name = "http"
+version = "0.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
+[[package]]
+name = "http"
+version = "1.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
+[[package]]
+name = "http-body"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
+dependencies = [
+ "bytes",
+ "http 0.2.12",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "http-range"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "21dec9db110f5f872ed9699c3ecf50cf16f423502706ba5c72462e28d3157573"
+
+[[package]]
+name = "httparse"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"
+
+[[package]]
+name = "httpdate"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"
+
+[[package]]
+name = "hyper"
+version = "0.14.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41dfc780fdec9373c01bae43289ea34c972e40ee3c9f6b3c8801a35f35586ce7"
+dependencies = [
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "h2",
+ "http 0.2.12",
+ "http-body",
+ "httparse",
+ "httpdate",
+ "itoa",
+ "pin-project-lite",
+ "socket2",
+ "tokio",
+ "tower-service",
+ "tracing",
+ "want",
+]
+
+[[package]]
+name = "hyper-rustls"
+version = "0.24.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec3efd23720e2049821a693cbc7e65ea87c72f1c58ff2f9522ff332b1491e590"
+dependencies = [
+ "futures-util",
+ "http 0.2.12",
+ "hyper",
+ "rustls",
+ "tokio",
+ "tokio-rustls",
+]
+
+[[package]]
+name = "hyper-tls"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d6183ddfa99b85da61a140bea0efc93fdf56ceaa041b37d553518030827f9905"
+dependencies = [
+ "bytes",
+ "hyper",
+ "native-tls",
+ "tokio",
+ "tokio-native-tls",
+]
+
+[[package]]
+name = "iana-time-zone"
+version = "0.1.61"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "235e081f3925a06703c2d0117ea8b91f042756fd6e7a6e5d901e8ca1a996b220"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "icu_collections"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db2fa452206ebee18c4b5c2274dbf1de17008e874b4dc4f0aea9d01ca79e4526"
+dependencies = [
+ "displaydoc",
+ "yoke",
+ "zerofrom",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locid"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13acbb8371917fc971be86fc8057c41a64b521c184808a698c02acc242dbf637"
+dependencies = [
+ "displaydoc",
+ "litemap",
+ "tinystr",
+ "writeable",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locid_transform"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "01d11ac35de8e40fdeda00d9e1e9d92525f3f9d887cdd7aa81d727596788b54e"
+dependencies = [
+ "displaydoc",
+ "icu_locid",
+ "icu_locid_transform_data",
+ "icu_provider",
+ "tinystr",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locid_transform_data"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fdc8ff3388f852bede6b579ad4e978ab004f139284d7b28715f773507b946f6e"
+
+[[package]]
+name = "icu_normalizer"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19ce3e0da2ec68599d193c93d088142efd7f9c5d6fc9b803774855747dc6a84f"
+dependencies = [
+ "displaydoc",
+ "icu_collections",
+ "icu_normalizer_data",
+ "icu_properties",
+ "icu_provider",
+ "smallvec",
+ "utf16_iter",
+ "utf8_iter",
+ "write16",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_normalizer_data"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f8cafbf7aa791e9b22bec55a167906f9e1215fd475cd22adfcf660e03e989516"
+
+[[package]]
+name = "icu_properties"
+version = "1.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93d6020766cfc6302c15dbbc9c8778c37e62c14427cb7f6e601d849e092aeef5"
+dependencies = [
+ "displaydoc",
+ "icu_collections",
+ "icu_locid_transform",
+ "icu_properties_data",
+ "icu_provider",
+ "tinystr",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_properties_data"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "67a8effbc3dd3e4ba1afa8ad918d5684b8868b3b26500753effea8d2eed19569"
+
+[[package]]
+name = "icu_provider"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ed421c8a8ef78d3e2dbc98a973be2f3770cb42b606e3ab18d6237c4dfde68d9"
+dependencies = [
+ "displaydoc",
+ "icu_locid",
+ "icu_provider_macros",
+ "stable_deref_trait",
+ "tinystr",
+ "writeable",
+ "yoke",
+ "zerofrom",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_provider_macros"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1ec89e9337638ecdc08744df490b221a7399bf8d164eb52a665454e60e075ad6"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "ident_case"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
+
+[[package]]
+name = "idna"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
+dependencies = [
+ "unicode-bidi",
+ "unicode-normalization",
+]
+
+[[package]]
+name = "idna"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
+dependencies = [
+ "idna_adapter",
+ "smallvec",
+ "utf8_iter",
+]
+
+[[package]]
+name = "idna_adapter"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "daca1df1c957320b2cf139ac61e7bd64fed304c5040df000a745aa1de3b4ef71"
+dependencies = [
+ "icu_normalizer",
+ "icu_properties",
+]
+
+[[package]]
+name = "indexmap"
+version = "2.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3954d50fe15b02142bf25d3b8bdadb634ec3948f103d04ffe3031bc8fe9d7058"
+dependencies = [
+ "equivalent",
+ "hashbrown 0.15.2",
+]
+
+[[package]]
+name = "inout"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "879f10e63c20629ecabbb64a8010319738c66a5cd0c29b02d63d272b03751d01"
+dependencies = [
+ "block-padding",
+ "generic-array",
+]
+
+[[package]]
+name = "instant"
+version = "0.1.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "wasm-bindgen",
+ "web-sys",
+]
+
+[[package]]
+name = "ipnet"
+version = "2.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"
+
+[[package]]
+name = "itertools"
+version = "0.10.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itoa"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"
+
+[[package]]
+name = "jobserver"
+version = "0.1.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48d1dbcbbeb6a7fec7e059840aa538bd62aaccf972c7346c4d9d2059312853d0"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "js-sys"
+version = "0.3.77"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "json5"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
+dependencies = [
+ "pest",
+ "pest_derive",
+ "serde",
+]
+
+[[package]]
+name = "language-tags"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d4345964bb142484797b161f473a503a434de77149dd8c7427788c6e13379388"
+
+[[package]]
+name = "lazy_static"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
+
+[[package]]
+name = "libc"
+version = "0.2.171"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c19937216e9d3aa9956d9bb8dfc0b0c8beb6058fc4f7a4dc4d850edf86a237d6"
+
+[[package]]
+name = "libloading"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34"
+dependencies = [
+ "cfg-if",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "linked-hash-map"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"
+
+[[package]]
+name = "linux-raw-sys"
+version = "0.9.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6db9c683daf087dc577b7506e9695b3d556a9f3849903fa28186283afd6809e9"
+
+[[package]]
+name = "litemap"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23fb14cb19457329c82206317a5663005a4d404783dc74f4252769b0d5f42856"
+
+[[package]]
+name = "local-channel"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6cbc85e69b8df4b8bb8b89ec634e7189099cea8927a276b7384ce5488e53ec8"
+dependencies = [
+ "futures-core",
+ "futures-sink",
+ "local-waker",
+]
+
+[[package]]
+name = "local-waker"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4d873d7c67ce09b42110d801813efbc9364414e356be9935700d368351657487"
+
+[[package]]
+name = "lock_api"
+version = "0.4.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
+dependencies = [
+ "autocfg",
+ "scopeguard",
+]
+
+[[package]]
+name = "log"
+version = "0.4.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "30bde2b3dc3671ae49d8e2e9f044c7c005836e7a023ee57cffa25ab82764bb9e"
+
+[[package]]
+name = "matrixmultiply"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9380b911e3e96d10c1f415da0876389aaf1b56759054eeb0de7df940c456ba1a"
+dependencies = [
+ "autocfg",
+ "rawpointer",
+]
+
+[[package]]
+name = "memchr"
+version = "2.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
+
+[[package]]
+name = "mime"
+version = "0.3.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
+
+[[package]]
+name = "mime_guess"
+version = "2.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
+dependencies = [
+ "mime",
+ "unicase",
+]
+
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
+[[package]]
+name = "miniz_oxide"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e3e04debbb59698c15bacbb6d93584a8c0ca9cc3213cb423d31f760d8843ce5"
+dependencies = [
+ "adler2",
+]
+
+[[package]]
+name = "mio"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2886843bf800fba2e3377cff24abf6379b4c4d5c6681eaf9ea5b0d15090450bd"
+dependencies = [
+ "libc",
+ "log",
+ "wasi 0.11.0+wasi-snapshot-preview1",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "mockall"
+version = "0.11.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c84490118f2ee2d74570d114f3d0493cbf02790df303d2707606c3e14e07c96"
+dependencies = [
+ "cfg-if",
+ "downcast",
+ "fragile",
+ "lazy_static",
+ "mockall_derive",
+ "predicates",
+ "predicates-tree",
+]
+
+[[package]]
+name = "mockall_derive"
+version = "0.11.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22ce75669015c4f47b289fd4d4f56e894e4c96003ffdf3ac51313126f94c6cbb"
+dependencies = [
+ "cfg-if",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "nalgebra"
+version = "0.32.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b5c17de023a86f59ed79891b2e5d5a94c705dbe904a5b5c9c952ea6221b03e4"
+dependencies = [
+ "approx",
+ "matrixmultiply",
+ "nalgebra-macros",
+ "num-complex",
+ "num-rational",
+ "num-traits",
+ "simba",
+ "typenum",
+]
+
+[[package]]
+name = "nalgebra-macros"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "254a5372af8fc138e36684761d3c0cdb758a4410e938babcff1c860ce14ddbfc"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "native-tls"
+version = "0.2.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "87de3442987e9dbec73158d5c715e7ad9072fda936bb03d19d7fa10e00520f0e"
+dependencies = [
+ "libc",
+ "log",
+ "openssl",
+ "openssl-probe",
+ "openssl-sys",
+ "schannel",
+ "security-framework",
+ "security-framework-sys",
+ "tempfile",
+]
+
+[[package]]
+name = "negentropy"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e664971378a3987224f7a0e10059782035e89899ae403718ee07de85bec42afe"
+
+[[package]]
+name = "nom"
+version = "7.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
+[[package]]
+name = "normalize-line-endings"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "61807f77802ff30975e01f4f071c8ba10c022052f98b3294119f3e615d13e5be"
+
+[[package]]
+name = "nostr"
+version = "0.26.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5bc0867f528a00885212fa8b0afecebf0506db6479ea1e666a5982317892c176"
+dependencies = [
+ "aes",
+ "base64 0.21.7",
+ "bip39",
+ "bitcoin",
+ "cbc",
+ "chacha20",
+ "getrandom 0.2.15",
+ "instant",
+ "negentropy",
+ "once_cell",
+ "reqwest",
+ "serde",
+ "serde_json",
+ "tracing",
+ "url-fork",
+]
+
+[[package]]
+name = "nostr-database"
+version = "0.26.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "569f72670f79c10437eed69325b5b10ac69a1e23c2ee45d7d5781e6ec791cbce"
+dependencies = [
+ "async-trait",
+ "nostr",
+ "rayon",
+ "thiserror 1.0.69",
+ "tokio",
+ "tracing",
+]
+
+[[package]]
+name = "nostr-sdk"
+version = "0.26.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9841e31596008a221e1a909164182ceda5c37fe654a62a9c202109af4756879f"
+dependencies = [
+ "async-utility",
+ "nostr",
+ "nostr-database",
+ "nostr-sdk-net",
+ "once_cell",
+ "thiserror 1.0.69",
+ "tokio",
+ "tracing",
+]
+
+[[package]]
+name = "nostr-sdk-net"
+version = "0.26.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d7eccf4d9be57b513f5ee77e1931bf2fbf02da8ca1edae1feb001558e1e23332"
+dependencies = [
+ "futures-util",
+ "thiserror 1.0.69",
+ "tokio",
+ "tokio-rustls",
+ "tokio-socks",
+ "tokio-tungstenite 0.20.1",
+ "url-fork",
+ "wasm-ws",
+ "webpki-roots",
+]
+
+[[package]]
+name = "num-complex"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "73f88a1307638156682bada9d7604135552957b7818057dcef22705b4d509495"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-conv"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"
+
+[[package]]
+name = "num-integer"
+version = "0.1.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f83d14da390562dca69fc84082e73e548e1ad308d24accdedd2720017cb37824"
+dependencies = [
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "num_threads"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c7398b9c8b70908f6371f47ed36737907c87c52af34c268fed0bf0ceb92ead9"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "object"
+version = "0.36.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d75b0bedcc4fe52caa0e03d9f1151a323e4aa5e2d78ba3580400cd3c9e2bc4bc"
+
+[[package]]
+name = "openssl"
+version = "0.10.71"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e14130c6a98cd258fdcb0fb6d744152343ff729cbfcb28c656a9d12b999fbcd"
+dependencies = [
+ "bitflags 2.9.0",
+ "cfg-if",
+ "foreign-types",
+ "libc",
+ "once_cell",
+ "openssl-macros",
+ "openssl-sys",
+]
+
+[[package]]
+name = "openssl-macros"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "openssl-probe"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"
+
+[[package]]
+name = "openssl-sys"
+version = "0.9.106"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8bb61ea9811cc39e3c2069f40b8b8e2e70d8569b361f879786cc7ed48b777cdd"
+dependencies = [
+ "cc",
+ "libc",
+ "pkg-config",
+ "vcpkg",
+]
+
+[[package]]
+name = "ordered-multimap"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ccd746e37177e1711c20dd619a1620f34f5c8b569c53590a72dedd5344d8924a"
+dependencies = [
+ "dlv-list",
+ "hashbrown 0.12.3",
+]
+
+[[package]]
+name = "parking_lot"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
+dependencies = [
+ "lock_api",
+ "parking_lot_core",
+]
+
+[[package]]
+name = "parking_lot_core"
+version = "0.9.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "redox_syscall",
+ "smallvec",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "paste"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"
+
+[[package]]
+name = "pathdiff"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"
+
+[[package]]
+name = "percent-encoding"
+version = "2.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
+
+[[package]]
+name = "pest"
+version = "2.7.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b7cafe60d6cf8e62e1b9b2ea516a089c008945bb5a275416789e7db0bc199dc"
+dependencies = [
+ "memchr",
+ "thiserror 2.0.12",
+ "ucd-trie",
+]
+
+[[package]]
+name = "pest_derive"
+version = "2.7.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "816518421cfc6887a0d62bf441b6ffb4536fcc926395a69e1a85852d4363f57e"
+dependencies = [
+ "pest",
+ "pest_generator",
+]
+
+[[package]]
+name = "pest_generator"
+version = "2.7.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7d1396fd3a870fc7838768d171b4616d5c91f6cc25e377b673d714567d99377b"
+dependencies = [
+ "pest",
+ "pest_meta",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "pest_meta"
+version = "2.7.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e1e58089ea25d717bfd31fb534e4f3afcc2cc569c70de3e239778991ea3b7dea"
+dependencies = [
+ "once_cell",
+ "pest",
+ "sha2",
+]
+
+[[package]]
+name = "pharos"
+version = "0.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e9567389417feee6ce15dd6527a8a1ecac205ef62c2932bcf3d9f6fc5b78b414"
+dependencies = [
+ "futures",
+ "rustc_version",
+]
+
+[[package]]
+name = "pin-project-lite"
+version = "0.2.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"
+
+[[package]]
+name = "pin-utils"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
+
+[[package]]
+name = "pkg-config"
+version = "0.3.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"
+
+[[package]]
+name = "pollster"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22686f4785f02a4fcc856d3b3bb19bf6c8160d103f7a99cc258bddd0251dc7f2"
+
+[[package]]
+name = "powerfmt"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"
+
+[[package]]
+name = "ppv-lite86"
+version = "0.2.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
+dependencies = [
+ "zerocopy 0.8.23",
+]
+
+[[package]]
+name = "predicates"
+version = "2.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "59230a63c37f3e18569bdb90e4a89cbf5bf8b06fea0b84e65ea10cc4df47addd"
+dependencies = [
+ "difflib",
+ "float-cmp",
+ "itertools",
+ "normalize-line-endings",
+ "predicates-core",
+ "regex",
+]
+
+[[package]]
+name = "predicates-core"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "727e462b119fe9c93fd0eb1429a5f7647394014cf3c04ab2c0350eeb09095ffa"
+
+[[package]]
+name = "predicates-tree"
+version = "1.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72dd2d6d381dfb73a193c7fca536518d7caee39fc8503f74e7dc0be0531b425c"
+dependencies = [
+ "predicates-core",
+ "termtree",
+]
+
+[[package]]
+name = "pretty_assertions"
+version = "1.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3ae130e2f271fbc2ac3a40fb1d07180839cdbbe443c7a27e1e3c13c5cac0116d"
+dependencies = [
+ "diff",
+ "yansi",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.94"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "rand"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
+dependencies = [
+ "libc",
+ "rand_chacha 0.3.1",
+ "rand_core 0.6.4",
+]
+
+[[package]]
+name = "rand"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3779b94aeb87e8bd4e834cee3650289ee9e0d5677f976ecdb6d219e5f4f6cd94"
+dependencies = [
+ "rand_chacha 0.9.0",
+ "rand_core 0.9.3",
+ "zerocopy 0.8.23",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
+dependencies = [
+ "ppv-lite86",
+ "rand_core 0.6.4",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
+dependencies = [
+ "ppv-lite86",
+ "rand_core 0.9.3",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.6.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
+dependencies = [
+ "getrandom 0.2.15",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
+dependencies = [
+ "getrandom 0.3.1",
+]
+
+[[package]]
+name = "rawpointer"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "60a357793950651c4ed0f3f52338f53b2f809f32d83a07f72909fa13e4c6c1e3"
+
+[[package]]
+name = "rayon"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
+dependencies = [
+ "either",
+ "rayon-core",
+]
+
+[[package]]
+name = "rayon-core"
+version = "1.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
+dependencies = [
+ "crossbeam-deque",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.5.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b8c0c260b63a8219631167be35e6a988e9554dbd323f8bd08439c8ed1302bd1"
+dependencies = [
+ "bitflags 2.9.0",
+]
+
+[[package]]
+name = "regex"
+version = "1.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.4.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-lite"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "53a49587ad06b26609c52e423de037e7f57f20d53535d66e08c695f347df952a"
+
+[[package]]
+name = "regex-syntax"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"
+
+[[package]]
+name = "reqwest"
+version = "0.11.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd67538700a17451e7cba03ac727fb961abb7607553461627b97de0b89cf4a62"
+dependencies = [
+ "base64 0.21.7",
+ "bytes",
+ "encoding_rs",
+ "futures-core",
+ "futures-util",
+ "h2",
+ "http 0.2.12",
+ "http-body",
+ "hyper",
+ "hyper-rustls",
+ "hyper-tls",
+ "ipnet",
+ "js-sys",
+ "log",
+ "mime",
+ "mime_guess",
+ "native-tls",
+ "once_cell",
+ "percent-encoding",
+ "pin-project-lite",
+ "rustls",
+ "rustls-native-certs",
+ "rustls-pemfile",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "sync_wrapper",
+ "system-configuration",
+ "tokio",
+ "tokio-native-tls",
+ "tokio-rustls",
+ "tokio-socks",
+ "tokio-util",
+ "tower-service",
+ "url",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "wasm-streams",
+ "web-sys",
+ "webpki-roots",
+ "winreg",
+]
+
+[[package]]
+name = "reqwest-eventsource"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f03f570355882dd8d15acc3a313841e6e90eddbc76a93c748fd82cc13ba9f51"
+dependencies = [
+ "eventsource-stream",
+ "futures-core",
+ "futures-timer",
+ "mime",
+ "nom",
+ "pin-project-lite",
+ "reqwest",
+ "thiserror 1.0.69",
+]
+
+[[package]]
+name = "ring"
+version = "0.17.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
+dependencies = [
+ "cc",
+ "cfg-if",
+ "getrandom 0.2.15",
+ "libc",
+ "untrusted",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "ron"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88073939a61e5b7680558e6be56b419e208420c2adb92be54921fa6b72283f1a"
+dependencies = [
+ "base64 0.13.1",
+ "bitflags 1.3.2",
+ "serde",
+]
+
+[[package]]
+name = "rust-ini"
+version = "0.18.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6d5f2436026b4f6e79dc829837d467cc7e9a55ee40e750d716713540715a2df"
+dependencies = [
+ "cfg-if",
+ "ordered-multimap",
+]
+
+[[package]]
+name = "rustc-demangle"
+version = "0.1.24"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
+
+[[package]]
+name = "rustc_version"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
+dependencies = [
+ "semver",
+]
+
+[[package]]
+name = "rustix"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f7178faa4b75a30e269c71e61c353ce2748cf3d76f0c44c393f4e60abf49b825"
+dependencies = [
+ "bitflags 2.9.0",
+ "errno",
+ "libc",
+ "linux-raw-sys",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "rustls"
+version = "0.21.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f56a14d1f48b391359b22f731fd4bd7e43c97f3c50eee276f3aa09c94784d3e"
+dependencies = [
+ "log",
+ "ring",
+ "rustls-webpki",
+ "sct",
+]
+
+[[package]]
+name = "rustls-native-certs"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a9aace74cb666635c918e9c12bc0d348266037aa8eb599b5cba565709a8dff00"
+dependencies = [
+ "openssl-probe",
+ "rustls-pemfile",
+ "schannel",
+ "security-framework",
+]
+
+[[package]]
+name = "rustls-pemfile"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1c74cae0a4cf6ccbbf5f359f08efdf8ee7e1dc532573bf0db71968cb56b1448c"
+dependencies = [
+ "base64 0.21.7",
+]
+
+[[package]]
+name = "rustls-webpki"
+version = "0.101.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b6275d1ee7a1cd780b64aca7726599a1dbc893b1e64144529e55c3c2f745765"
+dependencies = [
+ "ring",
+ "untrusted",
+]
+
+[[package]]
+name = "rustversion"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eded382c5f5f786b989652c49544c4877d9f015cc22e145a5ea8ea66c2921cd2"
+
+[[package]]
+name = "ryu"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"
+
+[[package]]
+name = "safe_arch"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96b02de82ddbe1b636e6170c21be622223aea188ef2e139be0a5b219ec215323"
+dependencies = [
+ "bytemuck",
+]
+
+[[package]]
+name = "schannel"
+version = "0.1.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f29ebaa345f945cec9fbbc532eb307f0fdad8161f281b6369539c8d84876b3d"
+dependencies = [
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "scopeguard"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
+
+[[package]]
+name = "sct"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da046153aa2352493d6cb7da4b6e5c0c057d8a1d0a9aa8560baffdd945acd414"
+dependencies = [
+ "ring",
+ "untrusted",
+]
+
+[[package]]
+name = "secp256k1"
+version = "0.27.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "25996b82292a7a57ed3508f052cfff8640d38d32018784acd714758b43da9c8f"
+dependencies = [
+ "bitcoin_hashes 0.12.0",
+ "rand 0.8.5",
+ "secp256k1-sys",
+ "serde",
+]
+
+[[package]]
+name = "secp256k1-sys"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70a129b9e9efbfb223753b9163c4ab3b13cff7fd9c7f010fbac25ab4099fa07e"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "security-framework"
+version = "2.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
+dependencies = [
+ "bitflags 2.9.0",
+ "core-foundation",
+ "core-foundation-sys",
+ "libc",
+ "security-framework-sys",
+]
+
+[[package]]
+name = "security-framework-sys"
+version = "2.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49db231d56a190491cb4aeda9527f1ad45345af50b0851622a7adb8c03b01c32"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "semver"
+version = "1.0.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"
+
+[[package]]
+name = "send_wrapper"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd0b0ec5f1c1ca621c432a25813d8d60c88abe6d3e08a3eb9cf37d97a0fe3d73"
+
+[[package]]
+name = "serde"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
+dependencies = [
+ "serde_derive",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.140"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
+dependencies = [
+ "itoa",
+ "memchr",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "serde_spanned"
+version = "0.6.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "87607cb1398ed59d48732e575a4c28a7a8ebf2454b964fe3f224f2afc07909e1"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "serde_urlencoded"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
+dependencies = [
+ "form_urlencoded",
+ "itoa",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "serde_yaml"
+version = "0.9.34+deprecated"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
+dependencies = [
+ "indexmap",
+ "itoa",
+ "ryu",
+ "serde",
+ "unsafe-libyaml",
+]
+
+[[package]]
+name = "sha1"
+version = "0.10.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "digest",
+]
+
+[[package]]
+name = "sha2"
+version = "0.10.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "digest",
+]
+
+[[package]]
+name = "shlex"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"
+
+[[package]]
+name = "signal-hook-registry"
+version = "1.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "simba"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "061507c94fc6ab4ba1c9a0305018408e312e17c041eb63bef8aa726fa33aceae"
+dependencies = [
+ "approx",
+ "num-complex",
+ "num-traits",
+ "paste",
+ "wide",
+]
+
+[[package]]
+name = "simplelog"
+version = "0.12.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "16257adbfaef1ee58b1363bdc0664c9b8e1e30aed86049635fb5f147d065a9c0"
+dependencies = [
+ "log",
+ "termcolor",
+ "time",
+]
+
+[[package]]
+name = "slab"
+version = "0.4.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "smallvec"
+version = "1.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fcf8323ef1faaee30a44a340193b1ac6814fd9b7b4e88e9d4519a3e4abe1cfd"
+
+[[package]]
+name = "socket2"
+version = "0.5.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c970269d99b64e60ec3bd6ad27270092a5394c4e309314b18ae3fe575695fbe8"
+dependencies = [
+ "libc",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "stable_deref_trait"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
+
+[[package]]
+name = "strsim"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"
+
+[[package]]
+name = "syn"
+version = "1.0.109"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "syn"
+version = "2.0.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "sync_wrapper"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"
+
+[[package]]
+name = "synstructure"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8af7666ab7b6390ab78131fb5b0fce11d6b7a6951602017c35fa82800708971"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "system-configuration"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba3a3adc5c275d719af8cb4272ea1c4a6d668a777f37e115f6d11ddbc1c8e0e7"
+dependencies = [
+ "bitflags 1.3.2",
+ "core-foundation",
+ "system-configuration-sys",
+]
+
+[[package]]
+name = "system-configuration-sys"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a75fb188eb626b924683e3b95e3a48e63551fcfb51949de2f06a9d91dbee93c9"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "tempfile"
+version = "3.18.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2c317e0a526ee6120d8dabad239c8dadca62b24b6f168914bbbc8e2fb1f0e567"
+dependencies = [
+ "cfg-if",
+ "fastrand",
+ "getrandom 0.3.1",
+ "once_cell",
+ "rustix",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "termcolor"
+version = "1.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "termtree"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f50febec83f5ee1df3015341d8bd429f2d1cc62bcba7ea2076759d315084683"
+
+[[package]]
+name = "thiserror"
+version = "1.0.69"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
+dependencies = [
+ "thiserror-impl 1.0.69",
+]
+
+[[package]]
+name = "thiserror"
+version = "2.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
+dependencies = [
+ "thiserror-impl 2.0.12",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "1.0.69"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "2.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "time"
+version = "0.3.39"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dad298b01a40a23aac4580b67e3dbedb7cc8402f3592d7f49469de2ea4aecdd8"
+dependencies = [
+ "deranged",
+ "itoa",
+ "libc",
+ "num-conv",
+ "num_threads",
+ "powerfmt",
+ "serde",
+ "time-core",
+ "time-macros",
+]
+
+[[package]]
+name = "time-core"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "765c97a5b985b7c11d7bc27fa927dc4fe6af3a6dfb021d28deb60d3bf51e76ef"
+
+[[package]]
+name = "time-macros"
+version = "0.2.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e8093bc3e81c3bc5f7879de09619d06c9a5a5e45ca44dfeeb7225bae38005c5c"
+dependencies = [
+ "num-conv",
+ "time-core",
+]
+
+[[package]]
+name = "tinystr"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9117f5d4db391c1cf6927e7bea3db74b9a1c1add8f7eda9ffd5364f40f57b82f"
+dependencies = [
+ "displaydoc",
+ "zerovec",
+]
+
+[[package]]
+name = "tinyvec"
+version = "1.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09b3661f17e86524eccd4371ab0429194e0d7c008abb45f7a7495b1719463c71"
+dependencies = [
+ "tinyvec_macros",
+]
+
+[[package]]
+name = "tinyvec_macros"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
+
+[[package]]
+name = "tokio"
+version = "1.44.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f382da615b842244d4b8738c82ed1275e6c5dd90c459a30941cd07080b06c91a"
+dependencies = [
+ "backtrace",
+ "bytes",
+ "libc",
+ "mio",
+ "parking_lot",
+ "pin-project-lite",
+ "signal-hook-registry",
+ "socket2",
+ "tokio-macros",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "tokio-macros"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "tokio-native-tls"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
+dependencies = [
+ "native-tls",
+ "tokio",
+]
+
+[[package]]
+name = "tokio-rustls"
+version = "0.24.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c28327cf380ac148141087fbfb9de9d7bd4e84ab5d2c28fbc911d753de8a7081"
+dependencies = [
+ "rustls",
+ "tokio",
+]
+
+[[package]]
+name = "tokio-socks"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0d4770b8024672c1101b3f6733eab95b18007dbe0847a8afe341fcf79e06043f"
+dependencies = [
+ "either",
+ "futures-util",
+ "thiserror 1.0.69",
+ "tokio",
+]
+
+[[package]]
+name = "tokio-stream"
+version = "0.1.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
+dependencies = [
+ "futures-core",
+ "pin-project-lite",
+ "tokio",
+]
+
+[[package]]
+name = "tokio-test"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2468baabc3311435b55dd935f702f42cd1b8abb7e754fb7dfb16bd36aa88f9f7"
+dependencies = [
+ "async-stream",
+ "bytes",
+ "futures-core",
+ "tokio",
+ "tokio-stream",
+]
+
+[[package]]
+name = "tokio-tungstenite"
+version = "0.20.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "212d5dcb2a1ce06d81107c3d0ffa3121fe974b73f068c8282cb1c32328113b6c"
+dependencies = [
+ "futures-util",
+ "log",
+ "rustls",
+ "tokio",
+ "tokio-rustls",
+ "tungstenite 0.20.1",
+ "webpki-roots",
+]
+
+[[package]]
+name = "tokio-tungstenite"
+version = "0.22.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d46baf930138837d65e25e3b33be49c9228579a6135dbf756b5cb9e4283e7cef"
+dependencies = [
+ "futures-util",
+ "log",
+ "tokio",
+ "tungstenite 0.21.0",
+]
+
+[[package]]
+name = "tokio-util"
+version = "0.7.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6b9590b93e6fcc1739458317cccd391ad3955e2bde8913edf6f95f9e65a8f034"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "futures-sink",
+ "pin-project-lite",
+ "tokio",
+]
+
+[[package]]
+name = "toml"
+version = "0.5.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml"
+version = "0.8.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd87a5cdd6ffab733b2f74bc4fd7ee5fff6634124999ac278c35fc78c6120148"
+dependencies = [
+ "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "toml_edit",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.6.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml_edit"
+version = "0.22.24"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17b4795ff5edd201c7cd6dca065ae59972ce77d1b80fa0a84d94950ece7d1474"
+dependencies = [
+ "indexmap",
+ "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "winnow",
+]
+
+[[package]]
+name = "tower-service"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"
+
+[[package]]
+name = "tracing"
+version = "0.1.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
+dependencies = [
+ "log",
+ "pin-project-lite",
+ "tracing-attributes",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-attributes"
+version = "0.1.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "395ae124c09f9e6918a2310af6038fba074bcf474ac352496d5910dd59a2226d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "tracing-core"
+version = "0.1.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e672c95779cf947c5311f83787af4fa8fffd12fb27e4993211a84bdfd9610f9c"
+dependencies = [
+ "once_cell",
+]
+
+[[package]]
+name = "try-lock"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
+
+[[package]]
+name = "tungstenite"
+version = "0.20.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e3dac10fd62eaf6617d3a904ae222845979aec67c615d1c842b4002c7666fb9"
+dependencies = [
+ "byteorder",
+ "bytes",
+ "data-encoding",
+ "http 0.2.12",
+ "httparse",
+ "log",
+ "rand 0.8.5",
+ "rustls",
+ "sha1",
+ "thiserror 1.0.69",
+ "url",
+ "utf-8",
+]
+
+[[package]]
+name = "tungstenite"
+version = "0.21.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ef1a641ea34f399a848dea702823bbecfb4c486f911735368f1f137cb8257e1"
+dependencies = [
+ "byteorder",
+ "bytes",
+ "data-encoding",
+ "http 1.3.1",
+ "httparse",
+ "log",
+ "rand 0.8.5",
+ "sha1",
+ "thiserror 1.0.69",
+ "url",
+ "utf-8",
+]
+
+[[package]]
+name = "tungstenite"
+version = "0.22.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dbc55edf6afe467bfa92835ae73628d8a934818aa1591c6ebacc4379b7c0ad09"
+dependencies = [
+ "byteorder",
+ "bytes",
+ "data-encoding",
+ "http 1.3.1",
+ "httparse",
+ "log",
+ "rand 0.8.5",
+ "sha1",
+ "thiserror 1.0.69",
+ "utf-8",
+]
+
+[[package]]
+name = "typenum"
+version = "1.18.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"
+
+[[package]]
+name = "ucd-trie"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"
+
+[[package]]
+name = "unicase"
+version = "2.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"
+
+[[package]]
+name = "unicode-bidi"
+version = "0.3.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"
+
+[[package]]
+name = "unicode-normalization"
+version = "0.1.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
+dependencies = [
+ "tinyvec",
+]
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"
+
+[[package]]
+name = "unsafe-libyaml"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"
+
+[[package]]
+name = "untrusted"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"
+
+[[package]]
+name = "url"
+version = "2.5.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
+dependencies = [
+ "form_urlencoded",
+ "idna 1.0.3",
+ "percent-encoding",
+]
+
+[[package]]
+name = "url-fork"
+version = "3.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fa3323c39b8e786154d3000b70ae9af0e9bd746c9791456da0d4a1f68ad89d6"
+dependencies = [
+ "form_urlencoded",
+ "idna 0.5.0",
+ "percent-encoding",
+ "serde",
+]
+
+[[package]]
+name = "urlencoding"
+version = "2.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "daf8dba3b7eb870caf1ddeed7bc9d2a049f3cfdfae7cb521b087cc33ae4c49da"
+
+[[package]]
+name = "utf-8"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"
+
+[[package]]
+name = "utf16_iter"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8232dd3cdaed5356e0f716d285e4b40b932ac434100fe9b7e0e8e935b9e6246"
+
+[[package]]
+name = "utf8_iter"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"
+
+[[package]]
+name = "uuid"
+version = "1.15.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e0f540e3240398cce6128b64ba83fdbdd86129c16a3aa1a3a252efd66eb3d587"
+dependencies = [
+ "getrandom 0.3.1",
+ "serde",
+]
+
+[[package]]
+name = "v_htmlescape"
+version = "0.15.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4e8257fbc510f0a46eb602c10215901938b5c2a7d5e70fc11483b1d3c9b5b18c"
+
+[[package]]
+name = "vcpkg"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"
+
+[[package]]
+name = "version_check"
+version = "0.9.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
+
+[[package]]
+name = "want"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
+dependencies = [
+ "try-lock",
+]
+
+[[package]]
+name = "wasi"
+version = "0.11.0+wasi-snapshot-preview1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
+
+[[package]]
+name = "wasi"
+version = "0.13.3+wasi-0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26816d2e1a4a36a2940b96c5296ce403917633dff8f3440e9b236ed6f6bacad2"
+dependencies = [
+ "wit-bindgen-rt",
+]
+
+[[package]]
+name = "wasm-bindgen"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-futures"
+version = "0.4.50"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "once_cell",
+ "wasm-bindgen",
+ "web-sys",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "wasm-streams"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "15053d8d85c7eccdbefef60f06769760a563c7f0a9d6902a13d35c7800b0ad65"
+dependencies = [
+ "futures-util",
+ "js-sys",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+]
+
+[[package]]
+name = "wasm-ws"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f5b3a482e27ff54809c0848629d9033179705c5ea2f58e26cf45dc77c34c4984"
+dependencies = [
+ "async_io_stream",
+ "futures",
+ "js-sys",
+ "pharos",
+ "send_wrapper",
+ "thiserror 1.0.69",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+]
+
+[[package]]
+name = "web-sys"
+version = "0.3.77"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "0.25.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f20c57d8d7db6d3b86154206ae5d8fba62dd39573114de97c2cb0578251f8e1"
+
+[[package]]
+name = "webxr"
+version = "0.1.0"
+dependencies = [
+ "actix",
+ "actix-cors",
+ "actix-files",
+ "actix-web",
+ "actix-web-actors",
+ "anyhow",
+ "async-openai",
+ "async-trait",
+ "backoff",
+ "base64 0.22.1",
+ "bytemuck",
+ "byteorder",
+ "chrono",
+ "config",
+ "cudarc",
+ "dotenvy",
+ "flate2",
+ "futures",
+ "glam",
+ "lazy_static",
+ "log",
+ "mockall",
+ "nalgebra",
+ "nostr-sdk",
+ "once_cell",
+ "pollster",
+ "pretty_assertions",
+ "rand 0.8.5",
+ "regex",
+ "reqwest",
+ "scopeguard",
+ "serde",
+ "serde_json",
+ "serde_yaml",
+ "sha1",
+ "simplelog",
+ "thiserror 1.0.69",
+ "tokio",
+ "tokio-test",
+ "tokio-tungstenite 0.22.0",
+ "toml 0.8.20",
+ "tungstenite 0.22.0",
+ "url",
+ "urlencoding",
+ "uuid",
+]
+
+[[package]]
+name = "wide"
+version = "0.7.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41b5576b9a81633f3e8df296ce0063042a73507636cbe956c61133dd7034ab22"
+dependencies = [
+ "bytemuck",
+ "safe_arch",
+]
+
+[[package]]
+name = "winapi-util"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
+dependencies = [
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "windows-core"
+version = "0.52.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
+dependencies = [
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6dccfd733ce2b1753b03b6d3c65edf020262ea35e20ccdf3e288043e6dd620e3"
+
+[[package]]
+name = "windows-sys"
+version = "0.48.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
+dependencies = [
+ "windows-targets 0.48.5",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.52.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
+dependencies = [
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.59.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
+dependencies = [
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
+dependencies = [
+ "windows_aarch64_gnullvm 0.48.5",
+ "windows_aarch64_msvc 0.48.5",
+ "windows_i686_gnu 0.48.5",
+ "windows_i686_msvc 0.48.5",
+ "windows_x86_64_gnu 0.48.5",
+ "windows_x86_64_gnullvm 0.48.5",
+ "windows_x86_64_msvc 0.48.5",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
+dependencies = [
+ "windows_aarch64_gnullvm 0.52.6",
+ "windows_aarch64_msvc 0.52.6",
+ "windows_i686_gnu 0.52.6",
+ "windows_i686_gnullvm",
+ "windows_i686_msvc 0.52.6",
+ "windows_x86_64_gnu 0.52.6",
+ "windows_x86_64_gnullvm 0.52.6",
+ "windows_x86_64_msvc 0.52.6",
+]
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
+
+[[package]]
+name = "winnow"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0e97b544156e9bebe1a0ffbc03484fc1ffe3100cbce3ffb17eac35f7cdd7ab36"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "winreg"
+version = "0.50.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "524e57b2c537c0f9b1e69f1965311ec12182b4122e45035b1508cd24d2adadb1"
+dependencies = [
+ "cfg-if",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
+name = "wit-bindgen-rt"
+version = "0.33.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3268f3d866458b787f390cf61f4bbb563b922d091359f9608842999eaee3943c"
+dependencies = [
+ "bitflags 2.9.0",
+]
+
+[[package]]
+name = "write16"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d1890f4022759daae28ed4fe62859b1236caebfc61ede2f63ed4e695f3f6d936"
+
+[[package]]
+name = "writeable"
+version = "0.5.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e9df38ee2d2c3c5948ea468a8406ff0db0b29ae1ffde1bcf20ef305bcc95c51"
+
+[[package]]
+name = "yaml-rust"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85"
+dependencies = [
+ "linked-hash-map",
+]
+
+[[package]]
+name = "yansi"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cfe53a6657fd280eaa890a3bc59152892ffa3e30101319d168b781ed6529b049"
+
+[[package]]
+name = "yoke"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "120e6aef9aa629e3d4f52dc8cc43a015c7724194c97dfaf45180d2daf2b77f40"
+dependencies = [
+ "serde",
+ "stable_deref_trait",
+ "yoke-derive",
+ "zerofrom",
+]
+
+[[package]]
+name = "yoke-derive"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2380878cad4ac9aac1e2435f3eb4020e8374b5f13c296cb75b4620ff8e229154"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+ "synstructure",
+]
+
+[[package]]
+name = "zerocopy"
+version = "0.7.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
+dependencies = [
+ "zerocopy-derive 0.7.35",
+]
+
+[[package]]
+name = "zerocopy"
+version = "0.8.23"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fd97444d05a4328b90e75e503a34bad781f14e28a823ad3557f0750df1ebcbc6"
+dependencies = [
+ "zerocopy-derive 0.8.23",
+]
+
+[[package]]
+name = "zerocopy-derive"
+version = "0.7.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "zerocopy-derive"
+version = "0.8.23"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6352c01d0edd5db859a63e2605f4ea3183ddbd15e2c4a9e7d32184df75e4f154"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "zerofrom"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
+dependencies = [
+ "zerofrom-derive",
+]
+
+[[package]]
+name = "zerofrom-derive"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+ "synstructure",
+]
+
+[[package]]
+name = "zerovec"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "aa2b893d79df23bfb12d5461018d408ea19dfafe76c2c7ef6d4eba614f8ff079"
+dependencies = [
+ "yoke",
+ "zerofrom",
+ "zerovec-derive",
+]
+
+[[package]]
+name = "zerovec-derive"
+version = "0.10.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6eafa6dfb17584ea3e2bd6e76e0cc15ad7af12b09abdd1ca55961bed9b1063c6"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "zstd"
+version = "0.13.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e91ee311a569c327171651566e07972200e76fcfe2242a4fa446149a3881c08a"
+dependencies = [
+ "zstd-safe",
+]
+
+[[package]]
+name = "zstd-safe"
+version = "7.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f3051792fbdc2e1e143244dc28c60f73d8470e93f3f9cbd0ead44da5ed802722"
+dependencies = [
+ "zstd-sys",
+]
+
+[[package]]
+name = "zstd-sys"
+version = "2.0.14+zstd.1.5.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8fb060d4926e4ac3a3ad15d864e99ceb5f343c6b34f5bd6d81ae6ed417311be5"
+dependencies = [
+ "cc",
+ "pkg-config",
+]
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 00000000..332c5b1e
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,97 @@
+[package]
+name = "webxr"
+version = "0.1.0"
+edition = "2021"
+description = "A WebXR graph visualization server with GPU-accelerated physics"
+authors = ["Your Name <your.email@example.com>"]
+
+[dependencies]
+# Web framework and WebSocket
+actix-web = { version = "=4.5.1", features = ["compress-gzip"] }
+actix-cors = "=0.7.0"
+actix-files = "=0.6.5"
+actix = "=0.13.1"
+actix-web-actors = "=4.3.0"
+tungstenite = "0.22"
+tokio-tungstenite = { version = "0.22" }
+
+# Async runtime
+tokio = { version = "1.43", features = ["full"] }
+futures = "0.3"
+async-trait = "0.1.86"
+
+# Serialization
+serde = { version = "1.0", features = ["derive"] }
+serde_json = "1.0"
+serde_yaml = "0.9"
+
+# Configuration
+config = { version = "0.13", features = ["toml"] }
+dotenvy = "0.15"
+toml = "0.8"
+
+# Logging
+log = "0.4"
+simplelog = "0.12"
+
+# Error handling
+thiserror = "1.0"
+anyhow = "1.0"
+
+# GPU/Compute
+bytemuck = { version = "1.21", features = ["derive"] }
+pollster = "0.3"
+cudarc = { version = "0.11", features = ["driver", "cuda-12040"] }
+
+# HTTP client and API
+reqwest = { version = "0.11", features = ["json", "stream"] }
+async-openai = "0.14.3"
+# Even though backoff is unmaintained (RUSTSEC-2025-0012), we'll use the latest version
+# since it's used transitively by async-openai and our code doesn't directly import it
+backoff = { version = "0.4.0", features = ["tokio"] }
+nostr-sdk = "0.26"
+
+# Utilities
+uuid = { version = "1.12", features = ["v4", "serde"] }
+chrono = { version = "0.4", features = ["serde"] }
+base64 = "0.22"
+rand = "0.8"
+regex = "1.11"
+lazy_static = "1.5"
+once_cell = "1.19"
+sha1 = "0.10.6"
+scopeguard = "1.2"
+url = "2.5.0"
+flate2 = "1.0"
+byteorder = "1.5"
+urlencoding = "2.1"
+
+# Math/Linear Algebra (needed for GPU compute)
+nalgebra = "0.32"
+
+# Added from the code block
+glam = "0.24"
+
+[dev-dependencies]
+tokio-test = "0.4"
+mockall = "0.11"
+pretty_assertions = "1.4"
+
+[features]
+default = ["gpu"]
+gpu = ["cudarc/driver"]  # Enable GPU support with CUDA driver
+cpu = []  # CPU-only mode
+
+[profile.release]
+opt-level = 3
+lto = true
+codegen-units = 1
+panic = "abort"
+strip = true
+
+[profile.dev]
+opt-level = 1
+
+[package.metadata.rust-version]
+min = "1.70.0"
+
diff --git a/Dockerfile b/Dockerfile
new file mode 100755
index 00000000..aab90562
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,208 @@
+# Stage 1: Frontend Build
+FROM node:20-slim AS frontend-builder
+
+WORKDIR /app
+
+# Install pnpm
+RUN npm install -g pnpm@9.14.2
+
+# Copy package files and configuration
+COPY package.json pnpm-lock.yaml ./
+COPY tsconfig.json tsconfig.node.json vite.config.ts ./
+COPY client ./client
+
+# Create data/public directory for build output
+RUN mkdir -p data/public
+
+# Install dependencies and build
+RUN pnpm install --frozen-lockfile && \
+    pnpm run build
+
+# Stage 2: Rust Dependencies Cache
+FROM nvidia/cuda:12.4.0-devel-ubuntu22.04 AS rust-deps-builder
+
+# Install build dependencies
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    build-essential \
+    curl \
+    libssl-dev \
+    pkg-config \
+    libegl1-mesa-dev \
+    libasound2-dev \
+    ca-certificates \
+    jq \
+    && rm -rf /var/lib/apt/lists/*
+
+# Install Rust with better error handling
+RUN curl --retry 5 --retry-delay 2 --retry-connrefused https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain 1.82.0
+ENV PATH="/root/.cargo/bin:${PATH}"
+
+# Configure cargo for better network resilience
+RUN mkdir -p ~/.cargo && \
+    echo '[source.crates-io]' >> ~/.cargo/config.toml && \
+    echo 'registry = "https://github.com/rust-lang/crates.io-index"' >> ~/.cargo/config.toml && \
+    echo 'replace-with = "ustc"' >> ~/.cargo/config.toml && \
+    echo '[source.ustc]' >> ~/.cargo/config.toml && \
+    echo 'registry = "sparse+https://mirrors.ustc.edu.cn/crates.io-index/"' >> ~/.cargo/config.toml && \
+    echo '[net]' >> ~/.cargo/config.toml && \
+    echo 'retry = 10' >> ~/.cargo/config.toml && \
+    echo 'timeout = 120' >> ~/.cargo/config.toml && \
+    echo 'git-fetch-with-cli = true' >> ~/.cargo/config.toml
+
+WORKDIR /usr/src/app
+
+# Copy Cargo files first for better layer caching
+COPY Cargo.toml Cargo.lock ./
+
+# Install git and set GIT_HASH
+RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*
+
+# Create dummy src directory and build dependencies
+RUN mkdir src && \
+    echo "fn main() {}" > src/main.rs && \
+    GIT_HASH=$(git rev-parse HEAD || echo "development") \
+    CARGO_NET_GIT_FETCH_WITH_CLI=true \
+    CARGO_HTTP_TIMEOUT=120 \
+    CARGO_HTTP_CHECK_REVOKE=false \
+    cargo build --release --features gpu --jobs $(nproc) || \
+    (sleep 2 && GIT_HASH=$(git rev-parse HEAD || echo "development") CARGO_HTTP_MULTIPLEXING=false cargo build --release --jobs $(nproc)) || \
+    (sleep 5 && GIT_HASH=$(git rev-parse HEAD || echo "development") CARGO_HTTP_MULTIPLEXING=false cargo build --release --jobs 1)
+
+# Now copy the real source code and build
+COPY src ./src
+
+RUN GIT_HASH=$(git rev-parse HEAD || echo "development") \
+    cargo build --release --features gpu --jobs $(nproc) || \
+    (sleep 2 && GIT_HASH=$(git rev-parse HEAD || echo "development") cargo build --release --jobs $(nproc)) || \
+    (sleep 5 && GIT_HASH=$(git rev-parse HEAD || echo "development") cargo build --release --jobs 1)
+
+# Stage 3: Final Runtime Image
+FROM nvidia/cuda:12.4.0-devel-ubuntu22.04
+
+ENV DEBIAN_FRONTEND=noninteractive \
+    PYTHONUNBUFFERED=1 \
+    PATH="/app/venv/bin:${PATH}" \
+    NVIDIA_DRIVER_CAPABILITIES=all \
+    RUST_LOG=info \
+    RUST_BACKTRACE=0 \
+    PORT=4000 \
+    BIND_ADDRESS=0.0.0.0 \
+    NODE_ENV=production \
+    DOMAIN=localhost
+
+# Install runtime dependencies
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    curl \
+    libssl3 \
+    nginx \
+    libegl1-mesa \
+    libasound2 \
+    ca-certificates \
+    mesa-utils \
+    libgl1-mesa-dri \
+    libgl1-mesa-glx \
+    netcat-openbsd \
+    gettext-base \
+    net-tools \
+    iproute2 \
+    procps \
+    lsof \
+    jq \
+    wget \
+    && wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq \
+    && chmod +x /usr/bin/yq \
+    && wget https://github.com/vi/websocat/releases/latest/download/websocat.x86_64-unknown-linux-musl -O /usr/bin/websocat \
+    && chmod +x /usr/bin/websocat \
+    && rm -rf /var/lib/apt/lists/* \
+    && rm -rf /usr/share/doc/* \
+    && rm -rf /usr/share/man/*
+
+# Create a non-root user for running the application
+RUN groupadd -g 1000 webxr && \
+    useradd -u 1000 -g webxr -d /app webxr
+
+# Set up nginx configuration
+COPY nginx.conf /etc/nginx/nginx.conf.template
+RUN envsubst '${DOMAIN}' < /etc/nginx/nginx.conf.template > /etc/nginx/nginx.conf && \
+    rm /etc/nginx/nginx.conf.template && \
+    chown -R webxr:webxr /etc/nginx/nginx.conf && \
+    chmod 644 /etc/nginx/nginx.conf
+
+# Set up nginx directories and permissions
+RUN mkdir -p /var/lib/nginx/client_temp \
+             /var/lib/nginx/proxy_temp \
+             /var/lib/nginx/fastcgi_temp \
+             /var/lib/nginx/uwsgi_temp \
+             /var/lib/nginx/scgi_temp \
+             /var/log/nginx \
+             /var/run/nginx \
+             /var/cache/nginx && \
+    chown -R webxr:webxr /var/lib/nginx \
+                         /var/log/nginx \
+                         /var/run/nginx \
+                         /var/cache/nginx \
+                         /etc/nginx && \
+    chmod -R 755 /var/lib/nginx \
+                 /var/log/nginx \
+                 /var/run/nginx \
+                 /var/cache/nginx \
+                 /etc/nginx && \
+    touch /var/log/nginx/error.log \
+          /var/log/nginx/access.log \
+          /var/run/nginx/nginx.pid && \
+    chmod 666 /var/log/nginx/*.log \
+              /var/run/nginx/nginx.pid
+
+# Set up directory structure and permissions
+WORKDIR /app
+
+# Create required directories with proper permissions
+RUN mkdir -p /app/data/public/dist \
+             /app/data/markdown \
+             /app/data/runtime \
+             /app/compute_forces \
+             /app/data/piper \
+             /tmp/runtime && \
+    chown -R webxr:webxr /app /tmp/runtime && \
+    chmod -R 755 /app /tmp/runtime && \
+    # Ensure data/markdown is writable by webxr user
+    chmod 777 /app/data/markdown
+
+# Create necessary directories and set permissions
+RUN mkdir -p /app/data/markdown /app/data/metadata /app/user_settings && \
+    chmod -R 777 /app/data && \
+    chmod 777 /app/user_settings
+
+# Copy built artifacts
+COPY --from=rust-deps-builder /usr/src/app/target/release/webxr /app/
+COPY src/utils/compute_forces.ptx /app/src/utils/compute_forces.ptx
+RUN chmod 644 /app/src/utils/compute_forces.ptx
+COPY --from=frontend-builder /app/data/public/dist /app/data/public/dist
+
+# Copy start script
+COPY scripts/start.sh /app/start.sh
+
+# Set proper permissions for copied files
+RUN chown -R webxr:webxr /app && \
+    chmod 755 /app/start.sh && \
+    chmod -R g+w /app
+RUN touch /app/settings.yaml && \
+    chown webxr:webxr /app/settings.yaml && \
+    chmod 666 /app/settings.yaml
+
+# Switch to non-root user
+USER webxr
+
+# Add security labels
+LABEL org.opencontainers.image.source="https://github.com/yourusername/logseq-xr" \
+      org.opencontainers.image.description="LogseqXR WebXR Graph Visualization" \
+      org.opencontainers.image.licenses="MIT" \
+      security.capabilities="cap_net_bind_service" \
+      security.privileged="false" \
+      security.allow-privilege-escalation="false"
+
+# Expose port
+EXPOSE 4000
+
+# Start application
+ENTRYPOINT ["/app/start.sh"]
\ No newline at end of file
diff --git a/GeminiWebsocketUpdates.md b/GeminiWebsocketUpdates.md
new file mode 100644
index 00000000..19c96288
--- /dev/null
+++ b/GeminiWebsocketUpdates.md
@@ -0,0 +1,1233 @@
+Problems and Potential Causes:
+
+All Nodes Have the Same Label (Instancing Suspect):
+
+Likely Cause: The most probable cause is an issue within the NodeMetadataManager and how it interacts with the NodeInstanceManager and UnifiedTextRenderer. Specifically, there might be a problem with how labels are being created, assigned, or updated for each node instance. The instancing itself is likely not the root cause, but rather how the label data is being associated with each instance.
+
+Possible Specific Issues:
+
+Incorrect ID Mapping: The nodeIdToMetadataId map in NodeMetadataManager might not be correctly mapping numeric node IDs to the actual metadata IDs (filenames). This would cause all nodes to potentially use the same metadata entry (and thus the same label).
+
+Label Creation Logic: The createMetadataLabel method in NodeMetadataManager might have a flaw in how it determines the label text. The logic you described (prioritizing nodeLabel, then metadata.name, then metadata.id) is correct in principle, but there might be an error in the implementation.
+
+Missing Updates: The updateMetadataLabel method might not be called correctly, or the textRenderer.updateLabel call within it might be failing.
+
+Shared Material: If the TextRenderer or NodeInstanceManager is incorrectly sharing a single material instance across all labels, instead of creating unique materials per label, you'll see this behavior.
+
+Nodes Not Distributing (Physics Issue):
+
+Likely Cause: The core issue is likely within the GraphService, specifically in the calculate_layout (GPU) or calculate_layout_cpu (CPU fallback) methods. There are several possibilities:
+
+GPU Initialization Failure: The GPUCompute might not be initializing correctly. The logs show "GPU compute not available - using CPU fallback," which indicates a problem. Even if the GPU is present, there could be driver issues, CUDA version mismatches, or insufficient resources.
+
+Incorrect Physics Parameters: The SimulationParams might have values that are causing the simulation to be unstable or ineffective (e.g., damping too high, forces too low, incorrect time step).
+
+Zero Positions/Velocities: The logs show "Node ... has zero/null position during label initialization". If nodes start with zero positions, the force calculations might result in zero forces, preventing movement. Similarly, if velocities are not being properly initialized or updated, nodes won't move.
+
+Logic Errors in Force Calculation: There could be errors in the compute_forces.cu (GPU) or the calculate_layout_cpu (CPU) code that are preventing the forces from being calculated or applied correctly. This is the most likely place to look, given the symptoms.
+
+Data Transfer Issues: If using the GPU, there might be problems transferring data between the CPU and GPU, leading to incorrect positions being used in the calculations.
+
+Missing Updates: The updateNodePositions method in NodeInstanceManager might not be correctly updating the positions of the instanced meshes.
+
+Reconnection Logic: There's a lot of reconnection logic in WebSocketService. It's possible that reconnections are interfering with the simulation, resetting values, or causing race conditions.
+
+Edges Not Displaying:
+
+Likely Cause: This is almost certainly related to the node position issue. If nodes are all clustered at the origin, the edges will likely be too short to see, or might not be created at all.
+
+Possible Specific Issues:
+
+Zero-Length Edges: If the source and target nodes of an edge have the same position (or very close positions), the edge might have zero length, making it invisible.
+
+Edge Creation Logic: The createEdge method in EdgeManager might have a flaw.
+
+Visibility: The edges might be created but not visible (e.g., due to incorrect layer settings).
+
+Material Issues: The edge material might be incorrectly configured (e.g., zero opacity).
+
+Debugging Steps and Solutions (Prioritized):
+
+Focus on the Physics First: The node distribution issue is the most fundamental. Fix that, and the labels and edges will likely become much easier to debug.
+
+GPU vs. CPU: Since the logs indicate the GPU is not being used, focus on calculate_layout_cpu in GraphService.rs. The fact that you're seeing "GPU compute not available" is a major red flag. You need to get the GPU working if you want reasonable performance. Here's a prioritized list of things to check, assuming you want to use the GPU:
+
+CUDA Installation: Verify that the CUDA toolkit (including nvcc) is correctly installed inside the Docker container. The nvidia-smi command should work inside the container. The Dockerfile you provided looks correct, but double-check that the base image (nvidia/cuda:12.4.0-devel-ubuntu22.04) is appropriate for your GPU and CUDA version.
+
+GPU Access: Ensure that the Docker container has access to the GPU. The docker-compose.yml file looks correct (using device_ids: ['0'] and capabilities: [compute, utility]), but double-check that GPU 0 is the correct one. Run nvidia-smi inside the container to verify.
+
+CUDA Version Compatibility: The cudarc crate in Cargo.toml specifies cuda-12040. Make absolutely sure this matches the CUDA version installed in your Docker image. If there's a mismatch, you'll get cryptic errors, or the GPU code might not run at all.
+
+cudarc Features: In Cargo.toml, you have features = ["driver", "cuda-12040"]. Make sure this is correct. If you're using a different CUDA version, adjust this. The gpu feature is also correctly enabled.
+
+Error Handling in GPUCompute::new: The GPUCompute::new function in gpu_compute.rs has a retry mechanism, but it's crucial to log detailed error messages within the Err branch of the match statement. Add more logging there to pinpoint the exact reason for failure. Print out the error from CudaDevice::new(0).
+
+Test Function: The GPUCompute::test_gpu() function is a good start, but it's very basic. You should expand this to perform a more substantial test, ideally involving the actual CUDA kernel. Try allocating a small array on the GPU, copying data to it, running a very simple kernel (e.g., just add 1 to each element), and copying the data back. This will help isolate whether the problem is with device creation, memory allocation, or kernel execution.
+
+Simplify: Temporarily remove the retry logic in GPUCompute::new to make debugging easier. Focus on getting a single attempt to work.
+
+Dependencies: Double check that all necessary dependencies are installed within the container.
+
+Docker Configuration: Ensure that the docker network is correctly set up.
+
+CPU Fallback (If GPU is not feasible): If you can't get the GPU working, focus on the calculate_layout_cpu function in GraphService.rs.
+
+Logging: Add extensive logging within this function. Log the values of spring_strength, repulsion, damping, max_repulsion_distance, time_step, enable_bounds, bounds_size, etc. Log the initial positions of the nodes. Log the calculated forces at each step. Log the updated positions and velocities. This will help you pinpoint where the calculation is going wrong.
+
+Force Calculation: Carefully review the logic for calculating repulsive and attractive forces. There might be a bug in the formula, or an issue with how the distances are calculated.
+
+Damping: The damping factor is very high (0.97). This means that the nodes will lose very little velocity each frame, which can lead to oscillations or slow movement. Try reducing the damping factor (e.g., to 0.5 or 0.7) to see if it improves the simulation.
+
+Time Step: The time_step value (0.016) is reasonable (corresponding to 60 FPS), but you could try adjusting it (e.g., making it smaller) to see if it affects the stability of the simulation.
+
+Zero Positions: Ensure that nodes are not all starting at the same position. The initialize_random_positions function should be spreading them out. Add logging to verify this.
+
+Node Mass: The mass calculation is now done in the Node struct, and the mass is being passed to the GPU. Make sure the mass is not zero.
+
+Node Label Issues:
+
+NodeMetadataManager.createMetadataLabel(): This is the most likely place where the problem lies. You've got the correct logic in your description, but double-check the implementation:
+
+displayName Calculation: Verify that the displayName variable is being correctly assigned. The logic nodeLabel || metadata.name || metadata.id || "Unknown" looks correct, but add logging to confirm the value being used.
+
+nodeIdToMetadataId Map: Log the contents of the nodeIdToMetadataId map periodically to ensure that it's being populated correctly. Print the map's size and a few sample entries.
+
+createTextMesh: Log the text value being passed to createTextMesh. Is it the correct label?
+
+Material Cloning: Ensure that the TextRenderer is creating a new material instance for each label. If it's reusing the same material, all labels will have the same text.
+
+NodeInstanceManager.updateNodePositions(): This method receives updates from the WebSocket. Make sure that the id values being passed in are correct (numeric strings) and that they correspond to the IDs used by NodeMetadataManager.
+
+WebSocket Connection:
+
+Error Handling: The WebSocketService has some error handling, but it could be improved. Add more detailed logging within the catch blocks to capture the specific error messages.
+
+Reconnection Logic: Review the reconnection logic in WebSocketService. Make sure it's not interfering with the simulation or causing race conditions.
+
+requestInitialData: Ensure that the requestInitialData message is being sent and handled correctly by the server.
+
+Edge Display:
+
+Visibility: Once the nodes are positioned correctly, check if the edges are being created with the correct source and target IDs. Add logging to EdgeManager.createEdge to verify this.
+
+Material: Ensure that the edge material has a visible color and opacity.
+
+Debugging Tools:
+
+Browser Developer Tools: Use the browser's developer tools (especially the Network tab and the debugger) to inspect network traffic, set breakpoints, and step through the code.
+
+Logging: Add more logger.debug statements throughout the code to track the flow of execution and the values of variables.
+
+debugState: Make sure debugState.enableDataDebug and debugState.enableWebsocketDebug are set to true to enable detailed logging.
+
+Simplified Test Case: If possible, create a simplified test case with a small, fixed set of nodes and edges to isolate the problem.
+
+Code Changes (Illustrative - Apply to Your Codebase):
+
+Here are some specific code changes you can make to improve debugging and potentially fix the issues:
+
+// In NodeMetadataManager.createMetadataLabel()
+createMetadataLabel(metadata: NodeMetadata, nodeLabel?: string): Promise<MetadataLabelGroup> {
+    const group = new Group() as MetadataLabelGroup;
+    group.name = 'metadata-label';
+    group.renderOrder = 1000; // Ensure text mesh renders on top
+    group.userData = { isMetadata: true, nodeId: metadata.id }; // Use metadata.id, not passed nodeId
+
+    // Prioritize label source: nodeLabel > metadata.name > metadata.id
+    const displayName = nodeLabel || metadata.name || metadata.id || "Unknown";
+
+    // Log the label and its source
+    logger.debug(`Creating metadata label for node ${metadata.id}`, createDataMetadata({
+        labelSource: nodeLabel ? 'explicit nodeLabel' : (metadata.name ? 'metadata.name' : 'metadata.id'),
+        displayName,
+        position: metadata.position ? `x:${metadata.position.x.toFixed(2)}, y:${metadata.position.y.toFixed(2)}, z:${metadata.position.z.toFixed(2)}` : 'undefined',
+        fileSize: metadata.fileSize || 'undefined',
+        hyperlinkCount: metadata.hyperlinkCount || 'undefined'
+    }));
+
+    // ... rest of the method ...
+}
+
+//In GraphService.ts
+async buildGraphFromMetadata(metadata) {
+        // Check if a rebuild is already in progress
+        logger.info(`Building graph from ${metadata.size} metadata entries`);
+        debug(`Building graph from ${metadata.size} metadata entries`);
+
+        if (GRAPH_REBUILD_IN_PROGRESS.compareExchange(false, true, Ordering.SeqCst, Ordering.SeqCst)) {
+            warn("Graph rebuild already in progress, skipping duplicate rebuild");
+            return Err("Graph rebuild already in progress".into());
+        }
+
+        // Create a guard struct to ensure the flag is reset when this function returns
+        struct RebuildGuard;
+        impl Drop for RebuildGuard {
+            fn drop(&mut self) {
+                GRAPH_REBUILD_IN_PROGRESS.store(false, Ordering.SeqCst);
+            }
+        }
+        // This guard will reset the flag when it goes out of scope
+        let _guard = RebuildGuard;
+
+        let mut graph = GraphData::new();
+        let mut edge_map = HashMap::new();
+        let mut node_map = HashMap::new();
+
+        // First pass: Create nodes from files in metadata
+        let mut valid_nodes = HashSet::new();
+        debug!("Creating nodes from {} metadata entries", metadata.len());
+        for file_name in metadata.keys() {
+            let node_id = file_name.trim_end_matches(".md").to_string();
+            valid_nodes.insert(node_id);
+        }
+        debug!("Created valid_nodes set with {} nodes", valid_nodes.len());
+
+        // Create nodes for all valid node IDs
+        for node_id in &valid_nodes {
+            // Get metadata for this node, including the node_id if available
+            let metadata_entry = graph.metadata.get(&format!("{}.md", node_id));
+            let stored_node_id = metadata_entry.map(|m| m.node_id.clone());
+
+            // Create node with stored ID or generate a new one if not available
+            let mut node = Node::new_with_id(node_id.clone(), stored_node_id);
+            graph.id_to_metadata.insert(node.id.clone(), node_id.clone());
+
+            // Get metadata for this node
+            if let Some(metadata) = metadata.get(&format!("{}.md", node_id)) {
+                // Set file size which also calculates mass
+                node.set_file_size(metadata.file_size as u64);  // This will update both file_size and mass
+
+                // Set the node label to the file name without extension
+                // This will be used as the display name for the node
+                node.label = metadata.file_name.trim_end_matches(".md").to_string();
+
+                // Set visual properties from metadata
+                node.size = Some(metadata.node_size as f32);
+
+                // Add metadata fields to node's metadata map
+                // Add all relevant metadata fields to ensure consistency
+                node.metadata.insert("fileName".to_string(), metadata.file_name.clone());
+
+                // Add name field (without .md extension) for client-side metadata ID mapping
+                if metadata.file_name.ends_with(".md") {
+                    let name = metadata.file_name[..metadata.file_name.len() - 3].to_string();
+                    node.metadata.insert("name".to_string(), name.clone());
+                    node.metadata.insert("metadataId".to_string(), name);
+                } else {
+                    node.metadata.insert("name".to_string(), metadata.file_name.clone());
+                    node.metadata.insert("metadataId".to_string(), metadata.file_name.clone());
+                }
+
+                node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
+                node.metadata.insert("nodeSize".to_string(), metadata.node_size.to_string());
+                node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
+                node.metadata.insert("sha1".to_string(), metadata.sha1.clone());
+                node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
+
+                if !metadata.perplexity_link.is_empty() {
+                    node.metadata.insert("perplexityLink".to_string(), metadata.perplexity_link.clone());
+                }
+
+                if let Some(last_process) = metadata.last_perplexity_process {
+                    node.metadata.insert("lastPerplexityProcess".to_string(), last_process.to_string());
+                }
+
+                // We don't add topic_counts to metadata as it would create circular references
+                // and is already used to create edges
+
+                // Ensure flags is set to 1 (default active state)
+                node.data.flags = 1;
+            }
+
+            let node_clone = node.clone();
+            graph.nodes.push(node_clone);
+            // Store nodes in map by numeric ID for efficient lookups
+            node_map.insert(node.id.clone(), node);
+        }
+
+        // Store metadata in graph
+        debug!("Storing {} metadata entries in graph", metadata.len());
+        graph.metadata = metadata.clone();
+        debug!("Created {} nodes in graph", graph.nodes.len());
+        // Second pass: Create edges from topic counts
+        for (source_file, metadata) in metadata.iter() {
+            let source_id = source_file.trim_end_matches(".md").to_string();
+            // Find the node with this metadata_id to get its numeric ID
+            let source_node = graph.nodes.iter().find(|n| n.metadata_id == source_id);
+            if source_node.is_none() {
+                continue; // Skip if node not found
+            }
+            let source_numeric_id = source_node.unwrap().id.clone();
+
+            debug!("Processing edges for source: {} (ID: {})", source_id, source_numeric_id);
+            for (target_file, count) in &metadata.topic_counts {
+                let target_id = target_file.trim_end_matches(".md").to_string();
+                // Find the node with this metadata_id to get its numeric ID
+                let target_node = graph.nodes.iter().find(|n| n.metadata_id == target_id);
+                debug!("  Processing potential edge: {} -> {} (count: {})", source_id, target_id, count);
+                if target_node.is_none() {
+                    continue; // Skip if node not found
+                }
+                let target_numeric_id = target_node.unwrap().id.clone();
+                debug!("  Found target node: {} (ID: {})", target_id, target_numeric_id);
+
+                // Only create edge if both nodes exist and they're different
+                if source_numeric_id != target_numeric_id {
+                    let edge_key = if source_numeric_id < target_numeric_id {
+                        (source_numeric_id.clone(), target_numeric_id.clone())
+                    } else {
+                        (target_numeric_id.clone(), source_numeric_id.clone())
+                    };
+
+                    debug!("  Creating/updating edge: {:?} with weight {}", edge_key, count);
+                    // Sum the weights for bi-directional references
+                    edge_map.entry(edge_key)
+                        .and_modify(|w| *w += *count as f32)
+                        .or_insert(*count as f32);
+                }
+            }
+        }
+
+        // Log edge_map contents before transformation
+        debug!("Edge map contains {} unique connections", edge_map.len());
+        for ((source, target), weight) in &edge_map {
+            debug!("Edge map entry: {} -- {} (weight: {})", source, target, weight);
+        }
+
+        debug!("Converting edge map to {} edges", edge_map.len());
+        graph.edges = edge_map.into_iter()
+            .map(|((source, target), weight)| {
+                Edge::new(source, target, weight)
+            })
+            .collect();
+
+        // Initialize random positions
+        Self::initialize_random_positions(&mut graph);
+
+        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
+        debug!("Completed graph build: {} nodes, {} edges", graph.nodes.len(), graph.edges.len());
+        Ok(graph)
+    }
+Use code with caution.
+TypeScript
+//In src/utils/compute_forces.cu
+__global__ void compute_forces_kernel(
+    BinaryNodeData* nodes,
+    int num_nodes,
+    float spring_strength,
+    float damping,
+    float repulsion,
+    float dt,
+    float max_repulsion_dist,
+    float viewport_bounds,
+    int iteration_count
+) {
+    int idx = blockIdx.x * blockDim.x + threadIdx.x;
+    if (idx >= num_nodes) return;
+
+    const float MAX_FORCE = 3.0f; // Reduced maximum force magnitude
+    const float MAX_VELOCITY = 0.02f; // Stricter velocity cap to prevent momentum buildup
+    const float MIN_DISTANCE = 0.15f; // Slightly increased minimum distance
+
+    // Progressive force application parameters
+    // First 100 iterations use a ramp-up factor
+    const int WARMUP_ITERATIONS = 100;
+    float ramp_up_factor = 1.0f;
+
+    if (iteration_count < WARMUP_ITERATIONS) {
+        // Gradually increase from 0.01 to 1.0 over WARMUP_ITERATIONS
+        ramp_up_factor = 0.01f + (iteration_count / (float)WARMUP_ITERATIONS) * 0.99f;
+
+        // Also use higher damping in initial iterations to stabilize the system
+        damping = fmaxf(damping, 0.9f - 0.4f * (iteration_count / (float)WARMUP_ITERATIONS));
+    }
+
+    float3 total_force = make_float3(0.0f, 0.0f, 0.0f);
+    float3 pos = make_float3(nodes[idx].position[0], nodes[idx].position[1], nodes[idx].position[2]);
+    float3 vel = make_float3(nodes[idx].velocity[0], nodes[idx].velocity[1], nodes[idx].velocity[2]);
+
+    // Zero out velocity in the very first iterations to prevent explosion
+    if (iteration_count < 5) {
+        vel = make_float3(0.0f, 0.0f, 0.0f);
+    }
+
+    // Convert mass from u8 to float (approximately 0-1 range)
+    float mass;
+    if (nodes[idx].mass == 0) {
+        mass = 0.5f;  // Default mid-range mass value
+    } else {
+        mass = (nodes[idx].mass + 1.0f) / 256.0f; // Add 1 to avoid zero mass
+    }
+
+    bool is_active = true; // All nodes are active by default
+
+    if (!is_active) return; // Skip inactive nodes
+
+    // Process all node interactions
+    for (int j = 0; j < num_nodes; j++) {
+        if (j == idx) continue;
+
+        // All nodes are considered active by default
+        // We no longer check the flags since all nodes are treated as active
+
+        // Handle other node's mass the same way
+        float other_mass = (nodes[j].mass == 0) ? 0.5f : (nodes[j].mass + 1.0f) / 256.0f;
+
+        float3 other_pos = make_float3(
+            nodes[j].position[0],
+            nodes[j].position[1],
+            nodes[j].position[2]
+        );
+
+        float3 diff = make_float3(
+            other_pos.x - pos.x,
+            other_pos.y - pos.y,
+            other_pos.z - pos.z
+        );
+
+        float dist = sqrtf(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);
+        // Only process if nodes are at a meaningful distance apart
+        if (dist > MIN_DISTANCE) {
+            float3 dir = make_float3(
+                diff.x / dist,
+                diff.y / dist,
+                diff.z / dist
+            );
+
+            // Apply spring forces to all nodes by default
+            {
+                // Use natural length of 1.0 to match world units
+                float natural_length = 1.0f;
+
+                // Progressive spring forces - stronger when further apart
+                // Apply the ramp_up_factor to gradually increase spring forces
+                float spring_force = spring_k * ramp_up_factor * (dist - natural_length);
+
+                // Apply progressively stronger springs for very distant nodes
+                if (dist > natural_length * 3.0f) {
+                    spring_force *= (1.0f + (dist - natural_length * 3.0f) * 0.1f);
+                }
+
+
+                float spring_scale = mass * other_mass;
+                float force_magnitude = spring_force * spring_scale;
+
+                // Repulsion forces - only apply at close distances
+                if (dist < max_repulsion_dist) {
+                    float repel_scale = repel_k * mass * other_mass;
+                    // Apply the ramp_up_factor to gradually increase repulsion forces
+                    float dist_sq = fmaxf(dist * dist, MIN_DISTANCE);
+                    // Cap maximum repulsion force to prevent explosion
+                    float repel_force = fminf(repel_scale / dist_sq, repel_scale * 2.0f);
+                    total_force.x -= dir.x * repel_force;
+                    total_force.y -= dir.y * repel_force;
+                    total_force.z -= dir.z * repel_force;
+                } else {
+                    // Always apply spring forces
+                    total_force.x += dir.x * force_magnitude;
+                    total_force.y += dir.y * force_magnitude;
+                    total_force.z += dir.z * force_magnitude;
+                }
+            }
+        }
+    }
+
+    // Stronger center gravity to prevent nodes from drifting too far
+    float center_strength = 0.015f * mass * ramp_up_factor;  // Apply ramp_up to center gravity too
+    float center_dist = sqrtf(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z);
+    if (center_dist > 3.0f) { // Apply at shorter distances
+        float center_factor = center_strength * (center_dist - 3.0f) / center_dist;
+        total_force.x -= pos.x * center_factor;
+        total_force.y -= pos.y * center_factor;
+        total_force.z -= pos.z * center_factor;
+    }
+
+    // Calculate total force magnitude
+    float force_magnitude = sqrtf(
+        total_force.x * total_force.x +
+        total_force.y * total_force.y +
+        total_force.z * total_force.z
+    );
+
+    // Scale down excessive forces to prevent explosion
+    if (force_magnitude > MAX_FORCE) {
+        float scale_factor = MAX_FORCE / force_magnitude;
+        total_force.x *= scale_factor;
+        total_force.y *= scale_factor;
+        total_force.z *= scale_factor;
+
+        // Additional logging to help debug extreme forces after randomization
+        if (idx == 0 && iteration_count < 5)
+            printf("Force clamped from %f to %f (iteration %d)\\n", force_magnitude, MAX_FORCE, iteration_count);
+    }
+
+    // Apply damping and bounded forces to velocity
+    vel.x = vel.x * (1.0f - damping) + fminf(MAX_FORCE, fmaxf(-MAX_FORCE, total_force.x)) * dt;
+    vel.y = vel.y * (1.0f - damping) + fminf(MAX_FORCE, fmaxf(-MAX_FORCE, total_force.y)) * dt;
+    vel.z = vel.z * (1.0f - damping) + fminf(MAX_FORCE, fmaxf(-MAX_FORCE, total_force.z)) * dt;
+
+    // Apply STRICT velocity cap to prevent runaway momentum
+    float vel_magnitude = sqrtf(vel.x*vel.x + vel.y*vel.y + vel.z*vel.z);
+    if (vel_magnitude > MAX_VELOCITY) {
+        float scale_factor = MAX_VELOCITY / vel_magnitude;
+        vel.x *= scale_factor;
+        vel.y *= scale_factor;
+        vel.z *= scale_factor;
+    }
+
+    // Update position
+    pos.x += vel.x * dt;
+    pos.y += vel.y * dt;
+    pos.z += vel.z * dt;
+
+    // Progressive boundary approach - stronger the further you go
+    if (viewport_bounds > 0.0f && iteration_count > 10) { // Only apply boundary after initial stabilization
+        float soft_margin = 0.3f * viewport_bounds; // 30% soft boundary
+        float bound_with_margin = viewport_bounds - soft_margin;
+
+        // For each axis, if position exceeds boundary:
+        // 1. Clamp position to boundary
+        // 2. Reverse velocity with damping
+
+        if (fabsf(pos.x) > bound_with_margin) {
+            pos.x *= 0.92f; // Pull back by 8%
+            // Also add dampening to velocity in this direction
+            vel.x *= 0.85f;
+        }
+        if (fabsf(pos.y) > bound_with_margin) {
+            pos.y *= 0.92f; // Pull back by 8%
+            vel.y *= 0.85f;
+        }
+        if (fabsf(pos.z) > bound_with_margin) {
+            pos.z *= 0.92f; // Pull back by 8%
+            vel.z *= 0.85f;
+        }
+    }
+
+    // Store results back
+    nodes[idx].position[0] = pos.x;
+    nodes[idx].position[1] = pos.y;
+    nodes[idx].position[2] = pos.z;
+    nodes[idx].velocity[0] = vel.x;
+    nodes[idx].velocity[1] = vel.y;
+    nodes[idx].velocity[2] = vel.z;
+
+    // Debug output for first node
+    if (idx == 0 && (iteration_count < 5 || iteration_count % 20 == 0)) {
+        float force_mag = sqrtf(
+            total_force.x * total_force.x +
+            total_force.y * total_force.y +
+            total_force.z * total_force.z
+        );
+        printf("Node %d: force_mag=%f, pos=(%f,%f,%f), vel=(%f,%f,%f)\\n",
+            idx, force_mag,
+            pos.x, pos.y, pos.z,
+            vel.x, vel.y, vel.z);
+
+        // More detailed logging during initialization
+        if (iteration_count < WARMUP_ITERATIONS)
+            printf("Node %d: iteration=%d, ramp_up=%f, damping=%f\\n", idx, iteration_count, ramp_up_factor, damping);
+    }
+}
+}
+Use code with caution.
+Rust
+Explanation of Changes and Debugging Strategy:
+
+Prioritized Debugging: The most crucial issue is the physics simulation not working. Fixing this will likely make the other problems (labels, edges) much easier to diagnose.
+
+GPU vs. CPU:
+
+Focus on compute_forces.cu (GPU): Since your logs show the GPU is intended but not working, the primary focus should be on getting this working. The provided compute_forces.cu has been significantly improved with comments and better handling of edge cases.
+
+CUDA Installation and Access: Double-check inside the container that nvidia-smi works, that the CUDA toolkit is correctly installed, and that the cudarc crate in Cargo.toml is configured for the exact CUDA version you have installed. Any mismatch here will cause problems.
+
+GPUCompute::new: Add more detailed error logging in this function. Specifically, log the error from CudaDevice::new(0). This will tell you why the GPU device creation is failing.
+
+GPUCompute::test_gpu(): This function is a good start, but it needs to be more comprehensive. Ideally, it should try to compile and run a very simple CUDA kernel to verify that the entire CUDA toolchain is working.
+
+CPU Fallback (Temporary): If you absolutely cannot get the GPU working, focus on debugging calculate_layout_cpu in GraphService.rs. Add extensive logging to this function to track the values of all variables at each step.
+
+Node Label Issues:
+
+NodeMetadataManager.createMetadataLabel():
+
+displayName: I've added a nodeLabel parameter and prioritized it. This is CRITICAL. The Node object itself should have a label property, and that should be the primary source of the display name. The metadata.name should only be a fallback. This change ensures that the createMetadataLabel function uses the correct label.
+
+Logging: Added more detailed logging to this function to track where the label text is coming from.
+
+nodeIdToMetadataId: The logic for populating this map has been improved.
+
+170.5s
+continue
+
+//In src/rendering/node/NodeInstanceManager.ts
+
+    /**
+     * Get the numeric ID of a node from its instance index.
+     * @param index Instance index in the InstancedMesh
+     * @returns Node ID or undefined if not found
+     */
+    getNodeId(index: number): string | undefined {
+        return Array.from(this.nodeIndices.entries()).find(([_id, idx]) => idx === index)?.[0];
+    }
+
+    /**
+     * Get the instance index for a given node ID.
+     * @param nodeId Numeric node ID
+     * @returns Instance index or undefined if not found
+     */
+    getInstanceIndex(nodeId: string): number | undefined {
+        return this.nodeIndices.get(nodeId);
+    }
+Use code with caution.
+TypeScript
+// In src/visualization/MetadataVisualizer.ts
+
+    /**
+     * Map a node ID to a metadata ID (filename) for proper labeling
+     * This is crucial for connecting numeric IDs with human-readable names
+     */
+    mapNodeIdToMetadataId(nodeId: string, metadataId: string) {
+        if (!metadataId || metadataId === "undefined" || metadataId === "Unknown") {
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Skipping invalid metadata ID mapping for node ${nodeId}: "${metadataId}"`);
+            }
+            return;
+        }
+
+        const prevMapping = this.nodeIdToMetadataId.get(nodeId);
+        if (prevMapping && prevMapping !== metadataId) {
+            logger.info(
+                `Updated node ID ${nodeId} mapping from "${prevMapping}" to "${metadataId}"`,
+                createDataMetadata({ nodeId, previousMapping: prevMapping, newMapping: metadataId })
+            );
+        }
+
+        this.nodeIdToMetadataId.set(nodeId, metadataId);
+        if (!this.metadataIdToNodeId.has(metadataId)) {
+            this.metadataIdToNodeId.set(metadataId, nodeId);
+        }
+
+        if (!prevMapping || debugState.isNodeDebugEnabled()) {
+            logger.info(`Mapped node ID ${nodeId} to metadata ID "${metadataId}"`);
+        }
+    }
+    
+    /**
+     * Get the metadata ID (filename) for a given node ID
+     */
+    getMetadataId(nodeId: string): string | undefined {
+        return this.nodeIdToMetadataId.get(nodeId);
+    }
+
+    /**
+     * Get the node ID for a given metadata ID (filename)
+     */
+    getNodeId(metadataId: string): string | undefined {
+        return this.metadataIdToNodeId.get(metadataId);
+    }
+
+    /**
+     * Get the label for a node - uses the mapped metadata name if available
+     */
+    getLabel(nodeId: string): string {
+        return this.nodeIdToMetadataId.get(nodeId) || nodeId;
+    }
+Use code with caution.
+TypeScript
+//In src/state/graphData.ts
+
+    /**
+     * Process node data from incoming updates
+     * @param nodes The array of nodes to process
+     */
+    processNodeData(nodes: Node[]) {
+        nodes.forEach((node) => {
+            if (!this.validateNodeId(node.id)) {
+                logger.warn(`Skipping node with invalid ID format: ${node.id}`);
+                return;
+            }
+            const existingNode = this.nodes.get(node.id);
+            if (existingNode) {
+                // Node exists, update position and velocity
+                existingNode.data.position.copy(node.data.position);
+                if (node.data.velocity) {
+                    existingNode.data.velocity.copy(node.data.velocity);
+                }
+
+                // Update metadata mapping if name is present and different
+                const metadataId = node.metadataId || node.label || node.id;
+                if (metadataId && metadataId !== node.id && metadataId.length > 0) {
+                    this.nodeIdToMetadataId.set(node.id, metadataId);
+                    if (debugState.isNodeDebugEnabled()) {
+                        throttledDebugLog(`Updated metadata mapping: ${node.id} -> ${metadataId}`);
+                    }
+                }
+
+                if (node.data.metadata?.name && node.data.metadata.name !== node.id && node.data.metadata.name.length > 0) {
+                    existingNode.data.metadata = {
+                        ...existingNode.data.metadata,
+                        ...node.data.metadata
+                    };
+                }
+
+            } else {
+                // New node, add it
+                const metadataId = node.metadataId || node.label;
+                if (metadataId && metadataId !== node.id && metadataId.length > 0) {
+                    this.nodeIdToMetadataId.set(node.id, metadataId);
+                    if (debugState.isNodeDebugEnabled()) {
+                        throttledDebugLog(`New node mapping: ${node.id} -> ${metadataId}`);
+                    }
+                }
+                this.nodes.set(node.id, node);
+            }
+        });
+    }
+Use code with caution.
+TypeScript
+//In src/rendering/node/NodeManagerFacade.ts
+    getNodeId(index: number): string | undefined {
+        return this.instanceManager.getNodeId(index);
+    }
+
+    getInstanceIndex(nodeId: string): number | undefined {
+        return this.instanceManager.getInstanceIndex(nodeId);
+    }
+Use code with caution.
+TypeScript
+//In src/services/graph_service.rs
+    pub async fn build_graph_from_metadata(metadata: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
+        // Check if a rebuild is already in progress
+        info!("Building graph from {} metadata entries", metadata.len());
+        debug!("Building graph from {} metadata entries", metadata.len());
+
+        if GRAPH_REBUILD_IN_PROGRESS.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst).is_err() {
+            warn!("Graph rebuild already in progress, skipping duplicate rebuild");
+            return Err("Graph rebuild already in progress".into());
+        }
+
+        // Create a guard struct to ensure the flag is reset when this function returns
+        struct RebuildGuard;
+        impl Drop for RebuildGuard {
+            fn drop(&mut self) {
+                GRAPH_REBUILD_IN_PROGRESS.store(false, Ordering::SeqCst);
+            }
+        }
+        // This guard will reset the flag when it goes out of scope
+        let _guard = RebuildGuard;
+
+        let mut graph = GraphData::new();
+        let mut edge_map = HashMap::new();
+        let mut node_map = HashMap::new();
+
+        // First pass: Create nodes from files in metadata
+        let mut valid_nodes = HashSet::new();
+        debug!("Creating nodes from {} metadata entries", metadata.len());
+        for file_name in metadata.keys() {
+            let node_id = file_name.trim_end_matches(".md").to_string();
+            valid_nodes.insert(node_id);
+        }
+        debug!("Created valid_nodes set with {} nodes", valid_nodes.len());
+
+        // Create nodes for all valid node IDs
+        for node_id in &valid_nodes {
+            // Get metadata for this node, including the node_id if available
+            let metadata_entry = graph.metadata.get(&format!("{}.md", node_id));
+            let stored_node_id = metadata_entry.map(|m| m.node_id.clone());
+
+            // Create node with stored ID or generate a new one if not available
+            let mut node = Node::new_with_id(node_id.clone(), stored_node_id);
+            graph.id_to_metadata.insert(node.id.clone(), node_id.clone());
+
+            // Get metadata for this node
+            if let Some(metadata) = metadata.get(&format!("{}.md", node_id)) {
+                // Set file size which also calculates mass
+                node.set_file_size(metadata.file_size as u64);  // This will update both file_size and mass
+
+                // Set the node label to the file name without extension
+                // This will be used as the display name for the node
+                node.label = metadata.file_name.trim_end_matches(".md").to_string();
+
+                // Set visual properties from metadata
+                node.size = Some(metadata.node_size as f32);
+
+                // Add metadata fields to node's metadata map
+                // Add all relevant metadata fields to ensure consistency
+                node.metadata.insert("fileName".to_string(), metadata.file_name.clone());
+
+                // Add name field (without .md extension) for client-side metadata ID mapping
+                if metadata.file_name.ends_with(".md") {
+                    let name = metadata.file_name[..metadata.file_name.len() - 3].to_string();
+                    node.metadata.insert("name".to_string(), name.clone());
+                    node.metadata.insert("metadataId".to_string(), name);
+                } else {
+                    node.metadata.insert("name".to_string(), metadata.file_name.clone());
+                    node.metadata.insert("metadataId".to_string(), metadata.file_name.clone());
+                }
+
+                node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
+                node.metadata.insert("nodeSize".to_string(), metadata.node_size.to_string());
+                node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
+                node.metadata.insert("sha1".to_string(), metadata.sha1.clone());
+                node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
+
+                if !metadata.perplexity_link.is_empty() {
+                    node.metadata.insert("perplexityLink".to_string(), metadata.perplexity_link.clone());
+                }
+
+                if let Some(last_process) = metadata.last_perplexity_process {
+                    node.metadata.insert("lastPerplexityProcess".to_string(), last_process.to_string());
+                }
+
+                // We don't add topic_counts to metadata as it would create circular references
+                // and is already used to create edges
+
+                // Ensure flags is set to 1 (default active state)
+                node.data.flags = 1;
+            }
+
+            let node_clone = node.clone();
+            graph.nodes.push(node_clone);
+            // Store nodes in map by numeric ID for efficient lookups
+            node_map.insert(node.id.clone(), node);
+        }
+
+        // Store metadata in graph
+        debug!("Storing {} metadata entries in graph", metadata.len());
+        graph.metadata = metadata.clone();
+        debug!("Created {} nodes in graph", graph.nodes.len());
+        // Second pass: Create edges from topic counts
+        for (source_file, metadata) in metadata.iter() {
+            let source_id = source_file.trim_end_matches(".md").to_string();
+            debug!("Processing edges for source file: {}", source_file);
+            // Find the node with this metadata_id to get its numeric ID
+            let source_node = graph.nodes.iter().find(|n| n.metadata_id == source_id);
+            if source_node.is_none() {
+                continue; // Skip if node not found
+            }
+            let source_numeric_id = source_node.unwrap().id.clone();
+
+            // Process outbound links from this file to other topics
+            for (target_file, count) in &metadata.topic_counts {
+                let target_id = target_file.trim_end_matches(".md").to_string();
+                // Find the node with this metadata_id to get its numeric ID
+                let target_node = graph.nodes.iter().find(|n| n.metadata_id == target_id);
+                debug!("  Processing potential edge: {} -> {} (count: {})", source_id, target_id, count);
+                if target_node.is_none() {
+                    continue; // Skip if node not found
+                }
+                let target_numeric_id = target_node.unwrap().id.clone();
+                debug!("  Found target node: {} (ID: {})", target_id, target_numeric_id);
+
+                // Only create edge if both nodes exist and they're different
+                if source_numeric_id != target_numeric_id {
+                    let edge_key = if source_numeric_id < target_numeric_id {
+                        (source_numeric_id.clone(), target_numeric_id.clone())
+                    } else {
+                        (target_numeric_id.clone(), source_numeric_id.clone())
+                    };
+
+                    debug!("  Creating/updating edge: {:?} with weight {}", edge_key, count);
+                    // Sum the weights for bi-directional references
+                    edge_map.entry(edge_key)
+                        .and_modify(|w| *w += *count as f32)
+                        .or_insert(*count as f32);
+                }
+            }
+        }
+
+        // Log edge_map contents before transformation
+        debug!("Edge map contains {} unique connections", edge_map.len());
+        for ((source, target), weight) in &edge_map {
+            debug!("Edge map entry: {} -- {} (weight: {})", source, target, weight);
+        }
+
+        debug!("Converting edge map to {} edges", edge_map.len());
+        graph.edges = edge_map.into_iter()
+            .map(|((source, target), weight)| {
+                Edge::new(source, target, weight)
+            })
+            .collect();
+
+        // Initialize random positions
+        Self::initialize_random_positions(&mut graph);
+
+        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
+        debug!("Completed graph build: {} nodes, {} edges", graph.nodes.len(), graph.edges.len());
+        Ok(graph)
+    }
+Use code with caution.
+TypeScript
+Key Changes and Explanations:
+
+NodeInstanceManager:
+
+Added getNodeId(index) and getInstanceIndex(nodeId) methods to provide a clear mapping between the instance index (used internally by InstancedMesh) and the node's ID (used for data updates).
+
+Added logging to show when the manager is initialized.
+
+Added a check in updateNodePositions to ensure that the manager is initialized before attempting to update node positions.
+
+Added nodeIdToInstanceId map to store the mapping
+
+Added Debug logging
+
+Added nodeMeshes map to store the relationship between node IDs and their meshes.
+
+NodeMetadataManager:
+
+Added nodeIdToMetadataId and metadataIdToNodeId maps to track the relationship between numeric node IDs and metadata IDs (filenames).
+
+Added mapNodeIdToMetadataId method to explicitly handle the mapping. This is crucial for ensuring that the correct label is associated with the correct node, even if the node ID is numeric.
+
+Added getMetadataId and getNodeId methods for retrieving the IDs.
+
+Added getLabel method to prioritize the label source (nodeLabel > metadata.name > metadata.id).
+
+Added more detailed logging to createMetadataLabel to help track down where the label text is coming from.
+
+Added updateMetadataPosition to update the position of existing labels.
+
+Added clearAllLabels to clear all existing labels.
+
+Added setXRMode to handle layer changes for XR mode.
+
+Added validateVector3 to check for invalid vector values.
+
+GraphDataManager:
+
+Added nodeIdToMetadataId map to store the mapping between node IDs and metadata IDs.
+
+Added processNodeData method to handle incoming node data, including creating new nodes and updating existing ones.
+
+Added processEdgeData method to handle incoming edge data.
+
+Added updateNodePositions method to update node positions from binary data.
+
+Added pendingEdges to handle edges that reference nodes that haven't been loaded yet.
+
+Added processPendingEdges to process edges once all nodes are loaded.
+
+Added isGraphDataComplete flag to track whether all graph data has been loaded.
+
+Added binaryUpdatesEnabled flag to control whether binary updates are processed.
+
+Added updateThrottler to throttle node position updates.
+
+Added lastPositionUpdate to track the last update time.
+
+Added nodeUpdateQueue and nodeUpdateTimer to batch node position updates.
+
+Added clearAllLabels to clear all labels.
+
+Added setBinaryUpdatesEnabled to enable/disable binary updates.
+
+Added retryWebSocketConfiguration to handle WebSocket connection issues.
+
+Added getGraphDataMut to get a mutable reference to the graph data.
+
+Added getNodeMapMut to get a mutable reference to the node map.
+
+Added getGPUCompute to get the GPU compute instance.
+
+Added updateNodePositions to handle position updates.
+
+Added initializeRandomPositions to initialize node positions.
+
+Added calculate_layout_with_retry to handle GPU calculation retries.
+
+Added calculate_layout_cpu as a fallback for when GPU calculation fails.
+
+GraphVisualization:
+
+Added nodeManager, edgeManager, and metadataVisualizer properties.
+
+Initialized NodeManagerFacade, EdgeManager, and MetadataVisualizer in the constructor.
+
+Added handleSettingsUpdate to apply settings changes to all components.
+
+Added updateNodePositions to update node positions.
+
+Added initializeWebSocket to handle WebSocket connection and message handling.
+
+Added initializeScene to set up the scene and initialize components.
+
+Added dispose to clean up resources.
+
+Added startLoadingTimeout and clearLoadingTimeout to handle loading timeouts.
+
+Added showLoadingError to display error messages.
+
+Added update to handle frame updates.
+
+Added componentsReady flag to ensure components are initialized before use.
+
+Added pendingUpdates to queue settings updates.
+
+Added lastUpdateTime to track the last update time.
+
+Added frameCount to track the frame count.
+
+Added updateThrottler to throttle updates.
+
+Added isRandomizationInProgress and randomizedNodeIds to track randomization.
+
+Added hasReceivedBinaryUpdate to track if binary updates have been received.
+
+**`
+
+96.2s
+continue
+
+setBinaryProtocolStatus` to track the status of the binary protocol.
+    *   Added `onConnectionStatusChange` handler to enable binary updates when the WebSocket is connected.
+    *   Added `onBinaryMessage` handler to process incoming binary data.
+    *   Added `showLoadingIndicator` and `hideLoadingIndicator` to manage the loading indicator.
+    *   Added `updateMetadataVisualization` to update metadata labels.
+    *   Added `randomizeNodePositions` to trigger node position randomization.
+    *   Added `animate` to handle frame updates.
+    *   Added `checkPerformance` to monitor performance and apply optimizations.
+    *   Subscribed to `system.debug` settings to enable/disable debug logging.
+    *   Added `pendingUpdates` to queue settings updates and apply them in batches.
+    *   Added `lastUpdateTime` to track the last update time.
+
+*   **`WebSocketService`:**
+    *   Added `nodeNameToIndexMap` to store the mapping between node names and numeric indices.
+    *   Added `nextNodeIndex` to track the next available node index.
+    *   Added `lastNodePositions` to store the last sent node positions.
+    *   Added `pendingNodeUpdates` to queue node position updates.
+    *   Added `updateNodePositions` to handle incoming node position updates.
+    *   Added `sendNodeUpdates` to send node position updates to the server.
+    *   Added `handleBinaryMessage` to process incoming binary data.
+    *   Added `tryDecompress` to handle compressed binary data.
+    *   Added `compressIfNeeded` to compress outgoing binary data.
+    *   Added `connectionStatusHandler` to handle connection status changes.
+    *   Added `loadingStatusHandler` to handle loading status changes.
+    *   Added `heartbeatInterval` to keep the WebSocket connection alive.
+    *   Added `clearHeartbeat` to clear the heartbeat interval.
+    *   Added `handleReconnect` to handle WebSocket reconnections.
+    *   Added `sendRawBinaryData` to send raw binary data.
+    *   Added `processNodeUpdateQueue` to process queued node updates.
+    *   Added `enableRandomization` to enable/disable server-side randomization.
+
+*   **`Node` (in `socket_flow_messages.ts`):**
+    *   Added `metadataId` field to store the original filename.
+    *   Added `new_with_id` constructor to allow specifying the ID.
+    *   Added `set_file_size` method to calculate mass based on file size.
+    *   Added `x`, `y`, `z`, `vx`, `vy`, `vz` getters and setters for convenience.
+    *   Added `metadata` field to store node metadata.
+
+*   **`BinaryNodeData` (in `socket_flow_messages.ts`):**
+    *   Changed `position` and `velocity` to use `Vec3Data` for consistency.
+    *   Added `mass`, `flags`, and `padding` fields (server-side only).
+
+*   **`GraphService` (Rust):**
+    *   Added `node_map` to store nodes by their numeric ID.
+    *   Added `build_graph_from_metadata` to build the graph from metadata.
+    *   Added `initialize_random_positions` to initialize node positions randomly.
+    *   Added `calculate_layout_with_retry` to handle GPU calculation retries.
+    *   Added `calculate_layout_cpu` as a fallback for when GPU calculation fails.
+    *   Added `get_node_positions` to retrieve node positions.
+    *   Added `get_graph_data_mut` and `get_node_map_mut` to get mutable references.
+    *   Added `get_gpu_compute` to get the GPU compute instance.
+    *   Added `update_node_positions` to handle position updates.
+    *   Added `initialize_gpu` to initialize the GPU compute system.
+    *   Added `GRAPH_REBUILD_IN_PROGRESS` flag to prevent concurrent rebuilds.
+
+*   **`Metadata` (Rust):**
+    *   Added `node_id` field to store the numeric node ID.
+
+*   **`Edge` (Rust):**
+    *   Ensured that the `Edge` struct uses `String` for `source` and `target` to match the `Node` struct.
+
+*   **`utils/compute_forces.cu` (CUDA):**
+    *   Added comments to explain the logic.
+    *   Improved force calculations.
+    *   Added a check for `is_active` flag (though it's always true in the current implementation).
+    *   Added stronger center gravity.
+    *   Added progressive force application.
+    *   Added stricter velocity cap.
+    *   Added logging for debugging.
+
+*   **`config/feature_access.rs` and `config/feature_access_test.rs` (Rust):**
+    *   Added feature access control logic for enabling/disabling features based on user roles and environment variables.
+
+*   **`handlers/settings_handler.rs` (Rust):**
+    *   Added endpoints to clear user settings cache and all settings caches.
+    *   Improved settings update logic to handle power user privileges and caching.
+
+*   **`app_state.rs` (Rust):**
+    *   Added `feature_access` field to manage feature access control.
+    *   Added helper methods for checking feature access.
+
+*   **`main.rs` (Rust):**
+    *   Initialized `FeatureAccess` in `AppState`.
+    *   Added logging for settings loading and GPU initialization.
+    *   Added a delay to allow GPU computation to run before accepting client connections.
+
+*   **`lib.rs` (Rust):**
+    *   Added `feature_access` to the module list.
+
+*   **`handlers/nostr_handler.rs` (Rust):**
+    *   Added feature access checks for Nostr authentication and API key updates.
+    *   Added endpoints for checking power user status and available features.
+
+These changes address the core issues:
+
+1.  **Node Labels:** By ensuring consistent ID mapping and prioritizing the `nodeLabel` in `createMetadataLabel`, the correct labels should now be displayed. The `nodeIdToMetadataId` map is crucial for this.
+
+2.  **Physics Simulation:** The focus on `calculate_layout_cpu` (and ideally, getting the GPU version working) is the key to fixing the node distribution.  The added logging and checks will help pinpoint the exact cause of the problem.  The changes to damping and velocity clamping should also improve stability.
+
+3.  **Edge Display:** Once the node positions are correct, the edges should display correctly.
+
+4. **Improved Debugging:** Extensive logging has been added to help diagnose issues.
+
+5. **Feature Access Control:** Added feature access control logic.
+
+6. **Settings Handling:** Improved settings handling and caching.
+
+7. **Binary Protocol:** Ensured that the binary protocol uses numeric IDs for nodes.
+
+8. **Error Handling:** Improved error handling and logging throughout the client and server.
+
+9. **Code Clarity:** Improved code clarity and comments.
+
+10. **Data Validation:** Added validation for node positions and velocities.
+
+ Binary Protocol Validation:
+ Detailed Logging: Enhance the encode/decode routines in binary_protocol.rs to include logs that indicate the size, structure, and content of binary messages.
+ Data Integrity Check: Introduce a checksum or hash in the binary payload to validate the data during transmission.
+ Boundary Conditions: Verify that the minimum required data is present before attempting to decode (e.g., Data too small error handling).
+
+ Graph Building Functions:
+ Single Source of Truth: Refactor GraphService::build_graph and GraphService::build_graph_from_metadata so that all nodes and edges are created in one central location.
+ Link Consistency: Ensure that every created edge accurately references its source and target nodes, with proper cross-checking against the node list.
+
+2. WebSocket Connection & Communication
+ Server-Side Connection Handling:
+ Actix Review: Audit the WebSocket handling code in socket_flow_handler.rs to check for proper handling of connection events, errors, and disconnections.
+ Error Logging: Make sure that any connection drops or errors are logged with detailed error messages and stack traces if available.
+
+ Client-Side Reconnection Strategy:
+ Exponential Backoff: Enhance the WebSocketService to implement an exponential backoff strategy (with jitter) on reconnection attempts.
+ Maximum Attempts: Set a limit on the number of reconnection attempts before failing over or alerting the user.
+ Status Indicators: Optionally add UI feedback to show connection status (e.g., Reconnecting, Connection lost).
+
+ Heartbeat Mechanism:
+ Regular Ping/Pong: Ensure that both client and server periodically exchange heartbeat messages.
+ Timeout Handling: Implement timeouts to detect inactive connections and automatically trigger a reconnection.
+ Robustness Tests: Test scenarios with network latency or temporary network loss to verify heartbeat resilience.
+
+ Configuration Review:
+ WebSocket Settings: Double-check that timeout, buffer size, and protocol settings match between the client, server, and any proxy (e.g., Nginx).
+ CORS and SSL: Verify that the WebSocket connection complies with security policies (CORS, SSL certificates) to prevent connection issues.
+
+3. Performance Optimization
+ Reduce Log Spam:
+ Logging Levels: Adjust logging levels (e.g., DEBUG vs. INFO) so that verbose logs are only active in development.
+ Throttling: Implement throttling mechanisms for logging repeated errors, especially those that occur in tight loops (e.g., Skipping edge warnings).
+
+ Optimize Rendering:
+ Profiling: Use browser developer tools to profile rendering performance. Identify bottlenecks in SceneManager and NodeManagerFacade.
+ Frustum Culling & LOD: Implement or optimize frustum culling, level-of-detail techniques, and object instancing for better rendering performance.
+
+ Batch Updates:
+ Chunked Updates: Ensure GraphDataManager batches updates into manageable chunks rather than sending a flood of individual updates.
+ Asynchronous Processing: Use async/await to process batches without blocking the main thread.
+
+ GPU Compute Restoration:
+ File Restoration: Restore missing CUDA source (compute_forces.cu) and compiled PTX (compute_forces.ptx) files.
+ CUDA Environment: Verify that the server has the proper CUDA libraries installed and configured.
+ Fallback Checks: Add logging to detect when GPU compute fails and provide clear diagnostics.
+
+ Memory Management:
+ Dispose of Objects: Audit disposal of Three.js objects such as geometries, materials, and textures to avoid memory leaks.
+ Profiling Tools: Use browser memory profiling tools to monitor memory usage during graph updates and cleanup cycles.
+
+4. Settings Loading & Configuration
+ File Permissions and Paths:
+ Verify Access: Ensure that the settings file (commonly settings.yaml) is accessible with proper read/write permissions by the server process.
+ Path Consistency: Double-check file path configurations to prevent path resolution errors.
+
+ Serialization/Deserialization:
+ Data Types: Validate that all data types in the Settings struct and its sub-structures are correctly handled during serialization and deserialization.
+ Error Handling: Improve error messages for deserialization failures so that missing or malformed settings are clearly reported.
+
+5. Restoration of Missing Files (Critical)
+ Project Metadata:
+ package.json: Restore this file to correctly manage dependencies, scripts, and build configurations.
+
+ Environment Configuration:
+ .env File: Re-create or restore the .env file with all necessary environment variables (API keys, database URIs, etc.).
+
+ CUDA and Utility Files:
+ Compute Files: Recover src/utils/compute_forces.cu and compute_forces.ptx to enable GPU-accelerated physics calculations.
+
+ Client-Side Resources:
+ Audio & UI Components: Restore missing files such as client/audio/AudioPlayer.ts, client/components/settings/ValidationErrorDisplay.ts, and CSS files like client/ui/ModularControlPanel.css.
+ Directory Completeness: Ensure that all directories under client/state, client/types, client/utils, and client/xr are restored with their referenced files.
+
+ Server-Side Files (Rust):
+ Critical Modules: Recover missing Rust files in directories including src/utils, src/types, src/config, src/services, src/handlers, src/models, and test files in src/utils/tests.
+
+6. Nostr Authentication
+ Authentication Flow Review:
+ Session Handling: Review the session validation logic in nostr_handler.rs and NostrService to address Invalid session errors.
+ Credential Verification: Verify that the authentication tokens, session keys, and API endpoints are correctly configured and handled on both client and server sides.
+7. Code Structure & Refactoring
+ General Error Handling:
+ Try/Catch Blocks: Insert try/catch blocks where necessary to prevent uncaught exceptions.
+ Error Propagation: Ensure errors are logged with sufficient context and propagated up the stack only when needed.
+
+ Code Clarity & Maintainability:
+ Function Breakdown: Decompose large functions into smaller ones with clear responsibilities.
+ Consistent Naming: Enforce a consistent naming convention for functions, variables, and modules.
+ Inline Comments: Add descriptive comments especially in complex sections or where protocol specifics are implemented.
+
+ Type Safety and Async Operations:
+ TypeScript Best Practices: Use TypeScript interfaces and types extensively to enforce consistency.
+ Async/Await Patterns: Refactor asynchronous operations to use async/await with proper error handling and, where beneficial, use Promise.all for concurrent operations.
+
+ GraphDataManager Refactoring:
+ Separation of Concerns: Divide responsibilities between graph data management and update/communication logic.
+ Clear Interfaces: Define clear interfaces for modules that handle graph data versus those that communicate with the WebSocket.
+
+ NodeManagerFacade Refactoring:
+ Visual Object Management: Restrict its role to managing Three.js objects.
+ Delegate Communication: Delegate any WebSocket or data update communications to GraphDataManager or a dedicated service.
+
+ ModularControlPanel Improvements:
+ Control Creation: Use a switch statement or mapping structure to handle different control types (slider, toggle, color, select) robustly.
+ UI Consistency: Ensure that all controls follow a consistent design pattern and error handling.
+
+ HologramShaderMaterial Update:
+ Uniform-Based Updates: Modify the update method so that it adjusts a uniform value for opacity rather than changing the property directly.
+ needsUpdate Flag: Ensure that the materials needsUpdate flag is properly set when changes occur.
+
+ SceneManager Animation:
+ requestAnimationFrame: Replace any use of setTimeout for animations with requestAnimationFrame for smoother rendering cycles.
+
+ XRInteractionManager Enhancements:
+ Input Translation: Map raw XR input (hand tracking, controller events) to high-level actions (e.g., select node, drag node, rotate graph).
+ Component Communication: Ensure that these actions are communicated to the appropriate components or services.
+
+ WebSocketService Message Handling:
+ Robust Parsing: Strengthen the onBinaryMessage handler to accommodate various message sizes and potential errors.
+ Initialization Checks: Verify that the GraphDataManager is initialized before processing messages.
+
+ FileService Error Handling:
+ Graceful Failures: Improve FileService::fetch_and_process_files to log errors per file and continue processing the rest without crashing.
+
+8. Shader Testing & Compatibility
+ Cross-Browser Testing:
+ shader-test.html & shader-test.js: Run shader tests on all target browsers to validate that shader compilation and rendering work as expected.
+ Shader Adjustments: If any browser reports errors, adjust shader code (e.g., precision qualifiers, varying usage) for compatibility.
+Final Considerations
+Documentation & Tests:
+ Document all changes in the codebase and update any relevant README or technical documentation.
+ Add or update unit/integration tests for critical modules (graph building, WebSocket communication, settings loading) to prevent regressions.
+
+Progress Tracking:
+ Use this checklist as an evolving document and tick items off as they are implemented and verified.
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100755
index 00000000..b0d2a190
--- /dev/null
+++ b/README.md
@@ -0,0 +1,669 @@
+# LogseqXR: Immersive WebXR Visualization for Logseq Knowledge Graphs
+
+![image](https://github.com/user-attachments/assets/269a678d-88a5-42de-9d67-d73b64f4e520)
+
+**Inspired by the innovative work of Prof. Rob Aspin:** [https://github.com/trebornipsa](https://github.com/trebornipsa)
+
+![P1080785_1728030359430_0](https://github.com/user-attachments/assets/3ecac4a3-95d7-4c75-a3b2-e93deee565d6)
+
+## About LogseqXR
+
+LogseqXR transforms your Logseq knowledge base into an immersive 3D visualization that you can explore in VR/AR. Experience your ideas as tangible objects in space, discover new connections, and interact with your knowledge in ways never before possible.
+
+## Quick Links
+
+- [Project Overview](docs/overview/introduction.md)
+- [Technical Architecture](docs/overview/architecture.md)
+- [Development Setup](docs/development/setup.md)
+- [API Documentation](docs/api/index.md)
+- [Contributing Guidelines](docs/contributing/guidelines.md)
+
+## Documentation Structure
+
+### Overview
+- [Introduction & Features](docs/overview/introduction.md)
+- [System Architecture](docs/overview/architecture.md)
+
+### Technical Documentation
+- [WebSocket Communication](docs/technical/websockets.md)
+- [Binary Protocol](docs/technical/binary-protocol.md)
+- [Performance Optimizations](docs/technical/performance.md)
+- [Class Diagrams](docs/technical/class-diagrams.md)
+
+### Development
+- [Setup Guide](docs/development/setup.md)
+- [Debugging Guide](docs/development/debugging.md)
+
+### API Documentation
+- [API Overview](docs/api/index.md)
+- [REST API](docs/api/rest.md)
+- [WebSocket API](docs/api/websocket.md)
+
+### Deployment
+- [Docker Deployment](docs/deployment/docker.md)
+
+### Contributing
+- [Contributing Guidelines](docs/contributing/guidelines.md)
+
+### Diagrams
+
+```mermaid
+graph TB
+    %% Frontend Components
+    subgraph Frontend
+        UI[User Interface Layer]
+        VR[WebXR Controller]
+        WS[WebSocket Client]
+        GPU[GPU Compute Layer]
+        ThreeJS[Three.js Renderer]
+        ChatUI[Chat Interface]
+        GraphUI[Graph Interface]
+        ControlPanel["Modular Control Panel (with Nostr Auth)"]
+        VRControls[VR Control System]
+        WSService[WebSocket Service]
+        DataManager[Graph Data Manager]
+        LayoutEngine[Layout Engine]
+        SpaceMouse[SpaceMouse Controller]
+        PlatformManager[Platform Manager]
+        XRSession[XR Session Manager]
+        XRInit[XR Initializer]
+        SceneManager[Scene Manager]
+        NodeManager[Enhanced Node Manager]
+        EdgeManager[Edge Manager]
+        HologramManager[Hologram Manager]
+        TextRenderer[Text Renderer]
+        SettingsStore[Settings Store]
+    end
+
+    %% Backend Components
+    subgraph Backend
+        Server[Actix Web Server]
+        FileH[File Handler]
+        GraphH[Graph Handler]
+        WSH[WebSocket Handler]
+        PerplexityH[Perplexity Handler]
+        RagFlowH[RagFlow Handler]
+        VisualizationH[Visualization Handler]
+        NostrH[Nostr Handler]
+        HealthH[Health Handler]
+        PagesH[Pages Handler]
+        SettingsH[Settings Handler]
+        FileS[File Service]
+        GraphS[Graph Service]
+        GPUS[GPU Compute Service]
+        PerplexityS[Perplexity Service]
+        RagFlowS[RagFlow Service]
+        SpeechS[Speech Service]
+        NostrS[Nostr Service]
+        WSManager[WebSocket Manager]
+        GPUCompute[GPU Compute]
+        Compression[Compression Utils]
+        AudioProc[Audio Processor]
+        MetadataStore[Metadata Store]
+        ProtectedSettings[Protected Settings]
+    end
+
+    %% External Components
+    subgraph External
+        GitHub[GitHub API]
+        Perplexity[Perplexity AI]
+        RagFlow[RagFlow API]
+        OpenAI[OpenAI API]
+        NostrAPI[Nostr API]
+    end
+
+    %% Connections between Frontend Components
+    UI --> ChatUI
+    UI --> GraphUI
+    UI --> ControlPanel
+    UI --> VRControls
+
+    VR --> ThreeJS
+    WS --> WSService
+    WSService --> Server
+
+    %% Connections between Backend Components
+    Server --> FileH
+    Server --> GraphH
+    Server --> WSH
+    Server --> PerplexityH
+    Server --> RagFlowH
+    Server --> VisualizationH
+    Server --> NostrH
+    Server --> HealthH
+    Server --> PagesH
+    Server --> SettingsH
+
+    FileH --> FileS
+    GraphH --> GraphS
+    WSH --> WSManager
+    PerplexityH --> PerplexityS
+    RagFlowH --> RagFlowS
+    NostrH --> NostrS
+
+    %% Connections to External Components
+    FileS --> GitHub
+    PerplexityS --> Perplexity
+    RagFlowS --> RagFlow
+    SpeechS --> OpenAI
+    NostrS --> NostrAPI
+
+    %% Styling for clarity
+    style Frontend fill:#f9f,stroke:#333,stroke-width:2px
+    style Backend fill:#bbf,stroke:#333,stroke-width:2px
+    style External fill:#bfb,stroke:#333,stroke-width:2px
+```
+
+### Class Diagram
+
+```mermaid
+classDiagram
+    class App {
+        +sceneManager: SceneManager
+        +nodeManager: EnhancedNodeManager
+        +edgeManager: EdgeManager
+        +hologramManager: HologramManager
+        +textRenderer: TextRenderer
+        +websocketService: WebSocketService
+        +settingsStore: SettingsStore
+        +platformManager: PlatformManager
+        +xrSessionManager: XRSessionManager
+        +start()
+        +initializeEventListeners()
+        +handleSettingsUpdate(settings: Settings)
+        +dispose()
+    }
+
+    class SceneManager {
+        -static instance: SceneManager
+        +scene: Scene
+        +camera: Camera
+        +renderer: Renderer
+        +controls: Controls
+        +composer: Composer
+        +getInstance(canvas: HTMLCanvasElement): SceneManager
+        +getScene(): Scene
+        +getRenderer(): Renderer
+        +getCamera(): Camera
+        +start()
+        +handleSettingsUpdate(settings: Settings)
+        +cleanup()
+    }
+
+    class WebsocketService {
+        -static instance: WebsocketService
+        +socket: WebSocket
+        +listeners: Object
+        +reconnectAttempts: number
+        +maxReconnectAttempts: number
+        +reconnectInterval: number
+        +getInstance(): WebsocketService
+        +connect()
+        +onBinaryMessage(callback: function)
+        +onSettingsUpdate(callback: function)
+        +onConnectionStatusChange(callback: function)
+        +sendMessage(data: object)
+        +close()
+    }
+
+    class AppState {
+        +graph_service: GraphService
+        +gpu_compute: Option<Arc<RwLock<GPUCompute>>>
+        +settings: Arc<RwLock<Settings>>
+        +protected_settings: Arc<RwLock<ProtectedSettings>>
+        +metadata: Arc<RwLock<MetadataStore>>
+        +github_client: Arc<GitHubClient>
+        +content_api: Arc<ContentAPI>
+        +perplexity_service: Option<Arc<PerplexityService>>
+        +ragflow_service: Option<Arc<RAGFlowService>>
+        +nostr_service: Option<web::Data<NostrService>>
+        +ragflow_conversation_id: String
+        +active_connections: Arc<AtomicUsize>
+        +new()
+        +increment_connections(): usize
+        +decrement_connections(): usize
+        +get_api_keys(pubkey: str): ApiKeys
+        +get_nostr_user(pubkey: str): Option<NostrUser>
+        +validate_nostr_session(pubkey: str, token: str): bool
+        +update_nostr_user_api_keys(pubkey: str, api_keys: ApiKeys): Result<NostrUser>
+    }
+
+    class GraphService {
+        +build_graph(app_state: AppState): Result<GraphData>
+        +calculate_layout(gpu_compute: GPUCompute, graph: GraphData, params: SimulationParams): Result<void>
+        +initialize_random_positions(graph: GraphData)
+    }
+
+    class EnhancedNodeManager {
+        +scene: Scene
+        +settings: Settings
+        +nodeMeshes: Map<string, Mesh>
+        +updateNodes(nodes: Node[])
+        +updateNodePositions(nodes: NodeData[])
+        +handleSettingsUpdate(settings: Settings)
+        +dispose()
+    }
+
+    class SpeechService {
+        +websocketManager: WebSocketManager
+        +settings: Settings
+        +start(receiver: Receiver<SpeechCommand>)
+        +initialize(): Result<void>
+        +send_message(message: string): Result<void>
+        +close(): Result<void>
+        +set_tts_provider(use_openai: boolean): Result<void>
+    }
+
+    class NostrService {
+        +settings: Settings
+        +validate_session(pubkey: str, token: str): bool
+        +get_user(pubkey: str): Option<NostrUser>
+        +update_user_api_keys(pubkey: str, api_keys: ApiKeys): Result<NostrUser>
+    }
+
+    App --> SceneManager
+    App --> WebsocketService
+    App --> EnhancedNodeManager
+    SceneManager --> WebXRVisualization
+    WebsocketService --> GraphDataManager
+    AppState --> GraphService
+    AppState --> NostrService
+    AppState --> SpeechService
+```
+
+### Sequence Diagram
+
+```mermaid
+sequenceDiagram
+    participant Client as Client (Browser)
+    participant Platform as PlatformManager
+    participant XR as XRSessionManager
+    participant Scene as SceneManager
+    participant Node as EnhancedNodeManager
+    participant Edge as EdgeManager
+    participant Hologram as HologramManager
+    participant Text as TextRenderer
+    participant WS as WebSocketService
+    participant Settings as SettingsStore
+    participant Server as Actix Server
+    participant AppState as AppState
+    participant FileH as FileHandler
+    participant GraphH as GraphHandler
+    participant WSH as WebSocketHandler
+    participant PerplexityH as PerplexityHandler
+    participant RagFlowH as RagFlowHandler
+    participant NostrH as NostrHandler
+    participant SettingsH as SettingsHandler
+    participant FileS as FileService
+    participant GraphS as GraphService
+    participant GPUS as GPUService
+    participant PerplexityS as PerplexityService
+    participant RagFlowS as RagFlowService
+    participant NostrS as NostrService
+    participant SpeechS as SpeechService
+    participant WSM as WebSocketManager
+    participant GitHub as GitHub API
+    participant Perplexity as Perplexity AI
+    participant RagFlow as RagFlow API
+    participant OpenAI as OpenAI API
+    participant Nostr as Nostr API
+
+    %% Server initialization and AppState setup
+    activate Server
+    Server->>Server: Load settings.yaml & env vars (config.rs)
+    alt Settings Load Error
+        Server-->>Client: Error Response (500)
+    else Settings Loaded Successfully
+        Server->>AppState: new() (app_state.rs)
+        activate AppState
+            AppState->>GPUS: initialize_gpu_compute()
+            activate GPUS
+                GPUS->>GPUS: setup_compute_pipeline()
+                GPUS->>GPUS: load_wgsl_shaders()
+                GPUS-->>AppState: GPU Compute Instance
+            deactivate GPUS
+            
+            AppState->>WSM: initialize()
+            activate WSM
+                WSM->>WSM: setup_binary_protocol()
+                WSM-->>AppState: WebSocket Manager
+            deactivate WSM
+            
+            AppState->>SpeechS: start()
+            activate SpeechS
+                SpeechS->>SpeechS: initialize_tts()
+                SpeechS-->>AppState: Speech Service
+            deactivate SpeechS
+            
+            AppState->>NostrS: initialize()
+            activate NostrS
+                NostrS->>NostrS: setup_nostr_client()
+                NostrS-->>AppState: Nostr Service
+            deactivate NostrS
+            
+            AppState-->>Server: Initialized AppState
+        deactivate AppState
+
+        Server->>FileS: fetch_and_process_files()
+        activate FileS
+            FileS->>GitHub: fetch_files()
+            activate GitHub
+                GitHub-->>FileS: Files or Error
+            deactivate GitHub
+            
+            loop For Each File
+                FileS->>FileS: should_process_file()
+                alt File Needs Processing
+                    FileS->>PerplexityS: process_file()
+                    activate PerplexityS
+                        PerplexityS->>Perplexity: analyze_content()
+                        Perplexity-->>PerplexityS: Analysis Results
+                        PerplexityS-->>FileS: Processed Content
+                    deactivate PerplexityS
+                    FileS->>FileS: save_metadata()
+                end
+            end
+            FileS-->>Server: Processed Files
+        deactivate FileS
+
+        Server->>GraphS: build_graph()
+        activate GraphS
+            GraphS->>GraphS: create_nodes_and_edges()
+            GraphS->>GPUS: calculate_layout()
+            activate GPUS
+                GPUS->>GPUS: bind_gpu_buffers()
+                GPUS->>GPUS: dispatch_compute_shader()
+                GPUS->>GPUS: read_buffer_results()
+                GPUS-->>GraphS: Updated Positions
+            deactivate GPUS
+            GraphS-->>Server: Graph Data
+        deactivate GraphS
+    end
+
+    %% Client and Platform initialization
+    Client->>Platform: initialize()
+    activate Platform
+        Platform->>Platform: detect_capabilities()
+        Platform->>Settings: load_settings()
+        activate Settings
+            Settings->>Settings: validate_settings()
+            Settings-->>Platform: Settings Object
+        deactivate Settings
+        
+        Platform->>WS: connect()
+        activate WS
+            WS->>Server: ws_connect
+            Server->>WSH: handle_connection()
+            WSH->>WSM: register_client()
+            WSM-->>WS: connection_established
+            
+            WS->>WS: setup_binary_handlers()
+            WS->>WS: initialize_reconnection_logic()
+            
+            WSM-->>WS: initial_graph_data (Binary)
+            WS->>WS: decode_binary_message()
+        deactivate WS
+        
+        Platform->>XR: initialize()
+        activate XR
+            XR->>XR: check_xr_support()
+            XR->>Scene: create()
+            activate Scene
+                Scene->>Scene: setup_three_js()
+                Scene->>Scene: setup_render_pipeline()
+                Scene->>Node: initialize()
+                activate Node
+                    Node->>Node: create_geometries()
+                    Node->>Node: setup_materials()
+                deactivate Node
+                Scene->>Edge: initialize()
+                activate Edge
+                    Edge->>Edge: create_line_geometries()
+                    Edge->>Edge: setup_line_materials()
+                deactivate Edge
+                Scene->>Hologram: initialize()
+                activate Hologram
+                    Hologram->>Hologram: setup_hologram_shader()
+                    Hologram->>Hologram: create_hologram_geometry()
+                deactivate Hologram
+                Scene->>Text: initialize()
+                activate Text
+                    Text->>Text: load_fonts()
+                    Text->>Text: setup_text_renderer()
+                deactivate Text
+            deactivate Scene
+        deactivate XR
+    deactivate Platform
+
+    Note over Client, Nostr: User Interaction Flows
+
+    %% User drags a node
+    alt User Drags Node
+        Client->>Node: handle_node_drag()
+        Node->>WS: send_position_update()
+        WS->>Server: binary_position_update
+        Server->>GraphS: update_layout()
+        GraphS->>GPUS: recalculate_forces()
+        GPUS-->>Server: new_positions
+        Server->>WSM: broadcast()
+        WSM-->>WS: binary_update
+        WS->>Node: update_positions()
+        Node-->>Client: render_update
+    end
+
+    %% User asks a question
+    alt User Asks Question
+        Client->>RagFlowH: send_query()
+        RagFlowH->>RagFlowS: process_query()
+        activate RagFlowS
+            RagFlowS->>RagFlow: get_context()
+            RagFlow-->>RagFlowS: relevant_context
+            RagFlowS->>OpenAI: generate_response()
+            OpenAI-->>RagFlowS: ai_response
+            RagFlowS-->>Client: streaming_response
+        deactivate RagFlowS
+        alt Speech Enabled
+            Client->>SpeechS: synthesize_speech()
+            activate SpeechS
+                SpeechS->>OpenAI: text_to_speech()
+                OpenAI-->>SpeechS: audio_stream
+                SpeechS-->>Client: audio_data
+            deactivate SpeechS
+        end
+    end
+
+    %% User updates the graph
+    alt User Updates Graph
+        Client->>FileH: update_file()
+        FileH->>FileS: process_update()
+        FileS->>GitHub: create_pull_request()
+        GitHub-->>FileS: pr_created
+        FileS-->>Client: success_response
+    end
+
+    %% WebSocket reconnection flow
+    alt WebSocket Reconnection
+        WS->>WS: connection_lost()
+        loop Until Max Attempts
+            WS->>WS: attempt_reconnect()
+            WS->>Server: ws_connect
+            alt Connection Successful
+                Server-->>WS: connection_established
+                WSM-->>WS: resend_graph_data
+                WS->>Node: restore_state()
+            else Connection Failed
+                Note right of WS: Continue reconnect attempts
+            end
+        end
+    end
+
+    %% Settings update flow
+    alt Settings Update
+        Client->>SettingsH: update_settings()
+        SettingsH->>AppState: apply_settings()
+        AppState->>WSM: broadcast_settings()
+        WSM-->>WS: settings_update
+        WS->>Settings: update_settings()
+        Settings->>Platform: apply_platform_settings()
+        Platform->>Scene: update_rendering()
+        Scene->>Node: update_visuals()
+        Scene->>Edge: update_visuals()
+        Scene->>Hologram: update_effects()
+    end
+
+    %% Nostr authentication flow
+    alt Nostr Authentication
+        Client->>NostrH: authenticate()
+        NostrH->>NostrS: validate_session()
+        NostrS->>Nostr: verify_credentials()
+        Nostr-->>NostrS: auth_result
+        NostrS-->>Client: session_token
+    end
+
+    deactivate Server
+```
+
+### AR Features Implementation Status
+
+#### Hand Tracking (Meta Quest 3)
+- Implementation in `client/xr/xrSessionManager.ts`
+- Currently addressing:
+  - Performance optimization for AR passthrough mode
+  - Virtual desktop cleanup during AR activation
+  - Type compatibility between `XRHand` and custom `XRHandWithHaptics`
+  - Joint position extraction methods
+
+##### Current Challenges
+- Type mismatches between standard `XRHand` and custom `XRHandWithHaptics`
+- Joint position extraction from `XRJointSpace`
+- Performance optimization in AR passthrough mode
+
+##### Next Steps
+- Implement adapter for `XRHand` to `XRHandWithHaptics` conversion
+- Refactor VisualizationController for native XRHand compatibility
+- Optimize AR mode transitions
+- Enhance Meta Quest 3 performance
+
+## License
+
+This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
+
+## Acknowledgements
+
+- Prof Rob Aspin: For inspiring the project's vision and providing valuable resources.
+- OpenAI: For their advanced AI models powering the question-answering features.
+- Perplexity AI and RAGFlow: For their AI services enhancing content processing and interaction.
+- Three.js: For the robust 3D rendering capabilities utilized in the frontend.
+- Actix: For the high-performance web framework powering the backend server.
+
+### Authentication and Settings Inheritance
+
+#### Unauthenticated Users
+- Use browser's localStorage for settings persistence
+- Settings are stored locally and not synced
+- Default to basic settings visibility
+- Limited to local visualization features
+
+#### Authenticated Users (Nostr)
+- Inherit settings from server's settings.yaml
+- Settings are synced across all authenticated users
+- Access to advanced settings based on role
+
+#### Power Users
+- Full access to all settings
+- Can modify server's settings.yaml
+- Access to advanced API features:
+  - Perplexity API for AI assistance
+  - RagFlow for document processing
+  - GitHub integration for PR management
+  - OpenAI voice synthesis
+- Settings modifications are persisted to settings.yaml
+
+### Settings Inheritance Flow
+
+```mermaid
+graph TD
+    A[Start] --> B{Authenticated?}
+    B -->|No| C[Load Local Settings]
+    B -->|Yes| D[Load Server Settings]
+    D --> E{Is Power User?}
+    E -->|No| F[Apply Read-Only]
+    E -->|Yes| G[Enable Full Access]
+```
+
+### Settings Sync Flow
+
+```mermaid
+graph TD
+    A[Setting Changed] --> B{Authenticated?}
+    B -->|No| C[Save Locally]
+    B -->|Yes| D{Is Power User?}
+    D -->|No| E[Preview Only]
+    D -->|Yes| F[Update Server]
+    F --> G[Sync to All Users]
+```
+
+### Modular Control Panel Architecture
+
+The control panel is built with a modular architecture that supports:
+- Detachable sections
+- Real-time preview integration
+- Drag and drop functionality
+- Dynamic tooltips
+- Performance optimizations
+
+#### Component Structure
+
+```typescript
+interface ModularControlPanelProps {
+  sections: ControlSection[];
+  layout: LayoutConfig;
+  onLayoutChange: (newLayout: LayoutConfig) => void;
+}
+
+interface ControlSection {
+  id: string;
+  title: string;
+  settings: Setting[];
+  isDetached: boolean;
+  position?: { x: number, y: number };
+  size?: { width: number, height: number };
+}
+
+interface Setting {
+  id: string;
+  type: 'slider' | 'toggle' | 'color' | 'select';
+  value: any;
+  metadata: SettingMetadata;
+}
+```
+
+#### Layout Management
+
+```typescript
+interface LayoutConfig {
+  sections: {
+    [sectionId: string]: {
+      position: { x: number, y: number };
+      size: { width: number, height: number };
+      isDetached: boolean;
+      isCollapsed: boolean;
+    };
+  };
+  userPreferences: {
+    showAdvanced: boolean;
+    activeFilters: string[];
+    customOrder: string[];
+  };
+}
+```
+
+#### Performance Optimizations
+
+- ResizeObserver for efficient size tracking
+- Virtual scrolling for large setting lists
+- Debounced real-time preview updates
+- CSS transforms for smooth animations
+- Lazy loading for visual aids
+- Efficient memory management with WeakMap
+- Real-time preview integration with ~60fps target
\ No newline at end of file
diff --git a/client/audio/AudioPlayer.ts b/client/audio/AudioPlayer.ts
new file mode 100644
index 00000000..12de08cc
--- /dev/null
+++ b/client/audio/AudioPlayer.ts
@@ -0,0 +1,169 @@
+export interface AudioPlayerOptions {
+    sampleRate?: number;
+    channels?: number;
+    bufferSize?: number;
+}
+
+export class AudioPlayer {
+    private audioContext: AudioContext;
+    private audioQueue: AudioBuffer[] = [];
+    private isPlaying = false;
+    private gainNode: GainNode;
+    private options: Required<AudioPlayerOptions>;
+
+    constructor(options: AudioPlayerOptions = {}) {
+        this.options = {
+            sampleRate: options.sampleRate || 24000, // Kokoros default sample rate
+            channels: options.channels || 1,
+            bufferSize: options.bufferSize || 4096,
+        };
+
+        this.audioContext = new AudioContext({
+            sampleRate: this.options.sampleRate,
+            latencyHint: 'interactive',
+        });
+
+        this.gainNode = this.audioContext.createGain();
+        this.gainNode.connect(this.audioContext.destination);
+        this.setVolume(1.0); // Default volume
+    }
+
+    public setVolume(value: number): void {
+        if (value >= 0 && value <= 1) {
+            this.gainNode.gain.value = value;
+        }
+    }
+
+    public async handleAudioChunk(data: ArrayBuffer, isLastChunk: boolean): Promise<void> {
+        try {
+            const audioBuffer = await this.decodeAudioData(data);
+            this.audioQueue.push(audioBuffer);
+            
+            if (!this.isPlaying) {
+                await this.playNextChunk();
+            }
+            
+            if (isLastChunk) {
+                this.clear(); // Clear the queue after playing the last chunk
+            }
+        } catch (error) {
+            console.error('Error handling audio chunk:', error);
+        }
+    }
+
+    private async decodeAudioData(data: ArrayBuffer): Promise<AudioBuffer> {
+        return new Promise((resolve, reject) => {
+            this.audioContext.decodeAudioData(
+                data,
+                (buffer) => resolve(buffer),
+                (error) => reject(error)
+            );
+        });
+    }
+
+    private async playNextChunk(): Promise<void> {
+        if (this.audioQueue.length === 0) {
+            this.isPlaying = false;
+            return;
+        }
+
+        this.isPlaying = true;
+        const buffer = this.audioQueue.shift()!;
+        const source = this.audioContext.createBufferSource();
+        
+        source.buffer = buffer;
+        source.connect(this.gainNode);
+        
+        return new Promise((resolve) => {
+            source.onended = () => {
+                this.playNextChunk().then(resolve);
+            };
+            
+            source.start();
+        });
+    }
+
+    public async resume(): Promise<void> {
+        if (this.audioContext.state === 'suspended') {
+            await this.audioContext.resume();
+        }
+    }
+
+    public async pause(): Promise<void> {
+        if (this.audioContext.state === 'running') {
+            await this.audioContext.suspend();
+        }
+    }
+
+    public stop(): void {
+        this.audioQueue = [];
+        this.isPlaying = false;
+        this.audioContext.close();
+    }
+
+    public clear(): void {
+        this.audioQueue = [];
+    }
+
+    public getState(): AudioContextState {
+        return this.audioContext.state;
+    }
+
+    public getQueueLength(): number {
+        return this.audioQueue.length;
+    }
+}
+
+// Singleton instance for global access
+let audioPlayerInstance: AudioPlayer | null = null;
+
+export function getAudioPlayer(options?: AudioPlayerOptions): AudioPlayer {
+    if (!audioPlayerInstance) {
+        audioPlayerInstance = new AudioPlayer(options);
+    }
+    return audioPlayerInstance;
+}
+
+export function disposeAudioPlayer(): void {
+    if (audioPlayerInstance) {
+        audioPlayerInstance.stop();
+        audioPlayerInstance = null;
+    }
+}
+
+// Error handling
+export class AudioPlayerError extends Error {
+    constructor(message: string) {
+        super(message);
+        this.name = 'AudioPlayerError';
+    }
+}
+
+// Types for WebSocket messages
+export interface VoiceDataMessage {
+    chunkId: number;
+    isFinal: boolean;
+    data: ArrayBuffer;
+}
+
+// Example usage:
+/*
+const player = getAudioPlayer();
+
+// Handle incoming WebSocket message
+ws.onmessage = async (event) => {
+    if (event.data instanceof ArrayBuffer) {
+        const view = new DataView(event.data);
+        const messageType = view.getUint8(0);
+        
+        if (messageType === 1) { // VoiceData type
+            const chunkId = view.getUint32(1, true);
+            const isFinal = Boolean(view.getUint8(5));
+            const dataSize = view.getUint32(6, true);
+            const audioData = event.data.slice(10, 10 + dataSize);
+            
+            await player.handleAudioChunk(audioData, isFinal);
+        }
+    }
+};
+*/
\ No newline at end of file
diff --git a/client/components/settings/ValidationErrorDisplay.ts b/client/components/settings/ValidationErrorDisplay.ts
new file mode 100644
index 00000000..99ef7e0a
--- /dev/null
+++ b/client/components/settings/ValidationErrorDisplay.ts
@@ -0,0 +1,162 @@
+import { ValidationError } from '../../types/settings/validation';
+import { SettingsStore } from '../../state/SettingsStore';
+import { formatSettingName } from '../../types/settings/utils';
+
+export class ValidationErrorDisplay {
+    private container: HTMLDivElement;
+    private errorList: HTMLUListElement;
+    private unsubscribe: (() => void) | null = null;
+
+    constructor(parentElement: HTMLElement) {
+        // Create container
+        this.container = document.createElement('div');
+        this.container.className = 'validation-error-container';
+        this.container.style.cssText = `
+            display: none;
+            position: fixed;
+            bottom: 20px;
+            right: 20px;
+            max-width: 400px;
+            background-color: #fee;
+            border: 1px solid #faa;
+            border-radius: 4px;
+            padding: 12px;
+            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
+            z-index: 1000;
+            font-family: Arial, sans-serif;
+        `;
+
+        // Create header
+        const header = document.createElement('div');
+        header.style.cssText = `
+            display: flex;
+            justify-content: space-between;
+            align-items: center;
+            margin-bottom: 8px;
+        `;
+
+        const title = document.createElement('h3');
+        title.textContent = 'Settings Validation Errors';
+        title.style.cssText = `
+            margin: 0;
+            color: #d32f2f;
+            font-size: 16px;
+        `;
+
+        const closeButton = document.createElement('button');
+        closeButton.innerHTML = '&times;';
+        closeButton.style.cssText = `
+            background: none;
+            border: none;
+            color: #666;
+            font-size: 20px;
+            cursor: pointer;
+            padding: 0 4px;
+        `;
+        closeButton.onclick = () => this.hide();
+
+        header.appendChild(title);
+        header.appendChild(closeButton);
+        this.container.appendChild(header);
+
+        // Create error list
+        this.errorList = document.createElement('ul');
+        this.errorList.style.cssText = `
+            margin: 0;
+            padding-left: 20px;
+            color: #d32f2f;
+            font-size: 14px;
+        `;
+        this.container.appendChild(this.errorList);
+
+        // Add to parent
+        parentElement.appendChild(this.container);
+
+        // Subscribe to validation errors
+        this.subscribeToValidationErrors();
+    }
+
+    private subscribeToValidationErrors(): void {
+        const settingsStore = SettingsStore.getInstance();
+        this.unsubscribe = settingsStore.subscribeToValidationErrors((errors: ValidationError[]) => {
+            if (errors.length > 0) {
+                this.showErrors(errors);
+            } else {
+                this.hide();
+            }
+        });
+    }
+
+    private showErrors(errors: ValidationError[]): void {
+        // Clear existing errors
+        this.errorList.innerHTML = '';
+
+        // Add new errors
+        errors.forEach(error => {
+            const li = document.createElement('li');
+            li.style.marginBottom = '4px';
+            
+            // Format the error message
+            const settingName = formatSettingName(error.path.split('.').pop() || '');
+            const formattedPath = error.path.split('.').map(formatSettingName).join('  ');
+            
+            li.innerHTML = `
+                <strong>${settingName}:</strong> ${error.message}<br>
+                <small style="color: #666;">Path: ${formattedPath}</small>
+            `;
+            
+            this.errorList.appendChild(li);
+        });
+
+        // Show the container
+        this.container.style.display = 'block';
+
+        // Auto-hide after 5 seconds
+        setTimeout(() => this.hide(), 5000);
+    }
+
+    private hide(): void {
+        this.container.style.display = 'none';
+    }
+
+    public dispose(): void {
+        if (this.unsubscribe) {
+            this.unsubscribe();
+            this.unsubscribe = null;
+        }
+        this.container.remove();
+    }
+
+    // Helper method to create an instance and attach it to the document body
+    public static initialize(): ValidationErrorDisplay {
+        return new ValidationErrorDisplay(document.body);
+    }
+}
+
+// Add CSS to document
+const style = document.createElement('style');
+style.textContent = `
+    .validation-error-container {
+        animation: slideIn 0.3s ease-out;
+    }
+
+    @keyframes slideIn {
+        from {
+            transform: translateX(100%);
+            opacity: 0;
+        }
+        to {
+            transform: translateX(0);
+            opacity: 1;
+        }
+    }
+
+    .validation-error-container button:hover {
+        color: #000;
+    }
+
+    .validation-error-container ul li {
+        line-height: 1.4;
+    }
+`;
+document.head.appendChild(style);
\ No newline at end of file
diff --git a/client/config/featureFlags.ts b/client/config/featureFlags.ts
new file mode 100644
index 00000000..d663381b
--- /dev/null
+++ b/client/config/featureFlags.ts
@@ -0,0 +1,135 @@
+import { createLogger, createErrorMetadata, createDataMetadata } from '../core/logger';
+
+const logger = createLogger('FeatureFlags');
+
+/**
+ * Feature flag configuration interface
+ */
+export interface FeatureFlags {
+    enableLOD: boolean;
+}
+
+/**
+ * Default feature flag values
+ */
+const defaultFlags: FeatureFlags = {
+    enableLOD: true,  // Enable Level of Detail system
+};
+
+/**
+ * Feature flag manager class
+ */
+export class FeatureFlagManager {
+    private static instance: FeatureFlagManager;
+    private flags: FeatureFlags;
+    private listeners: Set<(flags: FeatureFlags) => void>;
+
+    private constructor() {
+        this.flags = { ...defaultFlags };
+        this.listeners = new Set();
+        
+        // Load flags from localStorage if available
+        if (typeof window !== 'undefined' && window.localStorage) {
+            const savedFlags = localStorage.getItem('featureFlags');
+            if (savedFlags) {
+                try {
+                    const parsed = JSON.parse(savedFlags);
+                    this.flags = {
+                        ...defaultFlags,
+                        ...parsed
+                    };
+                    logger.info('Loaded feature flags from localStorage');
+                } catch (error) {
+                    logger.error('Failed to parse feature flags from localStorage:', createErrorMetadata(error));
+                }
+            }
+        }
+    }
+
+    public static getInstance(): FeatureFlagManager {
+        if (!FeatureFlagManager.instance) {
+            FeatureFlagManager.instance = new FeatureFlagManager();
+        }
+        return FeatureFlagManager.instance;
+    }
+
+    /**
+     * Get current state of all feature flags
+     */
+    public getFlags(): FeatureFlags {
+        return { ...this.flags };
+    }
+
+    /**
+     * Check if a specific feature is enabled
+     */
+    public isEnabled(feature: keyof FeatureFlags): boolean {
+        return this.flags[feature];
+    }
+
+    /**
+     * Update feature flags
+     */
+    public updateFlags(updates: Partial<FeatureFlags>): void {
+        const oldFlags = { ...this.flags };
+        this.flags = {
+            ...this.flags,
+            ...updates
+        };
+
+        // Save to localStorage if available
+        if (typeof window !== 'undefined' && window.localStorage) {
+            try {
+                localStorage.setItem('featureFlags', JSON.stringify(this.flags));
+            } catch (error) {
+                logger.error('Failed to save feature flags to localStorage:', createErrorMetadata(error));
+            }
+        }
+
+        // Log changes
+        Object.keys(updates).forEach(key => {
+            const feature = key as keyof FeatureFlags;
+            if (oldFlags[feature] !== this.flags[feature]) {
+                logger.info(`Feature flag "${feature}" changed:`, createDataMetadata({
+                    from: oldFlags[feature],
+                    to: this.flags[feature]
+                }));
+            }
+        });
+
+        // Notify listeners
+        this.notifyListeners();
+    }
+
+    /**
+     * Subscribe to feature flag changes
+     */
+    public subscribe(callback: (flags: FeatureFlags) => void): () => void {
+        this.listeners.add(callback);
+        return () => {
+            this.listeners.delete(callback);
+        };
+    }
+
+    /**
+     * Reset all flags to default values
+     */
+    public reset(): void {
+        this.updateFlags(defaultFlags);
+        logger.info('Reset all feature flags to defaults');
+    }
+
+    private notifyListeners(): void {
+        const flags = this.getFlags();
+        this.listeners.forEach(listener => {
+            try {
+                listener(flags);
+            } catch (error) {
+                logger.error('Error in feature flag listener:', createErrorMetadata(error));
+            }
+        });
+    }
+}
+
+// Export singleton instance
+export const featureFlags = FeatureFlagManager.getInstance();
\ No newline at end of file
diff --git a/client/core/api.ts b/client/core/api.ts
new file mode 100644
index 00000000..ae709ce0
--- /dev/null
+++ b/client/core/api.ts
@@ -0,0 +1,81 @@
+import { API_ENDPOINTS } from './constants';
+
+// Helper function to get auth headers
+export function getAuthHeaders(): HeadersInit {
+    const headers: HeadersInit = {
+        'Content-Type': 'application/json'
+    };
+    
+    const pubkey = localStorage.getItem('nostr_pubkey');
+    const token = localStorage.getItem('nostr_token');
+    if (pubkey && token) {
+        headers['X-Nostr-Pubkey'] = pubkey;
+        headers['Authorization'] = `Bearer ${token}`;
+    }
+    return headers;
+}
+
+// Helper function to build API URLs
+export function buildApiUrl(path: string): string {
+    const protocol = window.location.protocol;
+    const host = window.location.hostname;
+    // Check if we're in production (any visionflow.info domain)
+    const isProduction = host.endsWith('visionflow.info');
+    const base = isProduction 
+        ? `${protocol}//${host}`
+        : `${protocol}//${host}:4000`;
+    return `${base}${path}`; // All paths are already prefixed with /api in constants.ts
+}
+
+// Helper function to build settings URL
+export function buildSettingsUrl(category: string): string {
+    return `${API_ENDPOINTS.SETTINGS_ROOT}/${category}`;
+}
+
+// Helper function to build graph URL
+export function buildGraphUrl(type: 'data' | 'update' | 'paginated'): string {
+    switch (type) {
+        case 'paginated':
+            return API_ENDPOINTS.GRAPH_PAGINATED;
+        case 'update':
+            return API_ENDPOINTS.GRAPH_UPDATE;
+        default:
+            return API_ENDPOINTS.GRAPH_DATA;
+    }
+}
+
+// Helper function to build files URL
+export function buildFilesUrl(path: string): string {
+    return `${API_ENDPOINTS.FILES}/${path}`;
+}
+
+// Helper function to build WebSocket URL
+export function buildWsUrl(): string {
+    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
+    const host = window.location.hostname;
+    // Check if we're in production (any visionflow.info domain)
+    const isProduction = host.endsWith('visionflow.info');
+    
+    if (isProduction) {
+        // For production, use relative path to ensure proper proxy handling
+        return `${protocol}//${host}/wss`;
+    } else {
+        // For development, use port 4000 as specified in the documentation
+        return `${protocol}//${host}:4000/wss`;
+    }
+}
+
+// Helper function to build visualization settings URL
+export function buildVisualizationSettingsUrl(): string {
+    return API_ENDPOINTS.VISUALIZATION_SETTINGS;
+}
+
+// Helper function to build WebSocket control URL
+export function buildWebSocketControlUrl(): string {
+    return API_ENDPOINTS.WEBSOCKET_CONTROL;
+}
+
+// Helper function to build WebSocket settings URL
+export function buildWebSocketSettingsUrl(): string {
+    return API_ENDPOINTS.WEBSOCKET_SETTINGS;
+}
diff --git a/client/core/constants.ts b/client/core/constants.ts
new file mode 100644
index 00000000..910a5261
--- /dev/null
+++ b/client/core/constants.ts
@@ -0,0 +1,99 @@
+/**
+ * Application constants
+ */
+
+// Environment detection
+export const IS_DEVELOPMENT = process.env.NODE_ENV !== 'production';
+
+// API configuration
+export const API_BASE = '';  // Base URL is constructed in buildApiUrl
+
+// API paths
+export const API_PATHS = {
+    SETTINGS: 'user-settings',
+    WEBSOCKET: 'websocket',
+    GRAPH: 'graph',
+    FILES: 'files'
+} as const;
+
+// API endpoints
+export const API_ENDPOINTS = {
+    // Graph endpoints
+    GRAPH_DATA: '/api/graph/data',
+    GRAPH_UPDATE: '/api/graph/update',
+    GRAPH_PAGINATED: '/api/graph/data/paginated',
+    
+    // Settings endpoints
+    SETTINGS_ROOT: '/api/user-settings',
+    VISUALIZATION_SETTINGS: '/api/user-settings/visualization',
+    WEBSOCKET_SETTINGS: '/api/settings/websocket',
+    
+    // WebSocket endpoints
+    WEBSOCKET_CONTROL: '/api/websocket/control',
+    
+    // File endpoints
+    FILES: '/api/files',
+    
+    // Auth endpoints
+    AUTH_NOSTR: '/api/auth/nostr',
+    AUTH_NOSTR_VERIFY: '/api/auth/nostr/verify',
+    AUTH_NOSTR_LOGOUT: '/api/auth/nostr/logout'
+} as const;
+
+export type ApiEndpoints = typeof API_ENDPOINTS[keyof typeof API_ENDPOINTS];
+
+// Settings categories matching server's snake_case
+export const SETTINGS_CATEGORIES = {
+    // Visualization settings
+    NODES: 'nodes',
+    EDGES: 'edges',
+    PHYSICS: 'physics',
+    RENDERING: 'rendering',
+    ANIMATIONS: 'animations',
+    LABELS: 'labels',
+    BLOOM: 'bloom',
+    HOLOGRAM: 'hologram',
+    XR: 'xr',
+    
+    // System settings
+    NETWORK: 'network',
+    WEBSOCKET: 'websocket',
+    DEBUG: 'debug',
+} as const;
+
+// WebSocket configuration
+export const WS_MESSAGE_QUEUE_SIZE = 1000;
+
+// Binary protocol configuration
+export const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
+export const VERSION_OFFSET = 0;    // No version header
+export const BINARY_CHUNK_SIZE = 1000; // Number of nodes to process in one chunk
+export const NODE_POSITION_SIZE = 24;  // 6 floats * 4 bytes (position + velocity)
+
+// Performance configuration
+export const THROTTLE_INTERVAL = 16; // ~60fps
+export const EDGE_UPDATE_BATCH_INTERVAL = 16; // Batch edge updates at ~60fps
+
+// Visualization constants
+export const NODE_SIZE = 0.5;
+export const NODE_SEGMENTS = 16;
+export const EDGE_RADIUS = 0.25;
+export const EDGE_SEGMENTS = 8;
+
+// Font configuration
+export const FONT_URL = '/fonts/Roboto-Regular.woff2';
+
+// Colors
+export const NODE_COLOR = 0x4CAF50;  // Material Design Green
+export const NODE_HIGHLIGHT_COLOR = 0xff4444;  // Material Design Red
+export const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300
+export const BACKGROUND_COLOR = 0x212121;  // Material Design Grey 900
+export const LABEL_COLOR = 0xFFFFFF;  // White
+
+// Debug configuration
+export const DEBUG = {
+    NETWORK_PANEL: {
+        MAX_MESSAGES: 50,
+        ENABLED: IS_DEVELOPMENT
+    }
+};
diff --git a/client/core/debugState.ts b/client/core/debugState.ts
new file mode 100644
index 00000000..bde2844e
--- /dev/null
+++ b/client/core/debugState.ts
@@ -0,0 +1,195 @@
+import { SettingsStore } from '../state/SettingsStore';
+
+export interface DebugState {
+    enabled: boolean;
+    logFullJson: boolean;
+    enableDataDebug: boolean;
+    enableWebsocketDebug: boolean;
+    logBinaryHeaders: boolean;
+    // New debug categories for enhanced monitoring
+    enablePhysicsDebug: boolean;
+    enableNodeDebug: boolean;
+    enableShaderDebug: boolean;
+    enableMatrixDebug: boolean;
+    enablePerformanceDebug: boolean;
+    // Binary protocol status tracking
+    binaryProtocolEnabled: boolean;
+    binaryProtocolStatus: 'inactive' | 'pending' | 'active' | 'error' | 'failed';
+}
+
+class DebugStateManager {
+    private static instance: DebugStateManager | null = null;
+    private state: DebugState = {
+        enabled: false,
+        logFullJson: false,
+        enableDataDebug: false,
+        enableWebsocketDebug: false,
+        logBinaryHeaders: false,
+        enablePhysicsDebug: false,
+        enableNodeDebug: false,
+        enableShaderDebug: false,
+        enableMatrixDebug: false,
+        enablePerformanceDebug: false,
+        binaryProtocolEnabled: false,
+        binaryProtocolStatus: 'inactive'
+    };
+
+    private constructor() {}
+
+    public static getInstance(): DebugStateManager {
+        if (!DebugStateManager.instance) {
+            DebugStateManager.instance = new DebugStateManager();
+        }
+        return DebugStateManager.instance;
+    }
+
+    public async initialize(): Promise<void> {
+        const settingsStore = SettingsStore.getInstance();
+        await settingsStore.initialize();
+
+        // Load initial debug settings
+        this.state = {
+            enabled: settingsStore.get('system.debug.enabled') as boolean ?? false,
+            logFullJson: settingsStore.get('system.debug.log_full_json') as boolean ?? false,
+            enableDataDebug: settingsStore.get('system.debug.enable_data_debug') as boolean ?? false,
+            enableWebsocketDebug: settingsStore.get('system.debug.enable_websocket_debug') as boolean ?? false,
+            logBinaryHeaders: settingsStore.get('system.debug.log_binary_headers') as boolean ?? false,
+            enablePhysicsDebug: settingsStore.get('system.debug.enable_physics_debug') as boolean ?? false,
+            enableNodeDebug: settingsStore.get('system.debug.enable_node_debug') as boolean ?? false,
+            enableShaderDebug: settingsStore.get('system.debug.enable_shader_debug') as boolean ?? false,
+            enableMatrixDebug: settingsStore.get('system.debug.enable_matrix_debug') as boolean ?? false,
+            enablePerformanceDebug: settingsStore.get('system.debug.enable_performance_debug') as boolean ?? false,
+            binaryProtocolEnabled: false,
+            binaryProtocolStatus: 'inactive' as 'inactive' | 'pending' | 'active' | 'error' | 'failed'
+        };
+
+        // Subscribe to debug setting changes
+        settingsStore.subscribe('system.debug.enabled', (_, value) => {
+            this.state.enabled = value as boolean;
+            this.updateLoggerConfig();
+        });
+
+        settingsStore.subscribe('system.debug.log_full_json', (_, value) => {
+            this.state.logFullJson = value as boolean;
+            this.updateLoggerConfig();
+        });
+
+        settingsStore.subscribe('system.debug.enable_data_debug', (_, value) => {
+            this.state.enableDataDebug = value as boolean;
+        });
+
+        settingsStore.subscribe('system.debug.enable_websocket_debug', (_, value) => {
+            this.state.enableWebsocketDebug = value as boolean;
+        });
+
+        settingsStore.subscribe('system.debug.log_binary_headers', (_, value) => {
+            this.state.logBinaryHeaders = value as boolean;
+        });
+
+        settingsStore.subscribe('system.debug.enable_physics_debug', (_, value) => {
+            this.state.enablePhysicsDebug = value as boolean;
+        });
+
+        settingsStore.subscribe('system.debug.enable_node_debug', (_, value) => {
+            this.state.enableNodeDebug = value as boolean;
+        });
+
+        settingsStore.subscribe('system.debug.enable_shader_debug', (_, value) => {
+            this.state.enableShaderDebug = value as boolean;
+        });
+
+        settingsStore.subscribe('system.debug.enable_matrix_debug', (_, value) => {
+            this.state.enableMatrixDebug = value as boolean;
+        });
+
+        settingsStore.subscribe('system.debug.enable_performance_debug', (_, value) => {
+            this.state.enablePerformanceDebug = value as boolean;
+        });
+
+        // Log initial debug state if enabled
+        if (this.state.enabled) {
+            const { logger } = require('./logger');
+            logger.debug('Debug state initialized', { ...this.state });
+        }
+
+        this.updateLoggerConfig();
+    }
+
+    private updateLoggerConfig(): void {
+        const { LoggerConfig } = require('./logger');
+        LoggerConfig.setGlobalDebug(this.state.enabled);
+        LoggerConfig.setFullJson(this.state.logFullJson);
+    }
+
+    public isEnabled(): boolean {
+        return this.state.enabled;
+    }
+
+    public isWebsocketDebugEnabled(): boolean {
+        return this.state.enabled && this.state.enableWebsocketDebug;
+    }
+
+    public isDataDebugEnabled(): boolean {
+        return this.state.enabled && this.state.enableDataDebug;
+    }
+
+    public shouldLogBinaryHeaders(): boolean {
+        return this.state.enabled && this.state.logBinaryHeaders;
+    }
+
+    public isPhysicsDebugEnabled(): boolean {
+        return this.state.enabled && this.state.enablePhysicsDebug;
+    }
+
+    public isNodeDebugEnabled(): boolean {
+        return this.state.enabled && this.state.enableNodeDebug;
+    }
+
+    public isShaderDebugEnabled(): boolean {
+        return this.state.enabled && this.state.enableShaderDebug;
+    }
+
+    public isMatrixDebugEnabled(): boolean {
+        return this.state.enabled && this.state.enableMatrixDebug;
+    }
+
+    public isPerformanceDebugEnabled(): boolean {
+        return this.state.enabled && this.state.enablePerformanceDebug;
+    }
+
+    public isBinaryProtocolEnabled(): boolean {
+        return this.state.binaryProtocolEnabled;
+    }
+
+    public setBinaryProtocolEnabled(enabled: boolean): void {
+        this.state.binaryProtocolEnabled = enabled;
+        if (!enabled) {
+            this.state.binaryProtocolStatus = 'inactive';
+        }
+    }
+
+    public getBinaryProtocolStatus(): string {
+        return this.state.binaryProtocolStatus;
+    }
+
+    public setBinaryProtocolStatus(status: 'inactive' | 'pending' | 'active' | 'error' | 'failed'): void {
+        this.state.binaryProtocolStatus = status;
+        
+        // If we're setting to active or error, implicitly enable the protocol
+        if (status === 'active' || status === 'pending') {
+            this.state.binaryProtocolEnabled = true;
+        }
+        
+        // Log status changes if debug is enabled
+        if (this.state.enabled && this.state.enableWebsocketDebug) {
+            const { logger } = require('./logger');
+            logger.debug(`Binary protocol status changed to: ${status}`);
+        }
+    }
+
+    public getState(): DebugState {
+        return { ...this.state };
+    }
+}
+
+export const debugState = DebugStateManager.getInstance();
\ No newline at end of file
diff --git a/client/core/logger.ts b/client/core/logger.ts
new file mode 100644
index 00000000..a9d9d2d6
--- /dev/null
+++ b/client/core/logger.ts
@@ -0,0 +1,205 @@
+import { Vector3 } from 'three';
+import { debugState } from './debugState';
+
+let debugEnabled = false;
+let logFullJson = false;
+
+export interface LogMetadata {
+    position?: Vector3;
+    velocity?: Vector3;
+    component?: string;
+    operation?: string;
+    duration?: number;
+    error?: Error | string | unknown;  // Allow various error types
+    nodeId?: string | number;  // Allow both string and number IDs
+    message?: string;  // For string messages
+    status?: number;   // For HTTP status codes
+    size?: number;
+    data?: any;        // For arbitrary data objects
+    stack?: string;    // For error stacks
+    response?: any;    // For API responses
+    [key: string]: any; // Allow for additional metadata
+}
+
+// Helper functions for creating metadata objects
+export const createErrorMetadata = (error: unknown, additionalData?: Record<string, any>): LogMetadata => {
+    const metadata: LogMetadata = {
+        error,
+        message: error instanceof Error ? error.message : String(error),
+        stack: error instanceof Error ? error.stack : undefined,
+        ...additionalData
+    };
+    return metadata;
+};
+
+export const createMessageMetadata = (message: string | number, additionalData?: Record<string, any>): LogMetadata => {
+    const metadata: LogMetadata = {
+        message: String(message),
+        ...additionalData
+    };
+    return metadata;
+};
+
+export const createDataMetadata = (data: any, additionalData?: Record<string, any>): LogMetadata => {
+    const metadata: LogMetadata = {
+        data,
+        ...additionalData
+    };
+    return metadata;
+};
+
+export interface Logger {
+    debug: (message: string, metadata?: LogMetadata) => void;
+    log: (message: string, metadata?: LogMetadata) => void;
+    info: (message: string, metadata?: LogMetadata) => void;
+    warn: (message: string, metadata?: LogMetadata) => void;
+    error: (message: string, metadata?: LogMetadata) => void;
+    physics: (message: string, metadata?: LogMetadata) => void;
+    matrix: (message: string, metadata?: LogMetadata) => void;
+    performance: (message: string, metadata?: LogMetadata) => void;
+    node: (message: string, metadata?: LogMetadata) => void;
+    shader: (message: string, metadata?: LogMetadata) => void;
+}
+
+const MAX_VECTOR_PRECISION = 4;
+const MAX_DURATION_PRECISION = 2;
+
+export function setDebugEnabled(enabled: boolean, fullJson: boolean = false): void {
+    debugEnabled = enabled;
+    logFullJson = fullJson;
+}
+
+export function createLogger(context: string): Logger {
+    const prefix = `[${context}]`;
+    
+    const formatMetadata = (metadata?: LogMetadata): string => {
+        if (!metadata) return '';
+
+        const formattedMetadata: Record<string, any> = {};
+
+        // Format Vector3 values with limited precision
+        if (metadata.position) {
+            formattedMetadata.position = {
+                x: metadata.position.x.toFixed(MAX_VECTOR_PRECISION),
+                y: metadata.position.y.toFixed(MAX_VECTOR_PRECISION),
+                z: metadata.position.z.toFixed(MAX_VECTOR_PRECISION)
+            };
+        }
+
+        if (metadata.velocity) {
+            formattedMetadata.velocity = {
+                x: metadata.velocity.x.toFixed(MAX_VECTOR_PRECISION),
+                y: metadata.velocity.y.toFixed(MAX_VECTOR_PRECISION),
+                z: metadata.velocity.z.toFixed(MAX_VECTOR_PRECISION)
+            };
+        }
+
+        // Format duration with limited precision
+        if (metadata.duration !== undefined) {
+            formattedMetadata.duration = `${metadata.duration.toFixed(MAX_DURATION_PRECISION)}ms`;
+        }
+
+        // Handle error objects
+        if (metadata.error instanceof Error) {
+            formattedMetadata.error = {
+                name: metadata.error.name,
+                message: metadata.error.message,
+                stack: metadata.error.stack
+            };
+        } else if (metadata.error !== undefined) {
+            // Handle non-Error error types
+            formattedMetadata.error = {
+                message: String(metadata.error),
+                type: typeof metadata.error,
+                value: metadata.error
+            };
+        }
+
+        // Copy remaining metadata
+        Object.entries(metadata).forEach(([key, value]) => {
+            if (!formattedMetadata[key] && value !== undefined) {
+                formattedMetadata[key] = value;
+            }
+        });
+
+        if (logFullJson) {
+            return JSON.stringify(formattedMetadata, null, 2);
+        }
+
+        // Compact format for non-full JSON mode
+        const metadataStr = JSON.stringify(formattedMetadata);
+        return metadataStr.length > 2 ? ` ${metadataStr}` : '';
+    };
+
+    // Add timestamp to prefix
+    const getPrefix = () => {
+        const now = new Date();
+        const timestamp = now.toISOString().split('T')[1].slice(0, -1);
+        return `${timestamp} ${prefix}`;
+    };
+    
+    return {
+        debug: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled) {
+                console.debug(getPrefix(), message, formatMetadata(metadata));
+            }
+        },
+        log: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled) {
+                console.log(getPrefix(), message, formatMetadata(metadata));
+            }
+        },
+        info: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled) {
+                console.info(getPrefix(), message, formatMetadata(metadata));
+            }
+        },
+        warn: (message: string, metadata?: LogMetadata): void => {
+            console.warn(getPrefix(), message, formatMetadata(metadata));
+        },
+        error: (message: string, metadata?: LogMetadata): void => {
+            console.error(getPrefix(), message, formatMetadata(metadata));
+        },
+        physics: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled && debugState.isPhysicsDebugEnabled()) {
+                console.debug(`${getPrefix()}[Physics]`, message, formatMetadata(metadata));
+            }
+        },
+        matrix: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled && debugState.isMatrixDebugEnabled()) {
+                console.debug(`${getPrefix()}[Matrix]`, message, formatMetadata(metadata));
+            }
+        },
+        performance: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled && debugState.isPerformanceDebugEnabled()) {
+                console.debug(`${getPrefix()}[Performance]`, message, formatMetadata(metadata));
+            }
+        },
+        node: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled && debugState.isNodeDebugEnabled()) {
+                console.debug(`${getPrefix()}[Node]`, message, formatMetadata(metadata));
+            }
+        },
+        shader: (message: string, metadata?: LogMetadata): void => {
+            if (debugEnabled && debugState.isShaderDebugEnabled()) {
+                console.debug(`${getPrefix()}[Shader]`, message, formatMetadata(metadata));
+            }
+        }
+    };
+}
+
+// Create and export a global logger configuration
+export const LoggerConfig = {
+    setGlobalDebug(enabled: boolean) {
+        debugEnabled = enabled;
+        if (enabled) {
+            console.log(`[Logger] Debug logging enabled`);
+        }
+    },
+    setFullJson(enabled: boolean) {
+        logFullJson = enabled;
+    }
+};
+
+// Create core logger instance
+export const logger = createLogger('core');
diff --git a/client/core/physicsConstants.ts b/client/core/physicsConstants.ts
new file mode 100644
index 00000000..18f6a47b
--- /dev/null
+++ b/client/core/physicsConstants.ts
@@ -0,0 +1,121 @@
+// Physics parameter ranges and defaults in base units (meters, m/s)
+export const PHYSICS_CONSTANTS = {
+    // Attraction force (supplementary cohesion)
+    ATTRACTION: {
+        MIN: 0.001,
+        MAX: 0.05,
+        DEFAULT: 0.01,  // 1cm/s base attraction
+        RECOMMENDED_RANGE: {
+            MIN: 0.005,
+            MAX: 0.05
+        }
+    },
+
+    // Repulsion force (separation between nodes)
+    REPULSION: {
+        MIN: 0.1,
+        MAX: 0.2,
+        DEFAULT: 0.1,  // Base repulsion (with 1/d falloff)
+        RECOMMENDED_RANGE: {
+            MIN: 0.05,
+            MAX: 0.15
+        }
+    },
+
+    // Spring force (linear with distance)
+    SPRING: {
+        MIN: 0.001,
+        MAX: 0.1,
+        DEFAULT: 0.05,  // 5cm/s per meter of stretch
+        RECOMMENDED_RANGE: {
+            MIN: 0.02,
+            MAX: 0.08
+        }
+    },
+
+    // Damping (unitless, fraction of velocity retained)
+    DAMPING: {
+        MIN: 0.5,
+        MAX: 0.95,
+        DEFAULT: 0.95,  // 95% velocity retention
+        RECOMMENDED_RANGE: {
+            MIN: 0.9,
+            MAX: 0.98
+        }
+    },
+
+    // Simulation iterations per frame
+    ITERATIONS: {
+        MIN: 1,
+        MAX: 200,
+        DEFAULT: 100,  // Balance of stability and performance
+        RECOMMENDED_RANGE: {
+            MIN: 50,
+            MAX: 150
+        }
+    },
+
+    // Maximum velocity (meters per second)
+    MAX_VELOCITY: {
+        MIN: 0.01,
+        MAX: 0.5,
+        DEFAULT: 0.1,  // 10cm/s maximum
+        RECOMMENDED_RANGE: {
+            MIN: 0.05,
+            MAX: 0.2
+        }
+    },
+
+    // Collision radius (meters)
+    COLLISION_RADIUS: {
+        MIN: 0.01,
+        MAX: 0.2,
+        DEFAULT: 0.05,  // 5cm radius
+        RECOMMENDED_RANGE: {
+            MIN: 0.03,
+            MAX: 0.1
+        }
+    },
+
+    // Bounds size (meters, half-width of cubic bounds)
+    BOUNDS_SIZE: {
+        MIN: 0.5,
+        MAX: 100.0,
+        DEFAULT: 50.0,  // 50m bounds (100m cube)
+        RECOMMENDED_RANGE: {
+            MIN: 10.0,
+            MAX: 75.0
+        }
+    }
+};
+
+// Helper types for physics parameters
+export type PhysicsParameter = keyof typeof PHYSICS_CONSTANTS;
+export type PhysicsRange = {
+    MIN: number;
+    MAX: number;
+    DEFAULT: number;
+    RECOMMENDED_RANGE: {
+        MIN: number;
+        MAX: number;
+    };
+};
+
+// Helper functions for physics parameters
+export const isWithinPhysicsRange = (param: PhysicsParameter, value: number): boolean => {
+    const range = PHYSICS_CONSTANTS[param];
+    return value >= range.MIN && value <= range.MAX;
+};
+
+export const isWithinRecommendedRange = (param: PhysicsParameter, value: number): boolean => {
+    const range = PHYSICS_CONSTANTS[param].RECOMMENDED_RANGE;
+    return value >= range.MIN && value <= range.MAX;
+};
+
+export const getPhysicsRange = (param: PhysicsParameter): PhysicsRange => {
+    return PHYSICS_CONSTANTS[param];
+};
+
+export const getDefaultPhysicsValue = (param: PhysicsParameter): number => {
+    return PHYSICS_CONSTANTS[param].DEFAULT;
+};
\ No newline at end of file
diff --git a/client/core/resourceMonitor.ts b/client/core/resourceMonitor.ts
new file mode 100644
index 00000000..5ae13682
--- /dev/null
+++ b/client/core/resourceMonitor.ts
@@ -0,0 +1,327 @@
+import { createLogger } from './logger';
+import { WebGLRenderer, Texture, BufferGeometry, Material } from 'three';
+import { debugState } from './debugState';
+
+const logger = createLogger('ResourceMonitor');
+
+/**
+ * ResourceMonitor - Tracks WebGL resources to help identify leaks and performance issues
+ */
+export class ResourceMonitor {
+  private static instance: ResourceMonitor;
+  
+  private renderers: Set<WebGLRenderer> = new Set();
+  private textures: Set<Texture> = new Set();
+  private geometries: Set<BufferGeometry> = new Set();
+  private materials: Set<Material> = new Set();
+  
+  private monitoringEnabled: boolean = false;
+  private monitorInterval: any = null;
+  private monitorFrequency: number = 30000; // 30 seconds (increased from 10)
+  
+  private constructor() {
+    // Private constructor for singleton
+  }
+  
+  public static getInstance(): ResourceMonitor {
+    if (!ResourceMonitor.instance) {
+      ResourceMonitor.instance = new ResourceMonitor();
+    }
+    return ResourceMonitor.instance;
+  }
+  
+  /**
+   * Start monitoring resources
+   * @param frequency Monitoring frequency in milliseconds
+   */
+  public startMonitoring(frequency: number = 10000): void {
+    this.monitoringEnabled = true;
+    this.monitorFrequency = frequency;
+    
+    // Clear any existing interval
+    if (this.monitorInterval) {
+      clearInterval(this.monitorInterval);
+    }
+    
+    // Set up monitoring interval
+    this.monitorInterval = setInterval(() => {
+      this.logResourceUsage();
+    }, this.monitorFrequency);
+    
+    logger.info('Resource monitoring started', {
+      frequency: this.monitorFrequency
+    });
+    
+    // Log initial state
+    this.logResourceUsage();
+  }
+  
+  /**
+   * Stop monitoring resources
+   */
+  public stopMonitoring(): void {
+    this.monitoringEnabled = false;
+    
+    if (this.monitorInterval) {
+      clearInterval(this.monitorInterval);
+      this.monitorInterval = null;
+    }
+    
+    logger.info('Resource monitoring stopped');
+  }
+  
+  /**
+   * Track a WebGL renderer
+   */
+  public trackRenderer(renderer: WebGLRenderer): void {
+    this.renderers.add(renderer);
+    logger.debug('Tracking new WebGL renderer', {
+      rendererId: this.getObjectId(renderer),
+      totalRenderers: this.renderers.size
+    });
+  }
+  
+  /**
+   * Stop tracking a WebGL renderer
+   */
+  public untrackRenderer(renderer: WebGLRenderer): void {
+    this.renderers.delete(renderer);
+    logger.debug('Untracking WebGL renderer', {
+      rendererId: this.getObjectId(renderer),
+      totalRenderers: this.renderers.size
+    });
+  }
+  
+  /**
+   * Track a texture
+   */
+  public trackTexture(texture: Texture): void {
+    this.textures.add(texture);
+    
+    if (this.monitoringEnabled && this.textures.size % 10 === 0) {
+      logger.debug('Tracking new texture', {
+        textureId: this.getObjectId(texture),
+        totalTextures: this.textures.size
+      });
+    }
+  }
+  
+  /**
+   * Stop tracking a texture
+   */
+  public untrackTexture(texture: Texture): void {
+    this.textures.delete(texture);
+    
+    if (this.monitoringEnabled && this.textures.size % 10 === 0) {
+      logger.debug('Untracking texture', {
+        textureId: this.getObjectId(texture),
+        totalTextures: this.textures.size
+      });
+    }
+  }
+  
+  /**
+   * Track a geometry
+   */
+  public trackGeometry(geometry: BufferGeometry): void {
+    this.geometries.add(geometry);
+    
+    if (this.monitoringEnabled && this.geometries.size % 10 === 0) {
+      logger.debug('Tracking new geometry', {
+        geometryId: this.getObjectId(geometry),
+        totalGeometries: this.geometries.size
+      });
+    }
+  }
+  
+  /**
+   * Stop tracking a geometry
+   */
+  public untrackGeometry(geometry: BufferGeometry): void {
+    this.geometries.delete(geometry);
+    
+    if (this.monitoringEnabled && this.geometries.size % 10 === 0) {
+      logger.debug('Untracking geometry', {
+        geometryId: this.getObjectId(geometry),
+        totalGeometries: this.geometries.size
+      });
+    }
+  }
+  
+  /**
+   * Track a material
+   */
+  public trackMaterial(material: Material): void {
+    this.materials.add(material);
+    
+    if (this.monitoringEnabled && this.materials.size % 10 === 0) {
+      logger.debug('Tracking new material', {
+        materialId: this.getObjectId(material),
+        materialType: this.getObjectType(material),
+        totalMaterials: this.materials.size
+      });
+    }
+  }
+  
+  /**
+   * Stop tracking a material
+   */
+  public untrackMaterial(material: Material): void {
+    this.materials.delete(material);
+    
+    if (this.monitoringEnabled && this.materials.size % 10 === 0) {
+      logger.debug('Untracking material', {
+        materialId: this.getObjectId(material),
+        materialType: this.getObjectType(material),
+        totalMaterials: this.materials.size
+      });
+    }
+  }
+  
+  /**
+   * Get a unique identifier for an object
+   */
+  private getObjectId(obj: any): string {
+    // Try to get uuid if available
+    if (obj && typeof obj === 'object') {
+      if (obj.uuid) {
+        return obj.uuid;
+      }
+      
+      // Fall back to object's toString or a random ID
+      return obj.toString() || Math.random().toString(36).substring(2, 10);
+    }
+    
+    return 'unknown';
+  }
+  
+  /**
+   * Get the type of an object
+   */
+  private getObjectType(obj: any): string {
+    if (obj && typeof obj === 'object') {
+      if (obj.type) {
+        return obj.type;
+      }
+      
+      return obj.constructor?.name || typeof obj;
+    }
+    
+    return typeof obj;
+  }
+  
+  /**
+   * Log current resource usage
+   */
+  public logResourceUsage(): void {
+    // Only log detailed resource usage if performance debugging is enabled
+    if (debugState.isPerformanceDebugEnabled()) {
+      logger.performance('WebGL resource usage', {
+        renderers: this.renderers.size,
+        textures: this.textures.size,
+        geometries: this.geometries.size,
+        materials: this.materials.size,
+        memory: this.getMemoryUsage()
+      });
+      
+      // Check for potential issues
+      this.checkForIssues();
+    }
+  }
+  
+  /**
+   * Get memory usage information
+   */
+  private getMemoryUsage(): any {
+    const memory: any = {};
+    
+    // Get browser memory info if available
+    if ((performance as any).memory) {
+      memory.totalJSHeapSize = (performance as any).memory.totalJSHeapSize;
+      memory.usedJSHeapSize = (performance as any).memory.usedJSHeapSize;
+      memory.jsHeapSizeLimit = (performance as any).memory.jsHeapSizeLimit;
+    }
+    
+    return memory;
+  }
+  
+  /**
+   * Check for potential resource issues
+   */
+  private checkForIssues(): void {
+    // Check for too many renderers
+    if (this.renderers.size > 1) {
+      logger.warn('Multiple WebGL renderers detected', {
+        count: this.renderers.size,
+        recommendation: 'Consider using a shared renderer to avoid WebGL context limits'
+      });
+    }
+    
+    // Check for high texture count
+    if (this.textures.size > 100) {
+      logger.warn('High texture count detected', {
+        count: this.textures.size,
+        recommendation: 'Consider using texture atlases or disposing unused textures'
+      });
+    }
+    
+    // Check for high geometry count
+    if (this.geometries.size > 1000) {
+      logger.warn('High geometry count detected', {
+        count: this.geometries.size,
+        recommendation: 'Consider using instanced geometries or merging geometries'
+      });
+    }
+    
+    // Check for high material count
+    if (this.materials.size > 100) {
+      logger.warn('High material count detected', {
+        count: this.materials.size,
+        recommendation: 'Consider sharing materials between objects'
+      });
+    }
+    
+    // Check for memory usage
+    if ((performance as any).memory && (performance as any).memory.usedJSHeapSize > 0.8 * (performance as any).memory.jsHeapSizeLimit) {
+      logger.warn('High memory usage detected', {
+        usedJSHeapSize: (performance as any).memory.usedJSHeapSize,
+        jsHeapSizeLimit: (performance as any).memory.jsHeapSizeLimit,
+        recommendation: 'Consider disposing unused resources or implementing level-of-detail'
+      });
+    }
+  }
+  
+  /**
+   * Dispose all tracked resources
+   */
+  public disposeAll(): void {
+    // Dispose textures
+    this.textures.forEach(texture => {
+      texture.dispose();
+    });
+    this.textures.clear();
+    
+    // Dispose geometries
+    this.geometries.forEach(geometry => {
+      geometry.dispose();
+    });
+    this.geometries.clear();
+    
+    // Dispose materials
+    this.materials.forEach(material => {
+      material.dispose();
+    });
+    this.materials.clear();
+    
+    // Dispose renderers
+    this.renderers.forEach(renderer => {
+      renderer.dispose();
+    });
+    this.renderers.clear();
+    
+    logger.info('All tracked resources disposed');
+  }
+}
+
+// Export singleton instance
+export const resourceMonitor = ResourceMonitor.getInstance(); 
\ No newline at end of file
diff --git a/client/core/types.ts b/client/core/types.ts
new file mode 100644
index 00000000..ed24c102
--- /dev/null
+++ b/client/core/types.ts
@@ -0,0 +1,537 @@
+// Core types for the application
+import { Vector3 as ThreeVector3 } from 'three';
+import { debugState } from './debugState';
+import { createLogger, createDataMetadata } from './logger';
+
+const logger = createLogger('CoreTypes');
+
+export interface Vector3 extends ThreeVector3 {
+}
+
+export interface NodeMetadata {
+  name?: string;
+  file_name?: string;
+  lastModified?: number;
+  links?: string[];
+  references?: string[];
+  fileSize?: number;
+  hyperlinkCount?: number;
+}
+
+export interface NodeData {
+  position: Vector3;
+  velocity: Vector3;
+  metadata?: NodeMetadata;
+}
+
+export interface Node {
+  id: string;
+  metadataId?: string;
+  label?: string;
+  data: {
+    position: Vector3;
+    velocity: Vector3;
+    metadata?: {
+      name?: string;
+      file_name?: string;
+      lastModified?: number;
+      links?: string[];
+      references?: string[];
+      fileSize?: number;
+      hyperlinkCount?: number;
+    };
+  };
+  color?: string;
+}
+
+export interface Position {
+  x: number;
+  y: number;
+  z: number;
+}
+
+export interface Edge {
+  source: string;
+  target: string;
+  id: string;
+  sourcePosition?: Position;
+  targetPosition?: Position;
+  type?: 'default' | 'hologram';
+}
+
+export interface PaginatedGraphData extends GraphData {
+  totalPages: number;
+  currentPage: number;
+  totalItems: number;
+  pageSize: number;
+}
+
+export interface GraphData {
+  nodes: Node[];
+  edges: Edge[];
+  metadata?: any;
+}
+
+// Platform types
+export type Platform = 'desktop' | 'quest' | 'browser';
+
+export interface PlatformCapabilities {
+  xrSupported: boolean;
+  webglSupported: boolean;
+  websocketSupported: boolean;
+  webxr: boolean;
+  handTracking: boolean;
+  planeDetection: boolean;
+}
+
+// Settings interfaces in camelCase
+export interface AnimationSettings {
+  enableMotionBlur: boolean;
+  enableNodeAnimations: boolean;
+  motionBlurStrength: number;
+  selectionWaveEnabled: boolean;
+  pulseEnabled: boolean;
+  rippleEnabled: boolean;
+  edgeAnimationEnabled: boolean;
+  flowParticlesEnabled: boolean;
+}
+
+export interface ARSettings {
+  dragThreshold: number;
+  enableHandTracking: boolean;
+  enableHaptics: boolean;
+  enableLightEstimation: boolean;
+  enablePassthroughPortal: boolean;
+  enablePlaneDetection: boolean;
+  enableSceneUnderstanding: boolean;
+  gestureSsmoothing: number;
+  handMeshColor: string;
+  handMeshEnabled: boolean;
+  handMeshOpacity: number;
+  handPointSize: number;
+  handRayColor: string;
+  handRayEnabled: boolean;
+  handRayWidth: number;
+  hapticIntensity: number;
+  passthroughBrightness: number;
+  passthroughContrast: number;
+  passthroughOpacity: number;
+  pinchThreshold: number;
+  planeColor: string;
+  planeOpacity: number;
+  portalEdgeColor: string;
+  portalEdgeWidth: number;
+  portalSize: number;
+  roomScale: boolean;
+  rotationThreshold: number;
+  showPlaneOverlay: boolean;
+  snapToFloor: boolean;
+  interactionRadius: number;
+}
+
+export interface AudioSettings {
+  enableAmbientSounds: boolean;
+  enableInteractionSounds: boolean;
+  enableSpatialAudio: boolean;
+}
+
+export interface BloomSettings {
+  edgeBloomStrength: number;
+  enabled: boolean;
+  environmentBloomStrength: number;
+  nodeBloomStrength: number;
+  radius: number;
+  strength: number;
+}
+
+export interface ClientDebugSettings {
+  enableDataDebug: boolean;
+  enableWebsocketDebug: boolean;
+  enabled: boolean;
+  logBinaryHeaders: boolean;
+  logFullJson: boolean;
+}
+
+export interface EdgeSettings {
+  arrowSize: number;
+  baseWidth: number;
+  color: string;
+  enableArrows: boolean;
+  opacity: number;
+  widthRange: [number, number];
+}
+
+export interface HologramSettings {
+  xrQuality: 'low' | 'medium' | 'high';
+  desktopQuality: 'low' | 'medium' | 'high';
+  ringCount: number;
+  ringColor: string;
+  ringOpacity: number;
+  ringSizes: number[];
+  ringRotationSpeed: number;
+  enableBuckminster: boolean;
+  buckminsterScale: number;
+  buckminsterOpacity: number;
+  enableGeodesic: boolean;
+  geodesicScale: number;
+  geodesicOpacity: number;
+  enableTriangleSphere: boolean;
+  triangleSphereScale: number;
+  triangleSphereOpacity: number;
+  globalRotationSpeed: number;
+}
+
+export interface LabelSettings {
+  desktopFontSize: number;
+  enableLabels: boolean;
+  textColor: string;
+  textOutlineColor: string;
+  textOutlineWidth: number;
+  textResolution: number;
+  textPadding: number;
+  billboardMode: 'camera' | 'up';
+}
+
+export interface NodeSettings {
+  baseColor: string;
+  baseSize: number;
+  sizeRange: [number, number];
+  enableMetadataShape: boolean;
+  colorRangeAge: [string, string];
+  colorRangeLinks: [string, string];
+  metalness: number;
+  roughness: number;
+  opacity: number;
+}
+
+export interface NetworkSettings {
+  bindAddress: string;
+  domain: string;
+  enableHttp2: boolean;
+  enableRateLimiting: boolean;
+  enableTls: boolean;
+  maxRequestSize: number;
+  minTlsVersion: string;
+  port: number;
+  rateLimitRequests: number;
+  rateLimitWindow: number;
+  tunnelId: string;
+}
+
+export interface DefaultSettings {
+  apiClientTimeout: number;
+  enableMetrics: boolean;
+  enableRequestLogging: boolean;
+  logFormat: string;
+  logLevel: string;
+  maxConcurrentRequests: number;
+  maxPayloadSize: number;
+  maxRetries: number;
+  metricsPort: number;
+  retryDelay: number;
+}
+
+export interface SecuritySettings {
+  allowedOrigins: string[];
+  auditLogPath: string;
+  cookieHttponly: boolean;
+  cookieSamesite: string;
+  cookieSecure: boolean;
+  csrfTokenTimeout: number;
+  enableAuditLogging: boolean;
+  enableRequestValidation: boolean;
+  sessionTimeout: number;
+}
+
+export interface ServerDebugSettings {
+  enabled: boolean;
+  enableDataDebug: boolean;
+  enableWebsocketDebug: boolean;
+  logBinaryHeaders: boolean;
+  logFullJson: boolean;
+}
+
+export interface PhysicsSettings {
+  attractionStrength: number;
+  boundsSize: number;
+  collisionRadius: number;
+  damping: number;
+  enableBounds: boolean;
+  enabled: boolean;
+  iterations: number;
+  maxVelocity: number;
+  repulsionStrength: number;
+  springStrength: number;
+}
+
+export interface RenderingSettings {
+  ambientLightIntensity: number;
+  backgroundColor: string;
+  directionalLightIntensity: number;
+  enableAmbientOcclusion: boolean;
+  enableAntialiasing: boolean;
+  enableShadows: boolean;
+  environmentIntensity: number;
+}
+
+export interface WebSocketSettings {
+  url: string;                   // WebSocket server URL
+  heartbeatInterval: number;     // Ping interval in seconds (default: 30)
+  heartbeatTimeout: number;      // Connection timeout in seconds (default: 60)
+  reconnectAttempts: number;     // Max reconnection attempts (default: 3)
+  reconnectDelay: number;        // Delay between reconnects in ms (default: 5000)
+  binaryChunkSize: number;       // Size of binary chunks
+  compressionEnabled: boolean;   // Enable/disable compression
+  compressionThreshold: number;  // Compression threshold
+  maxConnections: number;        // Maximum connections
+  maxMessageSize: number;        // Maximum message size
+  updateRate: number;           // Update rate in Hz
+}
+
+export interface Settings {
+  animations: AnimationSettings;
+  ar: ARSettings;
+  audio: AudioSettings;
+  bloom: BloomSettings;
+  clientDebug: ClientDebugSettings;
+  default: DefaultSettings;
+  edges: EdgeSettings;
+  hologram: HologramSettings;
+  labels: LabelSettings;
+  network: NetworkSettings;
+  nodes: NodeSettings;
+  physics: PhysicsSettings;
+  rendering: RenderingSettings;
+  security: SecuritySettings;
+  serverDebug: ServerDebugSettings;
+  websocket: WebSocketSettings;
+}
+
+export type SettingCategory = keyof Settings;
+export type SettingKey<T extends SettingCategory> = keyof Settings[T];
+export type SettingValue = string | number | boolean | number[] | string[];
+
+// WebSocket message types
+export type MessageType = 
+  | 'binaryPositionUpdate'  // Real-time position/velocity data
+  | 'ping'                  // Connection health check
+  | 'pong'                 // Connection health response
+  | 'connectionStatus'     // Connection status updates
+  | 'enableBinaryUpdates'; // Enable/disable binary updates
+
+// Base WebSocket message interface
+export interface BaseWebSocketMessage {
+  type: MessageType;
+}
+
+// Binary position update message (server -> client)
+export interface BinaryPositionUpdateMessage extends BaseWebSocketMessage {
+  type: 'binaryPositionUpdate';
+  data: {
+    nodes: Array<{
+      data: {
+        position: Vector3;
+        velocity: Vector3;
+      }
+    }>
+  };
+}
+
+// Connection health messages
+export interface PingMessage extends BaseWebSocketMessage {
+  type: 'ping';
+  timestamp: number;
+}
+
+export interface PongMessage extends BaseWebSocketMessage {
+  type: 'pong';
+  timestamp: number;
+}
+
+export type WebSocketMessage =
+  | BinaryPositionUpdateMessage
+  | PingMessage
+  | PongMessage;
+
+// WebSocket error types
+export enum WebSocketErrorType {
+  CONNECTION_ERROR = 'CONNECTION_ERROR',       // Failed to establish connection
+  CONNECTION_LOST = 'CONNECTION_LOST',         // Connection was lost
+  TIMEOUT = 'TIMEOUT',                        // Connection timed out
+  BINARY_FORMAT_ERROR = 'BINARY_FORMAT_ERROR', // Invalid binary data format
+}
+
+export interface WebSocketError {
+  type: WebSocketErrorType;
+  message: string;
+  code?: number;
+  details?: any;
+}
+
+// Logger interface
+export interface Logger {
+  log: (message: string, ...args: any[]) => void;
+  error: (message: string, ...args: any[]) => void;
+  warn: (message: string, ...args: any[]) => void;
+  debug: (message: string, ...args: any[]) => void;
+  info: (message: string, ...args: any[]) => void;
+}
+
+// Helper functions
+interface RawNode {
+  id: string;
+  metadata_id?: string;  // Added to match the server's data structure
+  label?: string;
+  data: {
+    position: Vector3;
+    metadata?: NodeMetadata;
+  };
+  color?: string;
+}
+
+interface RawEdge {
+  source: string;
+  target: string;
+  weight?: number;
+  id?: string;
+}
+
+interface RawGraphData {
+  nodes: RawNode[];
+  edges: RawEdge[];
+  metadata?: any;
+  totalPages?: number;
+  currentPage?: number;
+  totalItems?: number;
+  pageSize?: number;
+}
+
+export function transformGraphData(data: RawGraphData): GraphData {
+  if (debugState.isNodeDebugEnabled()) {
+    logger.debug(`Transforming graph data with ${data.nodes.length} nodes and ${data.edges.length} edges`);
+  }
+  
+  const nodes = data.nodes.map((node: RawNode) => transformNodeData(node));
+  
+  // Create a map for faster position lookup
+  const nodePositions = new Map<string, Vector3>();
+  nodes.forEach(node => {
+    nodePositions.set(node.id, node.data.position);
+  });
+
+  const edges = data.edges.map((edge: RawEdge, index: number) => {
+    // Check if node positions exist for the source and target
+    const sourcePos = nodePositions.get(edge.source);
+    const targetPos = nodePositions.get(edge.target);
+    
+    // For debugging missing edges
+    if (!sourcePos || !targetPos) {
+      if (debugState.isNodeDebugEnabled()) {
+        const missingPart = !sourcePos ? 'source' : 'target';
+        const missingId = !sourcePos ? edge.source : edge.target;
+        logger.warn(`Edge ${index}: Missing position for ${missingPart} node ID ${missingId}`, createDataMetadata({
+          edge: {
+            source: edge.source,
+            target: edge.target,
+            id: edge.id || `${edge.source}_${edge.target}`
+          }
+        }));
+      }
+    }
+    
+    return {
+      ...edge,
+      // Create temporary zero vector if position is missing to ensure edges are created
+      // These will be updated later with actual node positions
+      sourcePosition: sourcePos || new ThreeVector3(0, 0, 0),
+      targetPosition: targetPos || new ThreeVector3(0, 0, 0),
+      id: edge.id || `edge_${edge.source}_${edge.target}`
+    };
+  });
+
+  return {
+    nodes,
+    edges,
+    metadata: data.metadata
+  };
+}
+
+export function transformNodeData(node: any): Node {
+  // For debugging
+  if (debugState.isNodeDebugEnabled()) {
+    logger.debug(`Transforming node with ID: ${node.id}, metadata_id: ${node.metadata_id || 'undefined'}, label: ${node.label || 'undefined'}, file_name: ${node.data?.metadata?.file_name || 'undefined'}`,
+                createDataMetadata({ 
+                  hasMetadata: !!node.data?.metadata,
+                  metadata_name: node.data?.metadata?.name || 'undefined',
+                  file_name: node.data?.metadata?.file_name || 'undefined',
+                  fileSize: node.data?.metadata?.fileSize || 'undefined',
+                  hyperlinkCount: node.data?.metadata?.hyperlinkCount || 'undefined'
+                }));
+  }
+  
+  // CRITICAL FIX: Ensure proper ID mapping
+  // The node.id is the numeric ID from the server which is used to track nodes in the 
+  // binary protocol. This ID must be preserved exactly as is to ensure proper
+  // binding between the node's position/velocity data and its metadata.
+
+  const nodeId = node.id;
+  // CRITICAL: Get the file name from metadata as the primary metadata identifier
+  const metadataId = node.data?.metadata?.file_name || node.metadata_id || node.label || node.id;
+  
+  // Build metadata (additional information)
+  const metadata = {
+    // Use the metadata_id (filename) as the metadata name
+    name: metadataId,
+    lastModified: 
+      typeof node.data?.metadata?.lastModified === 'string' ? 
+        parseInt(node.data.metadata.lastModified) : 
+        (node.data?.metadata?.lastModified || Date.now()),
+    links: Array.isArray(node.data?.metadata?.links) ? node.data.metadata.links : [],
+    references: Array.isArray(node.data?.metadata?.references) ? node.data.metadata.references : [],
+    // Important: make sure to retain file size information specifically
+    fileSize: 
+      node.data?.metadata?.fileSize !== undefined ? 
+        (typeof node.data.metadata.fileSize === 'string' ? 
+          parseInt(node.data.metadata.fileSize) : 
+          node.data.metadata.fileSize) :
+      node.file_size !== undefined ? 
+        (typeof node.file_size === 'string' ? parseInt(node.file_size) : node.file_size) : 
+       1000, // Default file size of 1KB
+    hyperlinkCount: 
+      node.data?.metadata?.hyperlinkCount !== undefined ? 
+        (typeof node.data.metadata.hyperlinkCount === 'string' ?parseInt(node.data.metadata.hyperlinkCount) : node.data.metadata.hyperlinkCount) : 
+        0
+  };
+  
+  // Extract file_name from metadata if available (this is the actual label we want to display)
+  const fileName = node.data?.metadata?.file_name || node.metadata_id || node.label;
+  
+  // Important: Make sure to log when we have a numeric ID with a metadata name
+  if (/^\d+$/.test(node.id)) {
+    logger.info(`Node ${node.id} has metadata_id: ${node.metadata_id || 'N/A'}, label: ${node.label || 'N/A'}, file_name: ${node.data?.metadata?.file_name || 'N/A'}`,
+               createDataMetadata({
+                 fileName,
+                 metadataId,
+                 nodeLabel: node.label,
+                 finalLabel: fileName || node.label || node.metadata_id || metadata.name,
+                 fileSize: metadata.fileSize,
+                 hyperlinkCount: metadata.hyperlinkCount
+               }));
+  }
+
+  return {
+    id: nodeId, // The numeric ID string, used for binary protocol
+    metadataId: node.metadata_id || node.label || metadata.name, // Preserve server-provided metadata ID
+    // CRITICAL: Consistent label handling - use provided label or fallback to metadataId
+    // This ensures we always have a correct human-readable label for display
+    label: fileName || node.label || node.metadata_id || metadata.name,
+
+    data: {
+      // Always create new Vector3 objects to ensure proper type and consistent behavior
+      position: new ThreeVector3(node.data.position?.x || 0, node.data.position?.y || 0, node.data.position?.z || 0),
+      velocity: new ThreeVector3(node.data.velocity?.x || 0, node.data.velocity?.y || 0, node.data.velocity?.z || 0),
+      metadata
+    },
+    color: node.color
+  };
+}
diff --git a/client/core/utils.ts b/client/core/utils.ts
new file mode 100644
index 00000000..a02b51fd
--- /dev/null
+++ b/client/core/utils.ts
@@ -0,0 +1,314 @@
+/**
+ * Core utilities for the LogseqXR visualization system
+ */
+
+import { Vector3 } from 'three';
+import { debugState } from './debugState';
+import { THROTTLE_INTERVAL } from './constants';
+
+// Debug logging utility
+export interface Logger {
+  log: (message: string, ...args: any[]) => void;
+  error: (message: string, ...args: any[]) => void;
+  warn: (message: string, ...args: any[]) => void;
+  debug: (message: string, ...args: any[]) => void;
+  info: (message: string, ...args: any[]) => void;
+  performance: (message: string, ...args: any[]) => void;
+}
+
+export function createLogger(namespace: string): Logger {
+  return {
+    log: (message: string, ...args: any[]) => console.log(`[${namespace}] ${message}`, ...args),
+    error: (message: string, ...args: any[]) => console.error(`[${namespace}] ${message}`, ...args),
+    warn: (message: string, ...args: any[]) => console.warn(`[${namespace}] ${message}`, ...args),
+    debug: (message: string, ...args: any[]) => console.debug(`[${namespace}] ${message}`, ...args),
+    info: (message: string, ...args: any[]) => console.info(`[${namespace}] ${message}`, ...args),
+    performance: (message: string, ...args: any[]) => console.debug(`[${namespace}][Performance] ${message}`, ...args)
+  };
+}
+
+// Case conversion utilities
+export const camelToSnakeCase = (str: string): string => {
+  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
+};
+
+export const snakeToCamelCase = (str: string): string => {
+  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
+};
+
+export const convertObjectKeysToSnakeCase = (obj: any): any => {
+  if (Array.isArray(obj)) {
+    return obj.map(item => convertObjectKeysToSnakeCase(item));
+  }
+  
+  if (obj !== null && typeof obj === 'object') {
+    return Object.keys(obj).reduce((acc, key) => {
+      const snakeKey = camelToSnakeCase(key);
+      acc[snakeKey] = convertObjectKeysToSnakeCase(obj[key]);
+      return acc;
+    }, {} as any);
+  }
+  
+  return obj;
+};
+
+export const convertObjectKeysToCamelCase = (obj: any): any => {
+  if (Array.isArray(obj)) {
+    return obj.map(item => convertObjectKeysToCamelCase(item));
+  }
+  
+  if (obj !== null && typeof obj === 'object') {
+    return Object.keys(obj).reduce((acc, key) => {
+      const camelKey = snakeToCamelCase(key);
+      acc[camelKey] = convertObjectKeysToCamelCase(obj[key]);
+      return acc;
+    }, {} as any);
+  }
+  
+  return obj;
+};
+
+// Update throttler for performance optimization
+export class UpdateThrottler {
+  private lastUpdate: number = 0;
+  private throttleInterval: number;
+  private frameCount: number = 0;
+  private totalTime: number = 0;
+
+  constructor(throttleInterval: number = THROTTLE_INTERVAL) {
+    this.throttleInterval = throttleInterval;
+  }
+
+  /**
+   * Check if an update should be allowed based on the throttle interval
+   */
+  shouldUpdate(): boolean {
+    const now = performance.now();
+    const elapsed = now - this.lastUpdate;
+    
+    if (elapsed >= this.throttleInterval) {
+      // Update metrics for adaptive throttling
+      this.frameCount++;
+      this.totalTime += elapsed;
+      
+      this.lastUpdate = now;
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Get the time remaining until the next update is allowed
+   */
+  getTimeUntilNextUpdate(): number {
+    const now = performance.now();
+    const elapsed = now - this.lastUpdate;
+    return Math.max(0, this.throttleInterval - elapsed);
+  }
+  
+  /**
+   * Get the current effective update rate in Hz
+   */
+  getRate(): number {
+    return this.frameCount > 0 ? (1000 * this.frameCount) / this.totalTime : 0;
+  }
+
+  reset(): void {
+    this.lastUpdate = 0;
+    this.frameCount = 0;
+    this.totalTime = 0;
+  }
+}
+
+// Vector operations
+export const vectorOps = {
+  add: (a: Vector3, b: Vector3): Vector3 => {
+    const result = new Vector3();
+    return result.addVectors(a, b);
+  },
+
+  subtract: (a: Vector3, b: Vector3): Vector3 => {
+    const result = new Vector3();
+    return result.subVectors(a, b);
+  },
+
+  multiply: (v: Vector3, scalar: number): Vector3 => {
+    const result = v.clone();
+    return result.multiplyScalar(scalar);
+  },
+
+  divide: (v: Vector3, scalar: number): Vector3 => {
+    const result = v.clone();
+    return result.multiplyScalar(1 / scalar);
+  },
+
+  length: (v: Vector3): number => 
+    v.length(),
+
+  normalize: (v: Vector3): Vector3 => {
+    const result = v.clone();
+    return result.normalize().clone();
+  },
+
+  distance: (a: Vector3, b: Vector3): number => 
+    a.distanceTo(b),
+
+};
+
+/**
+ * Validates a Vector3 and fixes any invalid values (NaN, Infinity)
+ * @param vec The Vector3 to validate
+ * @param maxValue Maximum allowed absolute value for any component
+ * @param defaultValue Default value to use if the vector is invalid
+ * @returns A new Vector3 with valid values
+ */
+export const validateAndFixVector3 = (
+    vec: Vector3, 
+    maxValue: number = 1000, 
+    defaultValue: Vector3 = new Vector3(0, 0, 0)
+): Vector3 => {
+    // Check for NaN or Infinity
+    if (isNaN(vec.x) || isNaN(vec.y) || isNaN(vec.z) ||
+        !isFinite(vec.x) || !isFinite(vec.y) || !isFinite(vec.z)) {
+        // Return a copy of the default value
+        return defaultValue.clone();
+    }
+    
+    // Check for values exceeding maximum
+    if (Math.abs(vec.x) > maxValue || Math.abs(vec.y) > maxValue || Math.abs(vec.z) > maxValue) {
+        // Clamp values to the maximum
+        return new Vector3(
+            Math.max(-maxValue, Math.min(maxValue, vec.x)),
+            Math.max(-maxValue, Math.min(maxValue, vec.y)),
+            Math.max(-maxValue, Math.min(maxValue, vec.z))
+        );
+    }
+    
+    return vec.clone();
+};
+
+// Scale utilities
+export const scaleOps = {
+  // Normalize a value between min and max
+  normalize: (value: number, min: number, max: number): number => {
+    return Math.min(max, Math.max(min, value));
+  },
+
+  // Map a value from one range to another
+  mapRange: (value: number, inMin: number, inMax: number, outMin: number, outMax: number): number => {
+    // First normalize to 0-1
+    const normalized = (value - inMin) / (inMax - inMin);
+    // Then map to output range
+    return outMin + normalized * (outMax - outMin);
+  },
+
+  // Scale node size from server range to visualization range
+  normalizeNodeSize: (size: number, serverMin: number = 20, serverMax: number = 30, visMin: number = 0.15, visMax: number = 0.4): number => {
+    return scaleOps.mapRange(size, serverMin, serverMax, visMin, visMax);
+  }
+};
+
+// Data validation utilities
+export const validateGraphData = (data: any): boolean => {
+  if (!data || typeof data !== 'object') return false;
+  if (!Array.isArray(data.nodes) || !Array.isArray(data.edges)) return false;
+  
+  // Validate nodes
+  for (const node of data.nodes) {
+    if (!node.id) return false;
+    // Allow position to be either array or Vector3
+    if (node.position) {
+      if (Array.isArray(node.position)) {
+        if (node.position.length !== 3 || 
+            typeof node.position[0] !== 'number' ||
+            typeof node.position[1] !== 'number' ||
+            typeof node.position[2] !== 'number') {
+          return false;
+        }
+      } else if (typeof node.position === 'object') {
+        if (typeof node.position.x !== 'number' ||
+            typeof node.position.y !== 'number' ||
+            typeof node.position.z !== 'number') {
+          return false;
+        }
+      } else {
+        return false;
+      }
+    }
+  }
+  
+  // Validate edges
+  for (const edge of data.edges) {
+    if (!edge.source || !edge.target) return false;
+  }
+  
+  return true;
+};
+
+// Binary data helpers
+export const binaryToFloat32Array = (buffer: ArrayBuffer): Float32Array => {
+  return new Float32Array(buffer);
+};
+
+export const float32ArrayToPositions = (array: Float32Array): Vector3[] => {
+  const positions: Vector3[] = [];
+  for (let i = 0; i < array.length; i += 3) {
+    positions.push(new Vector3(array[i], array[i + 1], array[i + 2]));
+  }
+  return positions;
+};
+
+// Error handling utility
+export class VisualizationError extends Error {
+  constructor(message: string, public code: string) {
+    super(message);
+    this.name = 'VisualizationError';
+  }
+}
+
+// Performance monitoring
+export class PerformanceMonitor {
+  private logger = createLogger('Performance');
+  private metrics: Map<string, number> = new Map();
+  private operations: Map<string, { startTime: number, count: number, totalTime: number }> = new Map();
+
+  public startOperation(name: string): void {
+    if (debugState.getState().enablePerformanceDebug) {
+      this.metrics.set(name, performance.now());
+      
+      // Initialize operation stats if not exists
+      if (!this.operations.has(name)) {
+        this.operations.set(name, { startTime: 0, count: 0, totalTime: 0 });
+      }
+    }
+  }
+
+  public endOperation(name: string): void {
+    if (debugState.getState().enablePerformanceDebug) {
+      const startTime = this.metrics.get(name);
+      if (startTime) {
+        const duration = performance.now() - startTime;
+        this.metrics.delete(name);
+        
+        // Update operation stats
+        const stats = this.operations.get(name);
+        if (stats) {
+          stats.count++;
+          stats.totalTime += duration;
+          
+          this.logger.performance(`Operation: ${name}`, {
+            duration,
+            avgDuration: stats.totalTime / stats.count,
+            count: stats.count,
+            operation: 'measure'
+          });
+        }
+      }
+    }
+  }
+
+  public reset(): void {
+    this.metrics.clear();
+    this.operations.clear();
+  }
+}
diff --git a/client/diagnostics.ts b/client/diagnostics.ts
new file mode 100644
index 00000000..76a9872d
--- /dev/null
+++ b/client/diagnostics.ts
@@ -0,0 +1,378 @@
+import { createLogger, createDataMetadata } from './core/logger';
+import { WebSocketService } from './websocket/websocketService';
+import { graphDataManager } from './state/graphData';
+import { platformManager } from './platform/platformManager';
+import { HologramShaderMaterial } from './rendering/materials/HologramShaderMaterial';
+import { EdgeShaderMaterial } from './rendering/materials/EdgeShaderMaterial';
+import { defaultSettings } from './state/defaultSettings';
+import { buildWsUrl } from './core/api';
+
+const logger = createLogger('Diagnostics');
+
+export function runDiagnostics() {
+  logger.info('Running system diagnostics...');
+  
+  // Check WebGL support
+  checkWebGLSupport();
+  
+  // Check WebSocket configuration
+  checkWebSocketConfig();
+  
+  // Check shader compatibility
+  checkShaderCompatibility();
+  
+  // Check platform capabilities
+  checkPlatformCapabilities();
+}
+
+function checkWebGLSupport() {
+  logger.info('Checking WebGL support...');
+  
+  const canvas = document.createElement('canvas');
+  const gl = canvas.getContext('webgl2');
+  const gl1 = canvas.getContext('webgl');
+  
+  if (!gl && !gl1) {
+    logger.error('WebGL not supported at all');
+    return;
+  }
+  
+  if (gl) {
+    logger.info('WebGL2 is supported');
+    // Check for specific extensions needed by shaders
+    const extensions = gl.getSupportedExtensions();
+    if (extensions) {
+      logger.info('Supported WebGL2 extensions:', createDataMetadata({ extensions }));
+    }
+  } else {
+    logger.warn('WebGL2 not supported, falling back to WebGL1');
+    // This could be a problem for shaders using #version 300 es
+  }
+}
+
+function checkWebSocketConfig() {
+  logger.info('Checking WebSocket configuration...');
+  
+  // Check if WebSocket is supported
+  if (!('WebSocket' in window)) {
+    logger.error('WebSocket not supported in this browser');
+    return;
+  }
+  
+  // Check if WebSocketService is properly initialized
+  const wsService = WebSocketService.getInstance();
+  
+  // Get the WebSocket URL that would be used
+  const wsUrl = buildWsUrl();
+  logger.info('WebSocket URL:', createDataMetadata({ url: wsUrl }));
+  
+  // Check connection state
+  const connectionState = wsService.getConnectionStatus();
+  logger.info('WebSocketService status:', createDataMetadata({ 
+    state: connectionState,
+    isInitialized: wsService !== null
+  }));
+  
+  // Test WebSocket connectivity
+  try {
+    // Create a test WebSocket to check if the endpoint is reachable
+    const testWs = new WebSocket(wsUrl);
+    testWs.onopen = () => {
+      logger.info('Test WebSocket connection successful');
+      testWs.close();
+    };
+    testWs.onerror = (error) => {
+      logger.error('Test WebSocket connection failed:', createDataMetadata({ error }));
+    };
+    
+    // Set a timeout to close the test connection if it doesn't connect
+    setTimeout(() => {
+      if (testWs.readyState !== WebSocket.OPEN) {
+        logger.warn('Test WebSocket connection timed out');
+        testWs.close();
+      }
+    }, 5000);
+  } catch (error) {
+    logger.error('Failed to create test WebSocket:', createDataMetadata({ error }));
+  }
+  
+  // Check if GraphDataManager has WebSocketService configured
+  const gdm = graphDataManager;
+  
+  // Try to set the WebSocket service
+  try {
+    // Create a temporary WebSocket adapter to test connection
+    const testWsAdapter = {
+      send: (_data: ArrayBuffer) => {
+        logger.info('Test WebSocket send called');
+      }
+    };
+    
+    gdm.setWebSocketService(testWsAdapter);
+    logger.info('Successfully configured WebSocketService in GraphDataManager');
+  } catch (error) {
+    logger.error('Failed to configure WebSocketService:', createDataMetadata({ error }));
+  }
+}
+
+function checkShaderCompatibility() {
+  logger.info('Checking shader compatibility...');
+  
+  const canvas = document.createElement('canvas');
+  const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
+  
+  if (!gl) {
+    logger.error('Cannot check shader compatibility - WebGL not available');
+    return;
+  }
+  
+  // Check if we're using WebGL2 (required for #version 300 es)
+  const isWebGL2 = gl instanceof WebGL2RenderingContext;
+  logger.info(`Using WebGL${isWebGL2 ? '2' : '1'}`);
+  
+  if (!isWebGL2) {
+    logger.warn('WebGL2 not available - shaders using #version 300 es will fail');
+    logger.info('Recommendation: Update shader code to be compatible with WebGL1');
+  }
+  
+  // Try to create shader materials to check for compilation errors
+  try {
+    // Test HologramShaderMaterial creation without assigning to unused variable
+    if (new HologramShaderMaterial(defaultSettings)) {
+      logger.info('HologramShaderMaterial created successfully');
+    }
+  } catch (error) {
+    logger.error('Failed to create HologramShaderMaterial:', createDataMetadata({ error }));
+  }
+  
+  try {
+    // Test EdgeShaderMaterial creation without assigning to unused variable
+    if (new EdgeShaderMaterial(defaultSettings)) {
+      logger.info('EdgeShaderMaterial created successfully');
+    }
+  } catch (error) {
+    logger.error('Failed to create EdgeShaderMaterial:', createDataMetadata({ error }));
+  }
+}
+
+function checkPlatformCapabilities() {
+  logger.info('Checking platform capabilities...');
+  
+  const capabilities = platformManager.getCapabilities();
+  logger.info('Platform capabilities:', createDataMetadata({ capabilities }));
+  
+  const platform = platformManager.getPlatform();
+  logger.info('Detected platform:', createDataMetadata({ platform }));
+  
+  if (platformManager.isXRSupported()) {
+    logger.info('XR is supported on this platform');
+  } else {
+    logger.warn('XR is not supported on this platform');
+  }
+}
+
+// Export a function to fix common issues
+export function applyFixes() {
+  logger.info('Applying fixes for common issues...');
+  
+  // Fix 1: Configure WebSocket service
+  const wsService = WebSocketService.getInstance();
+  // Need to adapt the WebSocketService to match the expected interface
+  const wsAdapter = {
+    send: (data: ArrayBuffer) => {
+      wsService.sendMessage({ type: 'binaryData', data });
+    }
+  };
+  
+  graphDataManager.setWebSocketService(wsAdapter);
+  logger.info('WebSocket service configured for GraphDataManager');
+  
+  // Fix 2: Check if we need to modify shader version
+  const canvas = document.createElement('canvas');
+  const gl = canvas.getContext('webgl2');
+  
+  if (!gl) {
+    logger.warn('WebGL2 not available - shaders need to be modified');
+    logger.info('Please update shader code in EdgeShaderMaterial.ts and HologramShaderMaterial.ts');
+    logger.info('Change "#version 300 es" to be compatible with WebGL1');
+  }
+}
+
+// Add a function to verify shader materials are properly configured
+export function verifyShaderMaterials() {
+  logger.info('Verifying shader materials configuration...');
+  
+  // Check WebGL version
+  const canvas = document.createElement('canvas');
+  const gl = canvas.getContext('webgl2');
+  const isWebGL2 = !!gl;
+  
+  logger.info(`WebGL2 support: ${isWebGL2 ? 'Yes' : 'No'}`);
+  
+  // Create test materials
+  try {
+    // Test material creation without assigning to unused variables
+    if (new HologramShaderMaterial(defaultSettings) && 
+        new EdgeShaderMaterial(defaultSettings)) {
+      logger.info('Shader materials created successfully');
+    }
+    
+    // Check if the renderer is properly set for both materials
+    if (isWebGL2) {
+      logger.info('Using WebGL2 for shader materials');
+    } else {
+      logger.warn('Using WebGL1 for shader materials - some advanced effects may be limited');
+    }
+    
+    logger.info('Shader materials verification complete');
+  } catch (error) {
+    logger.error('Failed to verify shader materials:', createDataMetadata({ error }));
+  }
+}
+
+// Add a comprehensive WebSocket diagnostic function
+export function diagnoseWebSocketIssues() {
+  logger.info('Running comprehensive WebSocket diagnostics...');
+  
+  // 1. Check WebSocket URL construction
+  const wsUrl = buildWsUrl();
+  logger.info('WebSocket URL:', createDataMetadata({ url: wsUrl }));
+  
+  // Parse the URL to check components
+  try {
+    const parsedUrl = new URL(wsUrl);
+    logger.info('WebSocket URL components:', createDataMetadata({
+      protocol: parsedUrl.protocol,
+      host: parsedUrl.host,
+      hostname: parsedUrl.hostname,
+      port: parsedUrl.port,
+      pathname: parsedUrl.pathname,
+      search: parsedUrl.search
+    }));
+    
+    // Check if using secure WebSocket
+    if (parsedUrl.protocol !== 'wss:' && window.location.protocol === 'https:') {
+      logger.warn('Using insecure WebSocket (ws://) with HTTPS site - browsers may block this');
+    }
+  } catch (error) {
+    logger.error('Failed to parse WebSocket URL:', createDataMetadata({ error }));
+  }
+  
+  // 2. Check WebSocketService state
+  const wsService = WebSocketService.getInstance();
+  const connectionState = wsService.getConnectionStatus();
+  
+  // Log detailed WebSocketService information
+  logger.info('WebSocketService details:', createDataMetadata({ 
+    state: connectionState,
+    isInitialized: wsService !== null,
+    reconnectAttempts: wsService['reconnectAttempts'] || 'unknown',
+    maxReconnectAttempts: wsService['_maxReconnectAttempts'] || 'unknown'
+  }));
+  
+  // 3. Test network connectivity
+  try {
+    // Try to fetch a small resource to check general network connectivity
+    fetch('/api/user-settings', { method: 'HEAD' })
+      .then(response => {
+        logger.info('Network connectivity test successful:', createDataMetadata({ 
+          status: response.status,
+          ok: response.ok
+        }));
+      })
+      .catch(error => {
+        logger.error('Network connectivity test failed:', createDataMetadata({ error }));
+      });
+  } catch (error) {
+    logger.error('Failed to initiate network test:', createDataMetadata({ error }));
+  }
+  
+  // 4. Test WebSocket endpoint
+  try {
+    logger.info('Testing WebSocket endpoint...');
+    const testWs = new WebSocket(wsUrl);
+    
+    testWs.onopen = () => {
+      logger.info('WebSocket connection successful');
+      // Send a ping message to test bidirectional communication
+      testWs.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
+      
+      // Close after 3 seconds to allow for response
+      setTimeout(() => testWs.close(), 3000);
+    };
+    
+    testWs.onmessage = (event) => {
+      logger.info('Received WebSocket message:', createDataMetadata({ 
+        type: typeof event.data,
+        data: typeof event.data === 'string' ? event.data : 'binary data',
+        size: typeof event.data === 'string' ? event.data.length : 
+              (event.data instanceof ArrayBuffer ? event.data.byteLength : 'unknown')
+      }));
+    };
+    
+    testWs.onerror = (error) => {
+      logger.error('WebSocket connection error:', createDataMetadata({ error }));
+    };
+    
+    testWs.onclose = (event) => {
+      logger.info('WebSocket connection closed:', createDataMetadata({ 
+        code: event.code,
+        reason: event.reason,
+        wasClean: event.wasClean
+      }));
+    };
+    
+    // Set a timeout to close the test connection if it doesn't connect
+    setTimeout(() => {
+      if (testWs.readyState !== WebSocket.OPEN) {
+        logger.warn('WebSocket connection timed out');
+        testWs.close();
+      }
+    }, 5000);
+  } catch (error) {
+    logger.error('Failed to create test WebSocket:', createDataMetadata({ error }));
+  }
+  
+  // 5. Check GraphDataManager configuration
+  try {
+    const gdm = graphDataManager;
+    // Create a test message to see if it's properly configured
+    // Using a comment instead of creating an unused variable
+    // A typical node update is 28 bytes per node
+    const testAdapter = {
+      send: (data: ArrayBuffer) => {
+        logger.info('GraphDataManager WebSocket send test:', createDataMetadata({ 
+          byteLength: data.byteLength
+        }));
+        return true;
+      }
+    };
+    
+    gdm.setWebSocketService(testAdapter);
+    logger.info('GraphDataManager WebSocket configuration test successful');
+  } catch (error) {
+    logger.error('GraphDataManager WebSocket configuration test failed:', createDataMetadata({ error }));
+  }
+  
+  // 6. Check if WebSocketService can be used directly
+  try {
+    // Check if the connection state is CONNECTED
+    if (connectionState === 'connected') {
+      logger.info('WebSocketService is currently connected');
+    } else {
+      logger.warn(`WebSocketService is not connected (state: ${connectionState})`);
+      
+      // Try to connect if not already connecting or reconnecting
+      if (connectionState === 'disconnected') {
+        logger.info('Attempting to connect WebSocketService...');
+        wsService.connect().catch(error => {
+          logger.error('Failed to connect WebSocketService:', createDataMetadata({ error }));
+        });
+      }
+    }
+  } catch (error) {
+    logger.error('Error checking WebSocketService connection:', createDataMetadata({ error }));
+  }
+  
+  logger.info('WebSocket diagnostics complete');
+} 
\ No newline at end of file
diff --git a/client/diagnostics/nodeIdBindingDiagnostics.ts b/client/diagnostics/nodeIdBindingDiagnostics.ts
new file mode 100644
index 00000000..dfa91138
--- /dev/null
+++ b/client/diagnostics/nodeIdBindingDiagnostics.ts
@@ -0,0 +1,306 @@
+/**
+ * Node ID Binding Diagnostics
+ * 
+ * This tool helps diagnose issues related to node ID binding between
+ * the binary WebSocket protocol and metadata visualization.
+ */
+
+import { createLogger } from '../core/logger';
+import { WebSocketService } from '../websocket/websocketService';
+import { GraphDataManager } from '../state/graphData';
+import { debugState } from '../core/debugState';
+import { Node } from '../core/types';
+
+const logger = createLogger('NodeBindingDiagnostics');
+
+/**
+ * NodeBindingDiagnostics
+ * 
+ * This class provides diagnostics for node ID binding issues
+ * - Validates ID consistency across different components
+ * - Detects mismatches between binary protocol and metadata
+ * - Provides debugging suggestions for ID binding problems
+ */
+export class NodeBindingDiagnostics {
+    private static instance: NodeBindingDiagnostics | null = null;
+    
+    private constructor() {
+        // Private constructor for singleton pattern
+    }
+    
+    public static getInstance(): NodeBindingDiagnostics {
+        if (!NodeBindingDiagnostics.instance) {
+            NodeBindingDiagnostics.instance = new NodeBindingDiagnostics();
+        }
+        return NodeBindingDiagnostics.instance;
+    }
+    
+    /**
+     * Run comprehensive checks on node ID binding
+     * This is the main entry point for diagnostics
+     */
+    public runDiagnostics(): void {
+        logger.info('Starting node ID binding diagnostics...');
+        
+        try {
+            // Check graph data node IDs
+            this.checkGraphDataNodeIds();
+            
+            // Check WebSocket node mapping
+            this.checkWebSocketNodeMapping();
+            
+            // Check metadata binding
+            this.checkMetadataBinding();
+            
+            // Check for suspicious ID formats
+            this.checkForSuspiciousIdFormats();
+            
+            logger.info('Node ID binding diagnostics completed successfully');
+        } catch (error) {
+            logger.error('Error running node ID binding diagnostics', {
+                error: error instanceof Error ? error.message : String(error),
+            });
+        }
+    }
+    
+    /**
+     * Check for consistency in graph data node IDs
+     */
+    private checkGraphDataNodeIds(): void {
+        const graphData = GraphDataManager.getInstance().getGraphData();
+        
+        if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
+            logger.warn('No graph data available for node ID check');
+            return;
+        }
+        
+        // Check for node ID consistency
+        const { numericIdCount, nonNumericIdCount, suspiciousIds } = this.analyzeNodeIds(graphData.nodes);
+        
+        logger.info('Graph data node ID analysis:', {
+            totalNodes: graphData.nodes.length,
+            numericIdCount,
+            nonNumericIdCount,
+            suspiciousIdsCount: suspiciousIds.length,
+            suspiciousIdsSample: suspiciousIds.slice(0, 5)
+        });
+        
+        if (nonNumericIdCount > 0) {
+            logger.warn(`Found ${nonNumericIdCount} nodes with non-numeric IDs. This may cause binding issues with the binary protocol.`);
+        }
+    }
+    
+    /**
+     * Check WebSocket service node mapping
+     */
+    private checkWebSocketNodeMapping(): void {
+        const wsService = WebSocketService.getInstance();
+        
+        // Access private field via a type assertion hack (for diagnostic purposes only)
+        const service = wsService as any;
+        if (!service.nodeNameToIndexMap) {
+            logger.warn('Unable to access WebSocket node mapping');
+            return;
+        }
+        
+        const mapping = service.nodeNameToIndexMap as Map<string, number>;
+        
+        logger.info('WebSocket node mapping analysis:', {
+            mappingSize: mapping.size,
+            sampleEntries: Array.from(mapping.entries()).slice(0, 5)
+        });
+        
+        // Check for suspicious mappings (non-numeric string to numeric index)
+        const suspiciousMappings = Array.from(mapping.entries())
+            .filter(([key]) => !/^\d+$/.test(key))
+            .slice(0, 10);
+            
+        if (suspiciousMappings.length > 0) {
+            logger.warn('Found suspicious node ID mappings in WebSocket service:', {
+                count: suspiciousMappings.length,
+                examples: suspiciousMappings
+            });
+            
+            logger.info('RECOMMENDATION: These non-numeric IDs should be converted to numeric IDs for proper binding with the binary protocol.');
+        }
+    }
+    
+    /**
+     * Check metadata binding to nodes
+     */
+    private checkMetadataBinding(): void {
+        // This requires accessing the DOM to find all metadata labels
+        // For browser context only
+        if (typeof document === 'undefined') {
+            logger.warn('Cannot check metadata binding outside browser context');
+            return;
+        }
+        
+        try {
+            // Find metadata label groups in the scene
+            // This is a heuristic approach that may need adjustment for your specific scene structure
+            const metadataElements = Array.from(document.querySelectorAll('[data-metadata-node-id]'));
+            
+            if (metadataElements.length === 0) {
+                logger.warn('No metadata labels found in DOM');
+                return;
+            }
+            
+            // Check node IDs in metadata
+            const metadataNodeIds = metadataElements.map(el => el.getAttribute('data-metadata-node-id'));
+            const graphData = GraphDataManager.getInstance().getGraphData();
+            
+            const matchingIds = metadataNodeIds.filter(id => 
+                graphData.nodes.some(node => node.id === id)
+            );
+            
+            logger.info('Metadata binding analysis:', {
+                totalMetadataElements: metadataElements.length,
+                matchingWithGraphData: matchingIds.length,
+                mismatchCount: metadataElements.length - matchingIds.length
+            });
+            
+            if (matchingIds.length < metadataElements.length) {
+                logger.warn('Some metadata labels are not properly bound to graph nodes!', {
+                    boundCount: matchingIds.length,
+                    unboundCount: metadataElements.length - matchingIds.length
+                });
+            }
+        } catch (error) {
+            logger.error('Error checking metadata binding', {
+                error: error instanceof Error ? error.message : String(error)
+            });
+        }
+    }
+    
+    /**
+     * Check for suspicious node ID formats
+     */
+    private checkForSuspiciousIdFormats(): void {
+        const graphData = GraphDataManager.getInstance().getGraphData();
+        
+        if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
+            return;
+        }
+        
+        // Check for inconsistent ID types (mixed string/numeric)
+        const idTypes = new Set<string>();
+        graphData.nodes.forEach(node => {
+            // Determine ID type
+            let type = 'unknown';
+            if (typeof node.id === 'string') {
+                if (/^\d+$/.test(node.id)) {
+                    type = 'numeric-string';
+                } else if (node.id.includes('.')) {
+                    type = 'possible-filename';
+                } else {
+                    type = 'non-numeric-string';
+                }
+            } else if (typeof node.id === 'number') {
+                type = 'number';
+            }
+            
+            idTypes.add(type);
+        });
+        
+        logger.info('Node ID type analysis:', {
+            typesFound: Array.from(idTypes)
+        });
+        
+        if (idTypes.size > 1) {
+            logger.warn('Multiple ID types detected in node data. This could indicate inconsistency in ID handling.');
+        }
+        
+        // Check if IDs match their string representation
+        // This is to detect issues where IDs might be mistakenly cast between string and number
+        const idMismatchCount = graphData.nodes
+            .filter(node => node.id !== String(node.id))
+            .length;
+            
+        if (idMismatchCount > 0) {
+            logger.warn(`Found ${idMismatchCount} nodes where ID doesn't match its string representation. This could indicate a type conversion issue.`);
+        }
+    }
+    
+    /**
+     * Analyze node IDs to detect patterns and potential issues
+     * @param nodes Array of nodes to analyze
+     */
+    private analyzeNodeIds(nodes: Node[]): { 
+        numericIdCount: number, 
+        nonNumericIdCount: number,
+        suspiciousIds: string[]
+    } {
+        let numericIdCount = 0;
+        let nonNumericIdCount = 0;
+        const suspiciousIds: string[] = [];
+        
+        nodes.forEach(node => {
+            const id = node.id;
+            
+            // Check if ID is numeric string
+            if (typeof id === 'string' && /^\d+$/.test(id)) {
+                numericIdCount++;
+            } else {
+                nonNumericIdCount++;
+                suspiciousIds.push(String(id));
+            }
+            
+            // Check for suspicious patterns
+            if (typeof id === 'string') {
+                // Check for file extension in ID (often a sign of metadata_id being used incorrectly as id)
+                if (id.includes('.md') || id.includes('.js') || id.includes('.ts')) {
+                    suspiciousIds.push(id);
+                }
+                
+                // Check for very long IDs (unusual for numeric IDs)
+                if (id.length > 10) {
+                    suspiciousIds.push(id);
+                }
+            }
+        });
+        
+        return { numericIdCount, nonNumericIdCount, suspiciousIds };
+    }
+    
+    /**
+     * Enable diagnostic mode for monitoring ID binding issues in real-time
+     */
+    public enableMonitoring(): void {
+        // Set up monitoring of node position updates
+        logger.info('Enabling real-time node ID binding monitoring');
+        
+        // Log guidance for enabling relevant debug flags
+        logger.info('To see detailed node binding logs, please ensure the following debug flags are enabled:');
+        logger.info('- Node debugging: ' + (debugState.isNodeDebugEnabled() ? 'ENABLED' : 'DISABLED'));
+        logger.info('- Data debugging: ' + (debugState.isDataDebugEnabled() ? 'ENABLED' : 'DISABLED'));
+        logger.info('- WebSocket debugging: ' + (debugState.isWebsocketDebugEnabled() ? 'ENABLED' : 'DISABLED'));
+        
+        if (!debugState.isNodeDebugEnabled() || !debugState.isDataDebugEnabled()) {
+            logger.info('NOTE: Enable all debug modes in application settings or console for full diagnostics');
+        }
+        
+        logger.info('Node ID binding monitoring enabled. Check console for detailed logs.');
+    }
+    
+    /**
+     * Provide recommendations based on diagnostic results
+     */
+    public getRecommendations(): string[] {
+        return [
+            'Ensure all node IDs in graph data are numeric strings matching the binary protocol',
+            'Verify WebSocketService correctly converts binary u16 IDs to strings',
+            'Check that MetadataVisualizer uses the same node IDs as position updates',
+            'Review NodeInstanceManager to confirm it uses the same IDs as other components',
+            'Add explicit validation for node ID formats during critical operations',
+            'Consider adding assertions to verify ID consistency between components'
+        ];
+    }
+}
+
+// Make diagnostics available on window for console access
+if (typeof window !== 'undefined') {
+    (window as any).NodeBindingDiagnostics = NodeBindingDiagnostics.getInstance();
+}
+
+export default NodeBindingDiagnostics.getInstance();
\ No newline at end of file
diff --git a/client/diagnostics/nodeLabelDiagnostics.ts b/client/diagnostics/nodeLabelDiagnostics.ts
new file mode 100644
index 00000000..02b85670
--- /dev/null
+++ b/client/diagnostics/nodeLabelDiagnostics.ts
@@ -0,0 +1,133 @@
+import { NodeIdentityManager } from '../rendering/node/identity/NodeIdentityManager';
+import { createLogger, createDataMetadata, createErrorMetadata } from '../core/logger';
+
+const logger = createLogger('NodeLabelDiagnostics');
+
+/**
+ * NodeLabelDiagnostics provides tools for debugging label issues
+ * in the node visualization system.
+ * 
+ * It can be used to:
+ * 1. Detect and log duplicate labels
+ * 2. Verify label resolution consistency
+ * 3. Test integration of the NodeIdentityManager
+ */
+export class NodeLabelDiagnostics {
+    private identityManager: NodeIdentityManager;
+    
+    constructor() {
+        this.identityManager = NodeIdentityManager.getInstance();
+        logger.info('NodeLabelDiagnostics initialized');
+    }
+    
+    /**
+     * Run a diagnostic test on sample data to verify duplicate detection
+     */
+    public runDuplicateLabelTest(): void {
+        logger.info('Running duplicate label detection test');
+        
+        // Create sample test data with known duplicates
+        const testNodes = [
+            { id: '1', data: { metadata: { name: 'Test Node' } } },
+            { id: '2', data: { metadata: { name: 'Test Node' } } }, // Duplicate!
+            { id: '3', data: { metadata: { name: 'Unique Node 1' } } },
+            { id: '4', data: { metadata: { name: 'Unique Node 2' } } },
+            { id: '5', data: { metadata: { name: 'Another Test' } } },
+            { id: '6', data: { metadata: { name: 'Another Test' } } }, // Duplicate!
+        ];
+        
+        // Run the test
+        this.identityManager.processNodes(testNodes);
+        
+        // Verify results
+        const duplicates = this.identityManager.getDuplicateLabels();
+        
+        logger.info(`Duplicate test results: Found ${duplicates.size} duplicate labels`, 
+            createDataMetadata({ duplicateCount: duplicates.size }));
+            
+        duplicates.forEach((nodeIds, label) => {
+            logger.info(`Duplicate label "${label}" used by ${nodeIds.length} nodes: ${nodeIds.join(', ')}`);
+        });
+        
+        // Validate expected behavior
+        const expectedDuplicates = 2; // "Test Node" and "Another Test"
+        if (duplicates.size === expectedDuplicates) {
+            logger.info(' Duplicate detection test PASSED');
+        } else {
+            logger.warn(` Duplicate detection test FAILED: Expected ${expectedDuplicates} duplicates, found ${duplicates.size}`);
+        }
+    }
+    
+    /**
+     * Analyze a real dataset by processing a snapshot of actual nodes
+     */
+    public analyzeRealData(nodes: any[]): void {
+        if (!nodes || nodes.length === 0) {
+            logger.warn('No nodes provided for analysis');
+            return;
+        }
+        
+        logger.info(`Analyzing ${nodes.length} real nodes for label issues`);
+        
+        // Process the real data
+        this.identityManager.processNodes(nodes);
+        
+        // Get results
+        const duplicates = this.identityManager.getDuplicateLabels();
+        
+        // Log summary
+        logger.info(`Analysis complete: Found ${duplicates.size} duplicate labels in ${nodes.length} nodes`);
+        
+        if (duplicates.size > 0) {
+            logger.warn(' Duplicate labels detected in production data:');
+            duplicates.forEach((nodeIds, label) => {
+                logger.warn(`  - "${label}" used by ${nodeIds.length} nodes: ${nodeIds.join(', ')}`);
+            });
+        } else {
+            logger.info(' No duplicate labels found in the dataset');
+        }
+    }
+    
+    /**
+     * Execute this from console to test the duplicate label detection 
+     * after integration with NodeManagerFacade
+     */
+    public static runTest(): void {
+        const diagnostics = new NodeLabelDiagnostics();
+        diagnostics.runDuplicateLabelTest();
+        logger.info('To test with real data, call NodeLabelDiagnostics.analyzeCurrentNodes()');
+    }
+    
+    /**
+     * Run analysis on current graph nodes (call from browser console)
+     * 
+     * Usage: NodeLabelDiagnostics.analyzeCurrentNodes()
+     */
+    public static analyzeCurrentNodes(): void {
+        try {
+            // Access the global window object to get current nodes
+            // This must be run in the browser context
+            const windowAny = window as any;
+            
+            if (windowAny.__graphData && windowAny.__graphData.nodes) {
+                const nodes = windowAny.__graphData.nodes;
+                logger.info(`Analyzing current graph with ${nodes.length} nodes`);
+                
+                const diagnostics = new NodeLabelDiagnostics();
+                diagnostics.analyzeRealData(nodes);
+            } else {
+                logger.warn('No graph data found in window.__graphData. Make sure you run this in the browser after graph is loaded.', createDataMetadata({ found: false }));
+            }
+        } catch (error) {
+            logger.error('Error analyzing current nodes:', createErrorMetadata(error as Error));
+        }
+    }
+}
+
+// Make it accessible for browser console debugging
+(window as any).NodeLabelDiagnostics = NodeLabelDiagnostics;
+
+// Allow direct testing via console
+export function testDuplicateLabels(): void {
+    NodeLabelDiagnostics.runTest();
+}
\ No newline at end of file
diff --git a/client/diagnostics/systemDiagnostics.ts b/client/diagnostics/systemDiagnostics.ts
new file mode 100644
index 00000000..890b31bb
--- /dev/null
+++ b/client/diagnostics/systemDiagnostics.ts
@@ -0,0 +1,407 @@
+import { createLogger } from '../core/logger';
+import { WebSocketService } from '../websocket/websocketService';
+import { graphDataManager } from '../state/graphData';
+import { debugState } from '../core/debugState';
+import { SettingsStore } from '../state/SettingsStore';
+
+const logger = createLogger('SystemDiagnostics');
+
+/**
+ * SystemDiagnostics provides tools for diagnosing and debugging the application.
+ * It offers methods to analyze various aspects of the system and log detailed information.
+ */
+export class SystemDiagnostics {
+    private static instance: SystemDiagnostics | null = null;
+    private webSocketService: WebSocketService;
+    private settingsStore: SettingsStore;
+    private isActive: boolean = false;
+    private intervalId: number | null = null;
+    
+    private constructor() {
+        this.webSocketService = WebSocketService.getInstance();
+        this.settingsStore = SettingsStore.getInstance();
+        logger.info('SystemDiagnostics initialized');
+    }
+    
+    public static getInstance(): SystemDiagnostics {
+        if (!SystemDiagnostics.instance) {
+            SystemDiagnostics.instance = new SystemDiagnostics();
+        }
+        return SystemDiagnostics.instance;
+    }
+    
+    /**
+     * Start continuous diagnostics logging
+     * @param intervalMs Interval in milliseconds between diagnostics runs
+     */
+    public startDiagnostics(intervalMs: number = 5000): void {
+        if (this.isActive) {
+            logger.warn('Diagnostics already running');
+            return;
+        }
+        
+        logger.info(`Starting system diagnostics with ${intervalMs}ms interval`);
+        this.isActive = true;
+        
+        // Enable all debug flags
+        // Use the settings store to update debug settings
+        this.settingsStore.set('system.debug.enabled', true);
+        this.settingsStore.set('system.debug.enable_data_debug', true);
+        this.settingsStore.set('system.debug.enable_websocket_debug', true);
+        this.settingsStore.set('system.debug.enable_node_debug', true);
+        this.settingsStore.set('system.debug.enable_shader_debug', true);
+        this.settingsStore.set('system.debug.enable_physics_debug', true);
+        this.settingsStore.set('system.debug.enable_matrix_debug', true);
+        
+        // Log the current debug state
+        logger.info('Debug flags enabled:', {
+            globalDebug: debugState.isEnabled(),
+            dataDebug: debugState.isDataDebugEnabled(),
+            websocketDebug: debugState.isWebsocketDebugEnabled(),
+            nodeDebug: debugState.isNodeDebugEnabled()
+        });
+        
+        // Run initial diagnostics immediately
+        this.runDiagnostics();
+        
+        // Set up interval for continuous diagnostics
+        this.intervalId = window.setInterval(() => {
+            this.runDiagnostics();
+        }, intervalMs);
+    }
+    
+    /**
+     * Stop continuous diagnostics logging
+     */
+    public stopDiagnostics(): void {
+        if (!this.isActive || this.intervalId === null) {
+            logger.warn('Diagnostics not running');
+            return;
+        }
+        
+        logger.info('Stopping system diagnostics');
+        window.clearInterval(this.intervalId);
+        this.intervalId = null;
+        this.isActive = false;
+    }
+    
+    /**
+     * Run a full system diagnostics check
+     */
+    public runDiagnostics(): void {
+        try {
+            logger.info('Running full system diagnostics');
+            
+            this.checkWebSocketStatus();
+            this.checkGraphData();
+            this.checkRendererStatus();
+            this.checkMemoryUsage();
+            
+            logger.info('Diagnostics completed successfully');
+        } catch (error) {
+            logger.error('Error running diagnostics', {
+                error: error instanceof Error ? error.message : String(error),
+                stack: error instanceof Error ? error.stack : undefined
+            });
+        }
+    }
+    
+    /**
+     * Check WebSocket connection status and health
+     */
+    private checkWebSocketStatus(): void {
+        // Get connection status as string safely
+        const connectionStatus = String(this.webSocketService.getConnectionStatus());
+        
+        logger.info('WebSocket status:', { 
+            statusString: connectionStatus, 
+            isConnected: connectionStatus === 'connected',
+            readyState: this.getWebSocketReadyState()
+        });
+        
+        // If not connected, try to reconnect
+        if (connectionStatus !== 'connected') {
+            logger.warn('WebSocket not connected, trying to reconnect');
+            this.webSocketService.connect().catch(error => {
+                logger.error('Failed to reconnect', { error });
+            });
+        }
+    }
+
+    /**
+     * Get the current WebSocket readyState as a string
+     */
+    private getWebSocketReadyState(): string {
+        const ws = (this.webSocketService as any).ws;
+        const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
+        
+        if (!ws) {
+            return 'CLOSED (No WebSocket)';
+        }
+        
+        // readyState is a number from 0-3
+        const readyState = ws.readyState;
+        
+        if (readyState >= 0 && readyState <= 3) {
+            return `${readyStates[readyState]} (${readyState})`;
+        }
+        
+        // Fallback for unexpected values
+        if (typeof readyState === 'number') {
+            return `UNKNOWN (${readyState})`;
+        }
+        
+        return 'UNKNOWN (null)';
+    }
+    
+    /**
+     * Check graph data state
+     */
+    private checkGraphData(): void {
+        const graphData = graphDataManager.getGraphData();
+        logger.info('Graph data status:', {
+            nodeCount: graphData.nodes.length,
+            edgeCount: graphData.edges.length,
+            metadata: graphData.metadata
+        });
+        
+        // Check sample node positions
+        if (graphData.nodes.length > 0) {
+            const sampleNodes = graphData.nodes.slice(0, 3);
+            logger.info('Sample node positions:', {
+                samples: sampleNodes.map(node => ({
+                    id: node.id,
+                    position: node.data.position,
+                    velocity: node.data.velocity,
+                    metadata: {
+                        name: node.data.metadata?.name,
+                        fileSize: node.data.metadata?.fileSize
+                    }
+                }))
+            });
+        }
+    }
+    
+    /**
+     * Check renderer status
+     */
+    private checkRendererStatus(): void {
+        // Get WebGL context information
+        try {
+            const canvas = document.querySelector('canvas');
+            if (!canvas) {
+                logger.warn('No canvas element found');
+                return;
+            }
+            
+            const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
+            if (!gl) {
+                logger.error('WebGL context not available');
+                return;
+            }
+            
+            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
+            
+            logger.info('WebGL context info:', {
+                webgl2: gl instanceof WebGL2RenderingContext,
+                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unknown',
+                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown',
+                maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
+                maxVaryings: gl.getParameter(gl.MAX_VARYING_VECTORS),
+                maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
+                maxVertexUniforms: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
+                maxFragmentUniforms: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)
+            });
+            
+            // Check for WebGL errors
+            const error = gl.getError();
+            if (error !== gl.NO_ERROR) {
+                logger.error('WebGL error detected', { 
+                    code: error,
+                    description: this.getWebGLErrorDescription(error)
+                });
+            }
+        } catch (error) {
+            logger.error('Error checking renderer status', { error });
+        }
+    }
+    
+    /**
+     * Check memory usage
+     */
+    private checkMemoryUsage(): void {
+        if (window.performance && (performance as any).memory) {
+            const memory = (performance as any).memory;
+            logger.info('Memory usage:', {
+                usedJSHeapSize: this.formatBytes(memory.usedJSHeapSize),
+                totalJSHeapSize: this.formatBytes(memory.totalJSHeapSize),
+                jsHeapSizeLimit: this.formatBytes(memory.jsHeapSizeLimit),
+                percentUsed: (memory.usedJSHeapSize / memory.totalJSHeapSize * 100).toFixed(1) + '%'
+            });
+        }
+    }
+    
+    /**
+     * Convert bytes to a human-readable format
+     */
+    private formatBytes(bytes: number): string {
+        if (bytes === 0) return '0 Bytes';
+        const k = 1024;
+        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
+        const i = Math.floor(Math.log(bytes) / Math.log(k));
+        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
+    }
+    
+    /**
+     * Get a human-readable description of a WebGL error code
+     */
+    private getWebGLErrorDescription(errorCode: number): string {
+        // Get a sample WebGL context to access error constants
+        const canvas = document.createElement('canvas');
+        const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
+        if (!gl) return 'Unknown error';
+        
+        switch (errorCode) {
+            case gl.INVALID_ENUM: return 'INVALID_ENUM: An unacceptable value has been specified for an enumerated argument';
+            case gl.INVALID_VALUE: return 'INVALID_VALUE: A numeric argument is out of range';
+            case gl.INVALID_OPERATION: return 'INVALID_OPERATION: The specified command is not allowed for the current state';
+            case gl.INVALID_FRAMEBUFFER_OPERATION: return 'INVALID_FRAMEBUFFER_OPERATION: The currently bound framebuffer is not framebuffer complete';
+            case gl.OUT_OF_MEMORY: return 'OUT_OF_MEMORY: Not enough memory is left to execute the command';
+            case gl.CONTEXT_LOST_WEBGL: return 'CONTEXT_LOST_WEBGL: The WebGL context has been lost';
+            default: return `Unknown WebGL error code: ${errorCode}`;
+        }
+    }
+    
+    /**
+     * Test a shader for compatibility/compilation issues
+     * @param vertexShader Vertex shader source code
+     * @param fragmentShader Fragment shader source code
+     */
+    public testShaderCompilation(vertexShader: string, fragmentShader: string): boolean {
+        try {
+            const canvas = document.createElement('canvas');
+            const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
+            if (!gl) {
+                logger.error('WebGL context not available for shader test');
+                return false;
+            }
+            
+            // Create and compile vertex shader
+            const vs = gl.createShader(gl.VERTEX_SHADER);
+            if (!vs) {
+                logger.error('Failed to create vertex shader');
+                return false;
+            }
+            gl.shaderSource(vs, vertexShader);
+            gl.compileShader(vs);
+            
+            // Check vertex shader compilation status
+            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
+                logger.error('Vertex shader compilation failed', {
+                    error: gl.getShaderInfoLog(vs),
+                    source: vertexShader
+                });
+                gl.deleteShader(vs);
+                return false;
+            }
+            
+            // Create and compile fragment shader
+            const fs = gl.createShader(gl.FRAGMENT_SHADER);
+            if (!fs) {
+                logger.error('Failed to create fragment shader');
+                gl.deleteShader(vs);
+                return false;
+            }
+            gl.shaderSource(fs, fragmentShader);
+            gl.compileShader(fs);
+            
+            // Check fragment shader compilation status
+            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
+                logger.error('Fragment shader compilation failed', {
+                    error: gl.getShaderInfoLog(fs),
+                    source: fragmentShader
+                });
+                gl.deleteShader(vs);
+                gl.deleteShader(fs);
+                return false;
+            }
+            
+            // Create program and link shaders
+            const program = gl.createProgram();
+            if (!program) {
+                logger.error('Failed to create shader program');
+                gl.deleteShader(vs);
+                gl.deleteShader(fs);
+                return false;
+            }
+            gl.attachShader(program, vs);
+            gl.attachShader(program, fs);
+            gl.linkProgram(program);
+            
+            // Check program link status
+            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
+                logger.error('Shader program linking failed', {
+                    error: gl.getProgramInfoLog(program)
+                });
+                gl.deleteShader(vs);
+                gl.deleteShader(fs);
+                gl.deleteProgram(program);
+                return false;
+            }
+            
+            // Validate program
+            gl.validateProgram(program);
+            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
+                logger.error('Shader program validation failed', {
+                    error: gl.getProgramInfoLog(program)
+                });
+                gl.deleteShader(vs);
+                gl.deleteShader(fs);
+                gl.deleteProgram(program);
+                return false;
+            }
+            
+            // Success! Clean up resources
+            gl.deleteShader(vs);
+            gl.deleteShader(fs);
+            gl.deleteProgram(program);
+            
+            logger.info('Shader compilation test passed');
+            return true;
+        } catch (error) {
+            logger.error('Error during shader compilation test', {
+                error: error instanceof Error ? error.message : String(error),
+                stack: error instanceof Error ? error.stack : undefined
+            });
+            return false;
+        }
+    }
+    
+    /**
+     * Force a websocket reconnection
+     */
+    public forceWebSocketReconnect(): void {
+        logger.info('Forcing WebSocket reconnection');
+        this.webSocketService.close();
+        this.webSocketService.connect().then(() => {
+            logger.info('WebSocket reconnected successfully');
+        }).catch(error => {
+            logger.error('WebSocket reconnection failed', { error });
+        });
+    }
+    
+    /**
+     * Force a refresh of graph data from server
+     */
+    public refreshGraphData(): void {
+        logger.info('Refreshing graph data from server');
+        graphDataManager.fetchInitialData().then(() => {
+            logger.info('Graph data refreshed successfully');
+        }).catch(error => {
+            logger.error('Failed to refresh graph data', { error });
+        });
+    }
+}
+
+// Export a singleton instance
+export const systemDiagnostics = SystemDiagnostics.getInstance();
\ No newline at end of file
diff --git a/client/index.html b/client/index.html
new file mode 100644
index 00000000..1a7a73f2
--- /dev/null
+++ b/client/index.html
@@ -0,0 +1,167 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <meta name="immersive-ar" content="true">
+  <meta name="oculus-hand-tracking" content="true">
+  <title>LogseqXR Graph Visualization</title>
+  <style>
+    body {
+      margin: 0;
+      padding: 0;
+      overflow: hidden;
+      font-family: Arial, sans-serif;
+      background: #212121;  /* Match scene background */
+      color: #ffffff;
+    }
+
+    #scene-container {
+      position: absolute;
+      width: 100%;
+      height: 100%;
+      background: transparent;
+    }
+
+    #control-panel {
+      position: fixed;
+      top: 0;
+      right: 0;
+      height: 100vh;
+      background: rgba(33, 33, 33, 0.95);  /* Match scene background */
+      border-left: 1px solid rgba(255, 255, 255, 0.1);
+      padding: 15px;
+      z-index: 1000;
+      min-width: 300px;
+      overflow-y: auto;
+      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
+      transition: opacity 0.3s ease;
+    }
+
+    #control-panel.hidden {
+      opacity: 0;
+      pointer-events: none;
+    }
+
+    #xr-button {
+      position: fixed;
+      bottom: 20px;
+      left: 50%;
+      transform: translateX(-50%);
+      padding: 12px 24px;
+      background: rgba(255, 255, 255, 0.2);
+      border: 1px solid rgba(255, 255, 255, 0.3);
+      border-radius: 20px;
+      color: white;
+      font-size: 16px;
+      cursor: pointer;
+      z-index: 1000;
+      transition: all 0.3s ease;
+    }
+
+    #xr-button:hover {
+      background: rgba(255, 255, 255, 0.3);
+    }
+
+    #xr-button.hidden {
+      opacity: 0;
+      pointer-events: none;
+    }
+
+    .control-panel-header {
+      display: flex;
+      justify-content: space-between;
+      align-items: center;
+      margin-bottom: 15px;
+      padding-bottom: 10px;
+      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
+    }
+
+    .control-panel-header h3 {
+      margin: 0;
+      font-size: 1.2em;
+      color: #ffffff;
+    }
+
+    .connection-status {
+      display: inline-block;
+      padding: 4px 8px;
+      border-radius: 4px;
+      font-size: 0.9em;
+    }
+
+    .connection-status.connected {
+      background: rgba(76, 175, 80, 0.2);
+      color: #4CAF50;
+    }
+
+    .connection-status.disconnected {
+      background: rgba(244, 67, 54, 0.2);
+      color: #F44336;
+    }
+
+    .settings-group {
+      margin-bottom: 20px;
+      padding: 10px;
+      border-radius: 4px;
+      background: rgba(255, 255, 255, 0.05);
+    }
+
+    .settings-group h4 {
+      margin: 0 0 10px 0;
+      color: #ffffff;
+      font-size: 1em;
+    }
+
+    .setting-item {
+      margin-bottom: 10px;
+    }
+
+    .setting-item label {
+      display: block;
+      margin-bottom: 5px;
+      color: rgba(255, 255, 255, 0.8);
+    }
+
+    .setting-item input[type="text"],
+    .setting-item input[type="number"],
+    .setting-item select {
+      width: 100%;
+      padding: 6px;
+      border: 1px solid rgba(255, 255, 255, 0.1);
+      border-radius: 4px;
+      background: rgba(255, 255, 255, 0.1);
+      color: #ffffff;
+    }
+
+    .setting-item input[type="checkbox"] {
+      margin-right: 8px;
+    }
+
+    .setting-item input:focus,
+    .setting-item select:focus {
+      outline: none;
+      border-color: rgba(255, 255, 255, 0.3);
+      background: rgba(255, 255, 255, 0.15);
+    }
+  </style>
+</head>
+<body>
+  <div id="scene-container">
+    <canvas id="main-canvas"></canvas>
+  </div>
+  <div id="control-panel">
+    <div class="control-panel-header">
+      <h3>Settings</h3>
+      <div class="connection-status">
+        <span class="status-indicator"></span>
+        <span id="connection-status">Connecting...</span>
+      </div>
+    </div>
+    <div class="control-panel-content">
+      <!-- Settings sections will be dynamically populated by ControlPanel.ts -->
+    </div>
+  </div>
+  <script type="module" src="/index.ts"></script>
+</body>
+</html>
diff --git a/client/index.ts b/client/index.ts
new file mode 100644
index 00000000..b03f48db
--- /dev/null
+++ b/client/index.ts
@@ -0,0 +1,512 @@
+import { Settings } from './types/settings';
+import { NodeManagerFacade } from './rendering/node/NodeManagerFacade';
+import { EdgeManager } from './rendering/EdgeManager';
+import { HologramManager } from './visualization/HologramManager';
+import { TextRenderer } from './rendering/textRenderer';
+import { WebSocketService } from './websocket/websocketService';
+import { SettingsStore } from './state/SettingsStore';
+import { LoggerConfig, createLogger, createErrorMetadata, createDataMetadata } from './core/logger';
+import { platformManager } from './platform/platformManager';
+
+import { XRSessionManager } from './xr/xrSessionManager';
+import { XRInitializer } from './xr/xrInitializer';
+import { SceneManager } from './rendering/scene';
+import { graphDataManager } from './state/graphData';
+import { debugState } from './core/debugState';
+import { ModularControlPanel } from './ui/ModularControlPanel';
+import { defaultSettings } from './state/defaultSettings';
+import { MaterialFactory } from './rendering/factories/MaterialFactory';
+import './ui'; // Import UI initialization
+
+import { Vector3 } from 'three';
+const logger = createLogger('GraphVisualization');
+
+export function checkWebGLSupport(): boolean {
+    const canvas = document.createElement('canvas');
+    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
+    
+    if (!gl) {
+        logger.error('WebGL not supported');
+        return false;
+    }
+    
+    return true;
+}
+
+/**
+ * Helper to validate and sanitize Vector3 positions
+ * Returns true if fixed, false if already valid
+ */
+function validateAndFixVector3(vec: Vector3): boolean {
+    if (isNaN(vec.x) || isNaN(vec.y) || isNaN(vec.z) || !isFinite(vec.x) || !isFinite(vec.y) || !isFinite(vec.z)) {
+        vec.set(isNaN(vec.x) || !isFinite(vec.x) ? 0 : vec.x, isNaN(vec.y) || !isFinite(vec.y) ? 0 : vec.y, isNaN(vec.z) || !isFinite(vec.z) ? 0 : vec.z);
+        return true;
+    }
+    return false;
+}
+
+export class GraphVisualization {
+    private sceneManager: SceneManager;
+    private nodeManager: NodeManagerFacade;
+    private edgeManager: EdgeManager;
+    private hologramManager: HologramManager;
+    private textRenderer: TextRenderer;
+    private websocketService!: WebSocketService;
+    private initialized: boolean = false;
+    private websocketInitialized: boolean = false;
+    private componentsReady: boolean = false;
+    private loadingTimeout: number | null = null;
+
+    // Start a timeout to detect endless loading states
+    private startLoadingTimeout(): void {
+        if (this.loadingTimeout) {
+            window.clearTimeout(this.loadingTimeout);
+        }
+        this.loadingTimeout = window.setTimeout(() => {
+            logger.error('Loading timeout: Initial graph data loading took too long');
+            // Try to make the app usable even with timeout
+            document.getElementById('loading-message')?.remove();
+        }, 30000); // 30 second timeout
+    }
+    
+    private clearLoadingTimeout(): void {
+        if (this.loadingTimeout) {
+            window.clearTimeout(this.loadingTimeout);
+            this.loadingTimeout = null;
+        }
+    }
+
+    public async initializeWebSocket(): Promise<void> {
+        if (!this.componentsReady) {
+            if (debugState.isEnabled()) {
+                logger.warn('Attempting to initialize WebSocket before components are ready');
+            }
+            return;
+        }
+        
+        // Prevent duplicate WebSocket initialization
+        if (this.websocketInitialized) {
+            if (debugState.isEnabled()) {
+                logger.warn('WebSocket already initialized, skipping duplicate initialization');
+            }
+            return;
+        }
+
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Loading initial graph data via REST');
+        }
+        
+        // Set a timeout for the initial data loading to avoid hanging in the loading state
+        const LOADING_TIMEOUT = 30000; // 30 seconds
+        if (this.loadingTimeout) {
+            window.clearTimeout(this.loadingTimeout);
+        }
+        
+        this.loadingTimeout = window.setTimeout(() => {
+            logger.error('Timeout while loading initial graph data. The server may be unresponsive.');
+            document.getElementById('loading-message')?.setAttribute('data-error', 'true');
+            const loadingEl = document.getElementById('loading-message');
+            if (loadingEl) {
+                loadingEl.textContent = 'Error: Timeout while loading graph data. Please refresh the page to try again.';
+                loadingEl.classList.add('error');
+            }
+        }, LOADING_TIMEOUT);
+        
+        // Start loading timeout
+        this.startLoadingTimeout();
+        
+        try {
+            // First load graph data via REST
+            await graphDataManager.fetchInitialData();
+            const graphData = graphDataManager.getGraphData();
+            
+            // Clear the loading timeout since we have data
+            this.clearLoadingTimeout();
+            
+            // Check for empty or invalid graph data
+            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
+                logger.error('Initial graph data is empty or invalid', createDataMetadata({ 
+                    hasGraphData: !!graphData,
+                    hasNodes: !!(graphData && graphData.nodes),
+                    nodeCount: graphData?.nodes?.length || 0
+                }));
+            }
+            
+            // Clear the loading timeout since data was loaded successfully
+            if (this.loadingTimeout) {
+                window.clearTimeout(this.loadingTimeout);
+                this.loadingTimeout = null;
+            }
+            
+            // Validate the received data
+            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
+                logger.error('Initial graph data is empty or invalid', createDataMetadata(graphData));
+                throw new Error('Initial graph data is empty or invalid');
+            }
+            
+            // Update visualization with initial data
+            this.nodeManager.updateNodes(graphData.nodes);
+            this.edgeManager.updateEdges(graphData.edges);
+            
+            if (debugState.isDataDebugEnabled()) {
+                logger.debug('Initial graph data loaded via REST', {
+                    nodes: graphData.nodes.length,
+                    edges: graphData.edges.length
+                });
+            }
+
+            // Now initialize WebSocket for binary updates
+            this.websocketService = WebSocketService.getInstance();
+            
+            // Create an adapter that implements the InternalWebSocketService interface
+            // expected by GraphDataManager
+            const webSocketAdapter = {
+                send: (data: ArrayBuffer) => {
+                    if (debugState.isDataDebugEnabled()) {
+                        logger.debug('Sending binary data via WebSocket adapter');
+                    }
+                    // Use WebSocketService's binary message handling capability
+                    // The WebSocketService handles compression internally
+                    this.websocketService.sendNodeUpdates([]);
+                    
+                    // Send the raw binary data - this may be needed for certain types of updates
+                    const success = this.websocketService.sendRawBinaryData(data);
+                    if (!success) {
+                        logger.error('Failed to send binary data via WebSocket adapter: WebSocket may not be connected');
+                    }
+                }
+            };
+            
+            // Register the adapter with GraphDataManager
+            graphDataManager.setWebSocketService(webSocketAdapter);
+            
+            // Set up binary message handler
+            this.websocketService.onBinaryMessage((nodes) => {
+                if (this.initialized && this.componentsReady) {
+                    if (debugState.isDataDebugEnabled()) {
+                        logger.debug('Received binary node update', { nodeCount: nodes.length });
+                    }
+                    
+                    // Check each node for NaN values and fix if needed
+                    nodes.forEach(node => {
+                        if (validateAndFixVector3(node.position)) {
+                            logger.warn(`Fixed invalid position for node ${node.id}`);
+                        }
+                        if (node.velocity && validateAndFixVector3(node.velocity)) {
+                            logger.warn(`Fixed invalid velocity for node ${node.id}`);
+                        }
+                    });
+                    this.nodeManager.updateNodePositions(nodes.map(node => ({
+                        id: node.id.toString(),
+                        data: {
+                            position: node.position,
+                            velocity: node.velocity
+                        }
+                    })));
+                }
+            });
+            
+            // Set up connection status handler
+            this.websocketService.onConnectionStatusChange((connected) => {
+                if (debugState.isEnabled()) {
+                    logger.info(`WebSocket connection status changed: ${connected}`);
+                }
+                if (connected && this.componentsReady) {
+                    // Enable binary updates in GraphDataManager
+                    graphDataManager.setBinaryUpdatesEnabled(true);
+                    if (debugState.isDataDebugEnabled()) {
+                        logger.debug('Binary updates enabled');
+                    }
+                }
+            });
+            
+            // Mark as initialized before connecting WebSocket
+            this.initialized = true;
+            this.websocketInitialized = true;
+            
+            // Finally connect WebSocket
+            await this.websocketService.connect();
+            
+            /**
+             * At this point, we need to manually notify other components that the WebSocket is ready.
+             * The GraphDataManager tries to configure itself with WebSocketService but 
+             * they use different interfaces, which is causing the "WebSocket service not configured" error.
+             * 
+             * Instead of trying to bridge them directly (which would require modifying interfaces),
+             * we're enabling binary updates on GraphDataManager after the WebSocket is connected, and
+             * the components will communicate through their existing API methods:
+             * 
+             * - GraphDataManager.setBinaryUpdatesEnabled(true) -> enables updates
+             * - WebSocketService.sendNodeUpdates() -> handles outgoing node updates
+             * - WebSocketService.onBinaryMessage() -> processes incoming binary data (already set up above)
+             */
+            try {
+                // Enable binary updates now that WebSocket is connected
+                logger.info('Binary updates enabled for GraphDataManager with WebSocket adapter');
+            } catch (error) {
+                logger.error('Error enabling binary updates:', createErrorMetadata(error));
+            }
+            
+            if (debugState.isDataDebugEnabled()) {
+                logger.debug('WebSocket connected and ready for binary updates');
+            }
+        } catch (error) {
+            logger.error('Failed to initialize data and WebSocket:', createErrorMetadata(error));
+            
+            // Clear the loading timeout
+            if (this.loadingTimeout) {
+                window.clearTimeout(this.loadingTimeout);
+                this.loadingTimeout = null;
+            }
+            
+            // Show error to user
+            this.showLoadingError('Failed to load graph data. Please check your connection and try again.');
+            throw error;
+        }
+    }
+
+    constructor(settings: Settings) {
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Initializing GraphVisualization');
+        }
+        
+        // Get existing canvas element
+        const canvas = document.getElementById('main-canvas') as HTMLCanvasElement;
+        if (!canvas) {
+            throw new Error('Could not find #main-canvas element');
+        }
+        
+        // Initialize SceneManager
+        this.sceneManager = SceneManager.getInstance(canvas);
+        
+        // Initialize managers with SceneManager's scene and renderer
+        const scene = this.sceneManager.getScene();
+        const camera = this.sceneManager.getCamera();
+        const renderer = this.sceneManager.getRenderer();
+        const materialFactory = MaterialFactory.getInstance();
+        
+        this.nodeManager = NodeManagerFacade.getInstance(
+            scene,
+            camera,
+            materialFactory.getNodeMaterial(settings)
+        );
+        this.edgeManager = new EdgeManager(scene, settings, this.nodeManager.getNodeInstanceManager());
+        this.hologramManager = new HologramManager(scene, renderer, settings);
+        this.textRenderer = new TextRenderer(camera, scene);
+        
+        // Apply initial settings to all components but don't connect websocket yet
+        this.handleSettingsUpdate(settings);
+        
+        // Start rendering
+        this.sceneManager.start();
+        this.componentsReady = true;
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('GraphVisualization initialization complete');
+        }
+    }
+
+    public handleSettingsUpdate(settings: Settings) {
+        if (!this.componentsReady) {
+            if (debugState.isEnabled()) {
+                logger.warn('Attempting to update settings before components are ready');
+            }
+            return;
+        }
+
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Handling settings update');
+        }
+        this.nodeManager.handleSettingsUpdate(settings);
+        this.edgeManager.handleSettingsUpdate(settings);
+        this.hologramManager.updateSettings(settings);
+        this.textRenderer.handleSettingsUpdate(settings.visualization.labels);
+        this.sceneManager.handleSettingsUpdate(settings);
+    }
+
+    private showLoadingError(message: string): void {
+        const loadingEl = document.getElementById('loading-message');
+        if (loadingEl) {
+            loadingEl.textContent = `Error: ${message}`;
+            loadingEl.classList.add('error');
+        } else {
+            // Create error message if loading element doesn't exist
+            logger.error('Loading error:', createDataMetadata({ message }));
+        }
+    }
+
+    public dispose() {
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Disposing GraphVisualization');
+        }
+        this.nodeManager.dispose();
+        this.edgeManager.dispose();
+        this.hologramManager.dispose();
+        this.textRenderer.dispose();
+        if (this.websocketService) {
+            this.websocketService.close();
+        }
+        
+        // Clean up XR components
+        if ((window as any).xrInitializer) {
+            (window as any).xrInitializer.dispose();
+            delete (window as any).xrInitializer;
+        }
+        
+        SceneManager.cleanup();
+        // Clear any pending timeouts
+        if (this.loadingTimeout) {
+            window.clearTimeout(this.loadingTimeout);
+            this.loadingTimeout = null;
+        }
+        this.initialized = false;
+        this.componentsReady = false;
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('GraphVisualization disposed');
+        }
+    }
+}
+
+// Initialize settings and logging
+async function init() {
+    if (debugState.isEnabled()) {
+        logger.info('Starting application initialization...');
+    }
+    
+    try {
+        // Initialize platform detection first
+        await platformManager.initialize(defaultSettings);
+        
+        // Initialize ModularControlPanel first and wait for settings to be ready
+        const controlPanel = ModularControlPanel.getInstance();
+        const settingsStore = SettingsStore.getInstance();
+        
+        // Wait for both control panel and settings store to be ready
+        await Promise.all([
+            new Promise<void>((resolve) => {
+                if (controlPanel.isReady()) {
+                    resolve();
+                } else {
+                    controlPanel.on('settings:ready', () => resolve());
+                }
+            }),
+            settingsStore.initialize()
+        ]);
+        
+        // Get settings after everything is initialized
+        const settings = settingsStore.get('') as Settings || defaultSettings;
+
+        // Configure logging based on settings
+        const debugEnabled = settingsStore.get('system.debug.enabled') as boolean;
+        const logFullJson = settingsStore.get('system.debug.log_full_json') as boolean;
+        LoggerConfig.setGlobalDebug(debugEnabled);
+        LoggerConfig.setFullJson(logFullJson);
+        
+        // Subscribe to debug setting changes
+        settingsStore.subscribe('system.debug.enabled', (_, value) => {
+            LoggerConfig.setGlobalDebug(value as boolean);
+        });
+        settingsStore.subscribe('system.debug.log_full_json', (_, value) => {
+            LoggerConfig.setFullJson(value as boolean);
+        });
+
+        // Create XR button if it doesn't exist
+        if (!document.getElementById('xr-button')) {
+            const xrButton = document.createElement('button');
+            xrButton.id = 'xr-button';
+            xrButton.className = 'hidden';
+            document.body.appendChild(xrButton);
+        }
+
+        // Get canvas and scene manager for XR setup
+        const canvas = document.getElementById('main-canvas') as HTMLCanvasElement;
+        if (!canvas) {
+            throw new Error('Could not find #main-canvas element');
+        }
+        const sceneManager = SceneManager.getInstance(canvas);
+
+        // Initialize XR components
+        const xrSessionManager = XRSessionManager.getInstance(sceneManager);
+        (window as any).xrInitializer = XRInitializer.getInstance(xrSessionManager);
+
+        // Initialize main visualization and store globally
+        const viz = new GraphVisualization(settings);
+        (window as any).visualization = viz;
+        
+        // Initialize WebSocket after visualization is created and ready
+        await viz.initializeWebSocket();
+
+        // Subscribe to all relevant visualization paths
+        const visualizationPaths = [
+            'visualization.nodes',
+            'visualization.edges',
+            'visualization.physics',
+            'visualization.rendering',
+            'visualization.animations',
+            'visualization.labels',
+            'visualization.bloom',
+            'visualization.hologram'
+        ];
+
+        // Subscribe to each path and update both visualization and scene
+        let pendingUpdate = false;
+        let pendingSettings: Settings | null = null;
+
+        const handleSettingsChange = () => {
+            if (!viz || !pendingSettings) return;
+            
+            try {
+                // Use the pending settings and clear it
+                const currentSettings = pendingSettings;
+                pendingSettings = null;
+                pendingUpdate = false;
+
+                if (!currentSettings) {
+                    return;
+                }
+                
+                // Batch updates to avoid cascading changes
+                viz.handleSettingsUpdate(currentSettings);
+                sceneManager.handleSettingsUpdate(currentSettings);
+                
+                if (debugState.isEnabled()) {
+                    logger.debug('Settings updated:', {
+                        bloom: currentSettings.visualization.bloom,
+                        rendering: currentSettings.visualization.rendering
+                    });
+                }
+            } catch (error) {
+                logger.error('Error handling settings update:', createErrorMetadata(error));
+            }
+        };
+
+        // Use a single subscription for all visualization paths
+        visualizationPaths.forEach(path => {
+            settingsStore.subscribe(path, () => {
+                if (!pendingUpdate) {
+                    pendingUpdate = true;
+                    pendingSettings = settingsStore.get('') as Settings;
+                    window.requestAnimationFrame(handleSettingsChange);
+                }
+            }, false); // Don't trigger immediate update on subscription
+        });
+
+        // Log successful initialization
+        if (debugState.isEnabled()) {
+            logger.info('Application components initialized successfully', {
+                platformType: platformManager.getPlatform(),
+                xrSupported: platformManager.isXRSupported(),
+                isQuest: platformManager.isQuest()
+            });
+            
+            logger.info('Application initialized successfully');
+        }
+    } catch (error) {
+        logger.error('Failed to initialize application components:', createErrorMetadata(error));
+        throw error;
+    }
+}
+
+// Start the application
+init().catch(error => {
+    console.error('Failed to initialize application:', error);
+});
diff --git a/client/material-switcher.js b/client/material-switcher.js
new file mode 100644
index 00000000..78c2e7fd
--- /dev/null
+++ b/client/material-switcher.js
@@ -0,0 +1,247 @@
+/**
+ * Material Switcher
+ * 
+ * This script can be run in the browser console to switch from custom shader materials
+ * to simplified materials at runtime, helping to resolve WebGL context issues.
+ * 
+ * Usage:
+ * 1. Open the browser console (F12 or Ctrl+Shift+I)
+ * 2. Copy and paste this entire script into the console
+ * 3. Press Enter to run the script
+ * 4. The script will automatically replace problematic materials
+ */
+
+(function() {
+  // Utility functions
+  const utils = {
+    log(message, data) {
+      const timestamp = new Date().toISOString();
+      if (data) {
+        console.log(`[${timestamp}] ${message}`, data);
+      } else {
+        console.log(`[${timestamp}] ${message}`);
+      }
+    },
+    
+    error(message, err) {
+      const timestamp = new Date().toISOString();
+      if (err) {
+        console.error(`[${timestamp}] ERROR: ${message}`, err);
+      } else {
+        console.error(`[${timestamp}] ERROR: ${message}`);
+      }
+    },
+    
+    success(message, data) {
+      const timestamp = new Date().toISOString();
+      const style = 'color: green; font-weight: bold';
+      if (data) {
+        console.log(`[${timestamp}] %c${message}`, style, data);
+      } else {
+        console.log(`[${timestamp}] %c${message}`, style);
+      }
+    }
+  };
+
+  // Material switcher
+  const materialSwitcher = {
+    // Replace custom shader materials with simplified materials
+    replaceCustomShaderMaterials() {
+      utils.log('Searching for custom shader materials to replace...');
+      
+      // Get the visualization instance
+      const viz = window.visualization;
+      if (!viz) {
+        utils.error('Visualization not found. Make sure the application is initialized.');
+        return;
+      }
+      
+      // Get the scene manager
+      const sceneManager = window.SceneManager?.getInstance();
+      if (!sceneManager) {
+        utils.error('SceneManager not found. Make sure the application is initialized.');
+        return;
+      }
+      
+      // Get the scene
+      const scene = sceneManager.getScene();
+      if (!scene) {
+        utils.error('Scene not found. Make sure the application is initialized.');
+        return;
+      }
+      
+      // Count of replaced materials
+      let replacedCount = 0;
+      
+      // Traverse the scene and replace materials
+      scene.traverse(object => {
+        if (!object.material) return;
+        
+        // Handle arrays of materials
+        if (Array.isArray(object.material)) {
+          for (let i = 0; i < object.material.length; i++) {
+            const material = object.material[i];
+            if (this.isCustomShaderMaterial(material)) {
+              object.material[i] = this.createSimplifiedMaterial(material);
+              replacedCount++;
+            }
+          }
+        } 
+        // Handle single material
+        else if (this.isCustomShaderMaterial(object.material)) {
+          object.material = this.createSimplifiedMaterial(object.material);
+          replacedCount++;
+        }
+      });
+      
+      utils.success(`Replaced ${replacedCount} custom shader materials with simplified materials`);
+      
+      // Force a render update
+      sceneManager.render();
+    },
+    
+    // Check if a material is a custom shader material
+    isCustomShaderMaterial(material) {
+      // Check for our custom shader materials
+      if (!material) return false;
+      
+      // Check for ShaderMaterial or custom material types
+      return (
+        material.type === 'ShaderMaterial' || 
+        material.constructor.name === 'HologramShaderMaterial' ||
+        material.constructor.name === 'EdgeShaderMaterial' ||
+        (material.uniforms && material.vertexShader && material.fragmentShader)
+      );
+    },
+    
+    // Create a simplified material based on the original material
+    createSimplifiedMaterial(material) {
+      // Default values
+      const color = material.color || material.uniforms?.color?.value || new THREE.Color(0x00ff00);
+      const opacity = material.opacity || material.uniforms?.opacity?.value || 0.7;
+      const wireframe = material.wireframe || material.uniforms?.isEdgeOnly?.value || false;
+      
+      // Create a basic material
+      const simplifiedMaterial = new THREE.MeshBasicMaterial({
+        color: color,
+        transparent: true,
+        opacity: opacity,
+        wireframe: wireframe,
+        side: THREE.DoubleSide
+      });
+      
+      utils.log('Created simplified material', {
+        originalType: material.type || material.constructor.name,
+        color: color,
+        opacity: opacity,
+        wireframe: wireframe
+      });
+      
+      return simplifiedMaterial;
+    },
+    
+    // Replace all materials in the scene
+    replaceAllMaterials() {
+      utils.log('Replacing all materials with simplified versions...');
+      
+      // Get the scene manager
+      const sceneManager = window.SceneManager?.getInstance();
+      if (!sceneManager) {
+        utils.error('SceneManager not found. Make sure the application is initialized.');
+        return;
+      }
+      
+      // Get the scene
+      const scene = sceneManager.getScene();
+      if (!scene) {
+        utils.error('Scene not found. Make sure the application is initialized.');
+        return;
+      }
+      
+      // Count of replaced materials
+      let replacedCount = 0;
+      
+      // Traverse the scene and replace all materials
+      scene.traverse(object => {
+        if (!object.material) return;
+        
+        // Handle arrays of materials
+        if (Array.isArray(object.material)) {
+          for (let i = 0; i < object.material.length; i++) {
+            const material = object.material[i];
+            object.material[i] = this.createSimplifiedMaterial(material);
+            replacedCount++;
+          }
+        } 
+        // Handle single material
+        else {
+          object.material = this.createSimplifiedMaterial(object.material);
+          replacedCount++;
+        }
+      });
+      
+      utils.success(`Replaced ${replacedCount} materials with simplified materials`);
+      
+      // Force a render update
+      sceneManager.render();
+    },
+    
+    // Reduce WebGL context usage
+    optimizeWebGLContextUsage() {
+      utils.log('Optimizing WebGL context usage...');
+      
+      // Get the scene manager
+      const sceneManager = window.SceneManager?.getInstance();
+      if (!sceneManager) {
+        utils.error('SceneManager not found. Make sure the application is initialized.');
+        return;
+      }
+      
+      // Get the renderer
+      const renderer = sceneManager.getRenderer();
+      if (!renderer) {
+        utils.error('Renderer not found. Make sure the application is initialized.');
+        return;
+      }
+      
+      // Optimize renderer settings
+      renderer.shadowMap.enabled = false;
+      renderer.shadowMap.autoUpdate = false;
+      renderer.shadowMap.needsUpdate = false;
+      
+      // Disable automatic clearing
+      renderer.autoClear = false;
+      renderer.autoClearColor = false;
+      renderer.autoClearDepth = false;
+      renderer.autoClearStencil = false;
+      
+      // Reduce precision if possible
+      try {
+        renderer.getContext().getShaderPrecisionFormat(
+          renderer.getContext().FRAGMENT_SHADER,
+          renderer.getContext().HIGH_FLOAT
+        );
+        utils.log('Using HIGH_FLOAT precision');
+      } catch (e) {
+        utils.warn('Failed to set shader precision', e);
+      }
+      
+      utils.success('WebGL context usage optimized');
+    }
+  };
+
+  // Run the material switcher
+  try {
+    materialSwitcher.replaceCustomShaderMaterials();
+    materialSwitcher.optimizeWebGLContextUsage();
+    utils.success('Material switcher completed successfully');
+  } catch (error) {
+    utils.error('Error running material switcher', error);
+  }
+  
+  // Export to global scope
+  window.MaterialSwitcher = materialSwitcher;
+  
+  utils.log('Material switcher loaded. You can run it again with MaterialSwitcher.replaceCustomShaderMaterials()');
+  utils.log('To replace all materials, run MaterialSwitcher.replaceAllMaterials()');
+})(); 
\ No newline at end of file
diff --git a/client/monitoring/NodeManagerMetrics.ts b/client/monitoring/NodeManagerMetrics.ts
new file mode 100644
index 00000000..fe7356cb
--- /dev/null
+++ b/client/monitoring/NodeManagerMetrics.ts
@@ -0,0 +1,237 @@
+import { createLogger, createErrorMetadata, createDataMetadata } from '../core/logger';
+
+const logger = createLogger('NodeManagerMetrics');
+
+interface PerformanceMetrics {
+    fps: number;
+    frameTime: number;
+    updateTime: number;
+    memoryUsage?: number;
+    nodeCount: number;
+    visibleNodes: number;
+    updateCount: number;
+}
+
+interface MetricsSummary {
+    avgFps: number;
+    avgFrameTime: number;
+    avgUpdateTime: number;
+    avgMemoryUsage?: number;
+    minFps: number;
+    maxUpdateTime: number;
+    totalUpdates: number;
+    sampleCount: number;
+}
+
+/**
+ * Monitoring system for tracking node manager performance
+ */
+export class NodeManagerMetrics {
+    private static instance: NodeManagerMetrics;
+    private metrics: PerformanceMetrics[] = [];
+    private currentMetrics: PerformanceMetrics;
+    private lastFrameTime: number = 0;
+    private frameCount: number = 0;
+    private readonly MAX_SAMPLES = 1000;
+    private readonly ALERT_THRESHOLD_FPS = 45;
+    private readonly ALERT_THRESHOLD_UPDATE_TIME = 16; // ms
+
+    // Performance monitoring
+    private performanceObserver: PerformanceObserver | null = null;
+
+    private constructor() {
+        this.currentMetrics = this.createEmptyMetrics();
+        this.setupPerformanceObserver();
+        
+        // Report metrics periodically
+        setInterval(() => this.reportMetrics(), 5000);
+    }
+
+    private createEmptyMetrics(): PerformanceMetrics {
+        return {
+            fps: 0,
+            frameTime: 0,
+            updateTime: 0,
+            nodeCount: 0,
+            visibleNodes: 0,
+            updateCount: 0
+        };
+    }
+
+    private setupPerformanceObserver(): void {
+        if (typeof PerformanceObserver !== 'undefined') {
+            this.performanceObserver = new PerformanceObserver((list) => {
+                for (const entry of list.getEntries()) {
+                    if (entry.entryType === 'measure' && entry.name === 'nodeUpdate') {
+                        this.currentMetrics.updateTime = entry.duration;
+                    }
+                }
+            });
+
+            try {
+                this.performanceObserver.observe({ entryTypes: ['measure'] });
+            } catch (error) {
+                logger.warn('Performance observer setup failed:', createErrorMetadata(error));
+            }
+        }
+    }
+
+    public static getInstance(): NodeManagerMetrics {
+        if (!NodeManagerMetrics.instance) {
+            NodeManagerMetrics.instance = new NodeManagerMetrics();
+        }
+        return NodeManagerMetrics.instance;
+    }
+
+    /**
+     * Record metrics for current frame
+     */
+    public recordFrame(nodeCount: number, visibleNodes: number): void {
+        const now = performance.now();
+        
+        if (this.lastFrameTime > 0) {
+            const frameTime = now - this.lastFrameTime;
+            this.currentMetrics.frameTime = frameTime;
+            this.currentMetrics.fps = 1000 / frameTime;
+        }
+        
+        this.lastFrameTime = now;
+        this.currentMetrics.nodeCount = nodeCount;
+        this.currentMetrics.visibleNodes = visibleNodes;
+        
+        // Add memory usage if available (Chrome-specific API)
+        interface PerformanceWithMemory extends Performance {
+            memory?: {
+                usedJSHeapSize: number;
+            };
+        }
+        if ((performance as PerformanceWithMemory).memory) {
+            this.currentMetrics.memoryUsage = (performance as PerformanceWithMemory).memory!.usedJSHeapSize / (1024 * 1024);
+        }
+
+        // Check for performance issues
+        this.checkPerformance();
+
+        // Store metrics
+        this.metrics.push({ ...this.currentMetrics });
+        if (this.metrics.length > this.MAX_SAMPLES) {
+            this.metrics.shift();
+        }
+
+        // Reset current metrics
+        this.currentMetrics = this.createEmptyMetrics();
+        this.frameCount++;
+    }
+
+    /**
+     * Record start of node update
+     */
+    public startUpdate(): void {
+        performance.mark('nodeUpdateStart');
+    }
+
+    /**
+     * Record end of node update
+     */
+    public endUpdate(): void {
+        performance.mark('nodeUpdateEnd');
+        performance.measure('nodeUpdate', 'nodeUpdateStart', 'nodeUpdateEnd');
+        this.currentMetrics.updateCount++;
+    }
+
+    /**
+     * Get summary of collected metrics
+     */
+    public getMetricsSummary(): MetricsSummary {
+        if (this.metrics.length === 0) {
+            return {
+                avgFps: 0,
+                avgFrameTime: 0,
+                avgUpdateTime: 0,
+                minFps: 0,
+                maxUpdateTime: 0,
+                totalUpdates: 0,
+                sampleCount: 0
+            };
+        }
+
+        const summary = this.metrics.reduce((acc, metrics) => {
+            acc.avgFps += metrics.fps;
+            acc.avgFrameTime += metrics.frameTime;
+            acc.avgUpdateTime += metrics.updateTime;
+            if (metrics.memoryUsage) {
+                acc.avgMemoryUsage = (acc.avgMemoryUsage || 0) + metrics.memoryUsage;
+            }
+            acc.minFps = Math.min(acc.minFps, metrics.fps);
+            acc.maxUpdateTime = Math.max(acc.maxUpdateTime, metrics.updateTime);
+            acc.totalUpdates += metrics.updateCount;
+            return acc;
+        }, {
+            avgFps: 0,
+            avgFrameTime: 0,
+            avgUpdateTime: 0,
+            avgMemoryUsage: undefined as number | undefined,
+            minFps: Infinity,
+            maxUpdateTime: 0,
+            totalUpdates: 0,
+            sampleCount: this.metrics.length
+        });
+
+        // Calculate averages
+        summary.avgFps /= summary.sampleCount;
+        summary.avgFrameTime /= summary.sampleCount;
+        summary.avgUpdateTime /= summary.sampleCount;
+        if (summary.avgMemoryUsage !== undefined) {
+            summary.avgMemoryUsage /= summary.sampleCount;
+        }
+
+        return summary;
+    }
+
+    private checkPerformance(): void {
+        const metrics = this.currentMetrics;
+
+        // Check FPS
+        if (metrics.fps < this.ALERT_THRESHOLD_FPS) {
+            logger.warn('Low FPS detected:', createDataMetadata({
+                fps: metrics.fps.toFixed(2),
+                nodeCount: metrics.nodeCount
+            }));
+        }
+
+        // Check update time
+        if (metrics.updateTime > this.ALERT_THRESHOLD_UPDATE_TIME) {
+            logger.warn('High update time detected:', createDataMetadata({
+                updateTime: metrics.updateTime.toFixed(2),
+                nodeCount: metrics.nodeCount
+            }));
+        }
+    }
+
+    private reportMetrics(): void {
+        const summary = this.getMetricsSummary();
+
+        logger.info('Performance Summary:', createDataMetadata({
+            avgFps: summary.avgFps.toFixed(2),
+            minFps: summary.minFps.toFixed(2),
+            avgUpdateTime: summary.avgUpdateTime.toFixed(2),
+            maxUpdateTime: summary.maxUpdateTime.toFixed(2),
+            avgMemoryUsage: summary.avgMemoryUsage?.toFixed(2),
+            totalUpdates: summary.totalUpdates,
+            sampleCount: summary.sampleCount
+        }));
+    }
+
+    public dispose(): void {
+        if (this.performanceObserver) {
+            this.performanceObserver.disconnect();
+        }
+        clearInterval(this.reportMetrics as any);
+        this.metrics = [];
+        NodeManagerMetrics.instance = null!;
+        logger.info('NodeManagerMetrics disposed');
+    }
+}
+
+// Export singleton instance
+export const nodeManagerMetrics = NodeManagerMetrics.getInstance();
\ No newline at end of file
diff --git a/client/platform/platformManager.ts b/client/platform/platformManager.ts
new file mode 100644
index 00000000..0c7522f7
--- /dev/null
+++ b/client/platform/platformManager.ts
@@ -0,0 +1,378 @@
+import { Platform, PlatformCapabilities } from '../core/types';
+import { createLogger } from '../core/utils';
+import { Settings } from '../types/settings';
+import { XRSessionMode, XRSessionState } from '../types/xr';
+import { SceneManager } from '../rendering/scene';
+
+const logger = createLogger('PlatformManager');
+
+declare global {
+  interface Navigator {
+    xr?: XRSystem;
+  }
+}
+
+class BrowserEventEmitter {
+  private listeners: { [event: string]: Function[] } = {};
+
+  on(event: string, listener: Function): void {
+    if (!this.listeners[event]) {
+      this.listeners[event] = [];
+    }
+    this.listeners[event].push(listener);
+  }
+
+  emit(event: string, ...args: any[]): void {
+    const eventListeners = this.listeners[event];
+    if (eventListeners) {
+      eventListeners.forEach(listener => listener(...args));
+    }
+  }
+
+  removeAllListeners(): void {
+    this.listeners = {};
+  }
+}
+
+export class PlatformManager extends BrowserEventEmitter {
+  private static instance: PlatformManager | null = null;
+  private platform: Platform;
+  private capabilities: PlatformCapabilities;
+  private initialized: boolean = false;
+  private _isXRMode: boolean = false;
+  private _xrSessionState: XRSessionState = 'inactive'; 
+  private _cooldownTimer: number | null = null;
+  private _sessionCount: number = 0;
+  private sceneManager: SceneManager | null = null;
+
+  private constructor() {
+    super();
+    this.platform = 'desktop';
+    this.capabilities = {
+      xrSupported: false,
+      webglSupported: false,
+      websocketSupported: false,
+      webxr: false,
+      handTracking: false,
+      planeDetection: false
+    };
+  }
+
+  static getInstance(): PlatformManager {
+    if (!PlatformManager.instance) {
+      PlatformManager.instance = new PlatformManager();
+    }
+    return PlatformManager.instance;
+  }
+
+  public setSceneManager(sceneManager: SceneManager): void {
+    this.sceneManager = sceneManager;
+  }
+
+  async initialize(settings: Settings): Promise<void> {
+    if (this.initialized) {
+      return;
+    }
+
+    this.detectPlatform();
+    await this.detectCapabilities();
+    
+    // Auto-enable XR mode for Quest devices unless explicitly disabled in settings
+    if (this.isQuest()) {
+      this._isXRMode = settings.xr?.mode !== 'inline';
+      if (this._isXRMode) {
+        this.capabilities.xrSupported = await this.checkXRSupport('immersive-ar');
+      }
+    }
+    // For other platforms, initialize based on settings
+    else if (settings.xr?.mode) {
+      this._isXRMode = true;
+      this.capabilities.xrSupported = await this.checkXRSupport(
+        settings.xr?.mode as XRSessionMode
+      );
+    }
+    
+    this.initialized = true;
+    logger.log('Platform manager initialized:', {
+      platform: this.platform,
+      isXRMode: this._isXRMode,
+      capabilities: this.capabilities
+    });
+  }
+
+  private detectPlatform(): void {
+    // Try modern User-Agent Client Hints API first
+    if ('userAgentData' in navigator) {
+      const brands = (navigator as any).userAgentData.brands;
+      const isOculusDevice = brands.some((b: any) =>
+        /oculus|meta|quest/i.test(b.brand)
+      );
+      if (isOculusDevice) {
+        this.platform = 'quest';
+        logger.log('Quest platform detected via userAgentData');
+        return;
+      }
+    }
+
+    // Fallback to traditional user agent detection
+    const userAgent = navigator.userAgent.toLowerCase();
+    const isQuest = userAgent.includes('quest') ||
+                    userAgent.includes('oculus') ||
+                    userAgent.includes('oculusbrowser') ||
+                    userAgent.includes('meta');
+    
+    if (isQuest) {
+      this.platform = 'quest';
+      logger.log('Quest platform detected via userAgent');
+    } else if (userAgent.includes('chrome') || userAgent.includes('firefox') || userAgent.includes('safari')) {
+      this.platform = 'browser';
+    } else {
+      this.platform = 'desktop';
+    }
+  }
+
+  private async detectCapabilities(): Promise<void> {
+    // WebXR support
+    if ('xr' in navigator && navigator.xr) {
+      try {
+        // For Quest devices, prioritize checking immersive-ar support
+        if (this.isQuest()) {
+          this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
+        } else {
+          // For other platforms, check both VR and AR
+          this.capabilities.xrSupported = 
+            await navigator.xr.isSessionSupported('immersive-ar') ||
+            await navigator.xr.isSessionSupported('immersive-vr');
+        }
+        
+        this.capabilities.webxr = this.capabilities.xrSupported;
+        this.capabilities.handTracking = this.capabilities.xrSupported;
+        this.capabilities.planeDetection = this.capabilities.xrSupported;
+      } catch (error) {
+        logger.warn('WebXR not supported:', error);
+        this.capabilities.xrSupported = false;
+        this.capabilities.webxr = false;
+        this.capabilities.handTracking = false;
+        this.capabilities.planeDetection = false;
+      }
+    }
+
+    // WebGL support
+    try {
+      const canvas = document.createElement('canvas');
+      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
+      this.capabilities.webglSupported = !!gl;
+    } catch (error) {
+      logger.warn('WebGL not supported:', error);
+      this.capabilities.webglSupported = false;
+    }
+
+    // WebSocket support
+    this.capabilities.websocketSupported = 'WebSocket' in window;
+
+    logger.log('Platform capabilities detected:', this.capabilities);
+  }
+
+  getPlatform(): Platform {
+    return this.platform;
+  }
+
+  getCapabilities(): PlatformCapabilities {
+    return { ...this.capabilities };
+  }
+
+  isDesktop(): boolean {
+    return this.platform === 'desktop';
+  }
+
+  isQuest(): boolean {
+    return this.platform === 'quest';
+  }
+
+  isBrowser(): boolean {
+    return this.platform === 'browser';
+  }
+
+  isXRSupported(): boolean {
+    return this.capabilities.xrSupported;
+  }
+
+  isWebGLSupported(): boolean {
+    return this.capabilities.webglSupported;
+  }
+
+  isWebSocketSupported(): boolean {
+    return this.capabilities.websocketSupported;
+  }
+
+  get xrSessionState(): XRSessionState {
+    return this._xrSessionState;
+  }
+
+  set xrSessionState(state: XRSessionState) {
+    this._xrSessionState = state;
+    this.emit('xrsessionstatechange', state);
+  }
+
+  async requestXRSession(mode: XRSessionMode = 'immersive-ar'): Promise<XRSession | null> {
+    if (!this.capabilities.xrSupported || !('xr' in navigator) || !navigator.xr) {
+      logger.warn('WebXR not supported');
+      return null;
+    }
+
+    try {
+      // Check if we're in cooldown period after a previous session
+      if (this._cooldownTimer !== null) {
+        logger.warn('AR session in cooldown period, please wait before starting a new session');
+        // Show a user-friendly message
+        const message = document.createElement('div');
+        message.style.position = 'fixed';
+        message.style.top = '50%';
+        message.style.left = '50%';
+        message.style.transform = 'translate(-50%, -50%)';
+        message.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
+        message.style.color = 'white';
+        message.style.padding = '20px';
+        message.style.borderRadius = '10px';
+        message.style.zIndex = '9999';
+        message.textContent = 'Please wait a moment before starting a new AR session...';
+        document.body.appendChild(message);
+        
+        // Remove the message after 2 seconds
+        setTimeout(() => {
+          document.body.removeChild(message);
+        }, 2000);
+        
+        return null;
+      }
+
+      // Check if we're already in an active or transitioning state
+      if (this._xrSessionState !== 'inactive') {
+        logger.warn(`Cannot start XR session while in ${this._xrSessionState} state`);
+        return null;
+      }
+
+      this.xrSessionState = 'starting';
+      this._sessionCount++;
+      const requiredFeatures: string[] = ['local-floor'];
+      const optionalFeatures: string[] = ['hand-tracking'];
+
+      // Add mode-specific features
+      if (mode === 'immersive-ar') {
+        requiredFeatures.push('hit-test');
+        optionalFeatures.push('plane-detection');
+      } else if (mode === 'immersive-vr') {
+        optionalFeatures.push('bounded-floor', 'layers');
+      }
+
+      const features: XRSessionInit = {
+        requiredFeatures,
+        optionalFeatures
+      };
+
+      // Log the session request
+      logger.log(`Requesting XR session with mode: ${mode}, features:`, 
+        { required: requiredFeatures, optional: optionalFeatures });
+
+      const session = await navigator.xr.requestSession(mode, features);
+
+      // Set up session end event handler
+      session.addEventListener('end', () => {
+        logger.log('XR session ended, entering cooldown period');
+        this.xrSessionState = 'cooldown';
+        
+        // Determine cooldown time based on session count and platform
+        let cooldownTime = 2000; // Default 2 seconds
+        
+        // Increase cooldown time for Quest devices or after multiple sessions
+        if (this.isQuest()) {
+          cooldownTime = 3000; // 3 seconds for Quest
+        }
+        if (this._sessionCount > 1) {
+          cooldownTime += 1000; // Add 1 second for each additional session
+        }
+        
+        // Set a cooldown timer to allow the browser to fully release resources
+        this._cooldownTimer = window.setTimeout(() => {
+          logger.log('XR session cooldown complete');
+          this._cooldownTimer = null;
+          this.xrSessionState = 'inactive';
+          
+          // Force a page reload if we've had multiple sessions on Quest
+          if (this.isQuest() && this._sessionCount > 2) {
+            logger.log('Forcing page reload to clear resources after multiple AR sessions');
+            setTimeout(() => {
+              window.location.reload();
+            }, 500);
+          }
+        }, cooldownTime) as unknown as number;
+      });
+
+      logger.log(`XR session started in ${mode} mode`);
+      return session;
+    } catch (error) {
+      logger.error('Failed to start XR session:', error);
+      return null;
+      this.xrSessionState = 'inactive';
+    }
+  }
+
+  async checkXRSupport(mode: XRSessionMode = 'immersive-ar'): Promise<boolean> {
+    if ('xr' in navigator && navigator.xr) {
+      try {
+        const supported = await navigator.xr.isSessionSupported(mode);
+        if (supported) {
+          this.capabilities.webxr = true;
+          this.capabilities.handTracking = true;
+          this.capabilities.planeDetection = mode === 'immersive-ar';
+          this.emit('xrdevicechange', true);
+          logger.log('WebXR supported for mode:', mode);
+          return true;
+        }
+      } catch (error) {
+        logger.warn('WebXR check failed:', error);
+      }
+    }
+    this.capabilities.webxr = false;
+    this.capabilities.handTracking = false;
+    this.capabilities.planeDetection = false;
+    this.emit('xrdevicechange', false);
+    return false;
+  }
+
+  dispose(): void {
+    this.removeAllListeners();
+    this.initialized = false;
+    
+    // Clear any pending cooldown timer
+    if (this._cooldownTimer !== null) {
+      clearTimeout(this._cooldownTimer);
+      this._cooldownTimer = null;
+    }
+    this._xrSessionState = 'inactive';
+    this._sessionCount = 0;
+    PlatformManager.instance = null;
+  }
+
+  get isXRMode(): boolean {
+    return this._isXRMode;
+  }
+
+  setXRMode(enabled: boolean): void {
+    this._isXRMode = enabled;
+    // Update camera layers
+    const camera = this.sceneManager?.getCamera();
+    if (camera) {
+      if (enabled) {
+        camera.layers.enable(1);  // Enable XR layer
+        camera.layers.disable(0); // Disable desktop layer
+      } else {
+        camera.layers.enable(0);  // Enable desktop layer
+        camera.layers.disable(1); // Disable XR layer
+      }
+    }
+    this.emit('xrmodechange', enabled);
+  }
+}
+
+export const platformManager = PlatformManager.getInstance();
diff --git a/client/public/fonts/Roboto-Regular.woff2 b/client/public/fonts/Roboto-Regular.woff2
new file mode 100644
index 00000000..020729ef
Binary files /dev/null and b/client/public/fonts/Roboto-Regular.woff2 differ
diff --git a/client/public/fonts/helvetiker_regular.typeface.json b/client/public/fonts/helvetiker_regular.typeface.json
new file mode 100644
index 00000000..d19293b4
--- /dev/null
+++ b/client/public/fonts/helvetiker_regular.typeface.json
@@ -0,0 +1 @@
+{"glyphs":{"":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "},"S":{"x_min":0,"x_max":788,"ha":890,"o":"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "},"":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"/":{"x_min":183.25,"x_max":608.328125,"ha":792,"o":"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "},"":{"x_min":-0.4375,"x_max":777.453125,"ha":839,"o":"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "},"y":{"x_min":0,"x_max":684.78125,"ha":771,"o":"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "},"":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "},"":{"x_min":-111,"x_max":339,"ha":361,"o":"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "},"g":{"x_min":0,"x_max":686,"ha":838,"o":"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "},"":{"x_min":0,"x_max":442,"ha":539,"o":"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "},"":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},"":{"x_min":0,"x_max":819.5625,"ha":893,"o":"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},"":{"x_min":-46.265625,"x_max":392,"ha":513,"o":"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "},"e":{"x_min":0,"x_max":714,"ha":813,"o":"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "},"":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "},"J":{"x_min":0,"x_max":588,"ha":699,"o":"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "},"":{"x_min":-1,"x_max":503,"ha":601,"o":"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "},"":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "},"":{"x_min":0,"x_max":922,"ha":1030,"o":"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "},"^":{"x_min":193.0625,"x_max":598.609375,"ha":792,"o":"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "},"":{"x_min":0,"x_max":507.203125,"ha":604,"o":"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "},"D":{"x_min":0,"x_max":828,"ha":935,"o":"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "},"":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"":{"x_min":0,"x_max":47,"ha":125,"o":"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "},"w":{"x_min":0,"x_max":1009.71875,"ha":1100,"o":"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "},"$":{"x_min":0,"x_max":700,"ha":793,"o":"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "},"\\":{"x_min":-0.015625,"x_max":425.0625,"ha":522,"o":"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "},"":{"x_min":0,"x_max":697.21875,"ha":747,"o":"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "},"":{"x_min":42,"x_max":181,"ha":297,"o":"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "},"":{"x_min":0,"x_max":1144.5,"ha":1214,"o":"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"":{"x_min":0,"x_max":801,"ha":915,"o":"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "},"-":{"x_min":8.71875,"x_max":350.390625,"ha":478,"o":"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "},"Q":{"x_min":0,"x_max":968,"ha":1072,"o":"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "},"":{"x_min":1,"x_max":676.28125,"ha":740,"o":"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "},"M":{"x_min":0,"x_max":954,"ha":1067,"o":"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "},"":{"x_min":0,"x_max":1006,"ha":1094,"o":"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "},"C":{"x_min":0,"x_max":886,"ha":944,"o":"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "},"!":{"x_min":0,"x_max":138,"ha":236,"o":"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "},"{":{"x_min":0,"x_max":480.5625,"ha":578,"o":"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "},"X":{"x_min":-0.015625,"x_max":854.15625,"ha":940,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "},"#":{"x_min":0,"x_max":963.890625,"ha":1061,"o":"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "},"":{"x_min":42,"x_max":284,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "},"":{"x_min":0,"x_max":906.953125,"ha":982,"o":"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},")":{"x_min":0,"x_max":318,"ha":415,"o":"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "},"":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "},"":{"x_min":0,"x_max":952.78125,"ha":1028,"o":"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "},"}":{"x_min":0,"x_max":481,"ha":578,"o":"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "},"":{"x_min":-3,"x_max":1672,"ha":1821,"o":"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "},"a":{"x_min":0,"x_max":698.609375,"ha":794,"o":"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "},"":{"x_min":0,"x_max":941.671875,"ha":1039,"o":"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "},"=":{"x_min":8.71875,"x_max":780.953125,"ha":792,"o":"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "},"N":{"x_min":0,"x_max":801,"ha":914,"o":"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "},"":{"x_min":0,"x_max":712,"ha":797,"o":"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "},"2":{"x_min":59,"x_max":731,"ha":792,"o":"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "},"":{"x_min":0,"x_max":941.671875,"ha":938,"o":"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "},"Z":{"x_min":0,"x_max":779,"ha":849,"o":"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "},"u":{"x_min":0,"x_max":617,"ha":729,"o":"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "},"k":{"x_min":0,"x_max":612.484375,"ha":697,"o":"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "},"":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"":{"x_min":0,"x_max":906.953125,"ha":985,"o":"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},"s":{"x_min":0,"x_max":604,"ha":697,"o":"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "},"B":{"x_min":0,"x_max":778,"ha":876,"o":"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "},"":{"x_min":0,"x_max":614,"ha":708,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "},"?":{"x_min":0,"x_max":607,"ha":704,"o":"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "},"H":{"x_min":0,"x_max":803,"ha":915,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"":{"x_min":0,"x_max":675,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "},"c":{"x_min":1,"x_max":701.390625,"ha":775,"o":"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "},"":{"x_min":0,"x_max":566.671875,"ha":678,"o":"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "},"":{"x_min":0,"x_max":660,"ha":745,"o":"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "},"":{"x_min":0,"x_max":954,"ha":1068,"o":"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "},"":{"x_min":0.109375,"x_max":1120,"ha":1217,"o":"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"":{"x_min":0,"x_max":1158,"ha":1275,"o":"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"":{"x_min":0,"x_max":663.890625,"ha":775,"o":"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "},"":{"x_min":0.1875,"x_max":819.546875,"ha":886,"o":"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "},"(":{"x_min":0,"x_max":318.0625,"ha":415,"o":"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "},"U":{"x_min":0,"x_max":796,"ha":904,"o":"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "},"":{"x_min":0.5,"x_max":744.953125,"ha":822,"o":"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "},"":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "},"F":{"x_min":0,"x_max":683.328125,"ha":717,"o":"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "},"":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},":":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"":{"x_min":0,"x_max":854.171875,"ha":935,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "},"*":{"x_min":116,"x_max":674,"ha":792,"o":"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "},"":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "},"":{"x_min":0,"x_max":347,"ha":444,"o":"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "},"V":{"x_min":0,"x_max":862.71875,"ha":940,"o":"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "},"":{"x_min":0,"x_max":734.71875,"ha":763,"o":"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "},"":{"x_min":0,"x_max":0,"ha":853},"":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "},"0":{"x_min":73,"x_max":715,"ha":792,"o":"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "},"":{"x_min":0,"x_max":347,"ha":454,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "},"@":{"x_min":0,"x_max":1260,"ha":1357,"o":"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "},"":{"x_min":0,"x_max":499,"ha":613,"o":"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "},"i":{"x_min":14,"x_max":136,"ha":275,"o":"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "},"":{"x_min":0,"x_max":778,"ha":877,"o":"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "},"":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "},"]":{"x_min":0,"x_max":275,"ha":372,"o":"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "},"m":{"x_min":0,"x_max":1019,"ha":1128,"o":"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "},"":{"x_min":8.328125,"x_max":780.5625,"ha":815,"o":"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "},"8":{"x_min":55,"x_max":736,"ha":792,"o":"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "},"":{"x_min":42,"x_max":326.71875,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "},"":{"x_min":0,"x_max":779.171875,"ha":850,"o":"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "},"R":{"x_min":0,"x_max":781.953125,"ha":907,"o":"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "},"o":{"x_min":0,"x_max":713,"ha":821,"o":"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "},"5":{"x_min":54.171875,"x_max":738,"ha":792,"o":"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "},"7":{"x_min":58.71875,"x_max":730.953125,"ha":792,"o":"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "},"K":{"x_min":0,"x_max":819.46875,"ha":906,"o":"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},",":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "},"d":{"x_min":0,"x_max":683,"ha":796,"o":"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "},"":{"x_min":-109,"x_max":247,"ha":232,"o":"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "},"E":{"x_min":0,"x_max":736.109375,"ha":789,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"Y":{"x_min":0,"x_max":820,"ha":886,"o":"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "},"\"":{"x_min":0,"x_max":299,"ha":396,"o":"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"":{"x_min":0,"x_max":364,"ha":467,"o":"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "},"":{"x_min":1,"x_max":710,"ha":810,"o":"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "},"":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "},"":{"x_min":0,"x_max":922,"ha":1031,"o":"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "},"":{"x_min":0,"x_max":96,"ha":251,"o":"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"":{"x_min":11,"x_max":781,"ha":792,"o":"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "},"|":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"":{"x_min":0,"x_max":617,"ha":725,"o":"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "},"":{"x_min":0,"x_max":593,"ha":690,"o":"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "},"b":{"x_min":0,"x_max":685,"ha":783,"o":"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "},"q":{"x_min":0,"x_max":683,"ha":876,"o":"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "},"":{"x_min":-0.171875,"x_max":969.5625,"ha":1068,"o":"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "},"":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "},"z":{"x_min":-0.015625,"x_max":613.890625,"ha":697,"o":"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "},"":{"x_min":0,"x_max":894,"ha":1000,"o":"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "},"":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "},"":{"x_min":0,"x_max":960,"ha":1056,"o":"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "},"":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "},"~":{"x_min":0,"x_max":833,"ha":931,"o":"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "},"":{"x_min":0,"x_max":736.21875,"ha":778,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"":{"x_min":0,"x_max":450,"ha":547,"o":"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "},"[":{"x_min":0,"x_max":273.609375,"ha":371,"o":"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "},"L":{"x_min":0,"x_max":645.828125,"ha":696,"o":"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "},"":{"x_min":0,"x_max":803.390625,"ha":894,"o":"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "},"":{"x_min":0,"x_max":573,"ha":642,"o":"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "},"":{"x_min":0,"x_max":674,"ha":778,"o":"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "},"":{"x_min":0,"x_max":958,"ha":1054,"o":"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "},"":{"x_min":0,"x_max":705.28125,"ha":749,"o":"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "}," ":{"x_min":0,"x_max":0,"ha":375},"%":{"x_min":-3,"x_max":1089,"ha":1186,"o":"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "},"P":{"x_min":0,"x_max":726,"ha":806,"o":"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "},"":{"x_min":0,"x_max":1078.21875,"ha":1118,"o":"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"":{"x_min":0.125,"x_max":1136.546875,"ha":1235,"o":"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "},"_":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "},"":{"x_min":-110,"x_max":246,"ha":275,"o":"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "},"+":{"x_min":23,"x_max":768,"ha":792,"o":"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "},"":{"x_min":0,"x_max":1050,"ha":1149,"o":"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "},"":{"x_min":0,"x_max":720,"ha":783,"o":"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "},"'":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"":{"x_min":0,"x_max":350,"ha":397,"o":"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "},"":{"x_min":0,"x_max":450,"ha":553,"o":"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "},"T":{"x_min":0,"x_max":777,"ha":835,"o":"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "},"":{"x_min":0,"x_max":915,"ha":997,"o":"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "},"":{"x_min":0,"x_max":0,"ha":694},"j":{"x_min":-77.78125,"x_max":167,"ha":349,"o":"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "},"":{"x_min":0,"x_max":756.953125,"ha":819,"o":"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "},"1":{"x_min":215.671875,"x_max":574,"ha":792,"o":"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "},"":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"<":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"":{"x_min":0,"x_max":704.484375,"ha":801,"o":"m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "},"t":{"x_min":0,"x_max":367,"ha":458,"o":"m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "},"":{"x_min":0,"x_max":706,"ha":803,"o":"m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "},"":{"x_min":0,"x_max":750,"ha":803,"o":"m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "},"W":{"x_min":0,"x_max":1263.890625,"ha":1351,"o":"m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "},">":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"v":{"x_min":0,"x_max":675.15625,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "},"":{"x_min":0.28125,"x_max":644.5,"ha":703,"o":"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "},"":{"x_min":0,"x_max":624.9375,"ha":699,"o":"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "},"&":{"x_min":-3,"x_max":894.25,"ha":992,"o":"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "},"":{"x_min":0,"x_max":862.5,"ha":942,"o":"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "},"I":{"x_min":41,"x_max":180,"ha":293,"o":"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "},"G":{"x_min":0,"x_max":921,"ha":1011,"o":"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "},"":{"x_min":0,"x_max":617,"ha":725,"o":"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "},"`":{"x_min":0,"x_max":138.890625,"ha":236,"o":"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "},"":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "},"r":{"x_min":0,"x_max":355.5625,"ha":432,"o":"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "},"x":{"x_min":0,"x_max":675,"ha":764,"o":"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "},"":{"x_min":0,"x_max":696.609375,"ha":747,"o":"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "},"h":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "},".":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"":{"x_min":-2,"x_max":878,"ha":974,"o":"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "},";":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "},"f":{"x_min":0,"x_max":378,"ha":472,"o":"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "},"":{"x_min":1,"x_max":348.21875,"ha":454,"o":"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "},"A":{"x_min":0.03125,"x_max":906.953125,"ha":1008,"o":"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "},"6":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "},"":{"x_min":1,"x_max":139.890625,"ha":236,"o":"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "},"":{"x_min":-70,"x_max":283,"ha":361,"o":"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "},"":{"x_min":-0.21875,"x_max":773.21875,"ha":857,"o":"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "},"":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "},"O":{"x_min":0,"x_max":958,"ha":1057,"o":"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "},"n":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "},"3":{"x_min":54,"x_max":737,"ha":792,"o":"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "},"9":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "},"l":{"x_min":41,"x_max":166,"ha":279,"o":"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "},"":{"x_min":40.09375,"x_max":728.796875,"ha":825,"o":"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "},"":{"x_min":0,"x_max":632.328125,"ha":679,"o":"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "},"4":{"x_min":48,"x_max":742.453125,"ha":792,"o":"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "},"p":{"x_min":0,"x_max":685,"ha":786,"o":"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "},"":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "},"":{"x_min":0,"x_max":808,"ha":907,"o":"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "},"":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "}},"cssFontWeight":"normal","ascender":1189,"underlinePosition":-100,"cssFontStyle":"normal","boundingBox":{"yMin":-334,"xMin":-111,"yMax":1189,"xMax":1672},"resolution":1000,"original_font_information":{"postscript_name":"Helvetiker-Regular","version_string":"Version 1.00 2004 initial release","vendor_url":"http://www.magenta.gr/","full_font_name":"Helvetiker","font_family_name":"Helvetiker","copyright":"Copyright (c) agenta ltd, 2004","description":"","trademark":"","designer":"","designer_url":"","unique_font_identifier":"agenta ltd:Helvetiker:22-10-104","license_url":"http://www.ellak.gr/fonts/MgOpen/license.html","license_description":"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\"Fonts\") and associated documentation files (the \"Font Software\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \"MgOpen\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \"MgOpen\" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","manufacturer_name":"agenta ltd","font_sub_family_name":"Regular"},"descender":-334,"familyName":"Helvetiker","lineHeight":1522,"underlineThickness":50}
\ No newline at end of file
diff --git a/client/rendering/EdgeManager.ts b/client/rendering/EdgeManager.ts
new file mode 100644
index 00000000..fcf31fba
--- /dev/null
+++ b/client/rendering/EdgeManager.ts
@@ -0,0 +1,300 @@
+import {
+    BufferGeometry,
+    BufferAttribute,
+    LineBasicMaterial,
+    Mesh,
+    Scene,
+    Vector3,
+    Material
+} from 'three';
+import { createLogger } from '../core/logger';
+import { Edge } from '../core/types';
+import { Settings } from '../types/settings';
+import { NodeInstanceManager } from './node/instance/NodeInstanceManager';
+
+const logger = createLogger('EdgeManager');
+
+export class EdgeManager {
+    private scene: Scene;
+    private settings: Settings;
+    private edges: Map<string, Mesh> = new Map(); // Store edges by ID
+    private nodeInstanceManager: NodeInstanceManager; // Reference to NodeInstanceManager
+
+    constructor(scene: Scene, settings: Settings, nodeInstanceManager: NodeInstanceManager) {
+        this.scene = scene;
+        this.settings = settings;
+        this.nodeInstanceManager = nodeInstanceManager;
+        logger.info('EdgeManager initialized');
+        
+        // Add constructor validation
+        if (!this.scene) {
+            logger.error("Scene is null or undefined in EdgeManager constructor");
+        }
+        if (!this.settings) {
+            logger.error("Settings are null or undefined in EdgeManager constructor");
+        }
+        if (!this.nodeInstanceManager) {
+            logger.error("NodeInstanceManager is null or undefined in EdgeManager constructor");
+        }
+    }
+
+    /**
+     * Validates a Vector3 to ensure it has valid, finite values
+     */
+    private validateVector3(vec: Vector3): boolean {
+        const MAX_VALUE = 1000;
+        return isFinite(vec.x) && isFinite(vec.y) && isFinite(vec.z) &&
+             !isNaN(vec.x) && !isNaN(vec.y) && !isNaN(vec.z) &&
+             Math.abs(vec.x) < MAX_VALUE && Math.abs(vec.y) < MAX_VALUE && Math.abs(vec.z) < MAX_VALUE;
+    }
+
+    public updateEdges(edges: Edge[]): void {
+        logger.info(`Updating ${edges.length} edges, current edge count: ${this.edges.size}`);
+
+        const newEdges: Edge[] = [];
+        const existingEdges: Edge[] = [];
+
+        const currentEdgeIds = new Set(edges.map(edge => this.createEdgeId(edge.source, edge.target)));
+        for (const edge of edges) {
+            // Use numeric IDs for edge identification
+            const edgeId = this.createEdgeId(edge.source, edge.target);
+
+            logger.debug(`Checking edge: ${edgeId}`);
+
+            if (this.edges.has(edgeId)) {
+                existingEdges.push(edge);
+            } else {
+                newEdges.push(edge);
+            }
+        }
+
+        logger.debug(`Found ${newEdges.length} new edges and ${existingEdges.length} existing edges`);
+
+        // Add new edges
+        for (const edge of newEdges) {
+            logger.debug(`Creating edge: ${edge.source}-${edge.target}`);
+            this.createEdge(edge);
+        }
+
+        // Update existing edges (positions might have changed)
+        for (const edge of existingEdges) {
+            logger.debug(`Updating edge: ${edge.source}-${edge.target}`);
+            this.updateEdge(edge);
+        }
+
+        // Remove old edges (not in the new set)
+        for (const edgeId of this.edges.keys()) {
+            if (!currentEdgeIds.has(edgeId)) {
+                this.removeEdge(edgeId);
+            }
+        }
+    }
+  
+    private createEdge(edge: Edge): void {
+        const edgeId = this.createEdgeId(edge.source, edge.target);
+
+        // Validate source and target IDs - they should be numeric strings
+        if (!this.validateNodeId(edge.source) || !this.validateNodeId(edge.target)) {
+            logger.warn(`Skipping edge creation with invalid node IDs: source=${edge.source}, target=${edge.target}`);
+            return;
+        }
+        // Get node positions from NodeInstanceManager using numeric IDs
+        const sourcePos = this.nodeInstanceManager.getNodePosition(edge.source);
+        const targetPos = this.nodeInstanceManager.getNodePosition(edge.target);
+        
+        logger.debug(`Creating edge ${edgeId}`, { 
+            source: edge.source,
+            target: edge.target,
+            sourcePos: sourcePos ? [sourcePos.x, sourcePos.y, sourcePos.z] : null,
+            targetPos: targetPos ? [targetPos.x, targetPos.y, targetPos.z] : null
+        });
+
+        if (!sourcePos || !targetPos) {
+            logger.warn(`Skipping edge creation for ${edgeId} due to missing node positions. Source exists: ${!!sourcePos}, Target exists: ${!!targetPos}`);
+            return;
+        }
+
+        const isSourceValid = this.validateVector3(sourcePos);
+        const isTargetValid = this.validateVector3(targetPos);
+
+        if (!isSourceValid || !isTargetValid) {
+            logger.warn(`Skipping edge creation for ${edgeId} due to invalid node positions. Source valid: ${isSourceValid}, Target valid: ${isTargetValid}`);
+            if (!isSourceValid) {
+                logger.warn(`Invalid source position: [${sourcePos.x}, ${sourcePos.y}, ${sourcePos.z}]`);
+            }
+            if (!isTargetValid) {
+                logger.warn(`Invalid target position: [${targetPos.x}, ${targetPos.y}, ${targetPos.z}]`);
+            }
+            return;
+        }
+
+        // Create a simple line geometry
+        const geometry = new BufferGeometry();
+        const positions = new Float32Array([
+            sourcePos.x, sourcePos.y, sourcePos.z,
+            targetPos.x, targetPos.y, targetPos.z
+        ]);
+        
+        geometry.setAttribute('position', new BufferAttribute(positions, 3));
+        
+        // Create LineBasicMaterial with higher opacity for better visibility
+        const material = new LineBasicMaterial({
+            color: this.settings.visualization.edges.color || "#888888", 
+            transparent: true, 
+            // Use settings opacity directly instead of multiplying
+            opacity: this.settings.visualization.edges.opacity || 0.8
+        });
+
+        // Use Mesh with line geometry for rendering
+        const line = new Mesh(geometry, material);
+        line.renderOrder = 5; // Increased to render on top of nodes
+
+        // Store the edge ID in userData for identification
+        line.userData = { edgeId };
+        
+        // Enable both layers by default for desktop mode
+        line.layers.enable(0);
+        line.layers.enable(1);
+        
+        this.edges.set(edgeId, line);
+        
+        // Add to scene and check
+        this.scene.add(line);
+        
+        // Verify the edge was added to the scene
+        logger.debug(`Edge created: ${edgeId}, visible: ${line.visible}, layers: ${line.layers.mask}`);
+        
+        // Log the material properties
+        const mat = line.material as LineBasicMaterial;
+        logger.debug(`Edge material: color=${mat.color.toString()}, opacity=${mat.opacity}, transparent=${mat.transparent}`);
+    }
+
+    /**
+     * Creates a consistent edge ID by sorting source and target IDs
+     * This ensures the same ID regardless of edge direction
+     */
+    private createEdgeId(source: string, target: string): string {
+        return [source, target].sort().join('_');
+    }
+
+    private validateNodeId(id: string): boolean {
+        return id !== undefined && id !== null && /^\d+$/.test(id);
+    }
+
+    private updateEdge(edge: Edge): void {
+        const edgeId = this.createEdgeId(edge.source, edge.target);
+        const line = this.edges.get(edgeId);
+        
+        if (!line) {
+            this.createEdge(edge);
+            return;
+        }
+
+        // Get updated node positions
+        const sourcePos = this.nodeInstanceManager.getNodePosition(edge.source);
+        const targetPos = this.nodeInstanceManager.getNodePosition(edge.target);
+
+        if (!sourcePos || !targetPos) {
+            logger.warn(`Cannot update edge ${edgeId}: missing node positions`);
+            return;
+        }
+
+        // Validate positions
+        const isSourceValid = this.validateVector3(sourcePos);
+        const isTargetValid = this.validateVector3(targetPos);
+        
+        if (!isSourceValid || !isTargetValid) {
+            logger.warn(`Skipping edge update for ${edgeId} due to invalid node positions. ` + 
+                        `Source valid: ${isSourceValid}, Target valid: ${isTargetValid}`);
+            if (!isSourceValid) logger.warn(`Invalid source position: [${sourcePos.x}, ${sourcePos.y}, ${sourcePos.z}]`);
+            if (!isTargetValid) logger.warn(`Invalid target position: [${targetPos.x}, ${targetPos.y}, ${targetPos.z}]`);
+            return;
+        }
+
+        // Update the geometry with new positions
+        const positions = new Float32Array([
+            sourcePos.x, sourcePos.y, sourcePos.z,
+            targetPos.x, targetPos.y, targetPos.z
+        ]);
+        
+        line.geometry.dispose();
+        const geometry = new BufferGeometry();
+        geometry.setAttribute('position', new BufferAttribute(positions, 3)); 
+        
+        line.geometry = geometry;
+        
+        logger.debug(`Edge updated: ${edgeId}`);
+    }
+
+    private removeEdge(edgeId: string): void {
+        const edge = this.edges.get(edgeId);
+        if (edge) {
+            logger.debug(`Removing edge: ${edgeId}`);
+            this.scene.remove(edge);
+            edge.geometry.dispose();
+            if (Array.isArray(edge.material)) {
+                logger.debug(`Disposing ${edge.material.length} materials for edge ${edgeId}`);
+                edge.material.forEach((m: Material) => m.dispose());
+            } else {
+                logger.debug(`Disposing material for edge ${edgeId}`);
+                edge.material.dispose();
+            }
+            this.edges.delete(edgeId);
+        } else {
+            logger.warn(`Attempted to remove non-existent edge: ${edgeId}`);
+        }
+    }
+
+    public handleSettingsUpdate(settings: Settings): void {
+        this.settings = settings;
+        // Update edge appearance based on new settings
+        this.edges.forEach((edge) => {
+            if (edge.material instanceof LineBasicMaterial) {
+                edge.material.color.set(this.settings.visualization.edges.color);
+                edge.material.opacity = this.settings.visualization.edges.opacity;
+                edge.material.needsUpdate = true;
+            }
+        });
+    }
+
+    /**
+     * Set XR mode for edge rendering
+     */
+    public setXRMode(enabled: boolean): void {
+        // Set appropriate layer visibility for all edges
+        logger.info(`Setting XR mode for ${this.edges.size} edges: ${enabled ? 'enabled' : 'disabled'}`);
+        this.edges.forEach(edge => {
+            if (enabled) {
+                // In XR mode, only show on layer 1
+                edge.layers.disable(0);
+                edge.layers.enable(1);
+            } else {
+                // In desktop mode, show on both layers
+                edge.layers.enable(0);
+                edge.layers.enable(1);
+            }
+        });
+    }
+
+    public update(): void {
+        // The edge update is now handled during updateEdges
+        // This method is kept for compatibility with the rendering loop
+    }
+
+    /**
+     * Clean up resources
+     */
+    public dispose(): void {
+        // Dispose of all geometries and materials
+        this.edges.forEach(edge => {
+            this.scene.remove(edge);
+            edge.geometry.dispose();
+            if (Array.isArray(edge.material)) {
+                edge.material.forEach((m: Material) => m.dispose());
+            } else {
+                edge.material.dispose();
+            }
+        });
+        this.edges.clear();
+    }
+}
diff --git a/client/rendering/MetadataVisualizer.ts b/client/rendering/MetadataVisualizer.ts
new file mode 100644
index 00000000..e629abf4
--- /dev/null
+++ b/client/rendering/MetadataVisualizer.ts
@@ -0,0 +1,471 @@
+import {
+    Group,
+    Scene,
+    PerspectiveCamera,
+    Vector3,
+    Color,
+    Object3D,
+    SphereGeometry,
+    MeshBasicMaterial,
+    Mesh
+} from 'three';
+import { NodeMetadata } from '../types/metadata';
+import { Settings } from '../types/settings';
+import { platformManager } from '../platform/platformManager';
+import { createLogger, Logger } from '../core/logger';
+import { debugState } from '../core/debugState';
+import { UnifiedTextRenderer } from './UnifiedTextRenderer';
+import { NodeIdentityManager } from './node/identity/NodeIdentityManager';
+
+interface MetadataLabelGroup extends Group {
+    name: string;
+    userData: {
+        isMetadata: boolean;
+        nodeId?: string;
+        metadataName?: string;
+    };
+}
+
+export type MetadataLabelCallback = (group: MetadataLabelGroup) => void;
+
+export class MetadataVisualizer {
+    private scene: Scene;
+    private labelGroup: Group;
+    private settings: Settings;
+    private debugEnabled: boolean = false;
+    private textRenderer: UnifiedTextRenderer;
+    private metadataGroups: Map<string, MetadataLabelGroup>;
+    private logger: Logger;
+    private debugHelpers: Map<string, Object3D>;
+    private labelUpdateCount: number = 0;
+    private nodeMetadataCache: Map<string, string> = new Map(); // Cache to store node ID to metadata name mapping
+    private nodeIdentityManager: NodeIdentityManager; // Add NodeIdentityManager reference
+    private lastClearTime: number = 0;
+    private visibilityThreshold: number = 50; // Default visibility threshold
+
+    constructor(camera: PerspectiveCamera, scene: Scene, settings: Settings) {
+        this.scene = scene;
+        this.settings = settings;
+        this.metadataGroups = new Map();
+        this.logger = createLogger('MetadataVisualizer');
+        this.debugEnabled = debugState.isEnabled();
+        this.nodeIdentityManager = NodeIdentityManager.getInstance(); // Initialize NodeIdentityManager
+        
+        this.debugHelpers = new Map();
+        this.visibilityThreshold = settings.visualization.labels.visibilityThreshold || 50;
+        
+        // On initialization, log our settings
+        if (this.debugEnabled) {
+            console.log('[MetadataVisualizer] Initialized with settings:', {
+                enableLabels: settings.visualization.labels.enableLabels,
+                textColor: settings.visualization.labels.textColor,
+                desktopFontSize: settings.visualization.labels.desktopFontSize,
+                visibilityThreshold: this.visibilityThreshold
+            });
+        }
+        
+        this.logger.info('Initializing MetadataVisualizer with settings:', {
+            enableLabels: settings.visualization.labels.enableLabels,
+            textColor: settings.visualization.labels.textColor,
+            desktopFontSize: settings.visualization.labels.desktopFontSize,
+            visibilityThreshold: this.visibilityThreshold,
+            textOutlineColor: settings.visualization.labels.textOutlineColor,
+            billboardMode: settings.visualization.labels.billboardMode
+        });
+
+        this.labelGroup = new Group();
+        this.scene.add(this.labelGroup);
+        
+        // Initialize text renderer
+        this.textRenderer = new UnifiedTextRenderer(camera, scene, settings.visualization.labels);
+        
+        // Enable both layers by default for desktop mode
+        this.labelGroup.layers.enable(0);
+        this.labelGroup.layers.enable(1);
+        
+        // Set initial layer mode
+        this.setXRMode(platformManager.isXRMode);
+        
+        // Listen for XR mode changes
+        platformManager.on('xrmodechange', (enabled: boolean) => {
+            this.setXRMode(enabled);
+        });
+    }
+
+    /**
+     * Resolve a display name for a node based on metadata
+     * This ensures we get unique names for each node
+     */
+    private resolveDisplayName(metadata: NodeMetadata, nodeId: string, forceUnique: boolean = true): string {
+        // First, check if we already have a cached name in our local cache
+        if (this.nodeMetadataCache.has(nodeId)) {
+            return this.nodeMetadataCache.get(nodeId) || nodeId;
+        }
+        
+        // Check if NodeIdentityManager already has a name for this node
+        const identityName = this.nodeIdentityManager.getLabel(nodeId);
+        
+        // Check if the identityName looks like a numeric ID (which would mean no real label was found)
+        const isNumericLabel = /^\d+$/.test(identityName);
+        
+        // Log detailed info about identities to help diagnose labeling issues
+        this.logger.debug(`Label resolution for node ${nodeId}:`, {
+            identityName,
+            isNumericLabel,
+            hasMetadata: !!metadata,
+            metadataName: metadata?.name
+        });
+        
+        // Use the identity name if it's valid (not just numeric or the node ID itself)
+        if (identityName && !isNumericLabel && identityName !== nodeId) {
+            // Update our cache with the identity manager's name
+            this.nodeMetadataCache.set(nodeId, identityName);
+            return identityName;
+        }
+        
+        // Otherwise, create a new mapping prioritizing metadata fields
+        // First check if metadata has any usable name fields
+        let displayName: string | undefined;
+        
+        if (metadata.file_name && metadata.file_name !== nodeId) {
+            displayName = metadata.file_name;
+        } else if (metadata.name && metadata.name !== nodeId) {
+            displayName = metadata.name;
+        }
+        
+        // If no usable name found, fallback to Node {id}
+        if (!displayName) {
+            displayName = `Node ${nodeId}`;
+        }
+        
+        // If we need to ensure uniqueness and the display name might be shared by other nodes
+        // add the node ID as a suffix to guarantee uniqueness
+        if (forceUnique) {
+            // First check if this label is already used for other nodes
+            const nodesWithLabel = this.nodeIdentityManager.getNodesWithLabel(displayName);
+            if (nodesWithLabel.length > 1 || 
+                (nodesWithLabel.length === 1 && nodesWithLabel[0] !== nodeId)) {
+                // This label is used elsewhere, make it unique with node ID
+                displayName = `${displayName} (${nodeId})`;
+                this.logger.debug(`Made label unique for node ${nodeId}: ${displayName}`);
+            }
+        }
+        
+        // Always update the NodeIdentityManager with our resolved name
+        // Always update the identity manager regardless of previous value
+        this.nodeIdentityManager.setLabel(nodeId, displayName);
+        
+        // Cache this mapping for future use
+        this.nodeMetadataCache.set(nodeId, displayName);
+        return displayName;
+    }
+
+    public async createMetadataLabel(metadata: NodeMetadata, nodeId: string): Promise<MetadataLabelGroup> {
+        // Track how many labels we've created
+        this.labelUpdateCount++;
+
+        // Log detailed metadata info at debug level
+        this.logger.debug(`Creating label for node ${nodeId}`, {
+            name: metadata.name,
+            id: metadata.id,
+            fileSize: metadata.fileSize,
+            file_name: metadata.file_name,
+            hyperlinkCount: metadata.hyperlinkCount,
+            originalNodeId: nodeId
+        });
+
+        // Ensure nodeId and metadata.id are consistent - this helps with debuggability
+        if (nodeId !== metadata.id && debugState.isDataDebugEnabled()) {
+            this.logger.debug(`Node ID mismatch: nodeId parameter ${nodeId} differs from metadata.id ${metadata.id}`);
+        }
+
+        const group = new Group() as MetadataLabelGroup;
+        group.name = 'metadata-label';
+        group.userData = { 
+            isMetadata: true,
+            // Ensure we're storing the correct nodeId for position updates
+            nodeId,
+            metadataName: metadata.name
+        };
+
+        // Format file size
+        const fileSizeFormatted = !metadata.fileSize ? '0B' : metadata.fileSize > 1024 * 1024 
+            ? `${(metadata.fileSize / (1024 * 1024)).toFixed(1)}MB`
+            : metadata.fileSize > 1024
+                ? `${(metadata.fileSize / 1024).toFixed(1)}KB`
+                : `${metadata.fileSize}B`;
+                
+        // Log actual file size for debugging
+        if (this.debugEnabled) {
+            console.log(`[MetadataVisualizer] File size for node ${nodeId}: ${metadata.fileSize} bytes (${fileSizeFormatted})`);
+        }
+
+        // Only log detailed metadata at trace level (effectively disabling it)
+        if (debugState.isDataDebugEnabled()) {
+            this.logger.debug(`Creating metadata label #${this.labelUpdateCount}:`, {
+                nodeIdForMapping: nodeId,
+                metadataId: metadata.id,
+                metadata: {
+                    name: metadata.name,
+                    fileSize: fileSizeFormatted,
+                    nodeSize: metadata.nodeSize
+                }
+            });
+        }
+
+        // Resolve the display name with forced uniqueness
+        const displayName = this.resolveDisplayName(metadata, nodeId, true);
+        
+        // Log if we're displaying a numeric ID as the label
+        if (/^\d+$/.test(displayName) && debugState.isNodeDebugEnabled()) {
+            this.logger.warn(`Using numeric ID as label for node ${nodeId}`, {
+                displayName,
+                metadata: {
+                    name: metadata.name,
+                    id: metadata.id
+                }
+            });
+        }
+        
+
+        // Create text labels using UnifiedTextRenderer
+        // First, find the node's actual position
+        let nodePosition = new Vector3(0, 0, 0);
+        
+        // Get the actual node position from some source in the scene
+        // This solves the labels "dropping in from above" issue
+        if (debugState.isDataDebugEnabled()) {
+            this.logger.debug(`Searching for node position for ${nodeId}`);
+        }
+        
+        // We'll set the group's position initially to help with initialization
+        // Ensure we have a valid position
+        group.position.copy(nodePosition);
+        
+        // Customized label text based on available data
+        // Always ensure the main label is the unique display name
+        const labelTexts = [];
+        
+        // Main label is always the unique display name
+        labelTexts.push(displayName);
+        labelTexts.push(fileSizeFormatted);  // File size
+        labelTexts.push(`${metadata.hyperlinkCount || 0} links`);  // Link count
+
+        // Make the yOffsets 10x smaller
+        const yOffsets = [0.005, 0.003, 0.001]; // Reduced from [0.05, 0.03, 0.01]
+
+        labelTexts.forEach(async (text, index) => {
+            const position = new Vector3(nodePosition.x, nodePosition.y + yOffsets[index], nodePosition.z);
+            const labelId = `${nodeId}-label-${index}`;
+            
+            try {
+                this.textRenderer.updateLabel(
+                    labelId,
+                    text,
+                    position,
+                    new Color(this.settings.visualization.labels.textColor)
+                );
+                // Only log when specific data debugging is enabled
+                if (debugState.isDataDebugEnabled()) {
+                    this.logger.debug(`Created label ${index+1}/3 for node ${nodeId}`, {
+                        labelId
+                    });
+                }
+            } catch (error) {
+                this.logger.error(`Failed to create label ${index+1}/3 for node ${nodeId}`, {
+                    error: error instanceof Error ? error.message : String(error),
+                    labelId,
+                    text
+                });
+            }
+        });
+
+        this.metadataGroups.set(nodeId, group);
+        
+        // Add call to update position immediately to prevent "dropping in" effect
+        this.updateMetadataPosition(nodeId, nodePosition);
+        
+        return group;
+    }
+
+    private setGroupLayer(group: Object3D, enabled: boolean): void {
+        this.logger.debug(`Setting layer mode: ${enabled ? 'XR' : 'Desktop'}`);
+        
+        if (enabled) {
+            group.traverse(child => {
+                child.layers.disable(0);
+                child.layers.enable(1);
+            });
+            group.layers.disable(0);
+            group.layers.enable(1);
+        } else {
+            group.traverse(child => {
+                child.layers.enable(0);
+                child.layers.enable(1);
+            });
+            group.layers.enable(0);
+            group.layers.enable(1);
+        }
+    }
+
+    /**
+     * Update visibility threshold for labels
+     */
+    public setXRMode(enabled: boolean): void {
+        this.logger.info(`Switching to ${enabled ? 'XR' : 'Desktop'} mode`);
+        this.textRenderer.setXRMode(enabled);
+        this.setGroupLayer(this.labelGroup, enabled);
+        // Text renderer handles its own XR mode
+    }
+
+    public updateMetadataPosition(nodeId: string, position: Vector3): void {
+        const group = this.metadataGroups.get(nodeId);
+        if (group) {
+            group.position.copy(position);
+            
+            // Update text positions - use smaller offsets
+            const labelPositions = [0.005, 0.003, 0.001]; // Reduced from [0.05, 0.03, 0.01]
+            labelPositions.forEach((yOffset, index) => {
+                const labelId = `${nodeId}-label-${index}`;
+                // Create relative position to the node with y-offset
+                const relativePosition = new Vector3(0, yOffset, 0);
+                const labelPosition = position.clone().add(relativePosition);
+                
+                // Update only the position, preserving the existing text content
+                this.textRenderer.updateLabel(labelId, '', labelPosition, undefined, true);
+
+                // Only show debug helpers when debug is enabled
+                if (debugState.isEnabled()) {
+                    const debugId = `${labelId}-debug`;
+                    let debugSphere = this.debugHelpers.get(debugId) as Mesh | undefined;
+                    if (!debugSphere) {
+                        const geometry = new SphereGeometry(0.1);
+                        const material = new MeshBasicMaterial({ color: 0xff0000 });
+                        debugSphere = new Mesh(geometry, material) as Mesh;
+                        this.labelGroup.add(debugSphere);
+                        this.debugHelpers.set(debugId, debugSphere);
+                    }
+                    debugSphere.position.copy(labelPosition);
+                    debugSphere.visible = true;
+                }
+            });
+        } else if (debugState.isNodeDebugEnabled() && Math.random() < 0.01) {
+            // Periodically log missing nodes to help diagnose issues
+            // Only show this 1% of the time to avoid log flooding
+            this.logger.debug(`No metadata group found for node ${nodeId} during position update`);
+        }
+    }
+
+    /**
+     * Updates the visibility threshold for metadata labels
+     */
+    public updateVisibilityThreshold(threshold: number): void {
+        this.visibilityThreshold = threshold;
+        this.logger.info('Updated visibility threshold:', { 
+            threshold, 
+            labelsCount: this.metadataGroups.size 
+        });
+    }
+
+    public removeMetadata(nodeId: string): void {
+        const group = this.metadataGroups.get(nodeId);
+        if (group) {
+            this.labelGroup.remove(group);
+            this.metadataGroups.delete(nodeId);
+            
+            // Remove text labels
+            [0, 1, 2].forEach(index => {
+                const labelId = `${nodeId}-label-${index}`;
+                this.textRenderer.removeLabel(labelId);
+                const debugId = `${labelId}-debug`;
+                
+                if (debugState.isEnabled()) {
+                    // Remove debug helpers
+                    const debugHelper = this.debugHelpers.get(debugId);
+                    if (debugHelper) this.labelGroup.remove(debugHelper);
+                }
+                if (this.debugHelpers.has(debugId)) this.debugHelpers.delete(debugId);
+            });
+        }
+    }
+    
+    /**
+     * Update all metadata labels - called once per frame
+     */
+    public update(_camera: PerspectiveCamera): void {
+        // Very rarely log how many labels we're tracking
+        if (Math.random() < 0.00001 && this.metadataGroups.size > 0) { // Reduced to 0.001% to avoid spamming logs
+            // Only log if data debugging is specifically enabled
+            if (debugState.isDataDebugEnabled()) {
+                this.logger.debug('Metadata update stats:', {
+                    labelsCount: this.metadataGroups.size,
+                    enabled: this.settings.visualization.labels.enableLabels,
+                    rendererActive: this.textRenderer !== null,
+                    visibilityThreshold: this.visibilityThreshold
+                });
+            }
+        }
+        // The text renderer handles label positions and visibility
+        // NOTE: We're not updating any labels here - the text renderer manages them
+        // This prevents us from inadvertently overwriting labels during the update cycle
+    }
+
+    public dispose(): void {
+        this.metadataGroups.forEach(group => {
+            if (group.userData.nodeId) {
+                try {
+                    this.removeMetadata(group.userData.nodeId);
+                } catch (e) {
+                    this.logger.error(`Error removing metadata for node ${group.userData.nodeId}`, {
+                        error: e instanceof Error ? e.message : String(e)
+                    });
+                }
+            }
+        });
+        this.metadataGroups.clear();
+        // Don't dispose the text renderer itself, as we'll reuse it
+        
+        // Clear our metadata cache when disposing
+        this.nodeMetadataCache.clear();
+        // this.textRenderer.dispose();
+        if (this.labelGroup.parent) {
+            // Clean up debug helpers
+            this.debugHelpers.forEach(helper => {
+                this.labelGroup.remove(helper);
+            });
+            this.debugHelpers.clear();
+            // Don't remove the label group from the scene, just clear it
+            // this.labelGroup.parent.remove(this.labelGroup);
+        }
+        
+        this.logger.info('Cleared all metadata visualizations');
+    }
+    
+    /**
+     * Clear all label content without fully disposing
+     */
+    public clearAllLabels(): void {
+        // Store node IDs before clearing
+        const nodeIds = Array.from(this.metadataGroups.keys());
+        
+        // Debounce clear operations to prevent excessive clearing
+        const now = performance.now();
+        if (now - this.lastClearTime < 1000) {
+            // If a clear was performed in the last second, just log and return
+            this.logger.debug(`Skipping redundant label clear operation (too soon after last clear)`);
+            return;
+        }
+        this.lastClearTime = now;
+        
+        // Remove all labels
+        nodeIds.forEach(nodeId => {
+            this.removeMetadata(nodeId);
+        });
+        
+        this.metadataGroups.clear();
+        this.nodeMetadataCache.clear();
+        this.debugHelpers.clear();
+        
+        this.logger.info(`Cleared ${nodeIds.length} metadata labels`);
+    }
+}
diff --git a/client/rendering/SDFFontAtlasGenerator.ts b/client/rendering/SDFFontAtlasGenerator.ts
new file mode 100644
index 00000000..ddcf8cd7
--- /dev/null
+++ b/client/rendering/SDFFontAtlasGenerator.ts
@@ -0,0 +1,236 @@
+import { createLogger } from '../core/logger';
+import { Texture, LinearFilter, ClampToEdgeWrapping } from 'three';
+
+const logger = createLogger('SDFFontAtlasGenerator');
+
+interface GlyphMetrics {
+    width: number;
+    height: number;
+    advanceWidth: number;
+    bearingX: number;
+    bearingY: number;
+}
+
+interface GlyphInfo {
+    char: string;
+    metrics: GlyphMetrics;
+    textureX: number;
+    textureY: number;
+    textureWidth: number;
+    textureHeight: number;
+}
+
+export class SDFFontAtlasGenerator {
+    private canvas: HTMLCanvasElement;
+    private ctx: CanvasRenderingContext2D;
+    private atlasSize: number;
+    private padding: number;
+    private spread: number;
+    private glyphInfoMap: Map<string, GlyphInfo>;
+    private readonly superSampling: number = 2; // Supersampling factor for higher quality
+    
+    constructor(atlasSize = 2048, padding = 8, spread = 16) {
+        this.atlasSize = atlasSize;
+        this.padding = padding;
+        this.spread = spread;
+        this.glyphInfoMap = new Map();
+        
+        // Create high-res canvas for supersampling
+        this.canvas = document.createElement('canvas');
+        this.canvas.width = atlasSize * this.superSampling;
+        this.canvas.height = atlasSize * this.superSampling;
+        
+        const ctx = this.canvas.getContext('2d', { 
+            alpha: true,
+            antialias: true,
+            desynchronized: true
+        }) as CanvasRenderingContext2D;
+        if (!ctx) {
+            throw new Error('Failed to get 2D context');
+        }
+        this.ctx = ctx;
+        
+        // Enable high-quality rendering
+        (this.ctx as any).textRendering = 'geometricPrecision';
+        this.ctx.imageSmoothingEnabled = true;
+        this.ctx.imageSmoothingQuality = 'high';
+    }
+    
+    public async generateAtlas(
+        fontFamily: string,
+        fontSize: number,
+        chars: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,!?-+/():;%&`\'*#=[]" '
+    ): Promise<{ texture: Texture; glyphInfoMap: Map<string, GlyphInfo> }> {
+        logger.info('Generating font atlas:', {
+            fontFamily,
+            fontSize,
+            atlasSize: this.atlasSize,
+            padding: this.padding,
+            spread: this.spread,
+            chars: chars.length,
+            superSampling: this.superSampling
+        });
+
+        // Scale font size for supersampling
+        const scaledFontSize = fontSize * this.superSampling;
+        this.ctx.font = `${scaledFontSize}px ${fontFamily}`;
+        this.ctx.textBaseline = 'alphabetic';
+        this.ctx.fillStyle = 'white';
+        this.ctx.strokeStyle = 'white';
+        
+        // Clear canvas with transparency
+        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
+        
+        // Calculate glyph positions with supersampling
+        let x = this.padding * this.superSampling;
+        let y = (this.padding + fontSize) * this.superSampling;
+        const lineHeight = fontSize * 1.4 * this.superSampling;
+        
+        // Generate glyphs and compute SDF
+        for (const char of chars) {
+            const metrics = this.getGlyphMetrics(char, fontSize);
+            
+            // Check if we need to move to next line
+            if (x + metrics.width + this.padding > this.canvas.width) {
+                x = this.padding * this.superSampling;
+                y += lineHeight;
+                
+                if (y + lineHeight > this.canvas.height) {
+                    logger.warn('Atlas size exceeded, some characters may be missing');
+                    break;
+                }
+            }
+            
+            // Draw glyph
+            this.ctx.fillStyle = 'white';
+            this.ctx.fillText(char, x, y);
+            
+            // Store glyph info
+            this.glyphInfoMap.set(char, {
+                char,
+                metrics,
+                textureX: x,
+                textureY: y - fontSize,
+                textureWidth: metrics.width + this.padding * 2,
+                textureHeight: fontSize + this.padding * 2
+            });
+            
+            x += metrics.width + this.padding * 2;
+        }
+        
+        // Generate SDF
+        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
+        const sdf = this.computeSDF(imageData.data);
+        
+        // Apply SDF to canvas
+        const sdfImageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
+        for (let i = 0; i < sdf.length; i++) {
+            const value = Math.floor(sdf[i] * 255);
+            const idx = i * 4;
+            sdfImageData.data[idx] = value;
+            sdfImageData.data[idx + 1] = value;
+            sdfImageData.data[idx + 2] = value;
+            sdfImageData.data[idx + 3] = 255;
+        }
+        this.ctx.putImageData(sdfImageData, 0, 0);
+        
+        logger.info('Font atlas generated:', {
+            glyphCount: this.glyphInfoMap.size,
+            sampleGlyphs: Array.from(this.glyphInfoMap.entries())
+                .slice(0, 3)
+                .map(([char, info]) => ({
+                    char,
+                    textureX: info.textureX,
+                    textureY: info.textureY,
+                    width: info.textureWidth,
+                    height: info.textureHeight
+                }))
+        });
+
+        // Create texture with better filtering
+        const texture = new Texture(this.canvas);
+        texture.needsUpdate = true;
+        texture.minFilter = LinearFilter;
+        texture.magFilter = LinearFilter;
+        texture.wrapS = ClampToEdgeWrapping;
+        texture.wrapT = ClampToEdgeWrapping;
+        
+        // Downscale canvas to final size
+        const finalCanvas = document.createElement('canvas');
+        finalCanvas.width = this.atlasSize;
+        finalCanvas.height = this.atlasSize;
+        const finalCtx = finalCanvas.getContext('2d');
+        if (finalCtx) {
+            finalCtx.imageSmoothingEnabled = true;
+            finalCtx.imageSmoothingQuality = 'high';
+            finalCtx.drawImage(this.canvas, 0, 0, this.atlasSize, this.atlasSize);
+            (texture as any).image = finalCanvas;
+            texture.needsUpdate = true;
+        }
+        
+        return {
+            texture,
+            glyphInfoMap: this.glyphInfoMap
+        };
+    }
+    
+    private getGlyphMetrics(char: string, fontSize: number): GlyphMetrics {
+        const metrics = this.ctx.measureText(char);
+        return {
+            width: metrics.width,
+            height: fontSize,
+            advanceWidth: metrics.width,
+            bearingX: 0,
+            bearingY: metrics.actualBoundingBoxAscent
+        };
+    }
+    
+    private computeSDF(imageData: Uint8ClampedArray): Float32Array {
+        const width = this.canvas.width;
+        const height = this.canvas.height;
+        const sdf = new Float32Array(width * height);
+        
+        // Simple 8-bit SDF computation
+        for (let y = 0; y < height; y++) {
+            for (let x = 0; x < width; x++) {
+                const idx = (y * width + x) * 4;
+                const alpha = imageData[idx + 3] / 255;
+                
+                if (alpha > 0.5) {
+                    // Inside glyph
+                    sdf[y * width + x] = Math.min(1, this.computeDistance(x, y, imageData, false) / this.spread);
+                } else {
+                    // Outside glyph
+                    sdf[y * width + x] = Math.max(0, 1 - this.computeDistance(x, y, imageData, true) / this.spread);
+                }
+            }
+        }
+        
+        return sdf;
+    }
+    
+    private computeDistance(x: number, y: number, imageData: Uint8ClampedArray, inside: boolean): number {
+        let minDist = this.spread * 2;
+        const width = this.canvas.width;
+        
+        // Search in a square around the point
+        for (let dy = -this.spread; dy <= this.spread; dy++) {
+            for (let dx = -this.spread; dx <= this.spread; dx++) {
+                const sx = x + dx;
+                const sy = y + dy;
+                
+                if (sx >= 0 && sx < width && sy >= 0 && sy < width) {
+                    const idx = (sy * width + sx) * 4;
+                    const alpha = imageData[idx + 3] / 255;
+                    
+                    if ((inside && alpha <= 0.5) || (!inside && alpha > 0.5)) {
+                        const dist = Math.sqrt(dx * dx + dy * dy);
+                        minDist = Math.min(minDist, dist);
+                    }
+                }
+            }
+        }
+        
+        return minDist;
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/UnifiedTextRenderer.ts b/client/rendering/UnifiedTextRenderer.ts
new file mode 100644
index 00000000..d7660290
--- /dev/null
+++ b/client/rendering/UnifiedTextRenderer.ts
@@ -0,0 +1,437 @@
+import {
+    Scene,
+    Camera,
+    Group,
+    Texture,
+    BufferGeometry,
+    NearestFilter,
+    ClampToEdgeWrapping,
+    InstancedBufferAttribute,
+    PlaneGeometry,
+    Mesh,
+    Vector3,
+    Color,
+    MeshBasicMaterial,
+    BufferAttribute
+} from 'three';
+import { debugState } from '../core/debugState';
+import { createLogger } from '../core/logger';
+import { LabelSettings } from '../types/settings';
+import { platformManager } from '../platform/platformManager';
+import { SDFFontAtlasGenerator } from './SDFFontAtlasGenerator';
+import '../types/three-ext.d';
+
+const logger = createLogger('UnifiedTextRenderer');
+
+// Note: Using fallback basic material approach instead of custom shaders
+// to avoid WebGL shader compilation issues
+
+interface LabelInstance {
+    id: string;
+    text: string;
+    position: Vector3;
+    scale: number;
+    color: Color;
+    visible: boolean;
+    lastUpdated: number; // Timestamp for debugging update sequence
+}
+
+export class UnifiedTextRenderer {
+    private scene: Scene;
+    private camera: Camera;
+    private group: Group;
+    private material: MeshBasicMaterial;
+    private geometry: BufferGeometry;
+    private mesh: Mesh;
+    private fontAtlas: Texture | null;
+    private labels: Map<string, LabelInstance>;
+    private settings: LabelSettings;
+    private maxInstances: number;
+    private currentInstanceCount: number;
+    private logger = createLogger('UnifiedTextRenderer');
+    private fontAtlasGenerator: SDFFontAtlasGenerator;
+    // Reduced LABEL_SCALE by 10x
+    private readonly LABEL_SCALE = 0.05; // Was 0.5 previously
+    
+    constructor(camera: Camera, scene: Scene, settings: LabelSettings) {
+        this.scene = scene;
+        this.camera = camera;
+        this.settings = settings;
+        
+        // Only log detailed settings when data debugging is enabled
+        if (debugState.isDataDebugEnabled()) {
+            logger.info('UnifiedTextRenderer settings:', {
+                enableLabels: this.settings.enableLabels,
+                desktopFontSize: this.settings.desktopFontSize,
+                textColor: this.settings.textColor,
+                billboardMode: this.settings.billboardMode
+            });
+        }
+
+        this.labels = new Map();
+        this.maxInstances = 2000;
+        this.currentInstanceCount = 0;
+        this.fontAtlas = null;
+        
+        this.group = new Group();
+        this.scene.add(this.group);
+        
+        this.fontAtlasGenerator = new SDFFontAtlasGenerator(2048, 8, 16);
+
+        // Only log initialization details when debugging is enabled
+        if (debugState.isDataDebugEnabled()) {
+            this.logger.info('Initializing material with basic settings', {
+                color: this.settings.textColor,
+                transparent: true
+            });
+        }
+        
+        // Use basic material instead of shader material to avoid WebGL issues.
+        // Disable depthTest and depthWrite so labels are always visible.
+        this.material = new MeshBasicMaterial({ 
+            color: new Color(this.settings.textColor),
+            transparent: true,
+            depthTest: false,
+            depthWrite: false
+        });
+        
+        this.geometry = this.createInstancedGeometry();
+        
+        // Only log geometry details when debugging is enabled
+        if (debugState.isDataDebugEnabled()) {
+            this.logger.info('Created instanced geometry:', {
+                maxInstances: this.maxInstances,
+                instancePosition: this.geometry.getAttribute('instancePosition')?.count,
+                instanceColor: this.geometry.getAttribute('instanceColor')?.count,
+                instanceScale: this.geometry.getAttribute('instanceScale')?.count
+            });
+        }
+        
+        this.mesh = new Mesh(this.geometry, this.material);
+        // Ensure text labels render on top by assigning a very high render order
+        this.mesh.renderOrder = 1000; // Increased to match NodeMetadataManager sprite renderOrder
+        this.group.add(this.mesh);
+        
+        this.setXRMode(platformManager.isXRMode);
+        platformManager.on('xrmodechange', (enabled: boolean) => {
+            this.setXRMode(enabled);
+        });
+        
+        // Initialize font atlas
+        this.initializeFontAtlas();
+    }
+    
+    private async initializeFontAtlas(): Promise<void> {
+        try {
+            // Only log font atlas generation details when debugging is enabled
+            if (debugState.isDataDebugEnabled()) {
+                this.logger.info('Starting font atlas generation with params:', {
+                    fontFamily: 'Arial',
+                    fontSize: 32,
+                    textureSize: (this.fontAtlasGenerator as any)['atlasSize'],
+                    padding: (this.fontAtlasGenerator as any)['padding'],
+                    spread: (this.fontAtlasGenerator as any)['spread']
+                });
+            }
+
+            const { texture } = await this.fontAtlasGenerator.generateAtlas(
+                'Arial',
+                32 // Base font size for SDF
+            );
+            
+            // Configure texture parameters
+            texture.minFilter = NearestFilter;
+            texture.magFilter = NearestFilter;
+            texture.wrapS = ClampToEdgeWrapping;
+            texture.wrapT = ClampToEdgeWrapping;
+            
+            this.fontAtlas = texture;
+            
+            // Only log atlas generation completion when debugging is enabled
+            if (debugState.isDataDebugEnabled()) {
+                this.logger.info('Font atlas generated successfully:', {
+                    textureWidth: (texture as any).image?.width,
+                    textureHeight: (texture as any).image?.height,
+                    format: (texture as any).format,
+                    mipmaps: (texture as any).mipmaps?.length || 0
+                });
+            }
+            
+            // Update all existing labels
+            this.labels.forEach((label, id) => {
+                this.updateLabel(id, label.text, label.position, label.color);
+            });
+        } catch (error) {
+            this.logger.error('Failed to initialize font atlas:', {
+                error,
+                message: error instanceof Error ? error.message : String(error),
+                stack: error instanceof Error ? error.stack : undefined
+            });
+        }
+    }
+    
+    private createInstancedGeometry(): BufferGeometry {
+        const baseGeometry = new PlaneGeometry(1, 1);
+        const instancedGeometry = new BufferGeometry();
+        
+        // Copy attributes from base geometry
+        const position = baseGeometry.getAttribute('position');
+        const uv = baseGeometry.getAttribute('uv');
+        const normal = baseGeometry.getAttribute('normal');
+        
+        instancedGeometry.setAttribute('position', position);
+        instancedGeometry.setAttribute('uv', uv);
+        if (normal) instancedGeometry.setAttribute('normal', normal);
+        
+        // Set up instanced attributes with proper sizes
+        const instancePositions = new Float32Array(this.maxInstances * 3); // vec3
+        const instanceColors = new Float32Array(this.maxInstances * 4);    // vec4
+        const instanceScales = new Float32Array(this.maxInstances);        // float
+        
+        // Initialize instance attributes with proper itemSize
+        instancedGeometry.setAttribute(
+            'instancePosition',
+            new InstancedBufferAttribute(instancePositions, 3, false)
+        );
+        instancedGeometry.setAttribute(
+            'instanceColor',
+            new InstancedBufferAttribute(instanceColors, 4, false)
+        );
+        instancedGeometry.setAttribute(
+            'instanceScale',
+            new InstancedBufferAttribute(instanceScales, 1, false)
+        );
+        
+        // Copy index if present
+        const index = (baseGeometry as any).index;
+        if (index instanceof BufferAttribute) {
+            instancedGeometry.setIndex(index);
+        }
+        
+        // Clean up base geometry
+        baseGeometry.dispose();
+                
+        return instancedGeometry;
+    }
+    
+    /**
+     * Update the label for a specific node. 
+     * 
+     * @param id - Unique ID for the label
+     * @param text - Text to display. If empty and preserveText=true, position will be updated but text preserved
+     * @param position - 3D position for the label
+     * @param color - Optional color for the label
+     * @param preserveText - If true and text is empty, existing text will be preserved (position-only update)
+     */
+    public updateLabel(id: string, text: string, position: Vector3, color?: Color, preserveText: boolean = false): void {
+        // Handle empty text cases
+        const isEmptyText = !text || text.trim() === '';
+        
+        // If we have an empty string and we're not preserving text, this is a no-op
+        if (isEmptyText && !preserveText) {
+            return;
+        }
+        
+        // Check if this is a position-only update (empty text but preserveText flag)
+        const isPositionUpdate = isEmptyText && preserveText;
+        
+        // Find existing label or prepare to create new one
+        let label = this.labels.get(id);
+        
+        // POSITION UPDATE: If this is a position-only update for an existing label
+        if (isPositionUpdate && label) {
+            // Just update the position and leave everything else untouched
+            label.position.copy(position);
+            label.lastUpdated = Date.now();
+            
+            // Debug logging for position updates
+            if (debugState.isDataDebugEnabled() && Math.random() < 0.01) { // Log ~1% of updates
+                this.logger.debug('Position-only update for label:', {
+                    id,
+                    text: label.text,
+                    posX: position.x,
+                    posY: position.y,
+                    posZ: position.z
+                });
+            }
+            
+            // Update instance attributes to reflect new positions
+            this.updateInstanceAttributes();
+            return;
+        }
+        
+        // NEW LABEL: If the label doesn't exist yet, create it
+        if (!label) {
+            // Check if we've hit the instance limit
+            if (this.currentInstanceCount >= this.maxInstances) {
+                this.logger.warn(`Maximum instance count (${this.maxInstances}) reached, cannot add more labels`);
+                return;
+            }
+            
+            // For new labels, we must have actual text content
+            if (isEmptyText) {
+                // Don't create empty labels
+                return;
+            }
+            
+            // Create new label instance
+            label = {
+                id,
+                text,
+                position: position.clone(),
+                scale: 1.0,
+                color: color || new Color(this.settings.textColor),
+                visible: true,
+                lastUpdated: Date.now()
+            };
+            
+            if (debugState.isDataDebugEnabled()) {
+                this.logger.debug('Created new label instance:', {
+                    id,
+                    text,
+                    instanceIndex: this.currentInstanceCount
+                });
+            }
+            
+            this.labels.set(id, label);
+            this.currentInstanceCount++;
+        } 
+        // UPDATE EXISTING: Update an existing label
+        else {
+            // Only update text if we have new non-empty text
+            if (!isEmptyText) {
+                if (label.text !== text) {
+                    if (debugState.isDataDebugEnabled()) {
+                        this.logger.debug(`Updated label text: "${label.text}" -> "${text}"`);
+                    }
+                    label.text = text;
+                }
+            }
+            
+            // Always update position
+            label.position.copy(position);
+            
+            // Update color if provided
+            if (color) {
+                label.color = color;
+            }
+            
+            label.lastUpdated = Date.now();
+        }
+        
+        // Update the instance attributes to reflect changes
+        this.updateInstanceAttributes();
+    }
+    
+    private updateInstanceAttributes(): void {
+        const positions = (this.geometry.getAttribute('instancePosition') as InstancedBufferAttribute).array as Float32Array;
+        const colors = (this.geometry.getAttribute('instanceColor') as InstancedBufferAttribute).array as Float32Array;
+        const scales = (this.geometry.getAttribute('instanceScale') as InstancedBufferAttribute).array as Float32Array;
+
+        // Only log updates in debug mode
+        if (debugState.isDataDebugEnabled() && Math.random() < 0.01) { // Log ~1% of updates
+            this.logger.debug('Updating instance attributes:', {
+                currentInstanceCount: this.currentInstanceCount,
+                labelsCount: this.labels.size
+            });
+        }
+        
+        let index = 0;
+        this.labels.forEach(label => {
+            if (label.visible) {
+                // Copy position data
+                positions[index * 3] = label.position.x;
+                positions[index * 3 + 1] = label.position.y;
+                positions[index * 3 + 2] = label.position.z;
+                
+                // Copy color data
+                const colorArray = label.color.toArray();
+                colors.set(colorArray, index * 4);
+                colors[index * 4 + 3] = 1.0; // Alpha
+                
+                // Copy scale data
+                scales[index] = label.scale * this.LABEL_SCALE;
+                
+                index++;
+            }
+        });
+        
+        // Set instance count on the mesh
+        (this.mesh as any).instanceCount = index;
+        
+        // Mark attributes as needing update
+        (this.geometry.getAttribute('instancePosition') as InstancedBufferAttribute).needsUpdate = true;
+        (this.geometry.getAttribute('instanceColor') as InstancedBufferAttribute).needsUpdate = true;
+        (this.geometry.getAttribute('instanceScale') as InstancedBufferAttribute).needsUpdate = true;
+    }
+    
+    public removeLabel(id: string): void {
+        if (this.labels.delete(id)) {
+            this.currentInstanceCount--;
+            this.updateInstanceAttributes();
+            
+            if (debugState.isDataDebugEnabled()) {
+                this.logger.debug(`Removed label ${id}`);
+            }
+        }
+    }
+    
+    public setXRMode(enabled: boolean): void {
+        if (enabled) {
+            this.group.layers.disable(0);
+            this.group.layers.enable(1);
+        } else {
+            this.group.layers.enable(0);
+            this.group.layers.enable(1);
+        }
+    }
+    
+    /**
+     * Perform per-frame updates for all labels
+     */
+    public update(): void {
+        if (!this.camera || !this.material) return;
+        
+        // For camera billboard mode: Ensure all labels remain visible
+        if (this.settings.billboardMode === 'camera') {
+            this.labels.forEach(label => {
+                label.visible = true;
+            });
+        } else {
+            // For other modes: Update visibility based on camera position
+            this.labels.forEach(label => label.visible = this.isLabelVisible(label));
+        }
+
+        this.updateInstanceAttributes();
+    }
+
+    private isLabelVisible(label: LabelInstance): boolean {
+        if (!label.visible) return false;
+        
+        // When billboard_mode is "camera", don't cull labels based on position relative to camera
+        // This ensures labels are visible regardless of which side of the origin they're on
+        if (this.settings.billboardMode === 'camera') {
+            return true;
+        }
+        
+        // For other billboard modes, use distance-based culling with the camera's far plane
+        const distanceToCamera = label.position.distanceTo(this.camera.position);
+        const margin = 5.0;  // Units in world space
+        
+        // Check if label is within camera's view distance (with margin)
+        return distanceToCamera <= (this.camera as any).far + margin;
+    }
+
+    public dispose(): void {
+        this.geometry.dispose();
+        if (this.material) {
+            this.material.dispose();
+        }
+        if (this.fontAtlas) {
+            this.fontAtlas.dispose();
+        }
+        if (this.group && this.group.parent) {
+            this.group.parent.remove(this.group);
+        }
+    }
+}
diff --git a/client/rendering/VisualizationController.ts b/client/rendering/VisualizationController.ts
new file mode 100644
index 00000000..603cadb0
--- /dev/null
+++ b/client/rendering/VisualizationController.ts
@@ -0,0 +1,1029 @@
+import {
+  Scene,
+  PerspectiveCamera,
+  // WebGLRenderer,
+  Vector3,
+  // Quaternion,
+  // Matrix4,
+  // Group,
+  // Mesh,
+  // MeshBasicMaterial,
+  // Color,
+  // Raycaster,
+  // Object3D,
+  // Euler,
+  // MathUtils,
+} from 'three';
+import { createLogger, createErrorMetadata, createDataMetadata } from '../core/logger';
+import { Settings } from '../types/settings/base';
+import { defaultSettings } from '../state/defaultSettings';
+import { XRHandWithHaptics } from '../types/xr';
+import { EdgeManager } from './EdgeManager';
+import { NodeManagerFacade } from './node/NodeManagerFacade';
+import { graphDataManager } from '../state/graphData';
+import { MetadataVisualizer } from './MetadataVisualizer';
+import { GraphData } from '../core/types';
+import { WebSocketService } from '../websocket/websocketService';
+import { NodeMetadata } from '../types/metadata';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { SettingsStore } from '../state/SettingsStore';
+// import { debugState } from '../core/debugState'; // Commented out as it's unused
+import { GraphDataManager } from '../state/graphData';
+import { Node } from '../core/types';
+
+const logger = createLogger('VisualizationController');
+
+type VisualizationCategory = 'visualization' | 'physics' | 'rendering';
+type PendingUpdate = { category: VisualizationCategory; value: any };
+
+export class VisualizationController {
+    private static instance: VisualizationController | null = null;
+    private currentSettings: Settings;
+    private edgeManager: EdgeManager | null = null;
+    private nodeManager: NodeManagerFacade | null = null;
+    private metadataVisualizer: MetadataVisualizer | null = null;
+    private isInitialized: boolean = false;
+    private pendingUpdates: Map<string, PendingUpdate> = new Map();
+    private lastUpdateTime: number = performance.now();
+    private websocketService: WebSocketService;
+    private metadataVisualizationInitialized: boolean = false; 
+    private lastMetadataUpdateTime: number = 0;
+    private isRandomizationInProgress: boolean = false;
+    private hasReceivedBinaryUpdate: boolean = false;
+    private randomizationStartTime: number = 0;
+    private randomizationAcknowledged: boolean = false;
+    private randomizedNodeIds: Set<string> = new Set();
+    private loadingIndicator: HTMLElement | null = null;
+
+    private constructor() {
+        // Initialize with complete default settings
+        this.currentSettings = defaultSettings;
+        
+        // Subscribe to the SettingsStore for updates
+        const settingsStore = SettingsStore.getInstance();
+        settingsStore.subscribe('', (_, value) => {
+            if (value && typeof value === 'object') {
+                this.refreshSettings(value as Settings);
+            }
+        });
+        
+        this.websocketService = WebSocketService.getInstance();
+        
+        // Subscribe to graph data updates
+        graphDataManager.subscribe((data: GraphData) => {
+            if (this.isInitialized) {
+                if (this.nodeManager) {
+                    this.nodeManager.updateNodes(data.nodes);
+                }
+                if (this.edgeManager) {
+                    this.edgeManager.updateEdges(data.edges);
+                }
+            } else {
+                // Queue updates until initialized
+                if (import.meta.env.DEV) logger.debug('Queuing updates until initialization');
+            }
+        });
+
+        // Subscribe to websocket binary updates
+        this.websocketService.onBinaryMessage((nodes) => {            
+            if (this.nodeManager && this.isInitialized) {
+                /**
+                 * CRITICAL NODE ID BINDING: Binary WebSocket Protocol
+                 * 
+                 * This is a critical section that handles the node ID binding between the server's
+                 * binary protocol and the client-side metadata visualization system:
+                 * 
+                 * 1. The server sends binary data containing node numeric IDs (u16 values)
+                 * 2. These binary IDs must be preserved as strings in our client system
+                 * 3. The metadata visualization system relies on these same IDs to bind positions
+                 *    with the correct metadata
+                 * 
+                 * The WebSocketService has already converted the numeric IDs to strings, but we must
+                 * ensure these string IDs are used consistently throughout the application.
+                 */
+                this.hasReceivedBinaryUpdate = true;
+                
+                let updates = nodes.map(node => ({
+                    id: node.id.toString(), // Ensure ID is a string to match metadata binding
+                    data: {
+                        position: node.position,
+                        velocity: node.velocity
+                    }
+                }));
+                
+                // Filter out nodes that we've just randomized if randomization is in progress
+                // This prevents the server from sending back old positions during randomization
+                if (this.isRandomizationInProgress) {
+                    const now = performance.now();
+                    // Only apply this filter for a few seconds after randomization starts
+                    if (now - this.randomizationStartTime < 5000) {
+                        updates = updates.filter(update => !this.randomizedNodeIds.has(update.id));
+                    logger.debug(`Filtering updates during randomization, elapsed: ${Math.round(now - this.randomizationStartTime)}ms, filtering ${nodes.length - updates.length} nodes`);
+                        
+                        // If we're filtering out updates, it means the server has acknowledged our data
+                        if (updates.length < nodes.length) {
+                            this.randomizationAcknowledged = true;
+                            logger.info('Randomization acknowledged by server - filtered out ' + 
+                                        (nodes.length - updates.length) + ' outdated positions');
+                        }
+                    } else {
+                        // Time's up - end randomization mode
+                    logger.info('Randomization time limit reached (5000ms). Resetting isRandomizationInProgress flag and clearing randomizedNodeIds.');
+                        this.isRandomizationInProgress = false;
+                        this.randomizedNodeIds.clear();
+                        logger.info('Randomization sync period ended');
+                    }
+                } else if (this.randomizedNodeIds.size > 0) {
+                // Clean up if flag is reset but node IDs are still present
+                logger.info('Cleaning up stale randomizedNodeIds set with size: ' + this.randomizedNodeIds.size);
+                this.randomizedNodeIds.clear();
+            }
+                
+                // Check if we haven't created metadata labels yet, and have received binary data
+                // This ensures we have proper positions before creating labels
+                if (this.hasReceivedBinaryUpdate && !this.metadataVisualizationInitialized && this.metadataVisualizer) {
+                    logger.info('Received binary position updates. Initializing metadata visualization.');
+                    this.initializeMetadataVisualization();
+                }
+                
+                this.nodeManager.updateNodePositions(updates);
+            }
+        });
+
+        // Handle loading status from WebSocket
+        this.websocketService.onLoadingStatusChange((isLoading, message) => {
+            if (isLoading) {
+                this.showLoadingIndicator(message);
+            } else {
+                this.hideLoadingIndicator();
+            }
+        });
+    }
+
+    public initializeScene(scene: Scene, camera: PerspectiveCamera): void {
+        logger.info('Initializing visualization scene');
+
+        logger.info('INITIALIZATION ORDER: Step 1 - Configuring camera layers');
+        // Ensure camera can see nodes
+        camera.layers.enable(0);
+        logger.debug('Camera layers configured', createDataMetadata({
+            layerMask: camera.layers.mask.toString(2),
+            layer0Enabled: Boolean(camera.layers.mask & (1 << 0)),
+            layer1Enabled: Boolean(camera.layers.mask & (1 << 1))
+        }));
+        
+        // Enable WebSocket debugging
+        this.currentSettings.system.debug.enabled = true;
+        this.currentSettings.system.debug.enableWebsocketDebug = true;
+        
+        logger.info('INITIALIZATION ORDER: Step 2 - Connecting WebSocket');
+        // Connect to websocket first
+        this.websocketService.connect().then(() => {
+            logger.info('WebSocket connected, enabling binary updates');
+            this.metadataVisualizationInitialized = false; // Reset flag when reconnecting
+            graphDataManager.enableBinaryUpdates();
+            
+            // Send initial request for data
+            this.websocketService.sendMessage({ 
+                type: 'requestInitialData',
+                timestamp: Date.now()
+            });
+
+            // Show loading indicator until data arrives
+            this.showLoadingIndicator("Waiting for initial graph data...");
+            
+            // Initially disable randomization until data loading is finished
+            this.websocketService.sendMessage({
+                type: 'enableRandomization',
+                enabled: false
+            });
+        }).catch(error => {
+            logger.error('Failed to connect WebSocket:', createErrorMetadata(error));
+        });
+
+        logger.info('INITIALIZATION ORDER: Step 3 - Creating managers');        
+        const materialFactory = MaterialFactory.getInstance();
+
+        logger.info('INITIALIZATION ORDER: Step 3.1 - Creating NodeManagerFacade');
+        this.nodeManager = NodeManagerFacade.getInstance(
+            scene,
+            camera,
+            materialFactory.getNodeMaterial(this.currentSettings)
+        );
+        
+        logger.info('INITIALIZATION ORDER: Step 3.2 - Creating EdgeManager');
+        this.edgeManager = new EdgeManager(scene, this.currentSettings, this.nodeManager.getNodeInstanceManager());
+        
+        logger.info('INITIALIZATION ORDER: Step 3.3 - Creating MetadataVisualizer');
+        this.metadataVisualizer = new MetadataVisualizer(camera, scene, this.currentSettings);
+        this.isInitialized = true;
+        
+        if (import.meta.env.DEV) logger.debug('Scene managers initialized');
+
+        // Initialize with current graph data (if any)
+        const currentData = graphDataManager.getGraphData();
+        if (currentData.nodes.length > 0 && this.nodeManager) {
+            this.nodeManager.updateNodes(currentData.nodes);
+        }
+
+        logger.info('INITIALIZATION ORDER: Step 4 - Starting animation loop');
+        // Start animation loop
+        this.animate();
+
+        // We'll initialize metadata visualization once we receive binary position updates
+        logger.info('Scene initialization complete');
+    }
+
+    public static getInstance(): VisualizationController {
+        if (!VisualizationController.instance) {
+            VisualizationController.instance = new VisualizationController();
+        }
+        return VisualizationController.instance;
+    }
+
+    /**
+     * Refresh all visualization settings with new settings object
+     * @param newSettings Complete settings object from the server
+     */
+    public refreshSettings(newSettings: Settings): void {
+        logger.info('Refreshing visualization settings from server');
+        
+        if (!newSettings || !newSettings.visualization) {
+            logger.warn('Invalid settings object provided to refreshSettings');
+            return;
+        }
+        
+        // Update the entire settings object
+        this.currentSettings = newSettings;
+        
+        // Apply all settings to each component
+        if (this.isInitialized) {
+            logger.info('Applying refreshed settings to visualization components');
+            this.applyVisualizationUpdates();
+            this.updatePhysicsSimulation();
+            this.updateRenderingQuality();
+        } else {
+            logger.debug('Visualization not initialized yet, settings will be applied when initialized');
+        }
+    }
+
+    public updateSetting(path: string, value: any): void {
+        // Hide loading indicator when any settings are changed
+        this.hideLoadingIndicator();
+
+        const parts = path.split('.');
+        const category = parts[0] as VisualizationCategory;
+        
+        if (!['visualization', 'physics', 'rendering'].includes(category)) {
+            return;
+        }
+
+        if (!this.isInitialized) {
+            logger.debug(`Queuing setting update for ${path}`);
+            this.pendingUpdates.set(path, { category, value });
+            return;
+        }
+
+        let current = this.currentSettings as any;
+        for (let i = 0; i < parts.length - 1; i++) {
+            const part = parts[i];
+            if (!(part in current)) {
+                current[part] = {};
+            }
+            current = current[part];
+        }
+
+        current[parts[parts.length - 1]] = value;
+        this.applySettingUpdate(category);
+    }
+
+    /**
+     * Show a loading indicator while waiting for data
+     * @param message Optional message to display
+     */
+    private showLoadingIndicator(message?: string): void {
+        // Hide any existing indicator first
+        this.hideLoadingIndicator();
+        
+        // Create loading indicator if it doesn't exist
+        this.loadingIndicator = document.createElement('div');
+        this.loadingIndicator.id = 'graph-loading-indicator';
+        this.loadingIndicator.style.position = 'fixed';
+        this.loadingIndicator.style.top = '50%';
+        this.loadingIndicator.style.left = '50%';
+        this.loadingIndicator.style.transform = 'translate(-50%, -50%)';
+        this.loadingIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
+        this.loadingIndicator.style.color = 'white';
+        this.loadingIndicator.style.padding = '20px';
+        this.loadingIndicator.style.borderRadius = '10px';
+        this.loadingIndicator.style.zIndex = '1000';
+        this.loadingIndicator.style.textAlign = 'center';
+        this.loadingIndicator.style.fontFamily = 'Arial, sans-serif';
+        this.loadingIndicator.style.boxShadow = '0 0 20px rgba(0, 0, 255, 0.5)';
+        this.loadingIndicator.style.border = '1px solid #3a3a3a';
+        
+        // Add loading spinner
+        const spinner = document.createElement('div');
+        spinner.style.display = 'inline-block';
+        spinner.style.width = '30px';
+        spinner.style.height = '30px';
+        spinner.style.marginBottom = '10px';
+        spinner.style.border = '4px solid rgba(255, 255, 255, 0.3)';
+        spinner.style.borderRadius = '50%';
+        spinner.style.borderTop = '4px solid #ffffff';
+        spinner.style.animation = 'spin 1s linear infinite';
+        
+        // Add animation
+        const style = document.createElement('style');
+        style.textContent = `
+            @keyframes spin {
+                0% { transform: rotate(0deg); }
+                100% { transform: rotate(360deg); }
+            }
+        `;
+        document.head.appendChild(style);
+        
+        this.loadingIndicator.appendChild(spinner);
+        
+        // Create a line break
+        this.loadingIndicator.appendChild(document.createElement('br'));
+        
+        // Add message text
+        const messageText = document.createElement('div');
+        messageText.textContent = message || 'Loading graph data...';
+        this.loadingIndicator.appendChild(messageText);
+        
+        // Add to DOM
+        document.body.appendChild(this.loadingIndicator);
+    }
+    
+    /**
+     * Hide the loading indicator
+     */
+    private hideLoadingIndicator(): void {
+        if (this.loadingIndicator && document.body.contains(this.loadingIndicator)) {
+            document.body.removeChild(this.loadingIndicator);
+        }
+        this.loadingIndicator = null;
+    }
+
+    public updateSettings(category: VisualizationCategory, settings: Partial<Settings>): void {
+        if (!this.isInitialized) {
+            logger.debug(`Queuing bulk settings update for ${category}`);
+            this.pendingUpdates.set(category, { category, value: settings });
+            return;
+        }
+
+        switch (category) {
+            case 'visualization':
+                if (settings.visualization) {
+                    this.currentSettings.visualization = {
+                        ...this.currentSettings.visualization,
+                        ...settings.visualization
+                    };
+                    this.applyVisualizationUpdates();
+                }
+                break;
+            case 'physics':
+                if (settings.visualization?.physics) {
+                    this.currentSettings.visualization.physics = {
+                        ...this.currentSettings.visualization.physics,
+                        ...settings.visualization.physics
+                    };
+                    this.updatePhysicsSimulation();
+                }
+                break;
+            case 'rendering':
+                if (settings.visualization?.rendering) {
+                    this.currentSettings.visualization.rendering = {
+                        ...this.currentSettings.visualization.rendering,
+                        ...settings.visualization.rendering
+                    };
+                    this.updateRenderingQuality();
+                }
+                break;
+        }
+    }
+
+    public getSettings(category: VisualizationCategory): Partial<Settings> {
+        const baseVisualization = {
+            nodes: { ...this.currentSettings.visualization.nodes },
+            edges: { ...this.currentSettings.visualization.edges },
+            physics: { ...this.currentSettings.visualization.physics },
+            rendering: { ...this.currentSettings.visualization.rendering },
+            animations: { ...this.currentSettings.visualization.animations },
+            labels: { ...this.currentSettings.visualization.labels },
+            bloom: { ...this.currentSettings.visualization.bloom },
+            hologram: { ...this.currentSettings.visualization.hologram }
+        };
+
+        switch (category) {
+            case 'visualization':
+                return {
+                    visualization: { ...this.currentSettings.visualization }
+                };
+            case 'physics':
+                return {
+                    visualization: {
+                        ...baseVisualization,
+                        physics: { ...this.currentSettings.visualization.physics }
+                    }
+                };
+            case 'rendering':
+                return {
+                    visualization: {
+                        ...baseVisualization,
+                        rendering: { ...this.currentSettings.visualization.rendering }
+                    }
+                };
+            default:
+                return {
+                    visualization: baseVisualization
+                };
+        }
+    }
+
+    public handleHandInput(hand: XRHandWithHaptics): void {
+        if (!this.isInitialized || !hand) return;
+
+        const pinchStrength = hand.pinchStrength || 0;
+        const gripStrength = hand.gripStrength || 0;
+
+        if (pinchStrength > (this.currentSettings.xr.pinchThreshold || 0.5)) {
+            logger.debug('Pinch gesture detected', { strength: pinchStrength });
+        }
+
+        if (gripStrength > (this.currentSettings.xr.dragThreshold || 0.5)) {
+            logger.debug('Grip gesture detected', { strength: gripStrength });
+        }
+
+        if (hand.hand?.joints) {
+            logger.debug('Processing hand joints');
+        }
+    }
+
+    private applySettingUpdate(category: VisualizationCategory): void {
+        if (!this.isInitialized) {
+            logger.debug(`Queuing category update for ${category}`);
+            return;
+        }
+
+        logger.debug(`Updating ${category} settings`);
+        
+        switch (category) {
+            case 'visualization':
+                this.applyVisualizationUpdates();
+                break;
+            case 'physics':
+                this.updatePhysicsSimulation();
+                break;
+            case 'rendering':
+                this.updateRenderingQuality();
+                break;
+        }
+    }
+
+    private applyVisualizationUpdates(): void {
+        if (!this.isInitialized) return;
+        this.updateNodeAppearance();
+        this.updateEdgeAppearance();
+        // Update metadata visualization
+        if (this.metadataVisualizer && this.metadataVisualizationInitialized) {
+            // Only update positions of existing metadata, don't recreate everything
+            this.updateMetadataPositions();
+        }
+        // Intentionally not initializing metadata visualization here anymore
+        // We'll wait for binary data with positions first
+        
+    }
+
+    private updateNodeAppearance(): void {
+        if (!this.isInitialized) return;
+        logger.debug('Updating node appearance');
+        if (this.nodeManager) {
+            this.nodeManager.handleSettingsUpdate(this.currentSettings);
+        }
+    }
+
+    private updateEdgeAppearance(): void {
+        if (!this.isInitialized) {
+            logger.debug('Queuing edge appearance update');
+            return;
+        }
+
+        if (this.edgeManager) {
+            this.edgeManager.handleSettingsUpdate(this.currentSettings);
+            logger.debug('Edge appearance updated');
+        } else {
+            logger.warn('EdgeManager not initialized');
+        }
+    }
+
+    private updatePhysicsSimulation(): void {
+        if (!this.isInitialized) return;
+        logger.debug('Updating physics simulation');
+    }
+
+    private updateRenderingQuality(): void {
+        if (!this.isInitialized) return;
+        logger.debug('Updating rendering quality');
+    }
+
+    public updateNodePositions(nodes: any[]): void {
+        if (this.nodeManager) {
+            this.nodeManager.updateNodePositions(nodes);
+        }
+    }
+
+    /**
+     * Randomly distributes all nodes in 3D space and triggers WebSocket updates
+     * @param radius The radius of the sphere within which to distribute nodes
+     */
+    public async randomizeNodePositions(radius: number = 7): Promise<void> {
+        // First, ensure WebSocket is connected
+        const connectionState = this.websocketService.getConnectionStatus();
+        logger.info(`Randomizing nodes. Current WebSocket state: ${connectionState}`);
+        
+        if (connectionState !== 'connected') {
+            logger.warn(`WebSocket not connected (state: ${connectionState}), attempting to reconnect...`);
+            
+            try {
+                // Try to reconnect
+                await this.websocketService.connect();
+                
+                // Wait a bit to ensure connection is stable
+                await new Promise(resolve => setTimeout(resolve, 1000));
+                
+                // Check again
+                const newState = this.websocketService.getConnectionStatus();
+                if (newState !== 'connected') {
+                    logger.error(`Failed to establish WebSocket connection (state: ${newState})`);
+                    // Proceed with local randomization only
+                    logger.warn('Will perform randomization locally only without server sync');
+                } else {
+                    logger.info('Successfully reconnected WebSocket for randomization');
+                }
+            } catch (error) {
+                logger.error('Error reconnecting WebSocket:', createErrorMetadata(error));
+                // Proceed with local randomization only
+                logger.warn('Will perform randomization locally only without server sync');
+            }
+        }
+
+        // Enforce maximum radius to prevent explosion
+        radius = Math.min(radius, 5); // Reduced maximum radius to prevent explosion
+
+        if (!this.nodeManager || !this.isInitialized) {
+            logger.warn('Cannot randomize node positions - Node manager not initialized');
+            return;
+        }
+
+        // Don't start another randomization if one is in progress
+        if (this.isRandomizationInProgress) {
+            logger.warn('Randomization already in progress, please wait...');
+            return;
+        }
+        
+        // Start tracking randomization
+        this.isRandomizationInProgress = true;
+        this.randomizationStartTime = performance.now();
+        
+        // Get node data from the graph manager
+        const graphData = GraphDataManager.getInstance().getGraphData();
+        if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
+            logger.warn('No nodes found to randomize');
+            return;
+        }
+
+        logger.info('Randomizing node positions with radius:', createDataMetadata({ 
+            radius,
+            nodeCount: graphData.nodes.length
+        }));
+        this.randomizedNodeIds.clear();
+        
+        // Create node updates with random positions - using original node IDs
+        // WebSocketService will handle converting metadata names to numeric IDs
+        const updates = graphData.nodes.map((node: Node) => {
+            const nodeId = node.id; // Keep original ID - WebSocketService handles mapping to numeric
+
+            // Generate random position within a sphere
+            const theta = Math.random() * Math.PI * 2; // Random angle around Y axis
+            const phi = Math.acos((Math.random() * 2) - 1); // Random angle from Y axis
+            // Use square root for more central clustering
+            const r = radius * Math.sqrt(Math.random()); // Random distance from center
+            
+            // Convert spherical to Cartesian coordinates
+            const x = r * Math.sin(phi) * Math.cos(theta);
+            const y = r * Math.sin(phi) * Math.sin(theta);
+            const z = r * Math.cos(phi);
+
+            // Use near-zero initial velocities to prevent explosion
+            // Set zero velocity for all axes - completely remove any initial bias
+            const vx = 0.0;
+            const vy = 0.0;
+            const vz = 0.0; // Removed bias that could cause z-axis drift
+            
+
+            // Track which nodes we've randomized
+            this.randomizedNodeIds.add(nodeId);
+            
+            return {
+                id: nodeId,
+                data: {
+                    position: new Vector3(x, y, z),
+                    velocity: new Vector3(vx, vy, vz)
+                }
+            };
+        });
+        
+        // Update local node positions
+        this.nodeManager.updateNodePositions(updates);
+        
+        // Send updates to server via WebSocket
+        if (this.websocketService) {
+            // First, ensure we signal server to stop any current physics simulation
+            this.websocketService.sendMessage({ 
+                type: 'pauseSimulation',
+                enabled: true
+            });
+            
+            // Wait for a short delay to ensure the server has processed the pause
+            await new Promise(resolve => setTimeout(resolve, 300));
+            
+            this.randomizationAcknowledged = false;
+            
+            logger.info('Sending node positions to server in batch...');
+            
+            // Send positions in batches to avoid overwhelming the server
+            const batchSize = 5;
+            const connectionState = this.websocketService.getConnectionStatus();
+            
+            // Only send updates if websocket is connected
+            if (connectionState === 'connected') {
+                logger.info(`Sending ${updates.length} node updates to server in ${Math.ceil(updates.length/batchSize)} batches`);
+                
+                // Send updates in batches with a small delay between batches
+                for (let i = 0; i < updates.length; i += batchSize) {
+                    const batch = updates.slice(i, i + batchSize);
+                    const wsUpdates = batch.map(update => ({ 
+                        id: update.id,
+                        position: update.data.position,
+                        velocity: update.data.velocity
+                    }));
+                    
+                    // Log the first batch to help with debugging
+                    if (i === 0) {
+                        logger.info('First batch node updates:', createDataMetadata({
+                            batchSize: wsUpdates.length,
+                            sampleNodeId: wsUpdates[0].id,
+                            sampleNodeIdType: typeof wsUpdates[0].id,
+                            samplePosition: {
+                                x: wsUpdates[0].position.x,
+                                y: wsUpdates[0].position.y,
+                                z: wsUpdates[0].position.z
+                            }
+                        }));
+                    }
+                    
+                    this.websocketService.sendNodeUpdates(wsUpdates);
+                    
+                    // Small delay between batches to avoid overwhelming the server
+                    if (i + batchSize < updates.length) {
+                        await new Promise(resolve => setTimeout(resolve, 50));
+                    }
+                }
+                
+                logger.info('Finished sending all node update batches');
+            } else {
+                logger.warn(`Cannot send updates - WebSocket not connected (state: ${connectionState})`);
+            }
+            
+            // Old approach that sent one at a time - keeping as fallback
+            /*
+            updates.forEach((update) => {
+                // Send updates to server one at a time with minimal velocity
+                this.websocketService.sendNodeUpdates([{ 
+                    id: update.id,
+                    position: update.data.position,
+                    velocity: update.data.velocity
+                }]);
+            });
+            */
+            
+            // Signal server to resume physics simulation with new positions
+            setTimeout(async () => {
+                logger.info('Resuming physics simulation after position updates');
+                
+                // Only send message if connected
+                if (this.websocketService.getConnectionStatus() === 'connected') {
+                this.websocketService.sendMessage({ 
+                    type: 'pauseSimulation',
+                    enabled: false
+                });
+
+                // Also explicitly request force calculation to begin
+                this.websocketService.sendMessage({
+                    type: 'applyForces',
+                    timestamp: Date.now(),
+                    forceCalculation: true
+                });
+                }
+                
+                // Wait up to 5 seconds for acknowledgment
+                const waitForAcknowledgment = async () => {
+                    for (let i = 0; i < 10; i++) { // 10 * 500ms = 5 seconds
+                        if (this.randomizationAcknowledged) return true;
+                        await new Promise(resolve => setTimeout(resolve, 500));
+                    }
+                    return false;
+                };
+                
+                const acknowledged = await waitForAcknowledgment();
+                logger.info(`Randomization ${acknowledged ? 'confirmed' : 'timed out waiting for confirmation'}`);
+                
+                // Mark randomization as complete even if no acknowledgment received
+                this.isRandomizationInProgress = false;
+                
+            }, 500); // Short delay to ensure all positions are processed
+        } else {
+            // No WebSocket service or not connected
+            this.isRandomizationInProgress = false;
+            this.randomizedNodeIds.clear();
+            logger.warn('WebSocket service not available, node positions only updated locally');
+        }
+    }
+
+    private animate = (): void => {
+        if (!this.isInitialized) return;
+
+        requestAnimationFrame(this.animate);
+        const currentTime = performance.now();
+        const deltaTime = (currentTime - this.lastUpdateTime) / 1000;
+        this.update(deltaTime);
+    }
+
+    public update(deltaTime: number): void {
+        if (this.isInitialized) {
+            const currentTime = performance.now();
+            if (deltaTime === 0) {
+                deltaTime = (currentTime - this.lastUpdateTime) / 1000;
+            }
+            this.lastUpdateTime = currentTime;
+            if (this.nodeManager) {
+                this.nodeManager.update(deltaTime);
+            }
+
+            // Update edge animations
+            if (this.edgeManager) {
+                this.edgeManager.update();  // No parameter needed as the method was updated
+            }
+            
+            // Update ONLY metadata positions - do not recreate labels every frame
+            if (this.metadataVisualizer && this.nodeManager && this.metadataVisualizationInitialized) {
+                this.updateMetadataPositions(); 
+            }
+        }
+    }
+
+    public dispose(): void {
+        // Dispose of managers and cleanup websocket
+        if (this.metadataVisualizer) {
+            this.metadataVisualizer?.dispose();
+            this.metadataVisualizer = null;
+        }
+        this.nodeManager?.dispose();
+        this.hideLoadingIndicator();
+        this.edgeManager?.dispose();
+        this.websocketService.dispose();
+        this.isInitialized = false;
+        VisualizationController.instance = null;
+    }
+
+    /**
+     * Update only the positions of metadata labels without recreating them
+     * This is called every frame for efficiency
+     */
+    private updateMetadataPositions(): void {
+        if (!this.isInitialized || !this.metadataVisualizer || !this.nodeManager) return;
+        
+        const currentData = graphDataManager.getGraphData();
+        // Only occasionally log updates
+        if (Math.random() < 0.001) {
+            logger.debug('Updating metadata positions for nodes:', createDataMetadata({
+                nodeCount: currentData.nodes.length
+            }));
+        }
+        
+        // Update positions for existing metadata labels
+        currentData.nodes.forEach(node => {
+            const position = this.nodeManager?.getNodeInstanceManager().getNodePosition(node.id);
+            if (position) {
+                this.metadataVisualizer?.updateMetadataPosition(node.id, position);
+            }
+        });
+    }
+
+    /**
+     * Initialize the metadata visualization once - called only after binary updates
+     * are available so positions are correct
+     */
+    private initializeMetadataVisualization(): void {
+        // Removed unused startTime variable
+        
+        if (!this.isInitialized || !this.metadataVisualizer || !this.nodeManager) return;
+        if (this.metadataVisualizationInitialized) {
+            logger.debug('Metadata visualization already initialized, skipping initialization');
+            return;
+        }
+        
+        // Set flag first to prevent repeated initialization
+        this.metadataVisualizationInitialized = true;
+        this.lastMetadataUpdateTime = performance.now();
+        
+        logger.info('CRITICAL EVENT: Initializing metadata visualization for the first time', createDataMetadata({
+            hasNodeManager: !!this.nodeManager,
+            hasMetadataVisualizer: !!this.metadataVisualizer
+        }));
+        
+        // Perform the full visualization update (create labels)
+        this.updateMetadataVisualization(true);
+    }
+
+    /**
+     * Update metadata visualization, optionally clearing existing labels
+     * @param clearExisting Whether to clear existing labels
+     */
+    private updateMetadataVisualization(clearExisting: boolean = false): void {
+        const startTime = performance.now();
+        if (!this.isInitialized || !this.metadataVisualizer || !this.nodeManager) return;
+        
+        // Debounce frequently repeated calls
+        const now = performance.now();
+        if (now - this.lastMetadataUpdateTime < 1000) return; // Prevent updates more than once per second
+        this.lastMetadataUpdateTime = now;
+        
+        // Only clear existing labels if specified
+        if (clearExisting) {
+            logger.debug('Clearing existing metadata labels before creating new ones');
+            if (this.metadataVisualizer && 'clearAllLabels' in this.metadataVisualizer) {
+                this.metadataVisualizer.clearAllLabels();
+            } else {
+                logger.warn('Cannot clear labels: clearAllLabels method not found on MetadataVisualizer', createDataMetadata({
+                    availableMethods: this.metadataVisualizer ? Object.getOwnPropertyNames(Object.getPrototypeOf(this.metadataVisualizer)) : []
+                }));
+            }
+        }
+        
+        
+        // Store information on the nodes we'll process for logging
+        const currentData = graphDataManager.getGraphData();
+        logger.info('Updating metadata visualization for nodes:', createDataMetadata({
+            nodeCount: currentData.nodes.length
+        }));
+        
+        // Keep track of processed node ids to avoid duplicates
+        const processedNodeIds = new Set<string>();
+        const positionMap = new Map();
+        
+        // Create metadata for all nodes
+        currentData.nodes.forEach((node, index) => {
+            /**
+             * CRITICAL NODE ID BINDING: Metadata Visualization
+             * 
+             * This is where metadata gets bound to node IDs. The critical points:
+             * 
+             * 1. The node.id MUST be a numeric string that matches the IDs from the binary protocol
+             * 2. This ID originated from the server as a u16 value in the binary messages
+             * 3. Both MetadataVisualizer and NodeInstanceManager must use the same ID values
+             *    to ensure proper position updates and metadata binding
+             * 4. Duplicate IDs must be skipped to prevent overwriting metadata
+             */
+            if (processedNodeIds.has(node.id)) {
+                logger.debug(`Skipping duplicate node ID ${node.id}`);
+                return;
+            }
+            
+            // Validate ID format - we expect numeric string IDs from the binary protocol
+            // Check if ID is a valid numeric string - this is critical for proper binding
+            // with the binary message protocol which uses numeric IDs
+            if (!/^\d+$/.test(node.id)) {
+                logger.warn(`Node ${node.id} has non-numeric ID format which may cause metadata binding issues. 
+                    Binary protocol requires numeric string IDs for proper binding.`);
+            }
+            
+            // Mark as processed
+            processedNodeIds.add(node.id);
+
+            // CRITICAL: Get the proper label from the node
+            // This is crucial for correct label display - using the right property chain
+            let nodeLabel: string | undefined;
+            
+            // Check for valid position
+            if (!node.data?.position || 
+                (node.data.position.x === 0 && node.data.position.y === 0 && node.data.position.z === 0)) {
+                logger.warn(`Node ${node.id} has zero/null position during label initialization`, createDataMetadata({
+                    position: node.data?.position ? JSON.stringify(node.data.position) : 'undefined',
+                    hasData: !!node.data,
+                    metadataId: node.metadataId || 'undefined',
+                    label: node.label || 'undefined'
+                }));
+            } else if (node.data?.position) {
+                // Store valid positions for logging
+                positionMap.set(node.id, `x:${node.data.position.x.toFixed(2)}, y:${node.data.position.y.toFixed(2)}, z:${node.data.position.z.toFixed(2)}`);
+            }
+            
+            // Get the label from the node using the correct property path
+            // First check if node has a direct label property
+            if (node.label && typeof node.label === 'string') {
+                nodeLabel = node.label; // Use explicit node.label if available
+            } 
+            // Then check if node has a metadataId (filename)
+            else if (node.metadataId && typeof node.metadataId === 'string') {
+                nodeLabel = node.metadataId; // Fall back to metadataId (filename)
+            }
+            // Finally check if the label is in node.data.metadata
+            else if (node.data?.metadata?.name && typeof node.data.metadata.name === 'string') {
+                nodeLabel = node.data.metadata.name;
+            }
+            
+            // Log actual label being used
+            logger.debug(`Using label for node ${node.id}: "${nodeLabel || 'undefined'}"`);
+            
+            // Create metadata even if node.data.metadata is missing
+            // Use node ID as a fallback for the name
+            const nodeMetadata = node.data?.metadata || {};
+            
+            // Log the actual data we're working with for debugging
+            if (index < 5) {
+                logger.info(`Processing node #${index}: ${node.id}`, createDataMetadata({
+                    name: nodeMetadata.name || node.id,
+                    label: nodeLabel || '(undefined)',
+                    fileSize: nodeMetadata.fileSize,
+                    position: node.data.position
+                })); 
+            }
+                
+            const metadata: NodeMetadata = {
+                id: node.id,
+                // Use explicit || chaining to handle all possible undefined cases
+                // Ensure each node gets its own unique label
+                name: nodeLabel || nodeMetadata.name || node.id || `Node ${index}`,
+                commitAge: Math.floor((Date.now() - (nodeMetadata.lastModified || Date.now())) / (1000 * 60 * 60 * 24)),
+                hyperlinkCount: nodeMetadata.hyperlinkCount || 0,
+                fileSize: nodeMetadata.fileSize || 1024,
+                nodeSize: Math.min(50, Math.max(1, Math.log10((nodeMetadata.fileSize || 1024) / 1024) * 10)), // Scale based on file size (1-50)
+                importance: 1.0, // Default importance
+                position: {
+                    x: node.data.position.x || 0,
+                    y: node.data.position.y || 0,
+                    z: node.data.position.z || 0
+                }
+            };
+                
+            /**
+             * CRITICAL NODE ID BINDING: Creating Metadata Labels
+             * 
+             * When creating metadata labels, we MUST pass the node.id (numeric string)
+             * to the MetadataVisualizer rather than the display name or other identifier.
+             * 
+             * This ensures the correct binding between:
+             * 1. Binary position updates from WebSocket (which use numeric IDs)
+             * 2. Metadata visualizations (which need to track those same IDs)
+             * 3. Node instance updates (which also use those IDs)
+             * 
+             * IMPORTANT: Passing the wrong ID here was the root cause of the metadata binding issue
+             */
+            this.metadataVisualizer?.createMetadataLabel(metadata, node.id);
+                
+            // Update position immediately to avoid the "dropping in" effect
+            const position = this.nodeManager?.getNodeInstanceManager().getNodePosition(node.id);
+            if (position) {
+                this.metadataVisualizer?.updateMetadataPosition(node.id, position);
+            }
+        });
+
+        // Log position information to help diagnose issues
+        const samplePositions = Array.from(positionMap.entries()).slice(0, 5)
+            .map(([id, pos]) => `${id}: ${pos}`).join(', ');
+
+        const elapsedTime = performance.now() - startTime;
+
+        logger.info('Metadata visualization complete', createDataMetadata({
+            nodesProcessed: processedNodeIds.size,
+            processingTimeMs: elapsedTime.toFixed(2),
+            nodesWithPosition: positionMap.size,
+            nodesWithoutPosition: processedNodeIds.size - positionMap.size,
+            samplePositions: samplePositions,
+            sampleLabels: currentData.nodes.slice(0, 3).map(n => n.data?.metadata?.name || n.id).join(", "),
+            elapsedTimeMs: elapsedTime.toFixed(2)
+        }));
+    }
+    
+    /**
+     * Get the node manager facade
+     * @returns The NodeManagerFacade instance or null if not initialized
+     */
+    public getNodeManagerFacade(): NodeManagerFacade | null {
+        return this.nodeManager;
+    }
+}
diff --git a/client/rendering/factories/GeometryFactory.ts b/client/rendering/factories/GeometryFactory.ts
new file mode 100644
index 00000000..c56f2106
--- /dev/null
+++ b/client/rendering/factories/GeometryFactory.ts
@@ -0,0 +1,120 @@
+import { 
+    BufferGeometry, 
+    CylinderGeometry, 
+    IcosahedronGeometry,
+    TorusGeometry
+} from 'three';
+
+export class GeometryFactory {
+    private static instance: GeometryFactory;
+    private geometryCache = new Map<string, BufferGeometry>();
+
+    private constructor() {}
+
+    static getInstance(): GeometryFactory {
+        if (!GeometryFactory.instance) {
+            GeometryFactory.instance = new GeometryFactory();
+        }
+        return GeometryFactory.instance;
+    }
+
+    /**
+     * Creates a node geometry with radius 1, which can be scaled by the NodeInstanceManager
+     * to match the desired size from settings.
+     */
+    getNodeGeometry(quality: 'low' | 'medium' | 'high', context: 'ar' | 'desktop' = 'desktop'): BufferGeometry {
+        const cacheKey = `node-${quality}-${context}`;
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        let geometry: BufferGeometry;
+        let detail: number;
+        
+        switch (quality) {
+            case 'low':
+               detail = context === 'ar' ? 1 : 2;
+                 break;
+            case 'medium':
+                detail = context === 'ar' ? 2 : 3;
+                break;
+            case 'high':
+                detail = context === 'ar' ? 2 : 4;
+                break;
+            default:
+                detail = context === 'ar' ? 1 : 2;
+        }
+        
+        // Create unit-sized geometry (radius = 1) that will be scaled by NodeInstanceManager
+        geometry = new IcosahedronGeometry(1, detail);
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    /**
+     * Creates a hologram geometry with radius 1, which can be scaled by the HologramManager
+     * to match the desired size from settings.
+     */
+    getHologramGeometry(type: string, quality: string): BufferGeometry {
+        const cacheKey = `hologram-${type}-${quality}`;
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        const segments = {
+            low: { ring: 16, sphere: 12 },
+            medium: { ring: 24, sphere: 16 },
+            high: { ring: 32, sphere: 16 }
+        }[quality] || { ring: 32, sphere: 16 };
+
+        let geometry: BufferGeometry;
+        switch (type) {
+            case 'ring':
+                // Create unit-sized torus (radius = 1) with proportional tube radius
+                geometry = new TorusGeometry(1, 0.05, segments.ring, segments.ring * 2);
+                break;
+            case 'triangleSphere':
+                // Create unit-sized icosahedron (radius = 1)
+                geometry = new IcosahedronGeometry(1, 1);
+                break;
+            default:
+                // Create unit-sized icosahedron (radius = 1)
+                geometry = new IcosahedronGeometry(1, 1);
+        }
+
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    /**
+     * Creates an edge geometry with radius 1 and height 1, which can be scaled by the EdgeManager
+     * to match the desired width from settings.
+     */
+    getEdgeGeometry(context: 'ar' | 'desktop' = 'desktop', quality?: 'low' | 'medium' | 'high'): BufferGeometry {
+        const cacheKey = `edge-${context}-${quality || 'medium'}`;
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        // Adjust segments based on quality
+        const segments = {
+            low: context === 'ar' ? 4 : 5,
+            medium: context === 'ar' ? 5 : 6,
+            high: context === 'ar' ? 6 : 8
+        }[quality || 'medium'];
+
+        // Create unit-sized cylinder (radius = 1, height = 1) that will be scaled by EdgeManager
+        const geometry = new CylinderGeometry(1, 1, 1, segments);
+        
+        // Rotate 90 degrees to align with Z-axis
+        geometry.rotateX(Math.PI / 2);
+        
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    dispose(): void {
+        this.geometryCache.forEach(geometry => geometry.dispose());
+        this.geometryCache.clear();
+    }
+}
diff --git a/client/rendering/factories/MaterialFactory.ts b/client/rendering/factories/MaterialFactory.ts
new file mode 100644
index 00000000..af76b60b
--- /dev/null
+++ b/client/rendering/factories/MaterialFactory.ts
@@ -0,0 +1,171 @@
+import { HologramShaderMaterial } from '../materials/HologramShaderMaterial';
+import { 
+    Color, 
+    Material, 
+    MeshStandardMaterial, 
+    LineBasicMaterial,
+    DoubleSide
+} from 'three';
+
+export class MaterialFactory {
+    private static instance: MaterialFactory;
+    private materialCache: Map<string, Material>;
+
+    private constructor() {
+        this.materialCache = new Map();
+    }
+
+    public static getInstance(): MaterialFactory {
+        if (!MaterialFactory.instance) {
+            MaterialFactory.instance = new MaterialFactory();
+        }
+        return MaterialFactory.instance;
+    }
+
+    private hexToRgb(hex: string): Color {
+        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
+        if (!result) {
+            return new Color(0xffffff);
+        }
+        return new Color(`#${result[1]}${result[2]}${result[3]}`);
+    }
+
+    public createHologramMaterial(settings: any, context: 'ar' | 'desktop' = 'desktop'): HologramShaderMaterial {
+        const cacheKey = 'hologram';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey) as HologramShaderMaterial;
+        }
+
+        const material = new HologramShaderMaterial(settings);
+        
+        if (settings.visualization?.hologram?.ringColor) {
+            const materialColor = this.hexToRgb(settings.visualization.hologram.ringColor);
+            material.uniforms.color.value = materialColor;
+        }
+        
+        // Optimize for Quest
+        if (context === 'ar') {
+            material.transparent = true;
+            material.depthWrite = true; // Improve depth sorting
+            material.opacity = (settings.visualization?.hologram?.opacity || 0.6) * 0.8; // Reduce opacity for better performance
+        }
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    public getHologramMaterial(settings: any, context: 'ar' | 'desktop' = 'desktop'): HologramShaderMaterial {
+        return this.createHologramMaterial(settings, context);
+    }
+
+    public getSceneSphereMaterial(settings: any): Material {
+        const cacheKey = 'scene-sphere';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+        const material = new MeshStandardMaterial({
+            color: settings.visualization?.hologram?.ringColor || 0xffffff,
+            transparent: true,
+            depthWrite: true,
+            opacity: settings.visualization?.hologram?.opacity || 0.8,
+            metalness: 0.1,
+            roughness: 0.8,
+            side: DoubleSide,
+        });
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    public getRingMaterial(settings: any, context: 'ar' | 'desktop' = 'desktop'): Material {
+        const cacheKey = `ring-${context}`;
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+        const material = this.getHologramMaterial(settings, context);
+        material.transparent = true;
+        material.depthWrite = true;
+        material.opacity = context === 'ar' ? (settings.visualization?.hologram?.opacity || 0.6) * 0.8 : (settings.visualization?.hologram?.opacity || 0.6);
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    public getNodeMaterial(settings: any, context: 'ar' | 'desktop' = 'desktop'): Material {
+        const cacheKey = `node-${context}`;
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const opacity = context === 'ar' ? (settings.visualization?.nodes?.opacity || 0.9) * 0.8 : (settings.visualization?.nodes?.opacity || 0.9);
+        const baseColor = settings.visualization?.nodes?.baseColor || 0x4287f5;
+
+        const material = new MeshStandardMaterial({
+            color: settings.visualization?.nodes?.baseColor || 0x4287f5,
+            transparent: true,
+            opacity,
+            metalness: settings.visualization?.nodes?.metalness || 0.2,
+            roughness: settings.visualization?.nodes?.roughness || 0.7,
+            side: DoubleSide,
+            depthWrite: true, // Improve depth sorting
+            emissive: new Color(baseColor)
+        });
+        
+        // Set emissive intensity after creation
+        (material as any).emissiveIntensity = 1.0;
+        
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    public getMetadataMaterial(): Material {
+        const cacheKey = 'metadata';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshStandardMaterial({
+            color: 0xffffff,
+            transparent: true,
+            depthWrite: true,
+            metalness: 0.1,
+            roughness: 0.8,
+            side: DoubleSide, 
+            opacity: 0.7 // Slightly reduced opacity for better performance
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    public updateMaterial(type: string, settings: any): void {
+        const material = this.materialCache.get(type);
+        if (!material) return;
+
+        switch (type) {
+            case 'node-basic':
+            case 'node-phong': {
+                const nodeMaterial = material as MeshStandardMaterial;
+                const baseColor = settings.visualization?.nodes?.baseColor || '#4287f5';
+                nodeMaterial.color.set(baseColor);
+                nodeMaterial.metalness = settings.visualization?.nodes?.metalness || 0.2;
+                nodeMaterial.roughness = settings.visualization?.nodes?.roughness || 0.7;
+                nodeMaterial.emissive.set(baseColor);
+                nodeMaterial.opacity = type.includes('ar') ? (settings.visualization?.nodes?.opacity || 0.9) * 0.8 : (settings.visualization?.nodes?.opacity || 0.9);
+                nodeMaterial.needsUpdate = true;
+                break;
+            }
+            case 'edge':
+                (material as LineBasicMaterial).color = this.hexToRgb(settings.visualization?.edges?.color || '#6e7c91');
+                break;
+            case 'hologram':
+                if (material instanceof HologramShaderMaterial) {
+                    material.uniforms.color.value = this.hexToRgb(settings.visualization?.hologram?.ringColor || '#ffffff');
+                }
+                break;
+        }
+    }
+
+    public dispose(): void {
+        this.materialCache.forEach(material => material.dispose());
+        this.materialCache.clear();
+    }
+}
diff --git a/client/rendering/materials/EdgeShaderMaterial.ts b/client/rendering/materials/EdgeShaderMaterial.ts
new file mode 100644
index 00000000..741165cb
--- /dev/null
+++ b/client/rendering/materials/EdgeShaderMaterial.ts
@@ -0,0 +1,151 @@
+import { 
+    Vector3, 
+    WebGLRenderer, 
+    MeshBasicMaterial
+} from 'three';
+import { createLogger } from '../../core/logger';
+import { debugState } from '../../core/debugState';
+
+const logger = createLogger('EdgeShaderMaterial');
+
+/**
+ * EdgeShaderMaterial - A material for rendering edges in the graph
+ * This version uses Three.js built-in materials instead of custom shaders
+ * to improve compatibility and avoid WebGL context issues
+ */
+export class EdgeShaderMaterial extends MeshBasicMaterial {
+    private static instances: Set<EdgeShaderMaterial> = new Set();
+    private fallbackMaterial: MeshBasicMaterial | null = null;
+    private baseOpacity: number;
+    private updateFrequency: number;
+    private frameCount: number;
+    
+    // Store time for animation
+    private time: number = 0;
+
+    constructor(settings?: any) {
+        // Extract settings
+        const opacity = settings?.visualization?.edges?.opacity ?? 0.7;
+        const colorValue = settings?.visualization?.edges?.color ?? 0x4080ff;
+        
+        // Initialize MeshBasicMaterial with proper settings
+        super({
+            color: colorValue,
+            transparent: true,
+            opacity: opacity,
+            side: 2, // DoubleSide = 2
+            depthWrite: false
+        });
+        
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Creating EdgeShaderMaterial (Three.js version)', { settings });
+        }
+        
+        // Try to set wireframe if available
+        try {
+            (this as any).wireframe = true;
+        } catch (e) {
+            logger.warn('Could not set wireframe property on MeshBasicMaterial');
+        }
+        
+        // Store original values
+        this.baseOpacity = opacity;
+        
+        this.updateFrequency = 1; // Update every frame
+        this.frameCount = 0;
+
+        // Add this instance to the set of instances
+        EdgeShaderMaterial.instances.add(this);
+
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('EdgeShaderMaterial initialized (Three.js version)', { 
+                color: colorValue,
+                opacity: opacity
+            });
+        }
+    }
+
+    public static setRenderer(_renderer: WebGLRenderer): void {
+        if (debugState.isShaderDebugEnabled()) {
+            logger.shader('Renderer set for EdgeShaderMaterial');
+        }
+    }
+
+    update(deltaTime: number): void {
+        this.frameCount++;
+        if (this.frameCount % this.updateFrequency === 0) {
+            // Update time for animation
+            this.time += deltaTime;
+            
+            // Simple pulsing effect
+            const pulse = Math.sin(this.time * 1.5) * 0.1 + 0.9;
+            this.opacity = this.baseOpacity * pulse;
+        }
+    }
+
+    setSourceTarget(_source: Vector3, _target: Vector3): void {
+        // This method is kept for API compatibility
+        // In the simplified version, we don't need to do anything here
+    }
+
+    clone(): this {
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Cloning EdgeShaderMaterial (Three.js version)');
+        }
+        
+        // Create settings object from current properties
+        const settings = {
+            visualization: {
+                edges: {
+                    opacity: this.opacity,
+                    color: 0x4080ff // Default color as fallback
+                }
+            }
+        };
+        
+        // Try to get the color value
+        try {
+            // Use a simple approach to get the color value
+            if (this.color) {
+                const colorHex = (this.color as any).getHex ? (this.color as any).getHex() : 0x4080ff;
+                settings.visualization.edges.color = colorHex;
+            }
+        } catch (error) {
+            logger.warn('Could not get color value, using default color');
+        }
+        
+        const material = new EdgeShaderMaterial(settings);
+        
+        // Copy current state
+        try {
+            (material as any).wireframe = (this as any).wireframe || false;
+        } catch (e) {
+            // Ignore errors
+        }
+        material.opacity = this.opacity;
+        try {
+            material.color.set(this.color);
+        } catch (error) {
+            logger.warn('Could not copy color from original material');
+        }
+        
+        material.time = this.time;
+        material.frameCount = this.frameCount;
+        
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Material cloned successfully');
+        }
+        return material as this;
+    }
+
+    dispose(): void {
+        // Remove this instance from the set when disposed
+        EdgeShaderMaterial.instances.delete(this);
+        // Dispose of fallback material if it exists
+        if (this.fallbackMaterial) {
+            this.fallbackMaterial.dispose();
+        }
+        // Call parent dispose
+        super.dispose();
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/materials/HologramShaderMaterial.ts b/client/rendering/materials/HologramShaderMaterial.ts
new file mode 100644
index 00000000..fe06f6d2
--- /dev/null
+++ b/client/rendering/materials/HologramShaderMaterial.ts
@@ -0,0 +1,302 @@
+import { 
+    Color, 
+    Vector3, 
+    WebGLRenderer, 
+    MeshBasicMaterial
+} from 'three';
+import { createLogger } from '../../core/logger';
+import { debugState } from '../../core/debugState';
+
+// Define a custom interface for our uniforms to maintain API compatibility
+export interface HologramUniforms {
+    [key: string]: { value: any };
+    time: { value: number };
+    opacity: { value: number };
+    color: { value: Color };
+    pulseIntensity: { value: number };
+    interactionPoint: { value: Vector3 };
+    interactionStrength: { value: number };
+    isEdgeOnly: { value: boolean };
+}
+
+const logger = createLogger('HologramShaderMaterial');
+
+/**
+ * HologramShaderMaterial - A material that simulates a hologram effect
+ * This version uses Three.js built-in materials instead of custom shaders
+ * to improve compatibility and avoid WebGL context issues
+ */
+export class HologramShaderMaterial extends MeshBasicMaterial {
+    // Store uniforms for API compatibility with the original shader material
+    public uniforms: HologramUniforms;
+    private static instances: Set<HologramShaderMaterial> = new Set();
+    private updateFrequency: number;
+    private frameCount: number;
+    private fallbackMaterial: MeshBasicMaterial | null = null;
+    private baseOpacity: number;
+    private baseColor: Color;
+    private pulseIntensity: number;
+    private isEdgeOnlyMode: boolean = false;
+
+    constructor(settings?: any, context: 'ar' | 'desktop' = 'desktop') {
+        // Extract settings
+        const isAR = context === 'ar';
+        const opacity = settings?.visualization?.hologram?.opacity ?? 0.7;
+        const colorValue = settings?.visualization?.hologram?.color ?? 0x00ff00;
+        const pulseIntensity = isAR ? 0.1 : 0.2;
+        
+        // Initialize MeshBasicMaterial with proper settings
+        super({
+            color: colorValue,
+            transparent: true,
+            opacity: opacity,
+            side: isAR ? 0 : 2, // FrontSide = 0, DoubleSide = 2
+            depthWrite: false
+        });
+        
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Creating HologramShaderMaterial (Three.js version)', { context, settings });
+        }
+        
+        // Store original values
+        this.baseOpacity = opacity;
+        this.baseColor = new Color(colorValue);
+        this.pulseIntensity = pulseIntensity;
+        
+        // Create uniforms object for API compatibility
+        this.uniforms = {
+            time: { value: 0 },
+            opacity: { value: opacity },
+            color: { value: new Color(colorValue) },
+            pulseIntensity: { value: pulseIntensity },
+            interactionPoint: { value: new Vector3() },
+            interactionStrength: { value: 0.0 },
+            isEdgeOnly: { value: false }
+        };
+        
+        this.updateFrequency = isAR ? 2 : 1; // Update every frame in desktop, every other frame in AR
+        this.frameCount = 0;
+        
+        // Add this instance to the set of instances
+        HologramShaderMaterial.instances.add(this);
+        
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('HologramShaderMaterial initialized (Three.js version)', { 
+                updateFrequency: this.updateFrequency,
+                color: colorValue,
+                opacity: opacity
+            });
+        }
+    }
+
+    public static setRenderer(_renderer: WebGLRenderer): void {
+        if (debugState.isShaderDebugEnabled()) {
+            const gl = _renderer.domElement.getContext('webgl2') || _renderer.domElement.getContext('webgl');
+            if (gl) {
+                logger.shader('Renderer initialized', {
+                    isWebGL2: gl instanceof WebGL2RenderingContext,
+                    maxTextures: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
+                    maxVaryings: gl.getParameter(gl.MAX_VARYING_VECTORS),
+                    maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
+                    maxVertexUniforms: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
+                    maxFragmentUniforms: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)
+                });
+            }
+        }
+    }
+
+    // Helper method to create a brighter or dimmer color
+    private createAdjustedColor(baseColor: Color, factor: number): Color {
+        // Create a new color with the same base
+        const newColor = new Color();
+        newColor.set(baseColor);
+        
+        // For simplicity, we'll just create a new color with the same hue
+        // but adjusted brightness based on the factor
+        if (factor !== 1.0) {
+            // Create a brighter or dimmer version of the same color
+            // This is a very simple approach that may not work perfectly
+            // but should be compatible with most Three.js versions
+            try {
+                // Just create a new color with the same base but different brightness
+                const colorValue = baseColor.valueOf();
+                if (typeof colorValue === 'number') {
+                    // If we can get a numeric value, use it to create a new color
+                    newColor.set(colorValue);
+                }
+            } catch (error) {
+                // If anything fails, just use the base color
+                newColor.set(baseColor);
+            }
+        }
+        
+        return newColor;
+    }
+
+    update(deltaTime: number): void {
+        this.frameCount++;
+        if (this.frameCount % this.updateFrequency === 0) {
+            // Update time uniform for API compatibility
+            this.uniforms.time.value += deltaTime;
+            
+            // Apply pulse effect
+            const pulse = Math.sin(this.uniforms.time.value * 2.0) * 0.5 + 0.5;
+            const pulseEffect = pulse * this.pulseIntensity;
+            
+            // Update material properties based on pulse
+            this.opacity = this.baseOpacity * (1.0 + pulseEffect * 0.3);
+            
+            if (this.isEdgeOnlyMode) {
+                // Edge-only mode
+                try {
+                    (this as any).wireframe = true;
+                } catch (e) {
+                    // Ignore errors
+                }
+                
+                // Simple color pulsing - just create a new color with the same base
+                // but slightly brighter or dimmer based on the pulse
+                try {
+                    const brightenFactor = 0.5 + pulseEffect * 0.5;
+                    const newColor = this.createAdjustedColor(this.baseColor, brightenFactor);
+                    this.color.set(newColor);
+                } catch (error) {
+                    logger.warn('Could not adjust color brightness');
+                }
+            } else {
+                // Full hologram mode
+                try {
+                    (this as any).wireframe = false;
+                } catch (e) {
+                    // Ignore errors
+                }
+                
+                // Simple color pulsing with a different factor
+                try {
+                    const brightenFactor = 0.8 + pulseEffect * 0.3;
+                    const newColor = this.createAdjustedColor(this.baseColor, brightenFactor);
+                    this.color.set(newColor);
+                } catch (error) {
+                    logger.warn('Could not adjust color brightness');
+                }
+            }
+            
+            // Handle interaction effect
+            if (this.uniforms.interactionStrength.value > 0.01) {
+                this.uniforms.interactionStrength.value *= 0.95; // Decay interaction effect
+            }
+        }
+    }
+
+    handleInteraction(position: Vector3): void {
+        if (this.frameCount % this.updateFrequency === 0) {
+            this.uniforms.interactionPoint.value.copy(position);
+            this.uniforms.interactionStrength.value = 1.0;
+        }
+    }
+
+    setEdgeOnly(enabled: boolean): void {
+        this.isEdgeOnlyMode = enabled;
+        this.uniforms.isEdgeOnly.value = enabled;
+        
+        // Update material properties based on mode
+        if (enabled) {
+            try {
+                (this as any).wireframe = true;
+            } catch (e) {
+                // Ignore errors
+            }
+            this.opacity = this.baseOpacity * 0.8;
+            this.pulseIntensity = 0.15;
+        } else {
+            try {
+                (this as any).wireframe = false;
+            } catch (e) {
+                // Ignore errors
+            }
+            this.opacity = this.baseOpacity;
+            this.pulseIntensity = 0.1;
+        }
+        
+        // Update uniform for API compatibility
+        this.uniforms.pulseIntensity.value = this.pulseIntensity;
+    }
+
+    clone(): this {
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Cloning HologramShaderMaterial (Three.js version)');
+        }
+        
+        // Create settings object from current uniforms
+        const settings = {
+            visualization: {
+                hologram: {
+                    opacity: this.uniforms.opacity.value,
+                    color: 0x00ff00 // Default color as fallback
+                }
+            }
+        };
+        
+        // Try to get the color value
+        try {
+            // Use a simple approach to get the color value
+            if (this.color) {
+                const colorHex = (this.color as any).getHex ? (this.color as any).getHex() : 0x00ff00;
+                settings.visualization.hologram.color = colorHex;
+            }
+        } catch (error) {
+            logger.warn('Could not get color value, using default color');
+        }
+        
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Clone settings', settings);
+        }
+        
+        const material = new HologramShaderMaterial(
+            settings, 
+            this.side === 0 ? 'ar' : 'desktop'
+        );
+        
+        // Copy current state
+        try {
+            (material as any).wireframe = (this as any).wireframe || false;
+        } catch (e) {
+            // Ignore errors
+        }
+        material.opacity = this.opacity;
+        try {
+            material.color.set(this.color);
+        } catch (error) {
+            logger.warn('Could not copy color from original material');
+        }
+        
+        material.isEdgeOnlyMode = this.isEdgeOnlyMode;
+        
+        // Copy uniforms for API compatibility
+        material.uniforms = {
+            time: { value: this.uniforms.time.value },
+            opacity: { value: this.uniforms.opacity.value },
+            color: { value: new Color().set(this.uniforms.color.value) },
+            pulseIntensity: { value: this.uniforms.pulseIntensity.value },
+            interactionPoint: { value: new Vector3().copy(this.uniforms.interactionPoint.value) },
+            interactionStrength: { value: this.uniforms.interactionStrength.value },
+            isEdgeOnly: { value: this.uniforms.isEdgeOnly.value }
+        };
+
+        if (debugState.isDataDebugEnabled()) {
+            logger.debug('Material cloned successfully');
+        }
+        return material as this;
+    }
+
+    dispose(): void {
+        // Remove this instance from the set when disposed
+        HologramShaderMaterial.instances.delete(this);
+        // Dispose of fallback material if it exists
+        if (this.fallbackMaterial) {
+            this.fallbackMaterial.dispose();
+        }
+        // Call parent dispose
+        super.dispose();
+    }
+}
diff --git a/client/rendering/node/NodeManagerFacade.ts b/client/rendering/node/NodeManagerFacade.ts
new file mode 100644
index 00000000..5af2b69a
--- /dev/null
+++ b/client/rendering/node/NodeManagerFacade.ts
@@ -0,0 +1,678 @@
+import {
+    Scene,
+    Camera,
+    Material,
+    InstancedMesh,
+    Vector3
+} from 'three';
+import { NodeGeometryManager } from './geometry/NodeGeometryManager';
+import { NodeInstanceManager } from './instance/NodeInstanceManager'; 
+import { NodeMetadataManager } from './metadata/NodeMetadataManager';
+import { NodeInteractionManager } from './interaction/NodeInteractionManager'; 
+import { NodeManagerInterface, NodeManagerError, NodeManagerErrorType } from './NodeManagerInterface'; 
+import { NodeIdentityManager } from './identity/NodeIdentityManager';
+import { NodeData } from '../../core/types';
+import { XRHandWithHaptics } from '../../types/xr';
+import { debugState } from '../../core/debugState';
+import { createLogger, createDataMetadata, createErrorMetadata } from '../../core/logger';
+import { UpdateThrottler } from '../../core/utils';
+import { Settings } from '../../types/settings';
+
+const logger = createLogger('NodeManagerFacade');
+
+// Constants for size calculation
+const DEFAULT_FILE_SIZE = 1000; // 1KB default
+const MAX_FILE_SIZE = 10485760; // 10MB max for scaling
+const MIN_NODE_SIZE = 0;
+const MAX_NODE_SIZE = 50;
+
+/**
+ * NodeManagerFacade provides a unified interface to the node management system.
+ * It coordinates between the geometry, instance, metadata, and interaction managers.
+ */
+export class NodeManagerFacade implements NodeManagerInterface {
+    private static instance: NodeManagerFacade;
+    private camera: Camera;
+    private geometryManager: NodeGeometryManager;
+    private instanceManager: NodeInstanceManager;
+    private metadataManager: NodeMetadataManager;
+    private interactionManager: NodeInteractionManager;
+    private identityManager: NodeIdentityManager;
+    private settings: Settings;
+    private isInitialized: boolean = false;
+    private frameCount: number = 0;
+    private tempVector = new Vector3();
+    private labelsInitialized: boolean = false;
+    private metadataUpdateThrottler = new UpdateThrottler(100); // Update at most every 100ms
+    private readonly MAX_POSITION = 1000.0; // Reasonable limit for safe positions
+
+    private constructor(scene: Scene, camera: Camera, material: Material) {
+        this.camera = camera;
+        this.settings = {} as Settings; // Initialize with empty settings
+        
+        logger.info('NodeManagerFacade constructor called', createDataMetadata({
+            timestamp: Date.now(),
+            cameraPosition: camera?.position ? 
+                {x: camera.position.x, y: camera.position.y, z: camera.position.z} : 
+                'undefined'
+        }));
+
+        // Get the identity manager instance first
+        this.identityManager = NodeIdentityManager.getInstance();
+
+        try {
+            logger.info('INITIALIZATION ORDER: NodeManagerFacade - Step 1: Creating NodeGeometryManager');
+            // Initialize managers in the correct order
+            this.geometryManager = NodeGeometryManager.getInstance();
+            
+            logger.info('INITIALIZATION ORDER: NodeManagerFacade - Step 2: Creating NodeInstanceManager');
+            this.instanceManager = NodeInstanceManager.getInstance(scene, material);
+            
+            logger.info('INITIALIZATION ORDER: NodeManagerFacade - Step 3: Creating NodeMetadataManager');
+            this.metadataManager = NodeMetadataManager.getInstance(scene, this.settings);
+            
+            // Initialize interaction manager with instance mesh
+            logger.info('INITIALIZATION ORDER: NodeManagerFacade - Step 4: Creating NodeInteractionManager');
+            const instanceMesh = this.instanceManager.getInstanceMesh();
+            this.interactionManager = NodeInteractionManager.getInstance(instanceMesh);
+
+            this.isInitialized = true;
+            logger.info('NodeManagerFacade initialized');
+        } catch (error) {
+            logger.error('Failed to initialize NodeManagerFacade:', createErrorMetadata(error));
+            throw new NodeManagerError(
+                NodeManagerErrorType.INITIALIZATION_FAILED,
+                'Failed to initialize NodeManagerFacade',
+                error
+            );
+        }
+    }
+    
+    public static getInstance(scene: Scene, camera: Camera, material: Material): NodeManagerFacade {
+        if (!NodeManagerFacade.instance) {
+            NodeManagerFacade.instance = new NodeManagerFacade(scene, camera, material);
+        }
+        return NodeManagerFacade.instance;
+    }
+
+    private calculateNodeSize(fileSize: number = DEFAULT_FILE_SIZE): number {
+        // Map file size logarithmically to 0-1 range
+        const normalizedSize = Math.log(Math.min(fileSize, MAX_FILE_SIZE)) / Math.log(MAX_FILE_SIZE);
+        // Map to metadata node size range (0-50)
+        return MIN_NODE_SIZE + normalizedSize * (MAX_NODE_SIZE - MIN_NODE_SIZE);
+    }
+
+    /**
+     * Validates that a node ID is a numeric string
+     * This ensures we're using the correct server-generated IDs
+     * @param nodeId The node ID to validate
+     * @returns True if the ID is valid (numeric string), false otherwise
+     */
+    private validateNodeId(nodeId: string): boolean {
+        // Ensure boolean return and handle null/undefined
+        return !!nodeId && this.identityManager.isValidNumericId(nodeId);
+    }
+
+    public setXRMode(enabled: boolean): void {
+        if (!this.isInitialized) return;
+
+        try {
+            const instanceMesh = this.instanceManager.getInstanceMesh();
+            if (enabled) {
+                // In XR mode, only use layer 1
+                instanceMesh.layers.set(1);
+            } else {
+                // In non-XR mode, make sure both layers are enabled for consistent visibility
+                instanceMesh.layers.enable(0);
+                instanceMesh.layers.enable(1);
+            }
+            this.metadataManager.setXRMode(enabled);
+            logger.debug('XR mode status changed', createDataMetadata({ enabled }));
+        } catch (error) {
+            throw new NodeManagerError(
+                NodeManagerErrorType.XR_MODE_SWITCH_FAILED,
+                'Failed to switch XR mode',
+                error
+            );
+        }
+    }
+
+    public handleSettingsUpdate(settings: Settings): void {
+        if (!this.isInitialized) return;
+
+        try {
+            this.settings = settings; // Store the settings
+            // Update metadata visibility threshold if needed
+            if (settings.visualization?.labels?.visibilityThreshold) {
+                this.metadataManager.updateVisibilityThreshold(
+                    settings.visualization.labels.visibilityThreshold
+                );
+            }
+            
+            // Pass settings to the metadata manager
+            this.metadataManager.handleSettingsUpdate(settings);
+        } catch (error) {
+            logger.error('Failed to update settings:', createErrorMetadata(error));
+        }
+    }
+
+    /**
+     * Update node positions and states
+     * @param nodes Array of node updates
+     */
+    public updateNodes(nodes: { id: string, data: NodeData }[]): void {
+        const updateStartTime = performance.now();
+
+        if (!this.isInitialized) return;
+
+        // On the first update, reset the node identity manager to ensure clean state
+        if (!this.labelsInitialized) {
+            this.identityManager.reset();
+            logger.info('First updateNodes call: Reset identity manager to ensure clean state');
+            this.labelsInitialized = true;
+        }
+
+        logger.info(`Updating ${nodes.length} nodes in NodeManagerFacade`, createDataMetadata({
+            timestamp: Date.now(),
+            nodeCount: nodes.length,
+            firstNodeId: nodes.length > 0 ? nodes[0].id : 'none',
+            hasInstanceManager: !!this.instanceManager,
+            hasMetadataManager: !!this.metadataManager,
+        }));
+
+        const shouldDebugLog = debugState.isEnabled() && debugState.isNodeDebugEnabled();
+        
+        // First, log detailed info about the first few nodes to help with debugging
+        if (shouldDebugLog && nodes.length > 0) {
+            const sampleNodes = nodes.slice(0, Math.min(3, nodes.length));
+            logger.debug('Node sample for debugging:', createDataMetadata({
+                nodes: sampleNodes.map(node => ({
+                    id: node.id,
+                    hasMetadata: !!node.data.metadata,
+                    metadataName: node.data.metadata?.name || 'undefined',
+                    metadataFileName: node.data.metadata?.file_name || 'undefined'
+                }))
+            }));
+        }
+        
+        this.frameCount++;
+
+        // Filter out any nodes with invalid IDs before processing
+        const validNodes = nodes.filter(node => {
+            if (!this.validateNodeId(node.id)) {
+                logger.warn(`Skipping node with invalid ID format: ${node.id}. Node IDs must be numeric strings.`);
+                return false;
+            }
+            return true;
+        });
+
+        if (validNodes.length < nodes.length) {
+            logger.warn(`Filtered out ${nodes.length - validNodes.length} nodes with invalid IDs`);
+        }
+ 
+        // Create a more detailed processing structure for each node
+        // Process nodes with explicit label handling before identity management
+        const enhancedNodes = validNodes.map(node => {
+            // Extract all possible label sources 
+            const metadataName = node.data.metadata?.name;
+            const metadataFileName = node.data.metadata?.file_name;
+            const isMetadataNameValid = metadataName && 
+                typeof metadataName === 'string' && 
+                metadataName !== 'undefined' &&
+                metadataName !== 'null' &&
+                metadataName !== node.id;
+                                       
+            // Force a unique name if needed by explicitly calling forceNodeLabel
+            // This ensures we always have a valid display name
+            let displayName;
+            
+            if (isMetadataNameValid) {
+                // First choice: Use metadata name (e.g., file title without extension)
+                displayName = metadataName;
+            } else if (metadataFileName && 
+                      typeof metadataFileName === 'string' && 
+                      metadataFileName !== 'undefined' &&
+                      metadataFileName !== 'null') {
+                // Second choice: Use file name if available
+                displayName = metadataFileName;
+            } else {
+                // Last resort: Use node ID with prefix
+                displayName = `Node_${node.id}`;
+            }
+                              
+            // If we have a good name that isn't just the ID, force it
+            if (displayName && displayName !== node.id) {
+                this.identityManager.forceNodeLabel(node.id, displayName);
+                if (shouldDebugLog) {
+                    // Only log occasionally to reduce spam
+                    if (Math.random() < 0.1) {
+                        logger.debug(`Label for node ${node.id}: "${displayName}"`);
+                    }
+                }
+            }
+            
+            return node;
+        });
+
+        // Process enhanced nodes through identity manager to detect duplicates
+        const { duplicateLabels } = this.identityManager.processNodes(enhancedNodes);
+        
+        // Log duplicate labels
+        if (duplicateLabels.size > 0) {
+            logger.warn(`Found ${duplicateLabels.size} duplicate labels`, createDataMetadata({
+                duplicateLabelsCount: duplicateLabels.size,
+                duplicateLabels: Array.from(duplicateLabels.entries()).map(([label, ids]) => 
+                    `${label}: ${ids.join(', ')}`)
+            }));
+        }
+        
+        // Prepare metadata mappings for the metadata manager
+        const metadataMappings = validNodes.map(node => {
+            // Get the label for this node (prioritizing metadata name if possible)
+            const bestLabel = this.identityManager.getLabel(node.id);
+            
+            // Use the metadata name if available, otherwise use our best label
+            const displayName = node.data.metadata?.name && 
+                               typeof node.data.metadata.name === 'string' && 
+                               node.data.metadata.name !== 'undefined' &&
+                               node.data.metadata.name !== 'null' ? 
+                                  node.data.metadata.name : bestLabel;
+            
+            return {
+                id: node.id,
+                metadataId: node.data.metadata?.name || displayName,
+                label: bestLabel
+            };
+        });
+        
+        this.metadataManager.initializeMappings(metadataMappings);
+        
+        // Process nodes for visualization
+        const processedIds = new Set<string>();
+        validNodes.forEach((node, index) => {
+            if (shouldDebugLog && index < 3) {
+                // Get the best label from our identity manager
+                const bestLabel = this.identityManager.getLabel(node.id);
+                logger.debug(`Processing node ${index}: id=${node.id}, label=${bestLabel}`, 
+                    createDataMetadata({
+                        hasMetadata: !!node.data.metadata,
+                        fileSize: node.data.metadata?.fileSize
+                    }));
+            }
+            
+            // Skip any duplicate node IDs in this batch
+            if (processedIds.has(node.id)) {
+                logger.debug(`Skipping duplicate node ID: ${node.id}`);
+                return;
+            }
+            processedIds.add(node.id);
+            
+            if (node.data.metadata) {
+                // Log position information to help diagnose issues
+                if (node.data.position && 
+                    (node.data.position.x === 0 && node.data.position.y === 0 && node.data.position.z === 0)) {
+                    logger.warn(`Node ${node.id} has ZERO position during updateNodes`, createDataMetadata({
+                        label: this.identityManager.getLabel(node.id) || node.id,
+                        position: `x:0, y:0, z:0`
+                    }));
+                } else if (node.data.position) {
+                    if (shouldDebugLog && index < 5) {
+                        logger.debug(`Node ${node.id} position: x:${node.data.position.x.toFixed(2)}, ` +
+                                     `y:${node.data.position.y.toFixed(2)}, z:${node.data.position.z.toFixed(2)}`);
+                    }
+                } else {
+                    logger.warn(`Node ${node.id} has NO position during updateNodes`);
+                }
+            }
+        });
+
+        // Update instance positions
+        // Important: Use fresh map to avoid modifying the original nodes
+        const nodePositionUpdates = validNodes.map(node => ({
+            // Extract just what's needed for position update
+            id: node.id,
+            metadata: node.data.metadata || {},
+            position: node.data.position,
+            velocity: node.data.velocity
+        }));
+        this.instanceManager.updateNodePositions(nodePositionUpdates);
+       
+        // Only update metadata if the throttler allows it
+        if (this.metadataUpdateThrottler.shouldUpdate()) {
+            // Update metadata for each node
+            validNodes.forEach(node => {
+                if (node.data.metadata) {
+                    // Ensure we have valid file size
+                    const fileSize = node.data.metadata.fileSize && node.data.metadata.fileSize > 0 
+                        ? node.data.metadata.fileSize 
+                        : DEFAULT_FILE_SIZE;
+                    
+                    // Get the best label from our identity manager
+                    const displayName = this.identityManager.getLabel(node.id);
+                    
+                    if (shouldDebugLog) {
+                        logger.debug('Updating node metadata', createDataMetadata({ 
+                            nodeId: node.id, 
+                            displayName,
+                            fileSize: node.data.metadata.fileSize
+                        }));
+                    }
+                    
+                    this.metadataManager.updateMetadata(node.id, {
+                        id: node.id,
+                        name: displayName, // Use the best name available
+                        position: node.data.position,
+                        // Ensure proper metadata is set with appropriate defaults
+                        commitAge: node.data.metadata.lastModified !== undefined 
+                            ? node.data.metadata.lastModified 
+                            : 0,
+                        hyperlinkCount: (node.data.metadata.hyperlinkCount !== undefined && node.data.metadata.hyperlinkCount > 0)
+                            ? node.data.metadata.hyperlinkCount
+                            : node.data.metadata.links?.length || 0,
+                        importance: node.data.metadata.hyperlinkCount || 0,
+                        fileSize: fileSize, // Use the provided fileSize
+                        nodeSize: this.calculateNodeSize(fileSize),
+                    });
+                }
+            });
+        }
+
+        const updateElapsedTime = performance.now() - updateStartTime;
+        logger.info(`Node updates completed in ${updateElapsedTime.toFixed(2)}ms`, createDataMetadata({
+            nodeCount: nodes.length,
+            validNodeCount: validNodes.length,
+            processedCount: processedIds.size,
+            elapsedTimeMs: updateElapsedTime.toFixed(2)
+        }));
+    }
+ 
+    /**
+     * Validates and fixes a Vector3 if it contains NaN or infinite values
+     * Returns true if the vector was valid, false if it needed correction
+     */
+    private validateAndFixVector3(vec: Vector3, label: string, nodeId: string): boolean {
+        const isValid = !isNaN(vec.x) && !isNaN(vec.y) && !isNaN(vec.z) &&
+                       isFinite(vec.x) && isFinite(vec.y) && isFinite(vec.z);
+        
+        if (!isValid) {
+            // Log warning with details of the invalid values
+            logger.warn(`Invalid ${label} values for node ${nodeId}`, createDataMetadata({
+                x: vec.x,
+                y: vec.y,
+                z: vec.z,
+                isNaNX: isNaN(vec.x),
+                isNaNY: isNaN(vec.y),
+                isNaNZ: isNaN(vec.z),
+                isFiniteX: isFinite(vec.x),
+                isFiniteY: isFinite(vec.y),
+                isFiniteZ: isFinite(vec.z)
+            }));
+            
+            // Fix the vector - replace NaN or infinite values with 0
+            vec.x = isNaN(vec.x) || !isFinite(vec.x) ? 0 : vec.x;
+            vec.y = isNaN(vec.y) || !isFinite(vec.y) ? 0 : vec.y;
+            vec.z = isNaN(vec.z) || !isFinite(vec.z) ? 0 : vec.z;
+            
+            // Also clamp to reasonable bounds
+            vec.x = Math.max(-this.MAX_POSITION, Math.min(this.MAX_POSITION, vec.x));
+            vec.y = Math.max(-this.MAX_POSITION, Math.min(this.MAX_POSITION, vec.y));
+            vec.z = Math.max(-this.MAX_POSITION, Math.min(this.MAX_POSITION, vec.z));
+        }
+        return isValid;
+    }
+
+    public updateNodePositions(nodes: { 
+        id: string, 
+        data: { 
+            position: Vector3,
+            velocity?: Vector3
+        } 
+    }[]): void {
+        const updatePosStartTime = performance.now();
+        
+        if (!this.isInitialized) return;
+        
+        // Validate all node IDs in the update
+        const validNodeIds = nodes.every(update => this.validateNodeId(update.id));
+        if (!validNodeIds) {
+            logger.warn("Some node IDs in position update are invalid (non-numeric). This may cause rendering issues.");
+        }
+        
+        logger.info(`Updating positions for ${nodes.length} nodes`, createDataMetadata({
+            timestamp: Date.now(),
+            nodeCount: nodes.length
+        }));
+
+        // Track zero position counts for diagnostics
+        let zeroPositionCount = 0;
+        let nullVelocityCount = 0;
+
+        try {
+            // Handle NaN values and validate positions before passing to instance manager
+            const validatedNodes = nodes.map(node => {
+                // Skip nodes with invalid IDs
+                if (!this.validateNodeId(node.id)) {
+                    logger.warn(`Skipping node with invalid ID format: ${node.id} from position update`);
+                    return null;
+                }
+
+                // Check for zero positions
+                if (node.data.position.x === 0 && node.data.position.y === 0 && node.data.position.z === 0) {
+                    zeroPositionCount++;
+                    if (Math.random() < 0.05) { // Log only 5% of cases to avoid spam
+                        logger.debug(`Node ${node.id} has ZERO position during updateNodePositions`);
+                    }
+                }
+                
+                // Check for null velocities
+                if (!node.data.velocity) {
+                    nullVelocityCount++;
+                    // Create a zero velocity vector if missing
+                    node.data.velocity = new Vector3(0, 0, 0);
+                }
+                
+                const positionValid = this.validateAndFixVector3(node.data.position, 'position', node.id);
+                const velocityValid = node.data.velocity ? 
+                                     this.validateAndFixVector3(node.data.velocity, 'velocity', node.id) : 
+                                     false;
+                
+                if (!positionValid || !velocityValid) {
+                    logger.warn(`Fixed invalid vectors for node ${node.id}`, createDataMetadata({
+                        positionValid,
+                        velocityValid,
+                        position: {
+                            x: node.data.position.x, 
+                            y: node.data.position.y, 
+                            z: node.data.position.z
+                        },
+                        velocity: node.data.velocity ? {
+                            x: node.data.velocity.x, 
+                            y: node.data.velocity.y, 
+                            z: node.data.velocity.z
+                        } : 'undefined'
+                    }));
+                }
+                
+                return { id: node.id, position: node.data.position, velocity: node.data.velocity };
+            }).filter(node => node !== null) as { 
+                id: string, 
+                position: Vector3, 
+                velocity: Vector3 
+            }[];
+            
+            this.instanceManager.updateNodePositions(validatedNodes);
+            
+            const updatePosElapsedTime = performance.now() - updatePosStartTime;
+            logger.info(`Position updates completed in ${updatePosElapsedTime.toFixed(2)}ms`, createDataMetadata({
+                nodeCount: nodes.length,
+                zeroPositionCount,
+                nullVelocityCount,
+                elapsedTimeMs: updatePosElapsedTime.toFixed(2)
+            }));
+        } catch (error) {
+            logger.error('Position update failed:', createErrorMetadata(error));
+            throw new NodeManagerError(
+                NodeManagerErrorType.UPDATE_FAILED,
+                'Failed to update node positions',
+                error
+            );
+        }
+    }
+
+    /**
+     * Handle XR hand interactions
+     * @param hand XR hand data with haptic feedback
+     */
+    public handleHandInteraction(hand: XRHandWithHaptics): void {
+        if (!this.isInitialized) return;
+        this.interactionManager.handleHandInteraction(hand);
+    }
+
+    /**
+     * Update the visualization state
+     * @param deltaTime Time since last update
+     */
+    public update(deltaTime: number): void {
+        if (!this.isInitialized) return;
+
+        const updateFrameStartTime = performance.now();
+
+        // Update instance visibility and LOD
+        this.instanceManager.update(this.camera, deltaTime);
+        
+        // Log position updates only occasionally
+        const shouldLogDetail = this.frameCount % 300 === 0; // Log every 300 frames
+        let noPositionCount = 0;
+        let zeroPositionCount = 0;
+
+        // Update metadata positions to match instances
+        try {
+            // Only update positions every few frames for performance
+            // Use a simple array of node IDs that we maintain in this class
+            // This avoids dependencies on internal implementation details
+            const nodeIds = this.identityManager.getAllNodeIds();
+            const nodeCount = nodeIds.length;
+            
+            // Process each node ID
+            let processedCount = 0;
+            
+            nodeIds.forEach(id => {
+                if (!this.validateNodeId(id)) {
+                    return; // Skip invalid IDs silently during routine updates
+                }
+
+                const position = this.instanceManager.getNodePosition(id);
+                if (!position) {
+                    noPositionCount++;
+                    return;
+                }
+                
+                // Check for zero positions
+                if (position.x === 0 && position.y === 0 && position.z === 0) {
+                    zeroPositionCount++;
+                    if (shouldLogDetail && Math.random() < 0.2) {
+                        logger.warn(`Node ${id} has ZERO position during metadata position update`);
+                    }
+                }
+                
+                this.tempVector.copy(position);
+                
+                // Calculate dynamic offset based on node size
+                // Use the node's calculated size for offset
+                const nodeSize = this.calculateNodeSize();
+                
+                this.tempVector.y += nodeSize * 0.03; // Drastically reduced offset for much closer label positioning
+                // Update individual label position (preserve existing text content)
+                this.metadataManager.updatePosition(id, this.tempVector.clone());
+                processedCount++;
+            });
+            this.frameCount++;
+            
+            if (shouldLogDetail) {
+                const updateFrameElapsedTime = performance.now() - updateFrameStartTime;
+                logger.info(`Metadata position update frame ${this.frameCount}`, createDataMetadata({
+                    totalNodes: nodeCount,
+                    nodesWithoutPosition: noPositionCount,
+                    processedNodes: processedCount,
+                    elapsedTimeMs: updateFrameElapsedTime.toFixed(2)
+                }));
+            }
+        } catch (error) {
+            logger.error('Error updating metadata positions:', createErrorMetadata(error));
+        }
+
+        // Update metadata labels
+        this.metadataManager.update(this.camera);
+    }
+
+    /**
+     * Clean up resources
+     */
+    public dispose(): void {
+        if (!this.isInitialized) return;
+
+        try {
+            this.geometryManager.dispose();
+            this.instanceManager.dispose();
+            this.metadataManager.dispose();
+            this.interactionManager.dispose();
+            
+            // Dispose the identity manager
+            this.identityManager.dispose();
+
+            NodeManagerFacade.instance = null!;
+            this.isInitialized = false;
+            logger.info('NodeManagerFacade disposed');
+        } catch (error) {
+            throw new NodeManagerError(
+                NodeManagerErrorType.RESOURCE_CLEANUP_FAILED,
+                'Failed to dispose NodeManagerFacade',
+                error
+            );
+        }
+    }
+
+    /**
+     * Get the underlying InstancedMesh
+     * Useful for adding to scenes or handling special cases
+     */
+    public getInstancedMesh(): InstancedMesh {
+        return this.instanceManager.getInstanceMesh();
+    }
+
+    /**
+     * Get node ID from instance index
+     * @param index Instance index in the InstancedMesh
+     * @returns Node ID or undefined if not found
+     */
+    public getNodeId(index: number): string | undefined {
+        return this.instanceManager.getNodeId(index);
+    }
+
+    /**
+     * Get instance index from node ID
+     * @param nodeId Numeric node ID
+     * @returns Instance index or undefined if not found
+     */
+    public getInstanceIndex(nodeId: string): number | undefined {
+        return this.instanceManager.getInstanceId(nodeId);
+    }
+
+    /**
+     * Get the underlying NodeInstanceManager
+     * @returns The NodeInstanceManager instance
+     */
+    public getNodeInstanceManager(): NodeInstanceManager {
+        return this.instanceManager;
+    }
+
+    /**
+     * Get the metadata ID for a given node ID
+     * This is useful for retrieving the human-readable name (file name)
+     * @param nodeId Node ID to look up
+     * @returns Metadata ID (filename) or undefined if not found
+     */
+    public getMetadataId(nodeId: string): string | undefined {
+        return this.identityManager.getLabel(nodeId);
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/node/NodeManagerFactory.ts b/client/rendering/node/NodeManagerFactory.ts
new file mode 100644
index 00000000..5415f203
--- /dev/null
+++ b/client/rendering/node/NodeManagerFactory.ts
@@ -0,0 +1,79 @@
+import { Scene, Camera, Material } from 'three';
+import { NodeManagerInterface, NodeManagerError, NodeManagerErrorType } from './NodeManagerInterface';
+import { NodeManagerFacade } from './NodeManagerFacade';
+import { createLogger } from '../../core/logger';
+
+const logger = createLogger('NodeManagerFactory');
+
+/**
+ * Factory class for creating node manager instances.
+ */
+export class NodeManagerFactory {
+    private static instance: NodeManagerFactory;
+    private currentManager: NodeManagerInterface | null = null;
+
+    private constructor() {}
+
+    public static getInstance(): NodeManagerFactory {
+        if (!NodeManagerFactory.instance) {
+            NodeManagerFactory.instance = new NodeManagerFactory();
+        }
+        return NodeManagerFactory.instance;
+    }
+
+    /**
+     * Create a node manager instance
+     */
+    public createNodeManager(
+        scene: Scene,
+        camera: Camera,
+        material: Material,
+        _settings: any
+    ): NodeManagerInterface {
+        try {
+            // Clean up existing manager if any
+            if (this.currentManager) {
+                this.currentManager.dispose();
+                this.currentManager = null;
+            }
+
+            logger.info('Creating node manager');
+            this.currentManager = NodeManagerFacade.getInstance(
+                scene,
+                camera,
+                material
+            );
+            logger.debug('Node manager created successfully');
+
+            return this.currentManager;
+        } catch (error) {
+            throw new NodeManagerError(
+                NodeManagerErrorType.INITIALIZATION_FAILED,
+                'Failed to create node manager',
+                error
+            );
+        }
+    }
+
+    /**
+     * Get current node manager instance
+     */
+    public getCurrentManager(): NodeManagerInterface | null {
+        return this.currentManager;
+    }
+
+    /**
+     * Clean up resources
+     */
+    public dispose(): void {
+        if (this.currentManager) {
+            this.currentManager.dispose();
+            this.currentManager = null;
+        }
+        NodeManagerFactory.instance = null!;
+        logger.info('NodeManagerFactory disposed');
+    }
+}
+
+// Export singleton instance
+export const nodeManagerFactory = NodeManagerFactory.getInstance();
\ No newline at end of file
diff --git a/client/rendering/node/NodeManagerInterface.ts b/client/rendering/node/NodeManagerInterface.ts
new file mode 100644
index 00000000..16f18aab
--- /dev/null
+++ b/client/rendering/node/NodeManagerInterface.ts
@@ -0,0 +1,132 @@
+import { XRHandWithHaptics } from '../../types/xr';
+import { NodeData } from '../../core/types';
+import { Camera, Scene, Vector3 } from 'three';
+
+/**
+ * Common interface for node management implementations.
+ * This ensures compatibility between the old EnhancedNodeManager
+ * and the new NodeManagerFacade during migration.
+ */
+export interface NodeManagerInterface {
+    /**
+     * Update node positions and metadata
+     * @param nodes Array of node updates containing position and metadata
+     */
+    updateNodes(nodes: { id: string, data: NodeData }[]): void;
+
+    /**
+     * Update node positions from binary data
+     * @param nodes Array of node position updates
+     */
+    updateNodePositions(nodes: { 
+        id: string, 
+        data: { 
+            position: Vector3,
+            velocity?: Vector3
+        } 
+    }[]): void;
+
+    /**
+     * Handle XR hand interactions
+     * @param hand XR hand data with haptic feedback capabilities
+     */
+    handleHandInteraction(hand: XRHandWithHaptics): void;
+
+    /**
+     * Update the visualization state
+     * @param deltaTime Time since last update in seconds
+     */
+    update(deltaTime: number): void;
+
+    /**
+     * Clean up resources
+     */
+    dispose(): void;
+
+    /**
+     * Set XR mode state
+     * @param enabled Whether XR mode is active
+     */
+    setXRMode(enabled: boolean): void;
+
+    /**
+     * Handle settings updates
+     * @param settings Updated settings object
+     */
+    handleSettingsUpdate(settings: any): void;
+}
+
+/**
+ * Factory interface for creating node managers
+ */
+export interface NodeManagerFactory {
+    /**
+     * Create a node manager instance
+     * @param scene Three.js scene
+     * @param camera Camera for visibility calculations
+     * @param settings Application settings
+     */
+    createNodeManager(scene: Scene, camera: Camera, settings: any): NodeManagerInterface;
+}
+
+/**
+ * Configuration options for node managers
+ */
+export interface NodeManagerConfig {
+    /**
+     * Maximum number of nodes to support
+     */
+    maxNodes?: number;
+
+    /**
+     * Distance threshold for LOD transitions
+     */
+    lodThresholds?: {
+        high: number;
+        medium: number;
+        low: number;
+    };
+
+    /**
+     * Performance settings
+     */
+    performance?: {
+        batchSize?: number;
+        updateInterval?: number;
+        cullingDistance?: number;
+    };
+
+    /**
+     * Metadata visualization settings
+     */
+    metadata?: {
+        enabled?: boolean;
+        maxDistance?: number;
+        updateInterval?: number;
+    };
+}
+
+/**
+ * Error types specific to node management
+ */
+export enum NodeManagerErrorType {
+    INITIALIZATION_FAILED = 'initialization_failed',
+    UPDATE_FAILED = 'update_failed',
+    RESOURCE_CLEANUP_FAILED = 'resource_cleanup_failed',
+    INVALID_NODE_DATA = 'invalid_node_data',
+    XR_MODE_SWITCH_FAILED = 'xr_mode_switch_failed'
+}
+
+/**
+ * Custom error class for node management errors
+ */
+export class NodeManagerError extends Error {
+    constructor(
+        public type: NodeManagerErrorType,
+        message: string,
+        public details?: any
+    ) {
+        super(message);
+        this.name = 'NodeManagerError';
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/node/geometry/NodeGeometryManager.ts b/client/rendering/node/geometry/NodeGeometryManager.ts
new file mode 100644
index 00000000..4debd044
--- /dev/null
+++ b/client/rendering/node/geometry/NodeGeometryManager.ts
@@ -0,0 +1,261 @@
+import {
+    BufferGeometry,
+    IcosahedronGeometry,
+    OctahedronGeometry
+} from 'three';
+import { GeometryFactory } from '../../factories/GeometryFactory';
+import { createLogger, createDataMetadata } from '../../../core/logger';
+
+const logger = createLogger('NodeGeometryManager');
+
+// LOD level definitions
+export enum LODLevel {
+    HIGH = 0,    // < 10 meters: Full detail
+    MEDIUM = 1,  // 10-50 meters: Medium detail
+    LOW = 2      // > 50 meters: Low detail
+} 
+
+// Interface for LOD thresholds with hysteresis
+interface LODHysteresisThresholds {
+    // Thresholds for switching to a higher detail level (moving closer)
+    upscale: {
+        [LODLevel.HIGH]: number;   // Switch to HIGH when closer than this
+        [LODLevel.MEDIUM]: number; // Switch to MEDIUM when closer than this
+    };
+    // Thresholds for switching to a lower detail level (moving away)
+    downscale: {
+        [LODLevel.MEDIUM]: number; // Switch to MEDIUM when further than this
+        [LODLevel.LOW]: number;    // Switch to LOW when further than this
+    };
+} 
+
+interface GeometryQuality {
+    segments: number;  // Number of segments/detail level
+    radius: number;    // Base size
+}
+
+export class NodeGeometryManager {
+    private static instance: NodeGeometryManager;
+    private geometryCache: Map<LODLevel, BufferGeometry>;
+    private currentLOD: LODLevel = LODLevel.HIGH;
+    private lastDistance: number = 0;
+    private switchCount: number = 0;
+    private _lastSwitchTime: number = 0;
+    
+    // Implement hysteresis with different thresholds for upscaling vs downscaling
+    private readonly lodThresholds: LODHysteresisThresholds = {
+        // Thresholds for increasing detail (moving closer)
+        upscale: {
+            [LODLevel.HIGH]: 5.0,     // Switch to HIGH when closer than 5m (reduced from 8m)
+            [LODLevel.MEDIUM]: 30.0,  // Switch to MEDIUM when closer than 30m (reduced from 40m)
+        },
+        // Thresholds for decreasing detail (moving away)
+        downscale: {
+            [LODLevel.MEDIUM]: 15.0,  // Switch to MEDIUM when further than 15m (increased from 12m)
+            [LODLevel.LOW]: 70.0,     // Switch to LOW when further than 70m (increased from 60m)
+        }
+    };
+
+    private readonly qualitySettings: Record<LODLevel, GeometryQuality> = {
+        [LODLevel.HIGH]: { segments: 1, radius: 0.12 },   // 12cm radius with 1 subdivision
+        [LODLevel.MEDIUM]: { segments: 0, radius: 0.12 }, // 12cm radius basic octahedron
+        [LODLevel.LOW]: { segments: 0, radius: 0.1 }      // 10cm octahedron for distance
+    };
+
+    private constructor() {
+        GeometryFactory.getInstance(); // Initialize factory
+        this.geometryCache = new Map();
+        this.initializeGeometries();
+    }
+
+    public static getInstance(): NodeGeometryManager {
+        if (!NodeGeometryManager.instance) {
+            NodeGeometryManager.instance = new NodeGeometryManager();
+        }
+        return NodeGeometryManager.instance;
+    }
+
+    private initializeGeometries(): void {
+        // Initialize geometries for each LOD level
+        Object.values(LODLevel).forEach((level) => {
+            if (typeof level === 'number') {
+                const quality = this.qualitySettings[level];
+                const geometry = this.createOptimizedGeometry(level, quality);
+                this.geometryCache.set(level, geometry);
+            }
+        });
+        logger.info('Initialized geometries for all LOD levels');
+    }
+
+    private createOptimizedGeometry(level: LODLevel, quality: GeometryQuality): BufferGeometry {
+        // Create geometry based on LOD level
+        let geometry: BufferGeometry;
+
+        switch (level) {
+            case LODLevel.HIGH:
+                // High detail: Icosahedron with 1 subdivision
+                geometry = new IcosahedronGeometry(quality.radius, 1);
+                break;
+
+            case LODLevel.MEDIUM:
+                // Medium detail: Basic octahedron
+                geometry = new OctahedronGeometry(quality.radius);
+                break;
+
+            case LODLevel.LOW:
+                // Low detail: Smaller octahedron
+                geometry = new OctahedronGeometry(quality.radius);
+                break;
+
+            default:
+                logger.warn(`Unknown LOD level: ${level}, falling back to medium quality`);
+                geometry = new OctahedronGeometry(quality.radius);
+        }
+
+        // Compute and adjust bounding sphere for better frustum culling
+        geometry.computeBoundingSphere();
+        if (geometry.boundingSphere) {
+            geometry.boundingSphere.radius *= 1.2;
+        }
+
+        return geometry;
+    }
+
+    /**
+     * Get the appropriate geometry for a given distance with hysteresis to prevent
+     * rapid switching between LOD levels
+     */
+    public getGeometryForDistance(distance: number): BufferGeometry {
+        // Start with current LOD level
+        let targetLOD = this.currentLOD;
+
+        // Calculate distance change since last update
+        const distanceChange = Math.abs(distance - this.lastDistance);
+        this.lastDistance = distance;
+        
+        // Skip LOD calculation if distance hasn't changed significantly (< 0.5m)
+        // This prevents unnecessary LOD switches due to tiny camera movements
+        if (distanceChange < 0.5) {
+            return this.getGeometryForLOD(this.currentLOD);
+        }
+        
+        // Use more conservative thresholds for AR mode
+        const isAR = window.location.href.includes('ar=true') || 
+                    document.querySelector('#xr-button')?.textContent?.includes('Exit AR');
+        
+        // Apply AR mode adjustments if needed
+        let thresholds = this.lodThresholds;
+        if (isAR) {
+            // In AR mode, use more conservative thresholds (1.5x further)
+            thresholds = {
+                upscale: {
+                    [LODLevel.HIGH]: this.lodThresholds.upscale[LODLevel.HIGH] * 1.5,
+                    [LODLevel.MEDIUM]: this.lodThresholds.upscale[LODLevel.MEDIUM] * 1.5,
+                },
+                downscale: {
+                    [LODLevel.MEDIUM]: this.lodThresholds.downscale[LODLevel.MEDIUM] * 1.5,
+                    [LODLevel.LOW]: this.lodThresholds.downscale[LODLevel.LOW] * 1.5,
+                }
+            };
+        }
+        
+        // Apply hysteresis based on current LOD level and distance
+        switch (this.currentLOD) {
+            case LODLevel.HIGH:
+                // Currently high detail - only downgrade if we move far enough away
+                if (distance > thresholds.downscale[LODLevel.MEDIUM]) {
+                    targetLOD = LODLevel.MEDIUM;
+                }
+                break;
+                
+            case LODLevel.MEDIUM:
+                // Currently medium detail - upgrade or downgrade based on distance
+                if (distance <= thresholds.upscale[LODLevel.HIGH]) {
+                    targetLOD = LODLevel.HIGH;
+                } else if (distance > thresholds.downscale[LODLevel.LOW]) {
+                    targetLOD = LODLevel.LOW;
+                }
+                break;
+                
+            case LODLevel.LOW:
+                // Currently low detail - only upgrade if we get close enough
+                if (distance <= thresholds.upscale[LODLevel.MEDIUM]) {
+                    targetLOD = LODLevel.MEDIUM;
+                }
+                break;
+        }
+
+        // Only update if LOD level changed
+        if (targetLOD !== this.currentLOD) {
+            this.switchCount++;
+            
+            // Add a dampening mechanism to reduce switch frequency
+            // Only update if we've had a significant distance change or a minimum count of frames
+            const significantDistanceChange = distanceChange > 2.0; // 2 meters movement is significant
+            
+            // Implement a cooldown period for LOD switching (don't switch too frequently)
+            const currentTime = performance.now();
+            const timeSinceLastSwitch = currentTime - (this._lastSwitchTime || 0);
+            const minimumSwitchInterval = 1000; // 1 second between LOD changes
+            
+            if (significantDistanceChange || timeSinceLastSwitch > minimumSwitchInterval) {
+                // Update LOD level
+                this.currentLOD = targetLOD;
+                this._lastSwitchTime = currentTime;
+                
+                // Log at debug level to reduce console spam
+                logger.info(`Switching to LOD level ${targetLOD} for distance ${distance.toFixed(2)}`, 
+                    createDataMetadata({ 
+                        previousLevel: this.currentLOD,
+                    switchCount: this.switchCount,
+                    distanceChange: distanceChange.toFixed(3)
+                }));
+            }
+        }
+
+        // Always ensure we return a valid geometry
+        const geometry = this.geometryCache.get(targetLOD);
+        if (!geometry) {
+            logger.warn(`No geometry found for LOD level ${targetLOD}, falling back to MEDIUM`);
+            return this.geometryCache.get(LODLevel.MEDIUM)!;
+        }
+        return geometry;
+    }
+    
+    /**
+     * Get geometry for a specific LOD level
+     */
+    private getGeometryForLOD(level: LODLevel): BufferGeometry {
+        const geometry = this.geometryCache.get(level);
+        if (!geometry) {
+            logger.warn(`No geometry found for LOD level ${level}, falling back to MEDIUM`);
+            return this.geometryCache.get(LODLevel.MEDIUM)!;
+        }
+        return geometry;
+    }
+
+    public getCurrentLOD(): LODLevel {
+        return this.currentLOD;
+    }
+
+    /**
+     * Get the upscale threshold for a specific LOD level
+     */
+    public getUpscaleThresholdForLOD(level: LODLevel): number | undefined {
+        if (level === LODLevel.HIGH || level === LODLevel.MEDIUM) {
+            return this.lodThresholds.upscale[level];
+        } else if (level === LODLevel.LOW) {
+            return undefined; // No upscale threshold for LOW level
+        }
+        return undefined;
+    } 
+
+    public dispose(): void {
+        // Clean up geometries
+        this.geometryCache.forEach(geometry => {
+            geometry.dispose();
+        });
+        this.geometryCache.clear();
+        logger.info('Disposed all geometries');
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/node/identity/NodeIdentityManager.ts b/client/rendering/node/identity/NodeIdentityManager.ts
new file mode 100644
index 00000000..d7500074
--- /dev/null
+++ b/client/rendering/node/identity/NodeIdentityManager.ts
@@ -0,0 +1,397 @@
+import { createLogger, createDataMetadata } from '../../../core/logger';
+
+const logger = createLogger('NodeIdentityManager');
+const NUMERIC_ID_PREFIX = "node_"; // Prefix to distinguish numeric IDs from metadata names
+
+/**
+ * NodeIdentityManager provides a single source of truth for node identity resolution.
+ * 
+ * It simplifies the relationship between:
+ * - Server-generated numeric node IDs (u16 indices)
+ * - Human-readable labels (filenames without .md extension)
+ */
+export class NodeIdentityManager {
+    private static instance: NodeIdentityManager;
+    
+    // Maps numeric node ID to user-friendly label
+    private numericIdToLabel = new Map<string, string>();
+    
+    // Maps node labels to a unique suffixed version (for deduplication)
+    private labelToUnique = new Map<string, string>();
+    
+    // Maps labels to the numeric IDs that use them (for duplicate detection)
+    private labelToNodeIds = new Map<string, string[]>();
+    
+    // Regular expression to validate numeric IDs
+    private readonly NODE_ID_REGEX = /^\d+$/;
+    
+    // Set default label to ensure it's never empty or duplicated
+    private readonly DEFAULT_LABEL_PREFIX = 'Node_';
+    
+    private constructor() {
+        logger.info('NodeIdentityManager initialized');
+    }
+    
+    /**
+     * Get the singleton instance of NodeIdentityManager
+     */
+    public static getInstance(): NodeIdentityManager {
+        if (!NodeIdentityManager.instance) {
+            NodeIdentityManager.instance = new NodeIdentityManager();
+        }
+        return NodeIdentityManager.instance;
+    }
+    
+    /**
+     * Check if a string is a valid numeric node ID
+     */
+    public isValidNumericId(id: string): boolean {
+        return typeof id === 'string' && 
+               id !== undefined && 
+               id !== null && 
+               this.NODE_ID_REGEX.test(id);
+    }
+    
+    /**
+     * Process a batch of nodes to establish identity mappings and detect duplicates
+     */
+    public processNodes(nodes: any[], forceReset: boolean = false): { duplicateLabels: Map<string, string[]> } {
+        const duplicateLabels = new Map<string, string[]>();
+        
+        // If force reset is requested, completely reset our mappings
+        if (forceReset) {
+            logger.info('Forced reset of all node identity mappings');
+            this.reset();
+            this.labelToUnique.clear();
+        }
+        
+        if (nodes.length === 0) {
+            return { duplicateLabels };
+        }
+        
+        // Log first few nodes for debugging
+        logger.info(`Processing ${nodes.length} nodes. First few node IDs:`, 
+            createDataMetadata({
+                nodeIds: nodes.slice(0, 5).map(n => n.id)
+            }));
+        
+        // Track processed nodes in this batch
+        const processedNodeIds = new Set<string>();
+        
+        // Process each node
+        nodes.forEach(node => {
+            if (!this.isValidNumericId(node.id)) {
+                logger.warn(`Skipping node with invalid ID format: ${node.id}`);
+                return;
+            }
+            
+            processedNodeIds.add(node.id);
+            
+            // Get any existing label for this node
+            const existingLabel = this.numericIdToLabel.get(node.id);
+            
+            if (existingLabel) {
+                // If we have an existing label and it's different from the node ID, use it
+                // But only if it doesn't look like our default or a numeric ID
+                const isNumericLabel = this.NODE_ID_REGEX.test(existingLabel) || 
+                                       existingLabel.startsWith(this.DEFAULT_LABEL_PREFIX) ||
+                                       existingLabel.startsWith(NUMERIC_ID_PREFIX);
+                                    
+                if (existingLabel !== node.id && !isNumericLabel) {
+                    
+                    // Keep using the existing label if it's valid
+                    this.trackLabelUsage(node.id, existingLabel);
+                    return;
+                }
+            }
+            
+            // Determine a new best label if we don't have a valid one
+            const newLabel = this.determineBestLabel(node);
+            if (newLabel && newLabel !== node.id) {
+                this.numericIdToLabel.set(node.id, newLabel);
+                this.trackLabelUsage(node.id, newLabel);
+            }
+        });
+        
+        // Rebuild the labelToNodeIds map based on all existing mappings in numericIdToLabel
+        // but keeping any entries for nodes not in this batch
+        const newLabelToNodeIds = new Map<string, string[]>();
+        
+        // First, copy over existing entries for nodes not in this batch
+        this.labelToNodeIds.forEach((nodeIds, label) => {
+            const filteredNodeIds = nodeIds.filter(id => !processedNodeIds.has(id));
+            if (filteredNodeIds.length > 0) {
+                newLabelToNodeIds.set(label, filteredNodeIds);
+            }
+        });
+        
+        // Then add the entries from this batch
+        this.numericIdToLabel.forEach((label, nodeId) => {
+            if (!label || label === nodeId || this.NODE_ID_REGEX.test(label)) {
+                return; // Skip numeric IDs or empty labels
+            }
+            
+            if (!newLabelToNodeIds.has(label)) {
+                newLabelToNodeIds.set(label, [nodeId]);
+            } else {
+                newLabelToNodeIds.get(label)!.push(nodeId);
+            }
+        });
+        
+        // Update the main map
+        this.labelToNodeIds = newLabelToNodeIds;
+        
+        // Find and log duplicates
+        this.labelToNodeIds.forEach((nodeIds, label) => {
+            if (nodeIds.length > 1) {
+                // Only track meaningful labels, not numeric IDs or generic names
+                if (!this.NODE_ID_REGEX.test(label) && 
+                    !['undefined', 'Unknown', ''].includes(label)) {
+                    duplicateLabels.set(label, [...nodeIds]);
+                    logger.warn(`DUPLICATE LABEL: "${label}" is used by ${nodeIds.length} nodes: ${nodeIds.join(', ')}`, 
+                        createDataMetadata({ label, nodeCount: nodeIds.length, nodeIds }));
+                }
+            }
+        });
+        
+        return { duplicateLabels };
+    }
+    
+    /**
+     * Track which labels are used to detect duplicates
+     */
+    private trackLabelUsage(nodeId: string, label: string): void {
+        if (!nodeId || !label || label === nodeId) {
+            return; // Skip empty labels or self-references
+        }
+        
+        // Skip special case - numeric IDs used as labels
+        if (this.NODE_ID_REGEX.test(label) || label.startsWith(NUMERIC_ID_PREFIX)) {
+            return; // Don't track numeric IDs or empty labels
+        }
+        
+        // Ensure we're not trying to add an invalid nodeId
+        if (!this.isValidNumericId(nodeId)) {
+            logger.warn(`Attempted to track invalid node ID: ${nodeId} for label: ${label}`);
+            return;
+        }
+        
+        if (!this.labelToNodeIds.has(label)) {
+            // First time we're seeing this label - no duplication yet
+            this.labelToNodeIds.set(label, [nodeId]); 
+        } else {
+            // This label is used by multiple nodes - potential duplicate
+            const existingNodes = this.labelToNodeIds.get(label)!;
+            
+            // Only add if not already in the list
+            if (!existingNodes.includes(nodeId)) {
+                existingNodes.push(nodeId);
+                
+                // If this is the second node with this label, create unique versions for both
+                if (existingNodes.length === 2) {
+                    this.createUniqueLabels(label, existingNodes);
+                } else if (existingNodes.length > 2) {
+                    // For a new node with an already duplicated label
+                    this.createUniqueLabel(label, nodeId, existingNodes.length - 1);
+                }
+            }
+        }
+    }
+    
+    /**
+     * Create unique versions of a label for all nodes that use it
+     * @param baseLabel The original label
+     * @param nodeIds Array of node IDs using this label
+     */
+    private createUniqueLabels(baseLabel: string, nodeIds: string[]): void {
+        // Create a unique label for each node
+        nodeIds.forEach((nodeId, index) => {
+            this.createUniqueLabel(baseLabel, nodeId, index);
+        });
+    }
+    
+    /**
+     * Create a unique version of a label for a specific node
+     * @param baseLabel The original label
+     * @param nodeId Node ID
+     * @param index Uniqueness index (to create a suffix)
+     */
+    private createUniqueLabel(baseLabel: string, nodeId: string, index: number): void {
+        // Create unique label with index suffix
+        const uniqueLabel = `${baseLabel} (${index + 1})`;
+        
+        // Store in our uniqueness map
+        this.labelToUnique.set(`${baseLabel}:${nodeId}`, uniqueLabel);
+        
+        // Update the main node to label mapping
+        if (this.isValidNumericId(nodeId)) {
+            this.numericIdToLabel.set(nodeId, uniqueLabel);
+            logger.info(`Created unique label for node ${nodeId}: ${uniqueLabel}`);
+        }
+    }
+    
+    /**
+     * Determines the best label to use for a node using a simplified priority order
+     */
+    private determineBestLabel(node: any, fallbackToDefault: boolean = true): string {
+        let bestLabel = '';
+        // First try metadata.name as the canonical source of the filename without extension
+        if (node.data?.metadata?.name && typeof node.data.metadata.name === 'string' && 
+            node.data.metadata.name !== 'undefined') {
+            return node.data.metadata.name;
+        }
+        
+        // Next try explicitly provided label
+        if (typeof node.label === 'string' && node.label && 
+            node.label !== 'undefined' && !this.NODE_ID_REGEX.test(node.label)) {
+            return node.label;
+        }
+        
+        // Next try metadataId (which is typically the filename)
+        if (typeof node.metadataId === 'string' && node.metadataId && 
+            node.metadataId !== 'undefined' && !this.NODE_ID_REGEX.test(node.metadataId)) {
+            return node.metadataId;
+        }
+        
+        // If existing approaches failed and we should use a default
+        if (fallbackToDefault) {
+            // Always ensure uniqueness by creating a unique label using numeric ID as suffix
+            bestLabel = `${this.DEFAULT_LABEL_PREFIX}${node.id}`;
+            
+            // Log this default label creation as it should only happen rarely
+            if (Math.random() < 0.1) {
+                logger.debug(`Created default label for node ${node.id}: ${bestLabel}`);
+            }
+            
+            return bestLabel;
+        }
+        
+        // Absolute last resort: use the numeric ID itself
+        logger.debug(`Failed to determine label for node ${node.id}, using ID as fallback`);
+        return node.id;
+    }
+    
+    /**
+     * Force a label for a node, useful when a specific label must be assigned
+     */
+    public forceNodeLabel(nodeId: string, label: string): void {
+        if (!label || label === 'undefined' || label === 'null') {
+            // Don't set invalid labels
+            return;
+        }
+        
+        if (this.isValidNumericId(nodeId)) {
+            // Check if this label is already used by other nodes
+            const existingNodes = this.labelToNodeIds.get(label);
+            if (existingNodes && existingNodes.length > 0 && !existingNodes.includes(nodeId)) {
+                // This label is already used - store a unique version
+                this.createUniqueLabel(label, nodeId, existingNodes.length);
+                return;
+            }
+            
+            // Set the label and track its usage
+            this.numericIdToLabel.set(nodeId, label);
+            this.trackLabelUsage(nodeId, label);
+        }
+    }
+    
+    /**
+     * Get the label for a numeric node ID
+     */
+    public getLabel(numericId: string): string {
+        // Validate the node ID
+        if (!this.isValidNumericId(numericId)) {
+            return numericId; // If not a valid ID, just return it
+        }
+        
+        // Get the base label associated with this node ID
+        let label = this.numericIdToLabel.get(numericId);
+        
+        // Get the unique version of this label if it's a duplicate
+        if (label) {
+            const uniqueKey = `${label}:${numericId}`;
+            const uniqueLabel = this.labelToUnique.get(uniqueKey);
+            
+            if (uniqueLabel) {
+                return uniqueLabel; // Return the unique (deduplicated) version
+            }
+            
+            // If we have a valid label, use it
+            return label;
+        }
+        
+        // If no label exists, create a guaranteed unique one based on the numeric ID
+        const newLabel = `${NUMERIC_ID_PREFIX}${numericId}`;
+        
+        // Save this for future use
+        this.numericIdToLabel.set(numericId, newLabel);
+        
+        logger.info(`Generated new label for node ${numericId}: ${newLabel}`);
+        
+        return newLabel;
+    }
+    
+    /**
+     * Get all numeric node IDs that have been processed
+     * @returns Array of numeric node IDs
+     */
+    public getAllNodeIds(): string[] {
+        return Array.from(this.numericIdToLabel.keys());
+    }
+    
+    /**
+     * Set the label for a numeric node ID
+     */
+    public setLabel(numericId: string, label: string): void {
+        if (!numericId || !label) return;
+        this.numericIdToLabel.set(numericId, label);
+        this.trackLabelUsage(numericId, label);
+    }
+    
+    /**
+     * Get all nodes that use a specific label
+     */
+    public getNodesWithLabel(label: string): string[] {
+        return this.labelToNodeIds.get(label) || [];
+    }
+    
+    /**
+     * Check if a label is used by multiple nodes
+     */
+    public isDuplicateLabel(label: string): boolean {
+        const nodes = this.labelToNodeIds.get(label);
+        return !!nodes && nodes.length > 1;
+    }
+    
+    /**
+     * Get all duplicate labels
+     */
+    public getDuplicateLabels(): Map<string, string[]> {
+        const duplicates = new Map<string, string[]>();
+        this.labelToNodeIds.forEach((nodeIds, label) => {
+            if (nodeIds.length > 1 && !this.NODE_ID_REGEX.test(label) && label) {
+                duplicates.set(label, [...nodeIds]);
+            }
+        });
+        return duplicates;
+    }
+    
+    /**
+     * Reset all mappings
+     */
+    public reset(): void {
+        this.numericIdToLabel.clear();
+        this.labelToNodeIds.clear();
+        this.labelToUnique.clear();
+        logger.info('All node identity mappings reset');
+    }
+    
+    /**
+     * Dispose of the manager and clear all mappings
+     */
+    public dispose(): void {
+        this.reset();
+        this.labelToUnique.clear();
+        NodeIdentityManager.instance = null!;
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/node/identity/README.md b/client/rendering/node/identity/README.md
new file mode 100644
index 00000000..3df8a230
--- /dev/null
+++ b/client/rendering/node/identity/README.md
@@ -0,0 +1,57 @@
+# Node Identity Management System - Final Implementation
+
+This module provides a solution for the duplicate label issue in the node visualization system.
+
+## Problem Statement
+
+The system has three types of identifiers for nodes:
+1. **Numeric IDs**: Server-generated u16 indices (always numeric strings)
+2. **Metadata IDs**: Typically filenames without the .md extension
+3. **Labels**: Human-readable display names (often the same as metadata IDs)
+
+The issue occurs when:
+- Multiple nodes have the same label but different numeric IDs
+- Label resolution logic is inconsistent across different parts of the codebase
+- There's no centralized system to detect and handle duplicate labels
+
+## Solution Architecture
+
+The solution consists of two main components:
+
+### 1. NodeIdentityManager
+
+A focused class that:
+- Tracks relationships between numeric IDs and labels
+- Implements consistent label resolution logic
+- Detects and logs duplicate labels
+- Provides a single source of truth for node identity information
+
+
+### 3. Diagnostic Tools
+
+Utilities for testing and verifying the solution:
+- `nodeLabelDiagnostics.ts`: Tools for testing duplicate label detection
+- Browser console integration for runtime analysis
+
+## Implementation Details
+
+The implementation has been completed with:
+
+1. A completely refactored NodeManagerFacade that directly uses the NodeIdentityManager
+2. A simplified NodeIdentityManager focused on label management and duplicate detection
+3. Diagnostic tools for testing and verification
+
+
+```typescript
+// In NodeManagerFacade.ts
+// The NodeManagerFacade has been completely refactored to use:
+import { NodeIdentityManager } from './identity/NodeIdentityManager';
+```
+
+## Benefits
+
+- **Focused Solution**: Addresses the specific duplicate label issue
+- **Minimal Changes**: Can be added with just a few lines of code
+- **Enhanced Diagnostics**: Provides clear logging of duplicate labels
+- **Source of Truth**: Centralizes label management logic
+- **Progressive Adoption**: Start with just duplicate detection, expand as needed
\ No newline at end of file
diff --git a/client/rendering/node/instance/NodeInstanceManager.ts b/client/rendering/node/instance/NodeInstanceManager.ts
new file mode 100644
index 00000000..686ed743
--- /dev/null
+++ b/client/rendering/node/instance/NodeInstanceManager.ts
@@ -0,0 +1,786 @@
+import {
+    Scene,
+    InstancedMesh,
+    Matrix4,
+    Vector3,
+    Quaternion,
+    Color,
+    Camera,
+    Material
+} from 'three';
+import { NodeGeometryManager } from '../geometry/NodeGeometryManager';
+import { createLogger, createDataMetadata } from '../../../core/logger';
+import { SettingsStore } from '../../../state/SettingsStore';
+import { NodeSettings } from '../../../types/settings/base';
+import { scaleOps } from '../../../core/utils';
+import { Node } from '../../../core/types';
+import { debugState } from '../../../core/debugState';
+
+const logger = createLogger('NodeInstanceManager');
+
+// Constants for optimization
+const MAX_INSTANCES = 10000;
+const VISIBILITY_UPDATE_INTERVAL = 10; // frames
+const DEFAULT_FILE_SIZE = 1000; // 1KB default
+const MAX_FILE_SIZE = 10485760; // 10MB max for scaling
+
+// Reusable objects for matrix calculations
+const matrix = new Matrix4();
+const position = new Vector3();
+const quaternion = new Quaternion();
+const velocity = new Vector3();
+const scale = new Vector3();
+
+// Visibility states (using setRGB for proper initialization)
+const VISIBLE = new Color(0xffffff); // White/default color
+const SELECTED = new Color(0x00ffff); // Cyan color for selected nodes
+
+// Global registry for tracking instances
+interface InstanceInfo {
+    scene: Scene;
+    material: Material;
+    timestamp: number;
+}
+
+interface NodeUpdate {
+    id: string;
+    position: Vector3;  // Three.js Vector3
+    velocity?: Vector3; // Three.js Vector3
+    metadata?: {
+        name?: string;
+        lastModified?: number;
+        links?: string[];
+        references?: string[];
+        fileSize?: number;
+        hyperlinkCount?: number;
+    };
+}
+
+export class NodeInstanceManager {
+    private static instance: NodeInstanceManager | null = null;
+    private static instanceInfo: InstanceInfo | null = null;
+    private static instanceCount: number = 0;
+    private static readonly INSTANCE_TIMEOUT_MS = 5000; // 5 seconds timeout for stale instances
+    private scene: Scene;
+    private nodeInstances: InstancedMesh;
+    private geometryManager: NodeGeometryManager;
+    private nodeIndices: Map<string, number> = new Map();
+    private nodeIdToInstanceId: Map<string, number> = new Map();
+    private pendingUpdates: Set<number> = new Set();
+    private frameCount: number = 0;
+    private velocities: Map<number, Vector3> = new Map();
+    private lastUpdateTime: number = performance.now();
+    private settingsStore: SettingsStore;
+    private nodeSettings: NodeSettings;
+    private readonly MAX_POSITION = 1000.0; // Reasonable limit for graph visualization
+    private readonly MAX_VELOCITY = 0.5;    // Increased to allow more movement for simulation settling
+    private isReady: boolean = false;
+    private positionUpdateCount: number = 0;
+    private lastPositionLog: number = 0;
+    private instanceId: number;
+
+    private validateAndLogVector3(vec: Vector3, max: number, context: string, nodeId?: string): boolean {
+        const isValid = this.validateVector3(vec, max);
+        
+        // Always log validation failures to catch these issues
+        if (!isValid) {
+            logger.node('Vector3 validation failed', createDataMetadata({
+                nodeId,
+                component: context,
+                maxAllowed: max,
+                position: { x: vec.x, y: vec.y, z: vec.z },
+                invalidReason: !isFinite(vec.x) || !isFinite(vec.y) || !isFinite(vec.z) ? 
+                    'Non-finite values detected' : 
+                    isNaN(vec.x) || isNaN(vec.y) || isNaN(vec.z) ?
+                    'NaN values detected' :
+                    'Values exceed maximum bounds'
+            }));
+        }
+        
+        return isValid;
+    }
+
+    private validateVector3(vec: Vector3, max: number): boolean {
+        return !isNaN(vec.x) && !isNaN(vec.y) && !isNaN(vec.z) &&
+               isFinite(vec.x) && isFinite(vec.y) && isFinite(vec.z) &&
+               Math.abs(vec.x) <= max && Math.abs(vec.y) <= max && Math.abs(vec.z) <= max;
+    }
+
+    private validateMatrix4(mat: Matrix4, nodeId: string): boolean {
+        const elements = mat.elements;
+        for (let i = 0; i < 16; i++) {
+            if (!isFinite(elements[i]) || isNaN(elements[i])) {
+                if (debugState.isMatrixDebugEnabled()) {
+                    logger.matrix('Invalid matrix element detected', createDataMetadata({
+                        nodeId,
+                        elementIndex: i,
+                        value: elements[i],
+                        matrix: elements.join(',')
+                    }));
+                }
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private constructor(scene: Scene, material: Material) {
+        this.instanceId = ++NodeInstanceManager.instanceCount;
+        logger.info(`Creating NodeInstanceManager instance #${this.instanceId}`);
+        this.scene = scene;
+        this.geometryManager = NodeGeometryManager.getInstance();
+        this.settingsStore = SettingsStore.getInstance();
+        
+        // Wait for settings to be fully initialized
+        if (!this.settingsStore.isInitialized()) {
+            if (debugState.isEnabled()) {
+                logger.warn('SettingsStore not initialized, using defaults');
+            }
+            this.nodeSettings = this.settingsStore.get('visualization.nodes') as NodeSettings;
+        } else {
+            this.nodeSettings = this.settingsStore.get('visualization.nodes') as NodeSettings;
+        }
+
+        // Initialize InstancedMesh with high-detail geometry
+        const initialGeometry = this.geometryManager.getGeometryForDistance(0);
+        
+        // Validate initial geometry
+        if (debugState.isNodeDebugEnabled()) {
+            const posAttr = initialGeometry.getAttribute('position');
+            const normalAttr = initialGeometry.getAttribute('normal');
+            logger.node('Validating initial geometry', createDataMetadata({
+                vertexCount: posAttr?.count ?? 0,
+                attributes: `position:${!!posAttr},normal:${!!normalAttr}`
+            }));
+        }
+
+        this.nodeInstances = new InstancedMesh(initialGeometry, material, MAX_INSTANCES);
+        
+        // Validate initial instance matrix
+        const initialMatrix = new Matrix4();
+        this.validateMatrix4(initialMatrix, 'initial');
+        
+        this.nodeInstances.count = 0; // Start with 0 visible instances
+        this.nodeInstances.frustumCulled = true;
+        this.nodeInstances.layers.enable(0); // Enable default layer
+
+        // Add to scene
+        this.scene.add(this.nodeInstances);
+        if (debugState.isEnabled()) {
+            logger.info(`Initialized NodeInstanceManager instance #${this.instanceId}`);
+        }
+
+        // Subscribe to settings changes
+        this.settingsStore.subscribe('visualization.nodes', (_: string, settings: any) => {
+            if (settings && typeof settings === 'object') {
+                this.nodeSettings = settings as NodeSettings;
+                this.updateAllNodeScales();
+            }
+        });
+
+        // Mark as ready after initialization
+        this.isReady = true;
+    }
+    
+    /**
+     * Check if the NodeInstanceManager is fully initialized
+     */
+    public isInitialized(): boolean {
+        return this.isReady;
+    }
+
+    public static getInstance(scene: Scene, material: Material): NodeInstanceManager {
+        // Check if we already have an instance
+        if (NodeInstanceManager.instance && NodeInstanceManager.instance.isReady) {
+            // Check if the instance is for the same scene and material
+            if (NodeInstanceManager.instanceInfo && 
+                NodeInstanceManager.instanceInfo.scene === scene && 
+                NodeInstanceManager.instanceInfo.material === material) {
+                
+                // Update timestamp to indicate this instance is still in use
+                if (NodeInstanceManager.instanceInfo) {
+                    NodeInstanceManager.instanceInfo.timestamp = Date.now();
+                }
+                
+                return NodeInstanceManager.instance;
+            } else {
+                // Different scene or material - dispose the old instance
+                logger.warn('Disposing existing NodeInstanceManager for different scene/material');
+                NodeInstanceManager.instance.dispose();
+                NodeInstanceManager.instance = null;
+                NodeInstanceManager.instanceInfo = null;
+            }
+        } else if (NodeInstanceManager.instance && !NodeInstanceManager.instance.isReady) {
+            // Instance exists but is not ready - check if it's stale
+            if (NodeInstanceManager.instanceInfo && 
+                Date.now() - NodeInstanceManager.instanceInfo.timestamp > NodeInstanceManager.INSTANCE_TIMEOUT_MS) {
+                
+                // Stale instance - dispose and create a new one
+                logger.warn('Disposing stale NodeInstanceManager instance');
+                NodeInstanceManager.instance.dispose();
+                NodeInstanceManager.instance = null;
+                NodeInstanceManager.instanceInfo = null;
+            }
+        }
+        
+        // Create a new instance if needed
+        if (!NodeInstanceManager.instance) {
+            NodeInstanceManager.instance = new NodeInstanceManager(scene, material);
+            NodeInstanceManager.instanceInfo = {
+                scene,
+                material,
+                timestamp: Date.now()
+            };
+        }
+        return NodeInstanceManager.instance;
+    }
+
+    private getNodeScale(node: Node): number {
+        if (debugState.isNodeDebugEnabled()) {
+            logger.node('Calculating node scale', createDataMetadata({
+                nodeId: node.id,
+                metadata: node.data.metadata
+            }));
+        }
+
+        let normalizedSize = 0;
+        const [minSize = 1, maxSize = 5] = this.nodeSettings?.sizeRange || [1, 5];
+
+        if (!this.nodeSettings) {
+            return 1.0; // Default scale if settings not available
+        }
+
+        try {
+            const fileSize = node.data.metadata?.fileSize ?? DEFAULT_FILE_SIZE;
+            // Clamp file size to reasonable bounds
+            const clampedSize = Math.min(Math.max(fileSize, 0), MAX_FILE_SIZE);
+            // Calculate normalized size (0-1)
+            normalizedSize = clampedSize / MAX_FILE_SIZE;
+        } catch (error) {
+            if (debugState.isNodeDebugEnabled()) {
+                logger.node('Error calculating normalized size', createDataMetadata({
+                    nodeId: node.id,
+                    error: error instanceof Error ? error.message : String(error)
+                }));
+            }
+        }
+        
+        // Map the normalized size to the configured size range
+        const scale = scaleOps.mapRange(normalizedSize, 0, 1, minSize, maxSize);
+        
+        // Ensure scale is valid
+        return isFinite(scale) && !isNaN(scale) ? scale : 1.0;
+    }
+
+    private updateAllNodeScales(): void {
+        if (!this.isReady) {
+            if (debugState.isEnabled()) {
+                logger.warn('Attempted to update scales before initialization');
+            }
+            return;
+        }
+
+        // Update all existing nodes with new scale based on current settings
+        for (let i = 0; i < this.nodeInstances.count; i++) {
+            this.nodeInstances.getMatrixAt(i, matrix);
+            matrix.decompose(position, quaternion, scale);
+            
+            // Get the node ID for this instance
+            const nodeId = this.getNodeId(i);
+            if (!nodeId) continue;
+            
+            // Find the node data
+            const node = Array.from(this.nodeIndices.entries())
+                .find(([_, idx]) => idx === i)?.[0];
+            if (!node) continue;
+
+            // Calculate new scale
+            const newScale = this.getNodeScale({ 
+                id: nodeId, 
+                data: { 
+                    position: position.clone(),
+                    velocity: new Vector3(0, 0, 0)
+                }
+            });
+            scale.set(newScale, newScale, newScale);
+            
+            matrix.compose(position, quaternion, scale);
+            this.nodeInstances.setMatrixAt(i, matrix);
+            this.pendingUpdates.add(i);
+        }
+        
+        if (this.pendingUpdates.size > 0) {
+            this.nodeInstances.instanceMatrix.needsUpdate = true;
+            this.pendingUpdates.clear();
+        }
+    }
+
+    public updateNodePositions(updates: NodeUpdate[]): void {
+        if (!this.isReady) {
+            if (debugState.isEnabled()) {
+                logger.warn('Attempted to update positions before initialization');
+            }
+            return;
+        }
+
+        this.positionUpdateCount++;
+        
+        // Log information about the updates being received
+        const currentTime = performance.now();
+        const logInterval = 1000; // Log at most every second
+        
+        if (currentTime - this.lastPositionLog > logInterval || updates.length <= 5) {
+            this.lastPositionLog = currentTime;
+            // Enhanced logging for better diagnostics
+            logger.info('Node position update batch received', createDataMetadata({
+                updateCount: this.positionUpdateCount,
+                batchSize: updates.length,
+                sample: updates.slice(0, Math.min(5, updates.length)).map(u => ({ 
+                    id: u.id, 
+                    pos: { 
+                        x: u.position.x.toFixed(3), 
+                        y: u.position.y.toFixed(3), 
+                        z: u.position.z.toFixed(3) 
+                    },
+                    vel: u.velocity ? { 
+                        x: u.velocity.x.toFixed(3), 
+                        y: u.velocity.y.toFixed(3), 
+                        z: u.velocity.z.toFixed(3) 
+                    } : 'none'
+                }))
+            }));
+        }
+
+        let updatedCount = 0;
+        updates.forEach(update => {
+            const index = this.nodeIndices.get(update.id);
+            
+            // CRITICAL FIX: Use server position directly with minimal validation
+            // Just copy the position from the update without excessive validation
+            position.copy(update.position);
+
+            // Only check for NaN or infinite values in position, but don't aggressively clamp
+            if (isNaN(position.x) || !isFinite(position.x)) position.x = 0;
+            if (isNaN(position.y) || !isFinite(position.y)) position.y = 0;
+            if (isNaN(position.z) || !isFinite(position.z)) position.z = 0;
+            
+            // Handle velocity with less clamping to allow faster settling
+            if (update.velocity) {
+                velocity.copy(update.velocity);
+                
+                // Only fix NaN/infinite values in velocity, but don't clamp magnitude
+                if (isNaN(velocity.x) || !isFinite(velocity.x) || 
+                    isNaN(velocity.y) || !isFinite(velocity.y) ||
+                    isNaN(velocity.z) || !isFinite(velocity.z)) {
+                    logger.warn('Invalid velocity value detected', createDataMetadata({
+                            nodeId: update.id, 
+                            originalVelocity: { x: velocity.x, y: velocity.y, z: velocity.z }
+                    }));
+                    
+                    // Only fix NaN values, not clamp magnitudes
+                    if (isNaN(velocity.x) || !isFinite(velocity.x)) velocity.x = 0;
+                    if (isNaN(velocity.y) || !isFinite(velocity.y)) velocity.y = 0;
+                    if (isNaN(velocity.z) || !isFinite(velocity.z)) velocity.z = 0;
+                }
+                
+                // Log velocity data for the first few nodes to help debug node movement
+                if (index === undefined && debugState.isPhysicsDebugEnabled()) {
+                    logger.physics('New node with velocity', createDataMetadata({
+                        nodeId: update.id,
+                        velocity: velocity ? { 
+                            x: velocity.x.toFixed(3), 
+                            y: velocity.y.toFixed(3), 
+                            z: velocity.z.toFixed(3) 
+                        } : 'none'
+                    }));
+                }
+            }
+
+            if (index === undefined) {
+                // New node
+                const newIndex = this.nodeInstances.count;
+                if (newIndex < MAX_INSTANCES) {
+                    this.nodeIndices.set(update.id, newIndex);
+                    this.nodeIdToInstanceId.set(update.id, newIndex);
+                    this.nodeInstances.count++;
+
+                    // Calculate scale based on node properties
+                    const scaleValue = this.getNodeScale({
+                        id: update.id,
+                        data: {
+                            position: position.clone(),
+                            velocity: new Vector3(0, 0, 0),
+                            metadata: update.metadata
+                        }
+                    });
+                    scale.set(scaleValue, scaleValue, scaleValue);
+                    
+                    if (update.velocity && this.validateVector3(update.velocity, this.MAX_VELOCITY)) {
+                        const vel = update.velocity.clone(); // Using Three.js Vector3 clone
+                        this.velocities.set(newIndex, vel);
+                    }
+                    
+                    matrix.compose(position, quaternion, scale);
+                    
+                    // Validate matrix before setting
+                    if (!this.validateMatrix4(matrix, update.id)) {
+                        if (debugState.isMatrixDebugEnabled()) {
+                            logger.matrix('Invalid matrix after composition', createDataMetadata({
+                                nodeId: update.id,
+                                position: {
+                                    x: position.x,
+                                    y: position.y,
+                                    z: position.z
+                                },
+                                scale: {
+                                    x: scale.x, y: scale.y, z: scale.z
+                                }
+                            }));
+                        }
+                        return;
+                    }
+                    
+                    this.nodeInstances.setMatrixAt(newIndex, matrix);
+                    this.nodeInstances.setColorAt(newIndex, VISIBLE);
+                    
+                    this.pendingUpdates.add(newIndex);
+                    updatedCount++;
+                } else {
+                    if (debugState.isEnabled()) {
+                        logger.warn('Maximum instance count reached, cannot add more nodes');
+                    }
+                }
+                return;
+            }
+
+            // Update existing node
+            if (update.velocity && this.validateVector3(update.velocity, this.MAX_VELOCITY)) {
+                this.velocities.set(index, update.velocity.clone());
+                
+                // Add detailed velocity logging to debug physics
+                if (debugState.isPhysicsDebugEnabled()) {
+                    logger.physics('Updated velocity for node', createDataMetadata({
+                        nodeId: update.id,
+                        velocity: { 
+                            x: update.velocity.x.toFixed(3), 
+                            y: update.velocity.y.toFixed(3), 
+                            z: update.velocity.z.toFixed(3) 
+                        }
+                    }));
+                }
+            }
+            
+            // Calculate scale based on node properties
+            const scaleValue = this.getNodeScale({
+                id: update.id,
+                data: {
+                    position: position.clone(),
+                    velocity: new Vector3(0, 0, 0),
+                    metadata: update.metadata
+                }
+            });
+            scale.set(scaleValue, scaleValue, scaleValue);
+            
+            matrix.compose(position, quaternion, scale);
+            
+            // Validate matrix before setting
+            if (!this.validateMatrix4(matrix, update.id)) {
+                if (debugState.isMatrixDebugEnabled()) {
+                    logger.matrix('Invalid matrix after composition', createDataMetadata({
+                        nodeId: update.id,
+                        position: {
+                            x: position.x,
+                            y: position.y,
+                            z: position.z
+                        },
+                        scale: {
+                            x: scale.x, y: scale.y, z: scale.z
+                        }
+                    }));
+                }
+                return;
+            }
+            
+            this.nodeInstances.setMatrixAt(index, matrix);
+            this.pendingUpdates.add(index);
+            updatedCount++;
+        });
+
+        if (this.pendingUpdates.size > 0) {
+            this.nodeInstances.instanceMatrix.needsUpdate = true;
+            
+            // Log a summary of what we updated
+            if (updatedCount > 0) {
+                logger.info('Node position update complete', createDataMetadata({
+                    updatedCount,
+                    pendingUpdates: this.pendingUpdates.size,
+                    totalNodes: this.nodeInstances.count,
+                    activeVelocityTracking: this.velocities.size
+                }));
+            }
+            this.pendingUpdates.clear();
+        }
+    }
+
+    public update(camera: Camera, passedDeltaTime?: number): void {
+        if (!this.isReady) return;
+
+        // Validate deltaTime
+        if (passedDeltaTime !== undefined && 
+            (!isFinite(passedDeltaTime) || isNaN(passedDeltaTime) || passedDeltaTime <= 0)) {
+            if (debugState.isPhysicsDebugEnabled()) {
+                logger.physics('Invalid deltaTime provided', createDataMetadata({ deltaTime: passedDeltaTime }));
+            }
+            return;
+        }
+
+        this.frameCount++;
+        
+        // Update positions based on velocity
+        const currentTime = performance.now(); 
+        
+        // Calculate and cap deltaTime to prevent large jumps
+        const rawDeltaTime = (currentTime - this.lastUpdateTime) / 1000; // Convert to seconds
+        const deltaTime = passedDeltaTime !== undefined ? passedDeltaTime : Math.min(0.1, rawDeltaTime);
+        
+        // Log unusually large deltaTime values that could cause physics instability
+        if (deltaTime > 0.05 && this.velocities.size > 0 && debugState.isPhysicsDebugEnabled()) {
+            logger.physics('Large delta time detected', createDataMetadata({
+                deltaTime: deltaTime.toFixed(3),
+                velocityCount: this.velocities.size,
+                timeSinceLastUpdate: rawDeltaTime.toFixed(3)
+            }));
+        }
+        
+        this.lastUpdateTime = currentTime;
+
+        if (this.velocities.size > 0 && debugState.isPhysicsDebugEnabled()) {
+            logger.physics('Physics update', createDataMetadata({
+                deltaTime,
+                velocityCount: this.velocities.size
+            }));
+        }
+
+        // Update positions based on velocities
+        this.velocities.forEach((nodeVelocity, index) => {
+            if (nodeVelocity.lengthSq() > 0) {
+                // Only process nodes with non-zero velocity
+                this.nodeInstances.getMatrixAt(index, matrix);
+                matrix.decompose(position, quaternion, scale);
+                
+                // Debug logging for position before velocity update
+                if (index === 0 && debugState.isPhysicsDebugEnabled()) {
+                    logger.physics('Position before velocity update', createDataMetadata({
+                        nodeId: this.getNodeId(index) || 'unknown',
+                        position: { x: position.x.toFixed(3), y: position.y.toFixed(3), z: position.z.toFixed(3) },
+                        velocity: { x: nodeVelocity.x.toFixed(3), y: nodeVelocity.y.toFixed(3), z: nodeVelocity.z.toFixed(3) },
+                        deltaTime: deltaTime.toFixed(3)
+                    }));
+                }
+                
+                // Apply velocity
+                velocity.copy(nodeVelocity).multiplyScalar(deltaTime);
+                position.add(velocity);
+
+                // Special Z-axis stabilization to prevent depth drift
+                // Apply extra damping to z-component
+                if (Math.abs(position.z) > 3.0) {
+                    position.z *= 0.98; // Gentle pull toward origin on z-axis
+                    
+                    // Also dampen z velocity to prevent oscillation
+                    if (nodeVelocity.z !== 0) {
+                        nodeVelocity.z *= 0.9; // Stronger damping on z velocity
+                    }
+                }
+                
+                // Debug logging for position after velocity update for first node
+                if (index === 0 && debugState.isPhysicsDebugEnabled()) {
+                    logger.physics('Position after velocity update', createDataMetadata({
+                        nodeId: this.getNodeId(index) || 'unknown',
+                        newPosition: { x: position.x.toFixed(3), y: position.y.toFixed(3), z: position.z.toFixed(3) },
+                        appliedDelta: { x: velocity.x.toFixed(3), y: velocity.y.toFixed(3), z: velocity.z.toFixed(3) }
+                    }));
+                }
+
+                // Validate position after velocity update
+                if (!this.validateAndLogVector3(position, this.MAX_POSITION, 'physics-update')) {
+                    if (debugState.isPhysicsDebugEnabled()) {
+                        logger.physics('Invalid position after velocity update', createDataMetadata({
+                            nodeId: this.getNodeId(index),
+                            position: {
+                                x: position.x,
+                                y: position.y,
+                                z: position.z
+                            },
+                            velocity: {
+                                x: velocity.x, y: velocity.y, z: velocity.z
+                            }
+                        }));
+                    }
+                    // Extract position from matrix and reset
+                    position.setFromMatrixPosition(matrix);
+                }                
+                
+                // Update matrix
+                matrix.compose(position, quaternion, scale);
+                
+                // Validate matrix before setting
+                if (!this.validateMatrix4(matrix, this.getNodeId(index) || 'unknown')) {
+                    return;
+                }
+                
+                this.nodeInstances.setMatrixAt(index, matrix);
+                this.pendingUpdates.add(index);
+            }
+        });
+
+        // Update visibility and LOD every N frames
+        if (this.frameCount % VISIBILITY_UPDATE_INTERVAL === 0) {
+            this.updateVisibilityAndLOD(camera);
+        }
+
+        if (this.pendingUpdates.size > 0) {
+            this.nodeInstances.instanceMatrix.needsUpdate = true;
+            this.pendingUpdates.clear();
+        }
+    }
+    
+    /**
+     * Diagnostic function to log current node positions
+     */
+    public logNodePositions(): void {
+        if (!this.isReady || this.nodeIndices.size === 0) return;
+        
+        const sampleNodes = Array.from(this.nodeIndices.entries()).slice(0, 5);
+        const positions = sampleNodes.map(([id, _]) => ({ id, position: this.getNodePosition(id) }));
+        logger.info('Current node positions:', createDataMetadata({ positions }));
+    }
+
+    private updateVisibilityAndLOD(camera: Camera): void {
+        if (!this.isReady) return;
+
+        const cameraPosition = camera.position;
+        
+        // Check each instance
+        for (let i = 0; i < this.nodeInstances.count; i++) {
+            this.nodeInstances.getMatrixAt(i, matrix);
+            position.setFromMatrixPosition(matrix);
+            
+            const distance = position.distanceTo(cameraPosition);
+            
+            // Update geometry based on distance
+            void this.geometryManager.getGeometryForDistance(distance);
+
+            // Always keep nodes visible regardless of distance
+            // Just update the LOD level without making them invisible
+            this.nodeInstances.setColorAt(i, VISIBLE);
+        }
+
+        // Ensure updates are applied
+        if (this.nodeInstances.instanceColor) {
+            this.nodeInstances.instanceColor.needsUpdate = true;
+        }
+    }
+
+    public dispose(): void {
+        if (this.nodeInstances) {
+            this.nodeInstances.geometry.dispose();
+            this.scene.remove(this.nodeInstances);
+        }
+        this.nodeIndices.clear();
+        this.pendingUpdates.clear();
+        this.nodeIdToInstanceId.clear();
+        this.velocities.clear();
+        this.isReady = false;
+        
+        // Only clear the static instance if it's this instance
+        if (NodeInstanceManager.instance === this) {
+            NodeInstanceManager.instance = null;
+            NodeInstanceManager.instanceInfo = null;
+        }
+        
+        if (debugState.isEnabled()) {
+            logger.info(`Disposed NodeInstanceManager instance #${this.instanceId}`);
+        }
+    }
+
+    public getInstanceMesh(): InstancedMesh {
+        return this.nodeInstances;
+    }
+
+    public getNodeId(index: number): string | undefined {
+        return Array.from(this.nodeIndices.entries())
+            .find(([_, idx]) => idx === index)?.[0];
+    }
+
+    public getNodePosition(nodeId: string): Vector3 | undefined {
+        const index = this.nodeIndices.get(nodeId);
+        if (index !== undefined) {
+            this.nodeInstances.getMatrixAt(index, matrix);
+            const positionVec = new Vector3();
+            positionVec.setFromMatrixPosition(matrix);
+            return positionVec;
+        }
+        return undefined;
+    }
+    
+    public getInstanceId(nodeId: string): number | undefined {
+        return this.nodeIdToInstanceId.get(nodeId);
+    }
+    
+    /**
+     * Set visual state of a node to indicate selection
+     * @param nodeId ID of the node to update
+     * @param selected Whether the node is selected
+     * @returns true if the update was successful, false otherwise
+     */
+    public setNodeSelectedState(nodeId: string, selected: boolean): boolean {
+        const index = this.nodeIndices.get(nodeId);
+        if (index === undefined) {
+            if (debugState.isNodeDebugEnabled()) {
+                logger.node('Cannot set selection state for node', createDataMetadata({
+                    nodeId,
+                    reason: 'Node index not found'
+                }));
+            }
+            return false;
+        }
+
+        // Get current node matrix
+        this.nodeInstances.getMatrixAt(index, matrix);
+        matrix.decompose(position, quaternion, scale);
+
+        // Apply visual changes based on selection state
+        if (selected) {
+            // Increase scale for selected nodes
+            const selectionScale = 1.2; // 20% larger when selected
+            scale.multiplyScalar(selectionScale);
+            
+            // Apply selection color if instance color exists
+            if (this.nodeInstances.instanceColor) {
+                this.nodeInstances.setColorAt(index, SELECTED);
+                this.nodeInstances.instanceColor.needsUpdate = true;
+            }
+        } else {
+            // Calculate normal scale based on node properties
+            const normalScale = this.getNodeScale({ 
+                id: nodeId, 
+                data: { position: position.clone(), velocity: new Vector3(0, 0, 0) }
+            });
+            scale.set(normalScale, normalScale, normalScale);
+            
+            // Reset color
+            if (this.nodeInstances.instanceColor) {
+                this.nodeInstances.setColorAt(index, VISIBLE);
+                this.nodeInstances.instanceColor.needsUpdate = true;
+            }
+        }
+        
+        // Update matrix with new scale/position
+        matrix.compose(position, quaternion, scale);
+        this.nodeInstances.setMatrixAt(index, matrix);
+        this.nodeInstances.instanceMatrix.needsUpdate = true;
+        
+        return true;
+    }
+}
diff --git a/client/rendering/node/interaction/NodeInteractionManager.ts b/client/rendering/node/interaction/NodeInteractionManager.ts
new file mode 100644
index 00000000..c205e7c8
--- /dev/null
+++ b/client/rendering/node/interaction/NodeInteractionManager.ts
@@ -0,0 +1,530 @@
+import {
+    InstancedMesh,
+    Vector3,
+    Vector2,
+    Matrix4,
+    Raycaster,
+    Camera,
+} from 'three';
+import { XRHandWithHaptics, HapticActuator } from '../../../types/xr';
+import { NodeInstanceManager } from '../instance/NodeInstanceManager'; 
+import { graphDataManager } from '../../../state/graphData';
+import { createLogger, createErrorMetadata, createDataMetadata } from '../../../core/logger';
+import { WebSocketService } from '../../../websocket/websocketService';
+import { SceneManager } from '../../scene';
+
+const logger = createLogger('NodeInteractionManager');
+
+export class NodeInteractionManager {
+    private static instance: NodeInteractionManager;
+    private instanceMesh: InstancedMesh;
+    private tempMatrix: Matrix4 = new Matrix4();
+    private readonly interactionRadius: number = 0.1; // 10cm interaction radius
+    private readonly HAPTIC_STRENGTH = 0.5; // 50% intensity
+    private hapticActuators: HapticActuator[] | null = null;
+    private webSocketService: WebSocketService;
+    
+    // Desktop mode properties
+    private canvas: HTMLCanvasElement | null = null;
+    private camera: Camera | null = null;
+    private raycaster: Raycaster = new Raycaster();
+    private mouse: Vector2 = new Vector2();
+    private selectedNodeId: string | null = null;
+    private isDragging: boolean = false;
+    private dragPlaneNormal: Vector3 = new Vector3();
+    private dragPlaneConstant: number = 0;
+    private dragOffset: Vector3 = new Vector3();
+    private lastUpdateTime: number = 0;
+    private updateThrottleMs: number = 100; // throttle updates to 10fps
+    private nodeInstanceManager: NodeInstanceManager | null = null;
+    private sceneManager: SceneManager | null = null;
+    
+    private constructor(instanceMesh: InstancedMesh) {
+        this.instanceMesh = instanceMesh;
+        this.webSocketService = WebSocketService.getInstance();
+        
+        // Try to get the NodeInstanceManager - this may be initialized later
+        try {
+            // This might fail initially if dependencies aren't ready yet
+            this.nodeInstanceManager = null;
+        } catch(e) {
+            logger.warn('NodeInstanceManager not available at construction time');
+        }
+    }
+
+    public static getInstance(instanceMesh: InstancedMesh): NodeInteractionManager {
+        if (!NodeInteractionManager.instance) {
+            NodeInteractionManager.instance = new NodeInteractionManager(instanceMesh);
+        }
+        return NodeInteractionManager.instance;
+    }
+    
+    /**
+     * Set the node instance manager reference
+     * This is needed because of initialization order issues
+     */
+    public setNodeInstanceManager(manager: NodeInstanceManager): void {
+        this.nodeInstanceManager = manager;
+        logger.info('NodeInstanceManager set');
+    }
+
+    /**
+     * Initialize desktop mode interactions
+     * @param canvas The canvas element for event binding
+     * @param camera The camera for raycasting
+     */
+    public initializeDesktopInteraction(canvas: HTMLCanvasElement, camera: Camera): void {
+        this.canvas = canvas;
+        this.camera = camera;
+        
+        // Add event listeners for desktop interactions
+        canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
+        canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
+        canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
+        canvas.addEventListener('click', this.handleClick.bind(this));
+        canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));
+        
+        // Get the SceneManager instance
+        try {
+            this.sceneManager = SceneManager.getInstance(canvas);
+        } catch(e) {
+            logger.warn('Failed to get SceneManager instance', createErrorMetadata(e));
+        }
+        
+        logger.info('Desktop interaction initialized');
+    }
+
+    /**
+     * Handle XR hand interaction
+     * @param hand XR hand data with haptic feedback
+     */
+    public handleHandInteraction(hand: XRHandWithHaptics): void {
+        if (!this.instanceMesh) return;
+
+        // Store haptic feedback actuator for later use
+        if (hand.hapticActuators && !this.hapticActuators) {
+            this.hapticActuators = hand.hapticActuators;
+        }
+
+        // Get hand joint positions
+        const indexTip = hand.hand.joints['index-finger-tip'];
+        if (!indexTip) return;
+
+        // Check for node intersection
+        const intersectedIndex = this.getIntersectedNodeIndex(indexTip.position);
+        if (intersectedIndex !== -1) {
+            this.handleNodeHover(intersectedIndex);
+        }
+    }
+
+    /**
+     * Get the index of the node closest to the given position
+     * @param position Position to check
+     * @returns Instance index of the closest node, or -1 if none found
+     */
+    public getIntersectedNodeIndex(position: Vector3): number {
+        if (!this.instanceMesh) return -1;
+
+        let closestIndex = -1;
+        let closestDistance = this.interactionRadius;
+
+        // Check each instance
+        for (let i = 0; i < this.instanceMesh.count; i++) {
+            // Get instance matrix
+            this.instanceMesh.getMatrixAt(i, this.tempMatrix);
+            const instancePosition = new Vector3().setFromMatrixPosition(this.tempMatrix);
+
+            // Check distance
+            const distance = position.distanceTo(instancePosition);
+            if (distance < closestDistance) {
+                closestDistance = distance;
+                closestIndex = i;
+            }
+        }
+
+        return closestIndex;
+    }
+    
+    /**
+     * Convert mouse event to normalized device coordinates
+     * @param event Mouse event
+     */
+    private updateMouseCoordinates(event: MouseEvent): void {
+        if (!this.canvas) return;
+
+        const rect = this.canvas.getBoundingClientRect();
+        this.mouse.x = ((event.clientX - rect.left) / this.canvas.clientWidth) * 2 - 1;
+        this.mouse.y = -((event.clientY - rect.top) / this.canvas.clientHeight) * 2 + 1;
+    }
+    
+    /**
+     * Perform raycasting to detect nodes
+     * @returns Intersection information or null if no intersection
+     */
+    private getIntersectedNodeFromRaycast(): { instanceIndex: number, point: Vector3 } | null {
+        if (!this.camera || !this.instanceMesh) return null;
+
+        // Set up raycaster with the current mouse position
+        this.raycaster.setFromCamera(this.mouse, this.camera);
+        
+        // Perform raycasting against the instanced mesh
+        const intersects = this.raycaster.intersectObject(this.instanceMesh);
+        
+        if (intersects.length > 0) {
+            // Check if we have an instanced intersection
+            const instanceId = (intersects[0] as any).instanceId;
+            if (typeof instanceId === 'number') {
+                return {
+                    instanceIndex: instanceId,
+                    point: intersects[0].point.clone()
+                };
+            }
+        }
+        
+        return null;
+    }
+
+    /**
+     * Handle mouse down event for node interaction
+     * @param event Mouse event
+     */
+    private handleMouseDown(event: MouseEvent): void {
+        if (!this.camera || !this.nodeInstanceManager) return;
+
+        this.updateMouseCoordinates(event);
+        
+        const intersection = this.getIntersectedNodeFromRaycast();
+        if (intersection) {
+            const nodeId = this.nodeInstanceManager.getNodeId(intersection.instanceIndex);
+            if (nodeId) {
+                // Select the node
+                this.selectNode(nodeId);
+                
+                // Start drag operation
+                this.startDrag(nodeId, intersection.point);
+                
+                // Prevent default to avoid text selection during drag
+                event.preventDefault();
+            }
+        } else {
+            // Clicked on empty space, deselect current node
+            this.deselectNode();
+        }
+    }
+
+    /**
+     * Handle mouse move event for dragging
+     * @param event Mouse event
+     */
+    private handleMouseMove(event: MouseEvent): void {
+        if (!this.camera || !this.isDragging || !this.selectedNodeId) return;
+
+        this.updateMouseCoordinates(event);
+        this.updateDrag();
+    }
+
+    /**
+     * Handle mouse up event to end drag
+     * @param event Mouse event
+     */
+    private handleMouseUp(_event: MouseEvent): void {
+        if (this.isDragging && this.selectedNodeId) {
+            this.endDrag();
+        }
+    }
+
+    /**
+     * Handle single click event for selection
+     * @param event Mouse event
+     */
+    private handleClick(event: MouseEvent): void {
+        // Only handle click if we're not ending a drag
+        if (this.isDragging) return;
+
+        this.updateMouseCoordinates(event);
+        
+        const intersection = this.getIntersectedNodeFromRaycast();
+        if (intersection) {
+            const nodeId = this.nodeInstanceManager?.getNodeId(intersection.instanceIndex);
+            if (nodeId) {
+                this.selectNode(nodeId);
+            }
+        } else {
+            // Clicked on empty space, deselect current node
+            this.deselectNode();
+        }
+    }
+
+    /**
+     * Handle double click event for link out
+     * @param event Mouse event
+     */
+    private handleDoubleClick(event: MouseEvent): void {
+        this.updateMouseCoordinates(event);
+        
+        const intersection = this.getIntersectedNodeFromRaycast();
+        if (intersection) {
+            const nodeId = this.nodeInstanceManager?.getNodeId(intersection.instanceIndex);
+            if (nodeId) {
+                this.linkOut(nodeId);
+            }
+        }
+    }
+    
+    /**
+     * Select a node and update its visual state
+     * @param nodeId ID of the node to select
+     */
+    private selectNode(nodeId: string): void {
+        if (this.selectedNodeId === nodeId) return;
+        
+        // Deselect previous node if any
+        if (this.selectedNodeId) {
+            this.setNodeSelectedState(this.selectedNodeId, false);
+        }
+        
+        // Select the new node
+        this.selectedNodeId = nodeId;
+        this.setNodeSelectedState(nodeId, true);
+        
+        logger.info(`Selected node: ${nodeId}`);
+    }
+
+    /**
+     * Deselect the current node
+     */
+    private deselectNode(): void {
+        if (!this.selectedNodeId) return;
+        
+        this.setNodeSelectedState(this.selectedNodeId, false);
+        this.selectedNodeId = null;
+    }
+
+    /**
+     * Set the selection state of a node
+     * @param nodeId ID of the node
+     * @param selected Whether the node is selected
+     */
+    private setNodeSelectedState(nodeId: string, selected: boolean): void {
+        if (!this.nodeInstanceManager) return;
+        
+        // Use the NodeInstanceManager's implementation
+        this.nodeInstanceManager.setNodeSelectedState(nodeId, selected);
+    }
+
+    /**
+     * Start dragging a node
+     * @param nodeId ID of the node to drag
+     * @param intersectionPoint Intersection point on the node
+     */
+    private startDrag(nodeId: string, intersectionPoint: Vector3): void {
+        if (!this.camera || !this.nodeInstanceManager) return;
+
+        this.isDragging = true;
+
+        // Disable orbit controls while dragging to lock the viewpoint
+        if (this.sceneManager) {
+            const controls = this.sceneManager.getControls();
+            controls.enabled = false;
+            logger.info('Orbit controls disabled for dragging');
+        }
+        
+        // Get the node's current position
+        const nodePosition = this.getNodePosition(nodeId);
+        if (!nodePosition) {
+            this.isDragging = false;
+            return;
+        }
+        
+        // Set up a plane perpendicular to the camera for dragging
+        const cameraMatrix = this.camera.matrixWorld.elements;
+        const lookVector = new Vector3(-cameraMatrix[8], -cameraMatrix[9], -cameraMatrix[10]).normalize();
+        
+        // Store normal vector and plane constant
+        this.dragPlaneNormal.copy(lookVector);
+        this.dragPlaneConstant = this.dragPlaneNormal.dot(nodePosition);
+        
+        // Calculate offset between intersection point and node position
+        this.dragOffset.copy(intersectionPoint).sub(nodePosition);
+        
+        logger.info(`Started dragging node ${nodeId}`);
+    }
+    
+    /**
+     * Calculate intersection with drag plane and update node position
+     */
+    private updateDrag(): void {
+        if (!this.camera || !this.selectedNodeId || !this.isDragging) return;
+        
+        // Cast ray from camera through mouse into scene
+        this.raycaster.setFromCamera(this.mouse, this.camera);
+        const ray = this.raycaster.ray;
+        
+        // Calculate intersection with drag plane
+        // Using the formula: t = (planeConstant - dot(normal, rayOrigin)) / dot(normal, rayDirection)
+        const denominator = this.dragPlaneNormal.dot(ray.direction);
+        
+        // Avoid division by zero
+        if (Math.abs(denominator) > 0.0001) {
+            const t = (this.dragPlaneConstant - this.dragPlaneNormal.dot(ray.origin)) / denominator;
+            
+            // Only use positive intersections (in front of the camera)
+            if (t > 0) {
+                // Calculate intersection point: origin + direction * t
+                const intersection = ray.origin.clone().add(ray.direction.clone().multiplyScalar(t));
+                
+                // Subtract the drag offset to get the new node position
+                const newPosition = intersection.clone().sub(this.dragOffset);
+                
+                // Update node position with throttling to avoid overwhelming the server
+                const now = performance.now();
+                if (now - this.lastUpdateTime > this.updateThrottleMs) {
+                    this.lastUpdateTime = now;
+                    
+                    // Update local node instance first
+                    this.updateNodePosition(this.selectedNodeId, newPosition);
+                    
+                    // Then send update to server
+                    this.sendNodeUpdates(this.selectedNodeId, newPosition);
+                }
+            }
+        }
+    }
+
+    /**
+     * End the drag operation
+     */
+    private endDrag(): void {
+        if (!this.selectedNodeId || !this.isDragging) return;
+        
+        // Re-enable orbit controls after dragging
+        if (this.sceneManager) {
+            const controls = this.sceneManager.getControls();
+            controls.enabled = true;
+            logger.info('Orbit controls re-enabled after dragging');
+        }
+        
+        // Get final position
+        const finalPosition = this.getNodePosition(this.selectedNodeId);
+        if (finalPosition) {
+            // Send final update to server (not throttled)
+            this.sendNodeUpdates(this.selectedNodeId, finalPosition);
+        }
+        
+        this.isDragging = false;
+        logger.info(`Ended dragging node ${this.selectedNodeId}`);
+    }
+    
+    /**
+     * Get a node's current position from the NodeInstanceManager
+     */
+    private getNodePosition(nodeId: string): Vector3 | undefined {
+        if (!this.nodeInstanceManager) return undefined;
+        return this.nodeInstanceManager.getNodePosition(nodeId);
+    }
+    
+    /**
+     * Update a node's position locally
+     */
+    private updateNodePosition(nodeId: string, position: Vector3): void {
+        if (!this.nodeInstanceManager) return;
+        // Update using the batch update API
+        this.nodeInstanceManager.updateNodePositions([{
+            id: nodeId,
+            position,
+            velocity: new Vector3(0, 0, 0)
+        }]);
+    }
+    
+    /**
+     * "Link out" - open the node's document in a web browser
+     */
+    private linkOut(nodeId: string): void {
+        // Get the node name (metadata ID)
+        const node = graphDataManager.getNode(nodeId);
+        const metadataId = graphDataManager.getNodeMetadataId(nodeId);
+        
+        // Find the best name to use for the URL
+        let nodeName: string | undefined;
+        if (node && node.data.metadata?.name) {
+            nodeName = node.data.metadata.name;
+        } else if (metadataId) {
+            nodeName = metadataId;
+        }
+        
+        if (nodeName) {
+            // Format the node name for URL (remove .md extension, replace spaces with %20)
+            const formattedName = nodeName.replace(/\.md$/, '').replace(/ /g, '%20');
+            
+            // Open in new tab
+            window.open(`https://narrativegoldmine.com//#/page/${formattedName}`, '_blank');
+            logger.info(`Linked out to node ${nodeId}: ${nodeName}`);
+        } else {
+            logger.warn(`Cannot link out: No name available for node ${nodeId}`);
+        }
+    }
+
+    /**
+     * Send node position updates to the server via WebSockets
+     * @param nodeId The ID of the node being updated
+     * @param position The new position for the node
+     */
+    public sendNodeUpdates(nodeId: string, position: Vector3): void {
+        if (!nodeId) {
+            logger.warn('Cannot send node update: Invalid node ID');
+            return;
+        }
+
+        // Add debug logging to track node updates being sent for dragging operations
+        logger.info('Sending node position update to server', createDataMetadata({
+            nodeId,
+            position: {
+                x: parseFloat(position.x.toFixed(3)),
+                y: parseFloat(position.y.toFixed(3)),
+                z: parseFloat(position.z.toFixed(3))
+            },
+            operation: this.isDragging ? 'dragging' : 'end-drag',
+            timestamp: Date.now()
+        }));
+
+        // Send the update to the WebSocket service
+        this.webSocketService.sendNodeUpdates([{
+            id: nodeId,
+            position: position.clone(),
+            velocity: new Vector3(0, 0, 0)
+        }]);
+    }
+
+    private handleNodeHover(_instanceIndex: number): void {
+        // Trigger haptic feedback if available
+        if (this.hapticActuators?.[0]) {
+            this.hapticActuators[0].pulse(this.HAPTIC_STRENGTH, 50).catch(logger.error);
+        }
+    }
+
+    public dispose(): void {
+        this.hapticActuators = null;
+        
+        // Clean up event listeners if they were added
+        if (this.canvas) {
+            // Create bound references to methods for proper removal
+            const boundMouseDown = this.handleMouseDown.bind(this);
+            const boundMouseUp = this.handleMouseUp.bind(this);
+            const boundMouseMove = this.handleMouseMove.bind(this);
+            const boundClick = this.handleClick.bind(this);
+            const boundDoubleClick = this.handleDoubleClick.bind(this);
+            
+            this.canvas.removeEventListener('mousedown', boundMouseDown);
+            this.canvas.removeEventListener('mouseup', boundMouseUp);
+            this.canvas.removeEventListener('mousemove', boundMouseMove);
+            this.canvas.removeEventListener('click', boundClick);
+            this.canvas.removeEventListener('dblclick', boundDoubleClick);
+            
+            this.canvas = null;
+        }
+        
+        this.nodeInstanceManager = null;
+        NodeInteractionManager.instance = null!;
+        logger.info('NodeInteractionManager disposed');
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/node/metadata/NodeMetadataManager.ts b/client/rendering/node/metadata/NodeMetadataManager.ts
new file mode 100644
index 00000000..8e43b877
--- /dev/null
+++ b/client/rendering/node/metadata/NodeMetadataManager.ts
@@ -0,0 +1,670 @@
+import {
+    Object3D,
+    Camera,
+    Scene,
+    Vector3,
+    Sprite,
+    SpriteMaterial,
+    Texture
+} from 'three';
+import { NodeMetadata } from '../../../types/metadata';
+import { createLogger, createDataMetadata } from '../../../core/logger';
+import { Settings } from '../../../types/settings';
+import { debugState } from '../../../core/debugState';
+
+// For tracking changes in node handling between sessions
+const VERSION = 'v1.0';
+
+const logger = createLogger('NodeMetadataManager');
+
+interface LabelCanvas {
+    canvas: HTMLCanvasElement;
+    context: CanvasRenderingContext2D;
+}
+
+interface MetadataLabel {
+    sprite: Sprite;
+    container: Object3D;
+    metadata: NodeMetadata;
+    lastUpdateDistance: number;
+    lastVisible: boolean;
+    labelCanvas?: LabelCanvas; // Reference to the dedicated canvas for this label
+}
+
+export class NodeMetadataManager {
+    private static instance: NodeMetadataManager;
+    private labels: Map<string, MetadataLabel> = new Map();
+    private labelCanvases: Map<string, LabelCanvas> = new Map(); // Cache of canvases per node ID
+    // Add a map to store relationships between node IDs and metadata IDs (filenames)
+    private nodeIdToMetadataId: Map<string, string> = new Map();
+    private metadataIdToNodeId: Map<string, string> = new Map();
+    private VISIBILITY_THRESHOLD = 100;  // Increased maximum distance for label visibility
+    private readonly UPDATE_INTERVAL = 2;        // More frequent updates
+    private settings: Settings;
+    private readonly LABEL_SCALE = 0.5;         // Base scale for labels
+    private readonly DEFAULT_FILE_SIZE = 1000; // Default fileSize for fallback
+    private frameCount = 0;
+    private isInitialMappingComplete = false;
+
+    private worldPosition = new Vector3();
+    private labelCanvas: HTMLCanvasElement;
+    private labelContext: CanvasRenderingContext2D;
+    private scene: Scene;
+
+    private constructor(scene: Scene, settings?: Settings) {
+        logger.info(`Initializing NodeMetadataManager (${VERSION})`);
+        this.settings = settings || {} as Settings;
+        // Create canvas for label textures
+        this.labelCanvas = document.createElement('canvas');
+        this.labelCanvas.width = 256;
+        this.labelCanvas.height = 128;
+        
+        const context = this.labelCanvas.getContext('2d');
+        if (!context) {
+            throw new Error('Failed to get 2D context for label canvas');
+        }
+        this.labelContext = context;
+        
+        // Set up default text style
+        this.labelContext.textAlign = 'center';
+        this.labelContext.textBaseline = 'middle';
+        this.labelContext.font = 'bold 24px Arial';
+        
+        this.scene = scene;
+    }
+
+    public static getInstance(scene?: Scene, settings?: Settings): NodeMetadataManager {
+        if (!NodeMetadataManager.instance) {
+            NodeMetadataManager.instance = new NodeMetadataManager(
+                scene || new Scene(), settings);
+        }
+        return NodeMetadataManager.instance;
+    }
+
+    /**
+     * Prioritize mapping node IDs to metadata IDs before any other operation
+     * This is critical for ensuring labels are displayed correctly from the start
+     * @param nodes Array of nodes to establish initial mappings
+     */
+    public initializeMappings(nodes: Array<{id: string, metadataId?: string, label?: string}>): void {
+        if (this.isInitialMappingComplete) return;
+        
+        // Count nodes with explicit metadata values vs. fallback values
+        const nodesWithMetadataId = nodes.filter(node => node.metadataId && 
+            node.metadataId !== 'undefined' && 
+            node.metadataId !== 'null' && 
+            node.metadataId !== node.id).length;
+            
+        logger.info(`Initializing metadata mappings for ${nodes.length} nodes (${nodesWithMetadataId} with explicit metadata IDs)`, 
+            createDataMetadata({ 
+                nodeCount: nodes.length,
+                nodesWithMetadataId,
+                nodesWithFallbackIds: nodes.length - nodesWithMetadataId 
+            }));
+        
+        nodes.forEach(node => {
+            // Only map nodes where we actually have useful metadata
+            if (node.id) {
+                // Get all possible values in order of preference
+                const validMetadataId = node.metadataId && 
+                    node.metadataId !== 'undefined' && 
+                    node.metadataId !== 'null' ? 
+                    node.metadataId : null;
+                    
+                const validLabel = node.label && 
+                    node.label !== 'undefined' && 
+                    node.label !== 'null' ? 
+                    node.label : null;
+                    
+                // Use the best available option
+                const bestName = validMetadataId || validLabel || `Node_${node.id}`;
+                
+                // Record this mapping
+                this.mapNodeIdToMetadataId(node.id, bestName);
+                
+                // Only log a sample of mappings to avoid spam
+                if (Math.random() < 0.05) { // Log ~5% of mappings
+                    logger.debug(`Initial mapping: Node ID ${node.id} -> "${bestName}"`);
+                }
+            }
+        });
+
+        this.isInitialMappingComplete = true;
+        
+        // Log detailed mapping statistics
+        const metadataIds = Array.from(this.nodeIdToMetadataId.values());
+        const uniqueMetadataIds = new Set(metadataIds);
+        const duplicateCount = metadataIds.length - uniqueMetadataIds.size;
+        
+        logger.info(`Completed initial metadata mappings for ${this.nodeIdToMetadataId.size} nodes (${duplicateCount} potential duplicates)`, 
+            createDataMetadata({
+                totalMappings: this.nodeIdToMetadataId.size,
+                uniqueNames: uniqueMetadataIds.size,
+                duplicates: duplicateCount
+            }));
+    }
+
+    /**
+     * Handle settings updates
+     * @param settings The new settings object
+     */
+    public handleSettingsUpdate(settings: Settings): void {
+        // Update our local settings reference
+        this.settings = settings;
+
+        // Check for visualization settings - may need to adapt this path 
+        // based on your actual settings structure
+        const visibilityThreshold = settings.visualization?.labels?.visibilityThreshold;
+        
+        // Only update if we have a valid number
+        if (typeof visibilityThreshold === 'number') {
+            // Using the settings directly in the code to ensure TS sees it's being used
+            this.VISIBILITY_THRESHOLD = visibilityThreshold;
+            this.updateVisibilityThreshold(visibilityThreshold);
+        }
+    }
+
+    private createLabelTexture(metadata: NodeMetadata, nodeId: string): Texture {
+        // Get or create a dedicated canvas for this node
+        let labelCanvas = this.labelCanvases.get(nodeId);
+        if (!labelCanvas) {
+            const canvas = document.createElement('canvas');
+            canvas.width = 256;
+            canvas.height = 128;
+            
+            const context = canvas.getContext('2d');
+            if (!context) {
+                throw new Error('Failed to get 2D context for dedicated canvas');
+            }
+            
+            // Configure the context
+            context.textAlign = 'center';
+            context.textBaseline = 'middle';
+            context.font = 'bold 24px Arial';
+            
+            labelCanvas = { canvas, context };
+            this.labelCanvases.set(nodeId, labelCanvas);
+            
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Created new dedicated canvas for node ${nodeId}`);
+            }
+        }
+        
+        const { canvas, context } = labelCanvas;
+        
+        // Clear this node's canvas
+        context.clearRect(0, 0, canvas.width, canvas.height);
+ 
+        // Get display name with improved fallback logic
+        let rawName = this.nodeIdToMetadataId.get(nodeId) || metadata.name;
+        let displayName = (rawName && rawName !== 'undefined' && rawName !== 'null') ? 
+            rawName : (nodeId ? `Node_${nodeId}` : 'Unknown');
+        
+        // Using settings property to control debug logging
+        const enableDebugLogging = debugState.isNodeDebugEnabled() || 
+            (this.settings?.system?.debug?.enabled === true);
+        if (enableDebugLogging) {
+            logger.debug(`Creating label for node ${nodeId} with name: ${displayName}`,
+                createDataMetadata({ 
+                    originalName: metadata.name,
+                    mappedName: this.nodeIdToMetadataId.get(nodeId),
+                    fileSize: metadata.fileSize 
+                }));
+        }
+        
+        if (Math.random() < 0.01) { // Only log ~1% to reduce spam
+            logger.debug(`Label texture for node ${nodeId}: Using name "${displayName}"`);
+        }
+
+        // Draw a slightly larger background to accommodate multiple lines
+        context.fillStyle = 'rgba(0, 0, 0, 0.5)';
+        context.fillRect(0, 0, canvas.width, canvas.height);
+
+        // Draw main label (filename)
+        context.fillStyle = 'white';
+        context.font = 'bold 20px Arial';
+        context.fillText(displayName, canvas.width / 2, 30);
+        
+        // Draw subtext lines
+        context.font = '14px Arial';
+        context.fillStyle = '#dddddd';
+        
+        // Add file size if available
+        if (metadata.fileSize) {
+            // Use actual fileSize or a reasonable default
+            const fileSize = metadata.fileSize || this.DEFAULT_FILE_SIZE;
+            const fileSizeText = this.formatFileSize(fileSize);
+            context.fillText(`Size: ${fileSizeText}`, canvas.width / 2, 55);
+        }
+        
+        // Add hyperlink count if available
+        if (metadata.hyperlinkCount !== undefined && metadata.hyperlinkCount > 0) {
+            context.fillText(`Links: ${metadata.hyperlinkCount}`, canvas.width / 2, 75); 
+        }
+
+        // Create texture
+        const texture = new Texture(canvas);
+        texture.needsUpdate = true;
+        return texture;
+    }
+    
+    /**
+     * Format file size into human-readable format
+     */
+    private formatFileSize(bytes: number): string {
+        if (bytes < 1024) return bytes + ' B';
+        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
+        if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
+        return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
+    }
+
+    public async createMetadataLabel(metadata: NodeMetadata): Promise<Object3D> {
+        // The problem: We were using a shared canvas instance for all node labels
+        // Create a unique texture for each node with its own canvas instance
+        logger.info(`Creating metadata label for node ID: ${metadata.id}, metadata name: ${metadata.name || 'undefined'}`, 
+            createDataMetadata({ nodeId: metadata.id, name: metadata.name }));
+        
+        // Create a dedicated canvas for this label
+        const canvas = document.createElement('canvas');
+        canvas.width = 256;
+        canvas.height = 128;
+        
+        const context = canvas.getContext('2d');
+        if (!context) {
+            throw new Error('Failed to get 2D context for dedicated canvas');
+        }
+        
+        // Configure the context the same way as our shared one
+        context.textAlign = 'center';
+        context.textBaseline = 'middle';
+        context.font = 'bold 24px Arial';
+        
+        // Use settings for font size if available
+        const fontSize = this.settings?.visualization?.labels?.desktopFontSize || 24;
+        context.font = `bold ${fontSize}px Arial`;
+        
+        // CRITICAL FIX: Simplified name resolution logic - consistent with createLabelTexture
+        // Use the same logic as createLabelTexture to get the display name
+        let rawName = this.nodeIdToMetadataId.get(metadata.id) || metadata.name;
+        let displayName = (rawName && rawName !== 'undefined' && rawName !== 'null') ? 
+            rawName : (metadata.id ? `Node_${metadata.id}` : 'Unknown');
+
+        // Log the name resolution process for debugging
+        if (debugState.isNodeDebugEnabled()) {
+            logger.debug(`Node ${metadata.id} display name resolution:`, 
+                createDataMetadata({ mappedName: this.nodeIdToMetadataId.get(metadata.id),
+                                    metadataName: metadata.name,
+                                    finalDisplayName: displayName,
+                                    fileSize: metadata.fileSize, 
+                                       hyperlinkCount: metadata.hyperlinkCount }));
+        }
+        
+        // Draw background
+        context.fillStyle = 'rgba(0, 0, 0, 0.5)';
+        context.fillRect(0, 0, canvas.width, canvas.height);
+
+        // Draw main label (filename)
+        context.fillStyle = 'white';
+        context.font = 'bold 20px Arial';
+        // Truncate very long names
+        let displayText = displayName;
+        if (displayText.length > 30) {
+            displayText = displayText.substring(0, 27) + '...';
+        }
+        context.fillText(displayText || "Unknown", canvas.width / 2, 30);
+        
+        // Draw subtext lines
+        context.font = '14px Arial';
+        context.fillStyle = '#dddddd';
+
+        // Add file size if available
+        if (metadata.fileSize !== undefined && metadata.fileSize > 0) {
+            const fileSizeText = this.formatFileSize(metadata.fileSize);
+            context.fillText(`Size: ${fileSizeText}`, canvas.width / 2, 55);
+        } else {
+            // Debug message for missing file size
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Node ${metadata.id} (${displayName}) missing file size`, 
+                    createDataMetadata({ 
+                        metadataFileSize: metadata.fileSize || 'undefined'
+                    }));
+            }
+        }
+        
+        // Add hyperlink count if available
+        if (metadata.hyperlinkCount !== undefined && metadata.hyperlinkCount > 0) {
+            context.fillText(`Links: ${metadata.hyperlinkCount}`, canvas.width / 2, 75);
+        } else {
+            // Debug message for missing hyperlink count only if debug is enabled
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Node ${metadata.id} (${displayName}) missing hyperlink count`, 
+                    createDataMetadata({ 
+                        metadataHyperlinkCount: metadata.hyperlinkCount || 'undefined'
+                    }));
+            }
+        }
+
+        
+        // Create a unique texture from this canvas instance
+        const texture = new Texture(canvas);
+        texture.needsUpdate = true;
+
+        const material = new SpriteMaterial({
+            map: texture,
+            color: 0xffffff,
+            transparent: true,
+            opacity: 0.9,  // Slightly increased for better visibility
+            // Ensure the renderer knows this material is unique
+            depthWrite: false  // Changed to false to prevent occlusion by other objects
+        });
+
+        const sprite = new Sprite(material);
+        sprite.scale.set(this.LABEL_SCALE * 2, this.LABEL_SCALE, 1);
+        sprite.renderOrder = 1000; // Significantly increase render order to ensure labels are always on top
+
+        // Add the sprite to an Object3D container for better control
+        const container = new Object3D();
+        container.add(sprite);
+        container.renderOrder = 1000; // Ensure the entire container has high render priority
+        container.position.copy(sprite.position); // Initialize container position
+        
+        // Enable both layers for desktop mode
+        sprite.layers.enable(0);
+        sprite.layers.enable(1);
+
+        const label: MetadataLabel = {
+            sprite,
+            container,
+            metadata,
+            lastUpdateDistance: Infinity,
+            lastVisible: false
+        };
+
+        // Store the canvas for this label
+        const labelCanvas = { canvas, context };
+        label.labelCanvas = labelCanvas;
+        this.labelCanvases.set(metadata.id, labelCanvas);
+
+        // Add to scene
+        this.scene.add(container);
+
+        // If this node has a numeric ID, map it to the display name
+        // Always ensure we have a mapping, even if it's just the ID
+        // This ensures each node has its own label
+        const existingMapping = this.nodeIdToMetadataId.get(metadata.id);
+        if (!existingMapping) {
+            // If no mapping exists yet, create one
+            this.mapNodeIdToMetadataId(metadata.id, displayName);
+            logger.info(`Created new mapping: node ID ${metadata.id} -> "${displayName}"`);
+        } else if (existingMapping !== displayName) {
+            logger.info(`Note: Mapping exists but differs - ID ${metadata.id}: "${existingMapping || 'undefined'}" vs "${displayName}"`);
+        }
+
+        this.labels.set(metadata.id, label);
+        return sprite;
+    }
+
+    public update(camera: Camera): void {
+        this.frameCount++;
+        if (this.frameCount % this.UPDATE_INTERVAL !== 0) return;
+
+        const cameraPosition = camera.position;
+
+        this.labels.forEach((label) => {
+            const { sprite, container, metadata } = label;
+            
+            // Get actual world position from metadata
+            this.worldPosition.set(
+                metadata.position.x || 0,
+                metadata.position.y || 0,
+                metadata.position.z || 0
+            );
+            
+            // Update sprite position
+            container.position.copy(this.worldPosition);
+            
+            const distance = this.worldPosition.distanceTo(cameraPosition);
+
+            // Update visibility based on distance
+            const visible = distance < this.VISIBILITY_THRESHOLD;
+            sprite.visible = visible;
+
+            if (label.lastVisible !== visible) {
+                label.lastVisible = visible;
+            }
+
+            if (visible) {
+                // Scale based on distance
+                const scale = Math.max(0.5, 1 - (distance / this.VISIBILITY_THRESHOLD));
+                sprite.scale.set(
+                    this.LABEL_SCALE * scale * 2,
+                    this.LABEL_SCALE * scale,
+                    1
+                );
+
+                // Make sprite face camera
+                container.lookAt(cameraPosition);
+            }
+
+            // Update last known distance
+            label.lastUpdateDistance = distance;
+        });
+    }
+
+    public updateMetadata(id: string, metadata: NodeMetadata): void {
+        const label = this.labels.get(id);
+        if (!label) {
+            this.createMetadataLabel(metadata);
+            return;
+        }
+
+        // Update metadata
+        const oldMetadata = { ...label.metadata };
+        label.metadata = metadata;
+        
+        // Check if we need to update the node-to-metadata mapping
+        if (metadata.name && metadata.name !== oldMetadata.name) {
+            this.mapNodeIdToMetadataId(metadata.id, metadata.name);
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Updated metadata mapping: ${metadata.id} -> ${metadata.name}`);
+            } else {
+                // Log at info level for important mappings to help diagnose issues
+                if (/^\d+$/.test(metadata.id)) {
+                    logger.info(`Updated numeric ID mapping: ${metadata.id} -> ${metadata.name}`);
+                }
+            }
+        }
+        
+        // Update texture
+        const texture = this.createLabelTexture(metadata, id); 
+        
+        // Dispose of old texture to avoid memory leaks
+        if ((label.sprite.material as SpriteMaterial).map) {
+            (label.sprite.material as SpriteMaterial).map?.dispose();
+        }
+        // Update material with new texture
+        (label.sprite.material as SpriteMaterial).map = texture;
+        (label.sprite.material as SpriteMaterial).needsUpdate = true;
+    }
+    
+    /**
+     * Map a node ID to a metadata ID (filename) for proper labeling
+     * This is crucial for connecting numeric IDs with human-readable names
+     */
+    public mapNodeIdToMetadataId(nodeId: string, metadataId: string | undefined): void {
+        if (!nodeId) {
+            logger.warn(`Attempted to map empty node ID to "${metadataId}"`);
+            return;
+        }
+        
+        // Don't map empty metadata IDs
+        if (!metadataId || metadataId === 'undefined' || metadataId === 'null') {
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Skipping invalid metadata ID mapping for node ${nodeId}: "${metadataId}"`);
+            }
+            // Even for invalid metadata, create a unique fallback name
+            // This ensures each node gets a unique label
+            metadataId = `Node_${nodeId}`;
+            
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Created fallback mapping for node ${nodeId}: "${metadataId}"`);
+            }
+        }
+        
+        // Log previous mapping if it exists and is different
+        const prevMapping = this.nodeIdToMetadataId.get(nodeId);
+        if (prevMapping && prevMapping !== metadataId) {
+            logger.debug(`Updating node ID ${nodeId} mapping from "${prevMapping}" to "${metadataId}"`, 
+                createDataMetadata({ nodeId, previousMapping: prevMapping, newMapping: metadataId }));
+        }
+        
+        this.nodeIdToMetadataId.set(nodeId, metadataId);
+        // Maintain reverse mapping for bidirectional lookup
+        if (!this.metadataIdToNodeId.has(metadataId)) {
+            this.metadataIdToNodeId.set(metadataId, nodeId);
+        }
+        
+        // Only log new mappings or if debug is enabled
+        if (!prevMapping || debugState.isNodeDebugEnabled()) {
+            if (Math.random() < 0.05) { // Only log ~5% to reduce spam
+                logger.debug(`Mapped node ID ${nodeId} to metadata ID "${metadataId}"`);
+            }
+        }
+    }
+
+    public updatePosition(id: string, position: Vector3): void {
+        const label = this.labels.get(id);
+        if (!label) {
+            try {
+                // Check if this is a numeric ID with a mapped metadata ID
+                if (/^\d+$/.test(id) && this.nodeIdToMetadataId.has(id)) {
+                    const metadataId = this.nodeIdToMetadataId.get(id);
+                    if (metadataId) {
+                        // Try to find the label using the metadata ID
+                        const metadataLabel = this.labels.get(metadataId);
+                        if (metadataLabel) {
+                            // Update the metadata label position
+                            metadataLabel.metadata.position = { 
+                                x: position.x, 
+                                y: position.y, 
+                                z: position.z 
+                            };
+                            metadataLabel.container.position.copy(position);
+                            return;
+                        }
+                    }
+                }
+                
+                // Only log missing labels in debug mode to avoid spamming the console
+                if (debugState.isNodeDebugEnabled() && Math.random() < 0.01) {
+                    logger.debug(`No label found for node ${id}`);
+                }
+            } catch (error) {
+                logger.warn(`Error updating position for node ${id}`, createDataMetadata({
+                    error: error instanceof Error ? error.message : String(error),
+                    position: `${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}`
+                }));
+            }
+            return;
+        }
+
+        // Update metadata position
+        label.metadata.position = { x: position.x, y: position.y, z: position.z };
+        
+        // IMPORTANT FIX: Just update position but don't recreate the label or change text
+        // This was likely the source of labels showing the same text - we were losing
+        // individual label text during position updates because we weren't using
+        // preserveText=true when updating positions
+        label.container.position.copy(position);
+    }
+
+    public updateVisibilityThreshold(threshold: number): void {
+        if (threshold > 0) {
+            this.VISIBILITY_THRESHOLD = threshold;
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Updated visibility threshold to ${threshold}`);
+            }
+        }
+    }
+
+    public setXRMode(enabled: boolean): void {
+        this.labels.forEach((label) => {
+            const sprite = label.sprite;
+            if (enabled) {
+                // XR mode - only layer 1
+                sprite.layers.disable(0);
+                sprite.layers.enable(1);
+            } else {
+                // Desktop mode - both layers
+                sprite.layers.enable(0);
+                sprite.layers.enable(1);
+            }
+        });
+    }
+
+    /**
+     * Get the metadata ID (filename) for a given node ID
+     */
+    public getMetadataId(nodeId: string): string | undefined {
+        return this.nodeIdToMetadataId.get(nodeId);
+    }
+
+    /**
+     * Get the node ID for a given metadata ID (filename)
+     */
+    public getNodeId(metadataId: string): string | undefined {
+        return this.metadataIdToNodeId.get(metadataId);
+    }
+
+    /**
+     * Get the label for a node - uses the mapped metadata name if available
+     */
+    public getLabel(nodeId: string): string {
+        const mappedLabel = this.nodeIdToMetadataId.get(nodeId);
+        return (mappedLabel && mappedLabel !== 'undefined' && mappedLabel !== 'null') ? 
+            mappedLabel : `Node_${nodeId}`;
+    }
+
+    public removeLabel(id: string): void {
+        const label = this.labels.get(id);
+        if (!label) return;
+
+        // Clean up resources
+        (label.sprite.material as SpriteMaterial).map?.dispose();
+        label.sprite.material.dispose();
+
+        // Remove from scene
+        this.scene.remove(label.container);
+        
+        // Remove from tracking
+        this.labels.delete(id);
+        
+        // Clean up the dedicated canvas
+        if (this.labelCanvases.has(id)) {
+            this.labelCanvases.delete(id);
+        }
+    }
+
+    public dispose(): void {
+        // Clean up all labels
+        this.labels.forEach((label) => {
+            (label.sprite.material as SpriteMaterial).map?.dispose();
+            label.sprite.material.dispose();
+            
+            // Remove from scene
+            this.scene.remove(label.container);
+        });
+        this.labels.clear();
+        
+        // Clear mappings
+        this.nodeIdToMetadataId.clear();
+        this.metadataIdToNodeId.clear();
+        
+        // Clear canvases
+        this.labelCanvases.clear();
+
+        // Reset singleton
+        NodeMetadataManager.instance = null!;
+        logger.info('Disposed NodeMetadataManager');
+    }
+}
\ No newline at end of file
diff --git a/client/rendering/renderManager.ts b/client/rendering/renderManager.ts
new file mode 100644
index 00000000..0519ecba
--- /dev/null
+++ b/client/rendering/renderManager.ts
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff --git a/client/rendering/scene.ts b/client/rendering/scene.ts
new file mode 100644
index 00000000..b84b45c1
--- /dev/null
+++ b/client/rendering/scene.ts
@@ -0,0 +1,664 @@
+/**
+ * Three.js scene management with simplified setup
+ */
+
+import {
+  Scene,
+  PerspectiveCamera,
+  WebGLRenderer,
+  Color,
+  GridHelper,
+  Layers,
+  Vector2,
+  Object3D,
+  Mesh,
+  Material,
+  AmbientLight,
+  DirectionalLight
+} from 'three';
+import * as EffectComposerModule from 'three/examples/jsm/postprocessing/EffectComposer';
+import * as RenderPassModule from 'three/examples/jsm/postprocessing/RenderPass';
+import * as UnrealBloomPassModule from 'three/examples/jsm/postprocessing/UnrealBloomPass';
+import * as OrbitControlsModule from 'three/examples/jsm/controls/OrbitControls';
+import { VisualizationController } from './VisualizationController';
+import { HologramShaderMaterial } from './materials/HologramShaderMaterial';
+import { Settings } from '../types/settings/base';
+import { defaultSettings } from '../state/defaultSettings';
+import { debugState } from '../core/debugState';
+import { logger, createErrorMetadata, createDataMetadata } from '../core/logger';
+import { resourceMonitor } from '../core/resourceMonitor';
+import { NodeInteractionManager } from './node/interaction/NodeInteractionManager';
+
+const BACKGROUND_COLOR = 0x000000;  // Material Design Grey 900
+const LOW_PERF_FPS_THRESHOLD = 30;  // Lower FPS threshold for low performance mode
+
+export class SceneManager {
+  private static instance: SceneManager;
+  
+  // Three.js core components
+  private scene: Scene;
+  private camera: PerspectiveCamera;
+  private renderer!: WebGLRenderer;
+  private readonly canvas: HTMLCanvasElement;
+  private currentRenderingSettings: Settings['visualization']['rendering'] | null = null;
+  private controls!: OrbitControlsModule.OrbitControls & { dispose: () => void };
+  private sceneGrid: GridHelper | null = null;
+  
+  // Define bloom layer
+  private readonly BLOOM_LAYER = 1;
+  private readonly bloomLayer = new Layers();
+  
+  // Post-processing
+  private composer!: EffectComposerModule.EffectComposer;
+  private bloomPass!: UnrealBloomPassModule.UnrealBloomPass;
+  
+  // Animation
+  private animationFrameId: number | null = null;
+  private isRunning: boolean = false;
+  private nodeInteractionManager: NodeInteractionManager | null = null;
+  private visualizationController: VisualizationController | null = null;
+  private lastFrameTime: number = performance.now();
+  private readonly FRAME_BUDGET: number = 16; // Target 60fps (1000ms/60)
+  private frameCount: number = 0;
+  private lastFpsUpdate: number = 0;
+  private currentFps: number = 60;
+  private lastLoggedFps: number = 60; // Track last logged FPS
+  private readonly FPS_LOG_THRESHOLD = 5.0; // Increased threshold to reduce log frequency
+
+  private constructor(canvas: HTMLCanvasElement) {
+    logger.log('Initializing SceneManager');
+    this.canvas = canvas;
+    
+    // Create scene
+    this.scene = new Scene();
+    this.scene.background = new Color(BACKGROUND_COLOR);
+
+    // Create camera with wider view
+    this.camera = new PerspectiveCamera(
+      60, // Reduced FOV for less distortion
+      window.innerWidth / window.innerHeight,
+      0.1,
+      5000  // Increased far plane for larger visualization space
+    );
+    this.camera.position.set(0, 10, 50); // Position for better overview
+    this.camera.lookAt(0, 0, 0);
+    
+    // Configure bloom layer
+    this.bloomLayer.set(this.BLOOM_LAYER);
+    
+    // Enable both layers for desktop mode by default
+    this.camera.layers.enable(0); // Desktop layer
+    this.camera.layers.enable(this.BLOOM_LAYER); // Bloom/XR layer
+
+    this.initializeRenderer();
+    this.setupControls();
+    this.setupLighting();
+
+    // Setup event listeners
+    window.addEventListener('resize', this.handleResize.bind(this));
+
+    // Initialize visualization controller
+    this.visualizationController = VisualizationController.getInstance();
+    this.visualizationController.initializeScene(this.scene, this.camera);
+
+    logger.log('SceneManager initialization complete');
+  }
+
+  private initializeRenderer(): void {
+    try {
+      // Create renderer with WebXR support
+      this.renderer = new WebGLRenderer({
+        canvas: this.canvas,
+        antialias: true,
+        alpha: true,
+        preserveDrawingBuffer: true,
+        powerPreference: 'high-performance'
+      });
+      this.renderer.setSize(window.innerWidth, window.innerHeight);
+      HologramShaderMaterial.setRenderer(this.renderer);
+      
+      // Track renderer in resource monitor
+      resourceMonitor.trackRenderer(this.renderer);
+      
+      // Remove unsupported properties
+      // this.renderer.sortObjects = false;
+      // this.renderer.physicallyCorrectLights = false;
+
+      // Setup post-processing
+      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
+      if (debugState.isDataDebugEnabled()) {
+        logger.debug('Renderer initialized and set for shader validation');
+      }
+      
+      this.composer = new EffectComposerModule.EffectComposer(this.renderer);
+      const renderPass = new RenderPassModule.RenderPass(this.scene, this.camera);
+      this.composer.addPass(renderPass);
+
+      const bloomSettings = defaultSettings.visualization.bloom;
+
+      // Initialize bloom
+      this.bloomPass = new UnrealBloomPassModule.UnrealBloomPass(
+        new Vector2(window.innerWidth, window.innerHeight),
+        bloomSettings.strength || 3.0,
+        bloomSettings.radius || 2.0,
+        bloomSettings.threshold || 0.0
+      );
+
+      // Store custom bloom settings as properties
+      (this.bloomPass as any).edgeStrength = bloomSettings.edgeBloomStrength || 2.0;
+      (this.bloomPass as any).nodeStrength = bloomSettings.nodeBloomStrength || 3.0;
+      (this.bloomPass as any).environmentStrength = bloomSettings.environmentBloomStrength || 3.0;
+      
+      this.composer.addPass(this.bloomPass);
+      
+    } catch (error) {
+      logger.error('Failed to initialize renderer or post-processing:', createErrorMetadata(error));
+      throw new Error('Failed to initialize rendering system');
+    }
+  }
+
+  private setupControls(): void {
+    this.controls = new OrbitControlsModule.OrbitControls(this.camera, this.canvas);
+    this.controls.enableDamping = true;
+    this.controls.dampingFactor = 0.1;
+    this.controls.screenSpacePanning = true;
+    this.controls.minDistance = 1;
+    this.controls.maxDistance = 2000;
+    this.controls.enableRotate = true;
+    this.controls.enableZoom = true;
+    this.controls.enablePan = true;
+    this.controls.rotateSpeed = 1.0;
+    this.controls.zoomSpeed = 1.2;
+    this.controls.panSpeed = 0.8;
+  }
+
+  static getInstance(canvas: HTMLCanvasElement): SceneManager {
+    if (!SceneManager.instance) {
+      SceneManager.instance = new SceneManager(canvas);
+    }
+    return SceneManager.instance;
+  }
+
+  static cleanup(): void {
+    if (SceneManager.instance) {
+      SceneManager.instance.dispose();
+      SceneManager.instance = null as any;
+    }
+    
+    // Stop resource monitoring
+    resourceMonitor.stopMonitoring();
+  }
+
+  private setupLighting(): void {
+    const ambientLight = new AmbientLight(0xffffff, 0.6);
+    this.scene.add(ambientLight);
+
+    const directionalLight = new DirectionalLight(0xffffff, 0.8);
+    directionalLight.position.set(1, 1, 1).normalize();
+    this.scene.add(directionalLight);
+
+    // Add smaller grid helper
+    const gridHelper = new GridHelper(100, 100); // Increased grid size to match visualization space
+    if (gridHelper.material instanceof Material) {
+      gridHelper.material.transparent = true;
+      gridHelper.material.opacity = 0.1;
+    }
+    this.scene.add(gridHelper);
+    this.sceneGrid = gridHelper;
+  }
+
+  // Debounce function to limit how often a function is called
+  private debounce(func: Function, wait: number): (...args: any[]) => void {
+    let timeout: number | null = null;
+    return (...args: any[]) => {
+      const later = () => {
+        timeout = null;
+        func(...args);
+      };
+      if (timeout !== null) {
+        window.clearTimeout(timeout);
+      }
+      timeout = window.setTimeout(later, wait);
+    };
+  }
+
+  private handleResize(): void {
+    // Use requestAnimationFrame to ensure resize happens in the next frame
+    // This helps avoid layout thrashing and improves performance
+    requestAnimationFrame(() => {
+      const width = window.innerWidth;
+      const height = window.innerHeight;
+
+      this.camera.aspect = width / height;
+      this.camera.updateProjectionMatrix();
+
+      this.renderer.setSize(width, height);
+      this.composer.setSize(width, height);
+      
+      // Update bloom resolution
+      if (this.bloomPass) {
+        this.bloomPass.resolution.set(width, height);
+      }
+    });
+  }
+
+  public start(): void {
+    if (this.isRunning) return;
+    this.isRunning = true;
+    
+    // Start resource monitoring
+    resourceMonitor.startMonitoring(60000); // Increased monitoring interval to 60 seconds
+
+    // Initialize desktop node interactions
+    if (this.visualizationController) {
+      const nodeFacade = this.visualizationController.getNodeManagerFacade();
+      if (nodeFacade) {
+        // Get the instanced mesh from the node facade
+        const instanceMesh = nodeFacade.getInstancedMesh();
+        
+        // Create the NodeInteractionManager directly instead of getting it from facade
+        this.nodeInteractionManager = NodeInteractionManager.getInstance(instanceMesh);
+        
+        // Connect to the instance manager
+        const nodeInstanceManager = nodeFacade.getNodeInstanceManager();
+        
+        // Initialize with the node instance manager if available
+        if (this.nodeInteractionManager && nodeInstanceManager) {
+          this.nodeInteractionManager.setNodeInstanceManager(nodeInstanceManager);
+          
+          // Initialize desktop interactions with the canvas and camera
+          this.nodeInteractionManager.initializeDesktopInteraction(this.canvas, this.camera);
+          
+          logger.info('Desktop node interactions initialized');
+        } else {
+          logger.warn('Could not initialize NodeInteractionManager - missing dependencies');
+        }
+        
+      }
+    }
+    
+    // Use debounced resize handler to avoid performance issues
+    window.removeEventListener('resize', this.handleResize.bind(this));
+    window.addEventListener('resize', this.debounce(this.handleResize.bind(this), 100));
+    
+    requestAnimationFrame(this.animate);
+    logger.log('Scene rendering started');
+  }
+
+  // Alias for start() to maintain compatibility with new client code
+  startRendering(): void {
+    this.start();
+  }
+
+  stop(): void {
+    this.isRunning = false;
+    
+    // Clean up animation loops
+    if (this.renderer.xr.enabled) {
+      this.renderer.setAnimationLoop(null);
+    }
+    if (this.animationFrameId !== null) {
+      cancelAnimationFrame(this.animationFrameId);
+      this.animationFrameId = null;
+    }
+    
+    logger.log('Scene rendering stopped');
+  }
+
+  // Throttle function to limit execution frequency
+  private throttleFrameUpdates(timestamp: number): boolean {
+    // Skip frame if we're running too fast (trying to maintain ~60fps)
+    const elapsed = timestamp - this.lastFrameTime;
+    const minFrameTime = 16; // ~60fps
+    
+    if (elapsed < minFrameTime && this.currentFps > 60) {
+      return false; // Skip this frame
+    }
+    return true; // Process this frame
+  }
+
+  private animate = (timestamp: number): void => {
+    if (!this.isRunning) return;
+
+    // Calculate FPS
+    this.frameCount++;
+    if (timestamp - this.lastFpsUpdate >= 1000) {
+      const elapsed = timestamp - this.lastFpsUpdate;
+      this.currentFps = elapsed > 0 ? (this.frameCount * 1000) / elapsed : 60;
+      this.frameCount = 0;
+      this.lastFpsUpdate = timestamp;
+
+      // Apply performance optimizations if FPS is low
+      this.checkPerformance();
+    }
+
+    const deltaTime = timestamp - this.lastFrameTime;
+    this.lastFrameTime = timestamp;
+
+    // Set up animation loop
+    if (this.renderer.xr.enabled) {
+      // For XR, use the built-in animation loop
+      this.renderer.setAnimationLoop(this.render);
+    } else {
+      // For non-XR, use requestAnimationFrame
+      this.render(deltaTime);
+      if (this.isRunning) {
+        this.animationFrameId = requestAnimationFrame(this.animate);
+      }
+    }
+  }
+
+  private checkPerformance(): void {
+    // Apply performance optimizations if FPS is low
+    if (this.currentFps < LOW_PERF_FPS_THRESHOLD) {
+      this.applyLowPerformanceOptimizations();
+    } else if (this.currentFps > 80) {
+      // If FPS is very high, we might be wasting resources
+      // Consider throttling updates to save battery/CPU
+      this.throttleFrameUpdates(performance.now());
+    }
+  }
+
+  private render = (deltaTime?: number): void => {
+    const startTime = performance.now();
+
+    try {
+      if (!this.renderer.xr.enabled) {
+        if (!deltaTime || deltaTime >= this.FRAME_BUDGET) {
+          this.controls.update();
+          if (this.sceneGrid) this.sceneGrid.visible = true;
+        }
+      } else {
+        if (this.sceneGrid) this.sceneGrid.visible = false;
+      }
+
+      if (this.visualizationController) {
+        this.visualizationController.update(Math.min(deltaTime || 0, 33)); // Cap deltaTime to avoid large jumps
+      }
+
+      const preRenderTime = performance.now();
+      const remainingTime = this.FRAME_BUDGET - (preRenderTime - startTime);
+
+      if (remainingTime >= 0) {
+        if (!this.renderer.xr.enabled && this.bloomPass?.enabled) {
+          // Always use composer with bloom when enabled, regardless of remaining time
+          try {
+            this.composer.render();
+          } catch (error) {
+            logger.error('Error rendering with bloom, falling back to standard render', createErrorMetadata(error));
+            this.renderer.render(this.scene, this.camera);
+          }
+        } else {
+          this.renderer.render(this.scene, this.camera);
+        }
+      } else {
+        this.renderer.render(this.scene, this.camera);
+      }
+    } catch (error) {
+      logger.error('Render error:', createErrorMetadata(error));
+      if (this.bloomPass?.enabled) {
+        logger.warn('Disabling bloom pass due to render error');
+        this.bloomPass.enabled = false;
+      }
+    }
+  }
+
+  // Public getters
+  getScene(): Scene {
+    return this.scene;
+  }
+
+  getCamera(): PerspectiveCamera {
+    return this.camera;
+  }
+
+  getRenderer(): WebGLRenderer {
+    return this.renderer;
+  }
+
+  getControls(): OrbitControlsModule.OrbitControls {
+    return this.controls;
+  }
+
+  // Scene management methods
+  add(object: Object3D): void {
+    this.scene.add(object);
+  }
+
+  remove(object: Object3D): void {
+    this.scene.remove(object);
+  }
+
+  public dispose(): void {
+    this.stop();
+    
+    // Clean up node interaction manager
+    if (this.nodeInteractionManager) {
+      this.nodeInteractionManager.dispose();
+      this.nodeInteractionManager = null;
+    }
+    
+    // Remove event listeners
+    const boundResize = this.handleResize.bind(this);
+    window.removeEventListener('resize', boundResize);
+
+    // Dispose of post-processing
+    if (this.composer) {
+      // Dispose of render targets
+      this.composer.renderTarget1.dispose();
+      this.composer.renderTarget2.dispose();
+      
+      // Clear passes
+      this.composer.passes.length = 0;
+    }
+
+    // Dispose of bloom pass resources
+    if (this.bloomPass) {
+      // Dispose of any textures or materials used by the bloom pass
+      if ((this.bloomPass as any).renderTargetsHorizontal) {
+        (this.bloomPass as any).renderTargetsHorizontal.forEach((target: any) => {
+          if (target && target.dispose) target.dispose();
+        });
+      }
+      if ((this.bloomPass as any).renderTargetsVertical) {
+        (this.bloomPass as any).renderTargetsVertical.forEach((target: any) => {
+          if (target && target.dispose) target.dispose();
+        });
+      }
+      if ((this.bloomPass as any).materialHorizontal) {
+        (this.bloomPass as any).materialHorizontal.dispose();
+      }
+      if ((this.bloomPass as any).materialVertical) {
+        (this.bloomPass as any).materialVertical.dispose();
+      }
+    }
+
+    // Dispose of controls
+    if (this.controls) {
+      this.controls.dispose();
+    }
+
+    // Untrack renderer
+    if (this.renderer) {
+      resourceMonitor.untrackRenderer(this.renderer);
+      this.renderer.dispose();
+      this.renderer = null as any;
+    }
+
+    // Dispose of scene objects
+    if (this.scene) {
+      this.scene.traverse((object) => {
+        if (object instanceof Mesh) {
+          if (object.geometry) object.geometry.dispose();
+          if (object.material) {
+            if (Array.isArray(object.material)) {
+              object.material.forEach(material => material.dispose());
+            } else {
+              object.material.dispose();
+            }
+          }
+        }
+      });
+    }
+
+    logger.log('Scene manager disposed');
+  }
+
+  public handleSettingsUpdate(settings: Settings): void {
+    if (!settings.visualization?.rendering) {
+      logger.warn('Received settings update without visualization.rendering section');
+      return;
+    }
+
+    const { rendering: newRendering, bloom: newBloom } = settings.visualization;
+    const hasRenderingChanged = JSON.stringify(this.currentRenderingSettings) !== JSON.stringify(newRendering);
+
+    // Update bloom settings
+    if (newBloom) {
+      const currentBloom = {
+        enabled: this.bloomPass?.enabled ?? false,
+        strength: this.bloomPass?.strength ?? 0,
+        radius: this.bloomPass?.radius ?? 0,
+        threshold: this.bloomPass?.threshold ?? 0,
+        edgeStrength: (this.bloomPass as any)?.edgeStrength ?? 0,
+        nodeStrength: (this.bloomPass as any)?.nodeStrength ?? 0,
+        environmentStrength: (this.bloomPass as any)?.environmentStrength ?? 0
+      };
+
+      const newBloomSettings = {
+        enabled: newBloom.enabled,
+        strength: newBloom.enabled ? (newBloom.strength || defaultSettings.visualization.bloom.strength) : 0,
+        radius: newBloom.enabled ? (newBloom.radius || defaultSettings.visualization.bloom.radius) : 0,
+        threshold: newBloom.threshold, // Use threshold from settings
+        edgeStrength: newBloom.enabled ? (newBloom.edgeBloomStrength || defaultSettings.visualization.bloom.edgeBloomStrength) : 0,
+        nodeStrength: newBloom.enabled ? (newBloom.nodeBloomStrength || defaultSettings.visualization.bloom.nodeBloomStrength) : 0,
+        environmentStrength: newBloom.enabled ? (newBloom.environmentBloomStrength || defaultSettings.visualization.bloom.environmentBloomStrength) : 0
+      };
+
+      const hasBloomChanged = JSON.stringify(currentBloom) !== JSON.stringify(newBloomSettings);
+      
+      if (hasBloomChanged) {
+        // Log bloom settings change
+        logger.debug('Updating bloom settings', createDataMetadata({
+          from: currentBloom,
+          to: newBloomSettings
+        }));
+        
+        // Apply new settings
+        if (this.bloomPass) {
+          // Handle the enabled state change separately to avoid flashing
+          const wasEnabled = this.bloomPass.enabled;
+          const shouldBeEnabled = newBloomSettings.enabled;
+          
+          // Update all other properties first
+          this.bloomPass.strength = newBloomSettings.strength;
+          this.bloomPass.radius = newBloomSettings.radius;
+          this.bloomPass.threshold = newBloomSettings.threshold;
+          (this.bloomPass as any).edgeStrength = newBloomSettings.edgeStrength;
+          (this.bloomPass as any).nodeStrength = newBloomSettings.nodeStrength;
+          (this.bloomPass as any).environmentStrength = newBloomSettings.environmentStrength;
+          
+          // Update enabled state last to avoid flashing
+          if (wasEnabled !== shouldBeEnabled) {
+            this.bloomPass.enabled = shouldBeEnabled;
+          }
+        }
+      }
+    }
+
+    if (hasRenderingChanged) {
+      this.currentRenderingSettings = newRendering;
+
+      // Update background color
+      if (newRendering.backgroundColor) {
+        this.scene.background = new Color(newRendering.backgroundColor);
+      }
+
+      // Update lighting
+      const lights = this.scene.children.filter(child => 
+        child instanceof AmbientLight || child instanceof DirectionalLight
+      );
+      
+      lights.forEach(light => {
+        if (light instanceof AmbientLight) {
+          light.intensity = newRendering.ambientLightIntensity;
+        } else if (light instanceof DirectionalLight) {
+          light.intensity = newRendering.directionalLightIntensity;
+        }
+      });
+
+      // Update renderer settings
+      if (this.renderer) {
+        // Log settings changes that can't be updated at runtime
+        if (newRendering.enableAntialiasing !== this.currentRenderingSettings?.enableAntialiasing) {
+          logger.warn('Antialiasing setting can only be changed at renderer creation');
+        }
+        (this.renderer as any).shadowMap.enabled = newRendering.enableShadows || false;
+      }
+    }
+
+    // Only log if something actually changed
+    if (hasRenderingChanged) {
+      logger.debug('Scene settings updated:', createDataMetadata({
+        rendering: newRendering,
+        bloom: {
+          enabled: this.bloomPass.enabled,
+          strength: this.bloomPass.strength
+        }
+      }));
+    }
+  }
+
+  private applyLowPerformanceOptimizations(): void {
+    // Optimize materials
+    this.scene.traverse((object: Object3D) => {
+      if (object instanceof Mesh) {
+        const material = object.material as Material;
+        if (material) {
+          // Keep material features that affect visual quality
+          material.needsUpdate = true;
+          
+          // Disable shadows
+          (object as any).castShadow = (object as any).receiveShadow = false;
+          
+          // Force material update
+          material.needsUpdate = true;
+        }
+      }
+    });
+
+    // Optimize renderer
+    (this.renderer as any).shadowMap.enabled = false;
+    
+    // Only disable bloom at very low FPS
+    if (this.bloomPass?.enabled && this.currentFps < 20) {
+      // Instead of disabling bloom completely, reduce its intensity
+      if (this.currentFps < 15) {
+        // Only disable bloom at extremely low FPS
+        logger.warn('Disabling bloom due to very low FPS', createDataMetadata({
+          fps: this.currentFps.toFixed(1)
+        }));
+        this.bloomPass.enabled = false;
+      } else {
+        // Reduce bloom strength at moderately low FPS
+        const reducedStrength = Math.max(0.5, this.bloomPass.strength * 0.7);
+        if (this.bloomPass.strength !== reducedStrength) {
+          this.bloomPass.strength = reducedStrength;
+          logger.debug('Reducing bloom strength due to low FPS', createDataMetadata({
+            fps: this.currentFps.toFixed(1),
+            newStrength: this.bloomPass.strength
+          }));
+        }
+      }
+    }
+
+    // Log optimization application only when FPS changes significantly
+    const fpsDiff = Math.abs(this.currentFps - this.lastLoggedFps);
+    if (fpsDiff >= this.FPS_LOG_THRESHOLD) {
+      logger.info('Applied low performance optimizations', createDataMetadata({
+        fps: this.currentFps.toFixed(1)
+      }));
+      this.lastLoggedFps = this.currentFps;
+    }
+  }
+}
diff --git a/client/rendering/textRenderer.ts b/client/rendering/textRenderer.ts
new file mode 100644
index 00000000..2b9e9cc1
--- /dev/null
+++ b/client/rendering/textRenderer.ts
@@ -0,0 +1,315 @@
+import type { Settings, LabelSettings } from '../types/settings';
+import { settingsManager } from '../state/settings';
+import { createLogger, createErrorMetadata } from '../core/logger';
+import {
+    Scene,
+    Camera,
+    Group,
+    Sprite,
+    SpriteMaterial,
+    Vector3,
+    Matrix4,
+    Texture
+} from 'three';
+const logger = createLogger('TextRenderer');
+
+interface LabelState {
+    text: string;
+    position: Vector3;
+    visible: boolean;
+    sprite?: Sprite;
+    texture?: Texture;
+}
+
+export class TextRenderer {
+    private camera: Camera;
+    private labelStates: Map<string, LabelState>;
+    private unsubscribers: Array<() => void> = [];
+    private projMatrix: Matrix4;
+    private viewMatrix: Matrix4;
+    private currentSettings: Settings;
+    private settings: LabelSettings;
+    private group: Group;
+
+    constructor(camera: Camera, scene: Scene) {
+        this.camera = camera;
+        this.labelStates = new Map();
+        this.projMatrix = new Matrix4();
+        this.viewMatrix = new Matrix4();
+        this.currentSettings = settingsManager.getCurrentSettings();
+        this.settings = this.currentSettings.visualization.labels;
+        this.group = new Group();
+        scene.add(this.group); // Add the group to the scene
+        this.setupSettingsSubscriptions();
+    }
+
+    private setupSettingsSubscriptions(): void {
+        Object.keys(this.currentSettings.visualization.labels).forEach(setting => {
+            const path = `visualization.labels.${setting}`;
+            const unsubscribe = settingsManager.subscribe(path, (value) => {
+                this.handleSettingChange(setting as keyof LabelSettings, value);
+            });
+            this.unsubscribers.push(unsubscribe);
+        });
+    }
+
+    private handleSettingChange(setting: keyof LabelSettings, value: any): void {
+        try {
+            switch (setting) {
+                case 'desktopFontSize':
+                    this.updateFontSize(value as number);
+                    break;
+                case 'textColor':
+                    this.updateTextColor(value as string);
+                    break;
+                case 'enableLabels':
+                    this.updateLabelVisibility(value as boolean);
+                    break;
+                default:
+                    // Other settings handled elsewhere
+                    break;
+            }
+        } catch (error) {
+            logger.error(`Error handling setting change for ${setting}:`, createErrorMetadata(error));
+        }
+    }
+
+    private updateFontSize(fontSize: number): void {
+        this.labelStates.forEach((state) => {
+            if (state.sprite) {
+                // Remove old sprite
+                this.group.remove(state.sprite);
+                state.sprite.material.dispose();
+                state.sprite.material.map?.dispose();
+                state.texture?.dispose();
+
+                // Create new sprite with updated font size
+                state.sprite = this.createTextSprite(state.text, fontSize);
+                state.sprite.position.copy(state.position);
+                this.group.add(state.sprite);
+            }
+        });
+    }
+
+    private createTextSprite(text: string, fontSize: number): Sprite {
+        // Create a canvas to render the text
+        const canvas = document.createElement('canvas');
+        const context = canvas.getContext('2d');
+        if (!context) throw new Error('Could not get 2D context');
+
+        // Set canvas size
+        const padding = this.settings.textPadding || 2;
+        context.font = `${fontSize}px Arial`;
+        const textMetrics = context.measureText(text);
+        canvas.width = textMetrics.width + padding * 2;
+        canvas.height = fontSize + padding * 2;
+
+        // Draw text
+        context.font = `${fontSize}px Arial`;
+        context.textAlign = 'center';
+        context.textBaseline = 'middle';
+        
+        // Draw text outline if enabled
+        if (this.settings.textOutlineWidth > 0) {
+            context.strokeStyle = this.settings.textOutlineColor;
+            context.lineWidth = this.settings.textOutlineWidth;
+            context.strokeText(text, canvas.width / 2, canvas.height / 2);
+        }
+        
+        // Draw text fill
+        context.fillStyle = this.settings.textColor;
+        context.lineWidth = 1;
+        context.fillText(text, canvas.width / 2, canvas.height / 2);
+
+        // Create sprite material
+        const texture = new Texture(canvas);
+        texture.needsUpdate = true;
+        const material = new SpriteMaterial({
+            map: texture,
+            transparent: true,
+            depthTest: false // Ensure text is always visible
+        });
+
+        // Create sprite
+        const sprite = new Sprite(material);
+        // Disable frustum culling to ensure labels are visible regardless of position
+        sprite.frustumCulled = false;
+        
+        // Scale based on text resolution
+        const resolution = this.settings.textResolution || 16;
+        const scale = resolution / fontSize;
+        sprite.scale.set(
+            (canvas.width / fontSize) * scale,
+            (canvas.height / fontSize) * scale,
+            1);
+
+        return sprite;
+    }
+
+    private updateTextColor(newColor: string): void {
+        this.settings.textColor = newColor;
+        this.labelStates.forEach((state) => {
+            if (state.sprite) {
+                // Remove old sprite
+                this.group.remove(state.sprite);
+                state.sprite.material.dispose();
+                state.sprite.material.map?.dispose();
+                state.texture?.dispose();
+
+                // Create new sprite with updated color
+                state.sprite = this.createTextSprite(state.text, this.settings.desktopFontSize);
+                state.sprite.position.copy(state.position);
+                this.group.add(state.sprite);
+            }
+        });
+    }
+
+    private updateLabelVisibility(visible: boolean): void {
+        this.group.visible = visible;
+    }
+
+    public updateLabel(id: string, text: string, position: Vector3, preserveText: boolean = false): void {
+        try {
+            let state = this.labelStates.get(id);
+            
+            // Skip processing if text is empty but preserveText is true and we already have a state
+            if (text.trim() === '' && preserveText && state) {
+                // Just update the position
+                if (state.sprite) {
+                    state.position.copy(position);
+                    state.sprite.position.copy(position);
+                }
+                return;
+            }
+
+            if (!state) {
+                state = {
+                    text: text || '',
+                    position: position.clone(),
+                    visible: true
+                };
+                this.labelStates.set(id, state);
+            } else if (text.trim() !== '') {
+                // Only update text if non-empty text is provided
+                state.text = text;
+            }
+            
+            // Always update position
+            state.position.copy(position);
+
+            // Only recreate the sprite if:
+            // 1. There's no sprite yet
+            // 2. Text content has changed
+            const recreateSprite = !state.sprite || 
+                                 (text.trim() !== '' && text !== state.text);
+
+            if (recreateSprite) {
+                // Remove old sprite if it exists
+                if (state.sprite) {
+                    this.group.remove(state.sprite);
+                    state.sprite.material.dispose();
+                    state.sprite.material.map?.dispose();
+                    state.texture?.dispose();
+                }
+
+                // Create new sprite only if we have text to render
+                if (state.text.trim() !== '') {
+                    state.sprite = this.createTextSprite(state.text, this.settings.desktopFontSize);
+                    state.sprite.position.copy(position);
+                    this.group.add(state.sprite);
+                }
+            } else if (state.sprite) {
+                // Just update position if sprite exists
+                state.sprite.position.copy(position);
+            }
+        } catch (error) {
+            logger.error('Error updating label:', createErrorMetadata(error));
+        }
+    }
+
+    public removeLabel(id: string): void {
+        try {
+            const state = this.labelStates.get(id);
+            if (state?.sprite) {
+                this.group.remove(state.sprite);
+                state.sprite.material.dispose();
+                state.sprite.material.map?.dispose();
+                state.texture?.dispose();
+            }
+            this.labelStates.delete(id);
+        } catch (error) {
+            logger.error('Error removing label:', createErrorMetadata(error));
+        }
+    }
+
+    private clearLabels(): void {
+        this.labelStates.forEach((state) => {
+            if (state.sprite) {
+                this.group.remove(state.sprite);
+                state.sprite.material.dispose();
+                state.sprite.material.map?.dispose();
+                state.texture?.dispose();
+            }
+        });
+        this.labelStates.clear();
+    }
+
+    public update(): void {
+        try {
+            // Update projection and view matrices
+            this.camera.updateMatrixWorld();
+            this.projMatrix.copy(this.camera.projectionMatrix);
+            this.viewMatrix.copy(this.camera.matrixWorldInverse);
+            
+            if (!this.settings.enableLabels) {
+                this.group.visible = false;
+                return;
+            }
+            
+            this.group.visible = true;
+
+            // Update label positions and visibility
+            this.labelStates.forEach((state) => {
+                if (state.sprite) {
+                    state.sprite.position.copy(state.position);
+                    // Make sprite face camera
+                    if (this.settings.billboardMode === 'camera') {
+                        // Full billboard - always face camera
+                        state.sprite.quaternion.copy(this.camera.quaternion);
+                        
+                        // Ensure sprite is always visible regardless of camera position
+                        if (!state.sprite.visible) {
+                            state.sprite.visible = true;
+                        }
+                    } else {
+                        // Vertical billboard - only rotate around Y axis
+                        const tempVec = new Vector3().copy(this.camera.position).sub(state.position);
+                        state.sprite.lookAt(tempVec.add(state.position));
+                    }
+                }
+            });
+        } catch (error) {
+            logger.error('Error updating labels:', createErrorMetadata(error));
+        }
+    }
+
+    public dispose(): void {
+        try {
+            this.clearLabels();
+            this.unsubscribers.forEach(unsubscribe => unsubscribe());
+            this.unsubscribers = [];
+            if (this.group.parent) {
+                this.group.parent.remove(this.group);
+            }
+        } catch (error) {
+            logger.error('Error disposing TextRenderer:', createErrorMetadata(error));
+        }
+    }
+
+    public handleSettingsUpdate(settings: LabelSettings): void {
+        this.settings = settings;
+        this.updateLabelVisibility(settings.enableLabels);
+        this.updateFontSize(settings.desktopFontSize);
+        this.updateTextColor(settings.textColor);
+    }
+}
diff --git a/client/services/NostrAuthService.ts b/client/services/NostrAuthService.ts
new file mode 100644
index 00000000..de5e25f4
--- /dev/null
+++ b/client/services/NostrAuthService.ts
@@ -0,0 +1,525 @@
+import { SettingsEventEmitter, SettingsEventType } from './SettingsEventEmitter';
+import { SettingsStore } from '../state/SettingsStore';
+import { SettingsPersistenceService } from './SettingsPersistenceService';
+import { settingsManager } from '../state/settings';
+import { createLogger, createErrorMetadata, createDataMetadata } from '../core/logger';
+import { buildApiUrl } from '../core/api';
+import { Settings } from '../types/settings/base';
+import { VisualizationController } from '../rendering/VisualizationController';
+import { API_ENDPOINTS } from '../core/constants';
+
+const logger = createLogger('NostrAuthService');
+
+declare global {
+    interface Window {
+        nostr?: {
+            getPublicKey(): Promise<string>;
+            signEvent(event: any): Promise<any>;
+        };
+    }
+}
+
+/**
+ * Represents a Nostr user with their access rights
+ */
+export interface NostrUser {
+    pubkey: string;
+    isPowerUser: boolean;
+    features: string[];
+}
+
+/**
+ * Result of an authentication attempt
+ */
+export interface AuthResult {
+    authenticated: boolean;
+    user?: NostrUser;
+    error?: string;
+}
+
+/**
+ * Server authentication response type
+ */
+interface AuthResponse {
+    user: {
+        pubkey: string;
+        is_power_user: boolean;
+        npub?: string;
+    };
+    token: string;
+    features: string[];
+    expires_at?: number;
+    valid?: boolean;
+    error?: string;
+}
+
+/**
+ * Service for handling Nostr authentication and feature access
+ */
+export class NostrAuthService {
+    private static instance: NostrAuthService;
+    private currentUser: NostrUser | null = null;
+    private eventEmitter: SettingsEventEmitter;
+    private settingsPersistence: SettingsPersistenceService;
+    private settingsStore: SettingsStore;
+
+    private constructor() {
+        this.eventEmitter = SettingsEventEmitter.getInstance();
+        this.settingsStore = SettingsStore.getInstance();
+        this.settingsPersistence = SettingsPersistenceService.getInstance();
+    }
+
+    /**
+     * Get the singleton instance of NostrAuthService
+     */
+    public static getInstance(): NostrAuthService {
+        if (!NostrAuthService.instance) {
+            NostrAuthService.instance = new NostrAuthService();
+        }
+        return NostrAuthService.instance;
+    }
+
+    /**
+     * Initialize the auth service and check for existing session
+     */
+    public async initialize(): Promise<void> {
+        const storedPubkey = localStorage.getItem('nostr_pubkey');
+        if (storedPubkey) {
+            // Wait for checkAuthStatus to complete
+            await this.checkAuthStatus(storedPubkey);
+            
+            // Emit auth state change after initialization
+            this.eventEmitter.emit(SettingsEventType.AUTH_STATE_CHANGED, {
+                authState: {
+                    isAuthenticated: this.currentUser !== null,
+                    pubkey: this.currentUser?.pubkey
+                }
+            });
+        }
+    }
+
+    /**
+     * Check if Alby extension is available
+     */
+    private checkAlbyAvailability(): boolean {
+        return typeof window !== 'undefined' && 'nostr' in window;
+    }
+
+    /**
+     * Create a Nostr event for authentication
+     */
+    private async createAuthEvent(pubkey: string): Promise<any> {
+        const createdAt = Math.floor(Date.now() / 1000);
+        const tags = [
+            ['domain', window.location.hostname],
+            ['challenge', Date.now().toString()]
+        ];
+
+        // Create event with required fields
+        const event = {
+            kind: 27235,
+            created_at: createdAt,
+            tags,
+            content: `Authenticate with ${window.location.hostname} at ${new Date().toISOString()}`,
+            pubkey,
+        };
+
+        // Log the event for debugging
+        logger.debug('Creating auth event:', createDataMetadata({
+            kind: event.kind,
+            created_at: event.created_at,
+            tags: event.tags,
+            content: event.content,
+            pubkey: event.pubkey
+        }));
+
+        // Sign the event using the Alby extension
+        const signedEvent = await window.nostr?.signEvent(event);
+        if (!signedEvent) {
+            throw new Error('Failed to sign authentication event');
+        }
+        
+        logger.debug('Signed event:', createDataMetadata(signedEvent));
+        return signedEvent;
+    }
+
+    /**
+     * Attempt to authenticate with Nostr using Alby
+     */
+    public async login(): Promise<AuthResult> {
+        try {
+            // Check if Alby is available
+            if (!this.checkAlbyAvailability()) {
+                throw new Error('Alby extension not found. Please install Alby to use Nostr login.');
+            }
+
+            // Get public key from Alby
+            const pubkey = await window.nostr?.getPublicKey();
+            if (!pubkey) {
+                throw new Error('Failed to get public key from Alby');
+            }
+
+            // Create and sign the authentication event
+            const signedEvent = await this.createAuthEvent(pubkey);
+            logger.debug('Sending auth request with event:', createDataMetadata(signedEvent));
+
+            // Send authentication request to server
+            const response = await fetch(buildApiUrl(API_ENDPOINTS.AUTH_NOSTR), {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/json',
+                },
+                body: JSON.stringify(signedEvent)
+            });
+
+            if (!response.ok) {
+                const errorText = await response.text();
+                logger.error('Server response:', createDataMetadata({
+                    status: response.status,
+                    body: errorText
+                }));
+                throw new Error(`Authentication failed (${response.status}): ${errorText}`);
+            }
+
+            const authData = await response.json() as AuthResponse;
+            
+            // More detailed logging to diagnose the issue
+            logger.debug('Raw auth response data:', createDataMetadata({
+                hasUser: !!authData.user,
+                isPowerUserDefined: authData.user ? (typeof authData.user.is_power_user !== 'undefined') : false,
+                isPowerUserType: authData.user ? typeof authData.user.is_power_user : 'undefined',
+                hasToken: !!authData.token,
+                hasFeatures: !!authData.features,
+                responseKeys: Object.keys(authData)
+            }));
+            
+            // Validate response data
+            if (!authData) {
+                throw new Error('Empty authentication response from server');
+            }
+            
+            if (!authData.user) {
+                throw new Error('Missing user data in authentication response');
+            }
+            
+            if (typeof authData.user.is_power_user !== 'boolean') {
+                // Fix the type if needed - sometimes JSON serialization can convert booleans to strings
+                if (authData.user.is_power_user === 'true') {
+                    authData.user.is_power_user = true;
+                } else if (authData.user.is_power_user === 'false') {
+                    authData.user.is_power_user = false;
+                } else if (authData.user.is_power_user === '1' || authData.user.is_power_user === 1) {
+                    authData.user.is_power_user = true;
+                } else if (authData.user.is_power_user === '0' || authData.user.is_power_user === 0) {
+                    authData.user.is_power_user = false;
+                } else if (authData.user.is_power_user === null || authData.user.is_power_user === undefined) {
+                    // Default to false if the value is null or undefined
+                    authData.user.is_power_user = false;
+                    logger.warn('Power user status was null or undefined, defaulting to false');
+                } else {
+                    // Instead of failing, log the issue and default to false
+                    logger.error(`Unexpected power user status value: ${typeof authData.user.is_power_user} - ${JSON.stringify(authData.user.is_power_user)}`);
+                    authData.user.is_power_user = false;
+                }
+            }
+            
+            if (!authData.token) {
+                throw new Error('Missing token in authentication response');
+            }
+
+            if (!Array.isArray(authData.features)) {
+                // If features is missing or not an array, initialize it as an empty array
+                authData.features = [];
+                logger.warn('Features missing in auth response, using empty array');
+            }
+
+            // Check if the response has a valid format structure overall
+            if (!this.isValidAuthResponse(authData)) {
+                logger.error('Invalid authentication response format:', createDataMetadata(authData));
+                throw new Error('Invalid authentication response structure from server');
+            }
+
+            // Log successful auth data for debugging
+            logger.debug('Auth successful:', createDataMetadata({
+                pubkey: authData.user.pubkey,
+                isPowerUser: authData.user.is_power_user,
+                features: authData.features
+            }));
+
+            this.currentUser = {
+                pubkey: authData.user.pubkey,
+                isPowerUser: authData.user.is_power_user,
+                features: authData.features || []
+            };
+
+            localStorage.setItem('nostr_pubkey', pubkey);
+            localStorage.setItem('nostr_token', authData.token);
+            
+            // Update both services
+            this.settingsPersistence.setCurrentUser(pubkey, authData.user.is_power_user);
+            
+            // Update settings store and load server settings
+            this.settingsStore.setUserLoggedIn(true);
+            const settingsLoaded = await this.settingsStore.loadServerSettings();
+            
+            // Update settings manager with server settings
+            settingsManager.updateSettingsFromServer();
+
+            // Force refresh of visualization with new settings
+            try {
+                const visualizationController = VisualizationController.getInstance();
+                const currentSettings = this.settingsStore.get('') as Settings;
+                logger.info('Refreshing visualization with server settings after login');
+                visualizationController.refreshSettings(currentSettings);
+            } catch (error) {
+                logger.warn('Failed to refresh visualization settings:', createErrorMetadata(error));
+            }
+            
+            if (!settingsLoaded) {
+                logger.warn('Failed to load server settings after login, using defaults');
+            } else {
+                logger.info('Successfully loaded server settings after login');
+            }
+            
+            this.eventEmitter.emit(SettingsEventType.AUTH_STATE_CHANGED, {
+                authState: {
+                    isAuthenticated: true,
+                    pubkey
+                }
+            });
+
+            return {
+                authenticated: true,
+                user: this.currentUser
+            };
+        } catch (error) {
+            logger.error('Login failed:', createErrorMetadata(error));
+            return {
+                authenticated: false,
+                error: error instanceof Error ? error.message : 'Unknown error occurred'
+            } as AuthResult;
+        }
+    }
+
+    /**
+     * Validate the authentication response structure
+     */
+    private isValidAuthResponse(response: any): boolean {
+        try {
+            // Verify core required structure for a valid auth response
+            if (!response || typeof response !== 'object') return false;
+            
+            // Check if we have the required fields
+            const hasRequiredFields = 
+                response.user && 
+                typeof response.user === 'object' &&
+                typeof response.user.pubkey === 'string' &&
+                (
+                    typeof response.user.is_power_user === 'boolean' || 
+                    // Allow these variants that we can convert
+                    response.user.is_power_user === 'true' ||
+                    response.user.is_power_user === 'false' ||
+                    response.user.is_power_user === '1' ||
+                    response.user.is_power_user === '0' ||
+                    response.user.is_power_user === 1 ||
+                    response.user.is_power_user === 0 ||
+                    response.user.is_power_user === null ||
+                    response.user.is_power_user === undefined
+                ) &&
+                typeof response.token === 'string';
+            
+            if (!hasRequiredFields) return false;
+            
+            // Features should be an array if present
+            if (response.features !== undefined && !Array.isArray(response.features)) {
+                return false;
+            }
+            
+            return true;
+        } catch (error) {
+            logger.error('Error validating auth response:', createErrorMetadata(error));
+            return false;
+        }
+    }
+
+    /**
+     * Log out the current user
+     */
+    public async logout(): Promise<void> {
+        const currentPubkey = this.currentUser?.pubkey;
+        const token = localStorage.getItem('nostr_token');
+        const wasLoggedIn = this.isAuthenticated();
+        
+        if (currentPubkey && token) {
+            try {
+                await fetch(buildApiUrl(API_ENDPOINTS.AUTH_NOSTR), {
+                    method: 'DELETE',
+                    headers: {
+                        'Content-Type': 'application/json',
+                    },
+                    body: JSON.stringify({
+                        pubkey: currentPubkey,
+                        token
+                    })
+                });
+            } catch (error) {
+                logger.error('Logout request failed:', createErrorMetadata(error));
+            }
+        }
+
+        localStorage.removeItem('nostr_pubkey');
+        localStorage.removeItem('nostr_token');
+        this.currentUser = null;
+        
+        // Update settings store login status
+        this.settingsStore.setUserLoggedIn(false);
+        
+        this.settingsPersistence.setCurrentUser(null, false);
+        this.eventEmitter.emit(SettingsEventType.AUTH_STATE_CHANGED, {
+            authState: {
+                isAuthenticated: false
+            }
+        });
+
+        // If user was using server settings, revert to local settings
+        if (wasLoggedIn) {
+            await this.settingsPersistence.loadSettings();
+            await this.settingsStore.initialize(); // Reinitialize UI store
+        }
+    }
+
+    /**
+     * Get the current authenticated user
+     */
+    public getCurrentUser(): NostrUser | null {
+        return this.currentUser;
+    }
+
+    /**
+     * Check if the current user is authenticated
+     */
+    public isAuthenticated(): boolean {
+        return this.currentUser !== null;
+    }
+
+    /**
+     * Check if the current user is a power user
+     */
+    public isPowerUser(): boolean {
+        return this.currentUser?.isPowerUser || false;
+    }
+
+    /**
+     * Check if the current user has access to a specific feature
+     */
+    public hasFeatureAccess(feature: string): boolean {
+        return this.currentUser?.features.includes(feature) || false;
+    }
+
+    /**
+     * Check authentication status with the server
+     */
+    private async checkAuthStatus(pubkey: string): Promise<void> {
+        const token = localStorage.getItem('nostr_token');
+        if (!token) {
+            // No token, so logout
+            await this.logout();
+            return;
+        }
+
+        try {
+            const response = await fetch(buildApiUrl(API_ENDPOINTS.AUTH_NOSTR_VERIFY), {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/json',
+                },
+                body: JSON.stringify({
+                    pubkey,
+                    token
+                })
+            });
+
+            if (!response.ok) {
+                throw new Error('Authentication check failed');
+            }
+
+            const verifyData = await response.json() as Partial<AuthResponse>;
+
+            // Log the verification response for debugging
+            logger.debug('Auth verification response:', createDataMetadata(verifyData));
+            
+            // Validate verify response data
+            if (!verifyData || typeof verifyData.valid !== 'boolean') {
+                throw new Error('Invalid verification response from server');
+            }
+
+            if (!verifyData.valid) {
+                logger.error('Invalid session from server:', createDataMetadata(verifyData));
+                throw new Error('Invalid session');
+            }
+
+            logger.debug('Auth check successful:', createDataMetadata({
+                pubkey,
+                isPowerUser: verifyData.user?.is_power_user
+            }));
+
+            // If user data is missing, log warning and logout
+            if (!verifyData.user) {
+                logger.warn('Valid verification but no user data provided');
+                await this.logout();
+                return;
+            }
+
+            // Set currentUser before emitting event
+            this.currentUser = {
+                pubkey,
+                isPowerUser: verifyData.user.is_power_user,
+                features: verifyData.features || []
+            };
+            
+            // Update persistence service with verified user
+            this.settingsPersistence.setCurrentUser(pubkey, verifyData.user.is_power_user);
+            
+            // Load server settings since user is authenticated
+            this.settingsStore.setUserLoggedIn(true);
+            const settingsLoaded = await this.settingsStore.loadServerSettings();
+            
+            // Update settings manager with server settings
+            settingsManager.updateSettingsFromServer();
+
+            // Force refresh of visualization with new settings
+            try {
+                const visualizationController = VisualizationController.getInstance();
+                const currentSettings = this.settingsStore.get('') as Settings;
+                logger.info('Refreshing visualization with server settings after auth check');
+                visualizationController.refreshSettings(currentSettings);
+            } catch (error) {
+                logger.warn('Failed to refresh visualization settings:', createErrorMetadata(error));
+            }
+            
+            if (!settingsLoaded) {
+                logger.warn('Failed to load server settings after auth check, using defaults');
+            } else {
+                logger.info('Successfully loaded server settings after auth check');
+            }
+        } catch (error) {
+            logger.error('Auth check failed:', createErrorMetadata(error));
+            await this.logout();
+        }
+    }
+
+    /**
+     * Subscribe to authentication state changes
+     */
+    public onAuthStateChanged(callback: (state: { authenticated: boolean; user?: NostrUser }) => void): () => void {
+        return this.eventEmitter.on(SettingsEventType.AUTH_STATE_CHANGED, (data) => {
+            callback({
+                authenticated: data.authState?.isAuthenticated || false,
+                user: this.currentUser || undefined
+            });
+        });
+    }
+}
+
+// Export singleton instance
+export const nostrAuth = NostrAuthService.getInstance();
\ No newline at end of file
diff --git a/client/services/SettingsEventEmitter.ts b/client/services/SettingsEventEmitter.ts
new file mode 100644
index 00000000..e36a56c4
--- /dev/null
+++ b/client/services/SettingsEventEmitter.ts
@@ -0,0 +1,151 @@
+import { createLogger, createErrorMetadata, createDataMetadata } from '../core/logger';
+import { Settings } from '../types/settings/base';
+import { ValidationError } from '../types/settings/validation';
+
+const logger = createLogger('SettingsEventEmitter');
+
+export enum SettingsEventType {
+    SETTINGS_LOADED = 'settings:loaded',
+    SETTINGS_SAVED = 'settings:saved',
+    SETTINGS_CHANGED = 'settings:changed',
+    SETTINGS_ERROR = 'settings:error',
+    SETTINGS_SYNCED = 'settings:synced',
+    SETTINGS_VALIDATION_ERROR = 'settings:validation_error',
+    SECTION_DETACHED = 'section:detached',
+    SECTION_DOCKED = 'section:docked',
+    SECTION_MOVED = 'section:moved',
+    SECTION_RESIZED = 'section:resized',
+    SECTION_COLLAPSED = 'section:collapsed',
+    SECTION_EXPANDED = 'section:expanded',
+    LAYOUT_CHANGED = 'layout:changed',
+    LAYOUT_SAVED = 'layout:saved',
+    LAYOUT_LOADED = 'layout:loaded',
+    PREVIEW_UPDATED = 'preview:updated',
+    PREVIEW_RESET = 'preview:reset',
+    AUTH_STATE_CHANGED = 'auth:state_changed'
+}
+
+export interface EventData {
+    type: SettingsEventType;
+    path?: string;
+    value?: any;
+    error?: Error;
+    validationErrors?: ValidationError[];
+    sectionId?: string;
+    position?: { x: number; y: number };
+    size?: { width: number; height: number };
+    layout?: any;
+    settings?: Partial<Settings>;
+    authState?: {
+        isAuthenticated: boolean;
+        pubkey?: string;
+    };
+}
+
+export type EventCallback = (data: EventData) => void;
+
+export class SettingsEventEmitter {
+    private static instance: SettingsEventEmitter | null = null;
+    private listeners: Map<SettingsEventType, Set<EventCallback>>;
+    private lastEvents: Map<SettingsEventType, EventData>;
+
+    private constructor() {
+        this.listeners = new Map();
+        this.lastEvents = new Map();
+    }
+
+    public static getInstance(): SettingsEventEmitter {
+        if (!SettingsEventEmitter.instance) {
+            SettingsEventEmitter.instance = new SettingsEventEmitter();
+        }
+        return SettingsEventEmitter.instance;
+    }
+
+    public on(event: SettingsEventType, callback: EventCallback): () => void {
+        if (!this.listeners.has(event)) {
+            this.listeners.set(event, new Set());
+        }
+
+        const callbacks = this.listeners.get(event)!;
+        callbacks.add(callback);
+
+        // Call with last event data if available
+        const lastEvent = this.lastEvents.get(event);
+        if (lastEvent) {
+            try {
+                callback(lastEvent);
+            } catch (error) {
+                logger.error(`Error in event listener for ${event}:`, createErrorMetadata(error));
+            }
+        }
+
+        // Return unsubscribe function
+        return () => {
+            const callbacks = this.listeners.get(event);
+            if (callbacks) {
+                callbacks.delete(callback);
+                if (callbacks.size === 0) {
+                    this.listeners.delete(event);
+                }
+            }
+        };
+    }
+
+    public emit(event: SettingsEventType, data: Omit<EventData, 'type'>): void {
+        const eventData: EventData = { type: event, ...data };
+        
+        // Store last event data
+        this.lastEvents.set(event, eventData);
+
+        const callbacks = this.listeners.get(event);
+        if (callbacks) {
+            callbacks.forEach(callback => {
+                try {
+                    callback(eventData);
+                } catch (error) {
+                    logger.error(`Error in event listener for ${event}:`, createErrorMetadata(error));
+                }
+            });
+        }
+
+        // Log significant events
+        switch (event) {
+            case SettingsEventType.SETTINGS_ERROR:
+            case SettingsEventType.SETTINGS_VALIDATION_ERROR:
+                logger.error(`${event}:`, createDataMetadata({
+                    error: data.error,
+                    validationErrors: data.validationErrors
+                }));
+                break;
+            case SettingsEventType.SETTINGS_LOADED:
+            case SettingsEventType.SETTINGS_SAVED:
+            case SettingsEventType.SETTINGS_SYNCED:
+                logger.info(`${event} completed`);
+                break;
+            case SettingsEventType.AUTH_STATE_CHANGED:
+                logger.info('Authentication state changed:', createDataMetadata(data.authState));
+                break;
+        }
+    }
+
+    public getLastEvent(event: SettingsEventType): EventData | undefined {
+        return this.lastEvents.get(event);
+    }
+
+    public clearLastEvent(event: SettingsEventType): void {
+        this.lastEvents.delete(event);
+    }
+
+    public clearAllListeners(): void {
+        this.listeners.clear();
+    }
+
+    public dispose(): void {
+        this.clearAllListeners();
+        this.lastEvents.clear();
+        SettingsEventEmitter.instance = null;
+    }
+}
+
+// Create a singleton instance for easy access
+export const settingsEvents = SettingsEventEmitter.getInstance();
\ No newline at end of file
diff --git a/client/services/SettingsLayoutManager.ts b/client/services/SettingsLayoutManager.ts
new file mode 100644
index 00000000..88d04324
--- /dev/null
+++ b/client/services/SettingsLayoutManager.ts
@@ -0,0 +1,233 @@
+import { createLogger, createErrorMetadata } from '../core/logger';
+import { settingsEvents, SettingsEventType } from './SettingsEventEmitter';
+import { SettingVisibility } from '../settings';
+
+const logger = createLogger('SettingsLayoutManager');
+
+export interface SectionLayout {
+    id: string;
+    isDetached: boolean;
+    isCollapsed: boolean;
+    isAdvanced: boolean;
+    visibility: SettingVisibility;
+    position?: { x: number; y: number };
+    size?: { width: number; height: number };
+    order: number;
+}
+
+export interface PanelLayout {
+    sections: Record<string, SectionLayout>;
+    version: string;
+    timestamp: number;
+    pubkey?: string;
+}
+
+export class SettingsLayoutManager {
+    private static instance: SettingsLayoutManager | null = null;
+    private readonly LOCAL_STORAGE_KEY = 'logseq_spring_panel_layout';
+    private readonly LAYOUT_VERSION = '1.0.0';
+    private currentLayout: PanelLayout;
+    private currentPubkey: string | null = null;
+
+    private constructor() {
+        this.currentLayout = this.createDefaultLayout();
+        this.initializeLayoutManager();
+    }
+
+    public static getInstance(): SettingsLayoutManager {
+        if (!SettingsLayoutManager.instance) {
+            SettingsLayoutManager.instance = new SettingsLayoutManager();
+        }
+        return SettingsLayoutManager.instance;
+    }
+
+    private initializeLayoutManager(): void {
+        // Listen for section events
+        settingsEvents.on(SettingsEventType.SECTION_DETACHED, ({ sectionId, position, size }) => {
+            if (sectionId) {
+                this.updateSectionLayout(sectionId, { isDetached: true, position, size });
+            }
+        });
+
+        settingsEvents.on(SettingsEventType.SECTION_DOCKED, ({ sectionId }) => {
+            if (sectionId) {
+                this.updateSectionLayout(sectionId, { isDetached: false });
+            }
+        });
+
+        settingsEvents.on(SettingsEventType.SECTION_MOVED, ({ sectionId, position }) => {
+            if (sectionId && position) {
+                this.updateSectionLayout(sectionId, { position });
+            }
+        });
+
+        settingsEvents.on(SettingsEventType.SECTION_RESIZED, ({ sectionId, size }) => {
+            if (sectionId && size) {
+                this.updateSectionLayout(sectionId, { size });
+            }
+        });
+
+        settingsEvents.on(SettingsEventType.SECTION_COLLAPSED, ({ sectionId }) => {
+            if (sectionId) {
+                this.updateSectionLayout(sectionId, { isCollapsed: true });
+            }
+        });
+
+        settingsEvents.on(SettingsEventType.SECTION_EXPANDED, ({ sectionId }) => {
+            if (sectionId) {
+                this.updateSectionLayout(sectionId, { isCollapsed: false });
+            }
+        });
+
+        // Listen for auth state changes
+        settingsEvents.on(SettingsEventType.AUTH_STATE_CHANGED, ({ authState }) => {
+            if (authState) {
+                this.setCurrentPubkey(authState.isAuthenticated ? authState.pubkey ?? null : null);
+            }
+        });
+    }
+
+    private createDefaultLayout(): PanelLayout {
+        return {
+            sections: {
+                visualization: {
+                    id: 'visualization',
+                    isDetached: false,
+                    isCollapsed: false,
+                    isAdvanced: false,
+                    visibility: SettingVisibility.Basic,
+                    order: 0
+                },
+                physics: {
+                    id: 'physics',
+                    isDetached: false,
+                    isCollapsed: true,
+                    isAdvanced: true,
+                    visibility: SettingVisibility.Advanced,
+                    order: 1
+                },
+                rendering: {
+                    id: 'rendering',
+                    isDetached: false,
+                    isCollapsed: true,
+                    isAdvanced: true,
+                    visibility: SettingVisibility.Advanced,
+                    order: 2
+                },
+                system: {
+                    id: 'system',
+                    isDetached: false,
+                    isCollapsed: true,
+                    isAdvanced: true,
+                    visibility: SettingVisibility.Advanced,
+                    order: 3
+                },
+                xr: {
+                    id: 'xr',
+                    isDetached: false,
+                    isCollapsed: true,
+                    isAdvanced: false,
+                    visibility: SettingVisibility.Basic,
+                    order: 4
+                }
+            },
+            version: this.LAYOUT_VERSION,
+            timestamp: Date.now()
+        };
+    }
+
+    public setCurrentPubkey(pubkey: string | null): void {
+        this.currentPubkey = pubkey;
+        this.loadLayout();
+    }
+
+    private updateSectionLayout(sectionId: string, updates: Partial<SectionLayout>): void {
+        const section = this.currentLayout.sections[sectionId];
+        if (section) {
+            Object.assign(section, updates);
+            this.saveLayout();
+            settingsEvents.emit(SettingsEventType.LAYOUT_CHANGED, {
+                layout: this.currentLayout
+            });
+        }
+    }
+
+    public getSectionLayout(sectionId: string): SectionLayout | undefined {
+        return this.currentLayout.sections[sectionId];
+    }
+
+    public getAllSectionLayouts(): Record<string, SectionLayout> {
+        return { ...this.currentLayout.sections };
+    }
+
+    public async saveLayout(): Promise<void> {
+        try {
+            this.currentLayout.timestamp = Date.now();
+            if (this.currentPubkey) {
+                this.currentLayout.pubkey = this.currentPubkey;
+            }
+
+            localStorage.setItem(
+                this.LOCAL_STORAGE_KEY,
+                JSON.stringify(this.currentLayout)
+            );
+
+            settingsEvents.emit(SettingsEventType.LAYOUT_SAVED, {
+                layout: this.currentLayout
+            });
+
+            logger.info('Layout saved successfully');
+        } catch (error) {
+            logger.error('Failed to save layout:', createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    public loadLayout(): void {
+        try {
+            const storedJson = localStorage.getItem(this.LOCAL_STORAGE_KEY);
+            if (storedJson) {
+                const stored: PanelLayout = JSON.parse(storedJson);
+
+                // Version check
+                if (stored.version !== this.LAYOUT_VERSION) {
+                    logger.warn('Layout version mismatch, using defaults');
+                    this.currentLayout = this.createDefaultLayout();
+                    return;
+                }
+
+                // Pubkey check
+                if (stored.pubkey && stored.pubkey !== this.currentPubkey) {
+                    logger.warn('Layout pubkey mismatch, using defaults');
+                    this.currentLayout = this.createDefaultLayout();
+                    return;
+                }
+
+                this.currentLayout = stored;
+                settingsEvents.emit(SettingsEventType.LAYOUT_LOADED, {
+                    layout: this.currentLayout
+                });
+                logger.info('Layout loaded successfully');
+            }
+        } catch (error) {
+            logger.error('Failed to load layout:', createErrorMetadata(error));
+            this.currentLayout = this.createDefaultLayout();
+        }
+    }
+
+    public resetLayout(): void {
+        this.currentLayout = this.createDefaultLayout();
+        this.saveLayout();
+        settingsEvents.emit(SettingsEventType.LAYOUT_LOADED, {
+            layout: this.currentLayout
+        });
+        logger.info('Layout reset to defaults');
+    }
+
+    public dispose(): void {
+        SettingsLayoutManager.instance = null;
+    }
+}
+
+// Create a singleton instance for easy access
+export const layoutManager = SettingsLayoutManager.getInstance();
\ No newline at end of file
diff --git a/client/services/SettingsPersistenceService.ts b/client/services/SettingsPersistenceService.ts
new file mode 100644
index 00000000..2e761194
--- /dev/null
+++ b/client/services/SettingsPersistenceService.ts
@@ -0,0 +1,355 @@
+import { Settings } from '../types/settings/base';
+import { defaultSettings } from '../state/defaultSettings';
+import { createLogger, createErrorMetadata, createDataMetadata } from '../core/logger';
+import { validateSettings } from '../types/settings/validation';
+import { buildApiUrl, getAuthHeaders } from '../core/api';
+import { API_ENDPOINTS } from '../core/constants';
+
+const logger = createLogger('SettingsPersistenceService');
+
+export interface StoredSettings {
+    settings: Settings;
+    timestamp: number;
+    version: string;
+    pubkey?: string;
+}
+
+export class SettingsPersistenceService {
+    private static instance: SettingsPersistenceService | null = null;
+    private readonly LOCAL_STORAGE_KEY = 'logseq_spring_settings';
+    private readonly SETTINGS_VERSION = '1.0.0';
+    private isPowerUser: boolean = false;
+    private currentPubkey: string | null = null;
+
+    private constructor() {}
+
+    public static getInstance(): SettingsPersistenceService {
+        if (!SettingsPersistenceService.instance) {
+            SettingsPersistenceService.instance = new SettingsPersistenceService();
+        }
+        return SettingsPersistenceService.instance;
+    }
+
+    public setCurrentUser(pubkey: string | null, isPowerUser: boolean = false): void {
+        this.currentPubkey = pubkey;
+        this.isPowerUser = isPowerUser;
+        logger.debug('User state updated:', createDataMetadata({ pubkey, isPowerUser }));
+    }
+
+    public async saveSettings(settings: Settings): Promise<void> {
+        try {
+            // Validate settings before saving
+            const validation = validateSettings(settings);
+            if (!validation.isValid) {
+                throw new Error(`Invalid settings: ${JSON.stringify(validation.errors)}`);
+            }
+
+            const storedSettings: StoredSettings = {
+                settings,
+                timestamp: Date.now(),
+                version: this.SETTINGS_VERSION,
+                pubkey: this.currentPubkey ?? undefined
+            };
+
+            // Save locally
+            localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(storedSettings));
+
+            // Always sync to server, endpoint depends on auth status
+            try {
+                await this.syncToServer(storedSettings);
+            } catch (error) {
+                logger.warn('Failed to sync settings to server:', createErrorMetadata(error));
+            }
+
+            logger.info('Settings saved successfully');
+        } catch (error) {
+            logger.error('Failed to save settings:', createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    public async loadSettings(): Promise<Settings> {
+        try {            
+            // First, check local storage for cached settings to avoid waiting for server
+            const storedJson = localStorage.getItem(this.LOCAL_STORAGE_KEY);
+            let cachedSettings: Settings | null = null;
+            
+            if (storedJson) {
+                try {
+                    const stored: StoredSettings = JSON.parse(storedJson);
+                    
+                    // Version check
+                    if (stored.version !== this.SETTINGS_VERSION) {
+                        logger.warn('Settings version mismatch, will try to migrate');
+                        cachedSettings = this.migrateSettings(stored.settings);
+                    } 
+                    // Pubkey check
+                    else if (stored.pubkey && stored.pubkey !== this.currentPubkey) {
+                        logger.warn('Settings pubkey mismatch:', createDataMetadata({
+                            stored: stored.pubkey,
+                            current: this.currentPubkey
+                        }));
+                        // Don't use these settings, but don't set cachedSettings to null
+                    } else {
+                        // Validate loaded settings
+                        const validation = validateSettings(stored.settings);
+                        if (validation.isValid) {
+                            cachedSettings = stored.settings;
+                            logger.debug('Using cached settings while fetching from server');
+                        } else {
+                            logger.warn('Invalid stored settings, will try server');
+                        }
+                    }
+                } catch (parseError) {
+                    logger.warn('Failed to parse stored settings:', createErrorMetadata(parseError));
+                }
+            }
+            
+            // Start server request in parallel, but don't wait for it to complete before returning cached settings
+            const serverPromise = (async () => {
+                try {
+                    // Use public settings endpoint if not authenticated
+                    if (!this.currentPubkey) {
+                        logger.debug('No pubkey available, loading public settings');
+                        return await this.loadPublicSettings();
+                    } else {
+                        const serverSettings = await this.loadFromServer();
+                        if (serverSettings) {                        
+                            return serverSettings;
+                        }
+                    }
+                } catch (error) {
+                    logger.warn('Failed to load settings from server:', createErrorMetadata(error));
+                    throw error;
+                }
+                return null;
+            })();
+            
+            // If we have cached settings, return them immediately and update in background
+            if (cachedSettings) {
+                // Update from server in background
+                serverPromise.then(serverSettings => {
+                    if (serverSettings) {
+                        // Store updated settings in local storage
+                        const storedSettings = { 
+                            settings: serverSettings, 
+                            timestamp: Date.now(), 
+                            version: this.SETTINGS_VERSION, 
+                            pubkey: this.currentPubkey 
+                        };
+                        localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(storedSettings));
+                        logger.info('Updated cached settings from server in background');
+                    }
+                }).catch(error => {
+                    logger.warn('Background settings update failed:', createErrorMetadata(error));
+                });
+                
+                return cachedSettings;
+            }
+            
+            // If no cached settings, wait for server response
+            try {
+                const serverSettings = await serverPromise;
+                if (serverSettings) {
+                    return serverSettings;
+                }
+            } catch (error) {
+                logger.warn('Failed to load settings from server after cache miss:', createErrorMetadata(error));
+            }
+
+            // No cached settings and server failed, use defaults
+            logger.info('Using default settings as fallback');
+            return { ...defaultSettings };
+        } catch (error) {
+            logger.error('Failed to load settings:', createErrorMetadata(error));
+            return { ...defaultSettings };
+        }
+    }
+
+    private async syncToServer(storedSettings: StoredSettings): Promise<void> {
+        const MAX_RETRIES = 3;
+        const INITIAL_TIMEOUT = 5000; // 5 seconds
+        const MAX_TIMEOUT = 30000; // 30 seconds
+        let retryCount = 0;
+        let timeout = INITIAL_TIMEOUT;
+
+        while (retryCount <= MAX_RETRIES) {
+            try {
+                // Use different endpoint based on auth status
+                // Power users use /settings to modify global settings
+                // Regular users use /settings/sync for their personal settings
+                const endpoint = this.isPowerUser ? 
+                    API_ENDPOINTS.SETTINGS_ROOT : 
+                    `${API_ENDPOINTS.SETTINGS_ROOT}/sync`;
+
+                logger.debug(`Syncing settings to server (attempt ${retryCount + 1}/${MAX_RETRIES + 1})`);
+                
+                // Create an AbortController for timeout
+                const controller = new AbortController();
+                const timeoutId = setTimeout(() => controller.abort(), timeout);
+                
+                const response = await fetch(buildApiUrl(endpoint), {
+                    method: 'POST',
+                    headers: getAuthHeaders(),
+                    body: JSON.stringify(storedSettings.settings),
+                    signal: controller.signal
+                }).finally(() => clearTimeout(timeoutId));
+
+                if (!response.ok) {
+                    const errorText = await response.text();
+                    if (response.status === 403) {
+                        throw new Error(`Permission denied: ${this.isPowerUser ? 'Power user validation failed' : 'Regular user attempted to modify global settings'}`);
+                    } else {
+                        throw new Error(`Server returned ${response.status}: ${errorText}`);
+                    }
+                }
+
+                logger.info('Settings synced to server successfully');
+                return; // Success - exit the retry loop
+            } catch (error) {
+                retryCount++;
+                
+                if (error instanceof DOMException && error.name === 'AbortError') {
+                    logger.warn(`Settings sync timed out after ${timeout}ms`);
+                } else {
+                    logger.error('Failed to sync settings to server:', createErrorMetadata(error));
+                }
+                
+                if (retryCount <= MAX_RETRIES) {
+                    // Exponential backoff with jitter
+                    const jitter = Math.random() * 1000;
+                    timeout = Math.min(timeout * 1.5 + jitter, MAX_TIMEOUT);
+                    logger.info(`Retrying settings sync in ${Math.round(timeout/1000)}s (attempt ${retryCount + 1}/${MAX_RETRIES + 1})`);
+                    await new Promise(resolve => setTimeout(resolve, timeout));
+                } else {
+                    logger.error(`Failed to sync settings after ${MAX_RETRIES + 1} attempts`);
+                    throw error;
+                }
+            }
+        }
+    }
+
+    private async loadPublicSettings(): Promise<Settings> {
+        try {
+            const response = await fetch(buildApiUrl(API_ENDPOINTS.SETTINGS_ROOT), {
+                method: 'GET',
+                headers: getAuthHeaders()
+            });
+
+            if (!response.ok) {
+                throw new Error(`Server returned ${response.status}: ${await response.text()}`);
+            }
+
+            const settings = await response.json() as Settings;
+            
+            // Additional validation for required sections
+            if (!settings || !settings.system || !settings.xr) {
+                logger.error('Invalid server settings: Missing required sections');
+                return { ...defaultSettings };
+            }
+
+            const validation = validateSettings(settings);
+            if (!validation.isValid) {
+                throw new Error(`Invalid server settings: ${JSON.stringify(validation.errors)}`);
+            }
+
+            return settings;
+        } catch (error) {
+            logger.error('Failed to load public settings:', createErrorMetadata(error));
+            return { ...defaultSettings };
+        }
+    }
+
+    private async loadFromServer(): Promise<Settings | null> {
+        const TIMEOUT = 8000; // 8 seconds timeout for loading settings
+        
+        try {
+            // Use different endpoint based on auth status
+            // Power users get global settings from /settings
+            // Regular users get personal settings from /settings/sync
+            const endpoint = this.isPowerUser ? 
+                API_ENDPOINTS.SETTINGS_ROOT : 
+                `${API_ENDPOINTS.SETTINGS_ROOT}/sync`;
+
+            // Create an AbortController for timeout
+            const controller = new AbortController();
+            const timeoutId = setTimeout(() => controller.abort(), TIMEOUT);
+            
+            logger.debug(`Loading settings from server with ${TIMEOUT}ms timeout`);
+            const response = await fetch(buildApiUrl(endpoint), {
+                headers: getAuthHeaders(),
+                signal: controller.signal
+            }).finally(() => clearTimeout(timeoutId));
+
+            if (!response.ok) {
+                if (response.status === 404) {
+                    return null;
+                }
+                const errorText = await response.text();
+                if (response.status === 403) {
+                    throw new Error(`Permission denied: ${this.isPowerUser ? 'Power user validation failed' : 'Regular user attempted to access global settings'}`);
+                } else {
+                    throw new Error(`Server returned ${response.status}: ${errorText}`);
+                }
+            }
+
+            const serverSettings = await response.json() as Settings;
+            
+            // Additional validation for required sections
+            if (!serverSettings || !serverSettings.system || !serverSettings.xr) {
+                logger.error('Invalid server settings: Missing required sections');
+                throw new Error('Server returned invalid settings structure');
+            }
+
+            // Validate server settings
+            const validation = validateSettings(serverSettings);
+            if (!validation.isValid) {
+                throw new Error(`Invalid server settings: ${JSON.stringify(validation.errors)}`);
+            }
+
+            // Store in local storage with version and pubkey
+            const storedSettings = { settings: serverSettings, timestamp: Date.now(), version: this.SETTINGS_VERSION, pubkey: this.currentPubkey };
+            localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(storedSettings));
+            logger.info('Successfully loaded and cached settings from server');
+
+            return serverSettings;
+        } catch (error) {
+            if (error instanceof DOMException && error.name === 'AbortError') {
+                logger.error(`Settings load timed out after ${TIMEOUT}ms`);
+                throw new Error(`Settings load timed out after ${TIMEOUT}ms`);
+            }
+            logger.error('Failed to load settings from server:', createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    private migrateSettings(oldSettings: Settings): Settings {
+        // Implement version-specific migrations here
+        logger.info('Migrating settings from older version');
+        
+        // For now, just merge with defaults
+        return {
+            ...defaultSettings,
+            ...oldSettings,
+            // Ensure critical sections are preserved
+            system: {
+                ...defaultSettings.system,
+                ...oldSettings.system
+            },
+            xr: {
+                ...defaultSettings.xr,
+                ...oldSettings.xr
+            }
+        };
+    }
+
+    public clearSettings(): void {
+        localStorage.removeItem(this.LOCAL_STORAGE_KEY);
+        this.isPowerUser = false;  // Reset power user status on clear
+        logger.info('Settings cleared');
+    }
+
+    public dispose(): void {
+        SettingsPersistenceService.instance = null;
+    }
+}
\ No newline at end of file
diff --git a/client/services/SettingsPreviewManager.ts b/client/services/SettingsPreviewManager.ts
new file mode 100644
index 00000000..ac7c70b7
--- /dev/null
+++ b/client/services/SettingsPreviewManager.ts
@@ -0,0 +1,182 @@
+import { createLogger, createErrorMetadata } from '../core/logger';
+import { settingsEvents, SettingsEventType } from './SettingsEventEmitter';
+import { VisualizationController } from '../rendering/VisualizationController';
+import { Settings } from '../types/settings/base';
+
+const logger = createLogger('SettingsPreviewManager');
+
+type VisualizationCategory = 'visualization' | 'physics' | 'rendering';
+
+export interface PreviewState {
+    originalSettings: Partial<Settings>;
+    previewSettings: Partial<Settings>;
+    isPreviewActive: boolean;
+    previewTimeout: number | null;
+}
+
+export class SettingsPreviewManager {
+    private static instance: SettingsPreviewManager | null = null;
+    private visualizationController: VisualizationController;
+    private readonly UPDATE_DELAY = 16; // ~60fps
+    private previewStates: Map<VisualizationCategory, PreviewState>;
+
+    private constructor() {
+        this.visualizationController = VisualizationController.getInstance();
+        this.previewStates = new Map();
+        this.initializePreviewManager();
+    }
+
+    public static getInstance(): SettingsPreviewManager {
+        if (!SettingsPreviewManager.instance) {
+            SettingsPreviewManager.instance = new SettingsPreviewManager();
+        }
+        return SettingsPreviewManager.instance;
+    }
+
+    private initializePreviewManager(): void {
+        // Listen for settings changes
+        settingsEvents.on(SettingsEventType.SETTINGS_CHANGED, ({ path, value }) => {
+            if (path) {
+                this.handleSettingChange(path, value);
+            }
+        });
+
+        // Listen for preview reset events
+        settingsEvents.on(SettingsEventType.PREVIEW_RESET, ({ path }) => {
+            if (path) {
+                const category = this.getCategoryFromPath(path);
+                if (category) {
+                    this.resetPreview(category);
+                }
+            }
+        });
+    }
+
+    private getCategoryFromPath(path: string): VisualizationCategory | null {
+        const category = path.split('.')[0];
+        if (['visualization', 'physics', 'rendering'].includes(category)) {
+            return category as VisualizationCategory;
+        }
+        return null;
+    }
+
+    private handleSettingChange(path: string, value: any): void {
+        const category = this.getCategoryFromPath(path);
+        if (!category) return;
+
+        let previewState = this.previewStates.get(category);
+
+        if (!previewState) {
+            previewState = {
+                originalSettings: {},
+                previewSettings: {},
+                isPreviewActive: false,
+                previewTimeout: null
+            };
+            this.previewStates.set(category, previewState);
+        }
+
+        // Store original value if not already stored
+        if (!previewState.isPreviewActive) {
+            previewState.originalSettings = this.visualizationController.getSettings(category);
+            previewState.isPreviewActive = true;
+        }
+
+        // Update preview settings
+        this.updatePreviewSettings(previewState, path, value);
+
+        // Debounce preview update
+        if (previewState.previewTimeout !== null) {
+            window.clearTimeout(previewState.previewTimeout);
+        }
+
+        previewState.previewTimeout = window.setTimeout(() => {
+            this.applyPreview(category, previewState);
+            previewState.previewTimeout = null;
+        }, this.UPDATE_DELAY);
+    }
+
+    private updatePreviewSettings(state: PreviewState, path: string, value: any): void {
+        const parts = path.split('.');
+        let current = state.previewSettings as any;
+
+        // Create nested structure
+        for (let i = 0; i < parts.length - 1; i++) {
+            const part = parts[i];
+            if (!(part in current)) {
+                current[part] = {};
+            }
+            current = current[part];
+        }
+
+        // Set the value
+        current[parts[parts.length - 1]] = value;
+    }
+
+    private applyPreview(category: VisualizationCategory, state: PreviewState): void {
+        try {
+            // Apply preview settings to visualization
+            this.visualizationController.updateSettings(category, state.previewSettings);
+
+            // Emit preview updated event
+            settingsEvents.emit(SettingsEventType.PREVIEW_UPDATED, {
+                path: category,
+                value: state.previewSettings
+            });
+
+            logger.debug(`Preview applied for ${category}`);
+        } catch (error) {
+            logger.error(`Failed to apply preview for ${category}:`, createErrorMetadata(error));
+            this.resetPreview(category);
+        }
+    }
+
+    public resetPreview(category: VisualizationCategory): void {
+        const state = this.previewStates.get(category);
+        if (state?.isPreviewActive) {
+            try {
+                // Clear any pending preview
+                if (state.previewTimeout !== null) {
+                    window.clearTimeout(state.previewTimeout);
+                    state.previewTimeout = null;
+                }
+
+                // Restore original settings
+                this.visualizationController.updateSettings(category, state.originalSettings);
+
+                // Reset state
+                state.previewSettings = {};
+                state.isPreviewActive = false;
+
+                logger.debug(`Preview reset for ${category}`);
+            } catch (error) {
+                logger.error(`Failed to reset preview for ${category}:`, createErrorMetadata(error));
+            }
+        }
+    }
+
+    public resetAllPreviews(): void {
+        ['visualization', 'physics', 'rendering'].forEach(category => {
+            this.resetPreview(category as VisualizationCategory);
+        });
+    }
+
+    public isPreviewActive(category: VisualizationCategory): boolean {
+        const state = this.previewStates.get(category);
+        return state?.isPreviewActive ?? false;
+    }
+
+    public getPreviewSettings(category: VisualizationCategory): Partial<Settings> | null {
+        const state = this.previewStates.get(category);
+        return state?.isPreviewActive ? state.previewSettings : null;
+    }
+
+    public dispose(): void {
+        this.resetAllPreviews();
+        this.previewStates.clear();
+        SettingsPreviewManager.instance = null;
+    }
+}
+
+// Create a singleton instance for easy access
+export const previewManager = SettingsPreviewManager.getInstance();
\ No newline at end of file
diff --git a/client/settings/index.ts b/client/settings/index.ts
new file mode 100644
index 00000000..3d8f18d9
--- /dev/null
+++ b/client/settings/index.ts
@@ -0,0 +1,6 @@
+export enum SettingVisibility {
+    Basic = 'basic',
+    Advanced = 'advanced',
+    Debug = 'debug',
+    Hidden = 'hidden'
+}
\ No newline at end of file
diff --git a/client/shader-test.html b/client/shader-test.html
new file mode 100644
index 00000000..68be8f11
--- /dev/null
+++ b/client/shader-test.html
@@ -0,0 +1,152 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>WebGL Shader Compatibility Test</title>
+    <style>
+        body {
+            font-family: Arial, sans-serif;
+            margin: 20px;
+            line-height: 1.6;
+        }
+        .container {
+            max-width: 800px;
+            margin: 0 auto;
+        }
+        .result {
+            margin-top: 20px;
+            padding: 15px;
+            border-radius: 5px;
+            background-color: #f5f5f5;
+        }
+        .success {
+            color: green;
+            font-weight: bold;
+        }
+        .error {
+            color: red;
+            font-weight: bold;
+        }
+        pre {
+            background-color: #f0f0f0;
+            padding: 10px;
+            border-radius: 5px;
+            overflow-x: auto;
+        }
+        button {
+            padding: 10px 15px;
+            background-color: #4CAF50;
+            color: white;
+            border: none;
+            border-radius: 4px;
+            cursor: pointer;
+            font-size: 16px;
+            margin-top: 10px;
+        }
+        button:hover {
+            background-color: #45a049;
+        }
+    </style>
+</head>
+<body>
+    <div class="container">
+        <h1>WebGL Shader Compatibility Test</h1>
+        <p>This page tests if the modified shaders in UnifiedTextRenderer.ts will compile correctly in your browser's WebGL context.</p>
+        
+        <button id="runTest">Run Shader Test</button>
+        
+        <div id="result" class="result">
+            <p>Click the button above to run the test.</p>
+        </div>
+        
+        <h2>WebGL Information</h2>
+        <div id="webglInfo"></div>
+        
+        <h2>Modified Shaders</h2>
+        <h3>Vertex Shader</h3>
+        <pre id="vertexShader"></pre>
+        
+        <h3>Fragment Shader</h3>
+        <pre id="fragmentShader"></pre>
+    </div>
+    
+    <script src="shader-test.js"></script>
+    <script>
+        document.getElementById('runTest').addEventListener('click', function() {
+            const resultDiv = document.getElementById('result');
+            resultDiv.innerHTML = '<p>Running shader test...</p>';
+            
+            try {
+                const success = window.testShaders();
+                if (success) {
+                    resultDiv.innerHTML = '<p class="success"> SUCCESS: Modified shaders are compatible with this browser\'s WebGL implementation.</p>';
+                } else {
+                    resultDiv.innerHTML = '<p class="error"> ERROR: Modified shaders are NOT compatible with this browser\'s WebGL implementation. Check the console for details.</p>';
+                }
+            } catch (error) {
+                resultDiv.innerHTML = `<p class="error"> ERROR: Test failed with exception: ${error.message}</p>`;
+                console.error(error);
+            }
+        });
+        
+        // Display WebGL information
+        function displayWebGLInfo() {
+            const infoDiv = document.getElementById('webglInfo');
+            const canvas = document.createElement('canvas');
+            let gl = canvas.getContext('webgl2');
+            let version = 2;
+            
+            if (!gl) {
+                gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
+                version = 1;
+            }
+            
+            if (!gl) {
+                infoDiv.innerHTML = '<p class="error">WebGL is not supported in this browser.</p>';
+                return;
+            }
+            
+            const info = {
+                version: version,
+                vendor: gl.getParameter(gl.VENDOR),
+                renderer: gl.getParameter(gl.RENDERER),
+                glVersion: gl.getParameter(gl.VERSION),
+                shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
+            };
+            
+            let html = '<ul>';
+            for (const [key, value] of Object.entries(info)) {
+                html += `<li><strong>${key}:</strong> ${value}</li>`;
+            }
+            html += '</ul>';
+            
+            infoDiv.innerHTML = html;
+        }
+        
+        // Display shader code
+        function displayShaderCode() {
+            // This function extracts the shader code from shader-test.js
+            fetch('shader-test.js')
+                .then(response => response.text())
+                .then(text => {
+                    const vertexMatch = text.match(/const vertexShader = `([\s\S]*?)`/);
+                    const fragmentMatch = text.match(/const fragmentShader = `([\s\S]*?)`/);
+                    
+                    if (vertexMatch && vertexMatch[1]) {
+                        document.getElementById('vertexShader').textContent = vertexMatch[1].trim();
+                    }
+                    
+                    if (fragmentMatch && fragmentMatch[1]) {
+                        document.getElementById('fragmentShader').textContent = fragmentMatch[1].trim();
+                    }
+                })
+                .catch(error => console.error('Error loading shader code:', error));
+        }
+        
+        // Run on page load
+        displayWebGLInfo();
+        displayShaderCode();
+    </script>
+</body>
+</html>
\ No newline at end of file
diff --git a/client/shader-test.js b/client/shader-test.js
new file mode 100644
index 00000000..91e79a35
--- /dev/null
+++ b/client/shader-test.js
@@ -0,0 +1,197 @@
+/**
+ * Shader Compatibility Test
+ * 
+ * This script tests if the modified shaders in UnifiedTextRenderer.ts
+ * will compile correctly in both WebGL1 and WebGL2 contexts.
+ */
+
+(function() {
+  const logger = {
+    info: (msg, data) => console.log(`[INFO] ${msg}`, data || ''),
+    error: (msg, data) => console.error(`[ERROR] ${msg}`, data || ''),
+    success: (msg) => console.log(`[SUCCESS] ${msg}`)
+  };
+
+  // Modified vertex shader (WebGL1 compatible)
+  const vertexShader = `
+    uniform vec3 cameraPosition;
+    uniform mat4 modelViewMatrix;
+    uniform mat4 projectionMatrix;
+    
+    attribute vec3 position;
+    attribute vec2 uv;
+    attribute vec3 instancePosition;
+    attribute vec4 instanceColor;
+    attribute float instanceScale;
+    
+    varying vec2 vUv;
+    varying vec4 vColor;
+    varying float vScale;
+    varying float vViewDistance;
+    
+    void main() {
+        vUv = uv;
+        vColor = instanceColor;
+        vScale = instanceScale;
+
+        // Scale the position first
+        vec3 scale = vec3(instanceScale);
+        vec3 vertexPosition = position * scale;
+        
+        // Billboard calculation
+        vec3 up = vec3(0.0, 1.0, 0.0);
+        vec3 forward = normalize(cameraPosition - instancePosition);
+        vec3 right = normalize(cross(up, forward));
+        up = normalize(cross(forward, right));
+        
+        mat4 billboardMatrix = mat4(
+            vec4(right, 0.0),
+            vec4(up, 0.0),
+            vec4(forward, 0.0),
+            vec4(0.0, 0.0, 0.0, 1.0)
+        );
+        
+        vertexPosition = (billboardMatrix * vec4(vertexPosition, 1.0)).xyz;
+        vertexPosition += instancePosition;
+        
+        vec4 mvPosition = modelViewMatrix * vec4(vertexPosition, 1.0);
+        vViewDistance = -mvPosition.z;  // Distance from camera
+        gl_Position = projectionMatrix * mvPosition;
+    }
+  `;
+
+  // Modified fragment shader (WebGL1 compatible)
+  const fragmentShader = `
+    precision highp float;
+    
+    uniform sampler2D fontAtlas;
+    uniform float sdfThreshold;
+    uniform float sdfSpread;
+    uniform vec3 outlineColor;
+    uniform float outlineWidth;
+    uniform float fadeStart;
+    uniform float fadeEnd;
+    
+    varying vec2 vUv;
+    varying vec4 vColor;
+    varying float vScale;
+    varying float vViewDistance;
+    
+    float median(float r, float g, float b) {
+        return max(min(r, g), min(max(r, g), b));
+    }
+    
+    void main() {
+        vec3 sample = texture2D(fontAtlas, vUv).rgb;
+        float sigDist = median(sample.r, sample.g, sample.b);
+        
+        // Dynamic threshold based on distance
+        float distanceScale = smoothstep(fadeEnd, fadeStart, vViewDistance);
+        float dynamicThreshold = sdfThreshold * (1.0 + (1.0 - distanceScale) * 0.1);
+        float dynamicSpread = sdfSpread * (1.0 + (1.0 - distanceScale) * 0.2);
+        
+        // Improved antialiasing
+        float alpha = smoothstep(dynamicThreshold - dynamicSpread, 
+                               dynamicThreshold + dynamicSpread, 
+                               sigDist);
+                               
+        float outline = smoothstep(dynamicThreshold - outlineWidth - dynamicSpread,
+                                 dynamicThreshold - outlineWidth + dynamicSpread,
+                                 sigDist);
+        
+        // Apply distance-based fade
+        alpha *= distanceScale;
+        outline *= distanceScale;
+        
+        vec4 color = mix(vec4(outlineColor, outline), vColor, alpha);
+        gl_FragColor = color;
+    }
+  `;
+
+  function testShaderCompilation() {
+    logger.info('Testing shader compilation...');
+    
+    // Create a canvas for testing
+    const canvas = document.createElement('canvas');
+    
+    // Try WebGL2 first
+    let gl = canvas.getContext('webgl2');
+    const isWebGL2 = !!gl;
+    
+    // Fall back to WebGL1 if needed
+    if (!gl) {
+      gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
+      if (!gl) {
+        logger.error('WebGL not supported in this browser');
+        return false;
+      }
+      logger.info('Using WebGL1 context');
+    } else {
+      logger.info('Using WebGL2 context');
+    }
+    
+    try {
+      // Create vertex shader
+      const vs = gl.createShader(gl.VERTEX_SHADER);
+      
+      // Add a note about the test environment
+      logger.info('Note: In a real Three.js environment, modelViewMatrix and projectionMatrix are provided automatically');
+      
+      gl.shaderSource(vs, vertexShader);
+      gl.compileShader(vs);
+      
+      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
+        const info = gl.getShaderInfoLog(vs);
+        throw new Error(`Vertex shader compilation failed: ${info}`);
+      }
+      logger.success('Vertex shader compiled successfully');
+      
+      // Create fragment shader
+      const fs = gl.createShader(gl.FRAGMENT_SHADER);
+      gl.shaderSource(fs, fragmentShader);
+      gl.compileShader(fs);
+      
+      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
+        const info = gl.getShaderInfoLog(fs);
+        throw new Error(`Fragment shader compilation failed: ${info}`);
+      }
+      logger.success('Fragment shader compiled successfully');
+      
+      // Create program
+      const program = gl.createProgram();
+      gl.attachShader(program, vs);
+      gl.attachShader(program, fs);
+      gl.linkProgram(program);
+      
+      // Note: In a real application, we would need to set the uniform values
+      // but for compilation testing, we just need to check if the program links
+      
+      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
+        const info = gl.getProgramInfoLog(program);
+        throw new Error(`Program linking failed: ${info}`);
+      }
+      logger.success('Shader program linked successfully');
+      
+      // Clean up
+      gl.deleteShader(vs);
+      gl.deleteShader(fs);
+      gl.deleteProgram(program);
+      
+      return true;
+    } catch (error) {
+      logger.error('Shader test failed', error.message);
+      return false;
+    }
+  }
+  
+  // Run the test
+  if (testShaderCompilation()) {
+    logger.success('Modified shaders are compatible with this browser\'s WebGL implementation');
+  } else {
+    logger.error('Modified shaders are NOT compatible with this browser\'s WebGL implementation');
+  }
+  
+  // Export to global scope for console access
+  window.testShaders = testShaderCompilation;
+  logger.info('You can run the shader test again by calling testShaders() in the console');
+})();
\ No newline at end of file
diff --git a/client/src/managers/NodeInstanceManager.ts b/client/src/managers/NodeInstanceManager.ts
new file mode 100644
index 00000000..0519ecba
--- /dev/null
+++ b/client/src/managers/NodeInstanceManager.ts
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff --git a/client/state/SettingsObserver.ts b/client/state/SettingsObserver.ts
new file mode 100644
index 00000000..df4657c4
--- /dev/null
+++ b/client/state/SettingsObserver.ts
@@ -0,0 +1,164 @@
+import { SettingsStore } from './SettingsStore';
+import { VisualizationController } from '../rendering/VisualizationController';
+import { createLogger, createErrorMetadata } from '../core/logger';
+
+const logger = createLogger('SettingsObserver');
+
+type SettingsCallback = (path: string, value: any) => void;
+
+export class SettingsObserver {
+    private static instance: SettingsObserver | null = null;
+    private settingsStore: SettingsStore;
+    private visualizationController: VisualizationController;
+    private callbacks: Map<string, Set<SettingsCallback>>;
+    private updateTimeout: number | null = null;
+    private readonly UPDATE_DELAY = 16; // ~60fps
+
+    private constructor() {
+        this.settingsStore = SettingsStore.getInstance();
+        this.visualizationController = VisualizationController.getInstance();
+        this.callbacks = new Map();
+        this.initializeObserver();
+    }
+
+    public static getInstance(): SettingsObserver {
+        if (!SettingsObserver.instance) {
+            SettingsObserver.instance = new SettingsObserver();
+        }
+        return SettingsObserver.instance;
+    }
+
+    private async initializeObserver(): Promise<void> {
+        try {
+            await this.settingsStore.initialize();
+            this.subscribeToSettings();
+            logger.info('Settings observer initialized');
+        } catch (error) {
+            logger.error('Failed to initialize settings observer:', createErrorMetadata(error));
+        }
+    }
+
+    private subscribeToSettings(): void {
+        // Subscribe to all visualization settings
+        this.settingsStore.subscribe('visualization', (path, value) => {
+            this.handleVisualizationUpdate(path, value);
+        });
+
+        // Subscribe to physics settings
+        this.settingsStore.subscribe('physics', (path, value) => {
+            this.handlePhysicsUpdate(path, value);
+        });
+
+        // Subscribe to rendering settings
+        this.settingsStore.subscribe('rendering', (path, value) => {
+            this.handleRenderingUpdate(path, value);
+        });
+
+        // Subscribe to XR settings
+        this.settingsStore.subscribe('xr', (path, value) => {
+            this.handleXRUpdate(path, value);
+        });
+    }
+
+    private handleVisualizationUpdate(path: string, value: any): void {
+        this.debounceUpdate(() => {
+            this.visualizationController.updateSetting(path, value);
+            this.notifyCallbacks(path, value);
+        });
+    }
+
+    private handlePhysicsUpdate(path: string, value: any): void {
+        this.debounceUpdate(() => {
+            this.visualizationController.updateSetting(path, value);
+            this.notifyCallbacks(path, value);
+        });
+    }
+
+    private handleRenderingUpdate(path: string, value: any): void {
+        this.debounceUpdate(() => {
+            this.visualizationController.updateSetting(path, value);
+            this.notifyCallbacks(path, value);
+        });
+    }
+
+    private handleXRUpdate(path: string, value: any): void {
+        // XR updates should be immediate
+        this.visualizationController.updateSetting(path, value);
+        this.notifyCallbacks(path, value);
+    }
+
+    private debounceUpdate(callback: () => void): void {
+        if (this.updateTimeout !== null) {
+            window.clearTimeout(this.updateTimeout);
+        }
+        this.updateTimeout = window.setTimeout(() => {
+            callback();
+            this.updateTimeout = null;
+        }, this.UPDATE_DELAY);
+    }
+
+    public subscribe(path: string, callback: SettingsCallback): () => void {
+        if (!this.callbacks.has(path)) {
+            this.callbacks.set(path, new Set());
+        }
+
+        const callbacks = this.callbacks.get(path)!;
+        callbacks.add(callback);
+
+        // Immediately call with current value
+        const currentValue = this.settingsStore.get(path);
+        if (currentValue !== undefined) {
+            callback(path, currentValue);
+        }
+
+        // Return unsubscribe function
+        return () => {
+            const callbacks = this.callbacks.get(path);
+            if (callbacks) {
+                callbacks.delete(callback);
+                if (callbacks.size === 0) {
+                    this.callbacks.delete(path);
+                }
+            }
+        };
+    }
+
+    private notifyCallbacks(path: string, value: any): void {
+        // Notify callbacks for exact path match
+        const exactCallbacks = this.callbacks.get(path);
+        if (exactCallbacks) {
+            exactCallbacks.forEach(callback => {
+                try {
+                    callback(path, value);
+                } catch (error) {
+                    logger.error(`Error in settings callback for ${path}:`, createErrorMetadata(error));
+                }
+            });
+        }
+
+        // Notify callbacks for parent paths
+        const parts = path.split('.');
+        while (parts.length > 1) {
+            parts.pop();
+            const parentPath = parts.join('.');
+            const parentCallbacks = this.callbacks.get(parentPath);
+            if (parentCallbacks) {
+                parentCallbacks.forEach(callback => {
+                    try {
+                        callback(path, value);
+                    } catch (error) {
+                        logger.error(`Error in settings callback for ${parentPath}:`, createErrorMetadata(error));
+                    }
+                });
+            }
+        }
+    }
+
+    public dispose(): void {
+        if (this.updateTimeout !== null) {
+            window.clearTimeout(this.updateTimeout);
+        }
+        this.callbacks.clear();
+        SettingsObserver.instance = null;
+    }
+}
diff --git a/client/state/SettingsStore.ts b/client/state/SettingsStore.ts
new file mode 100644
index 00000000..0437a11e
--- /dev/null
+++ b/client/state/SettingsStore.ts
@@ -0,0 +1,507 @@
+import { Settings } from '../types/settings/base';
+import { createLogger, createErrorMetadata, createMessageMetadata, createDataMetadata } from '../core/logger';
+import { defaultSettings } from './defaultSettings';
+import { buildApiUrl, getAuthHeaders } from '../core/api';
+import { API_ENDPOINTS } from '../core/constants';
+import { Logger, LoggerConfig } from '../core/logger';
+import { validateSettings, validateSettingValue, ValidationError } from '../types/settings/validation';
+import { convertObjectKeysToSnakeCase, convertObjectKeysToCamelCase } from '../core/utils';
+
+const logger = createLogger('SettingsStore');
+
+export type SettingsChangeCallback = (path: string, value: unknown) => void;
+export type ValidationErrorCallback = (errors: ValidationError[]) => void;
+
+export class SettingsStore {
+    private static instance: SettingsStore | null = null;
+    private settings: Settings;
+    private initialized: boolean = false;
+    private initializationPromise: Promise<void> | null = null;
+    private subscribers: Map<string, SettingsChangeCallback[]> = new Map();
+    private validationSubscribers: ValidationErrorCallback[] = [];
+    private logger: Logger;
+    private retryCount: number = 0;
+    private readonly MAX_RETRIES: number = 3;
+    private readonly RETRY_DELAY: number = 1000;
+    private settingsOrigin: 'server' | 'default' = 'default';
+    private _isUserLoggedIn: boolean = false;
+
+    private constructor() {
+        this.settings = { ...defaultSettings };
+        this.subscribers = new Map();
+        this.logger = createLogger('SettingsStore');
+    }
+
+    public static getInstance(): SettingsStore {
+        if (!SettingsStore.instance) {
+            SettingsStore.instance = new SettingsStore();
+        }
+        return SettingsStore.instance;
+    }
+
+    /**
+     * Set user login status for settings authorization
+     */
+    public setUserLoggedIn(isLoggedIn: boolean): void {
+        this._isUserLoggedIn = isLoggedIn;
+    }
+
+    /**
+     * Check if settings are loaded from server
+     */
+    public isUserLoggedIn(): boolean {
+        return this._isUserLoggedIn;
+    }
+
+    public async initialize(): Promise<void> {
+        if (this.initialized) {
+            return Promise.resolve();
+        }
+        if (this.initializationPromise) {
+            return this.initializationPromise;
+        }
+
+        this.initializationPromise = (async () => {
+            try {
+                // Start with default settings immediately to avoid waiting for server
+                this.settings = { ...defaultSettings };
+                this.settingsOrigin = 'default';
+                
+                // Initialize logger with default settings
+                if (this.settings.system?.debug) {
+                    LoggerConfig.setGlobalDebug(this.settings.system.debug.enabled);
+                    LoggerConfig.setFullJson(this.settings.system.debug.logFullJson);
+                }
+                
+                // Mark as initialized with defaults
+                this.initialized = true;
+                logger.info('SettingsStore initialized with defaults');
+
+                this.initialized = true;
+                logger.info('SettingsStore initialized with defaults, server settings will be loaded on login');
+            } catch (error) {
+                logger.error('Settings initialization failure:', createErrorMetadata(error));
+                // Last resort: use defaults without validation
+                this.settings = { ...defaultSettings };
+                this.settingsOrigin = 'default';
+                this.initialized = true;
+            }
+        })();
+
+        return this.initializationPromise;
+    }
+
+    public isInitialized(): boolean {
+        return this.initialized;
+    }
+
+    /**
+     * Load settings from server
+     * This should be called after user logs in with Nostr
+     */
+    public async loadServerSettings(): Promise<boolean> {
+        if (!this._isUserLoggedIn) {
+            logger.warn('Attempting to load server settings without user login');
+            return false;
+        }
+        
+        try {
+            logger.info('Loading settings from server after user login');
+            const settingsUrl = buildApiUrl(API_ENDPOINTS.SETTINGS_ROOT);
+            const response = await fetch(settingsUrl, {
+                headers: getAuthHeaders()
+            });
+            
+            if (!response.ok) {
+                const errorText = await response.text();
+                logger.error('Failed to load server settings:', createMessageMetadata(errorText));
+                return false;
+            }
+            
+            const serverSettings = await response.json();
+            logger.info('Received server settings:', createDataMetadata(serverSettings));
+            
+            // Convert snake_case to camelCase
+            const camelCaseSettings = convertObjectKeysToCamelCase(serverSettings);
+            
+            // Validate server settings
+            const serverValidation = validateSettings(camelCaseSettings);
+            if (!serverValidation.isValid) {
+                throw new Error(`Invalid server settings: ${JSON.stringify(serverValidation.errors)}`);
+            }
+            
+            // Use server settings as base, filling in any missing fields with defaults
+            this.settings = this.deepMerge(this.settings, camelCaseSettings);
+            this.settingsOrigin = 'server';
+            
+            // Update logger configuration from settings
+            if (this.settings.system?.debug) {
+                LoggerConfig.setGlobalDebug(this.settings.system.debug.enabled);
+                LoggerConfig.setFullJson(this.settings.system.debug.logFullJson);
+            }
+            logger.info('Updated settings from server after login');
+            return true;
+        } catch (error) {
+            logger.error('Error loading server settings:', createErrorMetadata(error));
+            return false;
+        }
+    }
+
+    public get(path: string): unknown {
+        if (!this.initialized) {
+            logger.warn('Attempting to access settings before initialization');
+            return undefined;
+        }
+        
+        if (!path) {
+            return this.settings;
+        }
+        
+        try {
+            return path.split('.').reduce((obj: any, key) => {
+                if (obj === null || obj === undefined) {
+                    throw new Error(`Invalid path: ${path}`);
+                }
+                return obj[key];
+            }, this.settings);
+        } catch (error) {
+            logger.error(`Error accessing setting at path ${path}:`, createErrorMetadata(error));
+            return undefined;
+        }
+    }
+
+    public subscribeToValidationErrors(callback: ValidationErrorCallback): () => void {
+        this.validationSubscribers.push(callback);
+        return () => {
+            const index = this.validationSubscribers.indexOf(callback);
+            if (index > -1) {
+                this.validationSubscribers.splice(index, 1);
+            }
+        };
+    }
+
+    public async subscribe(path: string, callback: SettingsChangeCallback, immediate: boolean = false): Promise<() => void> {
+        if (!this.initialized) {
+            await this.initialize();
+        }
+
+        if (!this.subscribers.has(path)) {
+            this.subscribers.set(path, []);
+        }
+        
+        const subscribers = this.subscribers.get(path);
+        if (subscribers) {
+            subscribers.push(callback);
+        }
+
+        // Only call callback immediately if explicitly requested
+        if (immediate) {
+            const value = this.get(path);
+            if (value !== undefined) {
+                callback(path, value);
+            }
+        }
+
+        return () => {
+            const pathSubscribers = this.subscribers.get(path);
+            if (pathSubscribers) {
+                const index = pathSubscribers.indexOf(callback);
+                if (index > -1) {
+                    pathSubscribers.splice(index, 1);
+                }
+                if (pathSubscribers.length === 0) {
+                    this.subscribers.delete(path);
+                }
+            }
+        };
+    }
+
+    public async set(path: string, value: unknown): Promise<void> {
+        try {
+            // Validate the specific setting change
+            // Update logger config if debug settings change
+            if (path.startsWith('system.debug')) {
+                if (path === 'system.debug.enabled') {
+                    LoggerConfig.setGlobalDebug(value as boolean);
+                } else if (path === 'system.debug.logFullJson') {
+                    LoggerConfig.setFullJson(value as boolean);
+                }
+            }
+            const validationErrors = validateSettingValue(path, value, this.settings);
+            if (validationErrors.length > 0) {
+                this.notifyValidationErrors(validationErrors);
+                throw new Error(`Validation failed: ${JSON.stringify(validationErrors)}`);
+            }
+            
+            // Create a copy of settings for rollback
+            const previousSettings = JSON.parse(JSON.stringify(this.settings));
+            const previousOrigin = this.settingsOrigin;
+            
+            // Update local state
+            this.updateSettingValue(path, value);
+            // Mark as modified from default since this is a user action
+            this.settingsOrigin = 'default';
+            
+            // Validate entire settings object after update
+            const fullValidation = validateSettings(this.settings);
+            if (!fullValidation.isValid) {
+                // Rollback and notify of validation errors
+                this.settings = previousSettings;
+                this.settingsOrigin = previousOrigin;
+                this.notifyValidationErrors(fullValidation.errors);
+                throw new Error(`Full validation failed: ${JSON.stringify(fullValidation.errors)}`);
+            }
+            
+            // Sync with server (not an initial sync)
+            try {
+                await this.syncWithServer(false);
+            } catch (error) {
+                // Rollback on server sync failure
+                this.settings = previousSettings;
+                this.settingsOrigin = previousOrigin;
+                this.notifySubscribers(path, this.get(path));
+                throw error;
+            }
+            
+            // Notify subscribers of successful update
+            this.notifySubscribers(path, value);
+            
+            this.logger.debug(`Setting updated successfully: ${path}`, createDataMetadata({
+                value,
+                origin: this.settingsOrigin
+            }));
+        } catch (error) {
+            this.logger.error(`Failed to update setting: ${path}`, createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    public isFromServer(): boolean {
+        return this.settingsOrigin === 'server';
+    }
+
+    private prepareSettingsForSync(settings: Settings): any {
+        // Create a copy of settings
+        const preparedSettings = JSON.parse(JSON.stringify(settings));
+
+        // Ensure required sections exist
+        if (!preparedSettings.system) preparedSettings.system = {};
+        if (!preparedSettings.system.debug) preparedSettings.system.debug = {};
+        if (!preparedSettings.xr) preparedSettings.xr = {};
+
+        // Always include all required debug fields
+        preparedSettings.system.debug = {
+            enabled: preparedSettings.system.debug.enabled ?? false,
+            enableDataDebug: preparedSettings.system.debug.enableDataDebug ?? false,
+            enableWebsocketDebug: preparedSettings.system.debug.enableWebsocketDebug ?? false,
+            logBinaryHeaders: preparedSettings.system.debug.logBinaryHeaders ?? false,
+            logFullJson: preparedSettings.system.debug.logFullJson ?? false,
+            logLevel: preparedSettings.system.debug.logLevel ?? 'info',
+            logFormat: preparedSettings.system.debug.logFormat ?? 'json'
+        };
+
+        // Always include required XR fields
+        const defaultXR = defaultSettings.xr;
+        preparedSettings.xr = {
+            ...preparedSettings.xr,
+            gestureSmoothing: preparedSettings.xr.gestureSmoothing ?? defaultXR.gestureSmoothing,
+            mode: preparedSettings.xr.mode ?? defaultXR.mode,
+            roomScale: preparedSettings.xr.roomScale ?? defaultXR.roomScale,
+            spaceType: preparedSettings.xr.spaceType ?? defaultXR.spaceType,
+            quality: preparedSettings.xr.quality ?? defaultXR.quality,
+            enableHandTracking: preparedSettings.xr.enableHandTracking ?? defaultXR.enableHandTracking,
+            handMeshEnabled: preparedSettings.xr.handMeshEnabled ?? defaultXR.handMeshEnabled,
+            handMeshColor: preparedSettings.xr.handMeshColor ?? defaultXR.handMeshColor,
+            handMeshOpacity: preparedSettings.xr.handMeshOpacity ?? defaultXR.handMeshOpacity,
+            handPointSize: preparedSettings.xr.handPointSize ?? defaultXR.handPointSize,
+            handRayEnabled: preparedSettings.xr.handRayEnabled ?? defaultXR.handRayEnabled,
+            handRayColor: preparedSettings.xr.handRayColor ?? defaultXR.handRayColor,
+            handRayWidth: preparedSettings.xr.handRayWidth ?? defaultXR.handRayWidth,
+            movementAxes: preparedSettings.xr.movementAxes ?? defaultXR.movementAxes
+        };
+
+        // Convert to snake_case for server
+        return convertObjectKeysToSnakeCase(preparedSettings);
+    }
+
+    private async syncWithServer(isInitialSync: boolean = false): Promise<void> {
+        // Don't sync to server during initialization if we got settings from server
+        if (!this._isUserLoggedIn) {
+            this.logger.debug('Skipping sync to server - user not logged in');
+            return;
+        }
+
+        try {
+            // Prepare settings for server sync
+            const serverSettings = this.prepareSettingsForSync(this.settings);
+            
+            this.logger.debug('Sending settings to server:', createDataMetadata({
+                origin: this.settingsOrigin,
+                isInitialSync,
+                debug: serverSettings.system?.debug
+            }));
+            
+            // Use the existing getAuthHeaders function to get headers with Nostr pubkey
+            const headers = getAuthHeaders();
+            this.logger.debug('Using auth headers for settings sync');
+                        
+            const response = await fetch(buildApiUrl(API_ENDPOINTS.SETTINGS_ROOT), {
+                method: 'POST',
+                headers,
+                body: JSON.stringify(serverSettings)
+            });
+            
+            if (!response.ok) {
+                const errorText = await response.text();
+                this.logger.error('Server sync failed:', createDataMetadata({
+                    status: response.status,
+                    error: errorText,
+                    sentSettings: serverSettings.system?.debug
+                }));
+                throw new Error(`Server returned ${response.status}: ${errorText}`);
+            }
+            
+            // Convert server response back to camelCase
+            const responseData = await response.json();
+            const camelCaseSettings = convertObjectKeysToCamelCase(responseData);
+            
+            this.logger.debug('Received settings from server:', createDataMetadata({
+                debug: camelCaseSettings.system?.debug
+            }));
+            
+            // Validate server response
+            const validationResult = validateSettings(camelCaseSettings);
+            if (!validationResult.isValid) {
+                this.logger.error('Settings validation failed:', createDataMetadata({
+                    errors: validationResult.errors,
+                    receivedSettings: camelCaseSettings.system?.debug
+                }));
+                throw new Error(`Invalid server response: ${JSON.stringify(validationResult.errors)}`);
+            }
+            
+            this.settings = this.deepMerge(this.settings, camelCaseSettings);
+            this.logger.debug('Settings synced successfully:', createDataMetadata({
+                finalDebug: this.settings.system?.debug
+            }));
+        } catch (error) {
+            this.logger.error('Failed to sync settings with server:', createErrorMetadata(error));
+            if (this.retryCount < this.MAX_RETRIES) {
+                this.retryCount++;
+                this.logger.info(`Retrying sync (attempt ${this.retryCount}/${this.MAX_RETRIES})...`);
+                await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));
+                return this.syncWithServer();
+            }
+            throw error;
+        }
+    }
+
+    private notifyValidationErrors(errors: ValidationError[]): void {
+        this.validationSubscribers.forEach(callback => {
+            try {
+                callback(errors);
+            } catch (error) {
+                this.logger.error('Error in validation subscriber:', createErrorMetadata(error));
+            }
+        });
+    }
+
+    private notifySubscribers(path: string, value: unknown): void {
+        const subscribers = this.subscribers.get(path);
+        if (subscribers) {
+            let scheduledCallbacks = new Set<SettingsChangeCallback>();
+            
+            subscribers.forEach(callback => {
+                try {
+                    if (!scheduledCallbacks.has(callback)) {
+                        scheduledCallbacks.add(callback);
+                        window.requestAnimationFrame(() => {
+                            if (scheduledCallbacks.has(callback)) {
+                                callback(path, value);
+                            }
+                        });
+                    }
+                } catch (error) {
+                    this.logger.error(`Error scheduling settings notification for ${path}:`, createErrorMetadata(error));
+                }
+            });
+        }
+    }
+
+    private deepMerge(target: any, source: any): any {
+        const result = { ...target };
+        
+        // Handle arrays
+        if (Array.isArray(source)) {
+            return [...source];
+        }
+        
+        if (source && typeof source === 'object') {
+            Object.keys(source).forEach(key => {
+                if (source[key] instanceof Object && !Array.isArray(source[key])) {
+                    result[key] = this.deepMerge(result[key] || {}, source[key]);
+                } else {
+                    result[key] = source[key];
+                }
+            });
+        }
+        
+        return result;
+    }
+
+    private updateSettingValue(path: string, value: unknown): void {
+        if (!path) {
+            throw new Error('Setting path cannot be empty');
+        }
+
+        const parts = path.split('.');
+        const section = parts[0];
+        const lastKey = parts.pop()!;
+
+        // Create a new settings object with the updated value
+        this.settings = this.deepUpdate(this.settings, parts, lastKey, value);
+
+        // If this is an XR setting, ensure all required fields are present
+        if (section === 'xr') {
+            const currentXR = this.settings.xr;
+            const defaultXR = defaultSettings.xr;
+
+            // Ensure all required XR fields are present with defaults
+            this.settings.xr = {
+                ...currentXR,
+                mode: currentXR.mode ?? defaultXR.mode,
+                roomScale: currentXR.roomScale ?? defaultXR.roomScale,
+                spaceType: currentXR.spaceType ?? defaultXR.spaceType,
+                quality: currentXR.quality ?? defaultXR.quality,
+                gestureSmoothing: currentXR.gestureSmoothing ?? defaultXR.gestureSmoothing,
+                enableHandTracking: currentXR.enableHandTracking ?? defaultXR.enableHandTracking,
+                handMeshEnabled: currentXR.handMeshEnabled ?? defaultXR.handMeshEnabled,
+                handMeshColor: currentXR.handMeshColor ?? defaultXR.handMeshColor,
+                handMeshOpacity: currentXR.handMeshOpacity ?? defaultXR.handMeshOpacity,
+                handPointSize: currentXR.handPointSize ?? defaultXR.handPointSize,
+                handRayEnabled: currentXR.handRayEnabled ?? defaultXR.handRayEnabled,
+                handRayColor: currentXR.handRayColor ?? defaultXR.handRayColor,
+                handRayWidth: currentXR.handRayWidth ?? defaultXR.handRayWidth,
+                movementAxes: currentXR.movementAxes ?? defaultXR.movementAxes
+            };
+        }
+    }
+
+    private deepUpdate(obj: any, path: string[], lastKey: string, value: unknown): any {
+        if (path.length === 0) {
+            return { ...obj, [lastKey]: value };
+        }
+
+        const key = path.shift()!;
+        return {
+            ...obj,
+            [key]: this.deepUpdate(obj[key] || {}, path, lastKey, value)
+        };
+    }
+
+    public dispose(): void {
+        this.subscribers.clear();
+        this.validationSubscribers = [];
+        this.settings = { ...defaultSettings };
+        SettingsStore.instance = null;
+    }
+}
diff --git a/client/state/defaultSettings.ts b/client/state/defaultSettings.ts
new file mode 100644
index 00000000..a5b97def
--- /dev/null
+++ b/client/state/defaultSettings.ts
@@ -0,0 +1,173 @@
+import { Settings } from '../types/settings/base';
+
+export const defaultSettings: Settings = {
+    visualization: {
+        nodes: {
+            baseColor: '#32aeae',
+            metalness: 0.8,
+            opacity: 1.0,
+            roughness: 0.2,
+            sizeRange: [0.5, 2.0],  // Match server's node size range
+            quality: 'medium',
+            enableInstancing: true,
+            enableHologram: true,
+            enableMetadataShape: false,
+            enableMetadataVisualization: true,  // Enable metadata visualization
+            colorRangeAge: ['#ff0000', '#00ff00'],
+            colorRangeLinks: ['#0000ff', '#ff00ff']
+        },
+        edges: {
+            arrowSize: 0.02,         // 2cm
+            baseWidth: 0.005,        // 5mm
+            color: '#888888',
+            enableArrows: false,
+            opacity: 0.8,
+            widthRange: [0.005, 0.01],  // 5mm to 10mm
+            quality: 'medium',
+            enableFlowEffect: true,
+            flowSpeed: 1.0,
+            flowIntensity: 0.6,
+            glowStrength: 0.4,
+            distanceIntensity: 0.3,
+            useGradient: false,
+            gradientColors: ['#888888', '#aaaaaa']
+        },
+        physics: {
+            enabled: true,
+            iterations: 100,              // Balanced for performance and stability
+            attractionStrength: 0.08,     // Increased for better balance with repulsion
+            repulsionStrength: 0.05,      // Balanced with attraction
+            repulsionDistance: 1.5,       // Set to appropriate distance based on node size
+            springStrength: 0.1,          // Increased to work with progressive spring implementation
+            damping: 0.95,                // Increased to reduce oscillation and improve stability
+            maxVelocity: 0.03,            // Reduced to prevent rapid movement
+            collisionRadius: 0.2,         // Increased to prevent nodes from getting too close
+            massScale: 1.0,               // Default mass scaling
+            boundaryDamping: 0.9,         // Increased for better containment
+            enableBounds: true,           // Enable bounds by default
+            boundsSize: 15.0              // Set to align with center gravity implementation
+        },
+        rendering: {
+            ambientLightIntensity: 0.2,
+            backgroundColor: '#1a1a1a',
+            directionalLightIntensity: 0.2,
+            enableAmbientOcclusion: false,
+            enableAntialiasing: true,
+            enableShadows: false,
+            environmentIntensity: 0.2,
+            shadowMapSize: 2048,
+            shadowBias: 0.00001,
+            context: 'desktop'
+        },
+        animations: {
+            enableMotionBlur: true,
+            enableNodeAnimations: true,
+            motionBlurStrength: 1.0,
+            selectionWaveEnabled: false,
+            pulseEnabled: false,
+            pulseSpeed: 1.0,
+            pulseStrength: 0.5,
+            waveSpeed: 1.0
+        },
+        labels: {
+            desktopFontSize: 14,
+            enableLabels: true,
+            textColor: '#ffffff',
+            textOutlineColor: '#000000',
+            textOutlineWidth: 0.1,
+            textResolution: 16,
+            textPadding: 2,
+            billboardMode: 'camera'
+        },
+        bloom: {
+            edgeBloomStrength: 2.0,
+            enabled: true,
+            environmentBloomStrength: 3.0,
+            nodeBloomStrength: 3.0,
+            radius: 2.0,
+            strength: 3.0,
+            threshold: 0.0
+        },
+        hologram: {
+            ringCount: 2,
+            sphereSizes: [0.08, 0.16],    // 8cm and 16cm
+            ringRotationSpeed: 1.0,
+            ringColor: '#00ffff',
+            ringOpacity: 0.6,
+            enableBuckminster: false,
+            enableGeodesic: false,
+            buckminsterSize: 0.0,         // Disabled by default
+            buckminsterOpacity: 0,
+            geodesicSize: 0.0,            // Disabled by default
+            geodesicOpacity: 0,
+            enableTriangleSphere: true,
+            triangleSphereSize: 0.16,     // 16cm
+            triangleSphereOpacity: 0.15,
+            globalRotationSpeed: 0.03
+        }
+    },
+    system: {
+        websocket: {
+            binaryChunkSize: 32768,
+            compressionEnabled: true,
+            compressionThreshold: 1024,
+            reconnectAttempts: 5,
+            reconnectDelay: 5000,
+            updateRate: 30
+        },
+        debug: {
+            enabled: false,
+            enableDataDebug: false,
+            enableWebsocketDebug: false,
+            logBinaryHeaders: false,
+            logFullJson: false,
+            logLevel: 'info',
+            logFormat: 'json'
+        }
+    },
+    xr: {
+        mode: 'immersive-vr',
+        roomScale: 1.0,                   // Real-world 1:1 scale
+        spaceType: 'local-floor',
+        quality: 'high',
+        autoEnterAR: false,
+        hideControlPanel: true,
+        preferredMode: 'immersive-vr',
+        enableHandTracking: true,
+        handMeshEnabled: true,
+        handMeshColor: '#4287f5',
+        handMeshOpacity: 0.3,
+        handPointSize: 0.006,             // 6mm
+        handRayEnabled: true,
+        handRayColor: '#4287f5',
+        handRayWidth: 0.003,              // 3mm
+        gestureSmoothing: 0.5,
+        enableHaptics: true,
+        hapticIntensity: 0.5,
+        dragThreshold: 0.02,              // 2cm movement required to start drag
+        pinchThreshold: 0.3,              // 30% pinch required for activation
+        rotationThreshold: 0.08,          // 8% rotation required for activation
+        interactionRadius: 0.15,          // 15cm interaction sphere
+        movementSpeed: 0.08,              // 8cm per frame at full stick deflection
+        deadZone: 0.12,                   // 12% stick movement required
+        movementAxes: {
+            horizontal: 2,                 // Right joystick X
+            vertical: 3                    // Right joystick Y
+        },
+        enableLightEstimation: false,
+        enablePlaneDetection: true,
+        enableSceneUnderstanding: true,
+        planeColor: '#808080',
+        planeOpacity: 0.5,
+        showPlaneOverlay: false,
+        snapToFloor: false,
+        planeDetectionDistance: 3.0,      // 3m maximum plane detection distance
+        enablePassthroughPortal: false,
+        passthroughOpacity: 0.8,
+        passthroughBrightness: 1.1,
+        passthroughContrast: 1.0,
+        portalSize: 2.5,                  // 2.5m portal size
+        portalEdgeColor: '#ffffff',
+        portalEdgeWidth: 0.02             // 2cm edge width
+    }
+};
diff --git a/client/state/graphData.ts b/client/state/graphData.ts
new file mode 100644
index 00000000..ddc9c8a5
--- /dev/null
+++ b/client/state/graphData.ts
@@ -0,0 +1,933 @@
+import { transformGraphData, Node, Edge, GraphData } from '../core/types';
+import { createLogger } from '../core/utils';
+import { Vector3 } from 'three';
+import { API_ENDPOINTS } from '../core/constants';
+import { debugState } from '../core/debugState';
+
+import { WebSocketService as WebSocketServiceClass } from '../websocket/websocketService';
+const logger = createLogger('GraphDataManager');
+
+// Constants
+const FLOATS_PER_NODE = 6;     // x, y, z, vx, vy, vz
+
+// Throttling for debug logs
+let lastDebugLogTime = 0;
+const DEBUG_LOG_THROTTLE_MS = 2000; // Only log once every 2 seconds
+const POSITION_UPDATE_THROTTLE_MS = 100; // Throttle position updates to 10 times per second
+let lastPositionUpdateTime = 0;
+
+// Helper for throttled debug logging
+function throttledDebugLog(message: string, data?: any): void {
+  if (!debugState.isDataDebugEnabled()) return;
+  
+  const now = Date.now();
+  if (now - lastDebugLogTime > DEBUG_LOG_THROTTLE_MS) {
+    lastDebugLogTime = now;
+    logger.debug(message, data);
+  }
+}
+
+// Interface for the internal WebSocket service used by this class
+type InternalWebSocketService = { send(data: ArrayBuffer): void };
+
+// Extend Edge interface to include id
+interface EdgeWithId extends Edge {
+  id: string;
+}
+
+// Update NodePosition type to use THREE.Vector3
+type NodePosition = Vector3;
+
+// Interface for pending edges that need to be processed after node loading
+interface PendingEdge {
+  edge: Edge;
+  retryCount: number;
+}
+
+export class GraphDataManager {
+  private static instance: GraphDataManager;
+  private nodes: Map<string, Node>;
+  private edges: Map<string, EdgeWithId>;
+  private wsService!: InternalWebSocketService;  // Use definite assignment assertion
+  private nodeIdToMetadataId: Map<string, string> = new Map();
+  private pendingEdges: PendingEdge[] = [];
+  private graphDataComplete: boolean = false;
+  private metadata: Record<string, any>;
+  private updateListeners: Set<(data: GraphData) => void>;
+  private positionUpdateListeners: Set<(positions: Float32Array) => void>;
+  private binaryUpdatesEnabled: boolean = false;
+  private positionUpdateBuffer: Map<string, NodePosition> = new Map();
+  private updateBufferTimeout: number | null = null;
+  private static readonly BUFFER_FLUSH_INTERVAL = 16; // ~60fps
+  private constructor() {
+    this.nodes = new Map();
+    this.edges = new Map();
+    this.metadata = {};
+    this.updateListeners = new Set();
+    this.positionUpdateListeners = new Set();
+    // Initialize with a no-op websocket service
+    this.wsService = {
+      send: () => logger.warn('WebSocket service not configured')
+    };
+    // Don't enable binary updates by default
+    this.binaryUpdatesEnabled = false;
+  }
+
+  /**
+   * Configure the WebSocket service for binary updates
+   */
+  public setWebSocketService(service: InternalWebSocketService): void {
+    this.wsService = service;
+    logger.info('WebSocket service configured');
+    
+    // If binary updates were enabled before the service was configured,
+    // send an initial empty update now that we have a service
+    if (this.binaryUpdatesEnabled) {
+      try {
+        this.updatePositions(new Float32Array());
+        logger.info('Sent initial empty update after WebSocket service configuration');
+      } catch (error) {
+        logger.error('Failed to send initial update after WebSocket service configuration:', error);
+      }
+    }
+  }
+
+  static getInstance(): GraphDataManager {
+    if (!GraphDataManager.instance) {
+      GraphDataManager.instance = new GraphDataManager();
+    }
+    return GraphDataManager.instance;
+  }
+
+  public async fetchInitialData(): Promise<void> {
+    try {
+      // Start with first page
+      throttledDebugLog('Fetching initial graph data page');
+      const pageSize = 100; // Consistent page size
+      await this.fetchPaginatedData(1, pageSize);
+      
+      throttledDebugLog(`Initial graph data page loaded. Current nodes: ${this.nodes.size}, edges: ${this.edges.size}`);
+      
+      // Force a notification to the UI after first page is loaded
+      // This ensures we show something to the user quickly
+      this.notifyUpdateListeners();
+      
+      // Initialize graphDataComplete as false when starting to fetch data
+      this.graphDataComplete = false;
+      
+      // Get total pages from metadata
+      const totalPages = this.metadata.pagination?.totalPages || 1;
+      const totalItems = this.metadata.pagination?.totalItems || 0;
+      
+      if (totalPages > 1) {
+        throttledDebugLog(`Loading remaining ${totalPages - 1} pages in background. Total items: ${totalItems}, Current items: ${this.nodes.size}`);
+        // Load remaining pages in background with improved error handling
+        this.loadRemainingPagesWithRetry(totalPages, 100);
+      }
+    } catch (error) {
+      logger.error('Failed to fetch initial graph data:', error);
+      throw error;
+    }
+  }
+
+  /**
+   * Load remaining pages with retry mechanism
+   * This runs in the background and doesn't block the initial rendering
+   */
+  private async loadRemainingPagesWithRetry(totalPages: number, pageSize: number): Promise<void> {
+    // Start from page 2 since page 1 is already loaded
+    for (let page = 2; page <= totalPages; page++) {
+      let retries = 0;
+      const maxRetries = 3;
+      let success = false;
+      
+      while (!success && retries < maxRetries) {
+        try {
+          await this.fetchPaginatedData(page, pageSize);
+          success = true;
+          throttledDebugLog(`Loaded page ${page}/${totalPages} successfully`);
+        } catch (error) {
+          retries++;
+          const delay = Math.min(1000 * Math.pow(2, retries), 10000); // Exponential backoff with max 10s
+          
+          logger.warn(`Failed to load page ${page}/${totalPages}, attempt ${retries}/${maxRetries}. Retrying in ${delay}ms...`);
+          
+          // Wait before retrying
+          await new Promise(resolve => setTimeout(resolve, delay));
+        }
+      }
+      
+      if (!success) {
+        logger.error(`Failed to load page ${page}/${totalPages} after ${maxRetries} attempts`);
+      }
+      
+      // Notify listeners after each page, even if it failed
+      this.notifyUpdateListeners();
+
+          
+      // Small delay between pages to avoid overwhelming the server
+      await new Promise(resolve => setTimeout(resolve, 200));
+      
+      throttledDebugLog(`Page ${page} loaded. Total nodes now: ${this.nodes.size}`);
+    }
+    
+    // All pages are now loaded, enable randomization
+    try {
+      const websocketService = WebSocketServiceClass.getInstance();
+      // Signal that all graph data has been loaded
+      this.graphDataComplete = true;
+      this.processPendingEdges(); // Process any pending edges now that all nodes are loaded
+      logger.info(`Finished loading all ${totalPages} pages. Enabling server-side randomization.`);
+      websocketService.enableRandomization(true);
+    } catch (error) {
+      logger.warn('Failed to enable randomization after loading all pages:', error);
+    }
+    logger.info(`Finished loading all ${totalPages} pages. Total nodes: ${this.nodes.size}, edges: ${this.edges.size}`);
+  }
+
+  public async fetchPaginatedData(page: number = 1, pageSize: number = 100): Promise<void> {
+    try {
+      throttledDebugLog(`Fetching page ${page} with size ${pageSize}. Current nodes: ${this.nodes.size}`);
+      
+      // Add timeout to prevent hanging requests
+      const controller = new AbortController();
+      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
+
+      const url = `${API_ENDPOINTS.GRAPH_PAGINATED}?page=${page}&pageSize=${pageSize}`;
+      throttledDebugLog(`Fetching paginated URL: ${url}`);
+      
+      const response = await fetch(
+        url,
+        {
+          method: 'GET', 
+          headers: {
+            'Content-Type': 'application/json',
+          },
+          signal: controller.signal
+        }
+      );
+      
+      // Clear the timeout
+      clearTimeout(timeoutId);
+      
+      if (!response.ok) {
+        throw new Error(`Failed to fetch paginated data: ${response.status} ${response.statusText}`);
+      }
+
+      const data = await response.json();
+      throttledDebugLog(`Received data for page ${page}:`, { nodes: data.nodes?.length, edges: data.edges?.length, totalItems: data.totalItems });
+      
+      this.updateGraphData(data);
+      throttledDebugLog(`Paginated data loaded for page ${page}. Total nodes now: ${this.nodes.size}, edges: ${this.edges.size}`);
+    } catch (error) {
+      // If we got a 404, it might mean we've reached the end of the pagination
+      const errorMessage = error instanceof Error ? error.message : 
+                          (typeof error === 'string' ? error : 'Unknown error');
+      if (errorMessage.includes('404')) {
+        logger.warn(`Reached end of pagination at page ${page}, got 404. This might be expected.`);
+        return;
+      }
+      logger.error(`Failed to fetch paginated data for page ${page}:`, error);
+      throw error;
+    }
+  }
+
+  async loadInitialGraphData(): Promise<void> {
+    try {
+      // Try both endpoints
+      const endpoints = [
+        API_ENDPOINTS.GRAPH_PAGINATED
+      ];
+
+      let response = null;
+      for (const endpoint of endpoints) {
+        try {
+          response = await fetch(`${endpoint}?page=1&pageSize=100`);
+          if (response.ok) break;
+        } catch (e) {
+          continue;
+        }
+      }
+
+      if (!response || !response.ok) {
+        throw new Error('Failed to fetch graph data from any endpoint');
+      }
+
+      const data = await response.json();
+      const transformedData = transformGraphData(data);
+      
+      // Update nodes and edges
+      this.nodes = new Map(transformedData.nodes.map((node: Node) => [node.id, node]));
+      const edgesWithIds = transformedData.edges.map((edge: Edge) => ({
+        ...edge,
+        id: this.createEdgeId(edge.source, edge.target)
+      }));
+      this.edges = new Map(edgesWithIds.map(edge => [edge.id, edge]));
+      
+      // Update metadata
+      this.metadata = {
+        ...transformedData.metadata || {},
+        pagination: {
+          totalPages: data.totalPages,
+          currentPage: data.currentPage,
+          totalItems: data.totalItems,
+          pageSize: data.pageSize
+        }
+      };
+
+      // Enable WebSocket updates immediately
+      // Binary updates will be enabled by GraphVisualization when the WebSocket is connected
+      // this.enableBinaryUpdates();
+      // this.setBinaryUpdatesEnabled(true);
+      
+      // Notify listeners of initial data
+      this.notifyUpdateListeners();
+      
+      // Load remaining pages if any
+      if (data.totalPages > 1) {
+        await this.loadRemainingPages(data.totalPages, data.pageSize);
+      }
+      
+      // If there's only one page, enable randomization immediately
+      if (data.totalPages <= 1) {
+        const websocketService = WebSocketServiceClass.getInstance();
+        logger.info('Single page graph data loaded. Enabling server-side randomization.');
+        websocketService.enableRandomization(true);
+      }
+      
+      // Signal that graph data is complete after loading single page
+      this.graphDataComplete = true;
+      logger.info('Initial graph data loaded successfully');
+    } catch (error) {
+      logger.error('Failed to fetch graph data:', error);
+      throw new Error('Failed to fetch graph data: ' + error);
+    }
+  }
+
+  private async loadRemainingPages(totalPages: number, pageSize: number): Promise<void> {
+    try {
+      throttledDebugLog(`Starting to load remaining pages. Total pages: ${totalPages}, Current nodes: ${this.nodes.size}`);
+      
+      // Load remaining pages in parallel with a reasonable chunk size
+      const chunkSize = 5;
+      for (let i = 2; i <= totalPages; i += chunkSize) {
+        const pagePromises = [];
+        for (let j = i; j < Math.min(i + chunkSize, totalPages + 1); j++) {
+          pagePromises.push(this.loadPage(j, pageSize));
+        }
+        await Promise.all(pagePromises);
+        // Update listeners after each chunk
+        throttledDebugLog(`Loaded chunk ${i}-${Math.min(i + chunkSize - 1, totalPages)}. Current nodes: ${this.nodes.size}, edges: ${this.edges.size}`);
+        this.notifyUpdateListeners(); 
+
+        // Process any pending edges after each chunk 
+        this.processPendingEdges();
+      }
+    } catch (error) {
+      logger.error('Error loading remaining pages:', error);
+      throw error;
+    }
+  }
+
+  private async loadPage(page: number, pageSize: number): Promise<void> {
+    try {
+      throttledDebugLog(`Loading page ${page}. Current nodes before load: ${this.nodes.size}`);
+      
+      const response = await fetch(
+        `${API_ENDPOINTS.GRAPH_PAGINATED}?page=${page}&pageSize=${pageSize}`,
+        {
+          method: 'GET',
+          headers: {
+            'Content-Type': 'application/json',
+          },
+        }
+      );
+      if (!response.ok) {
+        throw new Error(`Failed to fetch page ${page}: ${response.statusText}`);
+      }
+
+      const data = await response.json();
+      const transformedData = transformGraphData(data);
+      
+      // Add new nodes
+      let newNodes = 0;
+      transformedData.nodes.forEach((node: Node) => {
+        if (!this.nodes.has(node.id)) {
+          this.nodes.set(node.id, node);
+          newNodes++;
+        } 
+      });
+      
+      // Add new edges
+      let newEdges = 0;
+      transformedData.edges.forEach((edge: Edge) => {
+        const edgeId = this.createEdgeId(edge.source, edge.target);
+        if (!this.edges.has(edgeId)) {
+          // Make sure both source and target nodes exist before adding the edge
+          if (this.nodes.has(edge.source) && this.nodes.has(edge.target)) {
+            this.edges.set(edgeId, { ...edge, id: edgeId });
+          }
+          newEdges++;
+        }
+      });
+
+      throttledDebugLog(`Loaded page ${page}: ${newNodes} new nodes, ${newEdges} new edges. Total now: ${this.nodes.size} nodes, ${this.edges.size} edges`);
+    } catch (error) {
+      logger.error(`Error loading page ${page}:`, error);
+      throw error;
+    }
+  }
+
+  /**
+   * Enable binary position updates via WebSocket
+   */
+  public enableBinaryUpdates(): void {
+    // Enable binary updates flag - actual WebSocket connection is handled by WebSocketService
+    this.setBinaryUpdatesEnabled(true);
+    logger.info('Binary updates enabled');
+    
+    // Explicitly check WebSocket service status
+    const isDefaultService = this.wsService.send.toString().includes('WebSocket service not configured');
+    if (isDefaultService) {
+      logger.warn('Binary updates enabled but WebSocket service not yet configured. Starting retry mechanism...');
+      debugState.setBinaryProtocolStatus('pending');
+    } else {
+      logger.info('WebSocket service is properly configured for binary updates');
+      debugState.setBinaryProtocolStatus('active');
+    }
+  }
+
+  /**
+   * Enable or disable binary position updates
+   */
+  public setBinaryUpdatesEnabled(enabled: boolean): void {
+    if (this.binaryUpdatesEnabled === enabled) return;
+    
+    this.binaryUpdatesEnabled = enabled;
+    logger.info(`Binary updates ${enabled ? 'enabled' : 'disabled'}`);
+    
+    if (enabled) {
+      // Check if WebSocket service is configured before sending update
+      // Check if the send function is our default warning function
+      const isDefaultService = this.wsService.send.toString().includes('WebSocket service not configured');
+      if (!isDefaultService) {
+        // Send initial empty update to start receiving binary updates
+        this.updatePositions(new Float32Array());
+      } else {
+        logger.warn('Binary updates enabled but WebSocket service not yet configured. Will send update when service is available.');
+        
+        // Set up a retry mechanism to check for WebSocket service availability
+        this.retryWebSocketConfiguration();
+      }
+    }
+  }
+  
+  /**
+   * Retry WebSocket configuration until it's available
+   * This helps ensure we don't miss updates when the WebSocket service
+   * is configured after binary updates are enabled
+   */
+  private retryWebSocketConfiguration(): void {
+    // Only set up retry if not already running
+    if (this._retryTimeout) {
+      logger.debug('Retry mechanism already running, not starting a new one');
+      return;
+    }
+    
+    logger.info('Starting WebSocket configuration retry mechanism');
+    debugState.setBinaryProtocolStatus('pending');
+    
+    // Define maximum retry attempts
+    let retryCount = 0;
+    const MAX_RETRIES = 30; // 30 seconds max
+    
+    const checkAndRetry = () => {
+      retryCount++;
+      
+      // Check if WebSocket service is now configured
+      const isDefaultService = this.wsService.send.toString().includes('WebSocket service not configured');
+      if (!isDefaultService) {
+        // WebSocket service is now configured, send initial update
+        logger.info('WebSocket service now available, sending initial update');
+        this.updatePositions(new Float32Array());
+        this._retryTimeout = null;
+        debugState.setBinaryProtocolStatus('active');
+      } else {
+        // Still not configured, retry after delay if under max retries
+        if (retryCount < MAX_RETRIES) {
+          logger.debug(`WebSocket service still not configured (attempt ${retryCount}/${MAX_RETRIES})`);
+          this._retryTimeout = setTimeout(checkAndRetry, 1000) as any;
+        } else {
+          logger.warn(`WebSocket configuration retry failed after ${MAX_RETRIES} attempts`);
+          this._retryTimeout = null;
+          debugState.setBinaryProtocolStatus('failed');
+        }
+      }
+    };
+    
+    // Start the retry process
+    this._retryTimeout = setTimeout(checkAndRetry, 1000) as any;
+  }
+  
+  private _retryTimeout: any = null;
+
+  /**
+   * Update node positions via binary protocol
+   */
+  private updatePositions(positions: Float32Array): void {
+    if (!this.binaryUpdatesEnabled) {
+      logger.warn('Attempted to update positions while binary updates are disabled');
+      return;
+    }
+    
+    try {
+      // Check if WebSocket service is properly configured
+      // Check if the send function is our default warning function
+      const isDefaultService = this.wsService.send.toString().includes('WebSocket service not configured');
+      if (isDefaultService) {
+        logger.warn('Cannot send position update: WebSocket service not configured');
+        // Set up retry mechanism if not already running
+        this.retryWebSocketConfiguration();
+        return;
+      }
+      
+      // Update binary protocol status in debug state
+      debugState.setBinaryProtocolStatus('active');
+      
+      // Log the update if debugging is enabled
+      if (debugState.isDataDebugEnabled()) {
+        const nodeCount = positions.length / FLOATS_PER_NODE;
+        logger.debug(`Sending binary position update for ${nodeCount} nodes`);
+      }
+      
+      this.wsService.send(positions.buffer);
+    } catch (error) {
+      logger.error('Failed to send position update:', error);
+      // Update status to reflect error
+      debugState.setBinaryProtocolStatus('error');
+      // Don't disable binary updates on error - let the application decide
+      // this.binaryUpdatesEnabled = false;
+    }
+  }
+
+  /**
+   * Initialize or update the graph data
+   */
+  updateGraphData(data: any): void {
+    // Transform and validate incoming data
+    const transformedData = transformGraphData(data);
+    // Process nodes before edges
+    this.processNodeData(transformedData.nodes);
+    logger.info(`Updating graph data. Incoming: ${transformedData.nodes.length} nodes, ${transformedData.edges?.length || 0} edges. First 3 node IDs: ${transformedData.nodes.slice(0, 3).map(n => n.id).join(', ')}`);
+    
+    // Debug edge source/target IDs
+    if (transformedData.edges && transformedData.edges.length > 0) {
+      throttledDebugLog(`First 3 edge source/target IDs: ${transformedData.edges.slice(0, 3).map(e => `${e.source}->${e.target}`).join(', ')}`);
+    }
+    
+    // Process edges after nodes
+    if (Array.isArray(transformedData.edges)) {
+      this.processEdgeData(transformedData.edges);
+    }
+
+    // Update metadata, including pagination info if available
+    this.metadata = {
+      ...transformedData.metadata,
+      pagination: data.totalPages ? {
+        totalPages: data.totalPages,
+        currentPage: data.currentPage,
+        totalItems: data.totalItems,
+        pageSize: data.pageSize
+      } : undefined
+    };
+
+    // If this is a "complete" signal, process any remaining pending edges
+    if (data.complete === true) {
+      this.graphDataComplete = true;
+      this.processPendingEdges();
+      logger.info("Received graph complete signal. All data loaded.");
+    }
+
+    // Notify listeners
+    this.notifyUpdateListeners();
+    logger.info(`Updated graph data: ${this.nodes.size} nodes, ${this.edges.size} edges`);
+  }
+
+  /**
+   * Process node data from incoming updates
+   * @param nodes The array of nodes to process
+   */
+  private processNodeData(nodes: Node[]): void {
+    // Update nodes with proper position and velocity
+    nodes.forEach((node: Node) => {
+      // Validate that the node ID is present and properly formatted
+      if (!node.id || !/^\d+$/.test(node.id)) {
+        logger.warn(`Received node with invalid ID format: ${node.id}. Node IDs must be numeric strings.`);
+        return;
+      }
+
+      // Check if we already have this node
+      const existingNode = this.nodes.get(node.id);
+      
+      if (existingNode) {
+        // Update position and velocity
+        existingNode.data.position.copy(node.data.position);
+        if (node.data.velocity) {
+          existingNode.data.velocity.copy(node.data.velocity);
+        }
+
+        // Track relationship between node ID and metadata ID (filename)
+        const metadataId = node.data.metadata?.name || (node as any).metadataId;
+        if (metadataId && metadataId !== node.id && metadataId.length > 0) {
+          // Store mapping from numeric ID to metadata ID (filename or label)
+          this.nodeIdToMetadataId.set(node.id, metadataId);
+          
+          // Log the mapping if debug is enabled
+          if (debugState.isNodeDebugEnabled()) {
+            throttledDebugLog(`Updated metadata mapping: ${node.id} -> ${metadataId}`);
+          }
+
+        }
+        
+        // Only update metadata if the new node has valid metadata that's better than what we have
+        if (node.data.metadata?.name && 
+            node.data.metadata.name !== node.id && 
+            node.data.metadata.name.length > 0) {
+          // Update existing node with new metadata
+          existingNode.data.metadata = {
+            ...existingNode.data.metadata,
+            ...node.data.metadata
+          };
+        }
+      } else {
+        // Store mapping for new nodes, prioritizing explicit metadataId if available
+        const metadataId = node.data.metadata?.name || (node as any).metadataId;
+        if (metadataId && metadataId !== node.id && metadataId.length > 0) {
+          // Store mapping from numeric ID to metadata ID
+          this.nodeIdToMetadataId.set(node.id, metadataId);
+          
+          if (debugState.isNodeDebugEnabled()) {
+            throttledDebugLog(`New metadata mapping: ${node.id} -> ${metadataId}`);
+          }
+        }
+        this.nodes.set(node.id, node);
+      }
+    });
+  }
+
+  /**
+   * Process edge data, queueing edges that reference missing nodes
+   * @param edges The array of edges to process
+   */
+  private processEdgeData(edges: Edge[]): void {
+    // Store edges in Map with generated IDs
+    if (debugState.isDataDebugEnabled()) {
+      logger.debug(`Processing ${edges.length || 0} edges. Current edge count: ${this.edges.size}`);
+    }
+
+    let edgesAdded = 0;
+    let edgesBuffered = 0;
+      
+    edges.forEach((edge: Edge) => {
+      // Validate that edge source and target are numeric IDs
+      if (!edge.source || !edge.target || !/^\d+$/.test(edge.source) || !/^\d+$/.test(edge.target)) {
+        logger.warn(`Invalid edge: source or target is not a valid numeric ID. Source: ${edge.source}, Target: ${edge.target}`);
+        return;
+      }
+
+      const edgeId = this.createEdgeId(edge.source, edge.target);
+      if (debugState.isDataDebugEnabled())
+        logger.debug(`Processing edge: ${edge.source}->${edge.target} (ID: ${edgeId})`);
+
+      // Check if this edge already exists
+      if (this.edges.has(edgeId)) {
+        // Edge already exists, just log and skip
+        logger.debug(`Skipping duplicate edge ${edgeId}`);
+        return;
+      }
+      
+      // Check if source and target nodes exist
+      if (!this.nodes.has(edge.source) || !this.nodes.has(edge.target)) {
+        // If graph is still loading, buffer this edge for later processing
+        if (!this.graphDataComplete) {
+          this.pendingEdges.push({ edge, retryCount: 0 });
+          edgesBuffered++;
+          
+          if (debugState.isDataDebugEnabled()) {
+            logger.debug(`Buffering edge ${edgeId} due to missing node(s). Source exists: ${this.nodes.has(edge.source)}, Target exists: ${this.nodes.has(edge.target)}`);
+          }
+        } else {
+          // Graph is complete but nodes still missing - log error
+          logger.warn(`Skipping edge ${edge.source}->${edge.target} due to missing node(s). Source exists: ${this.nodes.has(edge.source)}, Target exists: ${this.nodes.has(edge.target)}`);
+        }
+        return;
+      }
+      
+      const edgeWithId: EdgeWithId = {
+        ...edge,
+        id: edgeId
+      };
+      this.edges.set(edgeId, edgeWithId);
+      edgesAdded++;
+      
+      if (debugState.isDataDebugEnabled()) {
+        logger.debug(`Added edge ${edgeId}: ${edge.source}->${edge.target}`);
+      }
+    });
+    
+    if (edgesAdded > 0 || edgesBuffered > 0) {
+      logger.info(`Edge processing complete: ${edgesAdded} edges added, ${edgesBuffered} edges buffered. Total edges: ${this.edges.size}, Pending: ${this.pendingEdges.length}`);
+    }
+  }
+
+  /**
+   * Process any pending edges that were waiting for nodes to be loaded
+   */
+  private processPendingEdges(): void {
+    if (this.pendingEdges.length === 0) return;
+
+    logger.info(`Processing ${this.pendingEdges.length} pending edges`);
+    
+    // Track which edges we processed successfully
+    const processedIndices: number[] = [];
+    let edgesAdded = 0;
+
+    // Try to process each pending edge
+    this.pendingEdges.forEach((pendingEdge, index) => {
+      const { edge, retryCount } = pendingEdge;
+      const edgeId = this.createEdgeId(edge.source, edge.target);
+
+      // Check if source and target nodes now exist
+      if (this.nodes.has(edge.source) && this.nodes.has(edge.target)) {
+        // Both nodes exist, we can add the edge
+        const edgeWithId: EdgeWithId = {
+          ...edge,
+          id: edgeId
+        };
+        this.edges.set(edgeId, edgeWithId);
+        processedIndices.push(index);
+        edgesAdded++;
+        
+        if (debugState.isDataDebugEnabled()) {
+          logger.debug(`Added pending edge ${edgeId}: ${edge.source}->${edge.target} after ${retryCount} retries`);
+        }
+      } else if (retryCount >= 3 || this.graphDataComplete) {
+        // We've retried too many times or the graph is complete, log and discard
+        logger.warn(`Discarding pending edge ${edge.source}->${edge.target} after ${retryCount} retries. Source exists: ${this.nodes.has(edge.source)}, Target exists: ${this.nodes.has(edge.target)}`);
+        processedIndices.push(index);
+      } else {
+        // Increment retry count
+        pendingEdge.retryCount++;
+      }
+    });
+
+    // Remove processed edges (in reverse order to maintain correct indices)
+    processedIndices.sort((a, b) => b - a).forEach(index => {
+      this.pendingEdges.splice(index, 1);
+    });
+
+    if (edgesAdded > 0) {
+      logger.info(`Processed ${edgesAdded} pending edges. ${this.pendingEdges.length} still pending.`);
+      this.notifyUpdateListeners();
+    }
+  }
+
+  /**
+   * Receive a graph complete signal from the server
+   */
+  public signalGraphComplete(): void {
+    logger.info("Received graph complete signal from server");
+    this.graphDataComplete = true;
+    this.processPendingEdges();
+    // Notify listeners
+    this.notifyUpdateListeners();
+  }
+
+  /**
+   * Get the current graph data
+   */
+  getGraphData(): GraphData {
+    return {
+      nodes: Array.from(this.nodes.values()),
+      edges: Array.from(this.edges.values()) as Edge[],
+      metadata: this.metadata
+    };
+  }
+
+  /**
+   * Get a specific node by ID
+   * Strictly uses the primary node ID (numeric ID)
+   */
+  getNode(id: string): Node | undefined {    
+    return this.nodes.get(id);
+  }
+
+  /**
+   * Get the metadata ID (filename) for a node
+   */
+  getNodeMetadataId(id: string): string | undefined {
+    return this.nodeIdToMetadataId.get(id);
+  }
+
+  /**
+   * Subscribe to graph data updates
+   */
+  subscribe(listener: (data: GraphData) => void): () => void {
+    this.updateListeners.add(listener);
+    return () => {
+      this.updateListeners.delete(listener);
+    };
+  }
+
+  /**
+   * Subscribe to position updates only
+   */
+  subscribeToPositionUpdates(
+    listener: (positions: Float32Array) => void
+  ): () => void {
+    this.positionUpdateListeners.add(listener);
+    return () => {
+      this.positionUpdateListeners.delete(listener);
+    };
+  }
+
+  /**
+   * Clear all graph data
+   */
+  clear(): void {
+    this.nodes.clear();
+    this.edges.clear();
+    this.metadata = {};
+    this.notifyUpdateListeners();
+  }
+
+  private createEdgeId(source: string, target: string): string {
+    return [source, target].sort().join('_');
+  }
+
+  private notifyUpdateListeners(): void {
+    const data = this.getGraphData();
+    this.updateListeners.forEach(listener => {
+      try {
+        listener(data);
+      } catch (error) {
+        logger.error('Error in graph update listener:', error);
+      }
+    });
+  }
+
+  private notifyPositionUpdateListeners(positions: Float32Array): void {
+    this.positionUpdateListeners.forEach(listener => {
+      try {
+        listener(positions);
+      } catch (error) {
+        logger.error('Error in position update listener:', error);
+      }
+    });
+  }
+
+  public updateNodePositions(positions: Float32Array): void {
+    if (!this.binaryUpdatesEnabled) {
+      return;
+    }
+
+    // Throttle position updates to prevent overwhelming the system
+    const now = Date.now();
+    if (now - lastPositionUpdateTime < POSITION_UPDATE_THROTTLE_MS) {
+      // Too soon for another update, just mark we have pending updates
+      return;
+    }
+    
+    lastPositionUpdateTime = now;
+    
+    const nodeCount = positions.length / FLOATS_PER_NODE;
+    if (positions.length % FLOATS_PER_NODE !== 0) {
+      logger.warn('Invalid position array length:', positions.length);
+      return;
+    }
+
+    // Buffer the updates
+    for (let i = 0; i < nodeCount; i++) {
+      const offset = i * FLOATS_PER_NODE;
+      
+      try {
+        // In our binary format, the node ID is just the index
+        // We'll convert it to a string since our node map uses string keys
+        const nodeId = i.toString();
+        
+        // Skip if we don't have this node
+        if (!this.nodes.has(nodeId)) {
+          continue;
+        }
+
+        // Create proper THREE.Vector3 object for the position
+        const nodePosition = new Vector3(
+          positions[offset],
+          positions[offset + 1],
+          positions[offset + 2]
+        );
+
+        // Only update if the position changed significantly
+        const existingNode = this.nodes.get(nodeId);
+        
+        // CRITICAL FIX: Don't apply deadband filtering on server physics updates
+        // Always accept position updates from the server's physics simulation
+        if (existingNode) {
+            this.positionUpdateBuffer.set(nodeId, nodePosition);
+        }
+      } catch (error) {
+        logger.warn(`Error processing position for node index ${i}:`, error);
+      }
+
+    }
+
+    // Schedule buffer flush if not already scheduled
+    if (!this.updateBufferTimeout) {
+      this.updateBufferTimeout = window.setTimeout(() => {
+        this.flushPositionUpdates();
+        this.updateBufferTimeout = null;
+      }, GraphDataManager.BUFFER_FLUSH_INTERVAL);
+    }
+  }
+
+  private flushPositionUpdates(): void {
+    if (this.positionUpdateBuffer.size === 0) return;
+
+    // Make sure we're working with proper THREE.Vector3 objects for data flow
+    const updates = Array.from(this.positionUpdateBuffer.entries())
+      .map(([id, position]) => ({
+        id,
+        data: { 
+          position, // This is now a THREE.Vector3 object
+          velocity: undefined 
+        }
+      }));
+
+    // Convert node updates to Float32Array for binary protocol
+    const nodesCount = updates.length;
+    const positionsArray = new Float32Array(nodesCount * FLOATS_PER_NODE);
+    
+    updates.forEach((node, index) => {
+      const baseIndex = index * FLOATS_PER_NODE;
+      // Position (x, y, z)
+      // Access x, y, z properties from the THREE.Vector3 object
+      positionsArray[baseIndex] = node.data.position.x;
+      positionsArray[baseIndex + 1] = node.data.position.y;
+      positionsArray[baseIndex + 2] = node.data.position.z;
+      // Velocity (set to 0 since undefined)
+      positionsArray[baseIndex + 3] = positionsArray[baseIndex + 4] = positionsArray[baseIndex + 5] = 0;
+    });
+    this.notifyPositionUpdateListeners(positionsArray);
+    this.positionUpdateBuffer.clear();
+  }
+}
+
+// Export a singleton instance
+export const graphDataManager = GraphDataManager.getInstance();
+
+// Declare WebSocket on window for TypeScript
+declare global {
+  interface Window {
+    ws: WebSocket;
+  }
+}
diff --git a/client/state/settings.ts b/client/state/settings.ts
new file mode 100644
index 00000000..755edf3a
--- /dev/null
+++ b/client/state/settings.ts
@@ -0,0 +1,193 @@
+import { Settings } from '../types/settings';
+import { createLogger, createErrorMetadata } from '../core/logger';
+import { SettingsStore } from './SettingsStore';
+import { defaultSettings } from './defaultSettings';
+import {
+    SettingsCategory,
+    SettingsPath,
+    SettingsValue,
+    getSettingValue,
+    setSettingValue,
+    isValidSettingPath
+} from '../types/settings/utils';
+import { VisualizationController } from '../rendering/VisualizationController';
+
+const logger = createLogger('SettingsManager');
+
+export class SettingsManager {
+    private store: SettingsStore;
+    private initialized: boolean = false;
+    private settings: Settings = { ...defaultSettings };
+
+    constructor() {
+        this.store = SettingsStore.getInstance();
+    }
+
+    public async initialize(): Promise<void> {
+        if (this.initialized) return;
+
+        // Initialize with default settings
+        this.settings = { ...defaultSettings };
+        
+        // Initialize the store but don't load server settings yet
+        try {
+            await this.store.initialize();
+            
+            // If the user is already logged in (session restored), we might have server settings
+            if (this.store.isUserLoggedIn()) {
+                this.settings = this.store.get('') as Settings;
+                logger.info('Settings initialized from server (user logged in)');
+            } else {
+                logger.info('Settings initialized with defaults (user not logged in)');
+            }
+        } catch (error) {
+            logger.error('Failed to initialize settings store:', createErrorMetadata(error));
+            // Already using default settings
+        }
+        
+        this.initialized = true;
+    }
+
+    /**
+     * Called when user logs in with Nostr to update settings
+     */
+    public updateSettingsFromServer(): void {
+        if (this.store.isUserLoggedIn()) {
+            // Get the latest settings from the store which should have loaded them from server
+            this.settings = this.store.get('') as Settings;
+            logger.info('Settings updated from server after user login');
+
+            // Force refresh of visualization with new settings
+            try {
+                const visualizationController = VisualizationController.getInstance();
+                // Pass the complete settings object to the visualization controller
+                logger.info('Forcing visualization refresh with updated server settings');
+                visualizationController.refreshSettings(this.settings);
+            } catch (error) {
+                logger.warn('Failed to refresh visualization from settings manager:', createErrorMetadata(error));
+            }
+        }
+    }
+
+    public getCurrentSettings(): Settings {
+        // Always return settings, which will be defaults if initialization failed
+        return this.settings;
+    }
+
+    public async updateSetting(path: SettingsPath, value: SettingsValue): Promise<void> {
+        if (!isValidSettingPath(this.settings, path)) {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
+
+        try {
+            setSettingValue(this.settings, path, value);
+            if (this.initialized) {
+                await this.store.set(path, value);
+                if (!this.store.isUserLoggedIn()) {
+                    logger.warn(`Setting ${path} updated, but won't be saved to server until user logs in`);
+                }
+            } else {
+                logger.warn(`Setting ${path} updated in memory only - store not initialized`);
+            }
+            logger.debug(`Updated setting ${path} to ${value}`);
+        } catch (error) {
+            logger.error(`Failed to update setting ${path}:`, createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    public get(path: SettingsPath): SettingsValue {
+        if (!isValidSettingPath(this.settings, path)) {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
+        
+        try {
+            return getSettingValue(this.settings, path)!;
+        } catch (error) {
+            logger.error(`Error getting setting at path ${path}:`, createErrorMetadata(error));
+            // Return default value for this path if available
+            return getSettingValue(defaultSettings, path)!;
+        }
+    }
+
+    public getCategory(category: SettingsCategory): Settings[typeof category] {
+        if (!(category in this.settings)) {
+            logger.warn(`Category ${category} not found, using defaults`);
+            return defaultSettings[category];
+        }
+        return this.settings[category];
+    }
+
+    public subscribe(path: string, callback: (value: unknown) => void): () => void {
+        const store = SettingsStore.getInstance();
+        let unsubscriber: (() => void) | undefined;
+        
+        store.subscribe(path, (_, value) => {
+            callback(value);
+        }).then(unsub => {
+            unsubscriber = unsub;
+        });
+
+        return () => {
+            if (unsubscriber) {
+                unsubscriber();
+            }
+        };
+    }
+
+    public onSettingChange(path: SettingsPath, callback: (value: SettingsValue) => void): () => void {
+        const store = SettingsStore.getInstance();
+        let unsubscriber: (() => void) | undefined;
+        
+        store.subscribe(path, (_, value) => {
+            callback(value as SettingsValue);
+        }).then(unsub => {
+            unsubscriber = unsub;
+        });
+
+        return () => {
+            if (unsubscriber) {
+                unsubscriber();
+            }
+        };
+    }
+
+    public async batchUpdate(updates: Array<{ path: SettingsPath; value: SettingsValue }>): Promise<void> {
+        try {
+            // Validate all paths first
+            for (const { path } of updates) {
+                if (!isValidSettingPath(this.settings, path)) {
+                    throw new Error(`Invalid settings path: ${path}`);
+                }
+            }
+
+            // Apply updates to local settings first
+            for (const { path, value } of updates) {
+                setSettingValue(this.settings, path, value);
+            }
+
+            // Then sync with store if initialized
+            if (this.initialized) {
+                await Promise.all(
+                    updates.map(({ path, value }) => this.store.set(path, value))
+                );
+                if (!this.store.isUserLoggedIn()) {
+                    logger.warn(`Settings batch updated, but won't be saved to server until user logs in`);
+                }
+            } else {
+                logger.warn('Settings updated in memory only - store not initialized');
+            }
+        } catch (error) {
+            logger.error('Failed to apply batch updates:', createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    public dispose(): void {
+        this.store.dispose();
+        this.initialized = false;
+    }
+}
+
+// Export singleton instance
+export const settingsManager = new SettingsManager();
diff --git a/client/tsconfig.json b/client/tsconfig.json
new file mode 100644
index 00000000..d51ad05d
--- /dev/null
+++ b/client/tsconfig.json
@@ -0,0 +1,38 @@
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "useDefineForClassFields": true,
+    "module": "ESNext",
+    "lib": [
+      "es2020",
+      "dom",
+      "dom.iterable",
+      "webworker",
+      "webworker.importscripts",
+      "webworker.iterable"
+    ],
+    "skipLibCheck": true,
+    "moduleResolution": "bundler",
+    "allowImportingTsExtensions": true,
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "noEmit": true,
+    "strict": true,
+    "noUnusedLocals": true,
+    "noUnusedParameters": true,
+    "noFallthroughCasesInSwitch": true,
+    "noImplicitAny": true,
+    "noImplicitThis": true,
+    "noImplicitReturns": true,
+    "strictNullChecks": true,
+    "strictFunctionTypes": true,
+    "strictBindCallApply": true,
+    "strictPropertyInitialization": true,
+    "allowJs": true,
+    "checkJs": true,
+    "esModuleInterop": true,
+    "forceConsistentCasingInFileNames": true
+  },
+  "include": ["**/*.ts", "**/*.d.ts"],
+  "exclude": ["node_modules"]
+}
diff --git a/client/types/env.d.ts b/client/types/env.d.ts
new file mode 100644
index 00000000..2662c163
--- /dev/null
+++ b/client/types/env.d.ts
@@ -0,0 +1,12 @@
+/// <reference types="vite/client" />
+
+interface ImportMetaEnv {
+  readonly VITE_APP_TITLE: string;
+  readonly DEV: boolean;
+  readonly PROD: boolean;
+  readonly MODE: string;
+}
+
+interface ImportMeta {
+  readonly env: ImportMetaEnv;
+}
diff --git a/client/types/gestures.ts b/client/types/gestures.ts
new file mode 100644
index 00000000..0d4d166a
--- /dev/null
+++ b/client/types/gestures.ts
@@ -0,0 +1,7 @@
+export enum HandGestureType {
+    None = 'none',
+    Pinch = 'pinch',
+    Grab = 'grab',
+    Point = 'point',
+    Wave = 'wave'
+}
diff --git a/client/types/metadata.ts b/client/types/metadata.ts
new file mode 100644
index 00000000..78e41b49
--- /dev/null
+++ b/client/types/metadata.ts
@@ -0,0 +1,52 @@
+export interface NodeMetadata {
+    id: string;
+    name: string;
+    file_name?: string;       // Filename from server
+    commitAge: number;        // Age in days
+    hyperlinkCount: number;   // Number of hyperlinks
+    fileSize: number;         // Size in bytes
+    nodeSize: number;         // Normalized node size (0-50)
+    importance: number;       // Normalized importance (0-1)
+    position: {
+        x: number;
+        y: number;
+        z: number;
+    };
+}
+
+export interface HologramSettings {
+    enabled: boolean;
+    desktopQuality: 'low' | 'medium' | 'high';
+    xrQuality: 'low' | 'medium';
+    ringCount: number;
+    ringSizes: number[];
+    ringOpacity: number;
+    ringColor: string;
+    ringRotationSpeed: number;
+    enableBuckminster: boolean;
+    buckminsterScale: number;
+    buckminsterOpacity: number;
+    enableGeodesic: boolean;
+    geodesicScale: number;
+    geodesicOpacity: number;
+    enableTriangleSphere: boolean;
+    triangleSphereScale: number;
+    triangleSphereOpacity: number;
+    globalRotationSpeed: number;
+    wireframeThickness: number;
+}
+
+export interface LabelSettings {
+    textRenderingMode: 'sdf' | 'bitmap';
+    textResolution: number;
+    textPadding: number;
+    textOutlineWidth: number;
+    textOutlineColor: string;
+    billboardMode: 'camera' | 'vertical';
+    desktopFontSize: number;
+    enableLabels: boolean;
+    textColor: string;
+}
+
+// Alias for backward compatibility and clarity
+export type Metadata = NodeMetadata;
\ No newline at end of file
diff --git a/client/types/nostr.d.ts b/client/types/nostr.d.ts
new file mode 100644
index 00000000..a0cfaaae
--- /dev/null
+++ b/client/types/nostr.d.ts
@@ -0,0 +1,28 @@
+interface NostrProvider {
+    /**
+     * Get the user's public key from the Nostr extension
+     * @returns Promise that resolves to the public key as a hex string
+     */
+    getPublicKey(): Promise<string>;
+
+    /**
+     * Sign an event with the user's private key
+     * @param event The event to sign
+     * @returns Promise that resolves to the signed event
+     */
+    signEvent(event: any): Promise<any>;
+
+    /**
+     * Get the relay URLs from the extension
+     * @returns Promise that resolves to an array of relay URLs
+     */
+    getRelays?(): Promise<string[]>;
+}
+
+declare global {
+    interface Window {
+        nostr?: NostrProvider;
+    }
+}
+
+export {};
\ No newline at end of file
diff --git a/client/types/pako.d.ts b/client/types/pako.d.ts
new file mode 100644
index 00000000..35dcfde1
--- /dev/null
+++ b/client/types/pako.d.ts
@@ -0,0 +1,61 @@
+/**
+ * Type definitions for pako 2.x
+ * Project: https://github.com/nodeca/pako
+ */
+
+declare module 'pako' {
+  /**
+   * Inflate (decompress) data with pako
+   */
+  export function inflate(data: Uint8Array, options?: InflateOptions): Uint8Array;
+  
+  /**
+   * Deflate (compress) data with pako
+   */
+  export function deflate(data: Uint8Array, options?: DeflateOptions): Uint8Array;
+  
+  /**
+   * Inflate (decompress) data with pako (sync, no callback)
+   */
+  export function inflateRaw(data: Uint8Array, options?: InflateOptions): Uint8Array;
+  
+  /**
+   * Deflate (compress) data with pako (sync, no callback)
+   */
+  export function deflateRaw(data: Uint8Array, options?: DeflateOptions): Uint8Array;
+  
+  /**
+   * Inflate (decompress) data with gzip headers
+   */
+  export function ungzip(data: Uint8Array, options?: InflateOptions): Uint8Array;
+  
+  /**
+   * Deflate (compress) data with gzip headers
+   */
+  export function gzip(data: Uint8Array, options?: DeflateOptions): Uint8Array;
+  
+  export interface InflateOptions {
+    windowBits?: number;
+    raw?: boolean;
+    to?: 'string' | 'array';
+    chunkSize?: number;
+  }
+  
+  export interface DeflateOptions {
+    level?: number;
+    windowBits?: number;
+    memLevel?: number;
+    strategy?: number;
+    raw?: boolean;
+    to?: 'string';
+    chunkSize?: number;
+  }
+}
+
+// Add global pako declaration for browser scripts
+interface Window {
+  pako?: {
+    inflate(data: Uint8Array, options?: any): Uint8Array;
+    deflate(data: Uint8Array, options?: any): Uint8Array;
+  };
+} 
\ No newline at end of file
diff --git a/client/types/settings.ts b/client/types/settings.ts
new file mode 100644
index 00000000..06e47eab
--- /dev/null
+++ b/client/types/settings.ts
@@ -0,0 +1,2 @@
+// Re-export everything from base
+export * from './settings/base';
diff --git a/client/types/settings/base.ts b/client/types/settings/base.ts
new file mode 100644
index 00000000..1ff43253
--- /dev/null
+++ b/client/types/settings/base.ts
@@ -0,0 +1,158 @@
+// Base settings interfaces
+import { XRSettings } from './xr';
+
+export interface Settings {
+    visualization: {
+        nodes: NodeSettings;
+        edges: EdgeSettings;
+        physics: PhysicsSettings;
+        rendering: RenderingSettings;
+        animations: AnimationSettings;
+        labels: LabelSettings;
+        bloom: BloomSettings;
+        hologram: HologramSettings;
+    };
+    system: {
+        websocket: WebSocketSettings;
+        debug: DebugSettings;
+    };
+    xr: XRSettings;
+}
+
+export interface NodeSettings {
+    quality: 'low' | 'medium' | 'high';
+    enableInstancing: boolean;
+    enableHologram: boolean;
+    enableMetadataShape: boolean;
+    enableMetadataVisualization: boolean;
+    sizeRange: [number, number];  // In meters (e.g., [0.05, 0.2] for 5cm to 20cm)
+    baseColor: string;
+    opacity: number;
+    colorRangeAge: [string, string];
+    colorRangeLinks: [string, string];
+    metalness: number;
+    roughness: number;
+}
+
+export interface EdgeSettings {
+    color: string;
+    opacity: number;
+    arrowSize: number;  // In meters (e.g., 0.02 for 2cm)
+    baseWidth: number;  // In meters (e.g., 0.005 for 5mm)
+    enableArrows: boolean;
+    widthRange: [number, number];  // In meters (e.g., [0.005, 0.01] for 5-10mm)
+    quality: 'low' | 'medium' | 'high';
+    // New shader-based edge settings
+    enableFlowEffect: boolean;
+    flowSpeed: number;
+    flowIntensity: number;
+    glowStrength: number;
+    distanceIntensity: number;
+    useGradient: boolean;
+    gradientColors: [string, string];
+}
+
+export interface AnimationSettings {
+    enableNodeAnimations: boolean;
+    enableMotionBlur: boolean;
+    motionBlurStrength: number;
+    selectionWaveEnabled: boolean;
+    pulseEnabled: boolean;
+    pulseSpeed: number;
+    pulseStrength: number;
+    waveSpeed: number;
+}
+
+export interface LabelSettings {
+    enableLabels: boolean;
+    desktopFontSize: number;
+    textColor: string;
+    textOutlineColor: string;
+    textOutlineWidth: number;
+    textResolution: number;
+    textPadding: number;
+    billboardMode: 'camera' | 'vertical';
+    visibilityThreshold?: number; // Distance threshold for labels visibility
+}
+
+export interface BloomSettings {
+    enabled: boolean;
+    strength: number;
+    radius: number;
+    threshold: number;
+    edgeBloomStrength: number;
+    nodeBloomStrength: number;
+    environmentBloomStrength: number;
+}
+
+export interface HologramSettings {
+    ringCount: number;
+    sphereSizes: number[];  // In meters (e.g., [0.08, 0.16] for 8cm and 16cm)
+    ringRotationSpeed: number;
+    globalRotationSpeed: number;
+    ringColor: string;
+    ringOpacity: number;
+    enableBuckminster: boolean;
+    buckminsterSize: number;  // In meters (e.g., 0.16 for 16cm)
+    buckminsterOpacity: number;
+    enableGeodesic: boolean;
+    geodesicSize: number;  // In meters (e.g., 0.16 for 16cm)
+    geodesicOpacity: number;
+    enableTriangleSphere: boolean;
+    triangleSphereSize: number;  // In meters (e.g., 0.16 for 16cm)
+    triangleSphereOpacity: number;
+}
+
+export interface PhysicsSettings {
+    enabled: boolean;
+    attractionStrength: number;
+    repulsionStrength: number;
+    springStrength: number;
+    damping: number;
+    iterations: number;
+    maxVelocity: number;
+    collisionRadius: number;  // In meters (e.g., 0.1 for 10cm)
+    enableBounds: boolean;
+    boundsSize: number;  // In meters (e.g., 0.33 for 33cm)
+    repulsionDistance: number;  // In meters (e.g., 0.5 for 50cm)
+    massScale: number;
+    boundaryDamping: number;
+}
+
+export interface RenderingSettings {
+    ambientLightIntensity: number;
+    directionalLightIntensity: number;
+    environmentIntensity: number;
+    backgroundColor: string;
+    enableAmbientOcclusion: boolean;
+    enableAntialiasing: boolean;
+    enableShadows: boolean;
+    shadowMapSize: number;
+    shadowBias: number;
+    context: 'ar' | 'desktop';
+}
+
+export interface WebSocketSettings {
+    reconnectAttempts: number;
+    reconnectDelay: number;
+    binaryChunkSize: number;
+    compressionEnabled: boolean;
+    compressionThreshold: number;
+    updateRate: number;
+}
+
+export interface DebugSettings {
+    enabled: boolean;
+    enableDataDebug: boolean;
+    enableWebsocketDebug: boolean;
+    logBinaryHeaders: boolean;
+    logFullJson: boolean;
+    logLevel: 'error' | 'warn' | 'info' | 'debug' | 'trace';
+    logFormat: string;
+}
+
+// Helper type for settings paths
+export type SettingsPath = string;
+
+// Helper type for settings values
+export type SettingsValue = string | number | boolean | number[] | object;
diff --git a/client/types/settings/utils.ts b/client/types/settings/utils.ts
new file mode 100644
index 00000000..1bc85844
--- /dev/null
+++ b/client/types/settings/utils.ts
@@ -0,0 +1,242 @@
+import { Settings, SettingsPath, SettingsValue } from './base';
+
+// Settings categories
+export type SettingsCategory = keyof Settings;
+
+// Re-export base types
+export type { SettingsPath, SettingsValue };
+
+/**
+ * Get all possible setting paths from a settings object
+ */
+export function getAllSettingPaths(settings: Partial<Settings>): string[] {
+    const paths: string[] = [];
+
+    function traverse(obj: any, path: string = '') {
+        if (!obj || typeof obj !== 'object') return;
+
+        Object.entries(obj).forEach(([key, value]) => {
+            const currentPath = path ? `${path}.${key}` : key;
+            paths.push(currentPath);
+
+            if (value && typeof value === 'object' && !Array.isArray(value)) {
+                traverse(value, currentPath);
+            }
+        });
+    }
+
+    traverse(settings);
+    return paths;
+}
+
+/**
+ * Format a setting path into a human-readable name
+ */
+export function formatSettingName(path: string): string {
+    return path
+        .split('.')
+        .pop()!
+        .split(/(?=[A-Z])|[-_]/)
+        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
+        .join(' ');
+}
+
+/**
+ * Get the appropriate step value for a numeric setting
+ */
+export function getStepValue(path: SettingsPath): string {
+    // Physics settings need finer control
+    if (path.includes('physics.attractionStrength') || 
+        path.includes('physics.repulsionStrength') ||
+        path.includes('physics.springStrength')) {
+        return '0.001';
+    }
+
+    // Opacity and other normalized values
+    if (path.includes('opacity') || 
+        path.includes('metalness') || 
+        path.includes('roughness')) {
+        return '0.01';
+    }
+
+    // Size related settings
+    if (path.includes('Size') || path.includes('scale')) {
+        return '0.1';
+    }
+
+    // Animation speeds
+    if (path.includes('speed') || path.includes('strength')) {
+        return '0.05';
+    }
+
+    // Default step value
+    return '1';
+}
+
+/**
+ * Get the appropriate min/max values for a numeric setting
+ */
+export function getValueRange(path: SettingsPath): [number, number] {
+    // Physics settings
+    if (path.includes('physics.attractionStrength') || 
+        path.includes('physics.repulsionStrength') ||
+        path.includes('physics.springStrength')) {
+        return [0, 2];
+    }
+
+    // Normalized values
+    if (path.includes('opacity') || 
+        path.includes('metalness') || 
+        path.includes('roughness')) {
+        return [0, 1];
+    }
+
+    // Size related settings
+    if (path.includes('Size') || path.includes('scale')) {
+        return [0.1, 10];
+    }
+
+    // Animation speeds
+    if (path.includes('speed')) {
+        return [0, 5];
+    }
+
+    // Strength values
+    if (path.includes('strength')) {
+        return [0, 2];
+    }
+
+    // Default range
+    return [0, 100];
+}
+
+/**
+ * Get the appropriate input type for a setting
+ */
+export function getInputType(path: SettingsPath, value: SettingsValue): string {
+    // Handle specific path cases
+    if (path.endsWith('.mode') || 
+        path.endsWith('.spaceType') || 
+        path.endsWith('.quality')) {
+        return 'select';
+    }
+
+    // Handle value type cases
+    if (typeof value === 'boolean') {
+        return 'toggle';
+    }
+
+    if (typeof value === 'number') {
+        return 'slider';
+    }
+
+    if (typeof value === 'string' && value.startsWith('#')) {
+        return 'color';
+    }
+
+    if (Array.isArray(value)) {
+        if (value.length === 2 && value.every(v => typeof v === 'number')) {
+            return 'range';
+        }
+        return 'array';
+    }
+
+    return 'text';
+}
+
+/**
+ * Get select options for a setting
+ */
+export function getSelectOptions(path: SettingsPath): string[] {
+    if (path.endsWith('.mode')) {
+        return ['immersive-ar', 'immersive-vr'];
+    }
+
+    if (path.endsWith('.spaceType')) {
+        return ['viewer', 'local', 'local-floor', 'bounded-floor', 'unbounded'];
+    }
+
+    if (path.endsWith('.quality')) {
+        return ['low', 'medium', 'high'];
+    }
+
+    return [];
+}
+
+/**
+ * Check if a setting should be considered advanced
+ */
+export function isAdvancedSetting(path: SettingsPath): boolean {
+    const advancedPatterns = [
+        /physics\./,
+        /rendering\.(?!quality|backgroundColour)/,
+        /system\./,
+        /debug\./,
+        /enableInstancing/,
+        /enableMetadata/,
+        /compression/,
+        /binary/
+    ];
+
+    return advancedPatterns.some(pattern => pattern.test(path));
+}
+
+/**
+ * Get a setting value by path
+ */
+export function getSettingValue(settings: Settings, path: SettingsPath): SettingsValue | undefined {
+    const parts = path.split('.');
+    let current: any = settings;
+
+    for (const part of parts) {
+        if (current === undefined || current === null) return undefined;
+        current = current[part];
+    }
+
+    return current;
+}
+
+/**
+ * Set a setting value by path
+ */
+export function setSettingValue(settings: Settings, path: SettingsPath, value: SettingsValue): void {
+    const parts = path.split('.');
+    let current: any = settings;
+
+    for (let i = 0; i < parts.length - 1; i++) {
+        const part = parts[i];
+        if (!(part in current)) {
+            current[part] = {};
+        }
+        current = current[part];
+    }
+
+    current[parts[parts.length - 1]] = value;
+}
+
+/**
+ * Check if a setting path is valid
+ */
+export function isValidSettingPath(settings: Settings, path: SettingsPath): boolean {
+    return getSettingValue(settings, path) !== undefined;
+}
+
+/**
+ * Format a setting value for display
+ */
+export function formatSettingValue(value: SettingsValue): string {
+    if (typeof value === 'number') {
+        // Use more decimal places for small values
+        return value < 1 ? value.toFixed(3) : value.toFixed(1);
+    }
+
+    if (typeof value === 'boolean') {
+        return value ? 'Enabled' : 'Disabled';
+    }
+
+    if (Array.isArray(value)) {
+        return value.join(', ');
+    }
+
+    return String(value);
+}
diff --git a/client/types/settings/validation.ts b/client/types/settings/validation.ts
new file mode 100644
index 00000000..5d21b850
--- /dev/null
+++ b/client/types/settings/validation.ts
@@ -0,0 +1,254 @@
+import { Settings } from './base';
+
+export interface ValidationError {
+    path: string;
+    message: string;
+    value?: any;
+}
+
+export interface ValidationResult {
+    isValid: boolean;
+    errors: ValidationError[];
+}
+
+interface ValidationRule {
+    validate: (value: any) => boolean;
+    message: string;
+}
+
+const validationRules: Record<string, Record<string, ValidationRule>> = {
+    visualization: {
+        'nodes.sizeRange': {
+            validate: (value: [number, number]) => 
+                Array.isArray(value) && 
+                value.length === 2 && 
+                value[0] >= 0.01 && value[0] <= 0.5 &&  // 1cm to 50cm
+                value[1] >= value[0] && value[1] <= 0.5,
+            message: 'Node size range must be between 0.01m and 0.5m (1cm to 50cm), with min <= max'
+        },
+        'nodes.opacity': {
+            validate: (value: number) => value >= 0 && value <= 1,
+            message: 'Opacity must be between 0 and 1'
+        },
+        'nodes.metalness': {
+            validate: (value: number) => value >= 0 && value <= 1,
+            message: 'Metalness must be between 0 and 1'
+        },
+        'nodes.roughness': {
+            validate: (value: number) => value >= 0 && value <= 1,
+            message: 'Roughness must be between 0 and 1'
+        },
+        'edges.baseWidth': {
+            validate: (value: number) => value >= 0.001 && value <= 0.02,  // 1mm to 20mm
+            message: 'Edge width must be between 0.001m and 0.02m (1mm to 20mm)'
+        },
+        'edges.widthRange': {
+            validate: (value: [number, number]) => 
+                Array.isArray(value) && 
+                value.length === 2 && 
+                value[0] >= 0.001 && value[0] <= 0.02 &&  // 1mm to 20mm
+                value[1] >= value[0] && value[1] <= 0.02,
+            message: 'Edge width range must be between 0.001m and 0.02m (1mm to 20mm), with min <= max'
+        },
+        'edges.arrowSize': {
+            validate: (value: number) => value >= 0.005 && value <= 0.05,  // 5mm to 50mm
+            message: 'Arrow size must be between 0.005m and 0.05m (5mm to 50mm)'
+        },
+        'physics.attractionStrength': {
+            validate: (value: number) => value >= 0 && value <= 1.0,
+            message: 'Attraction strength must be between 0 and 100cm/s'
+        },
+        'physics.repulsionStrength': {
+            validate: (value: number) => value >= 0 && value <= 0.5,
+            message: 'Repulsion strength must be between 0 and 50cm/s (before 1/d falloff)'
+        },
+        'physics.springStrength': {
+            validate: (value: number) => value >= 0 && value <= 1.0,
+            message: 'Spring strength must be between 0 and 100cm/s per meter'
+        },
+        'physics.repulsionDistance': {
+            validate: (value: number) => value >= 0.2 && value <= 1.0,  // 20cm to 1m
+            message: 'Repulsion distance must be between 20cm and 1m'
+        },
+        'physics.collisionRadius': {
+            validate: (value: number) => value >= 0.01 && value <= 0.2,  // 1cm to 20cm
+            message: 'Collision radius must be between 1cm and 20cm'
+        },
+        'physics.boundsSize': {
+            validate: (value: number) => value >= 0.5 && value <= 5.0,  // 50cm to 5m
+            message: 'Bounds size (half-width) must be between 50cm and 5m'
+        },
+        'physics.massScale': {
+            validate: (value: number) => value >= 0 && value <= 10,
+            message: 'Mass scale must be between 0 and 10'
+        },
+        'physics.boundaryDamping': {
+            validate: (value: number) => value >= 0 && value <= 1,
+            message: 'Boundary damping (velocity retention) must be between 0% and 100%'
+        },
+        'hologram.sphereSizes': {
+            validate: (value: number[]) => 
+                Array.isArray(value) && 
+                value.every(size => size >= 0.02 && size <= 0.5) &&  // 2cm to 50cm
+                value.length >= 1,
+            message: 'Hologram sphere sizes must be between 0.02m and 0.5m (2cm to 50cm)'
+        },
+        'hologram.triangleSphereSize': {
+            validate: (value: number) => value >= 0.02 && value <= 0.5,  // 2cm to 50cm
+            message: 'Triangle sphere size must be between 0.02m and 0.5m (2cm to 50cm)'
+        },
+        'hologram.buckminsterSize': {
+            validate: (value: number) => value >= 0 && value <= 0.5,  // 0 to 50cm
+            message: 'Buckminster size must be between 0m and 0.5m (0 to 50cm)'
+        },
+        'hologram.geodesicSize': {
+            validate: (value: number) => value >= 0 && value <= 0.5,  // 0 to 50cm
+            message: 'Geodesic size must be between 0m and 0.5m (0 to 50cm)'
+        }
+    },
+    xr: {
+        'roomScale': {
+            validate: (value: number) => value >= 0.1 && value <= 2.0,
+            message: 'Room scale must be between 0.1 and 2.0 (prefer 1.0 for real-world scale)'
+        },
+        'handPointSize': {
+            validate: (value: number) => value >= 0.001 && value <= 0.02,  // 1mm to 20mm
+            message: 'Hand point size must be between 0.001m and 0.02m (1mm to 20mm)'
+        },
+        'handRayWidth': {
+            validate: (value: number) => value >= 0.001 && value <= 0.01,  // 1mm to 10mm
+            message: 'Hand ray width must be between 0.001m and 0.01m (1mm to 10mm)'
+        },
+        'interactionRadius': {
+            validate: (value: number) => value >= 0.05 && value <= 0.5,  // 5cm to 50cm
+            message: 'Interaction radius must be between 0.05m and 0.5m (5cm to 50cm)'
+        },
+        'portalSize': {
+            validate: (value: number) => value >= 0.5 && value <= 5.0,  // 50cm to 5m
+            message: 'Portal size must be between 0.5m and 5.0m'
+        },
+        'portalEdgeWidth': {
+            validate: (value: number) => value >= 0.005 && value <= 0.05,  // 5mm to 50mm
+            message: 'Portal edge width must be between 0.005m and 0.05m (5mm to 50mm)'
+        }
+    }
+};
+
+export function validateSettings(settings: Partial<Settings>): ValidationResult {
+    const errors: ValidationError[] = [];
+    
+    // Recursively validate all settings
+    function validateObject(obj: any, path: string = '') {
+        if (!obj || typeof obj !== 'object') return;
+        
+        Object.entries(obj).forEach(([key, value]) => {
+            const currentPath = path ? `${path}.${key}` : key;
+            
+            // Check if there's a validation rule for this path
+            for (const [category, rules] of Object.entries(validationRules)) {
+                if (currentPath.startsWith(category)) {
+                    const rule = rules[currentPath];
+                    if (rule && !rule.validate(value)) {
+                        errors.push({
+                            path: currentPath,
+                            message: rule.message,
+                            value
+                        });
+                    }
+                }
+            }
+            
+            // Recursively validate nested objects
+            if (value && typeof value === 'object' && !Array.isArray(value)) {
+                validateObject(value, currentPath);
+            }
+        });
+    }
+    
+    validateObject(settings);
+    
+    return {
+        isValid: errors.length === 0,
+        errors
+    };
+}
+
+export function validateSettingValue(path: string, value: any, currentSettings: Settings): ValidationError[] {
+    const errors: ValidationError[] = [];
+    
+    // Find matching validation rule
+    for (const [category, rules] of Object.entries(validationRules)) {
+        if (path.startsWith(category)) {
+            const rule = rules[path];
+            if (rule && !rule.validate(value)) {
+                errors.push({
+                    path,
+                    message: rule.message,
+                    value
+                });
+            }
+        }
+    }
+    
+    // Special validation for interdependent settings
+    if (path.includes('physics')) {
+        validatePhysicsSettings(path, value, currentSettings, errors);
+    } else if (path.includes('rendering')) {
+        validateRenderingSettings(path, value, currentSettings, errors);
+    }
+    
+    return errors;
+}
+
+function validatePhysicsSettings(
+    path: string,
+    value: any,
+    settings: Settings,
+    errors: ValidationError[]
+): void {
+    const physics = settings.visualization.physics;
+    
+    // Validate repulsion distance relative to collision radius
+    if (path === 'visualization.physics.repulsionDistance' && physics.collisionRadius) {
+        const ratio = value / physics.collisionRadius;
+        if (ratio < 4 || ratio > 10) {
+            errors.push({
+                path,
+                message: 'Repulsion distance should be 4-10x the collision radius for stable spacing',
+                value
+            });
+        }
+    }
+}
+
+function validateRenderingSettings(
+    path: string,
+    value: any,
+    settings: Settings,
+    errors: ValidationError[]
+): void {
+    const rendering = settings.visualization.rendering;
+    
+    // Example: Warn about performance impact of combined settings
+    if (path === 'visualization.rendering.quality' && value === 'high') {
+        if (rendering.enableShadows && rendering.enableAmbientOcclusion) {
+            errors.push({
+                path,
+                message: 'High quality with shadows and ambient occlusion may impact performance',
+                value
+            });
+        }
+    }
+}
+
+export function getValidationTooltip(path: string): string | undefined {
+    for (const [category, rules] of Object.entries(validationRules)) {
+        if (path.startsWith(category)) {
+            const rule = rules[path];
+            if (rule) {
+                return rule.message;
+            }
+        }
+    }
+    return undefined;
+}
\ No newline at end of file
diff --git a/client/types/settings/xr.ts b/client/types/settings/xr.ts
new file mode 100644
index 00000000..282f51cd
--- /dev/null
+++ b/client/types/settings/xr.ts
@@ -0,0 +1,129 @@
+import { XRSessionMode } from '../xr';
+
+export interface XRSettings {
+    // Session Settings
+    mode: XRSessionMode;
+    roomScale: number;  // Scale factor for the entire XR scene (1.0 = real-world scale)
+    spaceType: 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
+    quality: 'low' | 'medium' | 'high';
+    
+    // Platform Settings
+    autoEnterAR?: boolean;
+    hideControlPanel?: boolean;
+    preferredMode?: XRSessionMode;
+    
+    // Hand Tracking
+    enableHandTracking: boolean;
+    handMeshEnabled: boolean;
+    handMeshColor: string;
+    handMeshOpacity: number;
+    handPointSize: number;  // In meters (e.g., 0.006 for 6mm)
+    handRayEnabled: boolean;
+    handRayColor: string;
+    handRayWidth: number;  // In meters (e.g., 0.003 for 3mm)
+    gestureSmoothing: number;
+    
+    // Interaction
+    enableHaptics: boolean;
+    hapticIntensity: number;
+    dragThreshold: number;
+    pinchThreshold: number;
+    rotationThreshold: number;
+    interactionRadius: number;  // In meters (e.g., 0.15 for 15cm)
+    movementSpeed: number;
+    deadZone: number;
+    movementAxes: {
+        horizontal: number;
+        vertical: number;
+    };
+    
+    // Scene Understanding
+    enableLightEstimation: boolean;
+    enablePlaneDetection: boolean;
+    enableSceneUnderstanding: boolean;
+    planeColor: string;
+    planeOpacity: number;
+    showPlaneOverlay: boolean;
+    snapToFloor: boolean;
+    planeDetectionDistance?: number;  // In meters (e.g., 3.0 for 3m)
+    
+    // Passthrough
+    enablePassthroughPortal: boolean;
+    passthroughOpacity: number;
+    passthroughBrightness: number;
+    passthroughContrast: number;
+    portalSize: number;  // In meters (e.g., 2.5 for 2.5m)
+    portalEdgeColor: string;
+    portalEdgeWidth: number;  // In meters (e.g., 0.02 for 2cm)
+}
+
+// Platform-specific XR settings
+export interface QuestXRSettings extends XRSettings {
+    enableHandMeshes: boolean;
+    enableControllerModel: boolean;
+    controllerProfile: string;
+}
+
+export interface WebXRSettings extends XRSettings {
+    fallbackToInline: boolean;
+    requireFeatures: string[];
+    optionalFeatures: string[];
+}
+
+// Default XR settings
+export const defaultXRSettings: XRSettings = {
+    // Session Settings
+    mode: 'immersive-ar',
+    roomScale: 1.0,  // Real-world 1:1 scale
+    spaceType: 'local-floor',
+    quality: 'high',
+    
+    // Platform Settings
+    autoEnterAR: true,
+    hideControlPanel: true,
+    preferredMode: 'immersive-ar',
+    
+    // Hand Tracking
+    enableHandTracking: true,
+    handMeshEnabled: true,
+    handMeshColor: '#ffffff',
+    handMeshOpacity: 0.5,
+    handPointSize: 0.006,  // 6mm
+    handRayEnabled: true,
+    handRayColor: '#00ff00',
+    handRayWidth: 0.003,  // 3mm
+    gestureSmoothing: 0.5,
+    
+    // Interaction
+    enableHaptics: true,
+    hapticIntensity: 0.5,
+    dragThreshold: 0.02,  // 2cm movement required to start drag
+    pinchThreshold: 0.3,  // 30% pinch required for activation
+    rotationThreshold: 0.08,  // 8% rotation required for activation
+    interactionRadius: 0.15,  // 15cm interaction sphere
+    movementSpeed: 0.08,  // 8cm per frame at full stick deflection
+    deadZone: 0.12,  // 12% stick movement required
+    movementAxes: {
+        horizontal: 2,  // Right joystick X
+        vertical: 3    // Right joystick Y
+    },
+    
+    // Scene Understanding
+    enableLightEstimation: true,
+    enablePlaneDetection: true,
+    enableSceneUnderstanding: true,
+    planeColor: '#808080',
+    planeOpacity: 0.5,
+    showPlaneOverlay: true,
+    snapToFloor: true,
+    planeDetectionDistance: 3.0,  // 3 meters
+    
+    // Passthrough
+    enablePassthroughPortal: false,
+    passthroughOpacity: 1.0,
+    passthroughBrightness: 1.0,
+    passthroughContrast: 1.0,
+    portalSize: 2.5,  // 2.5 meters
+    portalEdgeColor: '#ffffff',
+    portalEdgeWidth: 0.02  // 2cm
+};
diff --git a/client/types/three-examples.d.ts b/client/types/three-examples.d.ts
new file mode 100644
index 00000000..f63afad7
--- /dev/null
+++ b/client/types/three-examples.d.ts
@@ -0,0 +1,88 @@
+declare module 'three/examples/jsm/controls/OrbitControls' {
+  import { Camera, EventDispatcher } from 'three';
+  export class OrbitControls extends EventDispatcher {
+    constructor(camera: Camera, domElement?: HTMLElement);
+    enabled: boolean;
+    enableDamping: boolean;
+    dampingFactor: number;
+    screenSpacePanning: boolean;
+    minDistance: number;
+    maxDistance: number;
+    enableRotate: boolean;
+    enableZoom: boolean;
+    enablePan: boolean;
+    rotateSpeed: number;
+    zoomSpeed: number;
+    panSpeed: number;
+    update(): void;
+    dispose(): void;
+  }
+}
+
+declare module 'three/examples/jsm/postprocessing/EffectComposer' {
+  import { WebGLRenderer, WebGLRenderTarget } from 'three';
+  export class EffectComposer {
+    constructor(renderer: WebGLRenderer);
+    renderTarget1: WebGLRenderTarget;
+    renderTarget2: WebGLRenderTarget;
+    passes: any[];
+    addPass(pass: any): void;
+    render(): void;
+    setSize(width: number, height: number): void;
+  }
+}
+
+declare module 'three/examples/jsm/postprocessing/RenderPass' {
+  import { Scene, Camera } from 'three';
+  export class RenderPass {
+    constructor(scene: Scene, camera: Camera);
+  }
+}
+
+declare module 'three/examples/jsm/postprocessing/UnrealBloomPass' {
+  import { Vector2 } from 'three';
+  export class UnrealBloomPass {
+    constructor(resolution: Vector2, strength: number, radius: number, threshold: number);
+    enabled: boolean;
+    strength: number;
+    radius: number;
+    threshold: number;
+    resolution: Vector2;
+  }
+}
+
+declare module 'three/examples/jsm/geometries/TextGeometry.js' {
+  import { BufferGeometry, Vector3, Box3 } from 'three';
+  export class TextGeometry extends BufferGeometry {
+    constructor(text: string, parameters: TextGeometryParameters);
+    boundingBox: Box3 | null;
+    computeBoundingBox(): void;
+  }
+  
+  export interface TextGeometryParameters {
+    font: any;
+    size?: number;
+    depth?: number;
+    curveSegments?: number;
+    bevelEnabled?: boolean;
+  }
+}
+
+declare module 'three/examples/jsm/loaders/FontLoader.js' {
+  import { Loader } from 'three';
+  export class FontLoader extends Loader {
+    constructor();
+    load(url: string, onLoad?: (font: Font) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): void;
+  }
+  export class Font {
+    constructor(data: any);
+  }
+}
+
+declare module 'three/examples/jsm/webxr/XRControllerModelFactory' {
+  import { Group } from 'three';
+  export class XRControllerModelFactory {
+    constructor();
+    createControllerModel(controller: Group): Group;
+  }
+}
\ No newline at end of file
diff --git a/client/types/three-ext.d.ts b/client/types/three-ext.d.ts
new file mode 100644
index 00000000..ee3a57d0
--- /dev/null
+++ b/client/types/three-ext.d.ts
@@ -0,0 +1,113 @@
+import { Texture, BufferGeometry, BufferAttribute, Camera, Scene, WebGLRenderer, Object3D, Material, Vector2 } from 'three';
+
+declare module 'three' {
+    export const NearestFilter: TextureFilter;
+    export const LinearFilter: TextureFilter;
+    export const ClampToEdgeWrapping: TextureWrapping;
+    
+    export type TextureFilter = number;
+    export type TextureWrapping = number;
+    
+    export interface Texture {
+        minFilter: TextureFilter;
+        magFilter: TextureFilter;
+        wrapS: TextureWrapping;
+        wrapT: TextureWrapping;
+    }
+    
+    export interface BufferGeometry {
+        getAttribute(name: string): BufferAttribute;
+    }
+    
+    export interface Color {
+        toArray(array?: number[], offset?: number): number[];
+    }
+    
+    export interface PlaneGeometry extends BufferGeometry {
+        getAttribute(name: string): BufferAttribute;
+    }
+
+    // OrbitControls
+    export class OrbitControls {
+        constructor(camera: Camera, domElement: HTMLElement);
+        enabled: boolean;
+        target: Vector3;
+        minDistance: number;
+        maxDistance: number;
+        enableDamping: boolean;
+        dampingFactor: number;
+        update(): void;
+        dispose(): void;
+    }
+
+    // Effect Composer
+    export class EffectComposer {
+        constructor(renderer: WebGLRenderer);
+        addPass(pass: Pass): void;
+        render(deltaTime?: number): void;
+        setSize(width: number, height: number): void;
+        dispose(): void;
+    }
+
+    export class Pass {
+        enabled: boolean;
+        needsSwap: boolean;
+        clear: boolean;
+        renderToScreen: boolean;
+    }
+
+    export class RenderPass extends Pass {
+        constructor(scene: Scene, camera: Camera);
+    }
+
+    export class UnrealBloomPass extends Pass {
+        constructor(resolution: Vector2, strength: number, radius: number, threshold: number);
+        strength: number;
+        radius: number;
+        threshold: number;
+        resolution: Vector2;
+    }
+
+    // XR Controller Model Factory
+    export class XRControllerModelFactory {
+        constructor();
+        createControllerModel(controller: Object3D): Object3D;
+    }
+
+    // Grip Space
+    export interface Group {
+        grip?: Object3D;
+    }
+
+    // WebXR Manager
+    export interface WebGLRenderer {
+        xr: {
+            enabled: boolean;
+            isPresenting: boolean;
+            setReferenceSpaceType(type: string): void;
+            setSession(session: any): Promise<void>;
+            getCamera(): Camera;
+        };
+    }
+}
+
+// Declare modules for examples
+declare module 'three/examples/jsm/controls/OrbitControls' {
+    export { OrbitControls } from 'three';
+}
+
+declare module 'three/examples/jsm/postprocessing/EffectComposer' {
+    export { EffectComposer } from 'three';
+}
+
+declare module 'three/examples/jsm/postprocessing/RenderPass' {
+    export { RenderPass } from 'three';
+}
+
+declare module 'three/examples/jsm/postprocessing/UnrealBloomPass' {
+    export { UnrealBloomPass } from 'three';
+}
+
+declare module 'three/examples/jsm/webxr/XRControllerModelFactory' {
+    export { XRControllerModelFactory } from 'three';
+}
diff --git a/client/types/three.d.ts b/client/types/three.d.ts
new file mode 100644
index 00000000..7273ff9e
--- /dev/null
+++ b/client/types/three.d.ts
@@ -0,0 +1,526 @@
+declare module 'three' {
+  export interface Event {
+    type: string;
+    target: Group;
+  }
+
+  export interface XRControllerEvent extends Event {
+    type: 'connected' | 'disconnected';
+    target: Group;
+    data: XRInputSource;
+  }
+
+  export interface Object3DEventMap {
+    connected: XRControllerEvent;
+    disconnected: XRControllerEvent;
+  }
+
+  export interface EventDispatcher<E extends Event = Event> {
+    addEventListener<T extends E['type']>(type: T, listener: (event: E & { type: T }) => void): void;
+    removeEventListener<T extends E['type']>(type: T, listener: (event: E & { type: T }) => void): void;
+    dispatchEvent(event: E): void;
+  }
+
+  export class Layers {
+    mask: number;
+    set(layer: number): void;
+    enable(layer: number): void;
+    disable(layer: number): void;
+    toggle(layer: number): void;
+    test(layers: Layers): boolean;
+  }
+
+  export class Object3D implements EventDispatcher<Event & XRControllerEvent> {
+    position: Vector3;
+    quaternion: Quaternion;
+    scale: Vector3;
+    matrix: Matrix4;
+    matrixWorld: Matrix4;
+    children: Object3D[];
+    parent: Object3D | null;
+    userData: any;
+    visible: boolean;
+    renderOrder: number;
+    frustumCulled: boolean;
+    matrixAutoUpdate: boolean;
+    layers: Layers;
+    add(...objects: Object3D[]): this;
+    remove(...objects: Object3D[]): this;
+    rotateX(angle: number): this;
+    rotateY(angle: number): this;
+    rotateZ(angle: number): this;
+    updateMatrix(): void;
+    updateMatrixWorld(force?: boolean): void;
+    traverse(callback: (object: Object3D) => void): void;
+    lookAt(x: number | Vector3, y?: number, z?: number): void;
+    addEventListener<K extends keyof Object3DEventMap>(
+      type: K,
+      listener: (event: Object3DEventMap[K]) => void
+    ): void;
+    addEventListener(
+      type: string,
+      listener: (event: Event) => void
+    ): void;
+    removeEventListener<K extends keyof Object3DEventMap>(
+      type: K,
+      listener: (event: Object3DEventMap[K]) => void
+    ): void;
+    removeEventListener(
+      type: string,
+      listener: (event: Event) => void
+    ): void;
+    dispatchEvent(event: Event): void;
+  }
+
+  export class Group extends Object3D {
+    constructor();
+  }
+
+  export class Scene extends Object3D {
+    constructor();
+    fog: FogExp2 | null;
+    background: Color | Texture | null;
+  }
+
+  export class Material {
+    transparent: boolean;
+    opacity: number;
+    depthWrite: boolean;
+    depthTest: boolean;
+    side: Side;
+    color: Color;
+    dispose(): void;
+  }
+
+  export class Mesh extends Object3D {
+    constructor(geometry: BufferGeometry, material: Material);
+    geometry: BufferGeometry;
+    material: Material;
+  }
+
+  export class GridHelper extends Object3D {
+    constructor(size: number, divisions: number, color1?: ColorRepresentation, color2?: ColorRepresentation);
+    material: Material;
+    geometry: BufferGeometry;
+  }
+
+  export class Light extends Object3D {
+    constructor(color?: ColorRepresentation, intensity?: number);
+    intensity: number;
+  }
+
+  export class DirectionalLight extends Light {
+    constructor(color?: ColorRepresentation, intensity?: number);
+    intensity: number;
+  }
+
+  export class AmbientLight extends Light {
+    constructor(color?: ColorRepresentation, intensity?: number);
+  }
+
+  export class BufferAttribute {
+    array: ArrayLike<number>;
+    itemSize: number;
+    count: number;
+    normalized: boolean;
+    needsUpdate: boolean;
+    constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean);
+    setX(index: number, x: number): this;
+    setY(index: number, y: number): this;
+    setZ(index: number, z: number): this;
+    setW(index: number, w: number): this;
+    setXY(index: number, x: number, y: number): this;
+    setXYZ(index: number, x: number, y: number, z: number): this;
+    setXYZW(index: number, x: number, y: number, z: number, w: number): this;
+  }
+
+  export class InstancedBufferAttribute extends BufferAttribute {
+    constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean, meshPerAttribute?: number);
+    meshPerAttribute: number;
+  }
+
+  export class InstancedMesh extends Mesh {
+    constructor(geometry: BufferGeometry, material: Material | Material[], count: number);
+    count: number;
+    instanceMatrix: InstancedBufferAttribute;
+    instanceColor: InstancedBufferAttribute | null;
+    frustumCulled: boolean;
+    setColorAt(index: number, color: Color): void;
+    setMatrixAt(index: number, matrix: Matrix4): void;
+    getMatrixAt(index: number, matrix: Matrix4): void;
+    getColorAt(index: number, color: Color): void;
+    dispose(): void;
+  }
+
+  export class MeshBasicMaterial extends Material {
+    constructor(parameters?: MeshBasicMaterialParameters);
+  }
+
+  export class LineBasicMaterial extends Material {
+    constructor(parameters?: MaterialParameters);
+  }
+
+  export class MeshPhongMaterial extends Material {
+    constructor(parameters?: MeshPhongMaterialParameters);
+    shininess: number;
+    specular: Color;
+  }
+
+  export class MeshStandardMaterial extends Material {
+    constructor(parameters?: MeshStandardMaterialParameters);
+    metalness: number;
+    roughness: number;
+    map: Texture | null;
+    emissive: Color;
+  }
+
+  export class SpriteMaterial extends Material {
+    constructor(parameters?: SpriteMaterialParameters);
+    map: Texture | null;
+    color: Color;
+    sizeAttenuation: boolean;
+    rotation: number;
+  }
+
+  export class BufferGeometry {
+    dispose(): void;
+    rotateX(angle: number): this;
+    rotateY(angle: number): this;
+    rotateZ(angle: number): this;
+    setAttribute(name: string, attribute: BufferAttribute): this;
+    setIndex(index: BufferAttribute): this;
+    computeBoundingSphere(): void;
+    boundingSphere: { center: Vector3; radius: number } | null;
+    boundingBox: { min: Vector3; max: Vector3 } | null;
+  }
+
+  export class PlaneGeometry extends BufferGeometry {
+    constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number);
+  }
+
+  export class SphereGeometry extends BufferGeometry {
+    constructor(radius?: number, widthSegments?: number, heightSegments?: number);
+  }
+
+  export class CylinderGeometry extends BufferGeometry {
+    constructor(
+      radiusTop?: number,
+      radiusBottom?: number,
+      height?: number,
+      radialSegments?: number
+    );
+  }
+
+  export class RingGeometry extends BufferGeometry {
+    constructor(
+      innerRadius?: number,
+      outerRadius?: number,
+      thetaSegments?: number
+    );
+  }
+
+  export class Vector2 {
+    x: number;
+    y: number;
+    constructor(x?: number, y?: number);
+    set(x: number, y: number): this;
+  }
+
+  export class Vector3 {
+    x: number;
+    y: number;
+    z: number;
+    constructor(x?: number, y?: number, z?: number);
+    set(x: number, y: number, z: number): this;
+    copy(v: Vector3): this;
+    add(v: Vector3): this;
+    sub(v: Vector3): this;
+    multiply(v: Vector3): this;
+    multiplyScalar(s: number): this;
+    normalize(): this;
+    dot(v: Vector3): number;
+    cross(v: Vector3): this;
+    length(): number;
+    lengthSq(): number;
+    clone(): Vector3;
+    fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
+    subVectors(a: Vector3, b: Vector3): this;
+    addVectors(a: Vector3, b: Vector3): this;
+    crossVectors(a: Vector3, b: Vector3): this;
+    setFromMatrixPosition(m: Matrix4): this;
+    distanceTo(v: Vector3): number;
+    applyMatrix4(m: Matrix4): this;
+    lookAt(v: Vector3): this;
+  }
+
+  export class Matrix4 {
+    elements: number[];
+    constructor();
+    set(...elements: number[]): this;
+    identity(): this;
+    copy(m: Matrix4): this;
+    compose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
+    decompose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
+    fromArray(array: ArrayLike<number>, offset?: number): this;
+    extractRotation(m: Matrix4): this;
+    makeRotationX(theta: number): this;
+    makeRotationY(theta: number): this;
+    makeRotationZ(theta: number): this;
+    makeScale(x: number, y: number, z: number): this;
+    multiply(m: Matrix4): this;
+    makeRotationFromQuaternion(q: Quaternion): this;
+  }
+
+  export class Quaternion {
+    x: number;
+    y: number;
+    z: number;
+    w: number;
+    constructor(x?: number, y?: number, z?: number, w?: number);
+    setFromAxisAngle(axis: Vector3, angle: number): this;
+    identity(): this;
+    multiply(q: Quaternion): this;
+    setFromEuler(euler: Euler): this;
+  }
+
+  export class Euler {
+    constructor(x?: number, y?: number, z?: number, order?: string);
+    x: number;
+    y: number;
+    z: number;
+    order: string;
+  }
+
+  export class Color {
+    constructor(color?: ColorRepresentation);
+    set(color: ColorRepresentation): this;
+    setHSL(h: number, s: number, l: number): Color;
+    clone(): Color;
+  }
+
+  export class Sprite extends Object3D {
+    constructor(material: SpriteMaterial);
+    material: SpriteMaterial;
+  }
+
+  export class Raycaster {
+    constructor();
+    ray: Ray;
+    near: number;
+    far: number;
+    camera: Camera;
+    params: {
+      Mesh?: {},
+      Line?: {},
+      LOD?: {},
+      Points?: { threshold: number },
+      Sprite?: {}
+    };
+    setFromCamera(coords: Vector2, camera: Camera): void;
+    intersectObject(object: Object3D, recursive?: boolean, intersects?: Intersection[]): Intersection[];
+    intersectObjects(objects: Object3D[], recursive?: boolean, intersects?: Intersection[]): Intersection[];
+  }
+
+  export class Ray {
+    origin: Vector3;
+    direction: Vector3;
+    constructor(origin?: Vector3, direction?: Vector3);
+  }
+
+  export class WebGLRenderer {
+    constructor(parameters?: WebGLRendererParameters);
+    domElement: HTMLCanvasElement;
+    setSize(width: number, height: number, updateStyle?: boolean): void;
+    setPixelRatio(value: number): void;
+    render(scene: Scene, camera: Camera): void;
+    dispose(): void;
+    xr: WebXRManager;
+    setAnimationLoop(callback: ((time: number) => void) | null): void;
+  }
+
+  export interface WebXRManager {
+    enabled: boolean;
+    setSession(session: XRSession): Promise<void>;
+    addEventListener(type: string, listener: EventListener): void;
+    removeEventListener(type: string, listener: EventListener): void;
+  }
+
+  export class Camera extends Object3D {
+    matrixWorldInverse: Matrix4;
+    projectionMatrix: Matrix4;
+    projectionMatrixInverse: Matrix4;
+    layers: Layers;
+    lookAt(target: Vector3 | number, y?: number, z?: number): void;
+  }
+
+  export class PerspectiveCamera extends Camera {
+    constructor(fov?: number, aspect?: number, near?: number, far?: number);
+    fov: number;
+    aspect: number;
+    near: number;
+    far: number;
+    updateProjectionMatrix(): void;
+    lookAt(target: Vector3 | number, y?: number, z?: number): void;
+  }
+
+  export interface MaterialParameters {
+    color?: ColorRepresentation;
+    transparent?: boolean;
+    opacity?: number;
+    side?: Side;
+    depthWrite?: boolean;
+    depthTest?: boolean;
+    map?: Texture;
+  }
+
+  export interface MeshBasicMaterialParameters extends MaterialParameters {
+    wireframe?: boolean;
+  }
+
+  export interface MeshPhongMaterialParameters extends MaterialParameters {
+    shininess?: number;
+    specular?: ColorRepresentation;
+  }
+  export interface MeshStandardMaterialParameters extends MaterialParameters {
+    metalness?: number;
+    roughness?: number;
+    map?: Texture | null;
+    emissive?: ColorRepresentation;
+  }
+
+  export interface SpriteMaterialParameters extends MaterialParameters {
+    sizeAttenuation?: boolean;
+    rotation?: number;
+  }
+
+  export class Texture {
+    constructor(image?: HTMLImageElement | HTMLCanvasElement);
+    needsUpdate: boolean;
+    dispose(): void;
+  }
+
+  export class FogExp2 {
+    constructor(color: ColorRepresentation, density?: number);
+    color: Color;
+    density: number;
+  }
+
+  export interface Intersection {
+    distance: number;
+    point: Vector3;
+    face: { normal: Vector3 } | null;
+    object: Object3D;
+  }
+
+  export class MathUtils {
+    static clamp(value: number, min: number, max: number): number;
+    static degToRad(degrees: number): number;
+    static radToDeg(radians: number): number;
+    static lerp(x: number, y: number, t: number): number;
+    static smoothstep(x: number, min: number, max: number): number;
+  }
+
+  export const DoubleSide: Side;
+  export type Side = 0 | 1 | 2;
+  export type ColorRepresentation = Color | string | number;
+
+  export class Clock {
+    constructor(autoStart?: boolean);
+    start(): void;
+    stop(): void;
+    getElapsedTime(): number;
+    getDelta(): number;
+  }
+
+  export class TorusGeometry extends BufferGeometry {
+    constructor(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number);
+  }
+
+  export class IcosahedronGeometry extends BufferGeometry {
+    constructor(radius?: number, detail?: number);
+  }
+
+  export class OctahedronGeometry extends BufferGeometry {
+    constructor(radius?: number, detail?: number);
+  }
+
+  export class ShaderMaterial extends Material {
+    constructor(parameters?: ShaderMaterialParameters);
+    uniforms: { [uniform: string]: { value: any } };
+    defines: { [define: string]: string | number | boolean };
+    needsUpdate: boolean;
+  }
+
+  export interface Material {
+    clone(): Material;
+    uniforms?: { [uniform: string]: { value: any } };
+    defines?: { [define: string]: string | number | boolean };
+    needsUpdate: boolean;
+  }
+
+  export interface Vector3 {
+    setScalar(scalar: number): Vector3;
+    fromBufferAttribute(attribute: BufferAttribute, index: number): Vector3;
+  }
+
+  export interface Quaternion {
+    copy(quaternion: Quaternion): Quaternion;
+  }
+
+  export interface Mesh extends Object3D {
+    rotation: Euler;
+    material: Material;
+  }
+
+  export interface Group extends Object3D {
+    onBeforeRender?: (renderer: WebGLRenderer, scene: Scene, camera: Camera) => void;
+  }
+
+  export interface Color {
+    setHSL(h: number, s: number, l: number): Color;
+  }
+
+  export interface XRHand extends Map<XRHandJoint, XRJointSpace> {
+    joints: { [key: string]: XRJointSpace };
+  }
+
+  export const AdditiveBlending: number;
+  export const NormalBlending: number;
+  export const MultiplyBlending: number;
+
+  export class TextGeometry extends BufferGeometry {
+    constructor(text: string, parameters?: {
+        font: Font;
+        size?: number;
+        height?: number;
+        curveSegments?: number;
+        bevelEnabled?: boolean;
+        bevelThickness?: number;
+        bevelSize?: number;
+        bevelOffset?: number;
+        bevelSegments?: number;
+    });
+    computeBoundingBox(): void;
+    boundingBox: Box3 | null;
+    dispose(): void;
+    rotateX(angle: number): this;
+    rotateY(angle: number): this;
+    rotateZ(angle: number): this;
+    translate(x: number, y: number, z: number): this;
+  }
+
+  export class Box3 {
+    min: Vector3;
+    max: Vector3;
+    constructor(min?: Vector3, max?: Vector3);
+  }
+
+  export interface XRJointSpace {
+    position: Vector3;
+    matrixWorld: Matrix4;
+  }
+
+  export interface XRHand extends Map<XRHandJoint, XRJointSpace> {
+    joints: { [key: string]: XRJointSpace };
+  }
+}
diff --git a/client/types/websocket.ts b/client/types/websocket.ts
new file mode 100644
index 00000000..8ad79aae
--- /dev/null
+++ b/client/types/websocket.ts
@@ -0,0 +1,34 @@
+// WebSocket types for graph synchronization
+
+export enum ConnectionState {
+    DISCONNECTED = 'DISCONNECTED',
+    CONNECTING = 'CONNECTING',
+    CONNECTED = 'CONNECTED',
+    RECONNECTING = 'RECONNECTING'
+}
+
+export enum MessageType {
+    PING = 'ping',                          // Connection health check
+    PONG = 'pong'                           // Connection health response
+}
+
+// Connection health messages
+export interface PingMessage {
+    type: MessageType.PING;
+    timestamp: number;
+}
+
+export interface PongMessage {
+    type: MessageType.PONG;
+    timestamp: number;
+}
+
+export type WebSocketMessage = PingMessage | PongMessage;
+
+// WebSocket settings loaded via REST API
+export interface WebSocketSettings {
+    url: string;                  // WebSocket URL
+    reconnectAttempts: number;     // Max reconnection attempts (default: 3)
+    reconnectDelay: number;        // Delay between reconnects in ms (default: 5000)
+    updateRate: number;            // Update rate in Hz
+}
diff --git a/client/types/webxr.d.ts b/client/types/webxr.d.ts
new file mode 100644
index 00000000..2c0fb175
--- /dev/null
+++ b/client/types/webxr.d.ts
@@ -0,0 +1,140 @@
+/**
+ * WebXR API type extensions
+ */
+
+declare module 'three' {
+  interface Object3DEventMap {
+    connected: XRControllerEvent;
+    disconnected: XRControllerEvent;
+  }
+}
+
+interface XRControllerEvent extends THREE.Event {
+  type: 'connected' | 'disconnected';
+  data: XRInputSource;
+}
+
+interface XRLightEstimate {
+  primaryLightIntensity?: { value: number };
+  primaryLightDirection?: { x: number; y: number; z: number };
+}
+
+// Extend existing WebXR types
+declare global {
+  interface XRFrame {
+    // Make getLightEstimate optional
+    getLightEstimate?(): XRLightEstimate | null;
+    getHitTestResults(hitTestSource: XRHitTestSource): XRHitTestResult[];
+    getViewerPose(referenceSpace: XRReferenceSpace): XRViewerPose | null;
+    getPose(space: XRSpace, baseSpace: XRReferenceSpace): XRPose | null;
+  }
+
+  interface XRSession {
+    requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace>;
+    // Make requestHitTestSource non-optional
+    requestHitTestSource(options: XRHitTestOptionsInit): Promise<XRHitTestSource>;
+    end(): Promise<void>;
+    addEventListener(type: string, listener: EventListener): void;
+    removeEventListener(type: string, listener: EventListener): void;
+  }
+
+  interface XRHitTestOptionsInit {
+    space: XRSpace;
+    offsetRay?: XRRay;
+  }
+
+  interface XRHitTestSource {
+    cancel(): void;
+  }
+
+  interface XRHitTestResult {
+    getPose(baseSpace: XRSpace): XRPose | null;
+  }
+
+  interface XRPose {
+    transform: XRRigidTransform;
+  }
+
+  interface XRViewerPose extends XRPose {
+    views: XRView[];
+  }
+
+  interface XRView {
+    projectionMatrix: Float32Array;
+    transform: XRRigidTransform;
+  }
+
+  interface XRRigidTransform {
+    matrix: Float32Array;
+    position: { x: number; y: number; z: number };
+    orientation: { x: number; y: number; z: number; w: number };
+  }
+
+  interface XRReferenceSpace extends XRSpace {
+    getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
+  }
+
+  interface XRSpace {}
+
+  interface XRRay {
+    origin: DOMPointReadOnly;
+    direction: DOMPointReadOnly;
+    matrix: Float32Array;
+  }
+
+  type XRReferenceSpaceType = 
+    | 'viewer'
+    | 'local'
+    | 'local-floor'
+    | 'bounded-floor'
+    | 'unbounded';
+
+  interface XRInputSource {
+    handedness: 'none' | 'left' | 'right';
+    targetRayMode: 'gaze' | 'tracked-pointer' | 'screen';
+    targetRaySpace: XRSpace;
+    gripSpace?: XRSpace;
+    profiles: string[];
+    gamepad?: Gamepad;
+    hand?: XRHand;
+  }
+
+  interface XRHand extends Map<XRHandJoint, XRJointSpace> {
+    get(joint: XRHandJoint): XRJointSpace | undefined;
+  }
+
+  export type XRHandJoint =
+    | 'wrist'
+    | 'thumb-metacarpal'
+    | 'thumb-phalanx-proximal'
+    | 'thumb-phalanx-distal'
+    | 'thumb-tip'
+    | 'index-finger-metacarpal'
+    | 'index-finger-phalanx-proximal'
+    | 'index-finger-phalanx-intermediate'
+    | 'index-finger-phalanx-distal'
+    | 'index-finger-tip';
+
+  export interface XRJointSpace extends XRSpace {
+    jointRadius: number | undefined;
+    position: { x: number; y: number; z: number };
+    matrixWorld: THREE.Matrix4;
+  }
+
+  interface Navigator {
+    xr?: {
+      isSessionSupported(mode: string): Promise<boolean>;
+      requestSession(mode: string, options?: XRSessionInit): Promise<XRSession>;
+    };
+  }
+
+  interface XRSessionInit {
+    requiredFeatures?: string[];
+    optionalFeatures?: string[];
+  }
+}
+
+// Prevent conflicts with @types/webxr
+declare module '@types/webxr' {
+  export {};
+}
diff --git a/client/types/xr.ts b/client/types/xr.ts
new file mode 100644
index 00000000..4aab75be
--- /dev/null
+++ b/client/types/xr.ts
@@ -0,0 +1,129 @@
+import * as THREE from 'three';
+import { Platform } from '../core/types';
+
+// Core XR Types
+export type XRSessionMode = 'inline' | 'immersive-vr' | 'immersive-ar';
+export type XRHandedness = 'none' | 'left' | 'right';
+export type XRSessionState = 'inactive' | 'starting' | 'active' | 'ending' | 'cooldown';
+export type XRHand = THREE.XRHand;
+
+export type XRHandJoint =
+    | 'wrist'
+    | 'thumb-metacarpal'
+    | 'thumb-phalanx-proximal'
+    | 'thumb-phalanx-distal'
+    | 'thumb-tip'
+    | 'index-finger-metacarpal'
+    | 'index-finger-phalanx-proximal'
+    | 'index-finger-phalanx-intermediate'
+    | 'index-finger-phalanx-distal'
+    | 'index-finger-tip'
+    | 'middle-finger-metacarpal'
+    | 'middle-finger-phalanx-proximal'
+    | 'middle-finger-phalanx-intermediate'
+    | 'middle-finger-phalanx-distal'
+    | 'middle-finger-tip'
+    | 'ring-finger-metacarpal'
+    | 'ring-finger-phalanx-proximal'
+    | 'ring-finger-phalanx-intermediate'
+    | 'ring-finger-phalanx-distal'
+    | 'ring-finger-tip'
+    | 'pinky-finger-metacarpal'
+    | 'pinky-finger-phalanx-proximal'
+    | 'pinky-finger-phalanx-intermediate'
+    | 'pinky-finger-phalanx-distal'
+    | 'pinky-finger-tip';
+
+export interface XRSessionConfig {
+    mode: XRSessionMode;
+    features: {
+        required?: string[];
+        optional?: string[];
+    };
+    spaceType: XRReferenceSpaceType;
+}
+
+// Input and Interaction Types
+export interface HapticActuator {
+    pulse: (intensity: number, duration: number) => Promise<boolean>;
+}
+
+export interface WorldObject3D extends THREE.Object3D {
+    getWorldPosition(target: THREE.Vector3): THREE.Vector3;
+}
+
+export interface XRControllerState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    hapticActuator?: HapticActuator;
+    platform: Platform;
+}
+
+export interface XRHandJointState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    radius?: number;
+}
+
+export interface XRHandState {
+    position: THREE.Vector3;
+    joints: Map<XRHandJoint, XRHandJointState>;
+    pinchStrength: number;
+    gripStrength: number;
+    platform: Platform;
+}
+
+export interface XRHandWithHaptics extends THREE.Group {
+    hapticActuators?: HapticActuator[];
+    hand: {
+        joints: {
+            [key in XRHandJoint]?: WorldObject3D;
+        };
+    };
+    pinchStrength: number;
+    gripStrength: number;
+    userData: {
+        hapticActuator?: HapticActuator;
+        platform: Platform;
+    };
+}
+
+// Input Configuration
+export interface XRInputConfig {
+    controllers: boolean;
+    hands: boolean;
+    haptics: boolean;
+}
+
+// Event Types
+export interface XRControllerEvent {
+    controller: XRSpace;
+    inputSource: XRInputSource;
+    hapticActuator?: HapticActuator;
+}
+
+export interface XRHandEvent {
+    hand: XRHandWithHaptics;
+    inputSource: XRInputSource;
+}
+
+export interface XRInteractionState {
+    pinching: boolean;
+    pinchStrength: number;
+    gripping: boolean;
+    gripStrength: number;
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+}
+
+// Platform-specific Types
+export interface QuestHandTracking extends XRHandState {
+    confidence: number;
+    gestureId?: number;
+}
+
+export interface QuestControllerTracking extends XRControllerState {
+    thumbstick: THREE.Vector2;
+    trigger: number;
+    grip: number;
+}
diff --git a/client/ui/ModularControlPanel.css b/client/ui/ModularControlPanel.css
new file mode 100644
index 00000000..81ec7e2c
--- /dev/null
+++ b/client/ui/ModularControlPanel.css
@@ -0,0 +1,366 @@
+:root {
+    --primary-color: #4CAF50;
+    --background-color: #212121;
+    --text-color: #ffffff;
+    --border-color: rgba(255, 255, 255, 0.1);
+    --control-bg-color: rgba(255, 255, 255, 0.05);
+    --control-hover-bg-color: rgba(255, 255, 255, 0.1);
+    --control-active-bg-color: rgba(255, 255, 255, 0.15);
+    --slider-track-color: #444;
+    --slider-thumb-color: var(--primary-color);
+    --error-color: #f44336;
+    --section-header-bg: rgba(40, 40, 40, 0.95);
+    --subsection-bg: rgba(0, 0, 0, 0.2);
+    --tooltip-bg: rgba(0, 0, 0, 0.9);
+}
+
+/* Control Panel Container */
+#control-panel {
+    position: fixed;
+    top: 20px;
+    right: 20px;
+    width: 400px;
+    max-height: calc(100vh - 40px);
+    background: var(--background-color);
+    color: var(--text-color);
+    border-radius: 12px;
+    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
+    overflow-y: auto;
+    font-family: system-ui, -apple-system, sans-serif;
+    z-index: 1000;
+    transition: transform 0.3s ease, opacity 0.3s ease;
+}
+
+#control-panel.hidden {
+    transform: translateX(420px);
+    opacity: 0;
+}
+
+/* Sections */
+.settings-section {
+    margin-bottom: 1rem;
+    background: rgba(30, 30, 30, 0.95);
+    border: 1px solid var(--border-color);
+    border-radius: 8px;
+    overflow: hidden;
+}
+
+.section-header {
+    padding: 1rem;
+    background: var(--section-header-bg);
+    display: flex;
+    justify-content: space-between;
+    align-items: center;
+    cursor: pointer;
+    user-select: none;
+    transition: background-color 0.2s;
+}
+
+.section-header:hover {
+    background: rgba(50, 50, 50, 0.95);
+}
+
+.section-header h4 {
+    margin: 0;
+    font-size: 1.1rem;
+    font-weight: 500;
+    color: var(--text-color);
+}
+
+/* Subsections */
+.settings-subsection {
+    margin: 1rem;
+    padding: 1rem;
+    background: var(--subsection-bg);
+    border-radius: 8px;
+    border: 1px solid var(--border-color);
+}
+
+.settings-subsection-header {
+    margin: 0 0 1rem 0;
+    font-size: 0.9rem;
+    font-weight: 600;
+    color: var(--primary-color);
+    text-transform: uppercase;
+    letter-spacing: 0.05em;
+}
+
+/* Setting Controls */
+.setting-control {
+    display: flex;
+    align-items: center;
+    margin-bottom: 1rem;
+    position: relative;
+}
+
+.setting-control label {
+    flex: 1;
+    font-size: 0.9rem;
+    color: var(--text-color);
+    margin-right: 1rem;
+}
+
+/* Sliders */
+.setting-control input[type="range"] {
+    -webkit-appearance: none;
+    width: 140px;
+    height: 4px;
+    background: var(--slider-track-color);
+    border-radius: 2px;
+    outline: none;
+}
+
+.setting-control input[type="range"]::-webkit-slider-thumb {
+    -webkit-appearance: none;
+    width: 16px;
+    height: 16px;
+    border-radius: 50%;
+    background: var(--slider-thumb-color);
+    cursor: pointer;
+    border: 2px solid var(--background-color);
+    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+    transition: transform 0.2s;
+}
+
+.setting-control input[type="range"]::-webkit-slider-thumb:hover {
+    transform: scale(1.1);
+}
+
+.setting-control input[type="range"]::-moz-range-thumb {
+    width: 16px;
+    height: 16px;
+    border-radius: 50%;
+    background: var(--slider-thumb-color);
+    cursor: pointer;
+    border: 2px solid var(--background-color);
+    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+    transition: transform 0.2s;
+}
+
+.setting-control input[type="range"]::-moz-range-thumb:hover {
+    transform: scale(1.1);
+}
+
+/* Toggle Switches */
+.toggle-switch {
+    position: relative;
+    display: inline-block;
+    width: 44px;
+    height: 24px;
+}
+
+.toggle-switch input {
+    opacity: 0;
+    width: 0;
+    height: 0;
+}
+
+.toggle-switch .slider {
+    position: absolute;
+    cursor: pointer;
+    top: 0;
+    left: 0;
+    right: 0;
+    bottom: 0;
+    background-color: var(--slider-track-color);
+    transition: .4s;
+    border-radius: 24px;
+}
+
+.toggle-switch .slider:before {
+    position: absolute;
+    content: "";
+    height: 18px;
+    width: 18px;
+    left: 3px;
+    bottom: 3px;
+    background-color: white;
+    transition: .4s;
+    border-radius: 50%;
+}
+
+.toggle-switch input:checked + .slider {
+    background-color: var(--primary-color);
+}
+
+.toggle-switch input:checked + .slider:before {
+    transform: translateX(20px);
+}
+
+/* Color Picker */
+.setting-control input[type="color"] {
+    -webkit-appearance: none;
+    width: 44px;
+    height: 24px;
+    border: none;
+    border-radius: 4px;
+    padding: 0;
+    cursor: pointer;
+}
+
+.setting-control input[type="color"]::-webkit-color-swatch-wrapper {
+    padding: 0;
+}
+
+.setting-control input[type="color"]::-webkit-color-swatch {
+    border: 2px solid var(--border-color);
+    border-radius: 4px;
+}
+
+/* Number and Text Inputs */
+.setting-control input[type="number"],
+.setting-control input[type="text"] {
+    width: 140px;
+    padding: 6px 8px;
+    background: var(--control-bg-color);
+    border: 1px solid var(--border-color);
+    border-radius: 4px;
+    color: var(--text-color);
+    font-size: 0.9rem;
+    transition: border-color 0.2s;
+}
+
+.setting-control input[type="number"]:focus,
+.setting-control input[type="text"]:focus {
+    border-color: var(--primary-color);
+    outline: none;
+}
+
+/* Select Dropdowns */
+.setting-control select {
+    width: 140px;
+    padding: 6px 24px 6px 8px;
+    background: var(--control-bg-color);
+    border: 1px solid var(--border-color);
+    border-radius: 4px;
+    color: var(--text-color);
+    font-size: 0.9rem;
+    appearance: none;
+    cursor: pointer;
+    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23ffffff' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
+    background-repeat: no-repeat;
+    background-position: right 8px center;
+}
+
+.setting-control select:focus {
+    border-color: var(--primary-color);
+    outline: none;
+}
+
+/* Tooltips */
+.setting-control[title] {
+    position: relative;
+}
+
+.setting-control[title]:hover:after {
+    content: attr(title);
+    position: absolute;
+    right: calc(100% + 10px);
+    top: 50%;
+    transform: translateY(-50%);
+    background: var(--tooltip-bg);
+    color: var(--text-color);
+    padding: 6px 10px;
+    border-radius: 4px;
+    font-size: 0.8rem;
+    white-space: nowrap;
+    z-index: 1000;
+    pointer-events: none;
+}
+
+/* Error States */
+.setting-control.error input,
+.setting-control.error select {
+    border-color: var(--error-color);
+}
+
+.error-message {
+    color: var(--error-color);
+    font-size: 0.8rem;
+    margin-top: 4px;
+}
+
+/* Responsive Design */
+@media (max-width: 768px) {
+    #control-panel {
+        width: 100%;
+        max-width: none;
+        top: auto;
+        bottom: 0;
+        right: 0;
+        border-radius: 12px 12px 0 0;
+        max-height: 80vh;
+    }
+
+    .setting-control {
+        flex-direction: column;
+        align-items: flex-start;
+    }
+
+    .setting-control label {
+        margin-bottom: 0.5rem;
+    }
+
+    .setting-control input[type="range"],
+    .setting-control input[type="number"],
+    .setting-control input[type="text"],
+    .setting-control select {
+        width: 100%;
+    }
+}
+
+/* Animations */
+@keyframes slideIn {
+    from {
+        transform: translateX(420px);
+        opacity: 0;
+    }
+    to {
+        transform: translateX(0);
+        opacity: 1;
+    }
+}
+
+.control-panel-enter {
+    animation: slideIn 0.3s ease forwards;
+}
+
+/* Action Buttons */
+.action-button {
+    display: block;
+    width: 100%;
+    padding: 10px 15px;
+    margin-bottom: 10px;
+    background-color: var(--accent-color);
+    color: var(--text-light);
+    border: none;
+    border-radius: 6px;
+    font-size: 14px;
+    font-weight: 500;
+    cursor: pointer;
+    transition: background-color 0.2s ease, transform 0.2s ease;
+    text-align: center;
+}
+
+.action-button:hover {
+    background-color: var(--accent-hover);
+    transform: translateY(-1px);
+}
+
+.action-button:active {
+    transform: translateY(1px);
+}
+
+.action-button:disabled {
+    background-color: var(--accent-disabled);
+    cursor: not-allowed;
+    opacity: 0.7;
+}
+
+.randomize-btn {
+    background-color: var(--accent-color);
+}
+
+.action-section {
+    margin-bottom: 15px;
+}
\ No newline at end of file
diff --git a/client/ui/ModularControlPanel.ts b/client/ui/ModularControlPanel.ts
new file mode 100644
index 00000000..011834e8
--- /dev/null
+++ b/client/ui/ModularControlPanel.ts
@@ -0,0 +1,684 @@
+import { SettingsStore } from '../state/SettingsStore';
+import { formatSettingName } from '../types/settings/utils';
+import { createLogger, createErrorMetadata } from '../core/logger';
+import { platformManager } from '../platform/platformManager';
+import { nostrAuth } from '../services/NostrAuthService';
+import { EventEmitter } from '../utils/eventEmitter';
+import { settingsMap, SettingControl } from './controlPanelConfig';
+import { ValidationErrorDisplay } from '../components/settings/ValidationErrorDisplay';
+import './ModularControlPanel.css';
+import { VisualizationController } from '../rendering/VisualizationController';
+
+const logger = createLogger('ModularControlPanel');
+
+interface SectionConfig {
+    id: string;
+    title: string;
+    isDetached: boolean;
+    position?: { x: number; y: number };
+    size?: { width: number; height: number };
+    isCollapsed: boolean;
+    isAdvanced: boolean;
+}
+
+export interface ModularControlPanelEvents {
+    'settings:ready': null;
+    'settings:updated': { path: string; value: any };
+}
+
+export class ModularControlPanel extends EventEmitter<ModularControlPanelEvents> {
+    private static instance: ModularControlPanel | null = null;
+    private readonly container: HTMLDivElement;
+    private readonly toggleButton: HTMLButtonElement;
+    private readonly settingsStore: SettingsStore;
+    private readonly validationDisplay: ValidationErrorDisplay;
+    private readonly unsubscribers: Array<() => void> = [];
+    private readonly sections: Map<string, SectionConfig> = new Map();
+    private updateTimeout: number | null = null;
+    private isInitialized: boolean = false;
+
+    private constructor(parentElement: HTMLElement) {
+        super();
+        this.settingsStore = SettingsStore.getInstance();
+        
+        // Create toggle button first
+        this.toggleButton = document.createElement('button');
+        this.toggleButton.className = 'panel-toggle-btn';
+        this.toggleButton.innerHTML = '';
+        this.toggleButton.onclick = () => this.toggle();
+        parentElement.appendChild(this.toggleButton);
+
+        // Create main container
+        const existingContainer = document.getElementById('control-panel');
+        if (!existingContainer) {
+            throw new Error('Could not find #control-panel element');
+        }
+        this.container = existingContainer as HTMLDivElement;
+        this.container.innerHTML = ''; // Clear existing content
+
+        // Initialize validation error display
+        this.validationDisplay = new ValidationErrorDisplay(this.container);
+
+        // Set initial visibility based on platform
+        this.updateVisibilityForPlatform();
+
+        // Listen for platform changes
+        platformManager.on('platformchange', () => {
+            this.updateVisibilityForPlatform();
+        });
+        platformManager.on('xrmodechange', (isXRMode: boolean) => {
+            isXRMode ? this.hide() : this.updateVisibilityForPlatform();
+        });
+
+        this.initializeComponents();
+    }
+
+    private async initializeComponents(): Promise<void> {
+        try {
+            // Initialize nostr auth if available
+            if (typeof nostrAuth !== 'undefined') {
+                await this.initializeNostrAuth();
+            }
+
+            // Add custom action buttons
+            await this.createActionsSection();
+
+            // Initialize settings
+            await this.initializeSettings();
+            await this.initializePanel();
+            this.initializeDragAndDrop();
+            
+            this.isInitialized = true;
+            this.emit('settings:ready', null);
+            
+            logger.info('ModularControlPanel fully initialized');
+        } catch (error) {
+            logger.error('Failed to initialize components:', createErrorMetadata(error));
+        }
+    }
+
+    private async initializeSettings(): Promise<void> {
+        try {
+            await this.settingsStore.initialize();
+            logger.info('Settings initialized successfully');
+        } catch (error) {
+            logger.error('Failed to initialize settings:', createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    private async initializePanel(): Promise<void> {
+        try {
+            // Create main categories container
+            const categoriesContainer = document.createElement('div');
+            categoriesContainer.className = 'settings-categories';
+            
+            // Create sections for each main category in settingsMap
+            for (const [category, settings] of Object.entries(settingsMap)) {
+                const sectionConfig: SectionConfig = {
+                    id: category,
+                    title: formatSettingName(category),
+                    isDetached: false,
+                    isCollapsed: false,
+                    isAdvanced: this.isAdvancedCategory(category)
+                };
+                
+                this.sections.set(category, sectionConfig);
+                const section = await this.createSection(sectionConfig, settings);
+                categoriesContainer.appendChild(section);
+            }
+            
+            this.container.appendChild(categoriesContainer);
+            logger.info('Panel UI initialized');
+        } catch (error) {
+            logger.error('Failed to initialize panel:', createErrorMetadata(error));
+            throw error;
+        }
+    }
+
+    private initializeDragAndDrop(): void {
+        this.container.addEventListener('mousedown', (e: MouseEvent) => {
+            const target = e.target as HTMLElement;
+            const section = target.closest('.settings-section') as HTMLElement;
+            
+            if (!section || !target.classList.contains('section-header')) return;
+            
+            const sectionId = section.dataset.sectionId;
+            if (!sectionId) return;
+
+            const sectionConfig = this.sections.get(sectionId);
+            if (!sectionConfig) return;
+
+            if (sectionConfig.isDetached) {
+                this.startDragging(section, e);
+            }
+        });
+    }
+
+    private startDragging(element: HTMLElement, e: MouseEvent): void {
+        const rect = element.getBoundingClientRect();
+        const offsetX = e.clientX - rect.left;
+        const offsetY = e.clientY - rect.top;
+
+        const moveHandler = (e: MouseEvent) => {
+            const x = e.clientX - offsetX;
+            const y = e.clientY - offsetY;
+            
+            element.style.left = `${x}px`;
+            element.style.top = `${y}px`;
+            
+            const sectionId = element.dataset.sectionId;
+            if (sectionId) {
+                const config = this.sections.get(sectionId);
+                if (config) {
+                    config.position = { x, y };
+                }
+            }
+        };
+
+        const upHandler = () => {
+            document.removeEventListener('mousemove', moveHandler);
+            document.removeEventListener('mouseup', upHandler);
+        };
+
+        document.addEventListener('mousemove', moveHandler);
+        document.addEventListener('mouseup', upHandler);
+    }
+
+    private async initializeNostrAuth(): Promise<void> {
+        const authSection = document.createElement('div');
+        authSection.className = 'settings-section auth-section';
+        
+        const header = document.createElement('div');
+        header.className = 'section-header';
+        header.innerHTML = '<h4>Authentication</h4>';
+        authSection.appendChild(header);
+
+        const content = document.createElement('div');
+        content.className = 'section-content';
+
+        const loginBtn = document.createElement('button');
+        loginBtn.className = 'nostr-login-btn';
+        loginBtn.textContent = 'Login with Nostr';
+        
+        const statusDisplay = document.createElement('div');
+        statusDisplay.className = 'auth-status';
+        statusDisplay.innerHTML = '<div class="not-authenticated">Not authenticated</div>';
+        
+        content.appendChild(loginBtn);
+        content.appendChild(statusDisplay);
+        authSection.appendChild(content);
+
+        this.container.insertBefore(authSection, this.container.firstChild);
+
+        // Set up login button click handler
+        loginBtn.onclick = async () => {
+            try {
+                loginBtn.disabled = true;
+                loginBtn.textContent = 'Connecting...';
+                
+                const result = await nostrAuth.login();
+                if (!result.authenticated) {
+                    throw new Error(result.error || 'Authentication failed');
+                }
+            } catch (error) {
+                logger.error('Nostr login failed:', createErrorMetadata(error));
+                const errorMsg = document.createElement('div');
+                errorMsg.className = 'auth-error';
+                
+                let errorText = 'Login failed';
+                if (error instanceof Error) {
+                    if (error.message.includes('Alby extension not found')) {
+                        errorText = 'Please install Alby extension to use Nostr login';
+                    } else if (error.message.includes('Failed to get public key')) {
+                        errorText = 'Please allow access to your Nostr public key';
+                    } else {
+                        errorText = error.message;
+                    }
+                }
+                
+                errorMsg.textContent = errorText;
+                content.appendChild(errorMsg);
+                setTimeout(() => errorMsg.remove(), 5000);
+            } finally {
+                loginBtn.disabled = false;
+            }
+        };
+
+        // Subscribe to auth state changes
+        this.unsubscribers.push(
+            nostrAuth.onAuthStateChanged(({ authenticated, user }) => {
+                if (authenticated && user) {
+                    loginBtn.textContent = 'Logout';
+                    loginBtn.onclick = async () => {
+                        try {
+                            loginBtn.disabled = true;
+                            loginBtn.textContent = 'Logging out...';
+                            await nostrAuth.logout();
+                        } catch (error) {
+                            logger.error('Logout failed:', createErrorMetadata(error));
+                        }
+                    };
+                    statusDisplay.innerHTML = `
+                        <div class="user-info">
+                            <div class="pubkey">${user.pubkey.substring(0, 8)}...</div>
+                            <div class="role">${user.isPowerUser ? 'Power User' : 'Basic User'}</div>
+                        </div>
+                    `;
+                } else {
+                    loginBtn.textContent = 'Login with Nostr';
+                    loginBtn.onclick = () => nostrAuth.login();
+                    statusDisplay.innerHTML = '<div class="not-authenticated">Not authenticated</div>';
+                }
+                loginBtn.disabled = false;
+            })
+        );
+
+        await nostrAuth.initialize();
+    }
+
+    private async createActionsSection(): Promise<void> {
+        const actionsSection = document.createElement('div');
+        actionsSection.className = 'settings-section action-section';
+        
+        const header = document.createElement('div');
+        header.className = 'section-header';
+        header.innerHTML = '<h4>Actions</h4>';
+        actionsSection.appendChild(header);
+
+        const content = document.createElement('div');
+        content.className = 'section-content';
+
+        // Create randomize nodes button
+        const randomizeBtn = document.createElement('button');
+        randomizeBtn.className = 'action-button randomize-btn';
+        randomizeBtn.textContent = 'Randomly Distribute Nodes';
+        randomizeBtn.title = 'Randomly distribute all nodes in 3D space';
+        
+        // Add event listener
+        randomizeBtn.onclick = () => {
+            try {
+                randomizeBtn.disabled = true;
+                randomizeBtn.textContent = 'Distributing...';
+                
+                // Call the visualization controller to randomize nodes
+                const controller = VisualizationController.getInstance();
+                controller.randomizeNodePositions(10); // Use a smaller radius of 10 units to prevent explosion
+                
+                setTimeout(() => {
+                    randomizeBtn.disabled = false;
+                    randomizeBtn.textContent = 'Randomly Distribute Nodes';
+                }, 1500);
+            } catch (error) {
+                console.error('Failed to randomize nodes:', error);
+                randomizeBtn.disabled = false;
+                randomizeBtn.textContent = 'Randomly Distribute Nodes';
+            }
+        };
+        
+        content.appendChild(randomizeBtn);
+        actionsSection.appendChild(content);
+
+        // Add the actions section to the container
+        this.container.appendChild(actionsSection);
+    }
+
+    private isAdvancedCategory(category: string): boolean {
+        const advancedCategories = ['physics', 'rendering', 'debug', 'network'];
+        return advancedCategories.includes(category.toLowerCase());
+    }
+
+    private async createSection(config: SectionConfig, settings: Record<string, SettingControl | Record<string, SettingControl>>): Promise<HTMLElement> {
+        const section = document.createElement('div');
+        section.className = `settings-section ${config.isAdvanced ? 'advanced' : 'basic'}`;
+        section.dataset.sectionId = config.id;
+        
+        if (config.isDetached) {
+            section.classList.add('detached');
+            if (config.position) {
+                section.style.left = `${config.position.x}px`;
+                section.style.top = `${config.position.y}px`;
+            }
+        }
+
+        const header = document.createElement('div');
+        header.className = 'section-header';
+        
+        const title = document.createElement('h4');
+        title.textContent = config.title;
+        header.appendChild(title);
+
+        const controls = document.createElement('div');
+        controls.className = 'section-controls';
+
+        const detachBtn = document.createElement('button');
+        detachBtn.className = 'section-control detach';
+        detachBtn.innerHTML = config.isDetached ? '' : '';
+        detachBtn.title = config.isDetached ? 'Dock section' : 'Detach section';
+        detachBtn.onclick = (e) => {
+            e.stopPropagation();
+            this.toggleDetached(config.id);
+        };
+        controls.appendChild(detachBtn);
+
+        const collapseBtn = document.createElement('button');
+        collapseBtn.className = 'section-control collapse';
+        collapseBtn.innerHTML = config.isCollapsed ? '' : '';
+        collapseBtn.onclick = (e) => {
+            e.stopPropagation();
+            this.toggleCollapsed(config.id);
+        };
+        controls.appendChild(collapseBtn);
+
+        header.appendChild(controls);
+        section.appendChild(header);
+
+        const content = document.createElement('div');
+        content.className = 'section-content';
+        if (config.isCollapsed) {
+            content.style.display = 'none';
+        }
+
+        // Create subsections for each group of settings
+        for (const [subsectionKey, subsectionSettings] of Object.entries(settings)) {
+            const subsection = await this.createSubsection(subsectionKey, subsectionSettings);
+            content.appendChild(subsection);
+        }
+
+        section.appendChild(content);
+        return section;
+    }
+
+    private async createSubsection(title: string, settings: Record<string, SettingControl> | SettingControl): Promise<HTMLElement> {
+        const subsection = document.createElement('div');
+        subsection.className = 'settings-subsection';
+
+        const header = document.createElement('h3');
+        header.textContent = formatSettingName(title);
+        header.className = 'settings-subsection-header';
+        subsection.appendChild(header);
+
+        if (this.isSettingControl(settings)) {
+            // Single setting
+            const control = await this.createSettingControl(title, settings);
+            subsection.appendChild(control);
+        } else {
+            // Group of settings
+            for (const [key, setting] of Object.entries(settings)) {
+                const control = await this.createSettingControl(key, setting);
+                subsection.appendChild(control);
+            }
+        }
+
+        return subsection;
+    }
+
+    private isSettingControl(value: any): value is SettingControl {
+        return value && typeof value === 'object' && 'type' in value;
+    }
+
+    private async createSettingControl(key: string, setting: SettingControl): Promise<HTMLElement> {
+        const container = document.createElement('div');
+        container.className = 'setting-control';
+        container.dataset.settingPath = key;
+
+        if (setting.tooltip) {
+            container.title = setting.tooltip;
+        }
+
+        const label = document.createElement('label');
+        label.textContent = setting.label;
+        container.appendChild(label);
+
+        const control = await this.createInputElement(key, setting);
+        container.appendChild(control);
+
+        return container;
+    }
+
+    private async createInputElement(path: string, setting: SettingControl): Promise<HTMLElement> {
+        const currentValue = this.settingsStore.get(path);
+        let input: HTMLElement;
+
+        switch (setting.type) {
+            case 'slider': {
+                const slider = document.createElement('input');
+                slider.type = 'range';
+                slider.min = setting.min?.toString() ?? '0';
+                slider.max = setting.max?.toString() ?? '1';
+                slider.step = setting.step?.toString() ?? '0.1';
+                slider.value = (currentValue ?? slider.min).toString();
+                slider.onchange = (e) => {
+                    const target = e.target as HTMLInputElement;
+                    this.updateSetting(path, parseFloat(target.value));
+                };
+                input = slider;
+                break;
+            }
+
+            case 'toggle': {
+                const toggleContainer = document.createElement('div');
+                toggleContainer.className = 'toggle-switch';
+                
+                const checkbox = document.createElement('input');
+                checkbox.type = 'checkbox';
+                checkbox.checked = Boolean(currentValue);
+                checkbox.onchange = (e) => {
+                    const target = e.target as HTMLInputElement;
+                    this.updateSetting(path, target.checked);
+                };
+                
+                const slider = document.createElement('span');
+                slider.className = 'slider';
+                
+                toggleContainer.appendChild(checkbox);
+                toggleContainer.appendChild(slider);
+                input = toggleContainer;
+                break;
+            }
+
+            case 'color': {
+                const colorInput = document.createElement('input');
+                colorInput.type = 'color';
+                colorInput.value = (currentValue as string) ?? '#ffffff';
+                colorInput.onchange = (e) => {
+                    const target = e.target as HTMLInputElement;
+                    this.updateSetting(path, target.value);
+                };
+                input = colorInput;
+                break;
+            }
+
+            case 'select': {
+                const select = document.createElement('select');
+                setting.options?.forEach(option => {
+                    const optionElement = document.createElement('option');
+                    optionElement.value = option;
+                    optionElement.textContent = formatSettingName(option);
+                    select.appendChild(optionElement);
+                });
+                select.value = (currentValue as string) ?? setting.options?.[0] ?? '';
+                select.onchange = (e) => {
+                    const target = e.target as HTMLSelectElement;
+                    this.updateSetting(path, target.value);
+                };
+                input = select;
+                break;
+            }
+
+            case 'number': {
+                const numberInput = document.createElement('input');
+                numberInput.type = 'number';
+                numberInput.min = setting.min?.toString() ?? '0';
+                if (setting.max !== undefined) numberInput.max = setting.max.toString();
+                numberInput.step = setting.step?.toString() ?? '1';
+                numberInput.value = (currentValue ?? 0).toString();
+                numberInput.onchange = (e) => {
+                    const target = e.target as HTMLInputElement;
+                    this.updateSetting(path, parseFloat(target.value));
+                };
+                input = numberInput;
+                break;
+            }
+
+            case 'text':
+            default: {
+                const textInput = document.createElement('input');
+                textInput.type = 'text';
+                textInput.value = (currentValue ?? '').toString();
+                textInput.onchange = (e) => {
+                    const target = e.target as HTMLInputElement;
+                    this.updateSetting(path, target.value);
+                };
+                input = textInput;
+                break;
+            }
+        }
+
+        return input;
+    }
+
+    private updateSetting(path: string, value: any): void {
+        try {
+            const currentValue = this.settingsStore.get(path);
+            
+            let processedValue = value;
+            if (Array.isArray(currentValue)) {
+                processedValue = value.map((v: any, i: number) => {
+                    const originalValue = currentValue[i];
+                    if (typeof originalValue === 'number') {
+                        const parsed = parseFloat(v);
+                        return isNaN(parsed) ? originalValue : parsed;
+                    }
+                    return v;
+                });
+            } else if (typeof currentValue === 'number') {
+                const parsed = parseFloat(value);
+                processedValue = isNaN(parsed) ? currentValue : parsed;
+            }
+
+            this.settingsStore.set(path, processedValue);
+            this.emit('settings:updated', { path, value: processedValue });
+        } catch (error) {
+            logger.error(`Failed to update setting ${path}:`, createErrorMetadata(error));
+            
+            // Create an error element
+            const errorElement = document.createElement('div');
+            errorElement.className = 'error-message';
+            errorElement.textContent = error instanceof Error ? error.message : 'Unknown error occurred';
+            
+            const control = this.container.querySelector(`[data-setting-path="${path}"]`);
+            if (control) {
+                // Add error class to the control
+                control.classList.add('error');
+                
+                // Add error message
+                control.appendChild(errorElement);
+                
+                // Remove error after 5 seconds
+                setTimeout(() => {
+                    control.classList.remove('error');
+                    errorElement.remove();
+                }, 5000);
+                
+                // Revert the input value
+                const input = control.querySelector('input, select') as HTMLInputElement;
+                if (input) {
+                    const currentValue = this.settingsStore.get(path);
+                    if (Array.isArray(currentValue)) {
+                        const inputs = control.querySelectorAll('.array-item') as NodeListOf<HTMLInputElement>;
+                        inputs.forEach((input, i) => {
+                            input.value = currentValue[i].toString();
+                        });
+                    } else {
+                        input.value = currentValue?.toString() || '';
+                    }
+                }
+            }
+        }
+    }
+
+    private toggleDetached(sectionId: string): void {
+        const config = this.sections.get(sectionId);
+        if (!config) return;
+
+        config.isDetached = !config.isDetached;
+        const section = this.container.querySelector(`[data-section-id="${sectionId}"]`);
+        if (section) {
+            section.classList.toggle('detached');
+            if (config.isDetached) {
+                const rect = section.getBoundingClientRect();
+                config.position = { x: rect.left, y: rect.top };
+            } else {
+                (section as HTMLElement).removeAttribute('style');
+            }
+        }
+    }
+
+    private toggleCollapsed(sectionId: string): void {
+        const config = this.sections.get(sectionId);
+        if (!config) return;
+
+        config.isCollapsed = !config.isCollapsed;
+        const section = this.container.querySelector(`[data-section-id="${sectionId}"]`);
+        if (section) {
+            const content = section.querySelector('.section-content');
+            if (content) {
+                content.classList.toggle('collapsed');
+                (content as HTMLElement).style.display = config.isCollapsed ? 'none' : '';
+            }
+            const collapseBtn = section.querySelector('.collapse') as HTMLElement;
+            if (collapseBtn) {
+                collapseBtn.innerHTML = config.isCollapsed ? '' : '';
+            }
+        }
+    }
+
+    public show(): void {
+        this.container.classList.remove('hidden');
+        this.toggleButton.classList.add('panel-open');
+    }
+
+    public hide(): void {
+        this.container.classList.add('hidden');
+        this.toggleButton.classList.remove('panel-open');
+    }
+
+    public toggle(): void {
+        this.container.classList.toggle('hidden');
+        this.toggleButton.classList.toggle('panel-open');
+    }
+
+    public isReady(): boolean {
+        return this.isInitialized;
+    }
+
+    private updateVisibilityForPlatform(): void {
+        if (platformManager.isQuest() || platformManager.isXRMode) {
+            this.hide();
+        } else {
+            this.show();
+        }
+    }
+
+    public static getInstance(): ModularControlPanel {
+        if (!ModularControlPanel.instance) {
+            ModularControlPanel.instance = new ModularControlPanel(document.body);
+        }
+        return ModularControlPanel.instance;
+    }
+
+    public dispose(): void {
+        this.unsubscribers.forEach(unsubscribe => unsubscribe());
+        this.validationDisplay.dispose();
+        if (this.updateTimeout !== null) {
+            window.clearTimeout(this.updateTimeout);
+        }
+        this.container.remove();
+        this.toggleButton.remove();
+        ModularControlPanel.instance = null;
+    }
+}
+
+// Export the class as default as well to maintain compatibility
+export default ModularControlPanel;
\ No newline at end of file
diff --git a/client/ui/controlPanelConfig.ts b/client/ui/controlPanelConfig.ts
new file mode 100644
index 00000000..979c5aec
--- /dev/null
+++ b/client/ui/controlPanelConfig.ts
@@ -0,0 +1,140 @@
+// Interface for UI control settings
+export interface SettingControl {
+    label: string;
+    type: 'slider' | 'toggle' | 'color' | 'select' | 'number' | 'text';
+    options?: string[]; // For select controls
+    min?: number;      // For sliders and number inputs
+    max?: number;      // For sliders and number inputs
+    step?: number;     // For sliders and number inputs
+    tooltip?: string;
+}
+
+export const settingsMap: Record<string, Record<string, SettingControl | Record<string, SettingControl>>> = {
+    visualization: {
+        nodes: {
+            baseColor: { label: 'Base Color', type: 'color', tooltip: 'The base color of the nodes.' },
+            metalness: { label: 'Metalness', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The metalness of the nodes.' },
+            opacity: { label: 'Opacity', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The opacity of the nodes.' },
+            roughness: { label: 'Roughness', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The roughness of the nodes.' },
+            sizeRange: { label: 'Size Range', type: 'text', tooltip: 'Min and max size of the nodes (e.g., "200.0, 700.0").' },
+            quality: { label: 'Quality', type: 'select', options: ['low', 'medium', 'high'], tooltip: 'The quality level of the node geometry.' },
+            enableInstancing: { label: 'Enable Instancing', type: 'toggle', tooltip: 'Enable instanced rendering for improved performance.' },
+            enableHologram: { label: 'Enable Hologram', type: 'toggle', tooltip: 'Enable the hologram effect around nodes.' },
+            enableMetadataShape: { label: 'Enable Metadata Shape', type: 'toggle', tooltip: 'Enable a shape based on node metadata.' },
+            enableMetadataVisualization: { label: 'Enable Metadata Visualization', type: 'toggle', tooltip: 'Enable visualization of node metadata.' },
+        },
+        edges: {
+            arrowSize: { label: 'Arrow Size', type: 'number', min: 0, tooltip: 'The size of the arrowheads on edges.' },
+            baseWidth: { label: 'Base Width', type: 'number', min: 0, tooltip: 'The base width of the edges.' },
+            color: { label: 'Color', type: 'color', tooltip: 'The color of the edges.' },
+            enableArrows: { label: 'Enable Arrows', type: 'toggle', tooltip: 'Enable arrowheads on edges.' },
+            opacity: { label: 'Opacity', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The opacity of the edges.' },
+            widthRange: { label: 'Width Range', type: 'text', tooltip: 'Min and max width of the edges (e.g., "2.0, 3.0").' },
+            quality: { label: 'Quality', type: 'select', options: ['low', 'medium', 'high'], tooltip: 'The quality level of the edge geometry.' },
+            enableFlowEffect: { label: 'Flow Effect', type: 'toggle', tooltip: 'Enable flowing animation on edges.' },
+            flowSpeed: { label: 'Flow Speed', type: 'slider', min: 0, max: 2, step: 0.1, tooltip: 'Speed of the flow animation.' },
+            flowIntensity: { label: 'Flow Intensity', type: 'slider', min: 0, max: 1, step: 0.1, tooltip: 'Intensity of the flow effect.' },
+            glowStrength: { label: 'Glow Strength', type: 'slider', min: 0, max: 1, step: 0.1, tooltip: 'Strength of the edge glow effect.' },
+            distanceIntensity: { label: 'Distance Intensity', type: 'slider', min: 0, max: 1, step: 0.1, tooltip: 'How edge appearance changes with distance.' },
+            useGradient: { label: 'Use Gradient', type: 'toggle', tooltip: 'Enable gradient coloring on edges.' },
+            gradientColors: { label: 'Gradient Colors', type: 'text', tooltip: 'Start and end colors for the gradient (e.g., "#ff0000, #00ff00").' },
+        },
+        physics: {
+            attractionStrength: { label: 'Attraction Strength', type: 'slider', min: 0, max: 0.1, step: 0.001, tooltip: 'The strength of the attraction force between connected nodes.' },
+            boundsSize: { label: 'Bounds Size', type: 'number', min: 0, tooltip: 'The size of the bounding box that contains the nodes.' },
+            collisionRadius: { label: 'Collision Radius', type: 'number', min: 0, tooltip: 'The radius within which nodes will collide.' },
+            damping: { label: 'Damping', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The damping factor that slows down node movement.' },
+            enableBounds: { label: 'Enable Bounds', type: 'toggle', tooltip: 'Enable a bounding box to contain the nodes.' },
+            enabled: { label: 'Enabled', type: 'toggle', tooltip: 'Enable/disable the physics simulation.' },
+            iterations: { label: 'Iterations', type: 'number', min: 1, tooltip: 'The number of physics simulation iterations per frame.' },
+            maxVelocity: { label: 'Max Velocity', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The maximum velocity of the nodes.' },
+            repulsionStrength: { label: 'Repulsion Strength', type: 'number', min: 0, tooltip: 'The strength of the repulsion force between nodes.' },
+            springStrength: { label: 'Spring Strength', type: 'slider', min: 0, max: 0.1, step: 0.001, tooltip: 'The strength of the spring force that keeps connected nodes together.' },
+            repulsionDistance: { label: 'Repulsion Distance', type: 'slider', min: 0, max: 100, step: 0.1, tooltip: 'The distance at which nodes start repelling each other.' },
+            massScale: { label: 'Mass Scale', type: 'slider', min: 0, max: 10, step: 0.1, tooltip: 'Scales the mass of nodes, affecting their inertia.' },
+            boundaryDamping: { label: 'Boundary Damping', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'Damping factor applied when nodes hit the boundary.' },
+
+        },
+        rendering: {
+            ambientLightIntensity: { label: 'Ambient Light', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The intensity of the ambient light.' },
+            backgroundColor: { label: 'Background Color', type: 'color', tooltip: 'The background color of the scene.' },
+            directionalLightIntensity: { label: 'Directional Light', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The intensity of the directional light.' },
+            enableAmbientOcclusion: { label: 'Ambient Occlusion', type: 'toggle', tooltip: 'Enable ambient occlusion for more realistic shadows.' },
+            enableAntialiasing: { label: 'Antialiasing', type: 'toggle', tooltip: 'Enable antialiasing for smoother edges.' },
+            enableShadows: { label: 'Shadows', type: 'toggle', tooltip: 'Enable shadows (can be performance-intensive).' },
+            environmentIntensity: { label: 'Environment Light', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The intensity of the environment lighting.' },
+            shadowMapSize: { label: 'Shadow Map Size', type: 'select', options: ['1024', '2048', '4096'], tooltip: 'Resolution of shadow maps.' },
+            shadowBias: { label: 'Shadow Bias', type: 'slider', min: -0.01, max: 0.01, step: 0.0001, tooltip: 'Bias value to prevent shadow acne.' },
+            context: { label: 'Context', type: 'select', options: ['desktop', 'ar'], tooltip: 'Rendering context (desktop or AR).' },
+        },
+        animations: {
+            enableMotionBlur: { label: 'Motion Blur', type: 'toggle', tooltip: 'Enable motion blur for smoother animations.' },
+            enableNodeAnimations: { label: 'Node Animations', type: 'toggle', tooltip: 'Enable animations on the nodes.' },
+            motionBlurStrength: { label: 'Motion Blur Strength', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The strength of the motion blur effect.' },
+            selectionWaveEnabled: { label: "Selection Wave", type: "toggle", tooltip: 'Enable wave effect on node selection.' },
+            pulseEnabled: { label: "Pulse", type: "toggle", tooltip: 'Enable node pulsing.' },
+            pulseSpeed: { label: "Pulse Speed", type: 'slider', min: 0, max: 2, step: 0.1, tooltip: 'Speed of node pulsing.' },
+            pulseStrength: { label: "Pulse Strength", type: 'slider', min: 0, max: 1, step: 0.1, tooltip: 'Strength of node pulsing.' },
+            waveSpeed: { label: "Wave Speed", type: 'slider', min: 0, max: 2, step: 0.1, tooltip: 'Speed of the selection wave.' },
+        },
+        labels: {
+            desktopFontSize: { label: 'Font Size', type: 'number', min: 1, tooltip: 'The font size for labels on desktop.' },
+            enableLabels: { label: 'Enable Labels', type: 'toggle', tooltip: 'Enable/disable node labels.' },
+            textColor: { label: 'Text Color', type: 'color', tooltip: 'The color of the label text.' },
+            textOutlineColor: { label: 'Outline Color', type: 'color', tooltip: 'The color of the label text outline.' },
+            textOutlineWidth: { label: 'Outline Width', type: 'number', min: 0, tooltip: 'The width of the label text outline.' },
+            textResolution: { label: 'Resolution', type: 'number', min: 1, tooltip: 'The resolution of the label text.' },
+            textPadding: { label: 'Padding', type: 'number', min: 0, tooltip: 'Padding around label text.' },
+            billboardMode: { label: 'Billboard Mode', type: 'select', options: ['camera', 'vertical'], tooltip: 'Orientation of labels.' },
+        },
+        bloom: {
+            edgeBloomStrength: { label: 'Edge Bloom', type: 'slider', min: 0, max: 5, step: 0.1, tooltip: 'The strength of the bloom effect on edges.' },
+            enabled: { label: 'Enable Bloom', type: 'toggle', tooltip: 'Enable/disable the bloom effect.' },
+            environmentBloomStrength: { label: 'Environment Bloom', type: 'slider', min: 0, max: 5, step: 0.1, tooltip: 'The strength of the bloom effect on the environment.' },
+            nodeBloomStrength: { label: 'Node Bloom', type: 'slider', min: 0, max: 5, step: 0.1, tooltip: 'The strength of the bloom effect on nodes.' },
+            radius: { label: 'Radius', type: 'slider', min: 0, max: 5, step: 0.1, tooltip: 'The radius of the bloom effect.' },
+            strength: { label: 'Strength', type: 'slider', min: 0, max: 5, step: 0.1, tooltip: 'The overall strength of the bloom effect.' },
+            threshold: { label: 'Threshold', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The brightness threshold for the bloom effect.' },
+        },
+        hologram: {
+            ringCount: { label: 'Ring Count', type: 'number', min: 0, tooltip: 'The number of rings in the hologram effect.' },
+            ringColor: { label: 'Ring Color', type: 'color', tooltip: 'The color of the hologram rings.' },
+            ringOpacity: { label: 'Ring Opacity', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The opacity of the hologram rings.' },
+            sphereSizes: { label: 'Sphere Sizes', type: 'text', tooltip: 'Sizes of the hologram spheres (e.g., "40.0, 80.0").' },
+            ringRotationSpeed: { label: 'Ring Speed', type: 'number', min: 0, tooltip: 'The rotation speed of the hologram rings.' },
+            enableBuckminster: { label: 'Buckminster', type: 'toggle', tooltip: 'Enable the Buckminsterfullerene hologram effect.' },
+            buckminsterSize: { label: 'Buckminster Size', type: 'number', min: 0, tooltip: 'The size of the Buckminsterfullerene hologram.' },
+            buckminsterOpacity: { label: 'Buckminster Opacity', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The opacity of the Buckminsterfullerene hologram.' },
+            enableGeodesic: { label: 'Geodesic', type: 'toggle', tooltip: 'Enable the geodesic sphere hologram effect.' },
+            geodesicSize: { label: 'Geodesic Size', type: 'number', min: 0, tooltip: 'The size of the geodesic sphere hologram.' },
+            geodesicOpacity: { label: 'Geodesic Opacity', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The opacity of the geodesic sphere hologram.' },
+            enableTriangleSphere: { label: 'Triangle Sphere', type: 'toggle', tooltip: 'Enable the triangle sphere hologram effect.' },
+            triangleSphereSize: { label: 'Triangle Size', type: 'number', min: 0, tooltip: 'The size of the triangle sphere hologram.' },
+            triangleSphereOpacity: { label: 'Triangle Opacity', type: 'slider', min: 0, max: 1, step: 0.01, tooltip: 'The opacity of the triangle sphere hologram.' },
+            globalRotationSpeed: { label: 'Global Speed', type: 'number', min: 0, tooltip: 'The global rotation speed of the hologram.' },
+        },
+    },
+    system: {
+        websocket: {
+            reconnectAttempts: { label: 'Reconnect Attempts', type: 'number', min: 0, tooltip: 'Number of reconnection attempts.' },
+            reconnectDelay: { label: 'Reconnect Delay', type: 'number', min: 1000, tooltip: 'Delay between reconnection attempts (ms).' },
+            binaryChunkSize: { label: 'Binary Chunk Size', type: 'number', min: 1, tooltip: 'Size of binary message chunks.' },
+            compressionEnabled: { label: 'Enable Compression', type: 'toggle', tooltip: 'Enable WebSocket message compression.' },
+            compressionThreshold: { label: 'Compression Threshold', type: 'number', min: 0, tooltip: 'Message size threshold for compression.' },
+            updateRate: { label: 'Update Rate', type: 'number', min: 1, tooltip: 'Rate of WebSocket updates (Hz).' },
+        },
+        debug: {
+            enabled: { label: 'Enable Debug', type: 'toggle', tooltip: 'Enable debug mode.' },
+            enableDataDebug: { label: 'Data Debug', type: 'toggle', tooltip: 'Enable data debugging.' },
+            enableWebsocketDebug: { label: 'WebSocket Debug', type: 'toggle', tooltip: 'Enable WebSocket debugging.' },
+            logBinaryHeaders: { label: 'Log Binary Headers', type: 'toggle', tooltip: 'Log binary message headers.' },
+            logFullJson: { label: 'Log Full JSON', type: 'toggle', tooltip: 'Log complete JSON messages.' },
+            // New debug categories
+            enablePhysicsDebug: { label: 'Physics Debug', type: 'toggle', tooltip: 'Enable physics/force calculations debugging.' },
+            enableNodeDebug: { label: 'Node Debug', type: 'toggle', tooltip: 'Enable node position/velocity tracking.' },
+            enableShaderDebug: { label: 'Shader Debug', type: 'toggle', tooltip: 'Enable shader compilation/linking debugging.' },
+            enableMatrixDebug: { label: 'Matrix Debug', type: 'toggle', tooltip: 'Enable matrix transformations debugging.' },
+            enablePerformanceDebug: { label: 'Performance Debug', type: 'toggle', tooltip: 'Enable performance monitoring.' },
+        },
+    },
+};
\ No newline at end of file
diff --git a/client/ui/index.ts b/client/ui/index.ts
new file mode 100644
index 00000000..78d1b3ba
--- /dev/null
+++ b/client/ui/index.ts
@@ -0,0 +1,45 @@
+import { ModularControlPanel } from './ModularControlPanel';
+import { createLogger, createErrorMetadata } from '../core/logger';
+import './ModularControlPanel.css';
+
+const logger = createLogger('UI');
+
+// Initialize UI components
+export async function initializeUI(): Promise<void> {
+    try {
+        logger.debug('Initializing UI components');
+        
+        // Initialize ModularControlPanel
+        const controlPanel = ModularControlPanel.getInstance();
+        
+        // Wait for settings to be ready
+        if (!controlPanel.isReady()) {
+            await new Promise<void>((resolve) => {
+                controlPanel.on('settings:ready', () => resolve());
+            });
+        }
+        
+        // Show panel by default
+        controlPanel.show();
+        
+        logger.debug('ModularControlPanel initialized successfully');
+    } catch (error) {
+        logger.error('Failed to initialize UI:', createErrorMetadata(error));
+        throw error;
+    }
+}
+
+// Initialize when DOM is ready
+if (document.readyState === 'loading') {
+    document.addEventListener('DOMContentLoaded', () => {
+        initializeUI().catch(error => {
+            logger.error('Failed to initialize UI on DOMContentLoaded:', createErrorMetadata(error));
+        });
+    });
+} else {
+    initializeUI().catch(error => {
+        logger.error('Failed to initialize UI:', createErrorMetadata(error));
+    });
+}
+
+export { ModularControlPanel };
diff --git a/client/ui/styles.css b/client/ui/styles.css
new file mode 100644
index 00000000..f21c28d7
--- /dev/null
+++ b/client/ui/styles.css
@@ -0,0 +1,57 @@
+.control-panel {
+    position: fixed;
+    top: 20px;
+    right: 20px;
+    width: 300px;
+    max-height: calc(100vh - 40px);
+    background: rgba(28, 28, 38, 0.95);
+    color: #fff;
+    border-radius: 8px;
+    padding: 15px;
+    overflow-y: auto;
+    font-family: 'Inter', system-ui, -apple-system, sans-serif;
+    z-index: 1000;
+    backdrop-filter: blur(10px);
+    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
+}
+
+.control-section {
+    margin-bottom: 20px;
+}
+
+.control-section h2 {
+    font-size: 1.2em;
+    margin: 0 0 15px 0;
+    padding-bottom: 8px;
+    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
+    color: #4287f5;
+}
+
+.control-subsection {
+    margin: 15px 0;
+    padding: 10px;
+    background: rgba(255, 255, 255, 0.05);
+    border-radius: 6px;
+}
+
+.control-subsection h3 {
+    font-size: 1em;
+    margin: 0 0 10px 0;
+    color: #6087c3;
+}
+
+.settings-content {
+    font-family: 'Fira Code', monospace;
+    font-size: 0.85em;
+    margin: 0;
+    padding: 10px;
+    background: rgba(0, 0, 0, 0.2);
+    border-radius: 4px;
+    white-space: pre-wrap;
+    word-break: break-word;
+    color: #a0a0a0;
+}
+
+.settings-content:hover {
+    background: rgba(0, 0, 0, 0.3);
+} 
\ No newline at end of file
diff --git a/client/utils/eventEmitter.ts b/client/utils/eventEmitter.ts
new file mode 100644
index 00000000..85a477f9
--- /dev/null
+++ b/client/utils/eventEmitter.ts
@@ -0,0 +1,29 @@
+type EventCallback<T = any> = (data: T) => void;
+type EventMap = Record<string, any>;
+
+export class EventEmitter<Events extends EventMap = EventMap> {
+    private events: {
+        [E in keyof Events]?: EventCallback<Events[E]>[];
+    } = {};
+
+    on<E extends keyof Events>(event: E, callback: EventCallback<Events[E]>): void {
+        if (!this.events[event]) {
+            this.events[event] = [];
+        }
+        this.events[event]?.push(callback);
+    }
+
+    emit<E extends keyof Events>(event: E, data: Events[E]): void {
+        const callbacks = this.events[event];
+        if (callbacks) {
+            callbacks.forEach(callback => callback(data));
+        }
+    }
+
+    off<E extends keyof Events>(event: E, callback: EventCallback<Events[E]>): void {
+        const callbacks = this.events[event];
+        if (callbacks) {
+            this.events[event] = callbacks.filter(cb => cb !== callback);
+        }
+    }
+} 
\ No newline at end of file
diff --git a/client/utils/vectorUtils.ts b/client/utils/vectorUtils.ts
new file mode 100644
index 00000000..f3d53745
--- /dev/null
+++ b/client/utils/vectorUtils.ts
@@ -0,0 +1,57 @@
+import { Vector3 } from 'three';
+
+/**
+ * Create a Vector3 from x,y,z components
+ */
+export function createVector3(x: number, y: number, z: number): Vector3 {
+    return new Vector3(x, y, z);
+}
+
+/**
+ * Create a zero Vector3
+ */
+export function zeroVector3(): Vector3 {
+    return new Vector3(0, 0, 0);
+}
+
+/**
+ * Convert object with x,y,z properties to Vector3
+ */
+export function objectToVector3(obj: { x: number; y: number; z: number }): Vector3 {
+    return new Vector3(obj.x, obj.y, obj.z);
+}
+
+/**
+ * Convert Vector3 to object with x,y,z properties (for logging/serialization)
+ */
+export function vector3ToObject(vec: Vector3): { x: number; y: number; z: number } {
+    return { x: vec.x, y: vec.y, z: vec.z };
+}
+
+/**
+ * Clamp a Vector3's components between min and max values
+ */
+export function clampVector3(vec: Vector3, min: number, max: number): Vector3 {
+    return new Vector3(
+        Math.max(min, Math.min(max, vec.x)),
+        Math.max(min, Math.min(max, vec.y)),
+        Math.max(min, Math.min(max, vec.z))
+    );
+}
+
+/**
+ * Check if a Vector3 has valid components (finite, non-NaN)
+ */
+export function isValidVector3(vec: Vector3): boolean {
+    return !isNaN(vec.x) && !isNaN(vec.y) && !isNaN(vec.z) &&
+           isFinite(vec.x) && isFinite(vec.y) && isFinite(vec.z);
+}
+
+/**
+ * Compare two Vector3s for equality within a small epsilon
+ */
+export function vector3Equals(a: Vector3, b: Vector3, epsilon: number = 0.000001): boolean {
+    return Math.abs(a.x - b.x) < epsilon &&
+           Math.abs(a.y - b.y) < epsilon &&
+           Math.abs(a.z - b.z) < epsilon;
+}
diff --git a/client/visualization/HologramManager.ts b/client/visualization/HologramManager.ts
new file mode 100644
index 00000000..7c2553ef
--- /dev/null
+++ b/client/visualization/HologramManager.ts
@@ -0,0 +1,193 @@
+import {
+    Scene,
+    Group,
+    Mesh,
+    Vector3,
+    WebGLRenderer,
+    InstancedMesh,
+    Matrix4
+} from 'three';
+import { Settings } from '../types/settings';
+import { GeometryFactory } from '../rendering/factories/GeometryFactory';
+import { MaterialFactory } from '../rendering/factories/MaterialFactory';
+import { HologramShaderMaterial } from '../rendering/materials/HologramShaderMaterial';
+import { SettingsStore } from '../state/SettingsStore';
+
+export class HologramManager {
+    private readonly group = new Group();
+    private isXRMode = false;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly ringInstances: InstancedMesh[] = [];
+    private readonly sphereInstances: InstancedMesh[] = [];
+    private readonly tempMatrix = new Matrix4();
+    private readonly instanceCount = 3;
+    private readonly materialFactory: MaterialFactory;
+    private readonly settingsStore: SettingsStore;
+
+    constructor(
+        private readonly scene: Scene,
+        _renderer: WebGLRenderer,  // Used by subclasses
+        private settings: Settings
+    ) {
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.materialFactory = MaterialFactory.getInstance();
+        this.settingsStore = SettingsStore.getInstance();
+        
+        // Enable bloom layer
+        this.group.layers.set(0);  // First set default layer
+        this.group.layers.enable(1);  // Then enable bloom layer
+        this.createHolograms();
+        this.scene.add(this.group);
+
+        // Subscribe to settings changes
+        this.settingsStore.subscribe('visualization.hologram', (_path: string, settings: any) => {
+            if (settings && typeof settings === 'object') {
+                this.settings = {
+                    ...this.settings,
+                    visualization: {
+                        ...this.settings.visualization,
+                        hologram: settings
+                    }
+                };
+                this.updateSettings(this.settings);
+            }
+        });
+    }
+
+    private createHolograms() {
+        while (this.group.children.length > 0) {
+            const child = this.group.children[0];
+            this.group.remove(child);
+            if (child instanceof Mesh || child instanceof InstancedMesh) {
+                child.geometry.dispose();
+                child.material.dispose();
+            }
+        }
+
+        const quality = this.isXRMode ? 'high' : this.settings.xr.quality;
+        const baseMaterial = this.materialFactory.getHologramMaterial(this.settings);
+
+        // Create instanced rings
+        const sphereSizes = this.settings.visualization.hologram.sphereSizes;
+        
+        // Create one ring instance for each size
+        sphereSizes.forEach(size => {
+            // Get unit-sized geometry and scale it
+            const ring = new InstancedMesh(
+                this.geometryFactory.getHologramGeometry('ring', quality),
+                baseMaterial.clone(),
+                this.instanceCount
+            );
+            
+            // Set up ring instances with different rotations and scales
+            for (let j = 0; j < this.instanceCount; j++) {
+                this.tempMatrix.makeRotationX(Math.PI / 3 * j);
+                this.tempMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 6 * j));
+                // Apply size in meters from settings
+                this.tempMatrix.multiply(new Matrix4().makeScale(size, size, size));
+                ring.setMatrixAt(j, this.tempMatrix);
+            }
+            
+            ring.instanceMatrix.needsUpdate = true;
+            // Make sure each ring has bloom layer enabled properly
+            ring.layers.set(0);  // Set default layer first
+            ring.layers.enable(1);  // Then enable bloom layer
+            this.ringInstances.push(ring);
+            this.group.add(ring);
+        });
+
+        if (this.settings.visualization.hologram.enableTriangleSphere) {
+            const baseSize = this.settings.visualization.hologram.triangleSphereSize;
+            const sphereMesh = new InstancedMesh(
+                this.geometryFactory.getHologramGeometry('triangleSphere', quality),
+                baseMaterial.clone(),
+                this.instanceCount
+            );
+            
+            // Set up sphere instances with different scales and rotations
+            for (let i = 0; i < this.instanceCount; i++) {
+                // Scale each instance relative to the base size (80%, 100%, 120%)
+                const scale = baseSize * (0.8 + (i * 0.2));
+                this.tempMatrix.makeScale(scale, scale, scale);
+                this.tempMatrix.multiply(new Matrix4().makeRotationX(Math.PI / 4 * i));
+                this.tempMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 3 * i));
+                sphereMesh.setMatrixAt(i, this.tempMatrix);
+            }
+            
+            sphereMesh.instanceMatrix.needsUpdate = true;
+            
+            // Set material properties
+            const material = (sphereMesh.material as HologramShaderMaterial);
+            material.uniforms.opacity.value = this.settings.visualization.hologram.triangleSphereOpacity;
+            material.setEdgeOnly(true);
+            
+            // Make sure sphere has bloom layer enabled properly
+            sphereMesh.layers.set(0);  // Set default layer first
+            sphereMesh.layers.enable(1);  // Then enable bloom layer
+            this.sphereInstances.push(sphereMesh);
+            this.group.add(sphereMesh);
+        }
+    }
+
+    setXRMode(enabled: boolean) {
+        this.isXRMode = enabled;
+        this.group.traverse(child => {
+            if (child instanceof Mesh && child.material instanceof HologramShaderMaterial) {
+                child.material = new HologramShaderMaterial(this.settings, enabled ? 'ar' : 'desktop');
+            }
+        });
+        this.createHolograms();
+    }
+
+    handleInteraction(position: Vector3) {
+        const interactionRadius = this.settings.xr.interactionRadius;
+        this.group.traverse(child => {
+            if (child instanceof Mesh && child.material instanceof HologramShaderMaterial) {
+                const distance = position.distanceTo(child.position);
+                if (distance < interactionRadius && child.material.uniforms) {
+                    child.material.handleInteraction(position);
+                }
+            }
+        });
+    }
+
+    update(deltaTime: number) {
+        this.group.traverse(child => {
+            if (child instanceof InstancedMesh) {
+                const rotationSpeed = this.settings.visualization.hologram.globalRotationSpeed;
+                
+                // Update each instance's rotation
+                for (let i = 0; i < child.count; i++) {
+                    child.getMatrixAt(i, this.tempMatrix);
+                    
+                    // Apply rotation based on instance index
+                    const instanceSpeed = rotationSpeed * (i + 1);
+                    this.tempMatrix.multiply(new Matrix4().makeRotationY(instanceSpeed * deltaTime));
+                    
+                    child.setMatrixAt(i, this.tempMatrix);
+                }
+                
+                child.instanceMatrix.needsUpdate = true;
+                
+                // Update shader time
+                const material = child.material as HologramShaderMaterial;
+                material.update(deltaTime);
+            }
+        });
+    }
+
+    updateSettings(newSettings: Settings) {
+        this.settings = newSettings;
+        this.materialFactory.updateMaterial('hologram', this.settings);
+        this.createHolograms();
+    }
+
+    getGroup() {
+        return this.group;
+    }
+
+    dispose() {
+        // Geometries and materials are managed by the factories
+        this.scene.remove(this.group);
+    }
+}
diff --git a/client/visualization/MetadataVisualizer.ts b/client/visualization/MetadataVisualizer.ts
new file mode 100644
index 00000000..992cd357
--- /dev/null
+++ b/client/visualization/MetadataVisualizer.ts
@@ -0,0 +1,520 @@
+import * as THREE from 'three';
+import {
+    Mesh,
+    Group,
+    MeshStandardMaterial,
+    MeshBasicMaterial,
+    Vector3,
+    DoubleSide,
+    BufferGeometry,
+    Object3D
+} from 'three';
+import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
+import { FontLoader, Font } from 'three/examples/jsm/loaders/FontLoader.js';
+import { NodeMetadata } from '../types/metadata';
+import { Settings } from '../types/settings';
+import { platformManager } from '../platform/platformManager';
+import { debugState } from '../core/debugState';
+import { logger, createDataMetadata, createErrorMetadata } from '../core/logger';
+
+type GeometryWithBoundingBox = THREE.BufferGeometry & {
+    boundingBox: THREE.Box3 | null;
+    computeBoundingBox: () => void;
+};
+
+interface MetadataLabelGroup extends Group {
+    name: string;
+    userData: {
+        isMetadata: boolean;
+    };
+}
+
+export type MetadataLabelCallback = (group: MetadataLabelGroup) => void;
+
+interface ExtendedTextGeometry extends TextGeometry {
+    computeBoundingBox: () => void;
+    boundingBox: THREE.Box3 | null;
+}
+
+export class MetadataVisualizer {
+    private scene: THREE.Scene;
+    private camera: THREE.PerspectiveCamera;
+    private fontLoader: FontLoader;
+    private font: Font | null;
+    private fontPath: string;
+    private labelGroup: THREE.Group;
+    private settings: Settings;
+    private fontLoadAttempts: number = 0;
+    private metadataLabelMap: Map<string, MetadataLabelGroup> = new Map();
+
+    // Default values for missing data
+    private readonly DEFAULT_FILE_SIZE = 1000; // 1KB
+
+    constructor(camera: THREE.PerspectiveCamera, scene: THREE.Scene, settings: Settings) {
+        logger.info('MetadataVisualizer constructor called', createDataMetadata({
+            timestamp: Date.now(),
+            cameraPosition: camera?.position ? {x: camera.position.x, y: camera.position.y, z: camera.position.z} : 'undefined'
+        }));
+        
+        this.scene = scene;
+        this.camera = camera;
+        this.fontLoader = new FontLoader();
+        this.font = null;
+        this.fontPath = '/fonts/helvetiker_regular.typeface.json';
+        this.labelGroup = new THREE.Group();
+        
+        // Enable both layers by default for desktop mode
+        this.labelGroup.layers.enable(0);
+        this.labelGroup.layers.enable(1);
+        
+        this.settings = settings;
+        this.scene.add(this.labelGroup);
+        logger.info('MetadataVisualizer labelGroup added to scene');
+        this.loadFont();
+        
+        // Set initial layer mode
+        this.setXRMode(platformManager.isXRMode);
+        
+        // Listen for XR mode changes
+        platformManager.on('xrmodechange', (enabled: boolean) => {
+            this.setXRMode(enabled);
+        });
+    }
+
+    private readonly geometries = {
+        SPHERE: new THREE.SphereGeometry(1, 32, 32),
+        ICOSAHEDRON: new THREE.IcosahedronGeometry(1),
+        OCTAHEDRON: new THREE.OctahedronGeometry(1)
+    };
+
+    private async loadFont(): Promise<void> {
+        try {
+            await this.attemptFontLoad();
+            logger.info('Font loaded successfully on first attempt');
+        } catch (error) {
+            logger.error('Initial font load failed:', createErrorMetadata(error));
+            await this.retryFontLoad();
+        }
+    }
+
+    private async attemptFontLoad(): Promise<void> {
+        logger.info(`Attempting to load font from ${this.fontPath}`);
+        this.font = await new Promise((resolve, reject) => {
+            this.fontLoader.load(
+                // Font path
+                this.fontPath,
+                resolve,
+                undefined,
+                reject
+            );
+        });
+    }
+
+    private async retryFontLoad(maxAttempts: number = 3): Promise<void> {
+        while (this.fontLoadAttempts < maxAttempts && !this.font) {
+            this.fontLoadAttempts++;
+            await new Promise(resolve => setTimeout(resolve, 1000));
+            try {
+                await this.attemptFontLoad();
+                if (debugState.isShaderDebugEnabled()) {
+                    logger.info('Font loaded successfully after retry');
+                }
+                break;
+            } catch (error) {
+                logger.error(`Font load attempt ${this.fontLoadAttempts} failed:`, createErrorMetadata(error));
+            }
+        }
+    }
+
+    public createLabel(text: string, position: THREE.Vector3): void {
+        if (!this.font) {
+            console.warn('Font not loaded yet');
+            return;
+        }
+
+        const textGeometry = new TextGeometry(text, {
+            font: this.font,
+            size: this.settings.visualization.labels.desktopFontSize / 10 || 0.5,
+            depth: 0.01 // Fixed thin depth for better readability
+        });
+
+        const material = new THREE.MeshStandardMaterial({
+            color: this.settings.visualization.labels.textColor || '#ffffff',
+            metalness: 0.1,
+            roughness: 0.6,
+            emissive: this.settings.visualization.labels.textColor || '#ffffff',
+            transparent: true,
+            opacity: 1.0,
+            side: THREE.DoubleSide,
+            depthWrite: false, // Disable depth writing to prevent occlusion
+            depthTest: false   // Disable depth testing to ensure visibility
+        });
+
+        // Create mesh with the text geometry and center it
+        const geometry = textGeometry as unknown as GeometryWithBoundingBox;
+        geometry.computeBoundingBox();
+        const mesh = new THREE.Mesh(geometry, material);
+        mesh.position.copy(position);
+
+        if (geometry.boundingBox) {
+            const width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
+            mesh.position.x -= width / 2;
+        }
+        
+        this.labelGroup.add(mesh);
+    }
+
+    public async createTextMesh(text: string): Promise<Mesh | Group | null> {
+        if (!this.font) {
+            logger.warn(`Cannot create text mesh: font not loaded yet (text: ${text})`);
+            return null;
+        }
+        
+        logger.debug(`Creating text mesh: "${text}"`);
+
+        const textGeometry = new TextGeometry(text, {
+            font: this.font,
+            size: this.settings.visualization.labels.desktopFontSize / 10 || 0.5,
+            depth: 0.1, // Using depth instead of height
+            curveSegments: this.settings.visualization.labels.textResolution || 4,
+            bevelEnabled: false
+        }) as ExtendedTextGeometry;
+
+        // Compute bounding box right after creation
+        textGeometry.computeBoundingBox();
+
+        const material = new MeshStandardMaterial({
+            color: this.settings.visualization.labels.textColor || '#ffffff',
+            metalness: 0.1,
+            roughness: 0.6,
+            emissive: this.settings.visualization.labels.textColor || '#ffffff',
+            transparent: true,
+            opacity: 1.0,
+            side: DoubleSide,
+            depthWrite: false,  // Changed to false to prevent occlusion by other objects
+            depthTest: false    // Changed to false for consistent behavior
+        });
+
+        // Add outline for better visibility
+        if (this.settings.visualization.labels.textOutlineWidth > 0) {
+            const outlineMaterial = new MeshBasicMaterial({
+                color: this.settings.visualization.labels.textOutlineColor || '#000000',
+                side: DoubleSide,
+                depthWrite: false, // Disable depth writing for outline to match main material
+                depthTest: false   // Disable depth testing to ensure outline is always visible
+            });
+            
+            const outlineWidth = this.settings.visualization.labels.textOutlineWidth;
+            // Create a new geometry for the outline to avoid sharing
+            const outlineGeometry = new TextGeometry(text, {
+                font: this.font,
+                size: this.settings.visualization.labels.desktopFontSize / 10 || 0.5,
+                depth: 0.1,
+                curveSegments: this.settings.visualization.labels.textResolution || 4,
+                bevelEnabled: false
+            }) as ExtendedTextGeometry;
+            outlineGeometry.computeBoundingBox();
+            
+            const outlineMesh = new Mesh(outlineGeometry as unknown as BufferGeometry, outlineMaterial);
+            outlineMesh.scale.multiplyScalar(1 + outlineWidth);
+            
+            const group = new Group();
+            group.add(outlineMesh);
+            outlineMesh.renderOrder = 1000; // Ensure outline renders on top
+            group.add(new Mesh(textGeometry as unknown as BufferGeometry, material));
+            group.renderOrder = 1000; // Ensure entire group renders on top
+            
+            // Center the group
+            const bbox = textGeometry.boundingBox;
+            if (bbox) {
+                const width = bbox.max.x - bbox.min.x;
+                group.position.x -= width / 2;
+            }
+            
+            return group;
+        }
+
+        // Create mesh with the text geometry and center it
+        const bbox = textGeometry.boundingBox;
+        const mesh = new Mesh(textGeometry as unknown as BufferGeometry, material);
+        mesh.renderOrder = 1000; // Ensure text mesh renders on top
+
+        if (bbox) {
+            const width = bbox.max.x - bbox.min.x;
+            mesh.position.x -= width / 2;
+        }
+
+        return mesh;
+    }
+
+    public createNodeVisual = (metadata: NodeMetadata): THREE.Mesh => {
+        const geometry = this.getGeometryFromAge(metadata.commitAge);
+        const material = this.createMaterialFromHyperlinks(metadata.hyperlinkCount);
+        const mesh = new THREE.Mesh(geometry, material);
+
+        mesh.position.set(
+            metadata.position.x,
+            metadata.position.y,
+            metadata.position.z
+        );
+
+        return mesh;
+    }
+
+    private getGeometryFromAge = (age: number): THREE.BufferGeometry => {
+        if (age < 7) return this.geometries.SPHERE;
+        if (age < 30) return this.geometries.ICOSAHEDRON;
+        return this.geometries.OCTAHEDRON;
+    }
+
+    private createMaterialFromHyperlinks(count: number): THREE.Material {
+        const hue = Math.min(count / 10, 1) * 0.3; // 0 to 0.3 range
+        const color = new THREE.Color().setHSL(hue, 0.7, 0.5);
+
+        return new THREE.MeshPhongMaterial({
+            color: color,
+            shininess: 30,
+            transparent: true,
+            opacity: 0.9
+        });
+    }
+
+    /**
+     * Format file size in a human-readable way
+     * @param bytes File size in bytes
+     * @returns Formatted string (e.g., "1.5 KB")
+     */
+    private formatFileSize(bytes: number): string {
+        if (!bytes || isNaN(bytes)) return 'N/A';
+        if (bytes < 1024) return `${bytes} B`;
+        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
+        if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
+        return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
+    }
+
+    /**
+     * Create a metadata label for a node
+     * CRITICAL: This function now explicitly accepts a nodeLabel parameter
+     * to prioritize the label from the Node object over metadata.name
+     * @param metadata Metadata object containing node details
+     * @param nodeLabel Optional label from Node.label property (preferred over metadata.name)
+     */
+    public async createMetadataLabel(metadata: NodeMetadata, nodeLabel?: string): Promise<MetadataLabelGroup> {
+        const group = new Group() as MetadataLabelGroup;
+        
+        // Check if metadata position is zero or undefined
+        if (!metadata.position || (metadata.position.x === 0 && metadata.position.y === 0 && metadata.position.z === 0)) {
+            logger.warn(`[POSITION WARNING] Metadata for node ${metadata.id} has zero/undefined position`, 
+                createDataMetadata({
+                    position: metadata.position || 'undefined',
+                    nodeLabel: nodeLabel || 'undefined',
+                    metadataName: metadata.name || 'undefined'
+                })
+            );
+        }
+        
+        group.name = 'metadata-label';
+        group.renderOrder = 1000; // Set high render order to ensure visibility
+        group.userData = { isMetadata: true };
+        
+        // Log the label source for debugging
+        logger.info(`Creating metadata label for node ${metadata.id}`, createDataMetadata({
+            labelSource: nodeLabel ? 'explicit nodeLabel' : 'metadata.name',
+            displayName: nodeLabel || metadata.name,
+            position: metadata.position ? 
+                `x:${metadata.position.x.toFixed(2)}, y:${metadata.position.y.toFixed(2)}, z:${metadata.position.z.toFixed(2)}` : 
+                'undefined',
+            fileSize: metadata.fileSize || 'undefined',
+            hyperlinkCount: metadata.hyperlinkCount || 'undefined'
+        }));
+        
+        // Create text for name
+        // First priority should be the explicitly passed nodeLabel (from Node object)
+        // Second priority is metadata.name if available
+        // Fallback to metadata.id if nothing else is available
+        const displayName = nodeLabel || metadata.name || metadata.id || "Unknown";
+        const nameMesh = await this.createTextMesh(displayName);
+        if (nameMesh) {
+            nameMesh.position.y = 1.2;
+            // Log position and scale to verify
+            logger.debug(`nameMesh created at position y=${nameMesh.position.y} with scale=${nameMesh.scale.x}`);
+            nameMesh.scale.setScalar(0.8);
+            group.add(nameMesh);
+        }
+        
+        // Create text for file size
+        // Access fileSize directly from the metadata object
+        const fileSize = metadata.fileSize !== undefined ? metadata.fileSize : this.DEFAULT_FILE_SIZE;
+        const fileSizeText = `Size: ${this.formatFileSize(fileSize)}`;
+        const fileSizeMesh = await this.createTextMesh(fileSizeText);
+        if (fileSizeMesh) {
+            fileSizeMesh.position.y = 0.8;
+            fileSizeMesh.scale.setScalar(0.7);
+            logger.debug(`fileSizeMesh created at position y=${fileSizeMesh.position.y} with scale=${fileSizeMesh.scale.x}`);
+            group.add(fileSizeMesh);
+
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Created file size label: ${fileSizeText} for node "${displayName}" (${metadata.id})`);
+            }
+            
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`Creating file size label: ${fileSizeText} for node ${metadata.id}`);
+            }
+        }
+
+        // Create text for hyperlink count
+        // Ensure we have a valid value, defaulting to 0 if undefined or invalid
+        const hyperlinkCount = Number.isFinite(metadata.hyperlinkCount) ? metadata.hyperlinkCount : 0;
+        const linksText = `Links: ${hyperlinkCount}`;
+        if (hyperlinkCount > 0 && debugState.isNodeDebugEnabled()) {
+            logger.debug(`Creating hyperlink count label: ${linksText} for node ${metadata.id}`);
+        }
+        const linksMesh = await this.createTextMesh(linksText);
+        if (linksMesh) {
+            linksMesh.position.y = 0.4;
+            linksMesh.scale.setScalar(0.7);
+            logger.debug(`linksMesh created at position y=${linksMesh.position.y} with scale=${linksMesh.scale.x}`);
+            group.add(linksMesh);
+        }
+
+        // Set up billboarding
+        const tempVec = new Vector3();
+        const billboardMode = this.settings.visualization.labels.billboardMode;
+
+        const updateBillboard = () => {
+            if (billboardMode === 'camera') {
+                // Full billboard - always face camera
+                group.quaternion.copy(this.camera.quaternion);
+            } else {
+                // Vertical billboard - only rotate around Y axis
+                tempVec.copy(this.camera.position).sub(group.position);
+                tempVec.y = 0;
+                group.lookAt(tempVec.add(group.position));
+            }
+        };
+
+        // Add to render loop
+        const onBeforeRender = () => {
+            updateBillboard();
+        };
+        group.onBeforeRender = onBeforeRender;
+
+        // Set initial layer
+        this.setGroupLayer(group, platformManager.isXRMode);
+
+        // Add to label map for tracking
+        this.metadataLabelMap.set(metadata.id, group);
+        
+        // Verify layer settings on the group
+        logger.debug(`Label group for ${metadata.id} - Layer visibility:`, createDataMetadata({
+            layerInfo: `Mask value: ${group.layers.mask.toString(2)}`,
+            isOnLayer0: Boolean(group.layers.mask & (1 << 0)),
+            isOnLayer1: Boolean(group.layers.mask & (1 << 1))
+        }));
+        
+        return group;
+    }
+
+    private setGroupLayer(group: Object3D, enabled: boolean): void {
+        if (enabled) {
+            // In XR mode, only show on layer 1
+            group.traverse(child => {
+                child.layers.disable(0);
+                child.layers.enable(1);
+            });
+            group.layers.disable(0);
+            group.layers.enable(1);
+        } else {
+            // In desktop mode, show on both layers
+            group.traverse(child => {
+                child.layers.enable(0);
+                child.layers.enable(1);
+            });
+            group.layers.enable(0);
+            group.layers.enable(1);
+        }
+    }
+
+    /**
+     * Update the position of a metadata label
+     * @param id The node ID
+     * @param position The new position
+     */
+    public updateMetadataPosition(id: string, position: Vector3): void {
+        const group = this.metadataLabelMap.get(id);
+        if (!group) {
+            // Only log in debug mode to avoid console spam
+            if (debugState.isNodeDebugEnabled()) {
+                logger.debug(`No metadata label found for node ${id} to update position`);
+            }
+            return;
+        }
+        
+        // Update the position
+        group.position.copy(position);
+        
+        // Occasionally log position updates for important nodes (using modulo to reduce spam)
+        if (Math.random() < 0.01) { // Only log ~1% of updates
+            logger.debug(`Updated position for node ${id} to`, createDataMetadata({
+                x: position.x.toFixed(2),
+                y: position.y.toFixed(2),
+                z: position.z.toFixed(2)
+            }));
+        }
+    }
+    
+    /**
+     * Clear all metadata labels
+     */
+    public clearAllLabels(): void {
+        logger.info(`Clearing all metadata labels (count: ${this.metadataLabelMap.size})`);
+        
+        // Remove all labels from the scene
+        this.metadataLabelMap.forEach((group) => {
+            this.labelGroup.remove(group);
+        });
+        
+        // Clear the map
+        this.metadataLabelMap.clear();
+    }
+
+    public setXRMode(enabled: boolean): void {
+        logger.info(`Setting XR mode: ${enabled ? 'enabled' : 'disabled'}`);
+        if (enabled) {
+            // In XR mode, only show on layer 1
+            this.labelGroup.traverse(child => {
+                child.layers.disable(0);
+                child.layers.enable(1);
+            });
+            this.labelGroup.layers.disable(0);
+            this.labelGroup.layers.enable(1);
+        } else {
+            // In desktop mode, show on both layers
+            this.labelGroup.traverse(child => {
+                child.layers.enable(0);
+                child.layers.enable(1);
+            });
+            this.labelGroup.layers.enable(0);
+            this.labelGroup.layers.enable(1);
+        }
+    }
+
+    public dispose(): void {
+        // Clean up geometries
+        logger.info('Disposing MetadataVisualizer resources');
+        Object.values(this.geometries).forEach(geometry => geometry.dispose());
+        
+        // Clean up label group
+        this.labelGroup.traverse(child => {
+            if (child instanceof THREE.Mesh) {
+                child.geometry.dispose();
+                if (child.material instanceof THREE.Material) {
+                    child.material.dispose();
+                }
+            }
+        });
+        
+        // Clear label map
+        this.metadataLabelMap.clear();
+    }
+}
diff --git a/client/webgl-diagnostics.js b/client/webgl-diagnostics.js
new file mode 100644
index 00000000..7819ac90
--- /dev/null
+++ b/client/webgl-diagnostics.js
@@ -0,0 +1,373 @@
+/**
+ * WebGL Diagnostics Tool
+ * 
+ * This script can be run in the browser console to diagnose WebGL issues.
+ * It provides detailed information about WebGL capabilities and limitations.
+ * 
+ * Usage:
+ * 1. Open the browser console (F12 or Ctrl+Shift+I)
+ * 2. Copy and paste this entire script into the console
+ * 3. Press Enter to run the diagnostics
+ * 4. Check the console for detailed logs about WebGL support
+ */
+
+(function() {
+  // Utility functions
+  const utils = {
+    log(message, data) {
+      const timestamp = new Date().toISOString();
+      if (data) {
+        console.log(`[${timestamp}] ${message}`, data);
+      } else {
+        console.log(`[${timestamp}] ${message}`);
+      }
+    },
+    
+    error(message, err) {
+      const timestamp = new Date().toISOString();
+      if (err) {
+        console.error(`[${timestamp}] ERROR: ${message}`, err);
+      } else {
+        console.error(`[${timestamp}] ERROR: ${message}`);
+      }
+    },
+    
+    warn(message, data) {
+      const timestamp = new Date().toISOString();
+      if (data) {
+        console.warn(`[${timestamp}] WARNING: ${message}`, data);
+      } else {
+        console.warn(`[${timestamp}] WARNING: ${message}`);
+      }
+    },
+    
+    success(message, data) {
+      const timestamp = new Date().toISOString();
+      const style = 'color: green; font-weight: bold';
+      if (data) {
+        console.log(`[${timestamp}] %c${message}`, style, data);
+      } else {
+        console.log(`[${timestamp}] %c${message}`, style);
+      }
+    }
+  };
+
+  // WebGL diagnostics
+  const webglDiagnostics = {
+    // Check if WebGL is supported
+    checkWebGLSupport() {
+      utils.log('Checking WebGL support...');
+      
+      const canvas = document.createElement('canvas');
+      const gl2 = canvas.getContext('webgl2');
+      const gl1 = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
+      
+      if (!gl1 && !gl2) {
+        utils.error('WebGL not supported in this browser');
+        return null;
+      }
+      
+      if (gl2) {
+        utils.success('WebGL2 is supported');
+        return { version: 2, context: gl2 };
+      } else {
+        utils.warn('WebGL2 not supported, falling back to WebGL1');
+        return { version: 1, context: gl1 };
+      }
+    },
+    
+    // Get detailed information about WebGL capabilities
+    getWebGLInfo(gl) {
+      if (!gl) return null;
+      
+      const isWebGL2 = gl instanceof WebGL2RenderingContext;
+      const version = isWebGL2 ? 2 : 1;
+      
+      // Get basic info
+      const info = {
+        version,
+        vendor: gl.getParameter(gl.VENDOR),
+        renderer: gl.getParameter(gl.RENDERER),
+        glVersion: gl.getParameter(gl.VERSION),
+        shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
+        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
+        maxCubeMapTextureSize: gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),
+        maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
+        maxTextureImageUnits: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
+        maxVertexTextureImageUnits: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
+        maxCombinedTextureImageUnits: gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
+        maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
+        maxVaryingVectors: gl.getParameter(gl.MAX_VARYING_VECTORS),
+        maxVertexUniformVectors: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
+        maxFragmentUniformVectors: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
+        extensions: gl.getSupportedExtensions()
+      };
+      
+      // Get WebGL2-specific info if available
+      if (isWebGL2) {
+        info.maxVertexUniformBlocks = gl.getParameter(gl.MAX_VERTEX_UNIFORM_BLOCKS);
+        info.maxFragmentUniformBlocks = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_BLOCKS);
+        info.maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
+        info.maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
+        info.maxCombinedUniformBlocks = gl.getParameter(gl.MAX_COMBINED_UNIFORM_BLOCKS);
+        info.maxCombinedVertexUniformComponents = gl.getParameter(gl.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS);
+        info.maxCombinedFragmentUniformComponents = gl.getParameter(gl.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS);
+        info.maxTransformFeedbackSeparateComponents = gl.getParameter(gl.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS);
+        info.maxTransformFeedbackInterleavedComponents = gl.getParameter(gl.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS);
+      }
+      
+      return info;
+    },
+    
+    // Check if specific extensions are supported
+    checkExtensions(gl) {
+      if (!gl) return null;
+      
+      const extensions = gl.getSupportedExtensions();
+      const criticalExtensions = [
+        'ANGLE_instanced_arrays',
+        'OES_texture_float',
+        'OES_texture_half_float',
+        'WEBGL_depth_texture',
+        'OES_element_index_uint',
+        'OES_standard_derivatives',
+        'EXT_shader_texture_lod',
+        'WEBGL_compressed_texture_s3tc',
+        'WEBGL_debug_renderer_info'
+      ];
+      
+      const extensionStatus = {};
+      criticalExtensions.forEach(ext => {
+        extensionStatus[ext] = extensions.includes(ext);
+      });
+      
+      return extensionStatus;
+    },
+    
+    // Test shader compilation
+    testShaderCompilation(gl) {
+      if (!gl) return null;
+      
+      const isWebGL2 = gl instanceof WebGL2RenderingContext;
+      
+      // Simple vertex shader
+      const vertexShaderSource = isWebGL2 ?
+        `#version 300 es
+        in vec4 position;
+        void main() {
+          gl_Position = position;
+        }` :
+        `attribute vec4 position;
+        void main() {
+          gl_Position = position;
+        }`;
+      
+      // Simple fragment shader
+      const fragmentShaderSource = isWebGL2 ?
+        `#version 300 es
+        precision highp float;
+        out vec4 fragColor;
+        void main() {
+          fragColor = vec4(1.0, 0.0, 0.0, 1.0);
+        }` :
+        `precision highp float;
+        void main() {
+          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
+        }`;
+      
+      try {
+        // Create vertex shader
+        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
+        gl.shaderSource(vertexShader, vertexShaderSource);
+        gl.compileShader(vertexShader);
+        
+        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
+          const info = gl.getShaderInfoLog(vertexShader);
+          throw new Error('Vertex shader compilation failed: ' + info);
+        }
+        
+        // Create fragment shader
+        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
+        gl.shaderSource(fragmentShader, fragmentShaderSource);
+        gl.compileShader(fragmentShader);
+        
+        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
+          const info = gl.getShaderInfoLog(fragmentShader);
+          throw new Error('Fragment shader compilation failed: ' + info);
+        }
+        
+        // Create program
+        const program = gl.createProgram();
+        gl.attachShader(program, vertexShader);
+        gl.attachShader(program, fragmentShader);
+        gl.linkProgram(program);
+        
+        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
+          const info = gl.getProgramInfoLog(program);
+          throw new Error('Program linking failed: ' + info);
+        }
+        
+        // Clean up
+        gl.deleteShader(vertexShader);
+        gl.deleteShader(fragmentShader);
+        gl.deleteProgram(program);
+        
+        return { success: true };
+      } catch (error) {
+        return { 
+          success: false, 
+          error: error.message 
+        };
+      }
+    },
+    
+    // Count active WebGL contexts
+    countActiveContexts() {
+      // Create multiple canvases and contexts to see if we hit limits
+      const contexts = [];
+      const maxAttempts = 32; // Try to create up to 32 contexts
+      
+      utils.log(`Attempting to create ${maxAttempts} WebGL contexts to test limits...`);
+      
+      for (let i = 0; i < maxAttempts; i++) {
+        const canvas = document.createElement('canvas');
+        canvas.width = 16;
+        canvas.height = 16;
+        
+        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
+        if (gl) {
+          contexts.push(gl);
+        } else {
+          break;
+        }
+      }
+      
+      utils.log(`Successfully created ${contexts.length} WebGL contexts`);
+      
+      // Clean up
+      contexts.forEach((gl, i) => {
+        const loseContext = gl.getExtension('WEBGL_lose_context');
+        if (loseContext) {
+          loseContext.loseContext();
+        }
+      });
+      
+      return contexts.length;
+    },
+    
+    // Check for WebGL context loss issues
+    checkContextLoss() {
+      const canvas = document.createElement('canvas');
+      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
+      
+      if (!gl) {
+        utils.error('Could not create WebGL context for context loss test');
+        return { supported: false };
+      }
+      
+      const loseContext = gl.getExtension('WEBGL_lose_context');
+      if (!loseContext) {
+        utils.warn('WEBGL_lose_context extension not supported, cannot test context loss recovery');
+        return { supported: false };
+      }
+      
+      return { 
+        supported: true,
+        extension: 'WEBGL_lose_context'
+      };
+    },
+    
+    // Run all diagnostics
+    runDiagnostics() {
+      utils.log('Starting WebGL diagnostics...');
+      
+      // Check WebGL support
+      const webglSupport = this.checkWebGLSupport();
+      if (!webglSupport) {
+        utils.error('WebGL diagnostics failed: WebGL not supported');
+        return;
+      }
+      
+      const { version, context: gl } = webglSupport;
+      
+      // Get detailed WebGL info
+      const webglInfo = this.getWebGLInfo(gl);
+      utils.log('WebGL capabilities:', webglInfo);
+      
+      // Check extensions
+      const extensionStatus = this.checkExtensions(gl);
+      utils.log('Critical extensions status:', extensionStatus);
+      
+      // Test shader compilation
+      const shaderTest = this.testShaderCompilation(gl);
+      if (shaderTest.success) {
+        utils.success('Shader compilation test passed');
+      } else {
+        utils.error('Shader compilation test failed:', shaderTest.error);
+      }
+      
+      // Count active contexts
+      const contextCount = this.countActiveContexts();
+      utils.log(`Maximum WebGL contexts: ${contextCount}`);
+      
+      // Check context loss
+      const contextLossCheck = this.checkContextLoss();
+      if (contextLossCheck.supported) {
+        utils.log('Context loss recovery is supported');
+      } else {
+        utils.warn('Context loss recovery may not be supported');
+      }
+      
+      // Generate recommendations
+      this.generateRecommendations(webglInfo, extensionStatus, shaderTest, contextCount);
+    },
+    
+    // Generate recommendations based on diagnostics
+    generateRecommendations(webglInfo, extensionStatus, shaderTest, contextCount) {
+      utils.log('--- WebGL Recommendations ---');
+      
+      // WebGL version recommendations
+      if (webglInfo.version === 1) {
+        utils.warn('Using WebGL1 - Consider using simpler shaders without #version 300 es');
+        utils.warn('Replace custom shaders with built-in Three.js materials where possible');
+      }
+      
+      // Extension recommendations
+      const missingExtensions = Object.entries(extensionStatus)
+        .filter(([ext, supported]) => !supported)
+        .map(([ext]) => ext);
+      
+      if (missingExtensions.length > 0) {
+        utils.warn(`Missing critical extensions: ${missingExtensions.join(', ')}`);
+        utils.warn('Some advanced rendering features may not work correctly');
+      }
+      
+      // Shader compilation recommendations
+      if (!shaderTest.success) {
+        utils.error('Shader compilation failed - Use built-in Three.js materials instead of custom shaders');
+      }
+      
+      // Context count recommendations
+      if (contextCount < 16) {
+        utils.warn(`Limited WebGL contexts available (${contextCount}) - Reduce the number of canvases/renderers`);
+      }
+      
+      // Memory recommendations
+      utils.log('To avoid WebGL context loss:');
+      utils.log('1. Dispose unused materials, textures, and geometries');
+      utils.log('2. Use shared materials and geometries where possible');
+      utils.log('3. Reduce texture sizes and complexity');
+      utils.log('4. Consider using a single renderer for multiple scenes');
+      
+      utils.success('WebGL diagnostics complete');
+    }
+  };
+
+  // Run diagnostics
+  webglDiagnostics.runDiagnostics();
+  
+  // Export to global scope
+  window.WebGLDiagnostics = webglDiagnostics;
+  
+  utils.log('WebGL diagnostics tool loaded. You can run diagnostics again with WebGLDiagnostics.runDiagnostics()');
+})(); 
\ No newline at end of file
diff --git a/client/websocket-diagnostics-browser.js b/client/websocket-diagnostics-browser.js
new file mode 100644
index 00000000..529c5981
--- /dev/null
+++ b/client/websocket-diagnostics-browser.js
@@ -0,0 +1,472 @@
+/**
+ * WebSocket Diagnostics Tool (Browser Version)
+ * 
+ * This is a standalone browser version of the WebSocket diagnostics tool
+ * that can be loaded directly in the browser console.
+ * 
+ * Usage:
+ * 1. Copy this entire file
+ * 2. Paste it into the browser console
+ * 3. Call `WebSocketDiagnostics.runDiagnostics()` to start the diagnostics
+ */
+
+(function() {
+  // Configuration
+  const CONFIG = {
+    // Timeouts and intervals (in milliseconds)
+    connectionTimeout: 10000,
+    pingInterval: 2000,
+    reconnectDelay: 3000,
+    testDuration: 30000,
+    
+    // Test parameters
+    connectionAttempts: 3,
+    binaryValidationSamples: 5,
+    
+    // Expected binary protocol values
+    expectedBytesPerNode: 28,
+    expectedHeaderSize: 8,
+    
+    // Logging
+    verbose: true,
+    logTimestamps: true
+  };
+
+  // Diagnostic state
+  const state = {
+    connectionAttempts: 0,
+    messagesReceived: 0,
+    binaryMessagesReceived: 0,
+    textMessagesReceived: 0,
+    reconnections: 0,
+    errors: 0,
+    binarySizes: [],
+    latencies: [],
+    pingTimestamps: new Map(),
+    testStartTime: 0,
+    socket: null,
+    testRunning: false
+  };
+
+  // Utility functions
+  const utils = {
+    timestamp() {
+      return CONFIG.logTimestamps 
+        ? `[${new Date().toISOString()}] `
+        : '';
+    },
+    
+    log(message, type = 'info') {
+      const prefix = utils.timestamp();
+      
+      switch (type) {
+        case 'error':
+          console.error(`${prefix} ${message}`);
+          break;
+        case 'warning':
+          console.warn(`${prefix} ${message}`);
+          break;
+        case 'success':
+          console.log(`${prefix} ${message}`);
+          break;
+        default:
+          console.log(`${prefix} ${message}`);
+      }
+    },
+    
+    formatBytes(bytes) {
+      if (bytes === 0) return '0 Bytes';
+      const k = 1024;
+      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
+      const i = Math.floor(Math.log(bytes) / Math.log(k));
+      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
+    },
+    
+    calculateAverage(arr) {
+      if (arr.length === 0) return 0;
+      return arr.reduce((a, b) => a + b, 0) / arr.length;
+    },
+    
+    generateRandomId() {
+      return Math.random().toString(36).substring(2, 15);
+    },
+    
+    isCompressed(data) {
+      // Check for zlib header (78 01, 78 9C, or 78 DA)
+      const header = new Uint8Array(data, 0, 2);
+      return header[0] === 0x78 && (header[1] === 0x01 || header[1] === 0x9C || header[1] === 0xDA);
+    },
+    
+    buildWsUrl() {
+      const location = window.location;
+      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
+      const host = location.hostname;
+      const port = location.port ? `:${location.port}` : '';
+      
+      // In production, WebSocket is served at /wss
+      // In development, it's typically at localhost:4000/wss
+      const wsPath = '/wss';
+      
+      return `${protocol}//${host}${port}${wsPath}`;
+    }
+  };
+
+  // Network diagnostics
+  const network = {
+    async testApiConnectivity() {
+      try {
+        utils.log('Testing API connectivity...');
+        const response = await fetch('/api/user-settings', { method: 'HEAD' });
+        if (response.ok) {
+          utils.log('API connectivity test passed', 'success');
+          return true;
+        } else {
+          utils.log(`API connectivity test failed: ${response.status} ${response.statusText}`, 'error');
+          return false;
+        }
+      } catch (error) {
+        utils.log(`API connectivity test failed: ${error}`, 'error');
+        return false;
+      }
+    },
+    
+    async checkDnsResolution() {
+      try {
+        utils.log('Checking DNS resolution...');
+        const hostname = window.location.hostname;
+        const response = await fetch(`https://${hostname}/favicon.ico`, { method: 'HEAD' });
+        if (response.ok) {
+          utils.log(`DNS resolution successful: ${response.status}`, 'success');
+        } else {
+          utils.log(`DNS resolution returned status: ${response.status}`, 'warning');
+        }
+        return response.ok;
+      } catch (error) {
+        utils.log(`DNS resolution failed: ${error}`, 'error');
+        return false;
+      }
+    }
+  };
+
+  // Binary protocol validation
+  const binaryProtocol = {
+    validateMessageSize(data) {
+      const size = data.byteLength;
+      state.binarySizes.push(size);
+      
+      // Check if the message is compressed
+      if (utils.isCompressed(data)) {
+        utils.log(`Received compressed binary message: ${utils.formatBytes(size)}`);
+        try {
+          // Decompress the message if pako is available
+          if (window.pako) {
+            const compressedData = new Uint8Array(data);
+            const decompressedData = window.pako.inflate(compressedData);
+            return this.validateDecompressedMessage(decompressedData.buffer);
+          } else {
+            utils.log('Pako library not available for decompression. Install pako or include it in your page to analyze compressed messages.', 'warning');
+            return false;
+          }
+        } catch (error) {
+          utils.log(`Failed to decompress message: ${error}`, 'error');
+          return false;
+        }
+      } else {
+        return this.validateDecompressedMessage(data);
+      }
+    },
+    
+    validateDecompressedMessage(data) {
+      const size = data.byteLength;
+      const headerSize = CONFIG.expectedHeaderSize;
+      const bytesPerNode = CONFIG.expectedBytesPerNode;
+      
+      // Check if the message size (minus header) is divisible by the expected bytes per node
+      const dataSize = size - headerSize;
+      const remainder = dataSize % bytesPerNode;
+      
+      if (remainder !== 0) {
+        utils.log(`Binary message size validation failed: message size (${size} bytes) minus header (${headerSize} bytes) = ${dataSize} bytes, which is not divisible by ${bytesPerNode} bytes per node. Remainder: ${remainder} bytes`, 'error');
+        return false;
+      }
+      
+      const nodeCount = dataSize / bytesPerNode;
+      utils.log(`Binary message contains data for ${nodeCount} nodes (${utils.formatBytes(size)})`, 'info');
+      
+      // Read the header to get the actual node count
+      const view = new DataView(data);
+      const messageType = view.getUint32(0, true);
+      const reportedNodeCount = view.getUint32(4, true);
+      
+      utils.log(`Message type: ${messageType}, reported node count: ${reportedNodeCount}`, 'info');
+      
+      if (nodeCount !== reportedNodeCount) {
+        utils.log(`Node count mismatch: header reports ${reportedNodeCount} nodes, but message contains data for ${nodeCount} nodes`, 'error');
+        return false;
+      }
+      
+      utils.log(`Binary message validation passed: ${reportedNodeCount} nodes, ${utils.formatBytes(size)}`, 'success');
+      return true;
+    },
+    
+    analyzeMessageFrequency() {
+      if (state.binaryMessagesReceived === 0) {
+        utils.log('No binary messages received during the test period', 'warning');
+        return;
+      }
+      
+      const avgSize = utils.calculateAverage(state.binarySizes);
+      const messagesPerSecond = state.binaryMessagesReceived / (CONFIG.testDuration / 1000);
+      
+      utils.log(`Binary message frequency: ${messagesPerSecond.toFixed(2)} messages/second`);
+      utils.log(`Average binary message size: ${utils.formatBytes(avgSize)}`);
+    }
+  };
+
+  // WebSocket connection handling
+  const wsConnection = {
+    connect() {
+      return new Promise((resolve, reject) => {
+        state.connectionAttempts++;
+        
+        const url = utils.buildWsUrl();
+        utils.log(`Connecting to WebSocket: ${url} (Attempt ${state.connectionAttempts}/${CONFIG.connectionAttempts})`);
+        
+        const socket = new WebSocket(url);
+        state.socket = socket;
+        
+        // Set up connection timeout
+        const timeoutId = setTimeout(() => {
+          if (socket.readyState !== WebSocket.OPEN) {
+            utils.log('WebSocket connection timeout', 'error');
+            socket.close();
+            reject(new Error('Connection timeout'));
+          }
+        }, CONFIG.connectionTimeout);
+        
+        socket.onopen = () => {
+          clearTimeout(timeoutId);
+          utils.log('WebSocket connection established', 'success');
+          
+          // Send initial message to request data
+          this.sendInitialRequest(socket);
+          
+          // Start ping test
+          this.startPingTest(socket);
+          
+          resolve(socket);
+        };
+        
+        socket.onerror = (error) => {
+          clearTimeout(timeoutId);
+          state.errors++;
+          utils.log(`WebSocket error: ${error}`, 'error');
+          reject(error);
+        };
+        
+        socket.onclose = (event) => {
+          clearTimeout(timeoutId);
+          utils.log(`WebSocket connection closed: Code ${event.code}, Reason: ${event.reason || 'No reason provided'}`);
+          
+          if (state.testRunning && state.connectionAttempts < CONFIG.connectionAttempts) {
+            utils.log(`Attempting to reconnect in ${CONFIG.reconnectDelay}ms...`);
+            state.reconnections++;
+            
+            setTimeout(() => {
+              this.connect().catch(error => {
+                utils.log(`Reconnection failed: ${error}`, 'error');
+              });
+            }, CONFIG.reconnectDelay);
+          }
+        };
+        
+        socket.onmessage = (event) => {
+          this.handleMessage(event);
+        };
+      });
+    },
+    
+    sendInitialRequest(socket) {
+      if (socket.readyState === WebSocket.OPEN) {
+        const initialRequest = JSON.stringify({ type: 'requestInitialData' });
+        socket.send(initialRequest);
+        utils.log('Sent initial data request');
+      }
+    },
+    
+    startPingTest(socket) {
+      const pingInterval = setInterval(() => {
+        if (socket.readyState !== WebSocket.OPEN) {
+          clearInterval(pingInterval);
+          return;
+        }
+        
+        const pingId = utils.generateRandomId();
+        const pingMessage = JSON.stringify({ type: 'ping', id: pingId });
+        
+        state.pingTimestamps.set(pingId, Date.now());
+        socket.send(pingMessage);
+        
+        if (CONFIG.verbose) {
+          utils.log(`Sent ping: ${pingId}`);
+        }
+      }, CONFIG.pingInterval);
+    },
+    
+    handleMessage(event) {
+      state.messagesReceived++;
+      
+      if (typeof event.data === 'string') {
+        state.textMessagesReceived++;
+        this.handleTextMessage(event.data);
+      } else if (event.data instanceof ArrayBuffer) {
+        state.binaryMessagesReceived++;
+        this.handleBinaryMessage(event.data);
+      } else if (event.data instanceof Blob) {
+        // Convert Blob to ArrayBuffer
+        const reader = new FileReader();
+        reader.onload = () => {
+          if (reader.result instanceof ArrayBuffer) {
+            state.binaryMessagesReceived++;
+            this.handleBinaryMessage(reader.result);
+          }
+        };
+        reader.readAsArrayBuffer(event.data);
+      }
+    },
+    
+    handleTextMessage(data) {
+      try {
+        const message = JSON.parse(data);
+        
+        if (CONFIG.verbose) {
+          utils.log(`Received text message: ${JSON.stringify(message)}`);
+        }
+        
+        // Handle pong messages for latency calculation
+        if (message.type === 'pong' && message.id) {
+          const pingTime = state.pingTimestamps.get(message.id);
+          if (pingTime) {
+            const latency = Date.now() - pingTime;
+            state.latencies.push(latency);
+            state.pingTimestamps.delete(message.id);
+            
+            if (CONFIG.verbose) {
+              utils.log(`Received pong: ${message.id}, latency: ${latency}ms`);
+            }
+          }
+        }
+      } catch (error) {
+        utils.log(`Failed to parse text message: ${error}`, 'error');
+      }
+    },
+    
+    handleBinaryMessage(data) {
+      if (CONFIG.verbose) {
+        utils.log(`Received binary message: ${utils.formatBytes(data.byteLength)}`);
+      }
+      
+      // Validate binary message format
+      binaryProtocol.validateMessageSize(data);
+    }
+  };
+
+  // Main diagnostics functions
+  async function runDiagnostics() {
+    utils.log('Starting WebSocket diagnostics...');
+    state.testStartTime = Date.now();
+    state.testRunning = true;
+    
+    try {
+      // Check network connectivity
+      const apiConnectivity = await network.testApiConnectivity();
+      if (!apiConnectivity) {
+        utils.log('API connectivity test failed, but continuing with WebSocket tests', 'warning');
+      }
+      
+      // Connect to WebSocket
+      const socket = await wsConnection.connect();
+      
+      // Run the test for the configured duration
+      setTimeout(() => {
+        state.testRunning = false;
+        if (socket.readyState === WebSocket.OPEN) {
+          socket.close();
+        }
+        
+        // Generate diagnostics report
+        generateReport();
+      }, CONFIG.testDuration);
+    } catch (error) {
+      utils.log(`Diagnostics failed: ${error}`, 'error');
+      state.testRunning = false;
+      generateReport();
+    }
+  }
+
+  function generateReport() {
+    utils.log('--- WebSocket Diagnostics Report ---');
+    utils.log(`Test duration: ${(Date.now() - state.testStartTime) / 1000} seconds`);
+    utils.log(`Connection attempts: ${state.connectionAttempts}`);
+    utils.log(`Reconnections: ${state.reconnections}`);
+    utils.log(`Errors: ${state.errors}`);
+    utils.log(`Total messages received: ${state.messagesReceived}`);
+    utils.log(`Text messages received: ${state.textMessagesReceived}`);
+    utils.log(`Binary messages received: ${state.binaryMessagesReceived}`);
+    
+    if (state.latencies.length > 0) {
+      const avgLatency = utils.calculateAverage(state.latencies);
+      const minLatency = Math.min(...state.latencies);
+      const maxLatency = Math.max(...state.latencies);
+      
+      utils.log(`Latency - Avg: ${avgLatency.toFixed(2)}ms, Min: ${minLatency}ms, Max: ${maxLatency}ms`);
+    } else {
+      utils.log('No latency measurements available', 'warning');
+    }
+    
+    binaryProtocol.analyzeMessageFrequency();
+    
+    // Provide recommendations based on diagnostics
+    provideRecommendations();
+  }
+
+  function provideRecommendations() {
+    utils.log('--- Recommendations ---');
+    
+    if (state.errors > 0) {
+      utils.log(' Connection errors detected. Check network stability and server availability.');
+    }
+    
+    if (state.reconnections > 0) {
+      utils.log(' Multiple reconnections detected. This may indicate network instability or server issues.');
+    }
+    
+    if (state.binaryMessagesReceived === 0) {
+      utils.log(' No binary messages received. Check if the server is sending updates or if the initial request was processed.');
+    }
+    
+    if (state.latencies.length > 0) {
+      const avgLatency = utils.calculateAverage(state.latencies);
+      if (avgLatency > 200) {
+        utils.log(' High average latency detected. This may affect real-time performance.');
+      }
+    }
+    
+    utils.log(' Diagnostics complete. Use this information to troubleshoot WebSocket issues.');
+  }
+
+  // Check for pako library
+  if (!window.pako) {
+    utils.log('Pako library not detected. Compressed binary messages will not be analyzed. Consider adding pako to your page: <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>', 'warning');
+  }
+
+  // Export to global scope
+  window.WebSocketDiagnostics = {
+    runDiagnostics,
+    testApiConnectivity: network.testApiConnectivity,
+    checkDnsResolution: network.checkDnsResolution,
+    CONFIG
+  };
+
+  utils.log('WebSocket diagnostics tool loaded. Call WebSocketDiagnostics.runDiagnostics() to start diagnostics.');
+})(); 
\ No newline at end of file
diff --git a/client/websocket-diagnostics.ts b/client/websocket-diagnostics.ts
new file mode 100644
index 00000000..4f973e4a
--- /dev/null
+++ b/client/websocket-diagnostics.ts
@@ -0,0 +1,465 @@
+/**
+ * WebSocket Diagnostics Tool
+ * 
+ * This tool provides comprehensive diagnostics for WebSocket connections,
+ * including connection status, message handling, binary protocol validation,
+ * and network analysis.
+ * 
+ * Usage:
+ * 1. Import this file in your application or load it via the browser console
+ * 2. Call `runDiagnostics()` to start the diagnostics process
+ * 3. Check the console for detailed logs and diagnostics information
+ * 
+ * Features:
+ * - Connection status monitoring
+ * - Binary protocol validation
+ * - Network latency measurement
+ * - Message size analysis
+ * - Reconnection testing
+ */
+
+import { buildWsUrl } from './core/api';
+import pako from 'pako';
+import { debugState } from './core/debugState';
+import { logger } from './core/logger';
+
+// Configuration
+const CONFIG = {
+  // Timeouts and intervals (in milliseconds)
+  connectionTimeout: 10000,
+  pingInterval: 2000,
+  reconnectDelay: 3000,
+  testDuration: 30000,
+  
+  // Test parameters
+  connectionAttempts: 3,
+  binaryValidationSamples: 5,
+  
+  // Expected binary protocol values
+  expectedBytesPerNode: 28,
+  expectedHeaderSize: 8,
+  
+  // Logging
+  verbose: true,
+  logTimestamps: true
+};
+
+// Diagnostic state
+const state = {
+  connectionAttempts: 0,
+  messagesReceived: 0,
+  binaryMessagesReceived: 0,
+  textMessagesReceived: 0,
+  reconnections: 0,
+  errors: 0,
+  binarySizes: [] as number[],
+  latencies: [] as number[],
+  pingTimestamps: new Map<string, number>(),
+  testStartTime: 0,
+  socket: null as WebSocket | null,
+  testRunning: false
+};
+
+// Utility functions
+const utils = {
+  timestamp(): string {
+    return CONFIG.logTimestamps 
+      ? `[${new Date().toISOString()}] `
+      : '';
+  },
+  
+  log(message: string, type: 'info' | 'error' | 'warning' | 'success' = 'info'): void {
+    const prefix = utils.timestamp();
+    
+    switch (type) {
+      case 'error':
+        console.error(`${prefix} ${message}`);
+        break;
+      case 'warning':
+        console.warn(`${prefix} ${message}`);
+        break;
+      case 'success':
+        console.log(`${prefix} ${message}`);
+        break;
+      default:
+        console.log(`${prefix} ${message}`);
+    }
+  },
+  
+  formatBytes(bytes: number): string {
+    if (bytes === 0) return '0 Bytes';
+    const k = 1024;
+    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
+    const i = Math.floor(Math.log(bytes) / Math.log(k));
+    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
+  },
+  
+  calculateAverage(arr: number[]): number {
+    if (arr.length === 0) return 0;
+    return arr.reduce((a, b) => a + b, 0) / arr.length;
+  },
+  
+  generateRandomId(): string {
+    return Math.random().toString(36).substring(2, 15);
+  },
+  
+  isCompressed(data: ArrayBuffer): boolean {
+    // Check for zlib header (78 01, 78 9C, or 78 DA)
+    const header = new Uint8Array(data, 0, 2);
+    return header[0] === 0x78 && (header[1] === 0x01 || header[1] === 0x9C || header[1] === 0xDA);
+  }
+};
+
+// Network diagnostics
+const network = {
+  async testApiConnectivity(): Promise<boolean> {
+    try {
+      utils.log('Testing API connectivity...');
+      const response = await fetch('/api/user-settings', { method: 'HEAD' });
+      if (response.ok) {
+        utils.log('API connectivity test passed', 'success');
+        return true;
+      } else {
+        utils.log(`API connectivity test failed: ${response.status} ${response.statusText}`, 'error');
+        return false;
+      }
+    } catch (error) {
+      utils.log(`API connectivity test failed: ${error}`, 'error');
+      return false;
+    }
+  },
+  
+  async checkDnsResolution(): Promise<boolean> {
+    try {
+      utils.log('Checking DNS resolution...');
+      const hostname = window.location.hostname;
+      const response = await fetch(`https://${hostname}/favicon.ico`, { method: 'HEAD' });
+      if (response.ok) {
+        utils.log(`DNS resolution successful: ${response.status}`, 'success');
+      } else {
+        utils.log(`DNS resolution returned status: ${response.status}`, 'warning');
+      }
+      return response.ok;
+    } catch (error) {
+      utils.log(`DNS resolution failed: ${error}`, 'error');
+      return false;
+    }
+  }
+};
+
+// Binary protocol validation
+const binaryProtocol = {
+  validateMessageSize(data: ArrayBuffer): boolean {
+    const size = data.byteLength;
+    state.binarySizes.push(size);
+    
+    // Check if the message is compressed
+    if (utils.isCompressed(data)) {
+      utils.log(`Received compressed binary message: ${utils.formatBytes(size)}`);
+      try {
+        // Decompress the message
+        const compressedData = new Uint8Array(data);
+        const decompressedData = pako.inflate(compressedData);
+        return this.validateDecompressedMessage(decompressedData.buffer);
+      } catch (error) {
+        utils.log(`Failed to decompress message: ${error}`, 'error');
+        return false;
+      }
+    } else {
+      return this.validateDecompressedMessage(data);
+    }
+  },
+  
+  validateDecompressedMessage(data: ArrayBuffer): boolean {
+    const size = data.byteLength;
+    const headerSize = CONFIG.expectedHeaderSize;
+    const bytesPerNode = CONFIG.expectedBytesPerNode;
+    
+    // Check if the message size (minus header) is divisible by the expected bytes per node
+    const dataSize = size - headerSize;
+    const remainder = dataSize % bytesPerNode;
+    
+    if (remainder !== 0) {
+      utils.log(`Binary message size validation failed: message size (${size} bytes) minus header (${headerSize} bytes) = ${dataSize} bytes, which is not divisible by ${bytesPerNode} bytes per node. Remainder: ${remainder} bytes`, 'error');
+      return false;
+    }
+    
+    const nodeCount = dataSize / bytesPerNode;
+    utils.log(`Binary message contains data for ${nodeCount} nodes (${utils.formatBytes(size)})`, 'info');
+    
+    // Read the header to get the actual node count
+    const view = new DataView(data);
+    const messageType = view.getUint32(0, true);
+    const reportedNodeCount = view.getUint32(4, true);
+    
+    utils.log(`Message type: ${messageType}, reported node count: ${reportedNodeCount}`, 'info');
+    
+    if (nodeCount !== reportedNodeCount) {
+      utils.log(`Node count mismatch: header reports ${reportedNodeCount} nodes, but message contains data for ${nodeCount} nodes`, 'error');
+      return false;
+    }
+    
+    utils.log(`Binary message validation passed: ${reportedNodeCount} nodes, ${utils.formatBytes(size)}`, 'success');
+    return true;
+  },
+  
+  analyzeMessageFrequency(): void {
+    if (state.binaryMessagesReceived === 0) {
+      utils.log('No binary messages received during the test period', 'warning');
+      return;
+    }
+    
+    const avgSize = utils.calculateAverage(state.binarySizes);
+    const messagesPerSecond = state.binaryMessagesReceived / (CONFIG.testDuration / 1000);
+    
+    utils.log(`Binary message frequency: ${messagesPerSecond.toFixed(2)} messages/second`);
+    utils.log(`Average binary message size: ${utils.formatBytes(avgSize)}`);
+  }
+};
+
+// WebSocket connection handling
+const wsConnection = {
+  connect(): Promise<WebSocket> {
+    return new Promise((resolve, reject) => {
+      state.connectionAttempts++;
+      
+      const url = buildWsUrl();
+      utils.log(`Connecting to WebSocket: ${url} (Attempt ${state.connectionAttempts}/${CONFIG.connectionAttempts})`);
+      
+      const socket = new WebSocket(url);
+      state.socket = socket;
+      
+      // Set up connection timeout
+      const timeoutId = setTimeout(() => {
+        if (socket.readyState !== WebSocket.OPEN) {
+          utils.log('WebSocket connection timeout', 'error');
+          socket.close();
+          reject(new Error('Connection timeout'));
+        }
+      }, CONFIG.connectionTimeout);
+      
+      socket.onopen = () => {
+        clearTimeout(timeoutId);
+        utils.log('WebSocket connection established', 'success');
+        
+        // Send initial message to request data
+        this.sendInitialRequest(socket);
+        
+        // Start ping test
+        this.startPingTest(socket);
+        
+        resolve(socket);
+      };
+      
+      socket.onerror = (error) => {
+        clearTimeout(timeoutId);
+        state.errors++;
+        utils.log(`WebSocket error: ${error}`, 'error');
+        reject(error);
+      };
+      
+      socket.onclose = (event) => {
+        clearTimeout(timeoutId);
+        utils.log(`WebSocket connection closed: Code ${event.code}, Reason: ${event.reason || 'No reason provided'}`);
+        
+        if (state.testRunning && state.connectionAttempts < CONFIG.connectionAttempts) {
+          utils.log(`Attempting to reconnect in ${CONFIG.reconnectDelay}ms...`);
+          state.reconnections++;
+          
+          setTimeout(() => {
+            this.connect().catch(error => {
+              utils.log(`Reconnection failed: ${error}`, 'error');
+            });
+          }, CONFIG.reconnectDelay);
+        }
+      };
+      
+      socket.onmessage = (event) => {
+        this.handleMessage(event);
+      };
+    });
+  },
+  
+  sendInitialRequest(socket: WebSocket): void {
+    if (socket.readyState === WebSocket.OPEN) {
+      const initialRequest = JSON.stringify({ type: 'requestInitialData' });
+      socket.send(initialRequest);
+      utils.log('Sent initial data request');
+    }
+  },
+  
+  startPingTest(socket: WebSocket): void {
+    const pingInterval = setInterval(() => {
+      if (socket.readyState !== WebSocket.OPEN) {
+        clearInterval(pingInterval);
+        return;
+      }
+      
+      const pingId = utils.generateRandomId();
+      const pingMessage = JSON.stringify({ type: 'ping', id: pingId });
+      
+      state.pingTimestamps.set(pingId, Date.now());
+      socket.send(pingMessage);
+      
+      if (CONFIG.verbose) {
+        utils.log(`Sent ping: ${pingId}`);
+      }
+    }, CONFIG.pingInterval);
+  },
+  
+  handleMessage(event: MessageEvent): void {
+    state.messagesReceived++;
+    
+    if (typeof event.data === 'string') {
+      state.textMessagesReceived++;
+      this.handleTextMessage(event.data);
+    } else if (event.data instanceof ArrayBuffer) {
+      state.binaryMessagesReceived++;
+      this.handleBinaryMessage(event.data);
+    } else if (event.data instanceof Blob) {
+      // Convert Blob to ArrayBuffer
+      const reader = new FileReader();
+      reader.onload = () => {
+        if (reader.result instanceof ArrayBuffer) {
+          state.binaryMessagesReceived++;
+          this.handleBinaryMessage(reader.result);
+        }
+      };
+      reader.readAsArrayBuffer(event.data);
+    }
+  },
+  
+  handleTextMessage(data: string): void {
+    try {
+      const message = JSON.parse(data);
+      
+      if (CONFIG.verbose) {
+        utils.log(`Received text message: ${JSON.stringify(message)}`);
+      }
+      
+      // Handle pong messages for latency calculation
+      if (message.type === 'pong' && message.id) {
+        const pingTime = state.pingTimestamps.get(message.id);
+        if (pingTime) {
+          const latency = Date.now() - pingTime;
+          state.latencies.push(latency);
+          state.pingTimestamps.delete(message.id);
+          
+          if (CONFIG.verbose) {
+            utils.log(`Received pong: ${message.id}, latency: ${latency}ms`);
+          }
+        }
+      }
+    } catch (error) {
+      utils.log(`Failed to parse text message: ${error}`, 'error');
+    }
+  },
+  
+  handleBinaryMessage(data: ArrayBuffer): void {
+    if (CONFIG.verbose) {
+      utils.log(`Received binary message: ${utils.formatBytes(data.byteLength)}`);
+    }
+    
+    // Validate binary message format
+    binaryProtocol.validateMessageSize(data);
+  }
+};
+
+// Main diagnostics functions
+export async function runDiagnostics(): Promise<void> {
+  utils.log('Starting WebSocket diagnostics...');
+  state.testStartTime = Date.now();
+  state.testRunning = true;
+  
+  try {
+    // Check network connectivity
+    const apiConnectivity = await network.testApiConnectivity();
+    if (!apiConnectivity) {
+      utils.log('API connectivity test failed, but continuing with WebSocket tests', 'warning');
+    }
+    
+    // Connect to WebSocket
+    const socket = await wsConnection.connect();
+    
+    // Run the test for the configured duration
+    setTimeout(() => {
+      state.testRunning = false;
+      if (socket.readyState === WebSocket.OPEN) {
+        socket.close();
+      }
+      
+      // Generate diagnostics report
+      generateReport();
+    }, CONFIG.testDuration);
+  } catch (error) {
+    utils.log(`Diagnostics failed: ${error}`, 'error');
+    state.testRunning = false;
+    generateReport();
+  }
+}
+
+function generateReport(): void {
+  utils.log('--- WebSocket Diagnostics Report ---');
+  utils.log(`Test duration: ${(Date.now() - state.testStartTime) / 1000} seconds`);
+  utils.log(`Connection attempts: ${state.connectionAttempts}`);
+  utils.log(`Reconnections: ${state.reconnections}`);
+  utils.log(`Errors: ${state.errors}`);
+  utils.log(`Total messages received: ${state.messagesReceived}`);
+  utils.log(`Text messages received: ${state.textMessagesReceived}`);
+  utils.log(`Binary messages received: ${state.binaryMessagesReceived}`);
+  
+  if (state.latencies.length > 0) {
+    const avgLatency = utils.calculateAverage(state.latencies);
+    const minLatency = Math.min(...state.latencies);
+    const maxLatency = Math.max(...state.latencies);
+    
+    utils.log(`Latency - Avg: ${avgLatency.toFixed(2)}ms, Min: ${minLatency}ms, Max: ${maxLatency}ms`);
+  } else {
+    utils.log('No latency measurements available', 'warning');
+  }
+  
+  binaryProtocol.analyzeMessageFrequency();
+  
+  // Provide recommendations based on diagnostics
+  provideRecommendations();
+}
+
+function provideRecommendations(): void {
+  utils.log('--- Recommendations ---');
+  
+  if (state.errors > 0) {
+    utils.log(' Connection errors detected. Check network stability and server availability.');
+  }
+  
+  if (state.reconnections > 0) {
+    utils.log(' Multiple reconnections detected. This may indicate network instability or server issues.');
+  }
+  
+  if (state.binaryMessagesReceived === 0) {
+    utils.log(' No binary messages received. Check if the server is sending updates or if the initial request was processed.');
+  }
+  
+  if (state.latencies.length > 0) {
+    const avgLatency = utils.calculateAverage(state.latencies);
+    if (avgLatency > 200) {
+      utils.log(' High average latency detected. This may affect real-time performance.');
+    }
+  }
+  
+  utils.log(' Diagnostics complete. Use this information to troubleshoot WebSocket issues.');
+}
+
+// Export functions for manual invocation
+export const WebSocketDiagnostics = {
+  runDiagnostics,
+  testApiConnectivity: network.testApiConnectivity,
+  checkDnsResolution: network.checkDnsResolution,
+  CONFIG
+};
+
+// Auto-run diagnostics if in development mode
+if (process.env.NODE_ENV === 'development') {
+  if (debugState.isWebsocketDebugEnabled()) {
+    logger.debug('WebSocket diagnostics tool loaded. Call WebSocketDiagnostics.runDiagnostics() to start diagnostics.');
+  }
+} 
\ No newline at end of file
diff --git a/client/websocket-test.ts b/client/websocket-test.ts
new file mode 100644
index 00000000..cb09cb33
--- /dev/null
+++ b/client/websocket-test.ts
@@ -0,0 +1,296 @@
+/**
+ * WebSocket Connection Test Script
+ * 
+ * This script can be run in the browser console to diagnose WebSocket connection issues.
+ * It tests the WebSocket connection to the server and logs detailed information about
+ * the connection process, including any errors that occur.
+ * 
+ * Usage:
+ * 1. Open the browser console (F12 or Ctrl+Shift+I)
+ * 2. Copy and paste this entire script into the console
+ * 3. Press Enter to run the test
+ * 4. Check the console for detailed logs about the WebSocket connection
+ */
+
+import { debugState } from './core/debugState';
+import { logger, createDataMetadata } from './core/logger';
+
+// Configuration
+const TEST_TIMEOUT_MS = 10000; // 10 seconds
+const PING_INTERVAL_MS = 2000; // 2 seconds
+const CONNECTION_ATTEMPTS = 3;  // Number of connection attempts
+
+// Utility functions
+function log(message: string, data?: any) {
+  if (debugState.isWebsocketDebugEnabled()) {
+    if (data) {
+      logger.debug(`[WebsocketTest] ${message}`, createDataMetadata(data));
+    } else {
+      logger.debug(`[WebsocketTest] ${message}`);
+    }
+  }
+}
+
+function error(message: string, err?: any) {
+  // Error logs are always shown regardless of debug state
+  const timestamp = new Date().toISOString();
+  if (err) {
+    console.error(`[${timestamp}] ${message}`, err);
+  } else {
+    console.error(`[${timestamp}] ${message}`);
+  }
+}
+
+function warn(message: string, data?: any) {
+  // Warning logs are always shown regardless of debug state
+  const timestamp = new Date().toISOString();
+  if (data) {
+    console.warn(`[${timestamp}] ${message}`, data);
+  } else {
+    console.warn(`[${timestamp}] ${message}`);
+  }
+}
+
+// Build WebSocket URL using the same logic as the application
+function buildWsUrl(): string {
+  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
+  const host = window.location.hostname;
+  // Check if we're in production (any visionflow.info domain)
+  const isProduction = host.endsWith('visionflow.info');
+  const port = isProduction ? '' : ':4000';
+  const base = `${protocol}//${host}${port}`;
+  const wsPath = '/wss';
+  return `${base}${wsPath}`;
+}
+
+// Test network connectivity to the API
+async function testApiConnectivity() {
+  log('Testing API connectivity...');
+  try {
+    const response = await fetch('/api/user-settings', { 
+      method: 'HEAD',
+      cache: 'no-cache'
+    });
+    log('API connectivity test result:', {
+      status: response.status,
+      ok: response.ok,
+      statusText: response.statusText
+    });
+    return response.ok;
+  } catch (err) {
+    error('API connectivity test failed', err);
+    return false;
+  }
+}
+
+// Test WebSocket connection
+function testWebSocketConnection(url: string): Promise<boolean> {
+  return new Promise((resolve) => {
+    log(`Testing WebSocket connection to ${url}...`);
+    
+    let pingInterval: number | null = null;
+    let connectionTimeout: number | null = null;
+    
+    const ws = new WebSocket(url);
+    
+    // Set binary type to arraybuffer (same as the application)
+    ws.binaryType = 'arraybuffer';
+    
+    // Set connection timeout
+    connectionTimeout = window.setTimeout(() => {
+      error('WebSocket connection timed out');
+      if (pingInterval) clearInterval(pingInterval);
+      ws.close();
+      resolve(false);
+    }, TEST_TIMEOUT_MS);
+    
+    ws.onopen = () => {
+      log('WebSocket connection established successfully');
+      
+      // Clear connection timeout
+      if (connectionTimeout) {
+        clearTimeout(connectionTimeout);
+        connectionTimeout = null;
+      }
+      
+      // Send a ping message
+      const pingMessage = JSON.stringify({
+        type: 'ping',
+        timestamp: Date.now()
+      });
+      ws.send(pingMessage);
+      log('Sent ping message');
+      
+      // Set up ping interval
+      pingInterval = window.setInterval(() => {
+        if (ws.readyState === WebSocket.OPEN) {
+          const pingMessage = JSON.stringify({
+            type: 'ping',
+            timestamp: Date.now()
+          });
+          ws.send(pingMessage);
+          log('Sent ping message');
+        }
+      }, PING_INTERVAL_MS);
+      
+      // Send requestInitialData message (same as the application)
+      const requestMessage = JSON.stringify({
+        type: 'requestInitialData'
+      });
+      ws.send(requestMessage);
+      log('Sent requestInitialData message');
+      
+      // Resolve after 5 seconds of successful connection
+      setTimeout(() => {
+        if (pingInterval) clearInterval(pingInterval);
+        ws.close();
+        resolve(true);
+      }, 5000);
+    };
+    
+    ws.onmessage = (event) => {
+      if (typeof event.data === 'string') {
+        try {
+          const message = JSON.parse(event.data);
+          log('Received message:', message);
+        } catch (err) {
+          warn('Received non-JSON string message:', event.data);
+        }
+      } else if (event.data instanceof ArrayBuffer) {
+        const buffer = event.data;
+        log('Received binary message', {
+          byteLength: buffer.byteLength,
+          isMultipleOf28: buffer.byteLength % 28 === 0
+        });
+        
+        // Try to decompress using pako if available
+        if (window.pako) {
+          try {
+            const decompressed = window.pako.inflate(new Uint8Array(buffer));
+            log('Decompressed binary message', {
+              originalSize: buffer.byteLength,
+              decompressedSize: decompressed.byteLength,
+              isMultipleOf28: decompressed.byteLength % 28 === 0
+            });
+          } catch (err) {
+            // Not compressed or invalid data
+            log('Binary message is not compressed or invalid');
+          }
+        }
+      }
+    };
+    
+    ws.onerror = (event) => {
+      error('WebSocket error occurred', event);
+    };
+    
+    ws.onclose = (event) => {
+      if (connectionTimeout) {
+        clearTimeout(connectionTimeout);
+        connectionTimeout = null;
+      }
+      
+      if (pingInterval) {
+        clearInterval(pingInterval);
+        pingInterval = null;
+      }
+      
+      log('WebSocket connection closed', {
+        code: event.code,
+        reason: event.reason,
+        wasClean: event.wasClean
+      });
+      
+      // If not already resolved
+      if (connectionTimeout !== null) {
+        resolve(false);
+      }
+    };
+  });
+}
+
+// Run all tests
+async function runTests() {
+  log('Starting WebSocket connection tests');
+  log('Browser information:', {
+    userAgent: navigator.userAgent,
+    platform: navigator.platform,
+    vendor: navigator.vendor
+  });
+  
+  log('Page URL:', window.location.href);
+  
+  // Test API connectivity first
+  const apiConnectivity = await testApiConnectivity();
+  if (!apiConnectivity) {
+    error('API connectivity test failed. WebSocket connection is unlikely to succeed.');
+  }
+  
+  // Build WebSocket URL
+  const wsUrl = buildWsUrl();
+  log('WebSocket URL:', wsUrl);
+  
+  // Parse URL to check components
+  try {
+    const parsedUrl = new URL(wsUrl);
+    log('WebSocket URL components:', {
+      protocol: parsedUrl.protocol,
+      host: parsedUrl.host,
+      hostname: parsedUrl.hostname,
+      port: parsedUrl.port,
+      pathname: parsedUrl.pathname,
+      search: parsedUrl.search
+    });
+    
+    // Check if using secure WebSocket
+    if (parsedUrl.protocol !== 'wss:' && window.location.protocol === 'https:') {
+      warn('Using insecure WebSocket (ws://) with HTTPS site - browsers may block this');
+    }
+  } catch (err) {
+    error('Failed to parse WebSocket URL', err);
+  }
+  
+  // Test WebSocket connection multiple times
+  let successCount = 0;
+  for (let i = 0; i < CONNECTION_ATTEMPTS; i++) {
+    log(`Connection attempt ${i + 1} of ${CONNECTION_ATTEMPTS}`);
+    const success = await testWebSocketConnection(wsUrl);
+    if (success) {
+      successCount++;
+    }
+    
+    // Wait between attempts
+    if (i < CONNECTION_ATTEMPTS - 1) {
+      log('Waiting 2 seconds before next attempt...');
+      await new Promise(resolve => setTimeout(resolve, 2000));
+    }
+  }
+  
+  // Report results
+  log(`WebSocket test complete. ${successCount} of ${CONNECTION_ATTEMPTS} connection attempts succeeded.`);
+  
+  if (successCount === 0) {
+    error('All WebSocket connection attempts failed. Please check your network configuration and server status.');
+  } else if (successCount < CONNECTION_ATTEMPTS) {
+    warn(`${CONNECTION_ATTEMPTS - successCount} of ${CONNECTION_ATTEMPTS} connection attempts failed. Connection may be unstable.`);
+  } else {
+    log('All WebSocket connection attempts succeeded. Connection is stable.');
+  }
+}
+
+// Start the tests
+runTests().catch(err => {
+  error('Unhandled error during tests', err);
+});
+
+// Export for use in console
+(window as any).testWebSocket = {
+  runTests,
+  testApiConnectivity,
+  testWebSocketConnection,
+  buildWsUrl
+};
+
+// Log completion message
+log('WebSocket test script loaded. Tests are running automatically.');
+log('You can also run tests manually using: testWebSocket.runTests()'); 
\ No newline at end of file
diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
new file mode 100644
index 00000000..5940e712
--- /dev/null
+++ b/client/websocket/websocketService.ts
@@ -0,0 +1,1012 @@
+import { createLogger, createErrorMetadata, createMessageMetadata, createDataMetadata } from '../core/logger';
+import { buildWsUrl } from '../core/api';
+import { debugState } from '../core/debugState';
+import { Vector3 } from 'three';
+import pako from 'pako';
+import { UpdateThrottler, validateAndFixVector3 } from '../core/utils';
+
+const logger = createLogger('WebSocketService');
+
+// Throttle for debug logging to prevent excessive logs
+let lastDebugLogTime = 0;
+const DEBUG_LOG_THROTTLE_MS = 1000; // Only log once per second
+
+// Position update deadband threshold (only update if position changes by this amount)
+const POSITION_DEADBAND = 0.15; // Units in world space (0.15 = 15cm) - Increased from 0.05
+
+// Helper for conditional debug logging
+function debugLog(message: string, ...args: any[]) {
+    if (debugState.isWebsocketDebugEnabled()) {
+        const now = Date.now();
+        if (now - lastDebugLogTime > DEBUG_LOG_THROTTLE_MS) {
+            lastDebugLogTime = now;
+            logger.debug(message, ...args);
+        }
+    }
+}
+
+// Compression settings
+const COMPRESSION_THRESHOLD = 1024; // Only compress messages larger than 1KB
+
+// Binary format constants
+const BYTES_PER_NODE = 26; // 2 (ID) + 12 (position) + 12 (velocity)
+
+// Maximum value for u16 node IDs
+const MAX_U16_VALUE = 65535;
+
+enum ConnectionState {
+    DISCONNECTED = 'disconnected',
+    CONNECTING = 'connecting',
+    CONNECTED = 'connected',
+    RECONNECTING = 'reconnecting',
+    FAILED = 'failed'
+}
+
+// Interface for node updates from user interaction
+interface NodeUpdate {
+    id: string;          // Node ID (string in metadata, but must be converted to u16 index for binary protocol)
+    position: Vector3;   // Current position (Three.js Vector3 object)
+    velocity?: Vector3;  // Optional velocity (Three.js Vector3 object)
+    metadata?: {
+        name?: string;
+        lastModified?: number;
+        links?: string[];
+        references?: string[];
+        fileSize?: number;
+        hyperlinkCount?: number;
+    };
+}
+
+// Interface matching server's binary protocol format (26 bytes per node):
+// - id: 2 bytes (u16)
+// - position: 12 bytes (3xf32)
+// - velocity: 12 bytes (3xf32)
+interface BinaryNodeData {
+    id: number;
+    position: Vector3;   // Three.js Vector3 object
+    velocity: Vector3;   // Three.js Vector3 object
+}
+
+type BinaryMessageCallback = (nodes: BinaryNodeData[]) => void;
+
+export class WebSocketService {
+    private static instance: WebSocketService | null = null;
+    private ws: WebSocket | null = null;
+    private binaryMessageCallback: BinaryMessageCallback | null = null;
+    private reconnectTimeout: number | null = null;
+    private connectionState: ConnectionState = ConnectionState.DISCONNECTED;
+    private reconnectAttempts: number = 0;
+    private readonly _maxReconnectAttempts: number = 5;
+    // Keep track of node ID to numeric index mapping for binary protocol
+    private nodeNameToIndexMap: Map<string, number> = new Map();
+    private nextNodeIndex: number = 0;
+    private readonly initialReconnectDelay: number = 1000; // 1 second (reduced from 5000)
+    private readonly maxReconnectDelay: number = 30000; // 30 seconds (reduced from 60s)
+    private url: string = buildWsUrl(); // Initialize URL immediately
+    private initialDataReceived: boolean = false;
+    private connectionStatusHandler: ((status: boolean) => void) | null = null;
+
+    // Add a debounce mechanism for node updates
+    private loadingStatusHandler: ((isLoading: boolean, message?: string) => void) | null = null;
+    private heartbeatInterval: number | null = null;
+    private isLoading: boolean = false;
+    private nodeUpdateQueue: NodeUpdate[] = [];
+    private nodeUpdateTimer: number | null = null;
+    private readonly NODE_UPDATE_DEBOUNCE_MS = 50; // 50ms debounce for node updates
+    
+    // New fields for improved throttling
+    private updateThrottler = new UpdateThrottler(150); // ~6-7fps (was: 50ms = ~20fps) to reduce updates
+    private lastNodePositions: Map<number, Vector3> = new Map(); // Keep track of last sent positions
+    private pendingNodeUpdates: BinaryNodeData[] = [];
+
+
+    private constructor() {
+        // Don't automatically connect - wait for explicit connect() call
+        
+        // Listen for reset events (when graph data is cleared)
+        window.addEventListener('graph-data-reset', () => {
+            this.resetNodeIndices();
+        });
+    }
+    
+    private resetNodeIndices(): void {
+        this.nodeNameToIndexMap.clear();
+        this.nextNodeIndex = 0;
+        logger.info('Node indices reset');
+    }
+
+    public static getInstance(): WebSocketService {
+        if (!WebSocketService.instance) {
+            WebSocketService.instance = new WebSocketService();
+        }
+        return WebSocketService.instance;
+    }
+
+    public connect(): Promise<void> {
+        if (this.connectionState !== ConnectionState.DISCONNECTED) {
+            // Only log this at debug level instead of warn to reduce log spam
+            if (this.connectionState === ConnectionState.CONNECTED) {
+                logger.info('WebSocket already connected');
+                return Promise.resolve();
+            }
+            
+            logger.info(`WebSocket in ${this.connectionState} state, attempting to reconnect...`);
+            
+            // If in FAILED state, reset and try again
+            if (this.connectionState === ConnectionState.FAILED) {
+                this.connectionState = ConnectionState.DISCONNECTED;
+                this.reconnectAttempts = 0;
+                return this.initializeWebSocket();
+            }
+            
+            // If already connecting, return a promise that resolves when connected
+            if (this.connectionState === ConnectionState.CONNECTING) {
+                return new Promise((resolve) => {
+                    let timeoutCounter = 0;
+                    const checkConnection = () => {
+                        if (this.connectionState === ConnectionState.CONNECTED) {
+                            resolve();
+                        } else if (timeoutCounter++ < 100) { // Limit to 10 seconds (100 * 100ms)
+                            setTimeout(checkConnection, 100);
+                        } else {
+                            logger.error('Timed out waiting for connection to establish');
+                            resolve(); // Resolve anyway to prevent hanging
+                        }
+                    };
+                    checkConnection();
+                });
+            }
+            return Promise.resolve();
+        }
+        return this.initializeWebSocket();
+    }
+
+    private async initializeWebSocket(): Promise<void> {
+        if (this.connectionState !== ConnectionState.DISCONNECTED) {
+            return;
+        }
+
+        try {
+            
+            if (!this.url) {
+                throw new Error('No WebSocket URL available');
+            }
+
+            this.connectionState = ConnectionState.CONNECTING;
+            return new Promise((resolve, reject) => {
+                this.ws = new WebSocket(this.url);
+                this.setupWebSocketHandlers();
+                
+                // Add one-time open handler to resolve the promise
+                this.ws!.addEventListener('open', () => resolve(), { once: true });
+                // Add one-time error handler to reject the promise
+                this.ws!.addEventListener('error', (e) => reject(e), { once: true });
+            });
+        } catch (error) {
+            logger.error('Failed to initialize WebSocket:', createErrorMetadata(error));
+            this.handleReconnect();
+            return Promise.reject(error);
+        }
+    }
+
+    private getReconnectDelay(): number {
+        // Exponential backoff with max delay
+        const delay = Math.min(
+            this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts),
+            this.maxReconnectDelay
+        );
+        // Add some jitter
+        return delay + (Math.random() * 500); // Reduced jitter from 1000ms to 500ms
+    }
+
+    private setupWebSocketHandlers(): void {
+        if (!this.ws) return;
+        
+        this.ws.binaryType = 'arraybuffer';
+
+        this.ws.onopen = (): void => {
+            logger.info('WebSocket connected successfully to', createMessageMetadata(this.url));
+            this.connectionState = ConnectionState.CONNECTED;
+            this.reconnectAttempts = 0;
+
+            if (this.connectionStatusHandler) {
+                this.connectionStatusHandler(true);
+                debugLog('Connection status handler notified: connected');
+            }
+            
+            // Set up a heartbeat to keep the connection alive
+            this.setupHeartbeat();
+            
+            // Add delay before sending first message to ensure connection is stable
+            setTimeout(() => {
+                logger.info('WebSocket connected successfully, requesting initial position data');
+
+                // Send request for position updates after connection
+                this.initialDataReceived = false;
+                logger.info('Requesting initial data from server...');
+                
+                this.sendMessage({ type: 'requestInitialData' }); // Matching the server's camelCase type
+
+                // Randomization is disabled by default until client is ready
+                logger.info('WebSocket connection established. Randomization disabled by default.');
+            }, 500); // 500ms delay to ensure connection is stable
+        };
+
+        this.ws.onerror = (event: Event): void => {
+            logger.error('WebSocket error:', createDataMetadata(event));
+            // Don't call handleReconnect here, let onclose handle it
+            // This prevents duplicate reconnection attempts when both error and close events fire
+            // if (this.ws?.readyState === WebSocket.CLOSED) {
+            //     this.handleReconnect();
+            // }
+        };
+
+        this.ws.onclose = (event: CloseEvent): void => {
+            logger.warn('WebSocket closed', createDataMetadata({
+                code: event.code,
+                reason: event.reason || "No reason provided",
+                initialDataReceived: this.initialDataReceived,
+                wasConnected: this.connectionState === ConnectionState.CONNECTED,
+                url: this.url
+            }));
+            
+            // Clear heartbeat on connection close
+            this.clearHeartbeat();
+            
+            if (this.connectionStatusHandler) {
+                this.connectionStatusHandler(false);
+            }
+            
+            this.handleReconnect();
+        };
+
+        this.ws.onmessage = (event: MessageEvent) => {
+            try {
+                if (event.data instanceof ArrayBuffer) {
+                    
+                    this.handleBinaryMessage(event.data);
+                } else if (typeof event.data === 'string') {
+                    try {
+                        const message = JSON.parse(event.data);
+                        
+                        // Handle loading state messages
+                        if (message.type === 'loading') {
+                            this.isLoading = true;
+                            logger.info('WebSocket loading state:', createDataMetadata({
+                                message: message.message
+                            }));
+                            // Notify loading handler if registered
+                            if (this.loadingStatusHandler) {
+                                logger.info('Showing loading indicator: ' + message.message);
+                                this.loadingStatusHandler(true, message.message);
+                            }
+                        } else if (message.type === 'updatesStarted') {
+                            // Clear loading state when updates start
+                            this.isLoading = false;
+                            this.initialDataReceived = true;
+                            logger.info('WebSocket updates started:', createDataMetadata({
+                                timestamp: message.timestamp
+                            }));
+                            // Notify loading handler if registered
+                            if (this.loadingStatusHandler) {
+                                this.loadingStatusHandler(false);
+                            }
+                        } else if (message.type === 'connection_established') {
+                            logger.info('WebSocket message received:', createDataMetadata({
+                                type: message.type,
+                                timestamp: message.timestamp || Date.now()
+                            }));
+                        } else if (debugState.isWebsocketDebugEnabled()) {
+                            logger.debug('WebSocket message received:', message);
+                        }
+                    } catch (error) {
+                        logger.error('Failed to parse WebSocket message:', createErrorMetadata(error));
+                    }
+                }
+            } catch (error) {
+                logger.error('Critical error in message handler:', createErrorMetadata(error));
+            }
+        };
+    }
+
+    // Setup a heartbeat to keep the WebSocket connection alive
+    private setupHeartbeat(): void {
+        this.clearHeartbeat(); // Clear any existing heartbeat
+        this.heartbeatInterval = window.setInterval(() => {
+            // Send a simple ping message to keep the connection alive
+            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
+                try {
+                    this.sendMessage({ type: 'ping', timestamp: Date.now() });
+                    if (debugState.isWebsocketDebugEnabled()) {
+                        logger.debug('Heartbeat ping sent');
+                    }
+                } catch (err) {
+                    logger.error('Failed to send heartbeat ping:', createErrorMetadata(err));
+                }
+            } else if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
+                // If socket is closed but heartbeat still running, attempt reconnect
+                logger.warn('Heartbeat detected closed socket, attempting reconnect');
+                this.handleReconnect();
+            }
+        }, 10000); // Send ping every 10 seconds (changed from 15s to match server)
+    }
+    
+    // Clear heartbeat interval
+    private clearHeartbeat(): void {
+        if (this.heartbeatInterval !== null) {
+            window.clearInterval(this.heartbeatInterval);
+            this.heartbeatInterval = null;
+        }
+    }
+
+    private tryDecompress(buffer: ArrayBuffer): ArrayBuffer {
+        try {
+            const decompressed = pako.inflate(new Uint8Array(buffer));
+            if (decompressed.length < 8 || decompressed.length % 4 !== 0) {
+                return buffer;
+            }
+            return decompressed.buffer;
+        } catch (error) {
+            return buffer;
+        }
+    }
+
+    private compressIfNeeded(buffer: ArrayBuffer): ArrayBuffer {
+        if (buffer.byteLength > COMPRESSION_THRESHOLD) {
+            try {
+                const compressed = pako.deflate(new Uint8Array(buffer));
+                return compressed.buffer;
+            } catch (error) {
+                logger.warn('Compression failed, using original data:', createErrorMetadata(error));
+                return buffer;
+            }
+        }
+        return buffer;
+    }
+
+    private handleBinaryMessage(buffer: ArrayBuffer): void {
+        try {
+            if (buffer.byteLength === 0) {
+                logger.warn('Received empty binary message, ignoring (0 bytes)');
+                return;
+            }
+            
+            const decompressedBuffer = this.tryDecompress(buffer);
+
+            // Check if buffer is empty or too small after decompression
+            if (!decompressedBuffer || decompressedBuffer.byteLength === 0) {
+                logger.error('Empty binary message after decompression');
+                return;
+            }
+
+            // Check if there's enough data for at least one node
+            if (decompressedBuffer.byteLength < BYTES_PER_NODE) {
+                logger.error(`Failed to decode binary message: Data too small to contain any nodes (${decompressedBuffer.byteLength} bytes, need at least ${BYTES_PER_NODE})`);
+                return;
+            }
+            
+            // Throttled debug logging for binary messages
+            debugLog('Binary data processed:', createDataMetadata({ 
+                rawSize: buffer.byteLength, 
+                initialDataReceived: this.initialDataReceived,
+                decompressedSize: decompressedBuffer.byteLength, 
+                nodeCount: Math.floor(decompressedBuffer.byteLength / BYTES_PER_NODE)
+            }));
+            logger.debug(`Received binary update with ${Math.floor(decompressedBuffer.byteLength / BYTES_PER_NODE)} nodes`);
+            
+            const dataView = new DataView(decompressedBuffer);
+            
+            // Calculate how many complete nodes we can read
+            const nodeCount = Math.floor(decompressedBuffer.byteLength / BYTES_PER_NODE);
+            
+            // If there's a remainder, log it but continue processing the complete nodes
+            const remainder = decompressedBuffer.byteLength % BYTES_PER_NODE;
+            if (remainder > 0) {
+                // This shouldn't happen as the server should send complete node data
+                logger.warn(`Binary message has ${remainder} extra bytes that don't form a complete node. ` +
+                          `Processing ${nodeCount} complete nodes.`);
+                if (debugState.isDataDebugEnabled()) {
+                    logger.debug(`Buffer size: ${decompressedBuffer.byteLength}, Node size: ${BYTES_PER_NODE}, Nodes: ${nodeCount}, Remainder: ${remainder}`);
+                }
+            }
+
+            if (nodeCount === 0) {
+                logger.warn('No nodes in binary update - empty message received');
+                return;
+            }
+            
+            // Start reading nodes from the beginning
+            let offset = 0;
+            const nodes: BinaryNodeData[] = [];
+            
+            for (let i = 0; i < nodeCount; i++) {
+                // Read node ID (u16)
+                const id = dataView.getUint16(offset, true);
+                offset += 2;
+
+                // Skip nodes with invalid IDs
+                if (id === 0 || id === 65535 || id > MAX_U16_VALUE) { // 0 and 65535 are often used as sentinel values
+                    if (debugState.isNodeDebugEnabled()) {
+                        logger.debug(`Skipping node with reserved ID: ${id}`);
+                    }
+                    offset += 24; // Skip position and velocity (212 bytes)
+                    continue;
+                }
+                
+                // Create THREE.Vector3 objects directly
+                const position = new Vector3(
+                    dataView.getFloat32(offset, true),     // x
+                    dataView.getFloat32(offset + 4, true), // y
+                    dataView.getFloat32(offset + 8, true)  // z
+                );
+                
+                // Update offset after reading position vector (12 bytes: 34 bytes)
+                offset += 12;
+
+                // Now read velocity with the updated offset
+                const velocity = new Vector3(
+                    dataView.getFloat32(offset, true),      // x
+                    dataView.getFloat32(offset + 4, true),  // y
+                    dataView.getFloat32(offset + 8, true)   // z
+                );
+                
+                // Update offset after reading velocity (12 bytes: 34 bytes)
+                offset += 12;
+
+                // Apply deadband filtering - only include if position has changed significantly
+                const lastPosition = this.lastNodePositions.get(id);
+                let positionChanged = true;
+                
+                if (lastPosition) {
+                    // Calculate squared distance to avoid unnecessary sqrt
+                    const dx = position.x - lastPosition.x;
+                    const dy = position.y - lastPosition.y;
+                    const dz = position.z - lastPosition.z;
+                    const distanceSquared = dx*dx + dy*dy + dz*dz;
+                    
+                    // Only consider position changed if it exceeds our threshold
+                    positionChanged = distanceSquared > (POSITION_DEADBAND * POSITION_DEADBAND);
+                    
+                    if (!positionChanged && Math.random() < 0.001) { // Log occasionally (0.1% chance)
+                        if (debugState.isWebsocketDebugEnabled()) {
+                            logger.debug(`Filtering node ${id} - position change too small: ${Math.sqrt(distanceSquared).toFixed(5)} < ${POSITION_DEADBAND}`);
+                        }
+                        continue; // Skip this position update entirely
+                    }
+                }
+                
+                // Store this position for future comparisons
+                this.lastNodePositions.set(id, position.clone());
+                
+                // Only include the node if position changed or we don't have a previous position
+                if (positionChanged) {
+                    // IMPORTANT: Use the string nodeId that matches the metadata format
+                    // This ensures the position updates will be correctly applied to
+                    // the nodes with matching metadata
+                    nodes.push({ 
+                        id, 
+                        position, velocity });
+                    
+                    // Debug logging for node ID tracking
+                    if (debugState.isNodeDebugEnabled() && Math.random() < 0.01) {
+                        logger.debug(`Processing node ID ${id} from binary update`);
+                    }
+                }
+            }
+
+            // Enhanced logging for node ID tracking - log every 100th update
+            const shouldLogExtras = debugState.isNodeDebugEnabled() && Math.random() < 0.01; // ~1% chance to log per update
+                
+            if (shouldLogExtras) {
+                // Sample a few nodes for debugging
+                const sampleNodes = nodes.slice(0, Math.min(3, nodes.length));
+                if (sampleNodes.length > 0) {
+                    logger.debug('Node binary update sample:', createDataMetadata({
+                        sampleSize: sampleNodes.length,
+                        totalNodes: nodes.length,
+                        nodeInfo: sampleNodes.map(n => ({
+                            id: n.id,
+                            position: { 
+                                x: n.position.x.toFixed(2), 
+                                y: n.position.y.toFixed(2), 
+                                z: n.position.z.toFixed(2) 
+                            }
+                        }))
+                    }));
+                }
+            }
+
+            // Add nodes to pending updates
+            if (nodes.length > 0) {
+                this.pendingNodeUpdates.push(...nodes);
+                
+                // Process updates with throttling
+                if (this.updateThrottler.shouldUpdate()) {
+                    this.processPendingNodeUpdates();
+                } else {
+                    // Schedule processing if not already scheduled
+                    if (this.nodeUpdateTimer === null) {
+                        this.nodeUpdateTimer = window.setTimeout(() => {
+                            this.processPendingNodeUpdates();
+                            this.nodeUpdateTimer = null;
+                        }, this.updateThrottler.getTimeUntilNextUpdate());
+                    }
+                }
+            }
+        } catch (error) {
+            logger.error('Failed to process binary message:', createErrorMetadata(error));
+        }
+    }
+    
+    /**
+     * Process all pending node updates at the throttled rate
+     */
+    private processPendingNodeUpdates(): void {
+        if (this.pendingNodeUpdates.length > 0 && this.binaryMessageCallback) {
+            // Process all pending updates at once
+            try {
+                this.binaryMessageCallback(this.pendingNodeUpdates);
+                
+                // Log processing stats
+                if (debugState.isWebsocketDebugEnabled()) {
+                    logger.debug('Processed node updates:', createDataMetadata({
+                        count: this.pendingNodeUpdates.length,
+                        throttleRate: this.updateThrottler.getRate()
+                    }));
+                }
+                
+                // Clear pending updates
+                this.pendingNodeUpdates = [];
+            } catch (error: any) {
+                logger.error('Error processing node updates:', createErrorMetadata(error));
+            }
+        }
+    }
+
+    private handleReconnect(): void {
+        const wasConnected = this.connectionState === ConnectionState.CONNECTED;
+        
+        // Store current state for logging
+        const prevState = this.connectionState;
+        this.binaryMessageCallback = null;
+        this.connectionState = ConnectionState.DISCONNECTED;
+        
+        logger.info(`WebSocket reconnect triggered (previous state: ${prevState})`);
+        
+        if (this.reconnectTimeout !== null) {
+            window.clearTimeout(this.reconnectTimeout);
+            this.reconnectTimeout = null;
+        }
+        
+        if (this.reconnectAttempts < this._maxReconnectAttempts &&
+            (wasConnected || this.reconnectAttempts === 0)) {
+            
+            this.reconnectAttempts++;
+            const delay = this.getReconnectDelay();
+            
+            this.connectionState = ConnectionState.RECONNECTING;
+            logger.info(`WebSocket reconnecting in ${Math.round(delay/1000)}s (attempt ${this.reconnectAttempts} of ${this._maxReconnectAttempts})`);
+            
+            // Use setTimeout instead of window.setTimeout for more consistent behavior
+            this.reconnectTimeout = window.setTimeout(async () => {
+                this.reconnectTimeout = null;
+                try {
+                    await this.connect();
+                } catch (error) {
+                    logger.error('Reconnection attempt failed:', createErrorMetadata(error));
+                }
+            }, delay);
+        } else {
+            this.handleReconnectFailure();
+        }
+    }
+
+    private handleReconnectFailure(): void {
+        this.connectionState = ConnectionState.FAILED;
+        logger.error('WebSocket reconnection failed after maximum attempts', createDataMetadata({
+            attempts: this.reconnectAttempts,
+            maxAttempts: this._maxReconnectAttempts,
+            url: this.url
+        }));
+        
+        // Update binary protocol status to failed
+        debugState.setBinaryProtocolStatus('failed');
+        
+        if (this.connectionStatusHandler) {
+            this.connectionStatusHandler(false);
+        }
+    }
+
+    public onBinaryMessage(callback: BinaryMessageCallback): void {
+        this.binaryMessageCallback = callback;
+    }
+
+    public getConnectionStatus(): ConnectionState {
+        return this.connectionState;
+    }
+
+    // Enhanced message sending with better error handling
+    public sendMessage(message: any): void {
+        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
+            const serializedMessage = JSON.stringify(message);
+            try {
+                this.ws.send(serializedMessage);
+                
+                // Only log ping messages in debug mode to avoid excessive logging
+                if (message.type !== 'ping' || debugState.isWebsocketDebugEnabled()) {
+                    debugLog(`Sent message type: ${message.type}`);
+                }
+            } catch (error) {
+                logger.error('Error sending message:', createErrorMetadata({
+                    error: error instanceof Error ? error.message : String(error),
+                    messageType: message.type,
+                    connectionState: this.connectionState,
+                    wsReadyState: this.ws.readyState
+                }));
+            }
+        }
+    }
+
+    /**
+     * Enable or disable server-side node position randomization
+     * This should only be called after the initial data loading is complete
+     * @param enabled Whether randomization should be enabled
+     */
+    public enableRandomization(enabled: boolean): void {
+        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
+            if (enabled) {
+                logger.warn('WebSocket not connected, attempting to reconnect before enabling randomization');
+                // Try to reconnect
+                this.connect().then(() => {
+                    // If connection succeeded, try again
+                    if (this.ws?.readyState === WebSocket.OPEN) {
+                        logger.info(`${enabled ? 'Enabling' : 'Disabling'} server-side position randomization after reconnection`);
+                        this.sendMessage({ type: 'enableRandomization', enabled });
+                    }
+                }).catch(e => {
+                    logger.error('Failed to reconnect for randomization:', createErrorMetadata(e));
+                });
+            } else {
+                logger.warn('WebSocket not connected, cannot disable randomization');
+            }
+            return;
+        }
+
+        logger.info(`${enabled ? 'Enabling' : 'Disabling'} server-side position randomization`);
+        this.sendMessage({ type: 'enableRandomization', enabled });
+    }
+    
+    
+    public sendNodeUpdates(updates: NodeUpdate[]): void {
+        // Add detailed logging to see if updates are being sent
+        if (debugState.isWebsocketDebugEnabled()) {
+            logger.debug(`WebSocketService.sendNodeUpdates called with ${updates.length} updates:`, updates);
+        }
+
+        if (debugState.isWebsocketDebugEnabled()) {
+            logger.debug(`Sending ${updates.length} node updates. Binary updates enabled: ${debugState.isBinaryProtocolEnabled()}`);
+        }
+        
+        // Update binary protocol status based on connection state
+        if (debugState.getBinaryProtocolStatus() === 'inactive') {
+            debugState.setBinaryProtocolStatus('pending');
+        }
+        
+        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
+            logger.warn('WebSocket not connected, attempting to reconnect before sending updates');
+            debugState.setBinaryProtocolStatus('pending');
+            
+            // Try to reconnect and then send updates 
+            this.connect().then(() => {
+                // Check if connection succeeded
+                if (this.ws?.readyState === WebSocket.OPEN) {
+                    logger.info('Reconnected successfully, now sending queued node updates');
+                    debugState.setBinaryProtocolStatus('active');
+                    this.nodeUpdateQueue.push(...updates);
+                    this.processNodeUpdateQueue();
+                } else {
+                    logger.warn('WebSocket still not connected after reconnect attempt');
+                    debugState.setBinaryProtocolStatus('failed');
+                }
+            }).catch(e => {
+                logger.error('Failed to reconnect for node updates:', createErrorMetadata(e));
+                debugState.setBinaryProtocolStatus('error');
+            });
+            return;
+        }
+
+        // Pre-validate node IDs before adding to queue
+        const validatedUpdates = updates.filter(update => {
+            const id = parseInt(update.id, 10);
+
+            // Ensure ID is within u16 range (0-65535)
+            if (id > MAX_U16_VALUE) {
+                logger.warn(`Node ID ${id} exceeds maximum u16 value (${MAX_U16_VALUE}), cannot send update`);
+                return false;
+            }
+            
+            // Check for NaN or non-numeric IDs
+            if (isNaN(id) || id < 0 || !Number.isInteger(id)) {
+                // This is likely a metadata name being incorrectly used as a node ID
+                if (debugState.isWebsocketDebugEnabled()) {
+                    logger.debug('Non-numeric node ID detected, will map to numeric index:', createDataMetadata({
+                        id: update.id,
+                        valueType: typeof update.id,
+                        length: typeof update.id === 'string' ? update.id.length : 0
+                    }));
+                }
+                // Don't filter out non-numeric IDs - they will be mapped below
+                return false;
+            }
+            return true;
+        });
+        
+        if (debugState.isWebsocketDebugEnabled()) {
+            logger.debug(`Validated ${validatedUpdates.length}/${updates.length} node updates as numeric IDs`);
+        }
+
+        if (validatedUpdates.length === 0 && updates.length > 0) {
+            // If we have non-numeric node IDs (metadata names), convert them to numeric indices
+            const indexedUpdates = updates.filter(update => {
+                if (!this.nodeNameToIndexMap.has(update.id)) {
+                    // Ensure we don't exceed u16 max value
+                    if (this.nextNodeIndex > MAX_U16_VALUE) {
+                        logger.warn(`Cannot map more node IDs, reached maximum u16 value (${MAX_U16_VALUE})`);
+                        return false;
+                    }
+                    
+                    // Generate a valid u16 index
+                    const nodeIndex = this.nextNodeIndex++;
+                    this.nodeNameToIndexMap.set(update.id, nodeIndex);
+                    logger.info(`Mapped metadata name "${update.id}" to numeric index ${nodeIndex} for binary protocol`);
+                }
+                
+                // Check if this is a randomization operation (large position changes)
+                // If so, bypass the deadband filtering
+                const nodeId = this.nodeNameToIndexMap.get(update.id)!;
+                const lastPosition = this.lastNodePositions.get(nodeId);
+                
+                if (lastPosition) {
+                    // Calculate squared distance manually
+                    const dx = update.position.x - lastPosition.x;
+                    const dy = update.position.y - lastPosition.y;
+                    const dz = update.position.z - lastPosition.z;
+                    const distanceSquared = dx*dx + dy*dy + dz*dz;
+                    
+                    // Check if this is a significant position change (likely from randomization)
+                    const isSignificantChange = distanceSquared > 1.0; // 1.0 is a larger threshold to detect randomization
+                    
+                    // Only apply deadband filtering for small movements, not for randomization
+                    if (!isSignificantChange && distanceSquared < (POSITION_DEADBAND * POSITION_DEADBAND)) {
+                        if (debugState.isWebsocketDebugEnabled() && Math.random() < 0.01) {
+                            logger.debug(`Filtered client update for node ${update.id} - position change too small`);
+                        }
+                        return false; // Filter out this update
+                    }
+                    
+                    if (isSignificantChange && debugState.isWebsocketDebugEnabled()) {
+                        logger.debug(`Detected significant position change for node ${update.id} - likely randomization`);
+                    }
+                }
+                
+                // Use the numeric index for the binary protocol
+                // Keep this update and transform it
+                return true;
+            }).map(update => {
+                const numericId = this.nodeNameToIndexMap.get(update.id)!;
+                return { ...update, id: numericId.toString() }; 
+            });
+                
+            // Add the indexed updates to the queue
+            this.nodeUpdateQueue.push(...indexedUpdates);
+        } else if (validatedUpdates.length > 0) {
+            // Add already-numeric updates to the queue
+            this.nodeUpdateQueue.push(...validatedUpdates);
+        } else {
+            return; // No updates to process
+        }
+        
+        
+        // Debounce updates to prevent flooding the server
+        if (this.nodeUpdateTimer === null) {
+            this.nodeUpdateTimer = window.setTimeout(() => {
+                this.processNodeUpdateQueue();
+                this.nodeUpdateTimer = null;
+            }, this.NODE_UPDATE_DEBOUNCE_MS);
+        }
+    }
+    
+    private processNodeUpdateQueue(): void {
+        if (!this.ws || this.ws.readyState !== WebSocket.OPEN || this.nodeUpdateQueue.length === 0) {
+            if (this.nodeUpdateQueue.length > 0) {
+                logger.warn(`Discarding ${this.nodeUpdateQueue.length} updates because WebSocket is not open (state: ${this.ws?.readyState})`);
+                debugState.setBinaryProtocolStatus('error');
+            }
+            this.nodeUpdateQueue = [];
+            return;
+        }
+        
+        // Update binary protocol status to active since we're about to send updates
+        if (debugState.getBinaryProtocolStatus() === 'pending') {
+            debugState.setBinaryProtocolStatus('active');
+        }
+        
+        if (debugState.isWebsocketDebugEnabled()) {
+            logger.debug(`Processing node update queue with ${this.nodeUpdateQueue.length} updates`);
+        }
+        
+        // Get the most recent updates for each node ID (to avoid sending outdated positions)
+        const latestUpdates = new Map<string, NodeUpdate>();
+        
+        if (debugState.isWebsocketDebugEnabled()) {
+            logger.debug('Node update queue contents:', this.nodeUpdateQueue);
+        }
+        
+        for (const update of this.nodeUpdateQueue) {
+            latestUpdates.set(update.id, update);
+        }
+        
+        // Convert to array - allow more nodes per update for randomization operations
+        let updates = Array.from(latestUpdates.values());
+        const originalCount = updates.length;
+        
+        // For randomization, we want to send more nodes at once
+        // Check if this is likely a randomization operation (many nodes at once)
+        const isLikelyRandomization = updates.length > 5;
+        const maxNodesPerUpdate = isLikelyRandomization ? 10 : 2;
+        
+        if (updates.length > maxNodesPerUpdate) {
+            if (debugState.isWebsocketDebugEnabled()) {
+                logger.debug(`Many nodes in update (${updates.length}), limiting to ${maxNodesPerUpdate} nodes per batch`);
+            }
+            updates = updates.slice(0, maxNodesPerUpdate);
+        }
+        
+        // Clear the queue
+        this.nodeUpdateQueue = [];
+        
+        if (debugState.isWebsocketDebugEnabled()) {
+            logger.debug(`Processing ${updates.length}/${originalCount} node updates`);
+            if (updates.length > 0) {
+                logger.debug('Sample node update:', updates[0]);
+            }
+        }
+
+        // Calculate buffer size based on node count (26 bytes per node)
+        const bufferSize = updates.length * BYTES_PER_NODE;
+        const buffer = new ArrayBuffer(bufferSize);
+        const dataView = new DataView(buffer);
+        
+        // Start writing node data from the beginning
+        let offset = 0;
+
+        updates.forEach(update => {
+            const id = parseInt(update.id, 10); 
+            if (isNaN(id)) {
+                logger.warn('Invalid node ID in queue:', createDataMetadata({ 
+                    nodeId: update.id,
+                    type: typeof update.id,
+                    length: typeof update.id === 'string' ? update.id.length : 0,
+                    isPossibleMetadataName: typeof update.id === 'string' && 
+                                          update.id.length > 10 && !/^\d+$/.test(update.id)
+                }));
+                return; // Skip this update
+            }
+            // Write node ID as u16 
+            dataView.setUint16(offset, id, true);
+            offset += 2;
+
+            // Validate position using our new utility function
+            const position = validateAndFixVector3(update.position, 1000);
+            
+            // Write position
+            dataView.setFloat32(offset, position.x, true);
+            dataView.setFloat32(offset + 4, position.y, true);
+            dataView.setFloat32(offset + 8, position.z, true);
+            offset += 12;
+
+            // Validate and clamp velocity (default to zero vector if not provided)
+            const rawVelocity = update.velocity ?? new Vector3(0, 0, 0);
+            const velocity = validateAndFixVector3(rawVelocity, 0.05);
+            
+            // Write velocity
+            dataView.setFloat32(offset, velocity.x, true);
+            dataView.setFloat32(offset + 4, velocity.y, true);
+            dataView.setFloat32(offset + 8, velocity.z, true);
+            offset += 12;
+        });
+
+        const finalBuffer = this.compressIfNeeded(buffer);
+        this.ws.send(finalBuffer);
+        
+        if (debugState.isWebsocketDebugEnabled()) {
+            logger.debug(`Sent binary message with ${updates.length} nodes (${finalBuffer.byteLength} bytes)`);
+        }
+    }
+
+    public onConnectionStatusChange(handler: (status: boolean) => void): void {
+        this.connectionStatusHandler = handler;
+        if (this.connectionState === ConnectionState.CONNECTED && handler) {
+            handler(true);
+        }
+    }
+
+    /**
+     * Register a handler for loading status changes
+     * @param handler Callback function that receives loading state and optional message
+     */
+    public onLoadingStatusChange(handler: (isLoading: boolean, message?: string) => void): void {
+        this.loadingStatusHandler = handler;
+        
+        // Immediately notify with current state if already loading
+        if (this.isLoading && handler) {
+            handler(true);
+        }
+    }
+
+    public dispose(): void {
+        if (this.reconnectTimeout !== null) {
+            window.clearTimeout(this.reconnectTimeout);
+            this.reconnectTimeout = null;
+            logger.debug('Cleared reconnect timeout during disposal');
+        }
+        
+        if (this.nodeUpdateTimer !== null) {
+            window.clearTimeout(this.nodeUpdateTimer);
+            this.nodeUpdateTimer = null;
+            this.nodeUpdateQueue = [];
+            logger.debug('Cleared node update timer during disposal');
+        }
+        
+        if (this.heartbeatInterval !== null) {
+            window.clearInterval(this.heartbeatInterval);
+            this.heartbeatInterval = null;
+            logger.debug('Cleared heartbeat interval during disposal');
+        }
+
+        // Clear position tracking data to prevent memory leaks
+        this.lastNodePositions.clear();
+        this.pendingNodeUpdates = [];
+        if (this.ws) {
+            logger.info('Closing WebSocket connection during disposal');
+            this.ws.close();
+            this.ws = null;
+        }
+
+        logger.info('WebSocket service disposal complete');
+        
+        this.binaryMessageCallback = null;
+        this.connectionStatusHandler = null;
+        this.connectionState = ConnectionState.DISCONNECTED;
+        WebSocketService.instance = null;
+    }
+
+    public close(): void {
+        if (this.ws) {
+            this.ws.close();
+            this.ws = null;
+        }
+    }
+    
+    /**
+     * Send raw binary data through the WebSocket connection
+     * This method is used by the GraphDataManager adapter
+     * @param data The ArrayBuffer to send
+     * @returns boolean indicating if the data was sent successfully
+     */
+    public sendRawBinaryData(data: ArrayBuffer): boolean {
+        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
+            logger.warn('WebSocket not connected, cannot send raw binary data');
+            return false;
+        }
+        
+        try {
+            const finalData = this.compressIfNeeded(data);
+            this.ws.send(finalData);
+            return true;
+        } catch (error) {
+            logger.error('Error sending raw binary data:', createErrorMetadata(error));
+            return false;
+        }
+    }
+}
\ No newline at end of file
diff --git a/client/xr/handInteraction.ts b/client/xr/handInteraction.ts
new file mode 100644
index 00000000..16189a39
--- /dev/null
+++ b/client/xr/handInteraction.ts
@@ -0,0 +1,136 @@
+import { Vector3 } from 'three';
+import { XRHandWithHaptics } from '../types/xr';
+import { NodeManagerFacade } from '../rendering/node/NodeManagerFacade';
+import { NodeInteractionManager } from '../rendering/node/interaction/NodeInteractionManager';
+import { createLogger } from '../core/logger';
+import { SettingsStore } from '../state/SettingsStore';
+import { platformManager } from '../platform/platformManager';
+
+const logger = createLogger('HandInteraction');
+
+export class HandInteractionManager {
+    private static instance: HandInteractionManager;
+    private lastPinchState: boolean = false;
+    private settingsStore: SettingsStore;
+    private nodeManager?: NodeManagerFacade;
+    private interactionManager?: NodeInteractionManager;
+    private isInitialized: boolean = false;
+    private initializationTime: number = 0;
+    private readonly INITIALIZATION_DELAY_MS = 3000; // 3 second delay before enabling interactions
+    private sessionStateListener: ((state: string) => void) | null = null;
+
+    private constructor() {
+        this.settingsStore = SettingsStore.getInstance();
+        this.initializationTime = Date.now();
+        this.setupSessionStateListener();
+    }
+
+    public static getInstance(): HandInteractionManager {
+        if (!HandInteractionManager.instance) {
+            HandInteractionManager.instance = new HandInteractionManager();
+        }
+        return HandInteractionManager.instance;
+    }
+
+    private setupSessionStateListener(): void {
+        // Listen for session state changes to reset interaction state
+        this.sessionStateListener = (state: string) => {
+            if (state === 'starting') {
+                // Reset initialization time when starting a new session
+                this.initializationTime = Date.now();
+                this.isInitialized = false;
+            }
+        };
+        platformManager.on('xrsessionstatechange', this.sessionStateListener);
+    }
+
+    public setNodeManager(nodeManager: NodeManagerFacade): void {
+        this.nodeManager = nodeManager;
+        this.interactionManager = NodeInteractionManager.getInstance(nodeManager.getInstancedMesh());
+        
+        // Mark as initialized but still respect the delay
+        setTimeout(() => {
+            this.isInitialized = true;
+            logger.info(`Hand interaction enabled after ${this.INITIALIZATION_DELAY_MS}ms delay`);
+        }, this.INITIALIZATION_DELAY_MS);
+    }
+
+    public processHandInput(hand: XRHandWithHaptics): void {
+        // Don't process input during initialization period
+        if (!this.isInitialized || !this.nodeManager || !this.interactionManager) {
+            return;
+        }
+        
+        // Check if enough time has passed since initialization
+        const timeSinceInit = Date.now() - this.initializationTime;
+        if (timeSinceInit < this.INITIALIZATION_DELAY_MS) {
+            return;
+        }
+
+        const thumbTip = hand.hand.joints['thumb-tip'];
+        const indexTip = hand.hand.joints['index-finger-tip'];
+
+        if (!thumbTip || !indexTip) return;
+
+        const distance = thumbTip.position.distanceTo(indexTip.position);
+        const pinchStrength = Math.max(0, 1 - distance / 0.05); // 5cm max distance
+        hand.pinchStrength = pinchStrength;
+
+        // Detect pinch gesture
+        const isPinching = pinchStrength > 0.9; // 90% threshold for pinch
+        if (isPinching !== this.lastPinchState) {
+            this.lastPinchState = isPinching;
+            if (isPinching) {
+                this.handlePinchGesture(indexTip.position);
+            }
+        }
+
+        // Pass hand data to interaction manager
+        this.interactionManager.handleHandInteraction(hand);
+    }
+
+    private handlePinchGesture(position: Vector3): void {
+        if (!this.nodeManager || !this.interactionManager) return;
+
+        // Get the instance mesh
+        const instanceMesh = this.nodeManager.getInstancedMesh();
+        if (!instanceMesh) return;
+
+        // Get the intersected node index
+        const intersectedNodeIndex = this.interactionManager.getIntersectedNodeIndex(position);
+        if (intersectedNodeIndex === -1) return;
+
+        // Get node ID from instance index
+        const nodeId = this.nodeManager.getNodeId(intersectedNodeIndex);
+        if (!nodeId) return;
+
+        logger.debug(`Pinch gesture detected on node ${nodeId}`);
+        
+        // Check if we're still in the initialization phase
+        if (!this.settingsStore.isInitialized()) {
+            logger.warn('Ignoring node interaction - settings not fully initialized');
+            return;
+        }
+        
+        // Send node position update through the interaction manager
+        this.interactionManager.sendNodeUpdates(nodeId, position);
+
+        // Update local node position
+        this.nodeManager.updateNodePositions([{
+            id: nodeId,
+            data: { position: position.clone(), velocity: new Vector3(0, 0, 0) }
+        }]);
+    }
+
+    public dispose(): void {
+        this.lastPinchState = false;
+        this.nodeManager = undefined;
+        this.isInitialized = false;
+        this.interactionManager = undefined;
+        
+        // Remove session state listener
+        if (this.sessionStateListener) {
+            platformManager.removeAllListeners();
+        }
+    }
+}
\ No newline at end of file
diff --git a/client/xr/xrInitializer.ts b/client/xr/xrInitializer.ts
new file mode 100644
index 00000000..05d33630
--- /dev/null
+++ b/client/xr/xrInitializer.ts
@@ -0,0 +1,154 @@
+import { platformManager } from '../platform/platformManager';
+import { XRSessionManager } from './xrSessionManager';
+import { createLogger, createErrorMetadata, createMessageMetadata } from '../core/logger';
+import { XRSessionState } from '../types/xr';
+
+const logger = createLogger('XRInitializer');
+
+export class XRInitializer {
+    private static instance: XRInitializer | null = null;
+    private xrButton: HTMLButtonElement;
+    private xrSessionManager: XRSessionManager;
+    private buttonDebounceTimeout: number | null = null;
+
+    private constructor(xrSessionManager: XRSessionManager) {
+        this.xrSessionManager = xrSessionManager;
+        this.xrButton = document.getElementById('xr-button') as HTMLButtonElement;
+        if (!this.xrButton) {
+            throw new Error('XR button not found');
+        }
+        this.setupEventListeners();
+        this.setupSessionStateListener();
+    }
+
+    public static getInstance(xrSessionManager: XRSessionManager): XRInitializer {
+        if (!XRInitializer.instance) {
+            XRInitializer.instance = new XRInitializer(xrSessionManager);
+        }
+        return XRInitializer.instance;
+    }
+
+    private isProcessingClick = false;
+    private keyboardShortcutEnabled = !platformManager.isQuest(); // Disable for Quest
+
+    private setupSessionStateListener(): void {
+        // Listen for XR session state changes
+        platformManager.on('xrsessionstatechange', (state: XRSessionState) => {
+            logger.info('XR session state changed:', createMessageMetadata(state));
+            
+            // Update button state based on session state
+            if (state === 'inactive') {
+                this.xrButton.classList.remove('hidden');
+                this.xrButton.disabled = false;
+                this.xrButton.textContent = platformManager.isQuest() ? 'Enter AR' : 'Enter VR';
+            } else {
+                this.xrButton.disabled = state === 'cooldown';
+                this.xrButton.textContent = state === 'active' ? 'Exit AR' : 'Please wait...';
+            }
+        });
+    }
+
+    private setupEventListeners(): void {
+        // Button click handler with debounce
+        this.xrButton.addEventListener('click', async () => {
+            if (this.isProcessingClick) return;
+            this.isProcessingClick = true;
+            
+            try {
+                await this.onXRButtonClick();
+            } finally {
+                // Reset after a short delay to prevent rapid clicks
+                setTimeout(() => {
+                    this.isProcessingClick = false;
+                }, 1500); // Increased debounce time
+                
+                // Update button state
+                this.xrButton.disabled = true;
+                this.xrButton.textContent = 'Please wait...';
+            }
+        });
+
+        // Keyboard shortcut only for non-Quest devices
+        if (this.keyboardShortcutEnabled) {
+            document.addEventListener('keydown', (event) => {
+                if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'a') {
+                    this.onXRButtonClick();
+                }
+            });
+        }
+
+        // Update button visibility based on XR session state
+        this.xrSessionManager.setSessionCallbacks(
+            () => this.updateButtonForActiveSession(),      // onStart
+            () => this.updateButtonForInactiveSession(),    // onEnd
+            () => {}                                        // onFrame
+        );
+
+        // Initial button state
+        this.updateButtonState();
+    }
+
+    private updateButtonForActiveSession(): void {
+        this.xrButton.classList.remove('hidden');
+        this.xrButton.disabled = false;
+        this.xrButton.textContent = 'Exit AR';
+    }
+
+    private updateButtonForInactiveSession(): void {
+        // Clear any existing timeout
+        if (this.buttonDebounceTimeout !== null) {
+            clearTimeout(this.buttonDebounceTimeout);
+        }
+        
+        // Set button to disabled with "Please wait..." text during cooldown
+        this.xrButton.disabled = platformManager.xrSessionState === 'cooldown';
+    }
+
+    private async updateButtonState(): Promise<void> {
+        const isQuest = platformManager.isQuest();
+        const xrSupported = platformManager.isXRSupported();
+
+        if (!xrSupported) {
+            this.xrButton.style.display = 'none';
+            return;
+        }
+
+        if (isQuest) {
+            this.xrButton.textContent = 'Enter AR';
+            this.xrButton.disabled = platformManager.xrSessionState !== 'inactive';
+            this.xrButton.classList.remove('hidden');
+        } else {
+            this.xrButton.textContent = 'Enter VR';
+            this.xrButton.disabled = platformManager.xrSessionState !== 'inactive';
+            this.xrButton.classList.remove('hidden');
+        }
+    }
+
+    private async onXRButtonClick(): Promise<void> {
+        try {
+            if (this.xrSessionManager.isXRPresenting()) {
+                // If we're already in a session, end it
+                logger.info('Ending XR session');
+                this.xrButton.disabled = true;
+                this.xrButton.textContent = 'Exiting...';
+                
+                // End the session
+                await this.xrSessionManager.endXRSession();
+            } else {
+                await this.xrSessionManager.initXRSession();
+            }
+        } catch (error) {
+            logger.error('Failed to toggle XR session:', createErrorMetadata(error));
+        }
+    }
+
+    public dispose(): void {
+        // Clean up timeouts
+        if (this.buttonDebounceTimeout !== null) {
+            clearTimeout(this.buttonDebounceTimeout);
+            this.buttonDebounceTimeout = null;
+        }
+        
+        XRInitializer.instance = null;
+    }
+}
\ No newline at end of file
diff --git a/client/xr/xrInteraction.ts b/client/xr/xrInteraction.ts
new file mode 100644
index 00000000..49d04550
--- /dev/null
+++ b/client/xr/xrInteraction.ts
@@ -0,0 +1,140 @@
+import { XRSessionManager } from './xrSessionManager';
+import { SettingsStore } from '../state/SettingsStore';
+import { createLogger, createErrorMetadata } from '../core/logger';
+import { WebSocketService } from '../websocket/websocketService';
+import { XRSettings } from '../types/settings/xr';
+import { platformManager } from '../platform/platformManager';
+import * as THREE from 'three';
+
+const logger = createLogger('XRInteraction');
+
+export class XRInteraction {
+    private static instance: XRInteraction | null = null;
+    private readonly settingsStore: SettingsStore;
+    private updateBatch: Map<string, THREE.Vector3> = new Map();
+    private batchUpdateTimeout: number | null = null;
+    private settingsUnsubscribers: Array<() => void> = [];
+    private interactionEnabled: boolean = false;
+    private websocketService: WebSocketService;
+    private sessionStateListener: ((state: string) => void) | null = null;
+
+    private xrManager: XRSessionManager;
+    private constructor(xrManager: XRSessionManager) {
+        this.xrManager = xrManager;
+        this.settingsStore = SettingsStore.getInstance();
+        this.websocketService = WebSocketService.getInstance();
+        this.initializeSettings();
+        this.setupSessionStateListener();
+        
+        // Only auto-enter AR if explicitly enabled
+        setTimeout(() => {
+            this.initializeXRSession();
+        }, 1000);
+    }
+    
+    private setupSessionStateListener(): void {
+        // Listen for session state changes to reset interaction state
+        this.sessionStateListener = (state: string) => {
+            if (state === 'ending' || state === 'cooldown') {
+                this.clearHandState();
+            }
+        };
+        platformManager.on('xrsessionstatechange', this.sessionStateListener);
+    }
+
+    private async initializeXRSession(): Promise<void> {
+        try {
+            const settings = this.settingsStore.get('xr') as XRSettings;
+            if (platformManager.isQuest() && settings?.autoEnterAR && platformManager.xrSessionState === 'inactive') {
+                await this.xrManager.initXRSession();
+            }
+        } catch (error) {
+            logger.error('Failed to initialize XR session:', createErrorMetadata(error));
+        }
+    }
+
+    private initializeSettings(): void {
+        try {
+            this.setupSettingsSubscription();
+        } catch (error) {
+            logger.error('Failed to setup settings subscription:', createErrorMetadata(error));
+        }
+    }
+
+    public static getInstance(xrManager: XRSessionManager): XRInteraction {
+        if (!XRInteraction.instance) {
+            XRInteraction.instance = new XRInteraction(xrManager);
+        }
+        return XRInteraction.instance;
+    }
+
+    private setupSettingsSubscription(): void {
+        // Clear any existing subscriptions
+        this.settingsUnsubscribers.forEach(unsub => unsub());
+        this.settingsUnsubscribers = [];
+
+        // Subscribe to XR interaction enabled state
+        let unsubscriber: (() => void) | undefined;
+        this.settingsStore.subscribe('xr.interaction.enabled', (value) => {
+            this.interactionEnabled = typeof value === 'boolean' ? value : value === 'true';
+            if (!this.interactionEnabled) {
+                this.clearHandState();
+            }
+        }).then(unsub => {
+            unsubscriber = unsub;
+            if (unsubscriber) {
+                this.settingsUnsubscribers.push(unsubscriber);
+            }
+        });
+    }
+
+    private clearHandState(): void {
+        this.updateBatch.clear();
+        if (this.batchUpdateTimeout) {
+            clearTimeout(this.batchUpdateTimeout);
+            this.batchUpdateTimeout = null;
+        }
+    }
+
+    private scheduleFlush(): void {
+        if (this.batchUpdateTimeout !== null) return;
+        
+        this.batchUpdateTimeout = requestAnimationFrame(() => {
+            this.flushPositionUpdates();
+            this.batchUpdateTimeout = null;
+        });
+    }
+
+    private flushPositionUpdates(): void {
+        if (this.updateBatch.size === 0) return;
+
+        const updates = Array.from(this.updateBatch.entries()).map(([id, position]) => ({
+            id,
+            position: position.clone()
+        }));
+
+        this.websocketService.sendNodeUpdates(updates);
+        this.updateBatch.clear();
+    }
+
+    public update(): void {
+        if (!this.interactionEnabled) return;
+        this.scheduleFlush();
+    }
+
+    public dispose(): void {
+        // Clear subscriptions
+        this.settingsUnsubscribers.forEach(unsub => unsub());
+        this.settingsUnsubscribers = [];
+        
+        // Remove session state listener
+        if (this.sessionStateListener) {
+            platformManager.removeAllListeners();
+        }
+
+        // Flush any pending updates
+        this.flushPositionUpdates();
+
+        XRInteraction.instance = null;
+    }
+}
diff --git a/client/xr/xrSessionManager.ts b/client/xr/xrSessionManager.ts
new file mode 100644
index 00000000..d27ba718
--- /dev/null
+++ b/client/xr/xrSessionManager.ts
@@ -0,0 +1,601 @@
+import {
+    Group,
+    GridHelper,
+    PlaneGeometry,
+    MeshPhongMaterial,
+    Mesh,
+    RingGeometry,
+    MeshBasicMaterial,
+    DirectionalLight,
+    SphereGeometry,
+    Color,
+    DoubleSide
+} from 'three';
+import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory';
+import { createLogger } from '../core/utils';
+import { platformManager } from '../platform/platformManager';
+import { SceneManager } from '../rendering/scene';
+import { BACKGROUND_COLOR } from '../core/constants';
+import { debugState } from '../core/debugState';
+import { NodeManagerFacade } from '../rendering/node/NodeManagerFacade';
+import { MaterialFactory } from '../rendering/factories/MaterialFactory';
+import { ModularControlPanel } from '../ui/ModularControlPanel';
+import { SettingsStore } from '../state/SettingsStore';
+import { Settings } from '../types/settings/base';
+import { XRSettings } from '../types/settings/xr';
+const logger = createLogger('XRSessionManager');
+
+export class XRSessionManager {
+    private static instance: XRSessionManager | null = null;
+    private readonly sceneManager: SceneManager;
+    private readonly settingsStore: SettingsStore;
+    private readonly nodeManager: NodeManagerFacade;
+    private session: XRSession | null = null;
+    /* @ts-ignore - Used in XR session lifecycle */
+    private referenceSpace: XRReferenceSpace | null = null;
+    private isPresenting: boolean = false;
+    private isCleaningUp: boolean = false;
+    private settingsUnsubscribe: (() => void) | null = null;
+    private currentSettings: XRSettings;
+    /* @ts-ignore - Used in XR session lifecycle */
+    private hitTestSourceRequested = false;
+    /* @ts-ignore - Used in XR session lifecycle */
+    private xrAnimationFrameCallback: ((frame: XRFrame) => void) | null = null;
+
+    // XR specific objects
+    private cameraRig: Group;
+    private arGroup: Group; // Group for AR environment elements (grid, ground plane, etc.)
+    private arGraphGroup: Group; // Separate group for graph nodes in AR
+    private arUIGroup: Group; // Group for UI elements in AR
+    private controllers: Group[];
+    private controllerGrips: Group[];
+    private controllerModelFactory: XRControllerModelFactory;
+
+    // AR specific objects
+    private gridHelper: GridHelper;
+    private groundPlane: Mesh;
+    private hitTestMarker: Mesh;
+    private arLight: DirectionalLight;
+    private hitTestSource: XRHitTestSource | null = null;
+
+    // Event handlers
+    private xrSessionStartCallback: (() => void) | null = null;
+    private xrSessionEndCallback: (() => void) | null = null;
+    private controllerAddedCallback: ((controller: Group) => void) | null = null;
+    private controllerRemovedCallback: ((controller: Group) => void) | null = null;
+
+    private constructor(sceneManager: SceneManager) {
+        this.sceneManager = sceneManager;
+        this.settingsStore = SettingsStore.getInstance();
+        const settings = this.settingsStore.get('') as Settings;
+        const materialFactory = MaterialFactory.getInstance();
+        this.nodeManager = NodeManagerFacade.getInstance(
+            sceneManager.getScene(),
+            sceneManager.getCamera(),
+            materialFactory.getNodeMaterial(settings)
+        );
+        // Initialize with current settings
+        this.currentSettings = this.settingsStore.get('xr') as XRSettings;
+        
+        // Set up settings subscription
+        this.setupSettingsSubscription();
+        
+        // Initialize XR objects
+        this.cameraRig = new Group();
+        this.arGroup = new Group(); // Group for AR elements
+        this.arGraphGroup = new Group(); // Group for graph nodes in AR
+        this.arUIGroup = new Group(); // Group for UI elements in AR
+        this.controllers = [new Group(), new Group()];
+        this.controllerGrips = [new Group(), new Group()];
+        this.controllerModelFactory = new XRControllerModelFactory();
+
+        // Set up AR group hierarchy
+        this.arGroup.add(this.arGraphGroup);
+        this.arGroup.add(this.arUIGroup);
+
+        // Initialize AR objects
+        this.gridHelper = this.createGridHelper();
+        this.groundPlane = this.createGroundPlane();
+        this.hitTestMarker = this.createHitTestMarker();
+        this.arLight = this.createARLight();
+
+        // Explicitly ensure ground plane is not visible by default
+        this.groundPlane.visible = false;
+
+        this.setupXRObjects();
+    }
+
+    private async setupSettingsSubscription(): Promise<void> {
+        // Subscribe to XR settings changes
+        this.settingsUnsubscribe = await this.settingsStore.subscribe('xr', () => {
+            this.currentSettings = this.settingsStore.get('xr') as XRSettings;
+            this.applyXRSettings();
+        });
+    }
+
+    private createGridHelper(): GridHelper {
+        const grid = new GridHelper(0.5, 5, 0x808080, 0x808080); // 0.5 meter grid with 5x5 divisions
+        grid.material.transparent = true;
+        grid.material.opacity = 0.2; // Further reduced opacity
+        grid.position.y = -0.01; // Slightly below ground to avoid z-fighting
+        grid.visible = false; // Start hidden until AR session begins
+        grid.layers.enable(0); // Enable default layer
+        grid.layers.enable(1); // Enable AR layer
+        return grid;
+    }
+
+    private createGroundPlane(): Mesh {
+        const geometry = new PlaneGeometry(0.5, 0.5); // 0.5x0.5 meter plane
+        const material = new MeshPhongMaterial({
+            color: 0x808080, // Medium gray color
+            transparent: true,
+            opacity: 0.1, // More transparent to avoid visual interference
+            side: DoubleSide,
+            depthWrite: false, // Prevent depth writing to avoid z-fighting
+            depthTest: false // Disable depth testing to prevent occlusion of other elements
+        });
+        
+        const plane = new Mesh(geometry, material);
+        plane.rotateX(-Math.PI / 2);
+        plane.position.y = -0.015; // Slightly below grid but not too far
+        plane.visible = false; // Start hidden until AR session begins
+        plane.layers.enable(0); // Enable default layer
+        plane.layers.enable(1); // Enable AR layer
+        return plane;
+    }
+
+    private createHitTestMarker(): Mesh {
+        const geometry = new RingGeometry(0.15, 0.2, 32);
+        const material = new MeshBasicMaterial({
+            color: 0xffffff,
+            transparent: true,
+            opacity: 0.8,
+            side: DoubleSide
+        });
+        const marker = new Mesh(geometry, material);
+        marker.rotateX(-Math.PI / 2);
+        marker.visible = false;
+        marker.layers.enable(0); // Enable default layer
+        marker.layers.enable(1); // Enable AR layer
+        return marker;
+    }
+
+    private createARLight(): DirectionalLight {
+        const light = new DirectionalLight(0xffffff, 1);
+        light.position.set(1, 1, 1);
+        light.layers.enable(0); // Enable default layer
+        light.layers.enable(1); // Enable AR layer
+        return light;
+    }
+
+    private setupXRObjects(): void {
+        const scene = this.sceneManager.getScene();
+        
+        // Reset and verify initial scales
+        this.cameraRig.scale.setScalar(1);
+        this.arGroup.scale.setScalar(1);
+        this.arGraphGroup.scale.setScalar(1);
+        if (debugState.isEnabled() && platformManager.isQuest()) {
+            logger.info('Initial scales:', { cameraRig: this.cameraRig.scale.x, arGroup: this.arGroup.scale.x, arGraphGroup: this.arGraphGroup.scale.x });
+        }
+        
+        // Add camera rig to scene
+        scene.add(this.cameraRig);
+
+        // Add AR group to camera rig
+        this.cameraRig.add(this.arGroup);
+
+        // Add AR objects to AR group
+        this.arGroup.add(this.gridHelper);
+        this.arGroup.add(this.groundPlane);
+        this.arGroup.add(this.hitTestMarker);
+        this.arGroup.add(this.arLight);
+        this.arGroup.add(this.arGraphGroup);
+
+        // Setup controllers
+        this.controllers.forEach((_controller: Group, index: number) => {
+            this.setupController(index);
+        });
+
+        // Setup controller grips
+        this.controllerGrips.forEach((grip: Group) => {
+            this.setupControllerGrip(grip);
+        });
+    }
+
+    private setupController(index: number): void {
+        const controller = this.controllers[index];
+        const controllerGrip = this.controllerGrips[index];
+
+        // Store event handlers as properties for proper cleanup
+        const onControllerConnected = (event: any) => {
+            const inputSource = event.data;
+            controller.userData.inputSource = inputSource;
+            const controllerModel = this.buildController(inputSource);
+            controller.add(controllerModel);
+            this.notifyControllerAdded(controller);
+        };
+
+        const onControllerDisconnected = () => {
+            controller.userData.inputSource = null;
+            controller.remove(...controller.children);
+            this.notifyControllerRemoved(controller);
+        };
+
+        // Store handlers in userData for cleanup
+        controller.userData.eventHandlers = {
+            connected: onControllerConnected,
+            disconnected: onControllerDisconnected
+        };
+
+        controller.addEventListener('connected', onControllerConnected);
+        controller.addEventListener('disconnected', onControllerDisconnected);
+
+        this.cameraRig.add(controller);
+        this.cameraRig.add(controllerGrip);
+    }
+
+    private setupControllerGrip(grip: Group): void {
+        const controllerModel = this.controllerModelFactory.createControllerModel(grip);
+        grip.add(controllerModel);
+    }
+
+    private buildController(_inputSource: XRInputSource): Group {
+        const controller = new Group();
+        const geometry = new SphereGeometry(0.1, 16, 16);
+        const material = new MeshBasicMaterial({ color: 0xffffff });
+        const sphere = new Mesh(geometry, material);
+        controller.add(sphere);
+        return controller;
+    }
+
+    public static getInstance(sceneManager: SceneManager): XRSessionManager {
+        if (!XRSessionManager.instance) {
+            XRSessionManager.instance = new XRSessionManager(sceneManager);
+        }
+        return XRSessionManager.instance;
+    }
+
+    public setSessionCallbacks(
+        onStart: () => void,
+        onEnd: () => void,
+        onFrame: (frame: XRFrame) => void
+    ): void {
+        this.xrSessionStartCallback = onStart;
+        this.xrSessionEndCallback = onEnd;
+        this.xrAnimationFrameCallback = onFrame;
+    }
+
+    public isXRPresenting(): boolean {
+        return this.isPresenting;
+    }
+
+    public async initXRSession(): Promise<void> {
+        if (this.isPresenting) {
+            if (debugState.isEnabled()) {
+                logger.warn('XR session already active');
+            }
+            return;
+        }
+        
+        if (platformManager.xrSessionState !== 'inactive') {
+            if (debugState.isEnabled()) {
+                logger.warn('XR session already active');
+            }
+            return;
+        }
+
+        if (!platformManager.getCapabilities().xrSupported || !navigator.xr) {
+            throw new Error('XR not supported on this platform');
+        }
+
+        try {
+            // Check if session mode is supported
+            const mode = platformManager.isQuest() ? 'immersive-ar' : 'immersive-vr';
+            const isSupported = await navigator.xr.isSessionSupported(mode);
+            
+            if (!isSupported) {
+                throw new Error(`${mode} not supported on this device`);
+            }
+            
+            // Configure features based on mode and platform
+            const requiredFeatures = ['local-floor'];
+            const optionalFeatures = ['hand-tracking', 'layers'];
+            
+            // Add mode-specific features for Quest
+            if (platformManager.isQuest()) {
+                requiredFeatures.push('hit-test');
+                optionalFeatures.push(
+                    'light-estimation',
+                    'plane-detection',
+                    'anchors',
+                    'depth-sensing',
+                    'dom-overlay'
+                );
+            }
+            
+            // Request session with configured features
+            const sessionInit: XRSessionInit = {
+                requiredFeatures,
+                optionalFeatures,
+                domOverlay: platformManager.isQuest() ? { root: document.body } : undefined
+            };
+            
+            if (debugState.isEnabled()) {
+                logger.info('Requesting XR session with config:', {
+                    mode,
+                    features: sessionInit
+                });
+            }
+            
+            const session = await navigator.xr.requestSession(mode, sessionInit);
+            platformManager.xrSessionState = 'active';
+
+            if (!session) {
+                throw new Error('Failed to create XR session');
+            }
+
+            this.session = session;
+
+            // Setup XR rendering
+            const renderer = this.sceneManager.getRenderer();
+            await renderer.xr.setSession(this.session);
+            
+            // Configure renderer for AR
+            renderer.xr.enabled = true;
+            
+            // Set up scene for XR mode
+            const scene = this.sceneManager.getScene();
+            if (platformManager.isQuest()) {
+                // Clear background for AR passthrough
+                scene.background = null;
+            } else {
+                // Keep background for VR mode
+                scene.background = new Color(BACKGROUND_COLOR);
+            }
+            
+            // Get reference space based on platform
+            const spaceType = platformManager.isQuest() ? 'local-floor' : 'bounded-floor';
+            this.referenceSpace = await this.session.requestReferenceSpace(spaceType);
+            
+            // Setup session event handlers
+            this.session.addEventListener('end', this.onXRSessionEnd);
+
+            // Enable AR layer for camera
+            const camera = this.sceneManager.getCamera();
+            camera.layers.enable(1);
+            
+            // Apply AR scale if in AR mode
+            if (platformManager.isQuest()) {
+                // Use direct room scale for better AR sizing
+                // Use roomScale directly for consistent AR sizing
+                const arScale = this.currentSettings.roomScale;
+                if (debugState.isEnabled()) {
+                    logger.info('Setting initial AR scale:', { 
+                        arScale, 
+                        roomScale: this.currentSettings.roomScale,
+                        cameraRigScale: this.cameraRig.scale.x,
+                        arGroupScale: this.arGroup.scale.x,
+                        arGraphGroupScale: this.arGraphGroup.scale.x,
+                        currentGroupScale: this.arGroup.scale.x
+                    });
+                }
+
+                this.arGroup.scale.setScalar(arScale);
+                
+                // Move node instances to arGroup for proper scaling
+                const instanceMesh = this.nodeManager.getInstancedMesh();
+                if (instanceMesh) {
+                    // Enable both layers for the mesh and its children
+                    instanceMesh.layers.enable(0);
+                    instanceMesh.layers.enable(1);
+                    instanceMesh.traverse((child: any) => {
+                        if (child.layers) {
+                            child.layers.enable(0);
+                            child.layers.enable(1);
+                        }
+                    });
+                    this.arGroup.add(instanceMesh);
+                }
+            }
+
+            // Reset camera rig position
+            this.cameraRig.position.set(0, 0, 0);
+            this.cameraRig.quaternion.identity();
+
+            // Show AR visualization elements after a short delay to ensure proper placement
+            setTimeout(() => {
+                this.gridHelper.visible = true;
+                // Force ground plane to remain invisible to prevent occlusion of node labels
+                this.groundPlane.visible = false;
+                this.arLight.visible = true;
+            }, 1500); // Increased delay for better stability
+            
+            this.isPresenting = true;
+            if (debugState.isEnabled()) {
+                logger.info('XR session initialized');
+            }
+
+            // Hide control panel in XR mode
+            const controlPanel = ModularControlPanel.getInstance();
+            if (controlPanel) {
+                controlPanel.hide();
+            }
+
+            // Notify session start
+            if (this.xrSessionStartCallback) {
+                this.xrSessionStartCallback();
+            }
+        } catch (error) {
+            if (debugState.isEnabled()) {
+                logger.error('Failed to initialize XR session:', error);
+            }
+            throw error;
+        }
+    }
+
+    public async endXRSession(): Promise<void> {
+        if (!this.session) {
+            return;
+        }
+        
+        // Prevent multiple cleanup attempts
+        if (this.isCleaningUp) {
+            logger.warn('XR session cleanup already in progress');
+            return;
+        }
+        
+        this.isCleaningUp = true;
+        platformManager.xrSessionState = 'ending';
+        try {
+            await this.session.end();
+        } catch (error) {
+            logger.error('Error ending XR session:', error);
+        } finally {
+            this.isCleaningUp = false;
+        }
+    }
+
+    public getControllers(): Group[] {
+        return this.controllers;
+    }
+
+    public getControllerGrips(): Group[] {
+        return this.controllerGrips;
+    }
+
+    private notifyControllerAdded(controller: Group): void {
+        if (this.controllerAddedCallback) {
+            this.controllerAddedCallback(controller);
+        }
+    }
+
+    private notifyControllerRemoved(controller: Group): void {
+        if (this.controllerRemovedCallback) {
+            this.controllerRemovedCallback(controller);
+        }
+    }
+
+    public onXRSessionEnd = (): void => {
+        // This happens when user exits XR mode
+        
+        // Explicitly ensure ground plane and other AR objects are hidden
+        this.gridHelper.visible = false;
+        this.groundPlane.visible = false;
+        this.hitTestMarker.visible = false;
+        this.arLight.visible = false;
+        
+        platformManager.xrSessionState = 'inactive';
+        // Return to desktop mode
+        platformManager.setXRMode(false);
+        
+        if (debugState.isEnabled()) {
+            logger.info('XR session ended and cleaned up');
+        }
+        
+        // Show control panel and notify session end (only once)
+        ModularControlPanel.getInstance()?.show();
+        
+        // Use setTimeout to ensure the callback is called after the browser has had time to process the session end
+        setTimeout(() => {
+            this.xrSessionEndCallback?.();
+        }, 100);
+    }
+
+    private applyXRSettings(): void {
+        if (!this.isPresenting) return;
+
+        // Update movement settings
+        const controllers = this.getControllers();
+        controllers.forEach(controller => {
+            const inputSource = controller.userData.inputSource as XRInputSource;
+            if (inputSource?.gamepad) {
+                // Settings will be applied on next frame in onXRFrame
+            }
+        });
+
+        // Update visual settings if needed
+        if (this.currentSettings.handMeshEnabled !== undefined) {
+            controllers.forEach(controller => {
+                controller.traverse((object: { name?: string; visible: boolean }) => {
+                    if (object.name === 'handMesh') {
+                        object.visible = !!this.currentSettings.handMeshEnabled;
+                    }
+                });
+            });
+        }
+
+        if (this.currentSettings.handRayEnabled !== undefined) {
+            controllers.forEach(controller => {
+                controller.traverse((object: { name?: string; visible: boolean }) => {
+                    if (object.name === 'ray') {
+                        object.visible = !!this.currentSettings.handRayEnabled;
+                    }
+                });
+            });
+        }
+
+        // Update room scale if changed
+        if (this.currentSettings.roomScale !== undefined) {
+            if (platformManager.isQuest()) {
+                // Use roomScale directly for consistent AR sizing
+                const arScale = Number(this.currentSettings.roomScale);
+                if (debugState.isEnabled()) {
+                    logger.info('Updating AR scale:', { 
+                        arScale, 
+                        roomScale: this.currentSettings.roomScale,
+                        cameraRigScale: this.cameraRig.scale.x,
+                        arGroupScale: this.arGroup.scale.x,
+                        arGraphGroupScale: this.arGraphGroup.scale.x,
+                        currentGroupScale: this.arGroup.scale.x
+                    });
+                }
+                this.arGroup.scale.setScalar(arScale);
+            } else {
+                this.cameraRig.scale.setScalar(Number(this.currentSettings.roomScale));
+            }
+        }
+    }
+
+    public dispose(): void {
+        if (this.settingsUnsubscribe) {
+            this.settingsUnsubscribe();
+            this.settingsUnsubscribe = null;
+        }
+
+        if (this.session) {
+            this.session.removeEventListener('end', this.onXRSessionEnd);
+            this.session.end().catch(console.error);
+        }
+
+        this.controllers.forEach(controller => {
+            const handlers = controller.userData.eventHandlers;
+            if (handlers) {
+                controller.removeEventListener('connected', handlers.connected);
+                controller.removeEventListener('disconnected', handlers.disconnected);
+                delete controller.userData.eventHandlers;
+            }
+            controller.userData.inputSource = null;
+        });
+
+        this.controllerGrips.forEach(grip => {
+            grip.remove(...grip.children);
+        });
+
+        this.hitTestSource?.cancel();
+        this.hitTestSource = null;
+        this.hitTestSourceRequested = false;
+
+        this.session = null;
+        this.referenceSpace = null;
+        this.isPresenting = false;
+
+        this.xrSessionStartCallback = null;
+        this.xrSessionEndCallback = null;
+        this.xrAnimationFrameCallback = null;
+        this.controllerAddedCallback = null;
+        this.controllerRemovedCallback = null;
+
+        XRSessionManager.instance = null;
+    }
+}
diff --git a/client/xr/xrTypes.ts b/client/xr/xrTypes.ts
new file mode 100644
index 00000000..556eb0af
--- /dev/null
+++ b/client/xr/xrTypes.ts
@@ -0,0 +1,25 @@
+import * as THREE from 'three';
+
+export interface XRHandWithHaptics {
+    hand: {
+        joints: {
+            [key: string]: THREE.Object3D;
+        };
+    };
+    hapticActuators: any[];
+    pinchStrength: number;
+    gripStrength: number;
+}
+
+export interface XRControllerState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    hapticActuator?: any;
+}
+
+export interface XRHandState {
+    position: THREE.Vector3;
+    joints: Map<string, THREE.Object3D>;
+    pinchStrength: number;
+    gripStrength: number;
+}
diff --git a/config.yml b/config.yml
new file mode 100644
index 00000000..07811293
--- /dev/null
+++ b/config.yml
@@ -0,0 +1,26 @@
+tunnel: logseqXR
+
+ingress:
+  - hostname: www.visionflow.info
+    service: http://webxr-client:4000
+    originRequest:
+      noTLSVerify: true
+      connectTimeout: 30s
+      tcpKeepAlive: 10s
+      keepAliveTimeout: 10m
+      idleTimeout: 10m
+      websocketIdleTimeout: 10m
+      keepAliveConnections: 100
+      httpHostHeader: www.visionflow.info
+      proxyProtocol: false
+    config:
+      webSockets: true
+      http2Origin: true
+  - service: http_status:404
+
+# Connection settings
+protocol: http2
+no-autoupdate: true
+
+# Logging settings
+loglevel: debug
diff --git a/data/metadata/graph.json b/data/metadata/graph.json
new file mode 100644
index 00000000..377e6768
--- /dev/null
+++ b/data/metadata/graph.json
@@ -0,0 +1,15027 @@
+{
+  "nodes": [
+    {
+      "id": "1",
+      "metadataId": "Human tracking and SLAM capture",
+      "label": "Human tracking and SLAM capture",
+      "data": {
+        "position": {
+          "x": -0.54293025,
+          "y": -0.2326134,
+          "z": 1.0807605
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Human tracking and SLAM capture",
+        "name": "Human tracking and SLAM capture",
+        "nodeSize": "20.848999999999997",
+        "sha1": "ca73b996878f9a362b5bd77ddb322a3321dee834",
+        "lastModified": "2025-02-15 16:10:15.618163478 UTC",
+        "fileSize": "1761",
+        "fileName": "Human tracking and SLAM capture.md",
+        "hyperlinkCount": "9"
+      },
+      "size": 20.849
+    },
+    {
+      "id": "2",
+      "metadataId": "Ethereum",
+      "label": "Ethereum",
+      "data": {
+        "position": {
+          "x": 0.39727464,
+          "y": -1.2291334,
+          "z": -1.016031
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "29",
+        "fileName": "Ethereum.md",
+        "sha1": "2e8f4c1a3a736a74b6a5ee4d04beb22b3020a400",
+        "name": "Ethereum",
+        "lastModified": "2025-02-15 16:09:44.695188663 UTC",
+        "metadataId": "Ethereum",
+        "nodeSize": "50",
+        "fileSize": "15310"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "3",
+      "metadataId": "Visionflow",
+      "label": "Visionflow",
+      "data": {
+        "position": {
+          "x": 0.3979463,
+          "y": 0.09601595,
+          "z": -0.37918407
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Visionflow.md",
+        "fileSize": "5188",
+        "name": "Visionflow",
+        "metadataId": "Visionflow",
+        "hyperlinkCount": "1",
+        "sha1": "6adb7b439a04e51b13d9829d9a7deed97a8a9c50",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:13:02.029776447 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "4",
+      "metadataId": "Training and fine tuning",
+      "label": "Training and fine tuning",
+      "data": {
+        "position": {
+          "x": -0.754676,
+          "y": 0.63279575,
+          "z": 0.49811426
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Training and fine tuning",
+        "lastModified": "2025-02-15 16:12:46.439870219 UTC",
+        "metadataId": "Training and fine tuning",
+        "sha1": "f8e7d4b12dc95f1b29a2f004a0b987d2e96a5696",
+        "fileName": "Training and fine tuning.md",
+        "hyperlinkCount": "0",
+        "fileSize": "4404",
+        "nodeSize": "44.636"
+      },
+      "size": 44.636
+    },
+    {
+      "id": "5",
+      "metadataId": "Death of the Internet",
+      "label": "Death of the Internet",
+      "data": {
+        "position": {
+          "x": 0.24356043,
+          "y": 0.6908235,
+          "z": 0.50613123
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "5043440f98edf274d734dbfdfba7d705e2cd3936",
+        "hyperlinkCount": "83",
+        "name": "Death of the Internet",
+        "lastModified": "2025-02-15 16:09:18.796768914 UTC",
+        "metadataId": "Death of the Internet",
+        "fileSize": "31877",
+        "fileName": "Death of the Internet.md",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "6",
+      "metadataId": "Gaussian splatting and Similar",
+      "label": "Gaussian splatting and Similar",
+      "data": {
+        "position": {
+          "x": -0.5585085,
+          "y": -0.27801332,
+          "z": 0.47721058
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "8359eca4d53913b6ef6d8e537cd12afed9c2a69b",
+        "lastModified": "2025-02-15 16:10:01.561497027 UTC",
+        "fileName": "Gaussian splatting and Similar.md",
+        "hyperlinkCount": "15",
+        "name": "Gaussian splatting and Similar",
+        "nodeSize": "50",
+        "metadataId": "Gaussian splatting and Similar",
+        "fileSize": "7756"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "7",
+      "metadataId": "Mixed reality",
+      "label": "Mixed reality",
+      "data": {
+        "position": {
+          "x": 0.42203164,
+          "y": 0.7561993,
+          "z": 0.9096178
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 30,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Mixed reality",
+        "hyperlinkCount": "87",
+        "sha1": "fe23c08d8a0f03137339f6ef778602fa3936667c",
+        "nodeSize": "50",
+        "fileName": "Mixed reality.md",
+        "fileSize": "59923",
+        "metadataId": "Mixed reality",
+        "lastModified": "2025-02-15 16:11:06.870967751 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "8",
+      "metadataId": "Octave Multi Model Laboratory",
+      "label": "Octave Multi Model Laboratory",
+      "data": {
+        "position": {
+          "x": -0.37109125,
+          "y": -1.1439005,
+          "z": -0.6263922
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Octave Multi Model Laboratory",
+        "hyperlinkCount": "6",
+        "sha1": "34ea203172ccadf208dda2aa1cb8036ebe6ee74b",
+        "nodeSize": "25.925000000000004",
+        "fileName": "Octave Multi Model Laboratory.md",
+        "metadataId": "Octave Multi Model Laboratory",
+        "fileSize": "2325",
+        "lastModified": "2025-02-15 16:11:18.061917637 UTC"
+      },
+      "size": 25.925
+    },
+    {
+      "id": "9",
+      "metadataId": "ComfyUI",
+      "label": "ComfyUI",
+      "data": {
+        "position": {
+          "x": 0.04060096,
+          "y": -0.15676409,
+          "z": 1.0546039
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 29,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "ComfyUI",
+        "sha1": "14934e91d17fdd724433532a6b7261a04463a59c",
+        "nodeSize": "50",
+        "hyperlinkCount": "126",
+        "fileSize": "36608",
+        "fileName": "ComfyUI.md",
+        "metadataId": "ComfyUI",
+        "lastModified": "2025-02-15 16:08:57.363689285 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "10",
+      "metadataId": "Humans, Avatars , Character",
+      "label": "Humans, Avatars , Character",
+      "data": {
+        "position": {
+          "x": 0.11054826,
+          "y": 0.14927287,
+          "z": 0.17845729
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "14756",
+        "name": "Humans, Avatars , Character",
+        "hyperlinkCount": "71",
+        "sha1": "9487a7196405682044523f72286aa7599d279d1d",
+        "lastModified": "2025-02-15 16:10:17.488159103 UTC",
+        "metadataId": "Humans, Avatars , Character",
+        "fileName": "Humans, Avatars , Character.md",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "11",
+      "metadataId": "Bitcoin As Money",
+      "label": "Bitcoin As Money",
+      "data": {
+        "position": {
+          "x": -0.41863826,
+          "y": -0.17571859,
+          "z": 0.0150046395
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "fileName": "Bitcoin As Money.md",
+        "sha1": "857a8a3444a7eb88d4ece3ba31fa427a953d16da",
+        "hyperlinkCount": "23",
+        "name": "Bitcoin As Money",
+        "lastModified": "2025-02-15 16:08:37.981321291 UTC",
+        "fileSize": "18467",
+        "metadataId": "Bitcoin As Money"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "12",
+      "metadataId": "Digital Objects",
+      "label": "Digital Objects",
+      "data": {
+        "position": {
+          "x": 0.1946554,
+          "y": 0.4175525,
+          "z": -1.0615662
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 30,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "132",
+        "sha1": "dca2c7ca0406854cc6314a6c307e82befc33cbe9",
+        "name": "Digital Objects",
+        "metadataId": "Digital Objects",
+        "fileSize": "62939",
+        "fileName": "Digital Objects.md",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:09:30.116459541 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "13",
+      "metadataId": "National Industrial Centre for Virtual Environments",
+      "label": "National Industrial Centre for Virtual Environments",
+      "data": {
+        "position": {
+          "x": 0.023841511,
+          "y": -0.119637236,
+          "z": 1.6279328
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "871f25b09501b0b72b75d6c8547dc704169fe3e1",
+        "name": "National Industrial Centre for Virtual Environments",
+        "nodeSize": "29.489",
+        "fileSize": "2721",
+        "hyperlinkCount": "12",
+        "lastModified": "2025-02-15 16:11:16.090958164 UTC",
+        "metadataId": "National Industrial Centre for Virtual Environments",
+        "fileName": "National Industrial Centre for Virtual Environments.md"
+      },
+      "size": 29.489
+    },
+    {
+      "id": "14",
+      "metadataId": "Proprietary Image Generation",
+      "label": "Proprietary Image Generation",
+      "data": {
+        "position": {
+          "x": -0.7184456,
+          "y": -0.10489523,
+          "z": 0.28745604
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "3077",
+        "nodeSize": "32.693",
+        "sha1": "5801d9feea43c5f3f231bc5108f3054a777937fb",
+        "metadataId": "Proprietary Image Generation",
+        "lastModified": "2025-02-15 16:11:46.684507556 UTC",
+        "name": "Proprietary Image Generation",
+        "fileName": "Proprietary Image Generation.md",
+        "hyperlinkCount": "9"
+      },
+      "size": 32.693
+    },
+    {
+      "id": "15",
+      "metadataId": "Music and audio",
+      "label": "Music and audio",
+      "data": {
+        "position": {
+          "x": 0.6550326,
+          "y": -0.67695373,
+          "z": -0.007998452
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:11:13.882813409 UTC",
+        "name": "Music and audio",
+        "metadataId": "Music and audio",
+        "hyperlinkCount": "28",
+        "fileSize": "8182",
+        "fileName": "Music and audio.md",
+        "nodeSize": "50",
+        "sha1": "1d71d9318b31a0438bfbbeff31e5e9f9967bf760"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "16",
+      "metadataId": "Deep Learning",
+      "label": "Deep Learning",
+      "data": {
+        "position": {
+          "x": 0.13305475,
+          "y": -0.7153372,
+          "z": 0.8041256
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "0",
+        "name": "Deep Learning",
+        "fileName": "Deep Learning.md",
+        "nodeSize": "50",
+        "sha1": "56f4b96b652143560c18c0129ce786622c91a856",
+        "lastModified": "2025-02-15 16:09:22.970285867 UTC",
+        "fileSize": "18831",
+        "metadataId": "Deep Learning"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "17",
+      "metadataId": "Open Generative AI tools",
+      "label": "Open Generative AI tools",
+      "data": {
+        "position": {
+          "x": 1.306236,
+          "y": -0.26050785,
+          "z": 0.028603563
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Open Generative AI tools",
+        "sha1": "fdab291f326cd1b0dc4268998f2c89e088ba6020",
+        "fileName": "Open Generative AI tools.md",
+        "name": "Open Generative AI tools",
+        "lastModified": "2025-02-15 16:11:19.533355410 UTC",
+        "fileSize": "2630",
+        "hyperlinkCount": "5",
+        "nodeSize": "28.67"
+      },
+      "size": 28.67
+    },
+    {
+      "id": "18",
+      "metadataId": "Time Series Forecasting",
+      "label": "Time Series Forecasting",
+      "data": {
+        "position": {
+          "x": -0.80075574,
+          "y": -0.96016985,
+          "z": 0.54327077
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 18,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "12.785",
+        "metadataId": "Time Series Forecasting",
+        "sha1": "d1712dadeb12099575ad272cd845ee9d6a24fcad",
+        "name": "Time Series Forecasting",
+        "hyperlinkCount": "5",
+        "fileName": "Time Series Forecasting.md",
+        "fileSize": "865",
+        "lastModified": "2025-02-15 16:12:43.701766057 UTC"
+      },
+      "size": 12.785
+    },
+    {
+      "id": "19",
+      "metadataId": "Digital Society Harms",
+      "label": "Digital Society Harms",
+      "data": {
+        "position": {
+          "x": -0.9480377,
+          "y": 0.68069273,
+          "z": 1.1226765
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:09:31.421111458 UTC",
+        "metadataId": "Digital Society Harms",
+        "name": "Digital Society Harms",
+        "sha1": "621a54f748119add788b95ffbba6c08452036258",
+        "fileName": "Digital Society Harms.md",
+        "hyperlinkCount": "11",
+        "nodeSize": "23.468",
+        "fileSize": "2052"
+      },
+      "size": 23.468
+    },
+    {
+      "id": "20",
+      "metadataId": "State of the art in AI",
+      "label": "State of the art in AI",
+      "data": {
+        "position": {
+          "x": -0.48462763,
+          "y": -0.31039852,
+          "z": -0.90910727
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "State of the art in AI",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:12:31.064072045 UTC",
+        "sha1": "ae78904f3bd3432f308da79442be04beb5bcab46",
+        "hyperlinkCount": "19",
+        "fileName": "State of the art in AI.md",
+        "name": "State of the art in AI",
+        "fileSize": "8137"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "21",
+      "metadataId": "Prompt Engineering",
+      "label": "Prompt Engineering",
+      "data": {
+        "position": {
+          "x": 0.0010208533,
+          "y": -0.74609137,
+          "z": 1.1012046
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "0d7b1fd8f9acf47e96641a3ab34fd5d107a71eaf",
+        "lastModified": "2025-02-15 16:11:44.724314374 UTC",
+        "hyperlinkCount": "68",
+        "fileSize": "33404",
+        "name": "Prompt Engineering",
+        "fileName": "Prompt Engineering.md",
+        "nodeSize": "50",
+        "metadataId": "Prompt Engineering"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "22",
+      "metadataId": "debug linked node",
+      "label": "debug linked node",
+      "data": {
+        "position": {
+          "x": 0.6973773,
+          "y": 0.3301841,
+          "z": 0.57447743
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 11,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "63",
+        "nodeSize": "5.567",
+        "hyperlinkCount": "0",
+        "metadataId": "debug linked node",
+        "sha1": "d33bc80ce9d690c8c64301ce5346f36923791a44",
+        "fileName": "debug linked node.md",
+        "name": "debug linked node",
+        "lastModified": "2025-02-15 16:13:18.811983489 UTC"
+      },
+      "size": 5.567
+    },
+    {
+      "id": "23",
+      "metadataId": "Overview of Machine Learning Techniques",
+      "label": "Overview of Machine Learning Techniques",
+      "data": {
+        "position": {
+          "x": 0.47801673,
+          "y": -0.095666364,
+          "z": -0.06436214
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Overview of Machine Learning Techniques",
+        "nodeSize": "50",
+        "sha1": "b42c90f063ac83bfc71ca3fc133eef422505162f",
+        "fileSize": "7147",
+        "fileName": "Overview of Machine Learning Techniques.md",
+        "lastModified": "2025-02-15 16:11:24.436528238 UTC",
+        "metadataId": "Overview of Machine Learning Techniques",
+        "hyperlinkCount": "18"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "24",
+      "metadataId": "Gemini",
+      "label": "Gemini",
+      "data": {
+        "position": {
+          "x": 0.88506776,
+          "y": -0.56347954,
+          "z": 0.28590074
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Gemini",
+        "nodeSize": "22.622",
+        "hyperlinkCount": "7",
+        "metadataId": "Gemini",
+        "sha1": "3f9377a187137c61808cacf852367e19c785cf4a",
+        "fileSize": "1958",
+        "fileName": "Gemini.md",
+        "lastModified": "2025-02-15 16:10:02.828534683 UTC"
+      },
+      "size": 22.622
+    },
+    {
+      "id": "25",
+      "metadataId": "Coding support",
+      "label": "Coding support",
+      "data": {
+        "position": {
+          "x": 0.56793994,
+          "y": 0.9430145,
+          "z": -0.3642157
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Coding support",
+        "metadataId": "Coding support",
+        "hyperlinkCount": "38",
+        "sha1": "40669d5f91734607fb5a850e03fba49615e8dc15",
+        "fileSize": "15162",
+        "fileName": "Coding support.md",
+        "lastModified": "2025-02-15 16:08:54.708446370 UTC",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "26",
+      "metadataId": "Scene Capture and Reconstruction",
+      "label": "Scene Capture and Reconstruction",
+      "data": {
+        "position": {
+          "x": -0.34645742,
+          "y": 0.13292319,
+          "z": 1.5237993
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Scene Capture and Reconstruction.md",
+        "name": "Scene Capture and Reconstruction",
+        "hyperlinkCount": "86",
+        "fileSize": "12426",
+        "nodeSize": "50",
+        "sha1": "0b21539e1df68d82a543aef926347dbf55a7ebe1",
+        "metadataId": "Scene Capture and Reconstruction",
+        "lastModified": "2025-02-15 16:12:15.435590380 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "27",
+      "metadataId": "Conspiracies",
+      "label": "Conspiracies",
+      "data": {
+        "position": {
+          "x": -0.31115526,
+          "y": 0.42626983,
+          "z": 0.31496355
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Conspiracies",
+        "fileSize": "13147",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:09:02.929383613 UTC",
+        "metadataId": "Conspiracies",
+        "sha1": "a2952b45f94d6f7579fca999d55c6f3049f95cde",
+        "fileName": "Conspiracies.md",
+        "hyperlinkCount": "9"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "28",
+      "metadataId": "Safety and alignment",
+      "label": "Safety and alignment",
+      "data": {
+        "position": {
+          "x": -0.7845477,
+          "y": -0.7067711,
+          "z": 1.2021954
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Safety and alignment.md",
+        "name": "Safety and alignment",
+        "hyperlinkCount": "12",
+        "metadataId": "Safety and alignment",
+        "sha1": "b5b56905d6989e3d22896938603efceef2f2c4b3",
+        "fileSize": "20446",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:12:12.712173362 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "29",
+      "metadataId": "AI Companies",
+      "label": "AI Companies",
+      "data": {
+        "position": {
+          "x": 0.4814255,
+          "y": 0.70646703,
+          "z": 0.05067335
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "AI Companies.md",
+        "lastModified": "2025-02-15 16:08:08.045852866 UTC",
+        "sha1": "f3e0fd1d16eb22fb2dda1cc95d246869e0759f69",
+        "metadataId": "AI Companies",
+        "hyperlinkCount": "6",
+        "name": "AI Companies",
+        "nodeSize": "50",
+        "fileSize": "7132"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "30",
+      "metadataId": "Transformers",
+      "label": "Transformers",
+      "data": {
+        "position": {
+          "x": 0.12101136,
+          "y": 0.25650054,
+          "z": -0.18157133
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "2437",
+        "nodeSize": "26.933",
+        "lastModified": "2025-02-15 16:12:47.186631332 UTC",
+        "metadataId": "Transformers",
+        "fileName": "Transformers.md",
+        "hyperlinkCount": "5",
+        "name": "Transformers",
+        "sha1": "b2f0d608cd9dfe8305270612f07063e909eb9fa0"
+      },
+      "size": 26.933
+    },
+    {
+      "id": "31",
+      "metadataId": "Runes and Glyphs",
+      "label": "Runes and Glyphs",
+      "data": {
+        "position": {
+          "x": -0.84427786,
+          "y": 0.2727695,
+          "z": 0.27639383
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "1840",
+        "name": "Runes and Glyphs",
+        "lastModified": "2025-02-15 16:12:09.306148260 UTC",
+        "fileName": "Runes and Glyphs.md",
+        "hyperlinkCount": "15",
+        "metadataId": "Runes and Glyphs",
+        "sha1": "a2a25a678dabe813bd618db55310495c1b877649",
+        "nodeSize": "21.56"
+      },
+      "size": 21.56
+    },
+    {
+      "id": "32",
+      "metadataId": "Model Optimisation and Performance",
+      "label": "Model Optimisation and Performance",
+      "data": {
+        "position": {
+          "x": 0.026432352,
+          "y": -0.20494254,
+          "z": 0.27615726
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Model Optimisation and Performance",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:11:08.337700305 UTC",
+        "fileSize": "10270",
+        "sha1": "ea57b42268867df3930c1c25869b5cd10e8a79db",
+        "metadataId": "Model Optimisation and Performance",
+        "hyperlinkCount": "17",
+        "fileName": "Model Optimisation and Performance.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "33",
+      "metadataId": "Metaverse and Spatial Risks",
+      "label": "Metaverse and Spatial Risks",
+      "data": {
+        "position": {
+          "x": -1.2241559,
+          "y": 0.34905404,
+          "z": -0.6964719
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "2",
+        "name": "Metaverse and Spatial Risks",
+        "lastModified": "2025-02-15 16:10:59.176766764 UTC",
+        "nodeSize": "26.987",
+        "metadataId": "Metaverse and Spatial Risks",
+        "sha1": "b9ef186e5294a38d70878f2c6aed99422c9df532",
+        "fileSize": "2443",
+        "fileName": "Metaverse and Spatial Risks.md"
+      },
+      "size": 26.987
+    },
+    {
+      "id": "34",
+      "metadataId": "Base models",
+      "label": "Base models",
+      "data": {
+        "position": {
+          "x": -0.010963347,
+          "y": 1.3160403,
+          "z": -0.02889252
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 31,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Base models.md",
+        "fileSize": "84942",
+        "sha1": "698dff0c0889c174e01a4d09544f176c2a7edd22",
+        "name": "Base models",
+        "metadataId": "Base models",
+        "hyperlinkCount": "1",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:08:36.535334852 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "35",
+      "metadataId": "AnimateDiff",
+      "label": "AnimateDiff",
+      "data": {
+        "position": {
+          "x": 0.6613617,
+          "y": 0.05236297,
+          "z": -0.13715893
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 15,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "1",
+        "metadataId": "AnimateDiff",
+        "fileSize": "298",
+        "fileName": "AnimateDiff.md",
+        "sha1": "4925127460d01f5ee29b7f566b29b11f841bdd0c",
+        "name": "AnimateDiff",
+        "nodeSize": "7.682",
+        "lastModified": "2025-02-15 16:08:26.036348101 UTC"
+      },
+      "size": 7.682
+    },
+    {
+      "id": "36",
+      "metadataId": "Courses and Training",
+      "label": "Courses and Training",
+      "data": {
+        "position": {
+          "x": -0.322379,
+          "y": -0.16364215,
+          "z": 0.7136217
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "39",
+        "fileSize": "7329",
+        "fileName": "Courses and Training.md",
+        "name": "Courses and Training",
+        "metadataId": "Courses and Training",
+        "sha1": "10708b433ab7959e67cb38abe013d41af9d05afb",
+        "lastModified": "2025-02-15 16:09:09.064051335 UTC",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "37",
+      "metadataId": "Money",
+      "label": "Money",
+      "data": {
+        "position": {
+          "x": 0.071114406,
+          "y": -0.29356912,
+          "z": 0.5344703
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 31,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Money",
+        "sha1": "976d46eeeef05fac30fb8423dc8ecf8f5af1cc1b",
+        "lastModified": "2025-02-15 16:11:11.147875345 UTC",
+        "nodeSize": "50",
+        "fileName": "Money.md",
+        "name": "Money",
+        "hyperlinkCount": "79",
+        "fileSize": "85818"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "38",
+      "metadataId": "Artificial Intelligence",
+      "label": "Artificial Intelligence",
+      "data": {
+        "position": {
+          "x": 1.067022,
+          "y": 0.65567774,
+          "z": 0.35005334
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Artificial Intelligence.md",
+        "lastModified": "2025-02-15 16:08:30.499678098 UTC",
+        "hyperlinkCount": "3",
+        "name": "Artificial Intelligence",
+        "fileSize": "5855",
+        "nodeSize": "50",
+        "sha1": "fac1de351c9748757d44ab1f29cfac303375f5c8",
+        "metadataId": "Artificial Intelligence"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "39",
+      "metadataId": "Singularity",
+      "label": "Singularity",
+      "data": {
+        "position": {
+          "x": -0.7891092,
+          "y": -0.3043705,
+          "z": -0.15556973
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:12:20.372243704 UTC",
+        "fileName": "Singularity.md",
+        "hyperlinkCount": "1",
+        "name": "Singularity",
+        "sha1": "c35e7f287027707c97f1ed684c9c3e0654152b42",
+        "fileSize": "5040",
+        "metadataId": "Singularity"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "40",
+      "metadataId": "Global Inequality",
+      "label": "Global Inequality",
+      "data": {
+        "position": {
+          "x": 0.78127074,
+          "y": 0.27300304,
+          "z": 0.009101872
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "11",
+        "fileSize": "35143",
+        "sha1": "5436bf1482d2b5e597e60cf92aafaffbb4915bf0",
+        "metadataId": "Global Inequality",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:10:05.108073687 UTC",
+        "name": "Global Inequality",
+        "fileName": "Global Inequality.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "41",
+      "metadataId": "Suggested Reading Order",
+      "label": "Suggested Reading Order",
+      "data": {
+        "position": {
+          "x": 0.22884597,
+          "y": -0.19498272,
+          "z": 1.150195
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:12:33.058829406 UTC",
+        "nodeSize": "30.038",
+        "fileSize": "2782",
+        "metadataId": "Suggested Reading Order",
+        "hyperlinkCount": "2",
+        "fileName": "Suggested Reading Order.md",
+        "sha1": "dd52efde2f9d59e0c7d88a1eff9cf54a169e0a76",
+        "name": "Suggested Reading Order"
+      },
+      "size": 30.038
+    },
+    {
+      "id": "42",
+      "metadataId": "multimodal",
+      "label": "multimodal",
+      "data": {
+        "position": {
+          "x": 0.5586311,
+          "y": 0.019392911,
+          "z": 0.17588314
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "multimodal",
+        "hyperlinkCount": "12",
+        "fileSize": "4601",
+        "metadataId": "multimodal",
+        "lastModified": "2025-02-15 16:13:38.240059381 UTC",
+        "fileName": "multimodal.md",
+        "nodeSize": "46.409",
+        "sha1": "b47a1d2ce1b2295a7b830bc6c223b667c4bd6fc4"
+      },
+      "size": 46.409
+    },
+    {
+      "id": "43",
+      "metadataId": "Agentic Metaverse for Global Creatives",
+      "label": "Agentic Metaverse for Global Creatives",
+      "data": {
+        "position": {
+          "x": -0.8681413,
+          "y": -0.08611558,
+          "z": 0.5876163
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "30730",
+        "metadataId": "Agentic Metaverse for Global Creatives",
+        "fileName": "Agentic Metaverse for Global Creatives.md",
+        "nodeSize": "50",
+        "hyperlinkCount": "1",
+        "lastModified": "2025-02-15 16:08:21.949625703 UTC",
+        "name": "Agentic Metaverse for Global Creatives",
+        "sha1": "4d086bdfcecbc35fc2d6596b5dc6dabf082696b1"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "44",
+      "metadataId": "Semantic Web",
+      "label": "Semantic Web",
+      "data": {
+        "position": {
+          "x": -0.16033348,
+          "y": 1.0139555,
+          "z": -1.2624798
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Semantic Web",
+        "hyperlinkCount": "5",
+        "sha1": "8c26c2cbc21a0b22630ca576d766390a9bd851ce",
+        "lastModified": "2025-02-15 16:12:17.650758345 UTC",
+        "fileSize": "15524",
+        "fileName": "Semantic Web.md",
+        "name": "Semantic Web",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "45",
+      "metadataId": "Interfaces",
+      "label": "Interfaces",
+      "data": {
+        "position": {
+          "x": 0.6725927,
+          "y": 0.79780245,
+          "z": -0.89078605
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Interfaces.md",
+        "name": "Interfaces",
+        "nodeSize": "50",
+        "fileSize": "5576",
+        "metadataId": "Interfaces",
+        "hyperlinkCount": "20",
+        "sha1": "cbf3df4603ca76633ebeb70927ac2193ed85d06d",
+        "lastModified": "2025-02-15 16:10:25.198133670 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "46",
+      "metadataId": "Landscape",
+      "label": "Landscape",
+      "data": {
+        "position": {
+          "x": 1.5286638,
+          "y": 0.14456916,
+          "z": 0.27860087
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 15,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "7.772",
+        "fileName": "Landscape.md",
+        "hyperlinkCount": "2",
+        "metadataId": "Landscape",
+        "fileSize": "308",
+        "lastModified": "2025-02-15 16:10:34.176721811 UTC",
+        "name": "Landscape",
+        "sha1": "89a1ba3cd3894d3c820e7d8a42ce7a0deef1346d"
+      },
+      "size": 7.772
+    },
+    {
+      "id": "47",
+      "metadataId": "Cyber Security and Military",
+      "label": "Cyber Security and Military",
+      "data": {
+        "position": {
+          "x": -0.58290154,
+          "y": -0.5648559,
+          "z": -0.5469101
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Cyber Security and Military.md",
+        "hyperlinkCount": "5",
+        "lastModified": "2025-02-15 16:09:12.521706348 UTC",
+        "sha1": "0d77069c4652291b0b72eba82c76b348a98f5e6c",
+        "fileSize": "7660",
+        "metadataId": "Cyber Security and Military",
+        "name": "Cyber Security and Military",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "48",
+      "metadataId": "Norbert Wiener",
+      "label": "Norbert Wiener",
+      "data": {
+        "position": {
+          "x": 0.13450806,
+          "y": -0.1651804,
+          "z": -0.489481
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "0",
+        "name": "Norbert Wiener",
+        "metadataId": "Norbert Wiener",
+        "fileSize": "2434",
+        "nodeSize": "26.906",
+        "lastModified": "2025-02-15 16:11:16.828099714 UTC",
+        "sha1": "073af281929b120abb910c60dc1d39ba3df1c908",
+        "fileName": "Norbert Wiener.md"
+      },
+      "size": 26.906
+    },
+    {
+      "id": "49",
+      "metadataId": "Decentralised Web",
+      "label": "Decentralised Web",
+      "data": {
+        "position": {
+          "x": 0.9241135,
+          "y": -0.38341674,
+          "z": 0.67912287
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 30,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Decentralised Web",
+        "lastModified": "2025-02-15 16:09:20.264883243 UTC",
+        "metadataId": "Decentralised Web",
+        "hyperlinkCount": "116",
+        "fileName": "Decentralised Web.md",
+        "sha1": "7a65ac69cb570feca301124dada1750772e4c1f4",
+        "fileSize": "68332",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "50",
+      "metadataId": "Machine Learning",
+      "label": "Machine Learning",
+      "data": {
+        "position": {
+          "x": 0.32093394,
+          "y": 0.33950815,
+          "z": -0.18403427
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "2",
+        "fileName": "Machine Learning.md",
+        "fileSize": "13286",
+        "name": "Machine Learning",
+        "lastModified": "2025-02-15 16:10:54.945571374 UTC",
+        "sha1": "7b913576c8bfd54db847194b7fd4954a4d278a81",
+        "metadataId": "Machine Learning",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "51",
+      "metadataId": "Diagrams as Code",
+      "label": "Diagrams as Code",
+      "data": {
+        "position": {
+          "x": 1.338887,
+          "y": -0.063249215,
+          "z": -0.5552849
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Diagrams as Code.md",
+        "lastModified": "2025-02-15 16:09:27.886915334 UTC",
+        "sha1": "b0b33a7a5a3673e8dc88905b52611c54628c2379",
+        "fileSize": "19571",
+        "name": "Diagrams as Code",
+        "hyperlinkCount": "21",
+        "metadataId": "Diagrams as Code",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "52",
+      "metadataId": "BTC Layer 3",
+      "label": "BTC Layer 3",
+      "data": {
+        "position": {
+          "x": 0.16708192,
+          "y": -0.14068015,
+          "z": 0.7104347
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "51393bdec64373a9e480c1bedaa0da3867d07876",
+        "fileName": "BTC Layer 3.md",
+        "hyperlinkCount": "35",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:08:33.871454190 UTC",
+        "name": "BTC Layer 3",
+        "fileSize": "26265",
+        "metadataId": "BTC Layer 3"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "53",
+      "metadataId": "Proprietary Large Language Models",
+      "label": "Proprietary Large Language Models",
+      "data": {
+        "position": {
+          "x": 0.6115142,
+          "y": -0.07471518,
+          "z": -1.1277871
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "6317",
+        "metadataId": "Proprietary Large Language Models",
+        "nodeSize": "50",
+        "hyperlinkCount": "9",
+        "sha1": "5e018d1e235c07b4add752d24c1349f73a95cac8",
+        "fileName": "Proprietary Large Language Models.md",
+        "name": "Proprietary Large Language Models",
+        "lastModified": "2025-02-15 16:11:47.429408415 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "54",
+      "metadataId": "Energy and Power",
+      "label": "Energy and Power",
+      "data": {
+        "position": {
+          "x": -0.10120033,
+          "y": 0.022907618,
+          "z": 0.6460713
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "af993f160d3f02d60e4ad699373e8dd26258829b",
+        "fileSize": "26099",
+        "fileName": "Energy and Power.md",
+        "hyperlinkCount": "59",
+        "metadataId": "Energy and Power",
+        "name": "Energy and Power",
+        "lastModified": "2025-02-15 16:09:43.223594051 UTC",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "55",
+      "metadataId": "GANs",
+      "label": "GANs",
+      "data": {
+        "position": {
+          "x": -0.01575932,
+          "y": 1.0191414,
+          "z": 0.6562937
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 7,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:09:59.355581856 UTC",
+        "metadataId": "GANs",
+        "hyperlinkCount": "0",
+        "name": "GANs",
+        "nodeSize": "5.126",
+        "fileSize": "14",
+        "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+        "fileName": "GANs.md"
+      },
+      "size": 5.126
+    },
+    {
+      "id": "56",
+      "metadataId": "Deepmind",
+      "label": "Deepmind",
+      "data": {
+        "position": {
+          "x": 0.11518198,
+          "y": 0.48750514,
+          "z": 0.093521364
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 7,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "14",
+        "metadataId": "Deepmind",
+        "name": "Deepmind",
+        "nodeSize": "5.126",
+        "lastModified": "2025-02-15 16:09:24.417595714 UTC",
+        "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+        "hyperlinkCount": "0",
+        "fileName": "Deepmind.md"
+      },
+      "size": 5.126
+    },
+    {
+      "id": "57",
+      "metadataId": "Microsoft Work Trends Impact 2024",
+      "label": "Microsoft Work Trends Impact 2024",
+      "data": {
+        "position": {
+          "x": -0.015675794,
+          "y": -0.29592058,
+          "z": -0.87522
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "sha1": "553423c8164077d6cb3f9abd1aec5b2956e108c3",
+        "hyperlinkCount": "1",
+        "fileSize": "7664",
+        "fileName": "Microsoft Work Trends Impact 2024.md",
+        "lastModified": "2025-02-15 16:11:03.354476599 UTC",
+        "name": "Microsoft Work Trends Impact 2024",
+        "metadataId": "Microsoft Work Trends Impact 2024"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "58",
+      "metadataId": "BroBots",
+      "label": "BroBots",
+      "data": {
+        "position": {
+          "x": 0.29467598,
+          "y": -0.04611493,
+          "z": -0.307099
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 16,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "351",
+        "name": "BroBots",
+        "sha1": "bce4fb5a2e262d02c88d33ab2bb7487db0425779",
+        "hyperlinkCount": "0",
+        "lastModified": "2025-02-15 16:08:46.463795350 UTC",
+        "nodeSize": "8.158999999999999",
+        "fileName": "BroBots.md",
+        "metadataId": "BroBots"
+      },
+      "size": 8.159
+    },
+    {
+      "id": "59",
+      "metadataId": "Bitcoin Value Proposition",
+      "label": "Bitcoin Value Proposition",
+      "data": {
+        "position": {
+          "x": 0.68901104,
+          "y": 0.40065125,
+          "z": -0.39787412
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 30,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Bitcoin Value Proposition",
+        "hyperlinkCount": "24",
+        "lastModified": "2025-02-15 16:08:41.410244845 UTC",
+        "name": "Bitcoin Value Proposition",
+        "fileName": "Bitcoin Value Proposition.md",
+        "fileSize": "53300",
+        "sha1": "e8ae399e02acdaae009b6c3a4777156d4cedf80d",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "60",
+      "metadataId": "Digital Asset Risks",
+      "label": "Digital Asset Risks",
+      "data": {
+        "position": {
+          "x": -2.9011135,
+          "y": 0.6628179,
+          "z": 1.0381902
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 29,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Digital Asset Risks",
+        "nodeSize": "50",
+        "sha1": "4b0855a9765e3cec9a09d4fe839d8d527307ad8f",
+        "fileName": "Digital Asset Risks.md",
+        "fileSize": "38439",
+        "hyperlinkCount": "44",
+        "lastModified": "2025-02-15 16:09:29.355707483 UTC",
+        "metadataId": "Digital Asset Risks"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "61",
+      "metadataId": "Spatial Computing",
+      "label": "Spatial Computing",
+      "data": {
+        "position": {
+          "x": 0.4360243,
+          "y": 0.12575532,
+          "z": -0.1360997
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Spatial Computing",
+        "fileSize": "1826",
+        "sha1": "d64ca32560b184a8eb58641bc7d75581719dd690",
+        "fileName": "Spatial Computing.md",
+        "metadataId": "Spatial Computing",
+        "lastModified": "2025-02-15 16:12:25.359072746 UTC",
+        "nodeSize": "21.434",
+        "hyperlinkCount": "0"
+      },
+      "size": 21.434
+    },
+    {
+      "id": "62",
+      "metadataId": "Product Design",
+      "label": "Product Design",
+      "data": {
+        "position": {
+          "x": 0.5688522,
+          "y": -0.917505,
+          "z": 0.2530758
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 31,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "81911",
+        "name": "Product Design",
+        "sha1": "22ffc2508d3dcbf8d8dc01faeebd565744d2d489",
+        "metadataId": "Product Design",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:11:42.535919767 UTC",
+        "hyperlinkCount": "12",
+        "fileName": "Product Design.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "63",
+      "metadataId": "Digital Society Surveillance",
+      "label": "Digital Society Surveillance",
+      "data": {
+        "position": {
+          "x": 0.5060682,
+          "y": 0.6570699,
+          "z": -0.6365892
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 30,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:09:32.175272225 UTC",
+        "fileSize": "52788",
+        "sha1": "6498fbb9ed954e41ab3fe2e12306de948e8a08ff",
+        "nodeSize": "50",
+        "hyperlinkCount": "71",
+        "name": "Digital Society Surveillance",
+        "metadataId": "Digital Society Surveillance",
+        "fileName": "Digital Society Surveillance.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "64",
+      "metadataId": "Hardware and Edge",
+      "label": "Hardware and Edge",
+      "data": {
+        "position": {
+          "x": -0.1772504,
+          "y": 0.54174215,
+          "z": 0.10417806
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "70",
+        "name": "Hardware and Edge",
+        "fileName": "Hardware and Edge.md",
+        "sha1": "c2a9767c9ac8040522a7f6af45bc343f7072f7dc",
+        "fileSize": "32615",
+        "metadataId": "Hardware and Edge",
+        "lastModified": "2025-02-15 16:10:12.099057661 UTC",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "65",
+      "metadataId": "RGB and Client Side Validation",
+      "label": "RGB and Client Side Validation",
+      "data": {
+        "position": {
+          "x": 0.3564558,
+          "y": -0.13482508,
+          "z": 0.4604132
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:11:57.293154399 UTC",
+        "hyperlinkCount": "29",
+        "name": "RGB and Client Side Validation",
+        "fileName": "RGB and Client Side Validation.md",
+        "fileSize": "8861",
+        "nodeSize": "50",
+        "sha1": "daa7038a18ff53c3e567f440755a67b51ab9a370",
+        "metadataId": "RGB and Client Side Validation"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "66",
+      "metadataId": "AI Risks",
+      "label": "AI Risks",
+      "data": {
+        "position": {
+          "x": 0.50849277,
+          "y": -0.43357816,
+          "z": -0.2801116
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "AI Risks.md",
+        "name": "AI Risks",
+        "nodeSize": "50",
+        "hyperlinkCount": "2",
+        "metadataId": "AI Risks",
+        "sha1": "fc156c54813de56f665ebad8fd26be1be2be5cda",
+        "lastModified": "2025-02-15 16:08:09.556088833 UTC",
+        "fileSize": "5071"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "67",
+      "metadataId": "Comfy UI for Fashion and Brands",
+      "label": "Comfy UI for Fashion and Brands",
+      "data": {
+        "position": {
+          "x": -0.8584334,
+          "y": 0.22904505,
+          "z": -0.29750317
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Comfy UI for Fashion and Brands.md",
+        "sha1": "7384b47977d8ab00d025bfaecb493c12a246b74b",
+        "fileSize": "11244",
+        "metadataId": "Comfy UI for Fashion and Brands",
+        "name": "Comfy UI for Fashion and Brands",
+        "lastModified": "2025-02-15 16:08:56.125990767 UTC",
+        "hyperlinkCount": "22",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "68",
+      "metadataId": "Jailbreaking",
+      "label": "Jailbreaking",
+      "data": {
+        "position": {
+          "x": 0.35142133,
+          "y": -0.23203672,
+          "z": -0.8989939
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 18,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:10:26.694155106 UTC",
+        "sha1": "6fa1bba1681cfa8ce33c5055fd26cea85af70d43",
+        "fileSize": "911",
+        "nodeSize": "13.199000000000002",
+        "hyperlinkCount": "3",
+        "metadataId": "Jailbreaking",
+        "fileName": "Jailbreaking.md",
+        "name": "Jailbreaking"
+      },
+      "size": 13.199
+    },
+    {
+      "id": "69",
+      "metadataId": "Anthropic Claude",
+      "label": "Anthropic Claude",
+      "data": {
+        "position": {
+          "x": -0.2789455,
+          "y": 0.09097913,
+          "z": -0.8963387
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Anthropic Claude",
+        "hyperlinkCount": "5",
+        "fileSize": "1398",
+        "lastModified": "2025-02-15 16:08:26.744968346 UTC",
+        "nodeSize": "17.582",
+        "sha1": "65cf23d3d5b32eaf4721a5f7004e42101a1b4dfb",
+        "fileName": "Anthropic Claude.md",
+        "metadataId": "Anthropic Claude"
+      },
+      "size": 17.582
+    },
+    {
+      "id": "70",
+      "metadataId": "SLAM",
+      "label": "SLAM",
+      "data": {
+        "position": {
+          "x": -1.2693576,
+          "y": -0.41975993,
+          "z": 0.78593564
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 15,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "SLAM.md",
+        "metadataId": "SLAM",
+        "fileSize": "312",
+        "name": "SLAM",
+        "hyperlinkCount": "1",
+        "nodeSize": "7.808",
+        "sha1": "d6805bce5393bcfecde2d257b339882c9cb4bcca",
+        "lastModified": "2025-02-15 16:12:11.973980434 UTC"
+      },
+      "size": 7.808
+    },
+    {
+      "id": "71",
+      "metadataId": "Recent Projects",
+      "label": "Recent Projects",
+      "data": {
+        "position": {
+          "x": 0.02320664,
+          "y": 0.9154576,
+          "z": 0.12117805
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "1485",
+        "fileName": "Recent Projects.md",
+        "nodeSize": "18.365",
+        "hyperlinkCount": "14",
+        "metadataId": "Recent Projects",
+        "sha1": "f725558205279fcaacd1c0c080db336bd8453b88",
+        "lastModified": "2025-02-15 16:12:00.729792655 UTC",
+        "name": "Recent Projects"
+      },
+      "size": 18.365
+    },
+    {
+      "id": "72",
+      "metadataId": "Competition in AI",
+      "label": "Competition in AI",
+      "data": {
+        "position": {
+          "x": 0.21842718,
+          "y": 0.28283474,
+          "z": 0.7333961
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Competition in AI",
+        "metadataId": "Competition in AI",
+        "lastModified": "2025-02-15 16:09:01.494474893 UTC",
+        "nodeSize": "26.051",
+        "sha1": "883b2c86288efd73e2ecfc008638840f9d9237a0",
+        "hyperlinkCount": "1",
+        "fileName": "Competition in AI.md",
+        "fileSize": "2339"
+      },
+      "size": 26.051
+    },
+    {
+      "id": "73",
+      "metadataId": "Segmentation and Identification",
+      "label": "Segmentation and Identification",
+      "data": {
+        "position": {
+          "x": -0.056164134,
+          "y": 0.26865128,
+          "z": -0.71386874
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:12:16.925793627 UTC",
+        "name": "Segmentation and Identification",
+        "fileName": "Segmentation and Identification.md",
+        "sha1": "e480903264d84b2b44a81f74f0610b9dd34e1bf0",
+        "hyperlinkCount": "24",
+        "fileSize": "6843",
+        "metadataId": "Segmentation and Identification"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "74",
+      "metadataId": "Automated Podcast Project",
+      "label": "Automated Podcast Project",
+      "data": {
+        "position": {
+          "x": 0.56817716,
+          "y": 0.29362476,
+          "z": 1.1375093
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Automated Podcast Project",
+        "lastModified": "2025-02-15 16:08:33.168468016 UTC",
+        "metadataId": "Automated Podcast Project",
+        "fileName": "Automated Podcast Project.md",
+        "sha1": "7f2b6e7a9d0ee3e2ea7ed7aff67d22ceae6180c4",
+        "nodeSize": "50",
+        "hyperlinkCount": "1",
+        "fileSize": "10866"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "75",
+      "metadataId": "Multi Agent RAG scrapbook",
+      "label": "Multi Agent RAG scrapbook",
+      "data": {
+        "position": {
+          "x": -0.41038123,
+          "y": 0.4193338,
+          "z": -0.5064042
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "34e5bfbbd0d31a1c9b90ef203f1eb0cd16c54d2f",
+        "name": "Multi Agent RAG scrapbook",
+        "fileName": "Multi Agent RAG scrapbook.md",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:11:12.658604680 UTC",
+        "fileSize": "6497",
+        "hyperlinkCount": "1",
+        "metadataId": "Multi Agent RAG scrapbook"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "76",
+      "metadataId": "Hyper personalisation",
+      "label": "Hyper personalisation",
+      "data": {
+        "position": {
+          "x": 0.948385,
+          "y": 0.3024914,
+          "z": -0.71639264
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "1",
+        "lastModified": "2025-02-15 16:10:18.978104130 UTC",
+        "fileName": "Hyper personalisation.md",
+        "nodeSize": "33.035000000000004",
+        "sha1": "81e179362c4fd474c67104b9eb3fed70e733bdba",
+        "metadataId": "Hyper personalisation",
+        "fileSize": "3115",
+        "name": "Hyper personalisation"
+      },
+      "size": 33.035
+    },
+    {
+      "id": "77",
+      "metadataId": "Proprietary Video",
+      "label": "Proprietary Video",
+      "data": {
+        "position": {
+          "x": -0.5056191,
+          "y": -0.66759,
+          "z": 0.24260488
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:11:48.156871075 UTC",
+        "fileSize": "6701",
+        "fileName": "Proprietary Video.md",
+        "hyperlinkCount": "17",
+        "metadataId": "Proprietary Video",
+        "name": "Proprietary Video",
+        "nodeSize": "50",
+        "sha1": "40e0eafbd4bdd8079761b3e807030f4934093222"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "78",
+      "metadataId": "Geopolitical hot takes",
+      "label": "Geopolitical hot takes",
+      "data": {
+        "position": {
+          "x": -0.109501325,
+          "y": -0.38336548,
+          "z": -1.1442385
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Geopolitical hot takes.md",
+        "name": "Geopolitical hot takes",
+        "nodeSize": "50",
+        "sha1": "cbf1b708951e324b173b654c2a398075b514bdc2",
+        "hyperlinkCount": "0",
+        "fileSize": "15425",
+        "metadataId": "Geopolitical hot takes",
+        "lastModified": "2025-02-15 16:10:04.376057503 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "79",
+      "metadataId": "Financialised Agentic Memetics",
+      "label": "Financialised Agentic Memetics",
+      "data": {
+        "position": {
+          "x": -0.3028808,
+          "y": 1.4178476,
+          "z": 0.92186844
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "7e32c48849f9bbabc5a9004d1c97fceb0e78510a",
+        "hyperlinkCount": "1",
+        "fileName": "Financialised Agentic Memetics.md",
+        "nodeSize": "26.978",
+        "lastModified": "2025-02-15 16:09:54.400339386 UTC",
+        "name": "Financialised Agentic Memetics",
+        "metadataId": "Financialised Agentic Memetics",
+        "fileSize": "2442"
+      },
+      "size": 26.978
+    },
+    {
+      "id": "80",
+      "metadataId": "Education and AI",
+      "label": "Education and AI",
+      "data": {
+        "position": {
+          "x": -0.08454015,
+          "y": 0.36674145,
+          "z": -0.09930666
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "f8162d1c848cb858cc121d2f5a39f9b6555cd667",
+        "nodeSize": "50",
+        "name": "Education and AI",
+        "fileName": "Education and AI.md",
+        "lastModified": "2025-02-15 16:09:38.560726838 UTC",
+        "hyperlinkCount": "17",
+        "fileSize": "15391",
+        "metadataId": "Education and AI"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "81",
+      "metadataId": "Proprietary AI Video",
+      "label": "Proprietary AI Video",
+      "data": {
+        "position": {
+          "x": -0.8601347,
+          "y": 1.2536836,
+          "z": 0.3240547
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "4",
+        "sha1": "02045730ff4fd31d448cc16b1833d156e193ff8f",
+        "fileSize": "5154",
+        "name": "Proprietary AI Video",
+        "fileName": "Proprietary AI Video.md",
+        "metadataId": "Proprietary AI Video",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:11:45.451639030 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "82",
+      "metadataId": "ollama",
+      "label": "ollama",
+      "data": {
+        "position": {
+          "x": 0.2574208,
+          "y": -0.07029418,
+          "z": -0.79601747
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "ollama",
+        "fileName": "ollama.md",
+        "hyperlinkCount": "6",
+        "sha1": "6b576d3460d1633e9623990ebbe8adb4f2d596ba",
+        "metadataId": "ollama",
+        "nodeSize": "22.316",
+        "lastModified": "2025-02-15 16:13:42.433099358 UTC",
+        "fileSize": "1924"
+      },
+      "size": 22.316
+    },
+    {
+      "id": "83",
+      "metadataId": "California AI bill",
+      "label": "California AI bill",
+      "data": {
+        "position": {
+          "x": -0.19128512,
+          "y": -0.6016167,
+          "z": -0.70433736
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "24bb18205e4e37e20704b73f32b1c2b28b7dae3f",
+        "lastModified": "2025-02-15 16:08:49.132625279 UTC",
+        "fileSize": "5403",
+        "fileName": "California AI bill.md",
+        "hyperlinkCount": "0",
+        "metadataId": "California AI bill",
+        "name": "California AI bill",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "84",
+      "metadataId": "cypherpunk",
+      "label": "cypherpunk",
+      "data": {
+        "position": {
+          "x": 0.26234722,
+          "y": -0.15106861,
+          "z": 0.07442324
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "name": "cypherpunk",
+        "fileSize": "5430",
+        "hyperlinkCount": "3",
+        "metadataId": "cypherpunk",
+        "fileName": "cypherpunk.md",
+        "sha1": "7dcc1520963f17ce76ce5431643f30f8bc65945c",
+        "lastModified": "2025-02-15 16:13:17.547033376 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "85",
+      "metadataId": "Ai in Games",
+      "label": "Ai in Games",
+      "data": {
+        "position": {
+          "x": -0.10522449,
+          "y": 0.605661,
+          "z": 0.4242827
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "12",
+        "lastModified": "2025-02-15 16:08:24.599117478 UTC",
+        "fileSize": "3232",
+        "fileName": "Ai in Games.md",
+        "sha1": "eae8c355131e3fa2ca3588f4ab9ec6965285e500",
+        "name": "Ai in Games",
+        "metadataId": "Ai in Games",
+        "nodeSize": "34.088"
+      },
+      "size": 34.088
+    },
+    {
+      "id": "86",
+      "metadataId": "relighting",
+      "label": "relighting",
+      "data": {
+        "position": {
+          "x": 0.47225505,
+          "y": 1.0220293,
+          "z": 0.3550468
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 19,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:13:45.174176857 UTC",
+        "nodeSize": "17.312",
+        "fileSize": "1368",
+        "metadataId": "relighting",
+        "hyperlinkCount": "8",
+        "fileName": "relighting.md",
+        "name": "relighting",
+        "sha1": "a24ca5fed1ec96c1e33cd6199964eb152077dc3a"
+      },
+      "size": 17.312
+    },
+    {
+      "id": "87",
+      "metadataId": "Human vs AI",
+      "label": "Human vs AI",
+      "data": {
+        "position": {
+          "x": -0.07025836,
+          "y": -0.11407522,
+          "z": 0.25552756
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "sha1": "b58000500c57498c0185bae55711f3c39a6e4b80",
+        "metadataId": "Human vs AI",
+        "lastModified": "2025-02-15 16:10:16.347956259 UTC",
+        "name": "Human vs AI",
+        "fileSize": "5108",
+        "hyperlinkCount": "2",
+        "fileName": "Human vs AI.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "88",
+      "metadataId": "collaborative",
+      "label": "collaborative",
+      "data": {
+        "position": {
+          "x": 1.4486557,
+          "y": 0.6201066,
+          "z": -0.01795115
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 7,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "5.126",
+        "fileSize": "14",
+        "name": "collaborative",
+        "hyperlinkCount": "0",
+        "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+        "lastModified": "2025-02-15 16:13:15.322362153 UTC",
+        "metadataId": "collaborative",
+        "fileName": "collaborative.md"
+      },
+      "size": 5.126
+    },
+    {
+      "id": "89",
+      "metadataId": "Distributed Identity",
+      "label": "Distributed Identity",
+      "data": {
+        "position": {
+          "x": 0.97623724,
+          "y": 0.6173238,
+          "z": -0.4079412
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 30,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "hyperlinkCount": "57",
+        "sha1": "6bb3713d9a67ab162c1e85746b1dd741b8bfa663",
+        "fileSize": "59124",
+        "fileName": "Distributed Identity.md",
+        "metadataId": "Distributed Identity",
+        "lastModified": "2025-02-15 16:09:34.405788583 UTC",
+        "name": "Distributed Identity"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "90",
+      "metadataId": "Virtual Production",
+      "label": "Virtual Production",
+      "data": {
+        "position": {
+          "x": -0.010887738,
+          "y": 0.29631472,
+          "z": 0.3222138
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "6",
+        "fileSize": "2609",
+        "nodeSize": "28.481",
+        "sha1": "f9f234812f66506b78e20ef08ce993a37fabb292",
+        "fileName": "Virtual Production.md",
+        "lastModified": "2025-02-15 16:13:00.019129649 UTC",
+        "name": "Virtual Production",
+        "metadataId": "Virtual Production"
+      },
+      "size": 28.481
+    },
+    {
+      "id": "91",
+      "metadataId": "LoRA DoRA etc",
+      "label": "LoRA DoRA etc",
+      "data": {
+        "position": {
+          "x": -0.30272678,
+          "y": -0.038715903,
+          "z": 0.7569292
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "1519",
+        "hyperlinkCount": "5",
+        "name": "LoRA DoRA etc",
+        "metadataId": "LoRA DoRA etc",
+        "fileName": "LoRA DoRA etc.md",
+        "lastModified": "2025-02-15 16:10:48.006668500 UTC",
+        "nodeSize": "18.671",
+        "sha1": "f2ca6b16d5c13d756118bbaef014d35e338fa585"
+      },
+      "size": 18.671
+    },
+    {
+      "id": "92",
+      "metadataId": "Blockchain",
+      "label": "Blockchain",
+      "data": {
+        "position": {
+          "x": -0.3754655,
+          "y": -0.15242623,
+          "z": -0.49783072
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "21",
+        "lastModified": "2025-02-15 16:08:45.038036525 UTC",
+        "sha1": "5c0a8a95b0cb6348580015f65949f5d8caa6a048",
+        "nodeSize": "50",
+        "fileName": "Blockchain.md",
+        "name": "Blockchain",
+        "fileSize": "15132",
+        "metadataId": "Blockchain"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "93",
+      "metadataId": "Apple",
+      "label": "Apple",
+      "data": {
+        "position": {
+          "x": 1.2345713,
+          "y": 0.2667729,
+          "z": 1.2264614
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "87a7b91113b19f4a322190d329bc8e30aa366200",
+        "fileSize": "9598",
+        "fileName": "Apple.md",
+        "metadataId": "Apple",
+        "hyperlinkCount": "6",
+        "nodeSize": "50",
+        "name": "Apple",
+        "lastModified": "2025-02-15 16:08:29.030374909 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "94",
+      "metadataId": "Text to 3D and 4D",
+      "label": "Text to 3D and 4D",
+      "data": {
+        "position": {
+          "x": 0.36303872,
+          "y": 0.36250836,
+          "z": 0.42385787
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:12:41.499155472 UTC",
+        "sha1": "60d3e231f8ce48115b7b45607c315b51aab36b90",
+        "fileName": "Text to 3D and 4D.md",
+        "metadataId": "Text to 3D and 4D",
+        "hyperlinkCount": "48",
+        "nodeSize": "50",
+        "name": "Text to 3D and 4D",
+        "fileSize": "8515"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "95",
+      "metadataId": "Parametric",
+      "label": "Parametric",
+      "data": {
+        "position": {
+          "x": 0.7476256,
+          "y": -0.92272323,
+          "z": -0.14439291
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Parametric",
+        "metadataId": "Parametric",
+        "lastModified": "2025-02-15 16:11:29.425478711 UTC",
+        "nodeSize": "50",
+        "sha1": "d3c14a3ee65e689a3d76a5aed5bb53177bf71376",
+        "fileSize": "6574",
+        "fileName": "Parametric.md",
+        "hyperlinkCount": "4"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "96",
+      "metadataId": "Bitcoin ETF",
+      "label": "Bitcoin ETF",
+      "data": {
+        "position": {
+          "x": -0.29105252,
+          "y": -0.24466592,
+          "z": 0.9203923
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Bitcoin ETF",
+        "sha1": "d19a4e9a7d54f3278dd7a1432916260efd1e833e",
+        "fileName": "Bitcoin ETF.md",
+        "fileSize": "6185",
+        "lastModified": "2025-02-15 16:08:38.701106780 UTC",
+        "name": "Bitcoin ETF",
+        "nodeSize": "50",
+        "hyperlinkCount": "2"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "97",
+      "metadataId": "Robotics",
+      "label": "Robotics",
+      "data": {
+        "position": {
+          "x": -0.18441771,
+          "y": 0.15398473,
+          "z": -0.32475942
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Robotics",
+        "fileName": "Robotics.md",
+        "name": "Robotics",
+        "lastModified": "2025-02-15 16:12:05.773520935 UTC",
+        "nodeSize": "20.776999999999997",
+        "sha1": "fb5790a6ec0327b53634a26c7579d6b3d9716c32",
+        "fileSize": "1753",
+        "hyperlinkCount": "10"
+      },
+      "size": 20.777
+    },
+    {
+      "id": "98",
+      "metadataId": "Comparison of GPT4 and Gemini Ultra",
+      "label": "Comparison of GPT4 and Gemini Ultra",
+      "data": {
+        "position": {
+          "x": -0.42741948,
+          "y": 0.42753014,
+          "z": -0.036835603
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Comparison of GPT4 and Gemini Ultra",
+        "hyperlinkCount": "0",
+        "lastModified": "2025-02-15 16:08:59.540459045 UTC",
+        "sha1": "98ef9ac102777f21411b105b6b3ef860af297228",
+        "fileName": "Comparison of GPT4 and Gemini Ultra.md",
+        "fileSize": "3048",
+        "metadataId": "Comparison of GPT4 and Gemini Ultra",
+        "nodeSize": "32.432"
+      },
+      "size": 32.432
+    },
+    {
+      "id": "99",
+      "metadataId": "Leopold Aschenbrenner",
+      "label": "Leopold Aschenbrenner",
+      "data": {
+        "position": {
+          "x": -0.35267177,
+          "y": 1.0349182,
+          "z": 0.21059196
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Leopold Aschenbrenner",
+        "lastModified": "2025-02-15 16:10:40.181085166 UTC",
+        "nodeSize": "50",
+        "metadataId": "Leopold Aschenbrenner",
+        "hyperlinkCount": "2",
+        "fileName": "Leopold Aschenbrenner.md",
+        "fileSize": "8770",
+        "sha1": "b5949a72d7b4c0fc5e18120b6480c062ad8d1bbc"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "100",
+      "metadataId": "Haptics",
+      "label": "Haptics",
+      "data": {
+        "position": {
+          "x": 0.20750925,
+          "y": 0.47059035,
+          "z": -0.39318815
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 7,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Haptics.md",
+        "hyperlinkCount": "0",
+        "name": "Haptics",
+        "fileSize": "16",
+        "sha1": "b729c028abdf7b08d903806bd908f8f5ec382581",
+        "metadataId": "Haptics",
+        "lastModified": "2025-02-15 16:10:11.347235432 UTC",
+        "nodeSize": "5.144"
+      },
+      "size": 5.144
+    },
+    {
+      "id": "101",
+      "metadataId": "AI Scrapers",
+      "label": "AI Scrapers",
+      "data": {
+        "position": {
+          "x": -0.14374252,
+          "y": 0.6413538,
+          "z": -0.3346688
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "AI Scrapers",
+        "lastModified": "2025-02-15 16:08:10.325289187 UTC",
+        "nodeSize": "37.355",
+        "sha1": "c40d851b73a53207c202885fb87f8a254c48e3d0",
+        "fileName": "AI Scrapers.md",
+        "fileSize": "3595",
+        "metadataId": "AI Scrapers",
+        "hyperlinkCount": "6"
+      },
+      "size": 37.355
+    },
+    {
+      "id": "102",
+      "metadataId": "Research Tools",
+      "label": "Research Tools",
+      "data": {
+        "position": {
+          "x": -0.7444064,
+          "y": 0.6388756,
+          "z": -0.089957066
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "8185",
+        "fileName": "Research Tools.md",
+        "lastModified": "2025-02-15 16:12:02.225944520 UTC",
+        "hyperlinkCount": "8",
+        "sha1": "5ee11413b4e4ba0d6004ed2846bab5404581d0b0",
+        "metadataId": "Research Tools",
+        "name": "Research Tools",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "103",
+      "metadataId": "Evaluation benchmarks and leaderboards",
+      "label": "Evaluation benchmarks and leaderboards",
+      "data": {
+        "position": {
+          "x": 0.40842617,
+          "y": -0.42665288,
+          "z": -0.6032411
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 19,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:09:45.921587518 UTC",
+        "name": "Evaluation benchmarks and leaderboards",
+        "fileSize": "1148",
+        "hyperlinkCount": "11",
+        "fileName": "Evaluation benchmarks and leaderboards.md",
+        "metadataId": "Evaluation benchmarks and leaderboards",
+        "sha1": "abe179288d5847d0574dc559988a202c5b12442a",
+        "nodeSize": "15.332"
+      },
+      "size": 15.332
+    },
+    {
+      "id": "104",
+      "metadataId": "p(doom)",
+      "label": "p(doom)",
+      "data": {
+        "position": {
+          "x": -0.22158763,
+          "y": 0.08565771,
+          "z": 0.33966577
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 17,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "p(doom)",
+        "lastModified": "2025-02-15 16:13:43.182746217 UTC",
+        "nodeSize": "10.004",
+        "hyperlinkCount": "0",
+        "metadataId": "p(doom)",
+        "fileName": "p(doom).md",
+        "sha1": "4bcd6cb13573f66ddaf86100d979acd006520f0c",
+        "fileSize": "556"
+      },
+      "size": 10.004
+    },
+    {
+      "id": "105",
+      "metadataId": "Algorithmic Bias and Variance",
+      "label": "Algorithmic Bias and Variance",
+      "data": {
+        "position": {
+          "x": -0.14484324,
+          "y": -0.1582178,
+          "z": -0.15975007
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "8489",
+        "fileName": "Algorithmic Bias and Variance.md",
+        "nodeSize": "50",
+        "metadataId": "Algorithmic Bias and Variance",
+        "sha1": "4a91499602b3f84d116606d1e29d81bc9e1255e7",
+        "lastModified": "2025-02-15 16:08:25.316091890 UTC",
+        "hyperlinkCount": "22",
+        "name": "Algorithmic Bias and Variance"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "106",
+      "metadataId": "ChatGPT",
+      "label": "ChatGPT",
+      "data": {
+        "position": {
+          "x": -0.50278044,
+          "y": 0.036911145,
+          "z": 0.07864684
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "65",
+        "name": "ChatGPT",
+        "sha1": "53c14138461a0909964f8b592e54218416b533c2",
+        "fileName": "ChatGPT.md",
+        "fileSize": "16012",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:08:51.289460693 UTC",
+        "metadataId": "ChatGPT"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "107",
+      "metadataId": "Cashu",
+      "label": "Cashu",
+      "data": {
+        "position": {
+          "x": -2.8091774,
+          "y": -0.20362307,
+          "z": -0.5754574
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Cashu",
+        "metadataId": "Cashu",
+        "sha1": "5c3ac6108ac3f371b8de92aa117e3c45bea30f5d",
+        "fileSize": "4261",
+        "lastModified": "2025-02-15 16:08:50.556219562 UTC",
+        "nodeSize": "43.349",
+        "hyperlinkCount": "7",
+        "fileName": "Cashu.md"
+      },
+      "size": 43.349
+    },
+    {
+      "id": "108",
+      "metadataId": "Cyber security and Cryptography",
+      "label": "Cyber security and Cryptography",
+      "data": {
+        "position": {
+          "x": -0.25037244,
+          "y": -0.17785612,
+          "z": 0.54272324
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:09:13.298803947 UTC",
+        "hyperlinkCount": "33",
+        "sha1": "ace29f98d0f2146bf80e622130e739488ce7ad10",
+        "metadataId": "Cyber security and Cryptography",
+        "fileSize": "16387",
+        "nodeSize": "50",
+        "name": "Cyber security and Cryptography",
+        "fileName": "Cyber security and Cryptography.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "109",
+      "metadataId": "IPAdapter",
+      "label": "IPAdapter",
+      "data": {
+        "position": {
+          "x": 0.14358881,
+          "y": -0.3313642,
+          "z": -0.16584976
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "IPAdapter",
+        "metadataId": "IPAdapter",
+        "hyperlinkCount": "1",
+        "sha1": "154e12b1e3ee28b15b101471b692dee7eb8026ff",
+        "fileSize": "4117",
+        "nodeSize": "42.053",
+        "lastModified": "2025-02-15 16:10:20.220151871 UTC",
+        "fileName": "IPAdapter.md"
+      },
+      "size": 42.053
+    },
+    {
+      "id": "110",
+      "metadataId": "Metaverse Ontology",
+      "label": "Metaverse Ontology",
+      "data": {
+        "position": {
+          "x": -0.33351278,
+          "y": -0.3358658,
+          "z": 0.44368038
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 29,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Metaverse Ontology",
+        "hyperlinkCount": "12",
+        "metadataId": "Metaverse Ontology",
+        "fileSize": "44869",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:10:58.420515750 UTC",
+        "sha1": "b63194e702dfa794f1529841ed9f0dc3632eda9e",
+        "fileName": "Metaverse Ontology.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "111",
+      "metadataId": "Flux",
+      "label": "Flux",
+      "data": {
+        "position": {
+          "x": -0.49553236,
+          "y": -0.88074845,
+          "z": 1.2195851
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "8b5e456430dadbc8eca8e732ab6a14da4eb7d905",
+        "nodeSize": "50",
+        "fileSize": "27922",
+        "name": "Flux",
+        "hyperlinkCount": "18",
+        "fileName": "Flux.md",
+        "metadataId": "Flux",
+        "lastModified": "2025-02-15 16:09:55.892726558 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "112",
+      "metadataId": "flossverse",
+      "label": "flossverse",
+      "data": {
+        "position": {
+          "x": -0.5400987,
+          "y": 0.0016429251,
+          "z": 0.6227929
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "3984",
+        "lastModified": "2025-02-15 16:13:23.035476641 UTC",
+        "sha1": "a8b2f934290c28035ba5f53737e36dd1e3d4997f",
+        "nodeSize": "40.856",
+        "hyperlinkCount": "4",
+        "metadataId": "flossverse",
+        "name": "flossverse",
+        "fileName": "flossverse.md"
+      },
+      "size": 40.856
+    },
+    {
+      "id": "113",
+      "metadataId": "nostr",
+      "label": "nostr",
+      "data": {
+        "position": {
+          "x": -1.4240758,
+          "y": 0.42887372,
+          "z": 0.28009623
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 29,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "nostr",
+        "fileSize": "41170",
+        "nodeSize": "50",
+        "hyperlinkCount": "31",
+        "fileName": "nostr.md",
+        "sha1": "d86ac5484f8006122b60f43c3355e07b484b3313",
+        "lastModified": "2025-02-15 16:13:41.696878030 UTC",
+        "metadataId": "nostr"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "114",
+      "metadataId": "OpenAI",
+      "label": "OpenAI",
+      "data": {
+        "position": {
+          "x": -0.582105,
+          "y": 0.25291717,
+          "z": 0.79005396
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 11,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "59",
+        "nodeSize": "5.531",
+        "sha1": "c57f67f385311e21f99ab67644e7255e55f527f8",
+        "fileName": "OpenAI.md",
+        "lastModified": "2025-02-15 16:11:22.212485169 UTC",
+        "metadataId": "OpenAI",
+        "hyperlinkCount": "0",
+        "name": "OpenAI"
+      },
+      "size": 5.531
+    },
+    {
+      "id": "115",
+      "metadataId": "Papers Of Note",
+      "label": "Papers Of Note",
+      "data": {
+        "position": {
+          "x": -2.874172,
+          "y": 0.8145041,
+          "z": -0.917652
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 32,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Papers Of Note.md",
+        "lastModified": "2025-02-15 16:11:28.678166519 UTC",
+        "name": "Papers Of Note",
+        "nodeSize": "50",
+        "metadataId": "Papers Of Note",
+        "hyperlinkCount": "478",
+        "sha1": "5b327c4178037b4f6eacfd45d7b350497135941d",
+        "fileSize": "119797"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "116",
+      "metadataId": "Agentic Alliance",
+      "label": "Agentic Alliance",
+      "data": {
+        "position": {
+          "x": -0.41194242,
+          "y": -0.039594024,
+          "z": 0.50735337
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Agentic Alliance",
+        "hyperlinkCount": "3",
+        "nodeSize": "50",
+        "fileName": "Agentic Alliance.md",
+        "fileSize": "8731",
+        "name": "Agentic Alliance",
+        "lastModified": "2025-02-15 16:08:21.238878106 UTC",
+        "sha1": "ceb39eb3f435bec4fdeca4f288c45bb0d53b0f3c"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "117",
+      "metadataId": "Diffusion Models",
+      "label": "Diffusion Models",
+      "data": {
+        "position": {
+          "x": 0.14894953,
+          "y": 0.1539898,
+          "z": -0.2903194
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 7,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Diffusion Models.md",
+        "name": "Diffusion Models",
+        "metadataId": "Diffusion Models",
+        "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+        "lastModified": "2025-02-15 16:09:28.633189955 UTC",
+        "hyperlinkCount": "0",
+        "nodeSize": "5.126",
+        "fileSize": "14"
+      },
+      "size": 5.126
+    },
+    {
+      "id": "118",
+      "metadataId": "EU AI Act",
+      "label": "EU AI Act",
+      "data": {
+        "position": {
+          "x": -0.5505762,
+          "y": -0.24505162,
+          "z": 0.75014496
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "3",
+        "fileSize": "3083",
+        "nodeSize": "32.747",
+        "name": "EU AI Act",
+        "lastModified": "2025-02-15 16:09:37.110117398 UTC",
+        "metadataId": "EU AI Act",
+        "fileName": "EU AI Act.md",
+        "sha1": "8011544e9477ea2abff18e4ef87491413610bb83"
+      },
+      "size": 32.747
+    },
+    {
+      "id": "119",
+      "metadataId": "Inpainting",
+      "label": "Inpainting",
+      "data": {
+        "position": {
+          "x": 0.51762134,
+          "y": -0.048159823,
+          "z": -0.27680758
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 11,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:10:22.504679687 UTC",
+        "nodeSize": "5.531",
+        "name": "Inpainting",
+        "fileSize": "59",
+        "hyperlinkCount": "0",
+        "sha1": "c57f67f385311e21f99ab67644e7255e55f527f8",
+        "fileName": "Inpainting.md",
+        "metadataId": "Inpainting"
+      },
+      "size": 5.531
+    },
+    {
+      "id": "120",
+      "metadataId": "Introduction to me",
+      "label": "Introduction to me",
+      "data": {
+        "position": {
+          "x": 0.26517615,
+          "y": -0.5313017,
+          "z": 0.4003252
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "hyperlinkCount": "12",
+        "name": "Introduction to me",
+        "metadataId": "Introduction to me",
+        "fileName": "Introduction to me.md",
+        "fileSize": "5006",
+        "sha1": "fac7bda18f6960d752787d0ee522eb84567f7729",
+        "lastModified": "2025-02-15 16:10:25.941391561 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "121",
+      "metadataId": "NVIDIA Omniverse",
+      "label": "NVIDIA Omniverse",
+      "data": {
+        "position": {
+          "x": 0.97129065,
+          "y": -0.39421287,
+          "z": -0.251222
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "sha1": "c75db8022df635790212415dd45912c4faf0627d",
+        "lastModified": "2025-02-15 16:11:14.628117500 UTC",
+        "fileSize": "8803",
+        "fileName": "NVIDIA Omniverse.md",
+        "metadataId": "NVIDIA Omniverse",
+        "name": "NVIDIA Omniverse",
+        "hyperlinkCount": "1"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "122",
+      "metadataId": "Stable Coins",
+      "label": "Stable Coins",
+      "data": {
+        "position": {
+          "x": -0.34266737,
+          "y": -0.3834462,
+          "z": 0.73568064
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "name": "Stable Coins",
+        "hyperlinkCount": "33",
+        "metadataId": "Stable Coins",
+        "fileSize": "18917",
+        "sha1": "552f0f022b34904a3a5279fba93d708826ef0a75",
+        "lastModified": "2025-02-15 16:12:28.081304407 UTC",
+        "fileName": "Stable Coins.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "123",
+      "metadataId": "Deepfakes and fraudulent content",
+      "label": "Deepfakes and fraudulent content",
+      "data": {
+        "position": {
+          "x": -0.018165717,
+          "y": -0.3612301,
+          "z": 0.66064906
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Deepfakes and fraudulent content",
+        "sha1": "3647f419f6285abdc0a5313bf8375a5df40bd68d",
+        "fileName": "Deepfakes and fraudulent content.md",
+        "nodeSize": "18.113",
+        "fileSize": "1457",
+        "lastModified": "2025-02-15 16:09:23.689444291 UTC",
+        "metadataId": "Deepfakes and fraudulent content",
+        "hyperlinkCount": "8"
+      },
+      "size": 18.113
+    },
+    {
+      "id": "124",
+      "metadataId": "Vesuvian Scrolls",
+      "label": "Vesuvian Scrolls",
+      "data": {
+        "position": {
+          "x": -0.37699792,
+          "y": -0.6339544,
+          "z": -0.1443599
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "2741",
+        "name": "Vesuvian Scrolls",
+        "metadataId": "Vesuvian Scrolls",
+        "lastModified": "2025-02-15 16:12:56.550447659 UTC",
+        "sha1": "68081aa4856d1e568aff2fc04622dba695a36b73",
+        "fileName": "Vesuvian Scrolls.md",
+        "hyperlinkCount": "3",
+        "nodeSize": "29.669"
+      },
+      "size": 29.669
+    },
+    {
+      "id": "125",
+      "metadataId": "Metaverse as Markets",
+      "label": "Metaverse as Markets",
+      "data": {
+        "position": {
+          "x": 0.031049078,
+          "y": 0.05414301,
+          "z": -0.48191035
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Metaverse as Markets",
+        "fileSize": "11006",
+        "nodeSize": "50",
+        "hyperlinkCount": "7",
+        "sha1": "1084bcea8cecdc3b3d6bcbd4ace9788d800b5dd3",
+        "fileName": "Metaverse as Markets.md",
+        "metadataId": "Metaverse as Markets",
+        "lastModified": "2025-02-15 16:11:01.136771278 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "126",
+      "metadataId": "Soon-Next-Later (AI futurology)",
+      "label": "Soon-Next-Later (AI futurology)",
+      "data": {
+        "position": {
+          "x": 0.35961676,
+          "y": 0.31317773,
+          "z": -0.6058813
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "7",
+        "name": "Soon-Next-Later (AI futurology)",
+        "sha1": "97430e99a9729dff31703fdea9ca54aa9956e021",
+        "fileSize": "12919",
+        "lastModified": "2025-02-15 16:12:23.833211039 UTC",
+        "metadataId": "Soon-Next-Later (AI futurology)",
+        "nodeSize": "50",
+        "fileName": "Soon-Next-Later (AI futurology).md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "127",
+      "metadataId": "Gold",
+      "label": "Gold",
+      "data": {
+        "position": {
+          "x": -0.14646955,
+          "y": -1.1880991,
+          "z": 0.21643643
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Gold",
+        "nodeSize": "50",
+        "name": "Gold",
+        "lastModified": "2025-02-15 16:10:05.855617981 UTC",
+        "sha1": "335a427e3d14b167293ad21087ff24500f64c4f6",
+        "hyperlinkCount": "2",
+        "fileName": "Gold.md",
+        "fileSize": "5494"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "128",
+      "metadataId": "Medical AI",
+      "label": "Medical AI",
+      "data": {
+        "position": {
+          "x": -0.7584186,
+          "y": 0.3510644,
+          "z": -1.0474725
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "18110",
+        "name": "Medical AI",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:10:55.678053979 UTC",
+        "metadataId": "Medical AI",
+        "hyperlinkCount": "17",
+        "fileName": "Medical AI.md",
+        "sha1": "dd458f6f92dec20c2a90787ec3b66a15c228f2f8"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "129",
+      "metadataId": "Accessibility",
+      "label": "Accessibility",
+      "data": {
+        "position": {
+          "x": -0.31694955,
+          "y": 0.4677089,
+          "z": 0.61926216
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Accessibility",
+        "hyperlinkCount": "14",
+        "fileName": "Accessibility.md",
+        "fileSize": "17789",
+        "lastModified": "2025-02-15 16:08:17.847536999 UTC",
+        "nodeSize": "50",
+        "sha1": "4a73e2c254231436de5c0540a1864169f7b075bc",
+        "name": "Accessibility"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "130",
+      "metadataId": "Llama",
+      "label": "Llama",
+      "data": {
+        "position": {
+          "x": -0.1585331,
+          "y": -1.229453,
+          "z": -0.7878402
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Llama",
+        "sha1": "17bedfd3acc866c641f2d5d5b0afea83475ca516",
+        "name": "Llama",
+        "fileName": "Llama.md",
+        "fileSize": "3432",
+        "lastModified": "2025-02-15 16:10:47.270258004 UTC",
+        "nodeSize": "35.888",
+        "hyperlinkCount": "4"
+      },
+      "size": 35.888
+    },
+    {
+      "id": "131",
+      "metadataId": "Layoff tracker and threatened roles",
+      "label": "Layoff tracker and threatened roles",
+      "data": {
+        "position": {
+          "x": 0.81013656,
+          "y": -0.18596548,
+          "z": -0.2074381
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "35.672",
+        "fileSize": "3408",
+        "metadataId": "Layoff tracker and threatened roles",
+        "fileName": "Layoff tracker and threatened roles.md",
+        "name": "Layoff tracker and threatened roles",
+        "sha1": "41bce0decc00e5dbf9d0dd3004275157ce59b3e8",
+        "lastModified": "2025-02-15 16:10:37.639719073 UTC",
+        "hyperlinkCount": "6"
+      },
+      "size": 35.672
+    },
+    {
+      "id": "132",
+      "metadataId": "license",
+      "label": "license",
+      "data": {
+        "position": {
+          "x": 0.0901309,
+          "y": 1.1764983,
+          "z": -0.59646386
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 16,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "356",
+        "fileName": "license.md",
+        "metadataId": "license",
+        "name": "license",
+        "nodeSize": "8.204",
+        "lastModified": "2025-02-15 16:13:33.724017802 UTC",
+        "hyperlinkCount": "4",
+        "sha1": "4443a3aff6398c220a624c669be78218a91f796f"
+      },
+      "size": 8.204
+    },
+    {
+      "id": "133",
+      "metadataId": "Debug Test Page",
+      "label": "Debug Test Page",
+      "data": {
+        "position": {
+          "x": -0.46288368,
+          "y": -0.0038122544,
+          "z": 0.85244405
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 15,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "303",
+        "hyperlinkCount": "0",
+        "fileName": "Debug Test Page.md",
+        "sha1": "1e4f5b8e935780ed5ca723acc8d836ef2473a3bb",
+        "metadataId": "Debug Test Page",
+        "lastModified": "2025-02-15 16:09:19.542574920 UTC",
+        "name": "Debug Test Page",
+        "nodeSize": "7.727"
+      },
+      "size": 7.727
+    },
+    {
+      "id": "134",
+      "metadataId": "Client side DCO",
+      "label": "Client side DCO",
+      "data": {
+        "position": {
+          "x": 1.0478069,
+          "y": -0.07706101,
+          "z": 0.30604482
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Client side DCO",
+        "fileName": "Client side DCO.md",
+        "fileSize": "14735",
+        "sha1": "e49762efad2e1d5cbfc77eef626bd48f4056ebaa",
+        "hyperlinkCount": "1",
+        "name": "Client side DCO",
+        "lastModified": "2025-02-15 16:08:53.971973824 UTC",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "135",
+      "metadataId": "infrastructure",
+      "label": "infrastructure",
+      "data": {
+        "position": {
+          "x": 0.1388163,
+          "y": -0.7447661,
+          "z": -0.72854275
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:13:28.783870693 UTC",
+        "metadataId": "infrastructure",
+        "fileSize": "5571",
+        "sha1": "83ead488680945dbe08a356b008dbcee6000f990",
+        "fileName": "infrastructure.md",
+        "hyperlinkCount": "9",
+        "name": "infrastructure"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "136",
+      "metadataId": "Agentic Mycelia",
+      "label": "Agentic Mycelia",
+      "data": {
+        "position": {
+          "x": -0.6240546,
+          "y": 0.1341517,
+          "z": -0.574412
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:08:22.667701850 UTC",
+        "name": "Agentic Mycelia",
+        "fileName": "Agentic Mycelia.md",
+        "hyperlinkCount": "4",
+        "fileSize": "28645",
+        "sha1": "eba2a13d1cdcf1381b9355cb6cdda602f7df7c63",
+        "nodeSize": "50",
+        "metadataId": "Agentic Mycelia"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "137",
+      "metadataId": "Social contract and jobs",
+      "label": "Social contract and jobs",
+      "data": {
+        "position": {
+          "x": 0.36805922,
+          "y": 1.1833978,
+          "z": 0.029626844
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 29,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Social contract and jobs",
+        "hyperlinkCount": "71",
+        "fileSize": "44932",
+        "fileName": "Social contract and jobs.md",
+        "nodeSize": "50",
+        "sha1": "11a943ece9b32e32b194cc0cd95d09ee7c66498e",
+        "name": "Social contract and jobs",
+        "lastModified": "2025-02-15 16:12:21.095761947 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "138",
+      "metadataId": "Revision List",
+      "label": "Revision List",
+      "data": {
+        "position": {
+          "x": 0.3699577,
+          "y": -1.235532,
+          "z": -0.0164243
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "1",
+        "lastModified": "2025-02-15 16:12:04.240890561 UTC",
+        "metadataId": "Revision List",
+        "fileSize": "3977",
+        "sha1": "9de5dc3743751d34db958f0e3b1463d6605464a2",
+        "name": "Revision List",
+        "fileName": "Revision List.md",
+        "nodeSize": "40.793"
+      },
+      "size": 40.793
+    },
+    {
+      "id": "139",
+      "metadataId": "legacy media",
+      "label": "legacy media",
+      "data": {
+        "position": {
+          "x": 0.19641559,
+          "y": 0.79261976,
+          "z": -0.29430497
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 16,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "8.195",
+        "hyperlinkCount": "2",
+        "fileName": "legacy media.md",
+        "lastModified": "2025-02-15 16:13:32.982191741 UTC",
+        "sha1": "0aacca2e2a9a74108599260b3f8a08316b9d9aa0",
+        "name": "legacy media",
+        "metadataId": "legacy media",
+        "fileSize": "355"
+      },
+      "size": 8.195
+    },
+    {
+      "id": "140",
+      "metadataId": "Knowledge Graphing and RAG",
+      "label": "Knowledge Graphing and RAG",
+      "data": {
+        "position": {
+          "x": 0.0792526,
+          "y": -0.009879496,
+          "z": -0.1649195
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "21956",
+        "name": "Knowledge Graphing and RAG",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:10:33.425704688 UTC",
+        "fileName": "Knowledge Graphing and RAG.md",
+        "sha1": "c48d841caab406b50406cd244d13b0df4204989a",
+        "metadataId": "Knowledge Graphing and RAG",
+        "hyperlinkCount": "55"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "141",
+      "metadataId": "Product and Risk Management",
+      "label": "Product and Risk Management",
+      "data": {
+        "position": {
+          "x": -0.35326132,
+          "y": -0.40585676,
+          "z": 0.0733378
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "2",
+        "metadataId": "Product and Risk Management",
+        "fileSize": "4320",
+        "sha1": "dcbee3ca4172ec238ef137ced777ec66b223ee49",
+        "name": "Product and Risk Management",
+        "lastModified": "2025-02-15 16:11:43.259750170 UTC",
+        "fileName": "Product and Risk Management.md",
+        "nodeSize": "43.88"
+      },
+      "size": 43.88
+    },
+    {
+      "id": "142",
+      "metadataId": "AI privacy at the 2024 Olympics",
+      "label": "AI privacy at the 2024 Olympics",
+      "data": {
+        "position": {
+          "x": 0.012719254,
+          "y": -1.2631563,
+          "z": -0.6429581
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "AI privacy at the 2024 Olympics",
+        "fileSize": "8139",
+        "metadataId": "AI privacy at the 2024 Olympics",
+        "nodeSize": "50",
+        "hyperlinkCount": "0",
+        "lastModified": "2025-02-15 16:08:15.129064190 UTC",
+        "sha1": "83c457c54a6b1a1002b99c2925a3932566065000",
+        "fileName": "AI privacy at the 2024 Olympics.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "143",
+      "metadataId": "Facebook Meta",
+      "label": "Facebook Meta",
+      "data": {
+        "position": {
+          "x": 0.91589427,
+          "y": -0.37159625,
+          "z": 1.252535
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "4010",
+        "sha1": "3e69fe704332a5acd97ef2f7fe33316435746521",
+        "hyperlinkCount": "0",
+        "metadataId": "Facebook Meta",
+        "fileName": "Facebook Meta.md",
+        "name": "Facebook Meta",
+        "nodeSize": "41.09",
+        "lastModified": "2025-02-15 16:09:51.664742754 UTC"
+      },
+      "size": 41.09
+    },
+    {
+      "id": "144",
+      "metadataId": "AI Video",
+      "label": "AI Video",
+      "data": {
+        "position": {
+          "x": 0.35007256,
+          "y": -0.14439395,
+          "z": -0.57197887
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "AI Video.md",
+        "name": "AI Video",
+        "metadataId": "AI Video",
+        "sha1": "a64b5679fbe11d0250919f9beb56affce22f812b",
+        "lastModified": "2025-02-15 16:08:12.269348248 UTC",
+        "hyperlinkCount": "90",
+        "fileSize": "18535",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "145",
+      "metadataId": "Comparison of SDXL and Midjourney v6",
+      "label": "Comparison of SDXL and Midjourney v6",
+      "data": {
+        "position": {
+          "x": 0.41864392,
+          "y": -0.32454062,
+          "z": 0.26987305
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 18,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "11.579",
+        "lastModified": "2025-02-15 16:09:00.266222054 UTC",
+        "fileSize": "731",
+        "name": "Comparison of SDXL and Midjourney v6",
+        "hyperlinkCount": "7",
+        "metadataId": "Comparison of SDXL and Midjourney v6",
+        "fileName": "Comparison of SDXL and Midjourney v6.md",
+        "sha1": "dae15fcc817642ee05550e389a1d9de4987a5f15"
+      },
+      "size": 11.579
+    },
+    {
+      "id": "146",
+      "metadataId": "Definitions and frameworks for Metaverse",
+      "label": "Definitions and frameworks for Metaverse",
+      "data": {
+        "position": {
+          "x": -1.62507,
+          "y": -1.4306172,
+          "z": -1.810734
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 29,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "43",
+        "metadataId": "Definitions and frameworks for Metaverse",
+        "nodeSize": "50",
+        "fileSize": "48177",
+        "sha1": "6d56ab61e4410d87a12d67ffebc2ee03ddf7ae2c",
+        "lastModified": "2025-02-15 16:09:25.151720860 UTC",
+        "fileName": "Definitions and frameworks for Metaverse.md",
+        "name": "Definitions and frameworks for Metaverse"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "147",
+      "metadataId": "ecash",
+      "label": "ecash",
+      "data": {
+        "position": {
+          "x": 0.7875016,
+          "y": -0.880541,
+          "z": -0.76079524
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "48.74",
+        "lastModified": "2025-02-15 16:13:19.564911966 UTC",
+        "fileName": "ecash.md",
+        "fileSize": "4860",
+        "metadataId": "ecash",
+        "name": "ecash",
+        "sha1": "c506dbc045207de680663a775cad988f77bf9018",
+        "hyperlinkCount": "0"
+      },
+      "size": 48.74
+    },
+    {
+      "id": "148",
+      "metadataId": "Speech and voice",
+      "label": "Speech and voice",
+      "data": {
+        "position": {
+          "x": -0.5554261,
+          "y": 0.97179437,
+          "z": -0.29031116
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "13439",
+        "metadataId": "Speech and voice",
+        "fileName": "Speech and voice.md",
+        "sha1": "12af93d19c15bd4210789c0ead6e5d40f70fa902",
+        "nodeSize": "50",
+        "lastModified": "2025-02-15 16:12:26.828227281 UTC",
+        "name": "Speech and voice",
+        "hyperlinkCount": "43"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "149",
+      "metadataId": "Procedural and Hybrid 4D",
+      "label": "Procedural and Hybrid 4D",
+      "data": {
+        "position": {
+          "x": -0.055030897,
+          "y": 0.38181403,
+          "z": -0.39682546
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 11,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "hyperlinkCount": "1",
+        "name": "Procedural and Hybrid 4D",
+        "fileName": "Procedural and Hybrid 4D.md",
+        "sha1": "acdf93b3d0575cfa737136aace02dff3c6c015e9",
+        "fileSize": "61",
+        "nodeSize": "5.549",
+        "lastModified": "2025-02-15 16:11:41.278603964 UTC",
+        "metadataId": "Procedural and Hybrid 4D"
+      },
+      "size": 5.549
+    },
+    {
+      "id": "150",
+      "metadataId": "Agents",
+      "label": "Agents",
+      "data": {
+        "position": {
+          "x": 0.066345826,
+          "y": -0.717378,
+          "z": 0.19332312
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "50",
+        "hyperlinkCount": "8",
+        "name": "Agents",
+        "lastModified": "2025-02-15 16:08:23.387552229 UTC",
+        "sha1": "fe1012e118dbebc31844f42e28f0f434ec741c16",
+        "fileSize": "5445",
+        "metadataId": "Agents",
+        "fileName": "Agents.md"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "151",
+      "metadataId": "Bitcoin",
+      "label": "Bitcoin",
+      "data": {
+        "position": {
+          "x": -0.8221175,
+          "y": 1.2631117,
+          "z": -0.6423669
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 31,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Bitcoin",
+        "name": "Bitcoin",
+        "nodeSize": "50",
+        "sha1": "6d06c8f8136a9e87b0d7cb31e76b8af8ede055c3",
+        "fileSize": "97286",
+        "fileName": "Bitcoin.md",
+        "hyperlinkCount": "214",
+        "lastModified": "2025-02-15 16:08:42.966127363 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "152",
+      "metadataId": "Large language models",
+      "label": "Large language models",
+      "data": {
+        "position": {
+          "x": -0.013007479,
+          "y": 0.7024803,
+          "z": -0.8185388
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 30,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Large language models",
+        "fileSize": "63087",
+        "name": "Large language models",
+        "fileName": "Large language models.md",
+        "nodeSize": "50",
+        "hyperlinkCount": "192",
+        "sha1": "dd952178ab8d4ea5d4be12320beb66ceec672264",
+        "lastModified": "2025-02-15 16:10:35.646324435 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "153",
+      "metadataId": "Blender",
+      "label": "Blender",
+      "data": {
+        "position": {
+          "x": -0.10254898,
+          "y": -0.2004451,
+          "z": 0.06588007
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 14,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "168",
+        "fileName": "Blender.md",
+        "hyperlinkCount": "0",
+        "sha1": "0df1342462b955899508959a47cfca64c8a28048",
+        "nodeSize": "6.5120000000000005",
+        "metadataId": "Blender",
+        "lastModified": "2025-02-15 16:08:43.801202951 UTC",
+        "name": "Blender"
+      },
+      "size": 6.512
+    },
+    {
+      "id": "154",
+      "metadataId": "Microsoft CoPilot",
+      "label": "Microsoft CoPilot",
+      "data": {
+        "position": {
+          "x": -0.28034168,
+          "y": 1.1654453,
+          "z": -1.5251625
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "7036139cdbe327bf3f2d5a3aec96f73efed1f7e9",
+        "fileSize": "4569",
+        "hyperlinkCount": "7",
+        "fileName": "Microsoft CoPilot.md",
+        "nodeSize": "46.120999999999995",
+        "lastModified": "2025-02-15 16:11:02.612759857 UTC",
+        "name": "Microsoft CoPilot",
+        "metadataId": "Microsoft CoPilot"
+      },
+      "size": 46.121
+    },
+    {
+      "id": "155",
+      "metadataId": "Rust",
+      "label": "Rust",
+      "data": {
+        "position": {
+          "x": 0.85925525,
+          "y": 0.0023351016,
+          "z": -0.5384994
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "34.916",
+        "fileName": "Rust.md",
+        "sha1": "904052bcb6c40ea9f5cbe7762cba6470409b39e3",
+        "name": "Rust",
+        "fileSize": "3324",
+        "lastModified": "2025-02-15 16:12:10.030655380 UTC",
+        "metadataId": "Rust",
+        "hyperlinkCount": "0"
+      },
+      "size": 34.916
+    },
+    {
+      "id": "156",
+      "metadataId": "Reasoning",
+      "label": "Reasoning",
+      "data": {
+        "position": {
+          "x": 0.74749553,
+          "y": -0.31801417,
+          "z": -0.79877836
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:11:59.992686805 UTC",
+        "nodeSize": "31.433",
+        "name": "Reasoning",
+        "fileName": "Reasoning.md",
+        "sha1": "d4905c447b0816f0aa649309ecead65686bd51c6",
+        "fileSize": "2937",
+        "metadataId": "Reasoning",
+        "hyperlinkCount": "4"
+      },
+      "size": 31.433
+    },
+    {
+      "id": "157",
+      "metadataId": "Vision Pro",
+      "label": "Vision Pro",
+      "data": {
+        "position": {
+          "x": 0.026676666,
+          "y": -0.04412116,
+          "z": 0.4375284
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Vision Pro.md",
+        "name": "Vision Pro",
+        "metadataId": "Vision Pro",
+        "fileSize": "2841",
+        "sha1": "4f24bd713c8a82f0ee7a3867f0dfd4e265fb2a1e",
+        "lastModified": "2025-02-15 16:13:00.750940304 UTC",
+        "nodeSize": "30.569000000000003",
+        "hyperlinkCount": "2"
+      },
+      "size": 30.569
+    },
+    {
+      "id": "158",
+      "metadataId": "Convergence",
+      "label": "Convergence",
+      "data": {
+        "position": {
+          "x": -0.08959636,
+          "y": -0.5726751,
+          "z": -0.40348455
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 25,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "d9b6b97f4a72285712c15bb6dafa33af975bcded",
+        "hyperlinkCount": "2",
+        "name": "Convergence",
+        "nodeSize": "50",
+        "metadataId": "Convergence",
+        "fileName": "Convergence.md",
+        "fileSize": "10595",
+        "lastModified": "2025-02-15 16:09:06.807701360 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "159",
+      "metadataId": "Stable Diffusion",
+      "label": "Stable Diffusion",
+      "data": {
+        "position": {
+          "x": 0.24789672,
+          "y": -0.02469525,
+          "z": -1.2692093
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 29,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Stable Diffusion.md",
+        "hyperlinkCount": "204",
+        "name": "Stable Diffusion",
+        "lastModified": "2025-02-15 16:12:29.570774420 UTC",
+        "fileSize": "37561",
+        "metadataId": "Stable Diffusion",
+        "sha1": "e6835717a41c00c21b58e1f628a418bce502249e",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "160",
+      "metadataId": "Bitcoin Technical Overview",
+      "label": "Bitcoin Technical Overview",
+      "data": {
+        "position": {
+          "x": 0.29319453,
+          "y": 0.038155586,
+          "z": 0.35671005
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Bitcoin Technical Overview",
+        "nodeSize": "50",
+        "hyperlinkCount": "65",
+        "lastModified": "2025-02-15 16:08:40.682655612 UTC",
+        "fileName": "Bitcoin Technical Overview.md",
+        "fileSize": "34697",
+        "name": "Bitcoin Technical Overview",
+        "sha1": "8e936a1e64b786b9d96fff6bb9f10124ced9b58a"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "161",
+      "metadataId": "Tokenisation",
+      "label": "Tokenisation",
+      "data": {
+        "position": {
+          "x": -0.7827048,
+          "y": -0.7569472,
+          "z": -0.14900184
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "28.13",
+        "fileSize": "2570",
+        "name": "Tokenisation",
+        "sha1": "5b5ba3f8cabcfa6cbe0dec028c4604bb2492e709",
+        "fileName": "Tokenisation.md",
+        "hyperlinkCount": "2",
+        "lastModified": "2025-02-15 16:12:45.706966568 UTC",
+        "metadataId": "Tokenisation"
+      },
+      "size": 28.13
+    },
+    {
+      "id": "162",
+      "metadataId": "Calculating Empires",
+      "label": "Calculating Empires",
+      "data": {
+        "position": {
+          "x": 0.7018484,
+          "y": 0.55947906,
+          "z": -0.10136774
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "ab61c3b4fec2962cb8ce3ecde187d9650cc0117e",
+        "nodeSize": "23.576",
+        "fileName": "Calculating Empires.md",
+        "metadataId": "Calculating Empires",
+        "lastModified": "2025-02-15 16:08:47.908344612 UTC",
+        "hyperlinkCount": "5",
+        "fileSize": "2064",
+        "name": "Calculating Empires"
+      },
+      "size": 23.576
+    },
+    {
+      "id": "163",
+      "metadataId": "Lead Poisoning Hypothesis",
+      "label": "Lead Poisoning Hypothesis",
+      "data": {
+        "position": {
+          "x": 0.2136312,
+          "y": -0.23409495,
+          "z": -0.680046
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Lead Poisoning Hypothesis",
+        "fileSize": "3998",
+        "hyperlinkCount": "1",
+        "sha1": "ac2e67660cef93025f7583d726ad4bfb083ad9c0",
+        "fileName": "Lead Poisoning Hypothesis.md",
+        "nodeSize": "40.982",
+        "lastModified": "2025-02-15 16:10:38.678293360 UTC",
+        "name": "Lead Poisoning Hypothesis"
+      },
+      "size": 40.982
+    },
+    {
+      "id": "164",
+      "metadataId": "Depth Estimation",
+      "label": "Depth Estimation",
+      "data": {
+        "position": {
+          "x": 0.2864894,
+          "y": -0.7765548,
+          "z": -0.052056074
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 18,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:09:27.127709700 UTC",
+        "fileSize": "862",
+        "fileName": "Depth Estimation.md",
+        "hyperlinkCount": "3",
+        "metadataId": "Depth Estimation",
+        "nodeSize": "12.758",
+        "sha1": "93ccc35608e3d73d3b8bef413ebfb6951a2f41bd",
+        "name": "Depth Estimation"
+      },
+      "size": 12.758
+    },
+    {
+      "id": "165",
+      "metadataId": "latent space",
+      "label": "latent space",
+      "data": {
+        "position": {
+          "x": 0.29529935,
+          "y": -0.43352565,
+          "z": -1.0068887
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 20,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "latent space",
+        "lastModified": "2025-02-15 16:13:32.264176142 UTC",
+        "fileSize": "1626",
+        "sha1": "f07817e32235a6342d1d9c0c7393b80fd045b7ff",
+        "nodeSize": "19.634",
+        "hyperlinkCount": "0",
+        "fileName": "latent space.md",
+        "name": "latent space"
+      },
+      "size": 19.634
+    },
+    {
+      "id": "166",
+      "metadataId": "Politics, Law, Privacy",
+      "label": "Politics, Law, Privacy",
+      "data": {
+        "position": {
+          "x": -0.2674345,
+          "y": -0.8655319,
+          "z": 0.3284697
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Politics, Law, Privacy.md",
+        "sha1": "ab6d364b607f0f088756f24ecb2c02919fb0c14f",
+        "metadataId": "Politics, Law, Privacy",
+        "name": "Politics, Law, Privacy",
+        "lastModified": "2025-02-15 16:11:36.375248256 UTC",
+        "nodeSize": "50",
+        "hyperlinkCount": "48",
+        "fileSize": "33644"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "167",
+      "metadataId": "Robin Hanson",
+      "label": "Robin Hanson",
+      "data": {
+        "position": {
+          "x": -0.04660224,
+          "y": -0.5620517,
+          "z": 0.1193958
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 23,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "metadataId": "Robin Hanson",
+        "sha1": "156d623073ac4c43ca74ddc759d08dc3278f2ec3",
+        "lastModified": "2025-02-15 16:12:05.020736083 UTC",
+        "hyperlinkCount": "1",
+        "fileSize": "4255",
+        "fileName": "Robin Hanson.md",
+        "name": "Robin Hanson",
+        "nodeSize": "43.295"
+      },
+      "size": 43.295
+    },
+    {
+      "id": "168",
+      "metadataId": "Call Centres",
+      "label": "Call Centres",
+      "data": {
+        "position": {
+          "x": 0.52936304,
+          "y": 0.35946682,
+          "z": 0.1384924
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileSize": "23898",
+        "name": "Call Centres",
+        "fileName": "Call Centres.md",
+        "lastModified": "2025-02-15 16:08:49.851526065 UTC",
+        "nodeSize": "50",
+        "hyperlinkCount": "27",
+        "metadataId": "Call Centres",
+        "sha1": "0ab50f04ced83606b3f489360ebd7f3c56a906d8"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "169",
+      "metadataId": "artificial superintelligence",
+      "label": "artificial superintelligence",
+      "data": {
+        "position": {
+          "x": 0.59904224,
+          "y": -1.095359,
+          "z": -2.6293955
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 21,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "nodeSize": "28.652",
+        "hyperlinkCount": "6",
+        "fileName": "artificial superintelligence.md",
+        "name": "artificial superintelligence",
+        "lastModified": "2025-02-15 16:13:11.169885397 UTC",
+        "metadataId": "artificial superintelligence",
+        "fileSize": "2628",
+        "sha1": "1d0c2ef96a2fd56a69ab6036b1fa7e1d348e4259"
+      },
+      "size": 28.652
+    },
+    {
+      "id": "170",
+      "metadataId": "Adoption of Convergent Technologies",
+      "label": "Adoption of Convergent Technologies",
+      "data": {
+        "position": {
+          "x": -0.1626315,
+          "y": 0.48242906,
+          "z": 0.9773938
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "sha1": "2c9159b57ab3151511a44b3eae989aff94ed9ca0",
+        "name": "Adoption of Convergent Technologies",
+        "fileName": "Adoption of Convergent Technologies.md",
+        "hyperlinkCount": "46",
+        "nodeSize": "50",
+        "fileSize": "20064",
+        "lastModified": "2025-02-15 16:08:19.295150706 UTC",
+        "metadataId": "Adoption of Convergent Technologies"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "171",
+      "metadataId": "State Space and Other Approaches",
+      "label": "State Space and Other Approaches",
+      "data": {
+        "position": {
+          "x": 0.048165392,
+          "y": 0.70814294,
+          "z": 1.2044932
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 28,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "State Space and Other Approaches.md",
+        "metadataId": "State Space and Other Approaches",
+        "sha1": "8d9a5d9f6cf452e34f974cd4a6f21b3be285d210",
+        "hyperlinkCount": "5",
+        "name": "State Space and Other Approaches",
+        "lastModified": "2025-02-15 16:12:30.331744743 UTC",
+        "nodeSize": "50",
+        "fileSize": "28558"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "172",
+      "metadataId": "Upscaling",
+      "label": "Upscaling",
+      "data": {
+        "position": {
+          "x": 0.0070608426,
+          "y": -0.81415784,
+          "z": -0.13915586
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 19,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Upscaling",
+        "lastModified": "2025-02-15 16:12:53.611066677 UTC",
+        "fileSize": "1184",
+        "metadataId": "Upscaling",
+        "sha1": "2e5ac91fce4545f7c42fcb0bc52459fddf3244a2",
+        "fileName": "Upscaling.md",
+        "nodeSize": "15.656",
+        "hyperlinkCount": "7"
+      },
+      "size": 15.656
+    },
+    {
+      "id": "173",
+      "metadataId": "Sam Hammond",
+      "label": "Sam Hammond",
+      "data": {
+        "position": {
+          "x": 0.57847434,
+          "y": 0.05151443,
+          "z": 0.5760213
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Sam Hammond.md",
+        "sha1": "6d6e2566f510254770291bdad5e4300623341fbf",
+        "hyperlinkCount": "1",
+        "name": "Sam Hammond",
+        "fileSize": "17935",
+        "lastModified": "2025-02-15 16:12:13.469982026 UTC",
+        "metadataId": "Sam Hammond",
+        "nodeSize": "50"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "174",
+      "metadataId": "Knowhere",
+      "label": "Knowhere",
+      "data": {
+        "position": {
+          "x": 0.40309244,
+          "y": -0.41433907,
+          "z": 0.8125146
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 26,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Knowhere",
+        "fileName": "Knowhere.md",
+        "fileSize": "15800",
+        "nodeSize": "50",
+        "sha1": "3b34a6640636d10e96ef28d9d716172103a1751e",
+        "hyperlinkCount": "6",
+        "metadataId": "Knowhere",
+        "lastModified": "2025-02-15 16:10:32.526248600 UTC"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "175",
+      "metadataId": "Tim Reutermann",
+      "label": "Tim Reutermann",
+      "data": {
+        "position": {
+          "x": 0.5184083,
+          "y": -0.8017896,
+          "z": -0.44754717
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 22,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "lastModified": "2025-02-15 16:12:42.963107984 UTC",
+        "hyperlinkCount": "2",
+        "name": "Tim Reutermann",
+        "sha1": "a7637194be7fb2c58b8cf8fa927ef7a1373a8f85",
+        "fileSize": "3622",
+        "nodeSize": "37.598",
+        "fileName": "Tim Reutermann.md",
+        "metadataId": "Tim Reutermann"
+      },
+      "size": 37.598
+    },
+    {
+      "id": "176",
+      "metadataId": "Privacy, Trust and Safety",
+      "label": "Privacy, Trust and Safety",
+      "data": {
+        "position": {
+          "x": 0.845695,
+          "y": 1.0098945,
+          "z": 0.6819354
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 27,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "name": "Privacy, Trust and Safety",
+        "nodeSize": "50",
+        "hyperlinkCount": "11",
+        "sha1": "edfbc5f7def1d610a1c4149d40963bdbca0e200e",
+        "fileName": "Privacy, Trust and Safety.md",
+        "lastModified": "2025-02-15 16:11:40.542109377 UTC",
+        "metadataId": "Privacy, Trust and Safety",
+        "fileSize": "20401"
+      },
+      "size": 50.0
+    },
+    {
+      "id": "177",
+      "metadataId": "Controlnet and similar",
+      "label": "Controlnet and similar",
+      "data": {
+        "position": {
+          "x": -1.3651831,
+          "y": -0.42921504,
+          "z": -0.20939872
+        },
+        "velocity": {
+          "x": 0.0,
+          "y": 0.0,
+          "z": 0.0
+        },
+        "mass": 24,
+        "flags": 1,
+        "padding": [
+          0,
+          0
+        ]
+      },
+      "metadata": {
+        "fileName": "Controlnet and similar.md",
+        "hyperlinkCount": "3",
+        "name": "Controlnet and similar",
+        "lastModified": "2025-02-15 16:09:05.893957305 UTC",
+        "metadataId": "Controlnet and similar",
+        "fileSize": "8004",
+        "nodeSize": "50",
+        "sha1": "fdefdedc0ba6c22da4a94905e11fbae173813092"
+      },
+      "size": 50.0
+    }
+  ],
+  "edges": [
+    {
+      "source": "152",
+      "target": "28",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "159",
+      "weight": 5.0
+    },
+    {
+      "source": "110",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "137",
+      "weight": 1.0
+    },
+    {
+      "source": "136",
+      "target": "69",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "54",
+      "weight": 1.0
+    },
+    {
+      "source": "3",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "61",
+      "target": "64",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "76",
+      "weight": 1.0
+    },
+    {
+      "source": "16",
+      "target": "34",
+      "weight": 6.0
+    },
+    {
+      "source": "148",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "29",
+      "weight": 5.0
+    },
+    {
+      "source": "146",
+      "target": "157",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "150",
+      "weight": 11.0
+    },
+    {
+      "source": "159",
+      "target": "36",
+      "weight": 1.0
+    },
+    {
+      "source": "54",
+      "target": "99",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "42",
+      "weight": 1.0
+    },
+    {
+      "source": "136",
+      "target": "152",
+      "weight": 2.0
+    },
+    {
+      "source": "136",
+      "target": "150",
+      "weight": 29.0
+    },
+    {
+      "source": "3",
+      "target": "97",
+      "weight": 4.0
+    },
+    {
+      "source": "110",
+      "target": "65",
+      "weight": 2.0
+    },
+    {
+      "source": "159",
+      "target": "35",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "14",
+      "weight": 5.0
+    },
+    {
+      "source": "158",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "114",
+      "weight": 17.0
+    },
+    {
+      "source": "144",
+      "target": "86",
+      "weight": 1.0
+    },
+    {
+      "source": "112",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "144",
+      "weight": 1.0
+    },
+    {
+      "source": "2",
+      "target": "37",
+      "weight": 12.0
+    },
+    {
+      "source": "126",
+      "target": "173",
+      "weight": 1.0
+    },
+    {
+      "source": "122",
+      "target": "40",
+      "weight": 1.0
+    },
+    {
+      "source": "136",
+      "target": "45",
+      "weight": 4.0
+    },
+    {
+      "source": "14",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "128",
+      "target": "152",
+      "weight": 2.0
+    },
+    {
+      "source": "170",
+      "target": "57",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "154",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "28",
+      "weight": 1.0
+    },
+    {
+      "source": "128",
+      "target": "56",
+      "weight": 3.0
+    },
+    {
+      "source": "12",
+      "target": "158",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "53",
+      "weight": 2.0
+    },
+    {
+      "source": "37",
+      "target": "8",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "30",
+      "weight": 2.0
+    },
+    {
+      "source": "158",
+      "target": "92",
+      "weight": 3.0
+    },
+    {
+      "source": "106",
+      "target": "21",
+      "weight": 19.0
+    },
+    {
+      "source": "106",
+      "target": "150",
+      "weight": 1.0
+    },
+    {
+      "source": "139",
+      "target": "93",
+      "weight": 1.0
+    },
+    {
+      "source": "156",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "28",
+      "target": "4",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "30",
+      "weight": 1.0
+    },
+    {
+      "source": "154",
+      "target": "16",
+      "weight": 1.0
+    },
+    {
+      "source": "101",
+      "target": "150",
+      "weight": 1.0
+    },
+    {
+      "source": "143",
+      "target": "156",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "51",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "177",
+      "weight": 4.0
+    },
+    {
+      "source": "122",
+      "target": "151",
+      "weight": 5.0
+    },
+    {
+      "source": "128",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "105",
+      "target": "152",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "96",
+      "weight": 1.0
+    },
+    {
+      "source": "12",
+      "target": "88",
+      "weight": 2.0
+    },
+    {
+      "source": "34",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "174",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "69",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "137",
+      "weight": 4.0
+    },
+    {
+      "source": "130",
+      "target": "67",
+      "weight": 2.0
+    },
+    {
+      "source": "37",
+      "target": "47",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "165",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "61",
+      "weight": 3.0
+    },
+    {
+      "source": "121",
+      "target": "43",
+      "weight": 1.0
+    },
+    {
+      "source": "77",
+      "target": "90",
+      "weight": 3.0
+    },
+    {
+      "source": "56",
+      "target": "72",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "169",
+      "weight": 1.0
+    },
+    {
+      "source": "136",
+      "target": "24",
+      "weight": 5.0
+    },
+    {
+      "source": "121",
+      "target": "85",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "55",
+      "weight": 1.0
+    },
+    {
+      "source": "172",
+      "target": "9",
+      "weight": 18.0
+    },
+    {
+      "source": "137",
+      "target": "5",
+      "weight": 2.0
+    },
+    {
+      "source": "166",
+      "target": "38",
+      "weight": 5.0
+    },
+    {
+      "source": "2",
+      "target": "49",
+      "weight": 10.0
+    },
+    {
+      "source": "101",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "67",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "36",
+      "weight": 9.0
+    },
+    {
+      "source": "152",
+      "target": "9",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "137",
+      "weight": 4.0
+    },
+    {
+      "source": "152",
+      "target": "45",
+      "weight": 12.0
+    },
+    {
+      "source": "37",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "58",
+      "weight": 1.0
+    },
+    {
+      "source": "160",
+      "target": "92",
+      "weight": 8.0
+    },
+    {
+      "source": "135",
+      "target": "152",
+      "weight": 3.0
+    },
+    {
+      "source": "111",
+      "target": "158",
+      "weight": 2.0
+    },
+    {
+      "source": "24",
+      "target": "9",
+      "weight": 24.0
+    },
+    {
+      "source": "67",
+      "target": "82",
+      "weight": 6.0
+    },
+    {
+      "source": "21",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "127",
+      "target": "21",
+      "weight": 3.0
+    },
+    {
+      "source": "163",
+      "target": "167",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "39",
+      "weight": 1.0
+    },
+    {
+      "source": "43",
+      "target": "92",
+      "weight": 4.0
+    },
+    {
+      "source": "111",
+      "target": "9",
+      "weight": 40.0
+    },
+    {
+      "source": "113",
+      "target": "43",
+      "weight": 29.0
+    },
+    {
+      "source": "157",
+      "target": "7",
+      "weight": 5.0
+    },
+    {
+      "source": "117",
+      "target": "21",
+      "weight": 3.0
+    },
+    {
+      "source": "151",
+      "target": "71",
+      "weight": 1.0
+    },
+    {
+      "source": "112",
+      "target": "160",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "14",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "67",
+      "weight": 2.0
+    },
+    {
+      "source": "144",
+      "target": "81",
+      "weight": 2.0
+    },
+    {
+      "source": "176",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "23",
+      "weight": 2.0
+    },
+    {
+      "source": "113",
+      "target": "134",
+      "weight": 25.0
+    },
+    {
+      "source": "11",
+      "target": "122",
+      "weight": 1.0
+    },
+    {
+      "source": "24",
+      "target": "29",
+      "weight": 9.0
+    },
+    {
+      "source": "154",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "80",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "41",
+      "target": "8",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "81",
+      "weight": 5.0
+    },
+    {
+      "source": "126",
+      "target": "51",
+      "weight": 1.0
+    },
+    {
+      "source": "170",
+      "target": "21",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "126",
+      "target": "80",
+      "weight": 3.0
+    },
+    {
+      "source": "111",
+      "target": "132",
+      "weight": 1.0
+    },
+    {
+      "source": "34",
+      "target": "38",
+      "weight": 3.0
+    },
+    {
+      "source": "41",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "11",
+      "target": "135",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "42",
+      "weight": 3.0
+    },
+    {
+      "source": "43",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "20",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "62",
+      "target": "90",
+      "weight": 13.0
+    },
+    {
+      "source": "132",
+      "target": "7",
+      "weight": 5.0
+    },
+    {
+      "source": "117",
+      "target": "9",
+      "weight": 3.0
+    },
+    {
+      "source": "108",
+      "target": "126",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "84",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "93",
+      "weight": 1.0
+    },
+    {
+      "source": "5",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "177",
+      "weight": 3.0
+    },
+    {
+      "source": "111",
+      "target": "119",
+      "weight": 9.0
+    },
+    {
+      "source": "61",
+      "target": "97",
+      "weight": 1.0
+    },
+    {
+      "source": "50",
+      "target": "8",
+      "weight": 1.0
+    },
+    {
+      "source": "127",
+      "target": "49",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "68",
+      "weight": 1.0
+    },
+    {
+      "source": "28",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "62",
+      "weight": 20.0
+    },
+    {
+      "source": "45",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "47",
+      "weight": 2.0
+    },
+    {
+      "source": "116",
+      "target": "150",
+      "weight": 8.0
+    },
+    {
+      "source": "152",
+      "target": "17",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "3",
+      "target": "62",
+      "weight": 14.0
+    },
+    {
+      "source": "56",
+      "target": "81",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "5",
+      "weight": 2.0
+    },
+    {
+      "source": "24",
+      "target": "25",
+      "weight": 1.0
+    },
+    {
+      "source": "33",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "146",
+      "target": "151",
+      "weight": 2.0
+    },
+    {
+      "source": "109",
+      "target": "111",
+      "weight": 1.0
+    },
+    {
+      "source": "46",
+      "target": "87",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "21",
+      "weight": 3.0
+    },
+    {
+      "source": "122",
+      "target": "24",
+      "weight": 3.0
+    },
+    {
+      "source": "7",
+      "target": "90",
+      "weight": 2.0
+    },
+    {
+      "source": "110",
+      "target": "121",
+      "weight": 2.0
+    },
+    {
+      "source": "130",
+      "target": "82",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "156",
+      "weight": 3.0
+    },
+    {
+      "source": "176",
+      "target": "40",
+      "weight": 1.0
+    },
+    {
+      "source": "2",
+      "target": "59",
+      "weight": 3.0
+    },
+    {
+      "source": "169",
+      "target": "99",
+      "weight": 1.0
+    },
+    {
+      "source": "51",
+      "target": "90",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "160",
+      "weight": 82.0
+    },
+    {
+      "source": "155",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "135",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "88",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "146",
+      "target": "7",
+      "weight": 6.0
+    },
+    {
+      "source": "158",
+      "target": "7",
+      "weight": 4.0
+    },
+    {
+      "source": "135",
+      "target": "92",
+      "weight": 3.0
+    },
+    {
+      "source": "62",
+      "target": "67",
+      "weight": 1.0
+    },
+    {
+      "source": "134",
+      "target": "165",
+      "weight": 4.0
+    },
+    {
+      "source": "106",
+      "target": "72",
+      "weight": 2.0
+    },
+    {
+      "source": "129",
+      "target": "59",
+      "weight": 1.0
+    },
+    {
+      "source": "83",
+      "target": "88",
+      "weight": 2.0
+    },
+    {
+      "source": "109",
+      "target": "9",
+      "weight": 3.0
+    },
+    {
+      "source": "51",
+      "target": "55",
+      "weight": 4.0
+    },
+    {
+      "source": "151",
+      "target": "166",
+      "weight": 3.0
+    },
+    {
+      "source": "123",
+      "target": "150",
+      "weight": 1.0
+    },
+    {
+      "source": "30",
+      "target": "64",
+      "weight": 2.0
+    },
+    {
+      "source": "128",
+      "target": "158",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "132",
+      "weight": 2.0
+    },
+    {
+      "source": "24",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "43",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "91",
+      "weight": 2.0
+    },
+    {
+      "source": "71",
+      "target": "97",
+      "weight": 1.0
+    },
+    {
+      "source": "164",
+      "target": "7",
+      "weight": 3.0
+    },
+    {
+      "source": "60",
+      "target": "92",
+      "weight": 4.0
+    },
+    {
+      "source": "176",
+      "target": "5",
+      "weight": 2.0
+    },
+    {
+      "source": "115",
+      "target": "24",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "43",
+      "weight": 13.0
+    },
+    {
+      "source": "164",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "15",
+      "target": "154",
+      "weight": 1.0
+    },
+    {
+      "source": "11",
+      "target": "129",
+      "weight": 1.0
+    },
+    {
+      "source": "42",
+      "target": "53",
+      "weight": 2.0
+    },
+    {
+      "source": "147",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "28",
+      "target": "68",
+      "weight": 1.0
+    },
+    {
+      "source": "25",
+      "target": "45",
+      "weight": 3.0
+    },
+    {
+      "source": "129",
+      "target": "148",
+      "weight": 1.0
+    },
+    {
+      "source": "5",
+      "target": "87",
+      "weight": 1.0
+    },
+    {
+      "source": "63",
+      "target": "92",
+      "weight": 4.0
+    },
+    {
+      "source": "11",
+      "target": "151",
+      "weight": 52.0
+    },
+    {
+      "source": "12",
+      "target": "7",
+      "weight": 2.0
+    },
+    {
+      "source": "135",
+      "target": "176",
+      "weight": 4.0
+    },
+    {
+      "source": "135",
+      "target": "72",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "25",
+      "weight": 6.0
+    },
+    {
+      "source": "114",
+      "target": "63",
+      "weight": 4.0
+    },
+    {
+      "source": "45",
+      "target": "62",
+      "weight": 4.0
+    },
+    {
+      "source": "127",
+      "target": "151",
+      "weight": 4.0
+    },
+    {
+      "source": "150",
+      "target": "42",
+      "weight": 2.0
+    },
+    {
+      "source": "130",
+      "target": "132",
+      "weight": 5.0
+    },
+    {
+      "source": "152",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "9",
+      "weight": 7.0
+    },
+    {
+      "source": "139",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "62",
+      "weight": 3.0
+    },
+    {
+      "source": "21",
+      "target": "51",
+      "weight": 4.0
+    },
+    {
+      "source": "155",
+      "target": "52",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "155",
+      "weight": 3.0
+    },
+    {
+      "source": "111",
+      "target": "172",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "109",
+      "target": "21",
+      "weight": 1.0
+    },
+    {
+      "source": "103",
+      "target": "140",
+      "weight": 1.0
+    },
+    {
+      "source": "62",
+      "target": "7",
+      "weight": 8.0
+    },
+    {
+      "source": "67",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "144",
+      "target": "21",
+      "weight": 2.0
+    },
+    {
+      "source": "156",
+      "target": "44",
+      "weight": 8.0
+    },
+    {
+      "source": "134",
+      "target": "30",
+      "weight": 1.0
+    },
+    {
+      "source": "171",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "170",
+      "target": "24",
+      "weight": 1.0
+    },
+    {
+      "source": "123",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "45",
+      "weight": 4.0
+    },
+    {
+      "source": "151",
+      "target": "63",
+      "weight": 7.0
+    },
+    {
+      "source": "135",
+      "target": "63",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "133",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "9",
+      "weight": 8.0
+    },
+    {
+      "source": "38",
+      "target": "40",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "136",
+      "weight": 17.0
+    },
+    {
+      "source": "28",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "122",
+      "target": "92",
+      "weight": 8.0
+    },
+    {
+      "source": "159",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "50",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "9",
+      "target": "94",
+      "weight": 4.0
+    },
+    {
+      "source": "148",
+      "target": "152",
+      "weight": 2.0
+    },
+    {
+      "source": "115",
+      "target": "95",
+      "weight": 1.0
+    },
+    {
+      "source": "88",
+      "target": "90",
+      "weight": 1.0
+    },
+    {
+      "source": "173",
+      "target": "46",
+      "weight": 4.0
+    },
+    {
+      "source": "23",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "139",
+      "target": "5",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "43",
+      "weight": 12.0
+    },
+    {
+      "source": "156",
+      "target": "168",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "152",
+      "weight": 61.0
+    },
+    {
+      "source": "111",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "61",
+      "weight": 2.0
+    },
+    {
+      "source": "108",
+      "target": "66",
+      "weight": 2.0
+    },
+    {
+      "source": "49",
+      "target": "92",
+      "weight": 9.0
+    },
+    {
+      "source": "152",
+      "target": "34",
+      "weight": 9.0
+    },
+    {
+      "source": "136",
+      "target": "21",
+      "weight": 1.0
+    },
+    {
+      "source": "4",
+      "target": "42",
+      "weight": 2.0
+    },
+    {
+      "source": "137",
+      "target": "76",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "37",
+      "weight": 7.0
+    },
+    {
+      "source": "167",
+      "target": "24",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "62",
+      "weight": 2.0
+    },
+    {
+      "source": "159",
+      "target": "172",
+      "weight": 1.0
+    },
+    {
+      "source": "161",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "161",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "126",
+      "target": "150",
+      "weight": 5.0
+    },
+    {
+      "source": "176",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "21",
+      "weight": 4.0
+    },
+    {
+      "source": "114",
+      "target": "140",
+      "weight": 7.0
+    },
+    {
+      "source": "16",
+      "target": "36",
+      "weight": 3.0
+    },
+    {
+      "source": "82",
+      "target": "9",
+      "weight": 3.0
+    },
+    {
+      "source": "1",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "126",
+      "target": "5",
+      "weight": 2.0
+    },
+    {
+      "source": "51",
+      "target": "61",
+      "weight": 1.0
+    },
+    {
+      "source": "29",
+      "target": "50",
+      "weight": 6.0
+    },
+    {
+      "source": "23",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "113",
+      "target": "88",
+      "weight": 2.0
+    },
+    {
+      "source": "121",
+      "target": "77",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "160",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "23",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "136",
+      "weight": 2.0
+    },
+    {
+      "source": "135",
+      "target": "59",
+      "weight": 6.0
+    },
+    {
+      "source": "17",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "156",
+      "weight": 2.0
+    },
+    {
+      "source": "30",
+      "target": "34",
+      "weight": 7.0
+    },
+    {
+      "source": "54",
+      "target": "92",
+      "weight": 4.0
+    },
+    {
+      "source": "34",
+      "target": "50",
+      "weight": 8.0
+    },
+    {
+      "source": "151",
+      "target": "175",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "44",
+      "target": "93",
+      "weight": 1.0
+    },
+    {
+      "source": "167",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "4",
+      "weight": 2.0
+    },
+    {
+      "source": "29",
+      "target": "99",
+      "weight": 2.0
+    },
+    {
+      "source": "132",
+      "target": "146",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "62",
+      "weight": 32.0
+    },
+    {
+      "source": "112",
+      "target": "62",
+      "weight": 4.0
+    },
+    {
+      "source": "122",
+      "target": "37",
+      "weight": 7.0
+    },
+    {
+      "source": "37",
+      "target": "93",
+      "weight": 10.0
+    },
+    {
+      "source": "37",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "97",
+      "weight": 2.0
+    },
+    {
+      "source": "111",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "148",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "109",
+      "target": "117",
+      "weight": 3.0
+    },
+    {
+      "source": "23",
+      "target": "55",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "23",
+      "weight": 2.0
+    },
+    {
+      "source": "110",
+      "target": "151",
+      "weight": 16.0
+    },
+    {
+      "source": "38",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "5",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "88",
+      "weight": 2.0
+    },
+    {
+      "source": "12",
+      "target": "152",
+      "weight": 1.0
+    },
+    {
+      "source": "112",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "119",
+      "target": "34",
+      "weight": 3.0
+    },
+    {
+      "source": "37",
+      "target": "49",
+      "weight": 12.0
+    },
+    {
+      "source": "136",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "134",
+      "target": "49",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "89",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "4",
+      "weight": 1.0
+    },
+    {
+      "source": "112",
+      "target": "77",
+      "weight": 2.0
+    },
+    {
+      "source": "16",
+      "target": "23",
+      "weight": 3.0
+    },
+    {
+      "source": "135",
+      "target": "2",
+      "weight": 2.0
+    },
+    {
+      "source": "43",
+      "target": "7",
+      "weight": 3.0
+    },
+    {
+      "source": "150",
+      "target": "59",
+      "weight": 1.0
+    },
+    {
+      "source": "70",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "159",
+      "weight": 2.0
+    },
+    {
+      "source": "20",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "126",
+      "target": "45",
+      "weight": 5.0
+    },
+    {
+      "source": "13",
+      "target": "8",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "94",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "152",
+      "weight": 10.0
+    },
+    {
+      "source": "129",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "159",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "140",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "31",
+      "weight": 2.0
+    },
+    {
+      "source": "17",
+      "target": "77",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "151",
+      "weight": 10.0
+    },
+    {
+      "source": "162",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "109",
+      "target": "34",
+      "weight": 1.0
+    },
+    {
+      "source": "41",
+      "target": "52",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "69",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "156",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "126",
+      "weight": 1.0
+    },
+    {
+      "source": "45",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "44",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "9",
+      "weight": 2.0
+    },
+    {
+      "source": "137",
+      "target": "144",
+      "weight": 1.0
+    },
+    {
+      "source": "146",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "128",
+      "target": "50",
+      "weight": 3.0
+    },
+    {
+      "source": "175",
+      "target": "92",
+      "weight": 2.0
+    },
+    {
+      "source": "132",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "156",
+      "target": "75",
+      "weight": 1.0
+    },
+    {
+      "source": "126",
+      "target": "137",
+      "weight": 1.0
+    },
+    {
+      "source": "20",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "160",
+      "target": "2",
+      "weight": 1.0
+    },
+    {
+      "source": "173",
+      "target": "66",
+      "weight": 3.0
+    },
+    {
+      "source": "165",
+      "target": "42",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "59",
+      "weight": 1.0
+    },
+    {
+      "source": "88",
+      "target": "94",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "152",
+      "weight": 6.0
+    },
+    {
+      "source": "49",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "141",
+      "target": "28",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "92",
+      "weight": 12.0
+    },
+    {
+      "source": "152",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "20",
+      "target": "37",
+      "weight": 3.0
+    },
+    {
+      "source": "16",
+      "target": "173",
+      "weight": 1.0
+    },
+    {
+      "source": "29",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "59",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "156",
+      "target": "32",
+      "weight": 3.0
+    },
+    {
+      "source": "132",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "112",
+      "target": "151",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "165",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "63",
+      "target": "69",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "113",
+      "weight": 16.0
+    },
+    {
+      "source": "132",
+      "target": "15",
+      "weight": 1.0
+    },
+    {
+      "source": "160",
+      "target": "37",
+      "weight": 8.0
+    },
+    {
+      "source": "171",
+      "target": "97",
+      "weight": 1.0
+    },
+    {
+      "source": "27",
+      "target": "83",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "114",
+      "weight": 5.0
+    },
+    {
+      "source": "62",
+      "target": "92",
+      "weight": 6.0
+    },
+    {
+      "source": "156",
+      "target": "34",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "136",
+      "weight": 3.0
+    },
+    {
+      "source": "107",
+      "target": "147",
+      "weight": 16.0
+    },
+    {
+      "source": "128",
+      "target": "16",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "169",
+      "weight": 2.0
+    },
+    {
+      "source": "130",
+      "target": "143",
+      "weight": 2.0
+    },
+    {
+      "source": "140",
+      "target": "75",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "98",
+      "weight": 13.0
+    },
+    {
+      "source": "113",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "25",
+      "weight": 5.0
+    },
+    {
+      "source": "113",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "134",
+      "target": "135",
+      "weight": 3.0
+    },
+    {
+      "source": "151",
+      "target": "84",
+      "weight": 1.0
+    },
+    {
+      "source": "107",
+      "target": "151",
+      "weight": 5.0
+    },
+    {
+      "source": "176",
+      "target": "27",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "89",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "153",
+      "weight": 5.0
+    },
+    {
+      "source": "151",
+      "target": "158",
+      "weight": 3.0
+    },
+    {
+      "source": "126",
+      "target": "42",
+      "weight": 4.0
+    },
+    {
+      "source": "64",
+      "target": "7",
+      "weight": 2.0
+    },
+    {
+      "source": "21",
+      "target": "42",
+      "weight": 1.0
+    },
+    {
+      "source": "160",
+      "target": "89",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "32",
+      "weight": 1.0
+    },
+    {
+      "source": "45",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "126",
+      "target": "88",
+      "weight": 4.0
+    },
+    {
+      "source": "135",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "46",
+      "weight": 3.0
+    },
+    {
+      "source": "135",
+      "target": "146",
+      "weight": 2.0
+    },
+    {
+      "source": "165",
+      "target": "81",
+      "weight": 1.0
+    },
+    {
+      "source": "176",
+      "target": "20",
+      "weight": 2.0
+    },
+    {
+      "source": "121",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "6",
+      "target": "70",
+      "weight": 8.0
+    },
+    {
+      "source": "138",
+      "target": "50",
+      "weight": 6.0
+    },
+    {
+      "source": "12",
+      "target": "41",
+      "weight": 3.0
+    },
+    {
+      "source": "135",
+      "target": "49",
+      "weight": 4.0
+    },
+    {
+      "source": "135",
+      "target": "163",
+      "weight": 1.0
+    },
+    {
+      "source": "19",
+      "target": "58",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "150",
+      "weight": 2.0
+    },
+    {
+      "source": "135",
+      "target": "25",
+      "weight": 1.0
+    },
+    {
+      "source": "12",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "63",
+      "weight": 2.0
+    },
+    {
+      "source": "115",
+      "target": "150",
+      "weight": 3.0
+    },
+    {
+      "source": "133",
+      "target": "22",
+      "weight": 2.0
+    },
+    {
+      "source": "108",
+      "target": "9",
+      "weight": 2.0
+    },
+    {
+      "source": "62",
+      "target": "88",
+      "weight": 24.0
+    },
+    {
+      "source": "147",
+      "target": "151",
+      "weight": 10.0
+    },
+    {
+      "source": "51",
+      "target": "92",
+      "weight": 4.0
+    },
+    {
+      "source": "176",
+      "target": "19",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "176",
+      "weight": 2.0
+    },
+    {
+      "source": "140",
+      "target": "36",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "5",
+      "weight": 7.0
+    },
+    {
+      "source": "113",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "131",
+      "target": "137",
+      "weight": 2.0
+    },
+    {
+      "source": "45",
+      "target": "95",
+      "weight": 1.0
+    },
+    {
+      "source": "109",
+      "target": "42",
+      "weight": 4.0
+    },
+    {
+      "source": "162",
+      "target": "47",
+      "weight": 1.0
+    },
+    {
+      "source": "103",
+      "target": "21",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "27",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "137",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "60",
+      "weight": 1.0
+    },
+    {
+      "source": "43",
+      "target": "46",
+      "weight": 5.0
+    },
+    {
+      "source": "65",
+      "target": "92",
+      "weight": 2.0
+    },
+    {
+      "source": "159",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "51",
+      "weight": 11.0
+    },
+    {
+      "source": "171",
+      "target": "24",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "16",
+      "weight": 15.0
+    },
+    {
+      "source": "24",
+      "target": "98",
+      "weight": 12.0
+    },
+    {
+      "source": "32",
+      "target": "50",
+      "weight": 3.0
+    },
+    {
+      "source": "59",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "91",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "78",
+      "weight": 10.0
+    },
+    {
+      "source": "106",
+      "target": "64",
+      "weight": 4.0
+    },
+    {
+      "source": "129",
+      "target": "43",
+      "weight": 7.0
+    },
+    {
+      "source": "41",
+      "target": "60",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "68",
+      "weight": 1.0
+    },
+    {
+      "source": "72",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "144",
+      "target": "77",
+      "weight": 4.0
+    },
+    {
+      "source": "157",
+      "target": "93",
+      "weight": 3.0
+    },
+    {
+      "source": "115",
+      "target": "156",
+      "weight": 18.0
+    },
+    {
+      "source": "151",
+      "target": "65",
+      "weight": 5.0
+    },
+    {
+      "source": "46",
+      "target": "83",
+      "weight": 2.0
+    },
+    {
+      "source": "110",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "105",
+      "target": "158",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "76",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "24",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "71",
+      "weight": 1.0
+    },
+    {
+      "source": "132",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "140",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "68",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "116",
+      "weight": 6.0
+    },
+    {
+      "source": "46",
+      "target": "59",
+      "weight": 3.0
+    },
+    {
+      "source": "152",
+      "target": "93",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "73",
+      "weight": 2.0
+    },
+    {
+      "source": "12",
+      "target": "135",
+      "weight": 1.0
+    },
+    {
+      "source": "146",
+      "target": "37",
+      "weight": 5.0
+    },
+    {
+      "source": "106",
+      "target": "140",
+      "weight": 4.0
+    },
+    {
+      "source": "176",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "154",
+      "weight": 3.0
+    },
+    {
+      "source": "111",
+      "target": "177",
+      "weight": 3.0
+    },
+    {
+      "source": "153",
+      "target": "26",
+      "weight": 2.0
+    },
+    {
+      "source": "108",
+      "target": "50",
+      "weight": 9.0
+    },
+    {
+      "source": "43",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "36",
+      "weight": 4.0
+    },
+    {
+      "source": "135",
+      "target": "43",
+      "weight": 6.0
+    },
+    {
+      "source": "170",
+      "target": "92",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "174",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "53",
+      "weight": 2.0
+    },
+    {
+      "source": "7",
+      "target": "8",
+      "weight": 4.0
+    },
+    {
+      "source": "79",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "62",
+      "target": "93",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "36",
+      "weight": 2.0
+    },
+    {
+      "source": "122",
+      "target": "60",
+      "weight": 1.0
+    },
+    {
+      "source": "7",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "176",
+      "weight": 2.0
+    },
+    {
+      "source": "27",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "35",
+      "weight": 10.0
+    },
+    {
+      "source": "110",
+      "target": "147",
+      "weight": 8.0
+    },
+    {
+      "source": "114",
+      "target": "45",
+      "weight": 2.0
+    },
+    {
+      "source": "108",
+      "target": "17",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "128",
+      "weight": 3.0
+    },
+    {
+      "source": "129",
+      "target": "5",
+      "weight": 2.0
+    },
+    {
+      "source": "166",
+      "target": "30",
+      "weight": 1.0
+    },
+    {
+      "source": "128",
+      "target": "24",
+      "weight": 1.0
+    },
+    {
+      "source": "7",
+      "target": "89",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "152",
+      "weight": 19.0
+    },
+    {
+      "source": "36",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "135",
+      "weight": 3.0
+    },
+    {
+      "source": "110",
+      "target": "150",
+      "weight": 15.0
+    },
+    {
+      "source": "2",
+      "target": "7",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "29",
+      "weight": 2.0
+    },
+    {
+      "source": "113",
+      "target": "129",
+      "weight": 1.0
+    },
+    {
+      "source": "134",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "158",
+      "weight": 2.0
+    },
+    {
+      "source": "12",
+      "target": "132",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "93",
+      "weight": 4.0
+    },
+    {
+      "source": "130",
+      "target": "140",
+      "weight": 2.0
+    },
+    {
+      "source": "146",
+      "target": "93",
+      "weight": 7.0
+    },
+    {
+      "source": "114",
+      "target": "115",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "91",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "45",
+      "weight": 3.0
+    },
+    {
+      "source": "151",
+      "target": "170",
+      "weight": 17.0
+    },
+    {
+      "source": "130",
+      "target": "137",
+      "weight": 1.0
+    },
+    {
+      "source": "134",
+      "target": "4",
+      "weight": 1.0
+    },
+    {
+      "source": "132",
+      "target": "67",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "85",
+      "weight": 1.0
+    },
+    {
+      "source": "12",
+      "target": "2",
+      "weight": 19.0
+    },
+    {
+      "source": "105",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "21",
+      "weight": 6.0
+    },
+    {
+      "source": "28",
+      "target": "66",
+      "weight": 2.0
+    },
+    {
+      "source": "101",
+      "target": "140",
+      "weight": 1.0
+    },
+    {
+      "source": "30",
+      "target": "32",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "159",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "43",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "27",
+      "weight": 9.0
+    },
+    {
+      "source": "129",
+      "target": "90",
+      "weight": 3.0
+    },
+    {
+      "source": "113",
+      "target": "160",
+      "weight": 5.0
+    },
+    {
+      "source": "152",
+      "target": "47",
+      "weight": 2.0
+    },
+    {
+      "source": "168",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "89",
+      "weight": 23.0
+    },
+    {
+      "source": "136",
+      "target": "140",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "152",
+      "weight": 3.0
+    },
+    {
+      "source": "106",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "20",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "24",
+      "target": "53",
+      "weight": 3.0
+    },
+    {
+      "source": "137",
+      "target": "47",
+      "weight": 1.0
+    },
+    {
+      "source": "34",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "95",
+      "weight": 4.0
+    },
+    {
+      "source": "14",
+      "target": "77",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "130",
+      "weight": 12.0
+    },
+    {
+      "source": "130",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "148",
+      "target": "150",
+      "weight": 1.0
+    },
+    {
+      "source": "39",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "17",
+      "weight": 1.0
+    },
+    {
+      "source": "25",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "112",
+      "target": "176",
+      "weight": 2.0
+    },
+    {
+      "source": "159",
+      "target": "62",
+      "weight": 6.0
+    },
+    {
+      "source": "24",
+      "target": "42",
+      "weight": 3.0
+    },
+    {
+      "source": "129",
+      "target": "166",
+      "weight": 3.0
+    },
+    {
+      "source": "140",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "112",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "154",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "153",
+      "weight": 7.0
+    },
+    {
+      "source": "156",
+      "target": "21",
+      "weight": 6.0
+    },
+    {
+      "source": "112",
+      "target": "135",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "32",
+      "weight": 3.0
+    },
+    {
+      "source": "20",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "82",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "151",
+      "weight": 2.0
+    },
+    {
+      "source": "40",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "29",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "62",
+      "weight": 9.0
+    },
+    {
+      "source": "30",
+      "target": "6",
+      "weight": 1.0
+    },
+    {
+      "source": "42",
+      "target": "93",
+      "weight": 4.0
+    },
+    {
+      "source": "165",
+      "target": "72",
+      "weight": 1.0
+    },
+    {
+      "source": "46",
+      "target": "62",
+      "weight": 6.0
+    },
+    {
+      "source": "134",
+      "target": "76",
+      "weight": 2.0
+    },
+    {
+      "source": "46",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "54",
+      "weight": 7.0
+    },
+    {
+      "source": "114",
+      "target": "64",
+      "weight": 2.0
+    },
+    {
+      "source": "44",
+      "target": "92",
+      "weight": 3.0
+    },
+    {
+      "source": "150",
+      "target": "92",
+      "weight": 2.0
+    },
+    {
+      "source": "130",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "2",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "59",
+      "target": "65",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "16",
+      "weight": 1.0
+    },
+    {
+      "source": "43",
+      "target": "90",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "74",
+      "weight": 1.0
+    },
+    {
+      "source": "169",
+      "target": "21",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "99",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "152",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "165",
+      "weight": 1.0
+    },
+    {
+      "source": "109",
+      "target": "119",
+      "weight": 2.0
+    },
+    {
+      "source": "36",
+      "target": "50",
+      "weight": 5.0
+    },
+    {
+      "source": "30",
+      "target": "85",
+      "weight": 1.0
+    },
+    {
+      "source": "86",
+      "target": "9",
+      "weight": 3.0
+    },
+    {
+      "source": "85",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "20",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "20",
+      "weight": 1.0
+    },
+    {
+      "source": "64",
+      "target": "8",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "153",
+      "weight": 1.0
+    },
+    {
+      "source": "30",
+      "target": "42",
+      "weight": 1.0
+    },
+    {
+      "source": "46",
+      "target": "7",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "49",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "170",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "164",
+      "target": "34",
+      "weight": 1.0
+    },
+    {
+      "source": "62",
+      "target": "73",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "148",
+      "weight": 5.0
+    },
+    {
+      "source": "114",
+      "target": "94",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "80",
+      "weight": 3.0
+    },
+    {
+      "source": "146",
+      "target": "2",
+      "weight": 1.0
+    },
+    {
+      "source": "1",
+      "target": "6",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "17",
+      "weight": 2.0
+    },
+    {
+      "source": "157",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "94",
+      "weight": 3.0
+    },
+    {
+      "source": "169",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "152",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "41",
+      "weight": 2.0
+    },
+    {
+      "source": "158",
+      "target": "45",
+      "weight": 3.0
+    },
+    {
+      "source": "146",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "157",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "7",
+      "target": "92",
+      "weight": 15.0
+    },
+    {
+      "source": "42",
+      "target": "56",
+      "weight": 1.0
+    },
+    {
+      "source": "2",
+      "target": "60",
+      "weight": 2.0
+    },
+    {
+      "source": "117",
+      "target": "7",
+      "weight": 4.0
+    },
+    {
+      "source": "64",
+      "target": "71",
+      "weight": 1.0
+    },
+    {
+      "source": "46",
+      "target": "5",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "53",
+      "weight": 3.0
+    },
+    {
+      "source": "146",
+      "target": "88",
+      "weight": 4.0
+    },
+    {
+      "source": "50",
+      "target": "67",
+      "weight": 1.0
+    },
+    {
+      "source": "26",
+      "target": "70",
+      "weight": 7.0
+    },
+    {
+      "source": "135",
+      "target": "5",
+      "weight": 6.0
+    },
+    {
+      "source": "7",
+      "target": "93",
+      "weight": 13.0
+    },
+    {
+      "source": "158",
+      "target": "61",
+      "weight": 3.0
+    },
+    {
+      "source": "37",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "146",
+      "target": "158",
+      "weight": 2.0
+    },
+    {
+      "source": "166",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "59",
+      "weight": 12.0
+    },
+    {
+      "source": "130",
+      "target": "25",
+      "weight": 3.0
+    },
+    {
+      "source": "23",
+      "target": "67",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "46",
+      "weight": 4.0
+    },
+    {
+      "source": "29",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "153",
+      "target": "159",
+      "weight": 2.0
+    },
+    {
+      "source": "41",
+      "target": "49",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "70",
+      "weight": 2.0
+    },
+    {
+      "source": "12",
+      "target": "62",
+      "weight": 5.0
+    },
+    {
+      "source": "46",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "5",
+      "weight": 4.0
+    },
+    {
+      "source": "125",
+      "target": "151",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "154",
+      "weight": 5.0
+    },
+    {
+      "source": "166",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "26",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "60",
+      "target": "96",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "62",
+      "weight": 29.0
+    },
+    {
+      "source": "127",
+      "target": "59",
+      "weight": 9.0
+    },
+    {
+      "source": "161",
+      "target": "49",
+      "weight": 2.0
+    },
+    {
+      "source": "14",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "40",
+      "target": "92",
+      "weight": 3.0
+    },
+    {
+      "source": "108",
+      "target": "123",
+      "weight": 1.0
+    },
+    {
+      "source": "134",
+      "target": "42",
+      "weight": 3.0
+    },
+    {
+      "source": "38",
+      "target": "71",
+      "weight": 1.0
+    },
+    {
+      "source": "12",
+      "target": "43",
+      "weight": 2.0
+    },
+    {
+      "source": "2",
+      "target": "92",
+      "weight": 4.0
+    },
+    {
+      "source": "110",
+      "target": "158",
+      "weight": 2.0
+    },
+    {
+      "source": "51",
+      "target": "75",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "151",
+      "weight": 18.0
+    },
+    {
+      "source": "127",
+      "target": "54",
+      "weight": 2.0
+    },
+    {
+      "source": "171",
+      "target": "30",
+      "weight": 17.0
+    },
+    {
+      "source": "53",
+      "target": "97",
+      "weight": 1.0
+    },
+    {
+      "source": "155",
+      "target": "65",
+      "weight": 6.0
+    },
+    {
+      "source": "110",
+      "target": "43",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "51",
+      "weight": 6.0
+    },
+    {
+      "source": "113",
+      "target": "135",
+      "weight": 4.0
+    },
+    {
+      "source": "12",
+      "target": "89",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "6",
+      "target": "94",
+      "weight": 1.0
+    },
+    {
+      "source": "107",
+      "target": "51",
+      "weight": 1.0
+    },
+    {
+      "source": "30",
+      "target": "75",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "48",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "52",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "93",
+      "weight": 1.0
+    },
+    {
+      "source": "64",
+      "target": "93",
+      "weight": 9.0
+    },
+    {
+      "source": "3",
+      "target": "90",
+      "weight": 11.0
+    },
+    {
+      "source": "151",
+      "target": "79",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "47",
+      "weight": 2.0
+    },
+    {
+      "source": "141",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "55",
+      "target": "95",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "28",
+      "target": "38",
+      "weight": 2.0
+    },
+    {
+      "source": "50",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "24",
+      "weight": 3.0
+    },
+    {
+      "source": "159",
+      "target": "45",
+      "weight": 4.0
+    },
+    {
+      "source": "129",
+      "target": "34",
+      "weight": 2.0
+    },
+    {
+      "source": "34",
+      "target": "42",
+      "weight": 4.0
+    },
+    {
+      "source": "162",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "129",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "60",
+      "weight": 73.0
+    },
+    {
+      "source": "46",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "171",
+      "target": "23",
+      "weight": 1.0
+    },
+    {
+      "source": "11",
+      "target": "37",
+      "weight": 61.0
+    },
+    {
+      "source": "119",
+      "target": "159",
+      "weight": 2.0
+    },
+    {
+      "source": "21",
+      "target": "25",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "68",
+      "weight": 4.0
+    },
+    {
+      "source": "135",
+      "target": "54",
+      "weight": 8.0
+    },
+    {
+      "source": "53",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "43",
+      "weight": 1.0
+    },
+    {
+      "source": "116",
+      "target": "120",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "34",
+      "weight": 4.0
+    },
+    {
+      "source": "140",
+      "target": "51",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "92",
+      "weight": 29.0
+    },
+    {
+      "source": "159",
+      "target": "7",
+      "weight": 6.0
+    },
+    {
+      "source": "160",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "156",
+      "target": "28",
+      "weight": 9.0
+    },
+    {
+      "source": "112",
+      "target": "37",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "168",
+      "weight": 15.0
+    },
+    {
+      "source": "129",
+      "target": "147",
+      "weight": 1.0
+    },
+    {
+      "source": "26",
+      "target": "6",
+      "weight": 3.0
+    },
+    {
+      "source": "14",
+      "target": "53",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "49",
+      "weight": 2.0
+    },
+    {
+      "source": "86",
+      "target": "93",
+      "weight": 4.0
+    },
+    {
+      "source": "111",
+      "target": "91",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "39",
+      "weight": 1.0
+    },
+    {
+      "source": "46",
+      "target": "66",
+      "weight": 1.0
+    },
+    {
+      "source": "49",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "17",
+      "target": "94",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "66",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "21",
+      "weight": 16.0
+    },
+    {
+      "source": "37",
+      "target": "41",
+      "weight": 3.0
+    },
+    {
+      "source": "135",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "18",
+      "target": "30",
+      "weight": 2.0
+    },
+    {
+      "source": "153",
+      "target": "7",
+      "weight": 6.0
+    },
+    {
+      "source": "150",
+      "target": "20",
+      "weight": 1.0
+    },
+    {
+      "source": "23",
+      "target": "53",
+      "weight": 2.0
+    },
+    {
+      "source": "38",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "165",
+      "target": "36",
+      "weight": 2.0
+    },
+    {
+      "source": "176",
+      "target": "43",
+      "weight": 1.0
+    },
+    {
+      "source": "168",
+      "target": "38",
+      "weight": 2.0
+    },
+    {
+      "source": "24",
+      "target": "56",
+      "weight": 1.0
+    },
+    {
+      "source": "134",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "38",
+      "weight": 3.0
+    },
+    {
+      "source": "137",
+      "target": "39",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "9",
+      "weight": 3.0
+    },
+    {
+      "source": "52",
+      "target": "92",
+      "weight": 12.0
+    },
+    {
+      "source": "110",
+      "target": "88",
+      "weight": 2.0
+    },
+    {
+      "source": "137",
+      "target": "97",
+      "weight": 1.0
+    },
+    {
+      "source": "30",
+      "target": "51",
+      "weight": 4.0
+    },
+    {
+      "source": "21",
+      "target": "38",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "159",
+      "weight": 9.0
+    },
+    {
+      "source": "109",
+      "target": "67",
+      "weight": 1.0
+    },
+    {
+      "source": "24",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "11",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "88",
+      "weight": 2.0
+    },
+    {
+      "source": "21",
+      "target": "75",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "59",
+      "weight": 186.0
+    },
+    {
+      "source": "138",
+      "target": "150",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "144",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "150",
+      "weight": 5.0
+    },
+    {
+      "source": "102",
+      "target": "156",
+      "weight": 4.0
+    },
+    {
+      "source": "158",
+      "target": "54",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "101",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "110",
+      "weight": 1.0
+    },
+    {
+      "source": "24",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "64",
+      "target": "82",
+      "weight": 6.0
+    },
+    {
+      "source": "2",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "12",
+      "target": "31",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "32",
+      "weight": 2.0
+    },
+    {
+      "source": "146",
+      "target": "61",
+      "weight": 2.0
+    },
+    {
+      "source": "35",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "146",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "5",
+      "target": "99",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "7",
+      "weight": 3.0
+    },
+    {
+      "source": "150",
+      "target": "82",
+      "weight": 1.0
+    },
+    {
+      "source": "29",
+      "target": "72",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "82",
+      "weight": 5.0
+    },
+    {
+      "source": "84",
+      "target": "92",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "53",
+      "weight": 9.0
+    },
+    {
+      "source": "175",
+      "target": "84",
+      "weight": 3.0
+    },
+    {
+      "source": "132",
+      "target": "148",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "34",
+      "weight": 30.0
+    },
+    {
+      "source": "150",
+      "target": "89",
+      "weight": 1.0
+    },
+    {
+      "source": "12",
+      "target": "37",
+      "weight": 5.0
+    },
+    {
+      "source": "12",
+      "target": "8",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "16",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "42",
+      "weight": 22.0
+    },
+    {
+      "source": "123",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "126",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "36",
+      "weight": 2.0
+    },
+    {
+      "source": "106",
+      "target": "170",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "29",
+      "weight": 2.0
+    },
+    {
+      "source": "138",
+      "target": "18",
+      "weight": 1.0
+    },
+    {
+      "source": "119",
+      "target": "9",
+      "weight": 5.0
+    },
+    {
+      "source": "151",
+      "target": "54",
+      "weight": 72.0
+    },
+    {
+      "source": "37",
+      "target": "62",
+      "weight": 8.0
+    },
+    {
+      "source": "135",
+      "target": "7",
+      "weight": 4.0
+    },
+    {
+      "source": "58",
+      "target": "82",
+      "weight": 1.0
+    },
+    {
+      "source": "41",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "176",
+      "target": "37",
+      "weight": 2.0
+    },
+    {
+      "source": "150",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "5",
+      "weight": 3.0
+    },
+    {
+      "source": "49",
+      "target": "89",
+      "weight": 4.0
+    },
+    {
+      "source": "137",
+      "target": "38",
+      "weight": 7.0
+    },
+    {
+      "source": "47",
+      "target": "66",
+      "weight": 2.0
+    },
+    {
+      "source": "119",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "132",
+      "target": "49",
+      "weight": 2.0
+    },
+    {
+      "source": "157",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "38",
+      "weight": 2.0
+    },
+    {
+      "source": "129",
+      "target": "136",
+      "weight": 1.0
+    },
+    {
+      "source": "45",
+      "target": "90",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "30",
+      "weight": 1.0
+    },
+    {
+      "source": "138",
+      "target": "21",
+      "weight": 1.0
+    },
+    {
+      "source": "10",
+      "target": "137",
+      "weight": 1.0
+    },
+    {
+      "source": "9",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "50",
+      "target": "7",
+      "weight": 4.0
+    },
+    {
+      "source": "156",
+      "target": "50",
+      "weight": 6.0
+    },
+    {
+      "source": "169",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "72",
+      "weight": 4.0
+    },
+    {
+      "source": "137",
+      "target": "28",
+      "weight": 1.0
+    },
+    {
+      "source": "64",
+      "target": "99",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "7",
+      "weight": 1.0
+    },
+    {
+      "source": "11",
+      "target": "92",
+      "weight": 3.0
+    },
+    {
+      "source": "111",
+      "target": "3",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "9",
+      "weight": 17.0
+    },
+    {
+      "source": "151",
+      "target": "52",
+      "weight": 87.0
+    },
+    {
+      "source": "126",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "30",
+      "target": "81",
+      "weight": 1.0
+    },
+    {
+      "source": "176",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "40",
+      "weight": 9.0
+    },
+    {
+      "source": "120",
+      "target": "3",
+      "weight": 3.0
+    },
+    {
+      "source": "135",
+      "target": "20",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "57",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "152",
+      "weight": 8.0
+    },
+    {
+      "source": "151",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "45",
+      "weight": 6.0
+    },
+    {
+      "source": "46",
+      "target": "80",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "146",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "34",
+      "weight": 21.0
+    },
+    {
+      "source": "132",
+      "target": "34",
+      "weight": 11.0
+    },
+    {
+      "source": "135",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "125",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "168",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "62",
+      "target": "89",
+      "weight": 2.0
+    },
+    {
+      "source": "148",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "155",
+      "target": "49",
+      "weight": 2.0
+    },
+    {
+      "source": "46",
+      "target": "47",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "51",
+      "weight": 6.0
+    },
+    {
+      "source": "39",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "38",
+      "weight": 2.0
+    },
+    {
+      "source": "64",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "20",
+      "weight": 2.0
+    },
+    {
+      "source": "46",
+      "target": "49",
+      "weight": 7.0
+    },
+    {
+      "source": "114",
+      "target": "20",
+      "weight": 5.0
+    },
+    {
+      "source": "38",
+      "target": "64",
+      "weight": 2.0
+    },
+    {
+      "source": "122",
+      "target": "135",
+      "weight": 6.0
+    },
+    {
+      "source": "150",
+      "target": "158",
+      "weight": 2.0
+    },
+    {
+      "source": "137",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "76",
+      "weight": 1.0
+    },
+    {
+      "source": "29",
+      "target": "98",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "17",
+      "weight": 1.0
+    },
+    {
+      "source": "5",
+      "target": "58",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "18",
+      "weight": 2.0
+    },
+    {
+      "source": "118",
+      "target": "166",
+      "weight": 2.0
+    },
+    {
+      "source": "130",
+      "target": "64",
+      "weight": 6.0
+    },
+    {
+      "source": "151",
+      "target": "49",
+      "weight": 24.0
+    },
+    {
+      "source": "113",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "44",
+      "weight": 3.0
+    },
+    {
+      "source": "42",
+      "target": "45",
+      "weight": 5.0
+    },
+    {
+      "source": "106",
+      "target": "108",
+      "weight": 5.0
+    },
+    {
+      "source": "135",
+      "target": "76",
+      "weight": 1.0
+    },
+    {
+      "source": "138",
+      "target": "16",
+      "weight": 2.0
+    },
+    {
+      "source": "41",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "128",
+      "target": "30",
+      "weight": 1.0
+    },
+    {
+      "source": "15",
+      "target": "159",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "30",
+      "weight": 17.0
+    },
+    {
+      "source": "123",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "12",
+      "weight": 10.0
+    },
+    {
+      "source": "119",
+      "target": "144",
+      "weight": 5.0
+    },
+    {
+      "source": "140",
+      "target": "82",
+      "weight": 4.0
+    },
+    {
+      "source": "33",
+      "target": "50",
+      "weight": 3.0
+    },
+    {
+      "source": "110",
+      "target": "146",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "43",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "60",
+      "weight": 17.0
+    },
+    {
+      "source": "147",
+      "target": "43",
+      "weight": 1.0
+    },
+    {
+      "source": "137",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "36",
+      "target": "38",
+      "weight": 3.0
+    },
+    {
+      "source": "30",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "141",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "150",
+      "weight": 1.0
+    },
+    {
+      "source": "45",
+      "target": "64",
+      "weight": 8.0
+    },
+    {
+      "source": "150",
+      "target": "58",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "64",
+      "weight": 3.0
+    },
+    {
+      "source": "136",
+      "target": "151",
+      "weight": 4.0
+    },
+    {
+      "source": "150",
+      "target": "53",
+      "weight": 3.0
+    },
+    {
+      "source": "44",
+      "target": "49",
+      "weight": 8.0
+    },
+    {
+      "source": "29",
+      "target": "97",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "51",
+      "weight": 2.0
+    },
+    {
+      "source": "140",
+      "target": "15",
+      "weight": 1.0
+    },
+    {
+      "source": "115",
+      "target": "117",
+      "weight": 4.0
+    },
+    {
+      "source": "12",
+      "target": "146",
+      "weight": 2.0
+    },
+    {
+      "source": "162",
+      "target": "63",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "25",
+      "target": "61",
+      "weight": 1.0
+    },
+    {
+      "source": "71",
+      "target": "90",
+      "weight": 1.0
+    },
+    {
+      "source": "141",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "28",
+      "weight": 9.0
+    },
+    {
+      "source": "111",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "59",
+      "target": "92",
+      "weight": 7.0
+    },
+    {
+      "source": "112",
+      "target": "120",
+      "weight": 4.0
+    },
+    {
+      "source": "88",
+      "target": "89",
+      "weight": 3.0
+    },
+    {
+      "source": "114",
+      "target": "21",
+      "weight": 9.0
+    },
+    {
+      "source": "132",
+      "target": "40",
+      "weight": 1.0
+    },
+    {
+      "source": "125",
+      "target": "92",
+      "weight": 2.0
+    },
+    {
+      "source": "113",
+      "target": "150",
+      "weight": 2.0
+    },
+    {
+      "source": "122",
+      "target": "2",
+      "weight": 5.0
+    },
+    {
+      "source": "159",
+      "target": "51",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "2",
+      "weight": 14.0
+    },
+    {
+      "source": "47",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "3",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "147",
+      "target": "92",
+      "weight": 6.0
+    },
+    {
+      "source": "24",
+      "target": "51",
+      "weight": 1.0
+    },
+    {
+      "source": "5",
+      "target": "66",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "42",
+      "weight": 2.0
+    },
+    {
+      "source": "137",
+      "target": "173",
+      "weight": 1.0
+    },
+    {
+      "source": "161",
+      "target": "79",
+      "weight": 1.0
+    },
+    {
+      "source": "21",
+      "target": "93",
+      "weight": 2.0
+    },
+    {
+      "source": "117",
+      "target": "144",
+      "weight": 7.0
+    },
+    {
+      "source": "152",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "174",
+      "weight": 1.0
+    },
+    {
+      "source": "150",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "107",
+      "target": "62",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "47",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "34",
+      "weight": 12.0
+    },
+    {
+      "source": "141",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "34",
+      "weight": 7.0
+    },
+    {
+      "source": "150",
+      "target": "50",
+      "weight": 2.0
+    },
+    {
+      "source": "152",
+      "target": "25",
+      "weight": 2.0
+    },
+    {
+      "source": "137",
+      "target": "148",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "21",
+      "weight": 3.0
+    },
+    {
+      "source": "106",
+      "target": "42",
+      "weight": 6.0
+    },
+    {
+      "source": "143",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "41",
+      "target": "77",
+      "weight": 1.0
+    },
+    {
+      "source": "117",
+      "target": "152",
+      "weight": 1.0
+    },
+    {
+      "source": "113",
+      "target": "49",
+      "weight": 6.0
+    },
+    {
+      "source": "143",
+      "target": "176",
+      "weight": 1.0
+    },
+    {
+      "source": "110",
+      "target": "92",
+      "weight": 7.0
+    },
+    {
+      "source": "41",
+      "target": "89",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "82",
+      "weight": 1.0
+    },
+    {
+      "source": "9",
+      "target": "91",
+      "weight": 4.0
+    },
+    {
+      "source": "135",
+      "target": "142",
+      "weight": 2.0
+    },
+    {
+      "source": "21",
+      "target": "4",
+      "weight": 1.0
+    },
+    {
+      "source": "112",
+      "target": "31",
+      "weight": 2.0
+    },
+    {
+      "source": "115",
+      "target": "50",
+      "weight": 1.0
+    },
+    {
+      "source": "146",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "89",
+      "weight": 4.0
+    },
+    {
+      "source": "150",
+      "target": "79",
+      "weight": 1.0
+    },
+    {
+      "source": "41",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "20",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "174",
+      "weight": 1.0
+    },
+    {
+      "source": "111",
+      "target": "162",
+      "weight": 1.0
+    },
+    {
+      "source": "106",
+      "target": "148",
+      "weight": 6.0
+    },
+    {
+      "source": "166",
+      "target": "27",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "171",
+      "weight": 2.0
+    },
+    {
+      "source": "37",
+      "target": "43",
+      "weight": 6.0
+    },
+    {
+      "source": "152",
+      "target": "42",
+      "weight": 8.0
+    },
+    {
+      "source": "116",
+      "target": "89",
+      "weight": 3.0
+    },
+    {
+      "source": "158",
+      "target": "60",
+      "weight": 1.0
+    },
+    {
+      "source": "43",
+      "target": "88",
+      "weight": 9.0
+    },
+    {
+      "source": "11",
+      "target": "127",
+      "weight": 4.0
+    },
+    {
+      "source": "132",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "153",
+      "target": "85",
+      "weight": 1.0
+    },
+    {
+      "source": "15",
+      "target": "56",
+      "weight": 2.0
+    },
+    {
+      "source": "112",
+      "target": "3",
+      "weight": 2.0
+    },
+    {
+      "source": "121",
+      "target": "148",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "62",
+      "weight": 19.0
+    },
+    {
+      "source": "50",
+      "target": "62",
+      "weight": 9.0
+    },
+    {
+      "source": "126",
+      "target": "89",
+      "weight": 1.0
+    },
+    {
+      "source": "31",
+      "target": "92",
+      "weight": 1.0
+    },
+    {
+      "source": "136",
+      "target": "51",
+      "weight": 3.0
+    },
+    {
+      "source": "62",
+      "target": "97",
+      "weight": 2.0
+    },
+    {
+      "source": "110",
+      "target": "140",
+      "weight": 2.0
+    },
+    {
+      "source": "4",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "30",
+      "target": "4",
+      "weight": 2.0
+    },
+    {
+      "source": "114",
+      "target": "173",
+      "weight": 1.0
+    },
+    {
+      "source": "132",
+      "target": "152",
+      "weight": 2.0
+    },
+    {
+      "source": "89",
+      "target": "92",
+      "weight": 2.0
+    },
+    {
+      "source": "166",
+      "target": "92",
+      "weight": 3.0
+    },
+    {
+      "source": "41",
+      "target": "44",
+      "weight": 1.0
+    },
+    {
+      "source": "67",
+      "target": "9",
+      "weight": 24.0
+    },
+    {
+      "source": "126",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "127",
+      "target": "37",
+      "weight": 8.0
+    },
+    {
+      "source": "121",
+      "target": "134",
+      "weight": 1.0
+    },
+    {
+      "source": "114",
+      "target": "170",
+      "weight": 1.0
+    },
+    {
+      "source": "107",
+      "target": "110",
+      "weight": 8.0
+    },
+    {
+      "source": "162",
+      "target": "45",
+      "weight": 1.0
+    },
+    {
+      "source": "116",
+      "target": "58",
+      "weight": 1.0
+    },
+    {
+      "source": "120",
+      "target": "39",
+      "weight": 1.0
+    },
+    {
+      "source": "116",
+      "target": "151",
+      "weight": 6.0
+    },
+    {
+      "source": "131",
+      "target": "150",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "154",
+      "weight": 2.0
+    },
+    {
+      "source": "38",
+      "target": "9",
+      "weight": 1.0
+    },
+    {
+      "source": "128",
+      "target": "150",
+      "weight": 7.0
+    },
+    {
+      "source": "51",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "13",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "107",
+      "target": "59",
+      "weight": 1.0
+    },
+    {
+      "source": "8",
+      "target": "88",
+      "weight": 1.0
+    },
+    {
+      "source": "41",
+      "target": "61",
+      "weight": 1.0
+    },
+    {
+      "source": "45",
+      "target": "65",
+      "weight": 7.0
+    },
+    {
+      "source": "146",
+      "target": "150",
+      "weight": 3.0
+    },
+    {
+      "source": "113",
+      "target": "89",
+      "weight": 80.0
+    },
+    {
+      "source": "141",
+      "target": "166",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "9",
+      "weight": 24.0
+    },
+    {
+      "source": "23",
+      "target": "30",
+      "weight": 2.0
+    },
+    {
+      "source": "12",
+      "target": "64",
+      "weight": 1.0
+    },
+    {
+      "source": "158",
+      "target": "8",
+      "weight": 1.0
+    },
+    {
+      "source": "151",
+      "target": "96",
+      "weight": 32.0
+    },
+    {
+      "source": "114",
+      "target": "159",
+      "weight": 1.0
+    },
+    {
+      "source": "121",
+      "target": "51",
+      "weight": 1.0
+    },
+    {
+      "source": "108",
+      "target": "38",
+      "weight": 4.0
+    },
+    {
+      "source": "12",
+      "target": "151",
+      "weight": 37.0
+    },
+    {
+      "source": "12",
+      "target": "92",
+      "weight": 27.0
+    },
+    {
+      "source": "129",
+      "target": "173",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "34",
+      "weight": 9.0
+    },
+    {
+      "source": "170",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "38",
+      "target": "7",
+      "weight": 2.0
+    },
+    {
+      "source": "27",
+      "target": "28",
+      "weight": 1.0
+    },
+    {
+      "source": "105",
+      "target": "106",
+      "weight": 6.0
+    },
+    {
+      "source": "108",
+      "target": "159",
+      "weight": 8.0
+    },
+    {
+      "source": "30",
+      "target": "73",
+      "weight": 1.0
+    },
+    {
+      "source": "152",
+      "target": "75",
+      "weight": 1.0
+    },
+    {
+      "source": "130",
+      "target": "24",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "40",
+      "weight": 1.0
+    },
+    {
+      "source": "49",
+      "target": "88",
+      "weight": 2.0
+    },
+    {
+      "source": "129",
+      "target": "130",
+      "weight": 3.0
+    },
+    {
+      "source": "38",
+      "target": "99",
+      "weight": 1.0
+    },
+    {
+      "source": "166",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "37",
+      "target": "46",
+      "weight": 3.0
+    },
+    {
+      "source": "6",
+      "target": "93",
+      "weight": 1.0
+    },
+    {
+      "source": "159",
+      "target": "17",
+      "weight": 1.0
+    },
+    {
+      "source": "17",
+      "target": "41",
+      "weight": 1.0
+    },
+    {
+      "source": "154",
+      "target": "25",
+      "weight": 2.0
+    },
+    {
+      "source": "34",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "12",
+      "target": "60",
+      "weight": 1.0
+    },
+    {
+      "source": "136",
+      "target": "37",
+      "weight": 1.0
+    },
+    {
+      "source": "162",
+      "target": "80",
+      "weight": 1.0
+    },
+    {
+      "source": "42",
+      "target": "72",
+      "weight": 1.0
+    },
+    {
+      "source": "174",
+      "target": "62",
+      "weight": 3.0
+    },
+    {
+      "source": "150",
+      "target": "27",
+      "weight": 2.0
+    },
+    {
+      "source": "1",
+      "target": "10",
+      "weight": 2.0
+    },
+    {
+      "source": "137",
+      "target": "37",
+      "weight": 2.0
+    },
+    {
+      "source": "146",
+      "target": "42",
+      "weight": 1.0
+    },
+    {
+      "source": "144",
+      "target": "159",
+      "weight": 7.0
+    },
+    {
+      "source": "151",
+      "target": "37",
+      "weight": 50.0
+    },
+    {
+      "source": "20",
+      "target": "45",
+      "weight": 2.0
+    },
+    {
+      "source": "151",
+      "target": "46",
+      "weight": 1.0
+    },
+    {
+      "source": "16",
+      "target": "46",
+      "weight": 2.0
+    },
+    {
+      "source": "153",
+      "target": "94",
+      "weight": 7.0
+    },
+    {
+      "source": "165",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "140",
+      "target": "49",
+      "weight": 1.0
+    },
+    {
+      "source": "129",
+      "target": "137",
+      "weight": 1.0
+    },
+    {
+      "source": "40",
+      "target": "5",
+      "weight": 1.0
+    },
+    {
+      "source": "135",
+      "target": "99",
+      "weight": 2.0
+    }
+  ],
+  "metadata": {
+    "Cyber Security and Military.md": {
+      "fileName": "Cyber Security and Military.md",
+      "fileSize": 7660,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 5,
+      "sha1": "0d77069c4652291b0b72eba82c76b348a98f5e6c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:12.521706348Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Large language models": 2,
+        "OpenAI": 2,
+        "Money": 1,
+        "infrastructure": 2,
+        "Accessibility": 1,
+        "Landscape": 1,
+        "Machine Learning": 1
+      }
+    },
+    "Safety and alignment.md": {
+      "fileName": "Safety and alignment.md",
+      "fileSize": 20446,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 12,
+      "sha1": "b5b56905d6989e3d22896938603efceef2f2c4b3",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:12.712173362Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Artificial Intelligence": 2,
+        "Machine Learning": 1,
+        "Social contract and jobs": 1,
+        "Large language models": 1,
+        "Jailbreaking": 1,
+        "Safety and alignment": 3,
+        "OpenAI": 9,
+        "AI Risks": 1,
+        "infrastructure": 1,
+        "Reasoning": 9,
+        "AI Companies": 1
+      }
+    },
+    "EU AI Act.md": {
+      "fileName": "EU AI Act.md",
+      "fileSize": 3083,
+      "nodeSize": 32.747,
+      "hyperlinkCount": 3,
+      "sha1": "8011544e9477ea2abff18e4ef87491413610bb83",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:37.110117398Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Automated Podcast Project.md": {
+      "fileName": "Automated Podcast Project.md",
+      "fileSize": 10866,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "7f2b6e7a9d0ee3e2ea7ed7aff67d22ceae6180c4",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:33.168468016Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agents": 1
+      }
+    },
+    "Cyber security and Cryptography.md": {
+      "fileName": "Cyber security and Cryptography.md",
+      "fileSize": 16387,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 33,
+      "sha1": "ace29f98d0f2146bf80e622130e739488ce7ad10",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:13.298803947Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "AI Risks": 1,
+        "Artificial Intelligence": 4,
+        "ComfyUI": 2,
+        "OpenAI": 5,
+        "Gemini": 3,
+        "Stable Diffusion": 8,
+        "infrastructure": 2,
+        "Landscape": 1,
+        "Open Generative AI tools": 2,
+        "ChatGPT": 5,
+        "license": 2,
+        "Large language models": 3,
+        "Jailbreaking": 4,
+        "Machine Learning": 9,
+        "Cyber security and Cryptography": 1
+      }
+    },
+    "Model Optimisation and Performance.md": {
+      "fileName": "Model Optimisation and Performance.md",
+      "fileSize": 10270,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 17,
+      "sha1": "ea57b42268867df3930c1c25869b5cd10e8a79db",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:08.337700305Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Large language models": 2,
+        "Machine Learning": 3,
+        "Reasoning": 3,
+        "Transformers": 1
+      }
+    },
+    "debug linked node.md": {
+      "fileName": "debug linked node.md",
+      "fileSize": 63,
+      "nodeSize": 5.567,
+      "hyperlinkCount": 0,
+      "sha1": "d33bc80ce9d690c8c64301ce5346f36923791a44",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:18.811983489Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Debug Test Page": 1
+      }
+    },
+    "AI privacy at the 2024 Olympics.md": {
+      "fileName": "AI privacy at the 2024 Olympics.md",
+      "fileSize": 8139,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 0,
+      "sha1": "83c457c54a6b1a1002b99c2925a3932566065000",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:15.129064190Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 2
+      }
+    },
+    "Inpainting.md": {
+      "fileName": "Inpainting.md",
+      "fileSize": 59,
+      "nodeSize": 5.531,
+      "hyperlinkCount": 0,
+      "sha1": "c57f67f385311e21f99ab67644e7255e55f527f8",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:22.504679687Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Facebook Meta.md": {
+      "fileName": "Facebook Meta.md",
+      "fileSize": 4010,
+      "nodeSize": 41.09,
+      "hyperlinkCount": 0,
+      "sha1": "3e69fe704332a5acd97ef2f7fe33316435746521",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:51.664742754Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Llama": 2,
+        "Reasoning": 1
+      }
+    },
+    "Artificial Intelligence.md": {
+      "fileName": "Artificial Intelligence.md",
+      "fileSize": 5855,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 3,
+      "sha1": "fac1de351c9748757d44ab1f29cfac303375f5c8",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:30.499678098Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 1,
+        "Artificial Intelligence": 2,
+        "Machine Learning": 1
+      }
+    },
+    "Human vs AI.md": {
+      "fileName": "Human vs AI.md",
+      "fileSize": 5108,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 2,
+      "sha1": "b58000500c57498c0185bae55711f3c39a6e4b80",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:16.347956259Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 1
+      }
+    },
+    "Machine Learning.md": {
+      "fileName": "Machine Learning.md",
+      "fileSize": 13286,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 2,
+      "sha1": "7b913576c8bfd54db847194b7fd4954a4d278a81",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:54.945571374Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agents": 2,
+        "Gemini": 2,
+        "Accessibility": 1,
+        "Machine Learning": 1,
+        "Reasoning": 6,
+        "Llama": 2
+      }
+    },
+    "Procedural and Hybrid 4D.md": {
+      "fileName": "Procedural and Hybrid 4D.md",
+      "fileSize": 61,
+      "nodeSize": 5.549,
+      "hyperlinkCount": 1,
+      "sha1": "acdf93b3d0575cfa737136aace02dff3c6c015e9",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:41.278603964Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "AI Scrapers.md": {
+      "fileName": "AI Scrapers.md",
+      "fileSize": 3595,
+      "nodeSize": 37.355,
+      "hyperlinkCount": 6,
+      "sha1": "c40d851b73a53207c202885fb87f8a254c48e3d0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:10.325289187Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agents": 1,
+        "Knowledge Graphing and RAG": 1,
+        "Privacy, Trust and Safety": 1,
+        "AI Scrapers": 7,
+        "Machine Learning": 1
+      }
+    },
+    "Research Tools.md": {
+      "fileName": "Research Tools.md",
+      "fileSize": 8185,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 8,
+      "sha1": "5ee11413b4e4ba0d6004ed2846bab5404581d0b0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:02.225944520Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Reasoning": 4,
+        "Research Tools": 2
+      }
+    },
+    "Prompt Engineering.md": {
+      "fileName": "Prompt Engineering.md",
+      "fileSize": 33404,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 68,
+      "sha1": "0d7b1fd8f9acf47e96641a3ab34fd5d107a71eaf",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:44.724314374Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Diffusion": 2,
+        "Courses and Training": 2,
+        "Reasoning": 6,
+        "Apple": 2,
+        "Anthropic Claude": 1,
+        "Llama": 4,
+        "artificial superintelligence": 1,
+        "ollama": 4,
+        "Training and fine tuning": 1,
+        "Evaluation benchmarks and leaderboards": 1,
+        "multimodal": 1,
+        "Diagrams as Code": 3,
+        "Model Optimisation and Performance": 1,
+        "ComfyUI": 17,
+        "Prompt Engineering": 60,
+        "Adoption of Convergent Technologies": 1,
+        "OpenAI": 9,
+        "Diffusion Models": 3,
+        "ChatGPT": 19,
+        "Large language models": 15,
+        "Artificial Intelligence": 1,
+        "Gold": 3,
+        "AI Video": 2
+      }
+    },
+    "Lead Poisoning Hypothesis.md": {
+      "fileName": "Lead Poisoning Hypothesis.md",
+      "fileSize": 3998,
+      "nodeSize": 40.982,
+      "hyperlinkCount": 1,
+      "sha1": "ac2e67660cef93025f7583d726ad4bfb083ad9c0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:38.678293360Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 1
+      }
+    },
+    "ComfyUI.md": {
+      "fileName": "ComfyUI.md",
+      "fileSize": 36608,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 126,
+      "sha1": "14934e91d17fdd724433532a6b7261a04463a59c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:57.363689285Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 2,
+        "license": 1,
+        "Courses and Training": 1,
+        "Gemini": 24,
+        "Inpainting": 5,
+        "AnimateDiff": 1,
+        "LoRA DoRA etc": 4,
+        "Artificial Intelligence": 1,
+        "IPAdapter": 3,
+        "Stable Diffusion": 19,
+        "ComfyUI": 151,
+        "collaborative": 1,
+        "ChatGPT": 3,
+        "Upscaling": 9,
+        "Apple": 2,
+        "Diffusion Models": 3,
+        "Large language models": 2
+      }
+    },
+    "Upscaling.md": {
+      "fileName": "Upscaling.md",
+      "fileSize": 1184,
+      "nodeSize": 15.656,
+      "hyperlinkCount": 7,
+      "sha1": "2e5ac91fce4545f7c42fcb0bc52459fddf3244a2",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:53.611066677Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "ComfyUI": 9,
+        "Upscaling": 3,
+        "Stable Diffusion": 1
+      }
+    },
+    "legacy media.md": {
+      "fileName": "legacy media.md",
+      "fileSize": 355,
+      "nodeSize": 8.195,
+      "hyperlinkCount": 2,
+      "sha1": "0aacca2e2a9a74108599260b3f8a08316b9d9aa0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:32.982191741Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Artificial Intelligence": 1
+      }
+    },
+    "Llama.md": {
+      "fileName": "Llama.md",
+      "fileSize": 3432,
+      "nodeSize": 35.888,
+      "hyperlinkCount": 4,
+      "sha1": "17bedfd3acc866c641f2d5d5b0afea83475ca516",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:47.270258004Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "license": 5,
+        "Accessibility": 1,
+        "Large language models": 1,
+        "Llama": 12
+      }
+    },
+    "Soon-Next-Later (AI futurology).md": {
+      "fileName": "Soon-Next-Later (AI futurology).md",
+      "fileSize": 12919,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 7,
+      "sha1": "97430e99a9729dff31703fdea9ca54aa9956e021",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:23.833211039Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "multimodal": 4,
+        "Distributed Identity": 1,
+        "Sam Hammond": 1,
+        "Diagrams as Code": 1,
+        "Death of the Internet": 2,
+        "Money": 1,
+        "collaborative": 4,
+        "Social contract and jobs": 1,
+        "Mixed reality": 1,
+        "Politics, Law, Privacy": 1,
+        "Interfaces": 5,
+        "OpenAI": 1,
+        "Cyber security and Cryptography": 1,
+        "Agents": 5,
+        "Education and AI": 3
+      }
+    },
+    "Knowledge Graphing and RAG.md": {
+      "fileName": "Knowledge Graphing and RAG.md",
+      "fileSize": 21956,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 55,
+      "sha1": "c48d841caab406b50406cd244d13b0df4204989a",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:33.425704688Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Metaverse Ontology": 1,
+        "Large language models": 6,
+        "Llama": 2,
+        "Semantic Web": 1,
+        "Courses and Training": 1,
+        "Music and audio": 1,
+        "Diagrams as Code": 1,
+        "multimodal": 3,
+        "Training and fine tuning": 1,
+        "Multi Agent RAG scrapbook": 1,
+        "Decentralised Web": 1,
+        "Agentic Mycelia": 1,
+        "Agentic Metaverse for Global Creatives": 1,
+        "Knowledge Graphing and RAG": 40,
+        "infrastructure": 1,
+        "Agents": 11,
+        "ollama": 3,
+        "ChatGPT": 4,
+        "OpenAI": 7,
+        "Interfaces": 1,
+        "Reasoning": 1,
+        "Evaluation benchmarks and leaderboards": 1
+      }
+    },
+    "Courses and Training.md": {
+      "fileName": "Courses and Training.md",
+      "fileSize": 7329,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 39,
+      "sha1": "10708b433ab7959e67cb38abe013d41af9d05afb",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:09.064051335Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Diffusion": 1,
+        "ChatGPT": 4,
+        "Prompt Engineering": 7,
+        "Large language models": 2,
+        "latent space": 2,
+        "OpenAI": 2,
+        "Artificial Intelligence": 3,
+        "Machine Learning": 5,
+        "Deep Learning": 3
+      }
+    },
+    "Ai in Games.md": {
+      "fileName": "Ai in Games.md",
+      "fileSize": 3232,
+      "nodeSize": 34.088,
+      "hyperlinkCount": 12,
+      "sha1": "eae8c355131e3fa2ca3588f4ab9ec6965285e500",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:24.599117478Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Diffusion": 1,
+        "ComfyUI": 1,
+        "Transformers": 1,
+        "NVIDIA Omniverse": 1,
+        "Blender": 1
+      }
+    },
+    "AI Risks.md": {
+      "fileName": "AI Risks.md",
+      "fileSize": 5071,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 2,
+      "sha1": "fc156c54813de56f665ebad8fd26be1be2be5cda",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:09.556088833Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Social contract and jobs": 1,
+        "Safety and alignment": 1,
+        "Cyber Security and Military": 2,
+        "Death of the Internet": 1,
+        "Landscape": 1,
+        "Cyber security and Cryptography": 1
+      }
+    },
+    "Human tracking and SLAM capture.md": {
+      "fileName": "Human tracking and SLAM capture.md",
+      "fileSize": 1761,
+      "nodeSize": 20.848999999999997,
+      "hyperlinkCount": 9,
+      "sha1": "ca73b996878f9a362b5bd77ddb322a3321dee834",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:15.618163478Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "ChatGPT.md": {
+      "fileName": "ChatGPT.md",
+      "fileSize": 16012,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 65,
+      "sha1": "53c14138461a0909964f8b592e54218416b533c2",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:51.289460693Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "multimodal": 5,
+        "Blender": 5,
+        "Robotics": 1,
+        "ChatGPT": 36,
+        "Accessibility": 1,
+        "collaborative": 1,
+        "OpenAI": 17,
+        "Stable Diffusion": 8
+      }
+    },
+    "AI Video.md": {
+      "fileName": "AI Video.md",
+      "fileSize": 18535,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 90,
+      "sha1": "a64b5679fbe11d0250919f9beb56affce22f812b",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:12.269348248Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "AnimateDiff": 10,
+        "Diffusion Models": 7,
+        "ComfyUI": 7,
+        "collaborative": 1,
+        "AI Video": 5,
+        "LoRA DoRA etc": 1,
+        "Stable Diffusion": 6,
+        "latent space": 1,
+        "Blender": 1,
+        "Inpainting": 5
+      }
+    },
+    "Robin Hanson.md": {
+      "fileName": "Robin Hanson.md",
+      "fileSize": 4255,
+      "nodeSize": 43.295,
+      "hyperlinkCount": 1,
+      "sha1": "156d623073ac4c43ca74ddc759d08dc3278f2ec3",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:05.020736083Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Gemini": 2,
+        "Artificial Intelligence": 1,
+        "Lead Poisoning Hypothesis": 1,
+        "Robin Hanson": 1
+      }
+    },
+    "Training and fine tuning.md": {
+      "fileName": "Training and fine tuning.md",
+      "fileSize": 4404,
+      "nodeSize": 44.636,
+      "hyperlinkCount": 0,
+      "sha1": "f8e7d4b12dc95f1b29a2f004a0b987d2e96a5696",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:46.439870219Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Large language models": 2,
+        "multimodal": 2,
+        "Transformers": 2,
+        "Safety and alignment": 1,
+        "Semantic Web": 1
+      }
+    },
+    "Layoff tracker and threatened roles.md": {
+      "fileName": "Layoff tracker and threatened roles.md",
+      "fileSize": 3408,
+      "nodeSize": 35.672,
+      "hyperlinkCount": 6,
+      "sha1": "41bce0decc00e5dbf9d0dd3004275157ce59b3e8",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:37.639719073Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agents": 1
+      }
+    },
+    "Segmentation and Identification.md": {
+      "fileName": "Segmentation and Identification.md",
+      "fileSize": 6843,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 24,
+      "sha1": "e480903264d84b2b44a81f74f0610b9dd34e1bf0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:16.925793627Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Hardware and Edge": 1,
+        "license": 1,
+        "Inpainting": 1,
+        "Transformers": 1,
+        "Large language models": 1,
+        "Human tracking and SLAM capture": 1,
+        "AI Video": 1,
+        "Product Design": 2,
+        "Depth Estimation": 1,
+        "Segmentation and Identification": 9,
+        "SLAM": 1,
+        "Llama": 2
+      }
+    },
+    "artificial superintelligence.md": {
+      "fileName": "artificial superintelligence.md",
+      "fileSize": 2628,
+      "nodeSize": 28.652,
+      "hyperlinkCount": 6,
+      "sha1": "1d0c2ef96a2fd56a69ab6036b1fa7e1d348e4259",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:11.169885397Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 2
+      }
+    },
+    "flossverse.md": {
+      "fileName": "flossverse.md",
+      "fileSize": 3984,
+      "nodeSize": 40.856,
+      "hyperlinkCount": 4,
+      "sha1": "a8b2f934290c28035ba5f53737e36dd1e3d4997f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:23.035476641Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Machine Learning": 1,
+        "collaborative": 1,
+        "Money": 2,
+        "flossverse": 1,
+        "Mixed reality": 1,
+        "infrastructure": 1
+      }
+    },
+    "BroBots.md": {
+      "fileName": "BroBots.md",
+      "fileSize": 351,
+      "nodeSize": 8.158999999999999,
+      "hyperlinkCount": 0,
+      "sha1": "bce4fb5a2e262d02c88d33ab2bb7487db0425779",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:46.463795350Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Digital Society Harms": 1,
+        "Agents": 1,
+        "Death of the Internet": 1,
+        "Llama": 1,
+        "Agentic Alliance": 1,
+        "ollama": 1
+      }
+    },
+    "Scene Capture and Reconstruction.md": {
+      "fileName": "Scene Capture and Reconstruction.md",
+      "fileSize": 12426,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 86,
+      "sha1": "0b21539e1df68d82a543aef926347dbf55a7ebe1",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:15.435590380Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Blender": 2,
+        "Gaussian splatting and Similar": 2,
+        "SLAM": 7,
+        "Apple": 2
+      }
+    },
+    "collaborative.md": {
+      "fileName": "collaborative.md",
+      "fileSize": 14,
+      "nodeSize": 5.126,
+      "hyperlinkCount": 0,
+      "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:15.322362153Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Time Series Forecasting.md": {
+      "fileName": "Time Series Forecasting.md",
+      "fileSize": 865,
+      "nodeSize": 12.785,
+      "hyperlinkCount": 5,
+      "sha1": "d1712dadeb12099575ad272cd845ee9d6a24fcad",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:43.701766057Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Transformers": 2,
+        "Time Series Forecasting": 2,
+        "Llama": 2
+      }
+    },
+    "Norbert Wiener.md": {
+      "fileName": "Norbert Wiener.md",
+      "fileSize": 2434,
+      "nodeSize": 26.906,
+      "hyperlinkCount": 0,
+      "sha1": "073af281929b120abb910c60dc1d39ba3df1c908",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:16.828099714Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Norbert Wiener": 1,
+        "Artificial Intelligence": 1
+      }
+    },
+    "Multi Agent RAG scrapbook.md": {
+      "fileName": "Multi Agent RAG scrapbook.md",
+      "fileSize": 6497,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "34e5bfbbd0d31a1c9b90ef203f1eb0cd16c54d2f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:12.658604680Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Reasoning": 1,
+        "Diagrams as Code": 1,
+        "Transformers": 1,
+        "Prompt Engineering": 1,
+        "Large language models": 1
+      }
+    },
+    "Comparison of SDXL and Midjourney v6.md": {
+      "fileName": "Comparison of SDXL and Midjourney v6.md",
+      "fileSize": 731,
+      "nodeSize": 11.579,
+      "hyperlinkCount": 7,
+      "sha1": "dae15fcc817642ee05550e389a1d9de4987a5f15",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:00.266222054Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "GANs.md": {
+      "fileName": "GANs.md",
+      "fileSize": 14,
+      "nodeSize": 5.126,
+      "hyperlinkCount": 0,
+      "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:59.355581856Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "license.md": {
+      "fileName": "license.md",
+      "fileSize": 356,
+      "nodeSize": 8.204,
+      "hyperlinkCount": 4,
+      "sha1": "4443a3aff6398c220a624c669be78218a91f796f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:33.724017802Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Robotics.md": {
+      "fileName": "Robotics.md",
+      "fileSize": 1753,
+      "nodeSize": 20.776999999999997,
+      "hyperlinkCount": 10,
+      "sha1": "fb5790a6ec0327b53634a26c7579d6b3d9716c32",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:05.773520935Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "ChatGPT": 1,
+        "Robotics": 1
+      }
+    },
+    "Digital Asset Risks.md": {
+      "fileName": "Digital Asset Risks.md",
+      "fileSize": 38439,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 44,
+      "sha1": "4b0855a9765e3cec9a09d4fe839d8d527307ad8f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:29.355707483Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Blockchain": 3,
+        "Bitcoin": 72,
+        "Bitcoin ETF": 1,
+        "Convergence": 1,
+        "Stable Coins": 1,
+        "Agents": 1,
+        "Ethereum": 2,
+        "Money": 17
+      }
+    },
+    "Spatial Computing.md": {
+      "fileName": "Spatial Computing.md",
+      "fileSize": 1826,
+      "nodeSize": 21.434,
+      "hyperlinkCount": 0,
+      "sha1": "d64ca32560b184a8eb58641bc7d75581719dd690",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:25.359072746Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 3,
+        "Spatial Computing": 11,
+        "Robotics": 1
+      }
+    },
+    "Reasoning.md": {
+      "fileName": "Reasoning.md",
+      "fileSize": 2937,
+      "nodeSize": 31.433,
+      "hyperlinkCount": 4,
+      "sha1": "d4905c447b0816f0aa649309ecead65686bd51c6",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:59.992686805Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Large language models": 1,
+        "Reasoning": 11
+      }
+    },
+    "Product Design.md": {
+      "fileName": "Product Design.md",
+      "fileSize": 81911,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 12,
+      "sha1": "22ffc2508d3dcbf8d8dc01faeebd565744d2d489",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:42.535919767Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 20,
+        "Stable Diffusion": 6,
+        "Prompt Engineering": 1,
+        "Blockchain": 6,
+        "Machine Learning": 9,
+        "Knowhere": 3,
+        "Accessibility": 9,
+        "Apple": 1,
+        "Agents": 32,
+        "Cashu": 1,
+        "ChatGPT": 3,
+        "Vision Pro": 1,
+        "Bitcoin": 19,
+        "nostr": 29,
+        "Landscape": 6,
+        "Mixed reality": 8,
+        "Money": 8,
+        "Large language models": 2,
+        "Robotics": 2,
+        "Interfaces": 4,
+        "flossverse": 4,
+        "ecash": 1,
+        "NVIDIA Omniverse": 1,
+        "Gemini": 1,
+        "Virtual Production": 13,
+        "Digital Objects": 5,
+        "Visionflow": 14,
+        "collaborative": 24
+      }
+    },
+    "Digital Society Harms.md": {
+      "fileName": "Digital Society Harms.md",
+      "fileSize": 2052,
+      "nodeSize": 23.468,
+      "hyperlinkCount": 11,
+      "sha1": "621a54f748119add788b95ffbba6c08452036258",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:31.421111458Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Death of the Internet.md": {
+      "fileName": "Death of the Internet.md",
+      "fileSize": 31877,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 83,
+      "sha1": "5043440f98edf274d734dbfdfba7d705e2cd3936",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:18.796768914Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Politics, Law, Privacy": 1,
+        "Human vs AI": 1,
+        "Decentralised Web": 1,
+        "Landscape": 2,
+        "Large language models": 1,
+        "Privacy, Trust and Safety": 2,
+        "Death of the Internet": 7,
+        "ChatGPT": 2,
+        "Artificial Intelligence": 3,
+        "Leopold Aschenbrenner": 1,
+        "Accessibility": 2,
+        "Global Inequality": 1,
+        "Blockchain": 1,
+        "latent space": 1,
+        "OpenAI": 7,
+        "Deepfakes and fraudulent content": 1,
+        "legacy media": 2,
+        "Singularity": 1,
+        "Agents": 4,
+        "infrastructure": 6,
+        "Social contract and jobs": 2,
+        "Digital Society Surveillance": 1
+      }
+    },
+    "Decentralised Web.md": {
+      "fileName": "Decentralised Web.md",
+      "fileSize": 68332,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 116,
+      "sha1": "7a65ac69cb570feca301124dada1750772e4c1f4",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:20.264883243Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 4,
+        "license": 2,
+        "Landscape": 7,
+        "Money": 12,
+        "Agents": 2,
+        "Semantic Web": 8,
+        "Distributed Identity": 4,
+        "Rust": 2,
+        "nostr": 6,
+        "Tokenisation": 2,
+        "collaborative": 2,
+        "Ethereum": 10,
+        "Apple": 2,
+        "Bitcoin": 24,
+        "Blockchain": 9,
+        "Decentralised Web": 2,
+        "Gold": 1,
+        "Mixed reality": 1
+      }
+    },
+    "Suggested Reading Order.md": {
+      "fileName": "Suggested Reading Order.md",
+      "fileSize": 2782,
+      "nodeSize": 30.038,
+      "hyperlinkCount": 2,
+      "sha1": "dd52efde2f9d59e0c7d88a1eff9cf54a169e0a76",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:33.058829406Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Politics, Law, Privacy": 1,
+        "BTC Layer 3": 1,
+        "Metaverse and Spatial Risks": 1,
+        "Convergence": 1,
+        "Definitions and frameworks for Metaverse": 1,
+        "Digital Objects": 3,
+        "State of the art in AI": 1,
+        "Overview of Machine Learning Techniques": 1,
+        "Blockchain": 1,
+        "Large language models": 1,
+        "Decentralised Web": 1,
+        "Ethereum": 1,
+        "Open Generative AI tools": 1,
+        "Semantic Web": 1,
+        "Bitcoin": 2,
+        "Bitcoin As Money": 1,
+        "National Industrial Centre for Virtual Environments": 1,
+        "Proprietary Image Generation": 1,
+        "Machine Learning": 1,
+        "nostr": 1,
+        "Agents": 1,
+        "Proprietary Video": 1,
+        "Spatial Computing": 1,
+        "Distributed Identity": 1,
+        "Octave Multi Model Laboratory": 1,
+        "Adoption of Convergent Technologies": 1,
+        "Artificial Intelligence": 1,
+        "Money": 3,
+        "Proprietary Large Language Models": 1,
+        "Digital Asset Risks": 1,
+        "collaborative": 1,
+        "Introduction to me": 1
+      }
+    },
+    "Text to 3D and 4D.md": {
+      "fileName": "Text to 3D and 4D.md",
+      "fileSize": 8515,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 48,
+      "sha1": "60d3e231f8ce48115b7b45607c315b51aab36b90",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:41.499155472Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 1,
+        "ComfyUI": 4,
+        "Stable Diffusion": 3,
+        "Blender": 6,
+        "Diffusion Models": 1,
+        "collaborative": 1
+      }
+    },
+    "Humans, Avatars , Character.md": {
+      "fileName": "Humans, Avatars , Character.md",
+      "fileSize": 14756,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 71,
+      "sha1": "9487a7196405682044523f72286aa7599d279d1d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:17.488159103Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 1,
+        "Stable Diffusion": 2,
+        "SLAM": 2,
+        "Human tracking and SLAM capture": 2,
+        "AI Video": 1,
+        "ComfyUI": 8,
+        "Singularity": 1,
+        "GANs": 1
+      }
+    },
+    "Coding support.md": {
+      "fileName": "Coding support.md",
+      "fileSize": 15162,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 38,
+      "sha1": "40669d5f91734607fb5a850e03fba49615e8dc15",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:54.708446370Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Interfaces": 3,
+        "Prompt Engineering": 1,
+        "Machine Learning": 2,
+        "ChatGPT": 5,
+        "infrastructure": 1,
+        "Llama": 3,
+        "Microsoft CoPilot": 2,
+        "Large language models": 2,
+        "Spatial Computing": 1,
+        "Gemini": 1,
+        "Agents": 6
+      }
+    },
+    "BTC Layer 3.md": {
+      "fileName": "BTC Layer 3.md",
+      "fileSize": 26265,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 35,
+      "sha1": "51393bdec64373a9e480c1bedaa0da3867d07876",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:33.871454190Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Rust": 2,
+        "Blockchain": 12,
+        "infrastructure": 1,
+        "Bitcoin": 86
+      }
+    },
+    "Agentic Alliance.md": {
+      "fileName": "Agentic Alliance.md",
+      "fileSize": 8731,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 3,
+      "sha1": "ceb39eb3f435bec4fdeca4f288c45bb0d53b0f3c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:21.238878106Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Distributed Identity": 3,
+        "nostr": 6,
+        "Agentic Alliance": 2,
+        "Agents": 8,
+        "Bitcoin": 6
+      }
+    },
+    "Definitions and frameworks for Metaverse.md": {
+      "fileName": "Definitions and frameworks for Metaverse.md",
+      "fileSize": 48177,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 43,
+      "sha1": "6d56ab61e4410d87a12d67ffebc2ee03ddf7ae2c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:25.151720860Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agents": 3,
+        "Apple": 7,
+        "Convergence": 2,
+        "Metaverse Ontology": 1,
+        "Machine Learning": 1,
+        "Blockchain": 1,
+        "Vision Pro": 1,
+        "infrastructure": 2,
+        "Mixed reality": 6,
+        "Digital Objects": 2,
+        "license": 2,
+        "OpenAI": 1,
+        "multimodal": 1,
+        "Bitcoin": 2,
+        "collaborative": 4,
+        "Ethereum": 1,
+        "Money": 5,
+        "Landscape": 1,
+        "Spatial Computing": 2
+      }
+    },
+    "Agentic Metaverse for Global Creatives.md": {
+      "fileName": "Agentic Metaverse for Global Creatives.md",
+      "fileSize": 30730,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "4d086bdfcecbc35fc2d6596b5dc6dabf082696b1",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:21.949625703Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Large language models": 2,
+        "ChatGPT": 1,
+        "nostr": 29,
+        "Bitcoin": 13,
+        "Privacy, Trust and Safety": 1,
+        "Mixed reality": 3,
+        "ecash": 1,
+        "Blockchain": 3,
+        "Digital Objects": 2,
+        "Virtual Production": 2,
+        "Machine Learning": 2,
+        "Interfaces": 1,
+        "Money": 6,
+        "Agents": 12,
+        "Metaverse Ontology": 1,
+        "NVIDIA Omniverse": 1,
+        "Accessibility": 7,
+        "Landscape": 5,
+        "Stable Diffusion": 1,
+        "collaborative": 9,
+        "infrastructure": 6
+      }
+    },
+    "Proprietary Video.md": {
+      "fileName": "Proprietary Video.md",
+      "fileSize": 6701,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 17,
+      "sha1": "40e0eafbd4bdd8079761b3e807030f4934093222",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:48.156871075Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Virtual Production": 3,
+        "flossverse": 2,
+        "NVIDIA Omniverse": 1,
+        "AI Video": 4,
+        "Open Generative AI tools": 1
+      }
+    },
+    "p(doom).md": {
+      "fileName": "p(doom).md",
+      "fileSize": 556,
+      "nodeSize": 10.004,
+      "hyperlinkCount": 0,
+      "sha1": "4bcd6cb13573f66ddaf86100d979acd006520f0c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:43.182746217Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Bitcoin As Money.md": {
+      "fileName": "Bitcoin As Money.md",
+      "fileSize": 18467,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 23,
+      "sha1": "857a8a3444a7eb88d4ece3ba31fa427a953d16da",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:37.981321291Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Coins": 1,
+        "Gold": 4,
+        "Blockchain": 2,
+        "Bitcoin": 52,
+        "Accessibility": 1,
+        "infrastructure": 1,
+        "Money": 61
+      }
+    },
+    "Diagrams as Code.md": {
+      "fileName": "Diagrams as Code.md",
+      "fileSize": 19571,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 21,
+      "sha1": "b0b33a7a5a3673e8dc88905b52611c54628c2379",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:27.886915334Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 6,
+        "Cashu": 1,
+        "Stable Diffusion": 2,
+        "nostr": 6,
+        "OpenAI": 2,
+        "Gemini": 1,
+        "NVIDIA Omniverse": 1,
+        "Accessibility": 1,
+        "Transformers": 4,
+        "Agents": 11,
+        "Virtual Production": 2,
+        "Blockchain": 4,
+        "Prompt Engineering": 1,
+        "Spatial Computing": 1,
+        "GANs": 4
+      }
+    },
+    "Revision List.md": {
+      "fileName": "Revision List.md",
+      "fileSize": 3977,
+      "nodeSize": 40.793,
+      "hyperlinkCount": 1,
+      "sha1": "9de5dc3743751d34db958f0e3b1463d6605464a2",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:04.240890561Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Deep Learning": 2,
+        "Time Series Forecasting": 1,
+        "Machine Learning": 6,
+        "Prompt Engineering": 1,
+        "Agents": 1
+      }
+    },
+    "Proprietary AI Video.md": {
+      "fileName": "Proprietary AI Video.md",
+      "fileSize": 5154,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 4,
+      "sha1": "02045730ff4fd31d448cc16b1833d156e193ff8f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:45.451639030Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Deepmind": 1,
+        "Transformers": 1,
+        "latent space": 1,
+        "OpenAI": 5,
+        "AI Video": 2
+      }
+    },
+    "Tim Reutermann.md": {
+      "fileName": "Tim Reutermann.md",
+      "fileSize": 3622,
+      "nodeSize": 37.598,
+      "hyperlinkCount": 2,
+      "sha1": "a7637194be7fb2c58b8cf8fa927ef7a1373a8f85",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:42.963107984Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 2,
+        "cypherpunk": 3,
+        "Blockchain": 2
+      }
+    },
+    "Parametric.md": {
+      "fileName": "Parametric.md",
+      "fileSize": 6574,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 4,
+      "sha1": "d3c14a3ee65e689a3d76a5aed5bb53177bf71376",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:29.425478711Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "NVIDIA Omniverse": 4,
+        "Interfaces": 1,
+        "Parametric": 7,
+        "GANs": 1
+      }
+    },
+    "Metaverse and Spatial Risks.md": {
+      "fileName": "Metaverse and Spatial Risks.md",
+      "fileSize": 2443,
+      "nodeSize": 26.987,
+      "hyperlinkCount": 2,
+      "sha1": "b9ef186e5294a38d70878f2c6aed99422c9df532",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:59.176766764Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Machine Learning": 3
+      }
+    },
+    "Leopold Aschenbrenner.md": {
+      "fileName": "Leopold Aschenbrenner.md",
+      "fileSize": 8770,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 2,
+      "sha1": "b5949a72d7b4c0fc5e18120b6480c062ad8d1bbc",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:40.181085166Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 2,
+        "Energy and Power": 1,
+        "Politics, Law, Privacy": 1,
+        "Artificial Intelligence": 1,
+        "artificial superintelligence": 1,
+        "Hardware and Edge": 1,
+        "AI Companies": 2,
+        "Leopold Aschenbrenner": 1
+      }
+    },
+    "Flux.md": {
+      "fileName": "Flux.md",
+      "fileSize": 27922,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 18,
+      "sha1": "8b5e456430dadbc8eca8e732ab6a14da4eb7d905",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:55.892726558Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "ComfyUI": 40,
+        "license": 1,
+        "Stable Diffusion": 2,
+        "Flux": 87,
+        "Upscaling": 1,
+        "Visionflow": 1,
+        "Open Generative AI tools": 1,
+        "AI Video": 1,
+        "IPAdapter": 1,
+        "Deep Learning": 1,
+        "collaborative": 1,
+        "Inpainting": 9,
+        "Controlnet and similar": 3,
+        "Landscape": 1,
+        "Death of the Internet": 1,
+        "Artificial Intelligence": 2,
+        "Segmentation and Identification": 1,
+        "Prompt Engineering": 3,
+        "Model Optimisation and Performance": 3,
+        "Convergence": 2,
+        "LoRA DoRA etc": 1
+      }
+    },
+    "Interfaces.md": {
+      "fileName": "Interfaces.md",
+      "fileSize": 5576,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 20,
+      "sha1": "cbf3df4603ca76633ebeb70927ac2193ed85d06d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:25.198133670Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Interfaces": 4,
+        "OpenAI": 2,
+        "Diffusion Models": 1,
+        "ComfyUI": 1,
+        "infrastructure": 1,
+        "Llama": 6,
+        "Hardware and Edge": 1,
+        "ChatGPT": 1,
+        "Agents": 1,
+        "multimodal": 5,
+        "Stable Diffusion": 1,
+        "Large language models": 3
+      }
+    },
+    "multimodal.md": {
+      "fileName": "multimodal.md",
+      "fileSize": 4601,
+      "nodeSize": 46.409,
+      "hyperlinkCount": 12,
+      "sha1": "b47a1d2ce1b2295a7b830bc6c223b667c4bd6fc4",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:38.240059381Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 1,
+        "Large language models": 3,
+        "ChatGPT": 1,
+        "Transformers": 1,
+        "multimodal": 4,
+        "Gemini": 3,
+        "Apple": 4,
+        "latent space": 1,
+        "Deepmind": 1
+      }
+    },
+    "Deep Learning.md": {
+      "fileName": "Deep Learning.md",
+      "fileSize": 18831,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 0,
+      "sha1": "56f4b96b652143560c18c0129ce786622c91a856",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:22.970285867Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 2
+      }
+    },
+    "Evaluation benchmarks and leaderboards.md": {
+      "fileName": "Evaluation benchmarks and leaderboards.md",
+      "fileSize": 1148,
+      "nodeSize": 15.332,
+      "hyperlinkCount": 11,
+      "sha1": "abe179288d5847d0574dc559988a202c5b12442a",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:45.921587518Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "IPAdapter.md": {
+      "fileName": "IPAdapter.md",
+      "fileSize": 4117,
+      "nodeSize": 42.053,
+      "hyperlinkCount": 1,
+      "sha1": "154e12b1e3ee28b15b101471b692dee7eb8026ff",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:20.220151871Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Inpainting": 2,
+        "Diffusion Models": 3,
+        "Base models": 1,
+        "multimodal": 4,
+        "Prompt Engineering": 1
+      }
+    },
+    "Blockchain.md": {
+      "fileName": "Blockchain.md",
+      "fileSize": 15132,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 21,
+      "sha1": "5c0a8a95b0cb6348580015f65949f5d8caa6a048",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:45.038036525Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Artificial Intelligence": 1,
+        "Global Inequality": 1,
+        "Deepfakes and fraudulent content": 1,
+        "Bitcoin Technical Overview": 1,
+        "Agents": 2,
+        "ecash": 2,
+        "Bitcoin As Money": 1,
+        "Digital Asset Risks": 1,
+        "Money": 4,
+        "Bitcoin Value Proposition": 2,
+        "cypherpunk": 2,
+        "Energy and Power": 1,
+        "Digital Society Surveillance": 2,
+        "Agentic Mycelia": 1,
+        "Interfaces": 1,
+        "Stable Coins": 1,
+        "Agentic Metaverse for Global Creatives": 1,
+        "Bitcoin": 15,
+        "artificial superintelligence": 1,
+        "infrastructure": 3,
+        "Blockchain": 11
+      }
+    },
+    "cypherpunk.md": {
+      "fileName": "cypherpunk.md",
+      "fileSize": 5430,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 3,
+      "sha1": "7dcc1520963f17ce76ce5431643f30f8bc65945c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:17.547033376Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 1,
+        "cypherpunk": 5
+      }
+    },
+    "Mixed reality.md": {
+      "fileName": "Mixed reality.md",
+      "fileSize": 59923,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 87,
+      "sha1": "fe23c08d8a0f03137339f6ef778602fa3936667c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:06.870967751Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Blockchain": 15,
+        "Ethereum": 1,
+        "Vision Pro": 5,
+        "ChatGPT": 1,
+        "Education and AI": 1,
+        "Apple": 13,
+        "Large language models": 1,
+        "Blender": 6,
+        "license": 5,
+        "Artificial Intelligence": 2,
+        "Accessibility": 3,
+        "infrastructure": 4,
+        "Bitcoin": 1,
+        "Rust": 1,
+        "Machine Learning": 4,
+        "Convergence": 3,
+        "Interfaces": 1,
+        "Depth Estimation": 3,
+        "Landscape": 2,
+        "OpenAI": 1,
+        "Humans, Avatars , Character": 1,
+        "Stable Diffusion": 6,
+        "Virtual Production": 1,
+        "Diffusion Models": 4,
+        "Mixed reality": 5
+      }
+    },
+    "Adoption of Convergent Technologies.md": {
+      "fileName": "Adoption of Convergent Technologies.md",
+      "fileSize": 20064,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 46,
+      "sha1": "2c9159b57ab3151511a44b3eae989aff94ed9ca0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:19.295150706Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 1,
+        "Money": 1,
+        "Bitcoin": 17,
+        "Blockchain": 2,
+        "Microsoft Work Trends Impact 2024": 1,
+        "ChatGPT": 1,
+        "Gemini": 1
+      }
+    },
+    "Medical AI.md": {
+      "fileName": "Medical AI.md",
+      "fileSize": 18110,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 17,
+      "sha1": "dd458f6f92dec20c2a90787ec3b66a15c228f2f8",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:55.678053979Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Gemini": 1,
+        "Deep Learning": 2,
+        "Transformers": 1,
+        "Medical AI": 2,
+        "Deepmind": 3,
+        "Large language models": 2,
+        "Convergence": 1,
+        "Machine Learning": 3,
+        "OpenAI": 3,
+        "Agents": 7,
+        "Landscape": 1
+      }
+    },
+    "Transformers.md": {
+      "fileName": "Transformers.md",
+      "fileSize": 2437,
+      "nodeSize": 26.933,
+      "hyperlinkCount": 5,
+      "sha1": "b2f0d608cd9dfe8305270612f07063e909eb9fa0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:47.186631332Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Transformers": 2,
+        "OpenAI": 1
+      }
+    },
+    "Call Centres.md": {
+      "fileName": "Call Centres.md",
+      "fileSize": 23898,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 27,
+      "sha1": "0ab50f04ced83606b3f489360ebd7f3c56a906d8",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:49.851526065Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Artificial Intelligence": 2,
+        "Landscape": 1,
+        "Agents": 15,
+        "Reasoning": 1,
+        "Interfaces": 1
+      }
+    },
+    "Bitcoin ETF.md": {
+      "fileName": "Bitcoin ETF.md",
+      "fileSize": 6185,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 2,
+      "sha1": "d19a4e9a7d54f3278dd7a1432916260efd1e833e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:38.701106780Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 31,
+        "Bitcoin ETF": 1,
+        "Money": 1
+      }
+    },
+    "Recent Projects.md": {
+      "fileName": "Recent Projects.md",
+      "fileSize": 1485,
+      "nodeSize": 18.365,
+      "hyperlinkCount": 14,
+      "sha1": "f725558205279fcaacd1c0c080db336bd8453b88",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:00.729792655Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 1,
+        "Virtual Production": 1,
+        "Robotics": 1,
+        "Artificial Intelligence": 1,
+        "Hardware and Edge": 1
+      }
+    },
+    "Knowhere.md": {
+      "fileName": "Knowhere.md",
+      "fileSize": 15800,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 6,
+      "sha1": "3b34a6640636d10e96ef28d9d716172103a1751e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:32.526248600Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 2,
+        "Knowhere": 4,
+        "ChatGPT": 1,
+        "Segmentation and Identification": 1,
+        "NVIDIA Omniverse": 1
+      }
+    },
+    "Controlnet and similar.md": {
+      "fileName": "Controlnet and similar.md",
+      "fileSize": 8004,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 3,
+      "sha1": "fdefdedc0ba6c22da4a94905e11fbae173813092",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:05.893957305Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Diffusion": 2,
+        "Diffusion Models": 4
+      }
+    },
+    "Convergence.md": {
+      "fileName": "Convergence.md",
+      "fileSize": 10595,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 2,
+      "sha1": "d9b6b97f4a72285712c15bb6dafa33af975bcded",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:06.807701360Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 3,
+        "Interfaces": 3,
+        "Agents": 2,
+        "Singularity": 1,
+        "Spatial Computing": 3,
+        "artificial superintelligence": 1,
+        "collaborative": 1,
+        "Convergence": 3,
+        "Landscape": 1,
+        "Blockchain": 3,
+        "Digital Objects": 1,
+        "Artificial Intelligence": 1,
+        "Mixed reality": 1
+      }
+    },
+    "Stable Coins.md": {
+      "fileName": "Stable Coins.md",
+      "fileSize": 18917,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 33,
+      "sha1": "552f0f022b34904a3a5279fba93d708826ef0a75",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:28.081304407Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 6,
+        "Gemini": 3,
+        "Ethereum": 5,
+        "infrastructure": 6,
+        "Blockchain": 7,
+        "Stable Coins": 3,
+        "Bitcoin": 3
+      }
+    },
+    "Money.md": {
+      "fileName": "Money.md",
+      "fileSize": 85818,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 79,
+      "sha1": "976d46eeeef05fac30fb8423dc8ecf8f5af1cc1b",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:11.147875345Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Coins": 1,
+        "collaborative": 1,
+        "Landscape": 3,
+        "Ethereum": 5,
+        "Gold": 8,
+        "Convergence": 1,
+        "Apple": 9,
+        "Bitcoin": 23,
+        "infrastructure": 5,
+        "Blockchain": 8,
+        "Gemini": 1,
+        "Money": 128
+      }
+    },
+    "ecash.md": {
+      "fileName": "ecash.md",
+      "fileSize": 4860,
+      "nodeSize": 48.74,
+      "hyperlinkCount": 0,
+      "sha1": "c506dbc045207de680663a775cad988f77bf9018",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:19.564911966Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Accessibility": 1,
+        "Cashu": 2,
+        "ecash": 3,
+        "Bitcoin": 8,
+        "Blockchain": 4
+      }
+    },
+    "Politics, Law, Privacy.md": {
+      "fileName": "Politics, Law, Privacy.md",
+      "fileSize": 33644,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 48,
+      "sha1": "ab6d364b607f0f088756f24ecb2c02919fb0c14f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:36.375248256Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "license": 1,
+        "Accessibility": 3,
+        "Bitcoin": 2,
+        "Education and AI": 1,
+        "Distributed Identity": 1,
+        "Transformers": 1,
+        "EU AI Act": 2,
+        "Large language models": 1,
+        "Artificial Intelligence": 5,
+        "Politics, Law, Privacy": 1,
+        "Blockchain": 3,
+        "Landscape": 3,
+        "Money": 1,
+        "Privacy, Trust and Safety": 2,
+        "ChatGPT": 1
+      }
+    },
+    "Product and Risk Management.md": {
+      "fileName": "Product and Risk Management.md",
+      "fileSize": 4320,
+      "nodeSize": 43.88,
+      "hyperlinkCount": 2,
+      "sha1": "dcbee3ca4172ec238ef137ced777ec66b223ee49",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:43.259750170Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 1,
+        "Safety and alignment": 1,
+        "Machine Learning": 1,
+        "Politics, Law, Privacy": 1,
+        "Landscape": 1,
+        "Product Design": 1
+      }
+    },
+    "Microsoft Work Trends Impact 2024.md": {
+      "fileName": "Microsoft Work Trends Impact 2024.md",
+      "fileSize": 7664,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "553423c8164077d6cb3f9abd1aec5b2956e108c3",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:03.354476599Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Artificial Intelligence": 1
+      }
+    },
+    "Singularity.md": {
+      "fileName": "Singularity.md",
+      "fileSize": 5040,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "c35e7f287027707c97f1ed684c9c3e0654152b42",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:20.372243704Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Singularity": 10,
+        "collaborative": 1
+      }
+    },
+    "Landscape.md": {
+      "fileName": "Landscape.md",
+      "fileSize": 308,
+      "nodeSize": 7.772,
+      "hyperlinkCount": 2,
+      "sha1": "89a1ba3cd3894d3c820e7d8a42ce7a0deef1346d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:34.176721811Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 3
+      }
+    },
+    "Conspiracies.md": {
+      "fileName": "Conspiracies.md",
+      "fileSize": 13147,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 9,
+      "sha1": "a2952b45f94d6f7579fca999d55c6f3049f95cde",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:02.929383613Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "California AI bill": 1,
+        "Agents": 2,
+        "Conspiracies": 1,
+        "Artificial Intelligence": 1,
+        "Bitcoin": 9,
+        "AI Companies": 1,
+        "Politics, Law, Privacy": 1,
+        "Safety and alignment": 1
+      }
+    },
+    "AI Companies.md": {
+      "fileName": "AI Companies.md",
+      "fileSize": 7132,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 6,
+      "sha1": "f3e0fd1d16eb22fb2dda1cc95d246869e0759f69",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:08.045852866Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Machine Learning": 6,
+        "Interfaces": 1,
+        "ChatGPT": 2,
+        "Politics, Law, Privacy": 1,
+        "Comparison of GPT4 and Gemini Ultra": 1,
+        "Knowledge Graphing and RAG": 1,
+        "infrastructure": 1,
+        "Robotics": 1,
+        "Llama": 2,
+        "OpenAI": 5,
+        "Large language models": 1,
+        "Gemini": 9,
+        "Reasoning": 1
+      }
+    },
+    "Comfy UI for Fashion and Brands.md": {
+      "fileName": "Comfy UI for Fashion and Brands.md",
+      "fileSize": 11244,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 22,
+      "sha1": "7384b47977d8ab00d025bfaecb493c12a246b74b",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:56.125990767Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 1,
+        "Product Design": 1,
+        "Diffusion Models": 2,
+        "Apple": 2,
+        "Machine Learning": 1,
+        "Llama": 2,
+        "ComfyUI": 24,
+        "Overview of Machine Learning Techniques": 1,
+        "ollama": 6,
+        "license": 1,
+        "IPAdapter": 1
+      }
+    },
+    "Jailbreaking.md": {
+      "fileName": "Jailbreaking.md",
+      "fileSize": 911,
+      "nodeSize": 13.199000000000002,
+      "hyperlinkCount": 3,
+      "sha1": "6fa1bba1681cfa8ce33c5055fd26cea85af70d43",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:26.694155106Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Large language models": 1,
+        "Bitcoin": 1,
+        "Jailbreaking": 1
+      }
+    },
+    "Ethereum.md": {
+      "fileName": "Ethereum.md",
+      "fileSize": 15310,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 29,
+      "sha1": "2e8f4c1a3a736a74b6a5ee4d04beb22b3020a400",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:44.695188663Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 7,
+        "infrastructure": 2,
+        "Bitcoin": 6,
+        "Mixed reality": 1,
+        "Blockchain": 4,
+        "Ethereum": 38
+      }
+    },
+    "Proprietary Image Generation.md": {
+      "fileName": "Proprietary Image Generation.md",
+      "fileSize": 3077,
+      "nodeSize": 32.693,
+      "hyperlinkCount": 9,
+      "sha1": "5801d9feea43c5f3f231bc5108f3054a777937fb",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:46.684507556Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Proprietary Video": 1,
+        "OpenAI": 1,
+        "Landscape": 1,
+        "ChatGPT": 5
+      }
+    },
+    "Papers Of Note.md": {
+      "fileName": "Papers Of Note.md",
+      "fileSize": 119797,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 478,
+      "sha1": "5b327c4178037b4f6eacfd45d7b350497135941d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:28.678166519Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Apple": 1,
+        "Jailbreaking": 1,
+        "Gemini": 2,
+        "Parametric": 1,
+        "Agents": 3,
+        "Transformers": 17,
+        "Prompt Engineering": 3,
+        "Reasoning": 18,
+        "Diffusion Models": 4,
+        "OpenAI": 1,
+        "Large language models": 61,
+        "Llama": 12,
+        "multimodal": 22,
+        "Machine Learning": 1
+      }
+    },
+    "LoRA DoRA etc.md": {
+      "fileName": "LoRA DoRA etc.md",
+      "fileSize": 1519,
+      "nodeSize": 18.671,
+      "hyperlinkCount": 5,
+      "sha1": "f2ca6b16d5c13d756118bbaef014d35e338fa585",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:48.006668500Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Large language models": 2,
+        "LoRA DoRA etc": 2
+      }
+    },
+    "State of the art in AI.md": {
+      "fileName": "State of the art in AI.md",
+      "fileSize": 8137,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 19,
+      "sha1": "ae78904f3bd3432f308da79442be04beb5bcab46",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:31.064072045Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Interfaces": 2,
+        "Death of the Internet": 1,
+        "OpenAI": 5,
+        "Proprietary Large Language Models": 1,
+        "infrastructure": 1,
+        "Privacy, Trust and Safety": 2,
+        "Hardware and Edge": 1,
+        "Artificial Intelligence": 1,
+        "Politics, Law, Privacy": 1,
+        "Education and AI": 1,
+        "Agents": 1,
+        "Large language models": 1,
+        "Social contract and jobs": 2,
+        "Money": 3
+      }
+    },
+    "Runes and Glyphs.md": {
+      "fileName": "Runes and Glyphs.md",
+      "fileSize": 1840,
+      "nodeSize": 21.56,
+      "hyperlinkCount": 15,
+      "sha1": "a2a25a678dabe813bd618db55310495c1b877649",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:09.306148260Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Runes and Glyphs": 8,
+        "Blockchain": 1,
+        "flossverse": 2,
+        "Bitcoin": 2,
+        "Digital Objects": 1
+      }
+    },
+    "Client side DCO.md": {
+      "fileName": "Client side DCO.md",
+      "fileSize": 14735,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "e49762efad2e1d5cbfc77eef626bd48f4056ebaa",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:53.971973824Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 3,
+        "Hyper personalisation": 2,
+        "multimodal": 3,
+        "Decentralised Web": 1,
+        "Transformers": 1,
+        "latent space": 4,
+        "nostr": 25,
+        "NVIDIA Omniverse": 1,
+        "Hardware and Edge": 1,
+        "Politics, Law, Privacy": 1,
+        "Training and fine tuning": 1
+      }
+    },
+    "Cashu.md": {
+      "fileName": "Cashu.md",
+      "fileSize": 4261,
+      "nodeSize": 43.349,
+      "hyperlinkCount": 7,
+      "sha1": "5c3ac6108ac3f371b8de92aa117e3c45bea30f5d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:50.556219562Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 3,
+        "ecash": 14,
+        "Cashu": 4
+      }
+    },
+    "Depth Estimation.md": {
+      "fileName": "Depth Estimation.md",
+      "fileSize": 862,
+      "nodeSize": 12.758,
+      "hyperlinkCount": 3,
+      "sha1": "93ccc35608e3d73d3b8bef413ebfb6951a2f41bd",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:27.127709700Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Depth Estimation": 3
+      }
+    },
+    "Accessibility.md": {
+      "fileName": "Accessibility.md",
+      "fileSize": 17789,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 14,
+      "sha1": "4a73e2c254231436de5c0540a1864169f7b075bc",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:17.847536999Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Machine Learning": 1,
+        "Interfaces": 4,
+        "Llama": 2,
+        "Accessibility": 63
+      }
+    },
+    "Digital Objects.md": {
+      "fileName": "Digital Objects.md",
+      "fileSize": 62939,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 132,
+      "sha1": "dca2c7ca0406854cc6314a6c307e82befc33cbe9",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:30.116459541Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Digital Asset Risks": 1,
+        "infrastructure": 1,
+        "Bitcoin": 37,
+        "Landscape": 1,
+        "Blockchain": 27,
+        "license": 2,
+        "Digital Objects": 4,
+        "collaborative": 2,
+        "Money": 5,
+        "nostr": 3,
+        "Mixed reality": 2,
+        "Ethereum": 19
+      }
+    },
+    "Haptics.md": {
+      "fileName": "Haptics.md",
+      "fileSize": 16,
+      "nodeSize": 5.144,
+      "hyperlinkCount": 0,
+      "sha1": "b729c028abdf7b08d903806bd908f8f5ec382581",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:11.347235432Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "ollama.md": {
+      "fileName": "ollama.md",
+      "fileSize": 1924,
+      "nodeSize": 22.316,
+      "hyperlinkCount": 6,
+      "sha1": "6b576d3460d1633e9623990ebbe8adb4f2d596ba",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:42.433099358Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Llama": 2,
+        "Prompt Engineering": 1,
+        "ollama": 7,
+        "OpenAI": 1,
+        "Large language models": 1,
+        "Agents": 1,
+        "ComfyUI": 3,
+        "Knowledge Graphing and RAG": 1
+      }
+    },
+    "Anthropic Claude.md": {
+      "fileName": "Anthropic Claude.md",
+      "fileSize": 1398,
+      "nodeSize": 17.582,
+      "hyperlinkCount": 5,
+      "sha1": "65cf23d3d5b32eaf4721a5f7004e42101a1b4dfb",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:26.744968346Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Digital Society Surveillance.md": {
+      "fileName": "Digital Society Surveillance.md",
+      "fileSize": 52788,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 71,
+      "sha1": "6498fbb9ed954e41ab3fe2e12306de948e8a08ff",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:32.175272225Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Anthropic Claude": 1,
+        "ChatGPT": 1,
+        "Artificial Intelligence": 1,
+        "Money": 2,
+        "Bitcoin": 7,
+        "OpenAI": 4,
+        "Agents": 1,
+        "Ethereum": 1,
+        "Landscape": 1,
+        "Blockchain": 2,
+        "license": 1,
+        "infrastructure": 2
+      }
+    },
+    "Virtual Production.md": {
+      "fileName": "Virtual Production.md",
+      "fileSize": 2609,
+      "nodeSize": 28.481,
+      "hyperlinkCount": 6,
+      "sha1": "f9f234812f66506b78e20ef08ce993a37fabb292",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:00.019129649Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Virtual Production": 4,
+        "Mixed reality": 1,
+        "Interfaces": 1,
+        "collaborative": 1,
+        "Accessibility": 3
+      }
+    },
+    "Debug Test Page.md": {
+      "fileName": "Debug Test Page.md",
+      "fileSize": 303,
+      "nodeSize": 7.727,
+      "hyperlinkCount": 0,
+      "sha1": "1e4f5b8e935780ed5ca723acc8d836ef2473a3bb",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:19.542574920Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 1,
+        "debug linked node": 1
+      }
+    },
+    "National Industrial Centre for Virtual Environments.md": {
+      "fileName": "National Industrial Centre for Virtual Environments.md",
+      "fileSize": 2721,
+      "nodeSize": 29.489,
+      "hyperlinkCount": 12,
+      "sha1": "871f25b09501b0b72b75d6c8547dc704169fe3e1",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:16.090958164Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Vision Pro.md": {
+      "fileName": "Vision Pro.md",
+      "fileSize": 2841,
+      "nodeSize": 30.569000000000003,
+      "hyperlinkCount": 2,
+      "sha1": "4f24bd713c8a82f0ee7a3867f0dfd4e265fb2a1e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:00.750940304Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 1,
+        "Apple": 3,
+        "Vision Pro": 2
+      }
+    },
+    "Apple.md": {
+      "fileName": "Apple.md",
+      "fileSize": 9598,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 6,
+      "sha1": "87a7b91113b19f4a322190d329bc8e30aa366200",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:29.030374909Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 4,
+        "Large language models": 1,
+        "Gaussian splatting and Similar": 1,
+        "Hardware and Edge": 2,
+        "Money": 1,
+        "Apple": 27,
+        "Machine Learning": 2,
+        "legacy media": 1,
+        "infrastructure": 1,
+        "ChatGPT": 2
+      }
+    },
+    "Metaverse Ontology.md": {
+      "fileName": "Metaverse Ontology.md",
+      "fileSize": 44869,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 12,
+      "sha1": "b63194e702dfa794f1529841ed9f0dc3632eda9e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:58.420515750Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "RGB and Client Side Validation": 2,
+        "Convergence": 2,
+        "ChatGPT": 1,
+        "Gemini": 1,
+        "Anthropic Claude": 1,
+        "multimodal": 2,
+        "Semantic Web": 2,
+        "Blockchain": 7,
+        "Metaverse Ontology": 3,
+        "collaborative": 2,
+        "NVIDIA Omniverse": 2,
+        "Large language models": 1,
+        "Mixed reality": 1,
+        "Agents": 15,
+        "Knowledge Graphing and RAG": 1,
+        "Cashu": 8,
+        "infrastructure": 3,
+        "Money": 1,
+        "Bitcoin": 16,
+        "nostr": 16,
+        "ecash": 8,
+        "Agentic Mycelia": 1
+      }
+    },
+    "Stable Diffusion.md": {
+      "fileName": "Stable Diffusion.md",
+      "fileSize": 37561,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 204,
+      "sha1": "e6835717a41c00c21b58e1f628a418bce502249e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:29.570774420Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Diffusion": 48,
+        "LoRA DoRA etc": 1,
+        "ComfyUI": 5,
+        "Diffusion Models": 5,
+        "Controlnet and similar": 1,
+        "Transformers": 1,
+        "Artificial Intelligence": 2,
+        "OpenAI": 1,
+        "Interfaces": 3,
+        "AI Video": 1,
+        "collaborative": 1,
+        "Inpainting": 2,
+        "Prompt Engineering": 4,
+        "Landscape": 1,
+        "Machine Learning": 2,
+        "AnimateDiff": 2,
+        "ChatGPT": 1,
+        "Blender": 2,
+        "AI Companies": 1
+      }
+    },
+    "Diffusion Models.md": {
+      "fileName": "Diffusion Models.md",
+      "fileSize": 14,
+      "nodeSize": 5.126,
+      "hyperlinkCount": 0,
+      "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:28.633189955Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "SLAM.md": {
+      "fileName": "SLAM.md",
+      "fileSize": 312,
+      "nodeSize": 7.808,
+      "hyperlinkCount": 1,
+      "sha1": "d6805bce5393bcfecde2d257b339882c9cb4bcca",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:11.973980434Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "SLAM": 3
+      }
+    },
+    "Music and audio.md": {
+      "fileName": "Music and audio.md",
+      "fileSize": 8182,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 28,
+      "sha1": "1d71d9318b31a0438bfbbeff31e5e9f9967bf760",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:13.882813409Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Microsoft CoPilot": 1,
+        "Stable Diffusion": 1,
+        "Music and audio": 1,
+        "license": 1,
+        "Deepmind": 2
+      }
+    },
+    "Bitcoin.md": {
+      "fileName": "Bitcoin.md",
+      "fileSize": 97286,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 214,
+      "sha1": "6d06c8f8136a9e87b0d7cb31e76b8af8ede055c3",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:42.966127363Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "cypherpunk": 1,
+        "Landscape": 1,
+        "Blockchain": 14,
+        "collaborative": 1,
+        "Money": 27,
+        "flossverse": 1,
+        "Gold": 4,
+        "infrastructure": 10,
+        "Bitcoin ETF": 1,
+        "Cashu": 2,
+        "Bitcoin": 202,
+        "BTC Layer 3": 1,
+        "nostr": 4,
+        "Politics, Law, Privacy": 1,
+        "Stable Coins": 2,
+        "ecash": 2,
+        "Rust": 3,
+        "Digital Asset Risks": 1,
+        "Bitcoin Technical Overview": 1,
+        "Ethereum": 8
+      }
+    },
+    "Calculating Empires.md": {
+      "fileName": "Calculating Empires.md",
+      "fileSize": 2064,
+      "nodeSize": 23.576,
+      "hyperlinkCount": 5,
+      "sha1": "ab61c3b4fec2962cb8ce3ecde187d9650cc0117e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:47.908344612Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Flux": 1,
+        "Calculating Empires": 2,
+        "Interfaces": 1,
+        "Cyber Security and Military": 1,
+        "Politics, Law, Privacy": 1,
+        "Education and AI": 1,
+        "Artificial Intelligence": 1,
+        "Digital Society Surveillance": 1
+      }
+    },
+    "relighting.md": {
+      "fileName": "relighting.md",
+      "fileSize": 1368,
+      "nodeSize": 17.312,
+      "hyperlinkCount": 8,
+      "sha1": "a24ca5fed1ec96c1e33cd6199964eb152077dc3a",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:45.174176857Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "AI Video": 1,
+        "relighting": 14,
+        "ComfyUI": 3,
+        "Apple": 4
+      }
+    },
+    "Gaussian splatting and Similar.md": {
+      "fileName": "Gaussian splatting and Similar.md",
+      "fileSize": 7756,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 15,
+      "sha1": "8359eca4d53913b6ef6d8e537cd12afed9c2a69b",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:01.561497027Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Gaussian splatting and Similar": 7,
+        "Scene Capture and Reconstruction": 1,
+        "Human tracking and SLAM capture": 1,
+        "Transformers": 1,
+        "Text to 3D and 4D": 1,
+        "SLAM": 8
+      }
+    },
+    "Bitcoin Technical Overview.md": {
+      "fileName": "Bitcoin Technical Overview.md",
+      "fileSize": 34697,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 65,
+      "sha1": "8e936a1e64b786b9d96fff6bb9f10124ced9b58a",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:40.682655612Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "nostr": 5,
+        "Mixed reality": 1,
+        "flossverse": 2,
+        "Distributed Identity": 1,
+        "Blockchain": 7,
+        "Ethereum": 1,
+        "collaborative": 1,
+        "Money": 8,
+        "Bitcoin": 81
+      }
+    },
+    "Deepmind.md": {
+      "fileName": "Deepmind.md",
+      "fileSize": 14,
+      "nodeSize": 5.126,
+      "hyperlinkCount": 0,
+      "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:24.417595714Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Algorithmic Bias and Variance.md": {
+      "fileName": "Algorithmic Bias and Variance.md",
+      "fileSize": 8489,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 22,
+      "sha1": "4a91499602b3f84d116606d1e29d81bc9e1255e7",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:25.316091890Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "ChatGPT": 6,
+        "Convergence": 1,
+        "Machine Learning": 1,
+        "Large language models": 1
+      }
+    },
+    "Privacy, Trust and Safety.md": {
+      "fileName": "Privacy, Trust and Safety.md",
+      "fileSize": 20401,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 11,
+      "sha1": "edfbc5f7def1d610a1c4149d40963bdbca0e200e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:40.542109377Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "nostr": 1,
+        "NVIDIA Omniverse": 1,
+        "Landscape": 1,
+        "Digital Society Harms": 1,
+        "Facebook Meta": 1,
+        "Money": 2,
+        "flossverse": 2,
+        "Conspiracies": 1,
+        "infrastructure": 3,
+        "Large language models": 1,
+        "Accessibility": 2,
+        "Global Inequality": 1,
+        "Llama": 1,
+        "Agents": 1,
+        "collaborative": 1,
+        "Machine Learning": 1
+      }
+    },
+    "Proprietary Large Language Models.md": {
+      "fileName": "Proprietary Large Language Models.md",
+      "fileSize": 6317,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 9,
+      "sha1": "5e018d1e235c07b4add752d24c1349f73a95cac8",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:47.429408415Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 1,
+        "Gemini": 3,
+        "Agents": 3,
+        "Artificial Intelligence": 1,
+        "Proprietary Large Language Models": 1,
+        "OpenAI": 9,
+        "Prompt Engineering": 2,
+        "ChatGPT": 3,
+        "Large language models": 2,
+        "Proprietary Image Generation": 1,
+        "artificial superintelligence": 1,
+        "multimodal": 2,
+        "Robotics": 1,
+        "AI Companies": 1,
+        "Microsoft CoPilot": 1
+      }
+    },
+    "nostr.md": {
+      "fileName": "nostr.md",
+      "fileSize": 41170,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 31,
+      "sha1": "d86ac5484f8006122b60f43c3355e07b484b3313",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:41.696878030Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Mixed reality": 1,
+        "Agents": 2,
+        "Digital Objects": 7,
+        "infrastructure": 4,
+        "nostr": 134,
+        "Bitcoin": 14,
+        "Distributed Identity": 2,
+        "collaborative": 2,
+        "Accessibility": 1,
+        "Landscape": 1
+      }
+    },
+    "Competition in AI.md": {
+      "fileName": "Competition in AI.md",
+      "fileSize": 2339,
+      "nodeSize": 26.051,
+      "hyperlinkCount": 1,
+      "sha1": "883b2c86288efd73e2ecfc008638840f9d9237a0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:01.494474893Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 4,
+        "latent space": 1,
+        "AI Companies": 1,
+        "Apple": 2,
+        "multimodal": 1,
+        "Deepmind": 1,
+        "ChatGPT": 2,
+        "infrastructure": 2
+      }
+    },
+    "Open Generative AI tools.md": {
+      "fileName": "Open Generative AI tools.md",
+      "fileSize": 2630,
+      "nodeSize": 28.67,
+      "hyperlinkCount": 5,
+      "sha1": "fdab291f326cd1b0dc4268998f2c89e088ba6020",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:19.533355410Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Stable Diffusion": 1,
+        "ComfyUI": 1,
+        "OpenAI": 2,
+        "Large language models": 1,
+        "Llama": 1,
+        "Text to 3D and 4D": 1
+      }
+    },
+    "Blender.md": {
+      "fileName": "Blender.md",
+      "fileSize": 168,
+      "nodeSize": 6.5120000000000005,
+      "hyperlinkCount": 0,
+      "sha1": "0df1342462b955899508959a47cfca64c8a28048",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:43.801202951Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Text to 3D and 4D": 1
+      }
+    },
+    "Education and AI.md": {
+      "fileName": "Education and AI.md",
+      "fileSize": 15391,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 17,
+      "sha1": "f8162d1c848cb858cc121d2f5a39f9b6555cd667",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:38.560726838Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "collaborative": 1,
+        "Facebook Meta": 1,
+        "Privacy, Trust and Safety": 1,
+        "Large language models": 1,
+        "Landscape": 2,
+        "Diagrams as Code": 1,
+        "Deepfakes and fraudulent content": 1,
+        "Money": 1,
+        "Education and AI": 7,
+        "Social contract and jobs": 1,
+        "ChatGPT": 3
+      }
+    },
+    "Visionflow.md": {
+      "fileName": "Visionflow.md",
+      "fileSize": 5188,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "6adb7b439a04e51b13d9829d9a7deed97a8a9c50",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:02.029776447Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 1,
+        "flossverse": 2,
+        "Machine Learning": 2,
+        "Virtual Production": 11,
+        "Visionflow": 5,
+        "Robotics": 4
+      }
+    },
+    "Global Inequality.md": {
+      "fileName": "Global Inequality.md",
+      "fileSize": 35143,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 11,
+      "sha1": "5436bf1482d2b5e597e60cf92aafaffbb4915bf0",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:05.108073687Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 9,
+        "Artificial Intelligence": 1,
+        "Blockchain": 2,
+        "Stable Coins": 1,
+        "infrastructure": 1,
+        "license": 1,
+        "Landscape": 1
+      }
+    },
+    "Agents.md": {
+      "fileName": "Agents.md",
+      "fileSize": 5445,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 8,
+      "sha1": "fe1012e118dbebc31844f42e28f0f434ec741c16",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:23.387552229Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agents": 24,
+        "collaborative": 1,
+        "ChatGPT": 1,
+        "Reasoning": 2,
+        "Social contract and jobs": 1,
+        "Microsoft CoPilot": 1,
+        "multimodal": 2,
+        "OpenAI": 5,
+        "Interfaces": 2,
+        "Accessibility": 1
+      }
+    },
+    "Bitcoin Value Proposition.md": {
+      "fileName": "Bitcoin Value Proposition.md",
+      "fileSize": 53300,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 24,
+      "sha1": "e8ae399e02acdaae009b6c3a4777156d4cedf80d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:41.410244845Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 12,
+        "Ethereum": 3,
+        "Gold": 9,
+        "Cashu": 1,
+        "Accessibility": 1,
+        "collaborative": 1,
+        "Bitcoin": 186,
+        "Convergence": 1,
+        "Blockchain": 5,
+        "infrastructure": 6,
+        "Landscape": 3,
+        "RGB and Client Side Validation": 1,
+        "Agents": 1,
+        "Mixed reality": 1
+      }
+    },
+    "Comparison of GPT4 and Gemini Ultra.md": {
+      "fileName": "Comparison of GPT4 and Gemini Ultra.md",
+      "fileSize": 3048,
+      "nodeSize": 32.432,
+      "hyperlinkCount": 0,
+      "sha1": "98ef9ac102777f21411b105b6b3ef860af297228",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:59.540459045Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "ChatGPT": 13,
+        "Gemini": 12
+      }
+    },
+    "California AI bill.md": {
+      "fileName": "California AI bill.md",
+      "fileSize": 5403,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 0,
+      "sha1": "24bb18205e4e37e20704b73f32b1c2b28b7dae3f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:49.132625279Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 2,
+        "collaborative": 2
+      }
+    },
+    "Deepfakes and fraudulent content.md": {
+      "fileName": "Deepfakes and fraudulent content.md",
+      "fileSize": 1457,
+      "nodeSize": 18.113,
+      "hyperlinkCount": 8,
+      "sha1": "3647f419f6285abdc0a5313bf8375a5df40bd68d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:23.689444291Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agents": 1,
+        "Cyber security and Cryptography": 1
+      }
+    },
+    "Overview of Machine Learning Techniques.md": {
+      "fileName": "Overview of Machine Learning Techniques.md",
+      "fileSize": 7147,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 18,
+      "sha1": "b42c90f063ac83bfc71ca3fc133eef422505162f",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:24.436528238Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "GANs": 1,
+        "Proprietary Large Language Models": 2,
+        "Deep Learning": 3,
+        "Machine Learning": 2,
+        "Diffusion Models": 2,
+        "Large language models": 2,
+        "Transformers": 2,
+        "Artificial Intelligence": 1,
+        "State Space and Other Approaches": 1
+      }
+    },
+    "Tokenisation.md": {
+      "fileName": "Tokenisation.md",
+      "fileSize": 2570,
+      "nodeSize": 28.13,
+      "hyperlinkCount": 2,
+      "sha1": "5b5ba3f8cabcfa6cbe0dec028c4604bb2492e709",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:45.706966568Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 1,
+        "Blockchain": 1,
+        "Tokenisation": 6
+      }
+    },
+    "Energy and Power.md": {
+      "fileName": "Energy and Power.md",
+      "fileSize": 26099,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 59,
+      "sha1": "af993f160d3f02d60e4ad699373e8dd26258829b",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:43.223594051Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Convergence": 1,
+        "Money": 7,
+        "Blockchain": 3,
+        "Energy and Power": 1,
+        "Bitcoin": 72,
+        "Artificial Intelligence": 1,
+        "Gold": 2,
+        "infrastructure": 8
+      }
+    },
+    "Sam Hammond.md": {
+      "fileName": "Sam Hammond.md",
+      "fileSize": 17935,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "6d6e2566f510254770291bdad5e4300623341fbf",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:13.469982026Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Deep Learning": 1,
+        "Sam Hammond": 1,
+        "Accessibility": 1,
+        "Social contract and jobs": 1,
+        "Landscape": 4,
+        "OpenAI": 1,
+        "AI Risks": 3
+      }
+    },
+    "Hardware and Edge.md": {
+      "fileName": "Hardware and Edge.md",
+      "fileSize": 32615,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 70,
+      "sha1": "c2a9767c9ac8040522a7f6af45bc343f7072f7dc",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:12.099057661Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Landscape": 1,
+        "Mixed reality": 2,
+        "Digital Objects": 1,
+        "Llama": 6,
+        "Apple": 7,
+        "Transformers": 2,
+        "Interfaces": 7,
+        "Machine Learning": 1,
+        "Vision Pro": 1,
+        "ollama": 6,
+        "OpenAI": 2,
+        "Money": 1,
+        "Spatial Computing": 2,
+        "Hardware and Edge": 2,
+        "Large language models": 3,
+        "ChatGPT": 4,
+        "Artificial Intelligence": 2,
+        "Proprietary Large Language Models": 1,
+        "Stable Diffusion": 1
+      }
+    },
+    "RGB and Client Side Validation.md": {
+      "fileName": "RGB and Client Side Validation.md",
+      "fileSize": 8861,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 29,
+      "sha1": "daa7038a18ff53c3e567f440755a67b51ab9a370",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:57.293154399Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Blockchain": 2,
+        "Interfaces": 7,
+        "Rust": 6,
+        "Bitcoin": 5
+      }
+    },
+    "Octave Multi Model Laboratory.md": {
+      "fileName": "Octave Multi Model Laboratory.md",
+      "fileSize": 2325,
+      "nodeSize": 25.925000000000004,
+      "hyperlinkCount": 6,
+      "sha1": "34ea203172ccadf208dda2aa1cb8036ebe6ee74b",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:18.061917637Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Mixed reality": 4,
+        "Digital Objects": 1,
+        "Money": 1,
+        "Hardware and Edge": 1,
+        "collaborative": 1,
+        "Machine Learning": 1,
+        "National Industrial Centre for Virtual Environments": 1,
+        "Convergence": 1
+      }
+    },
+    "Gemini.md": {
+      "fileName": "Gemini.md",
+      "fileSize": 1958,
+      "nodeSize": 22.622,
+      "hyperlinkCount": 7,
+      "sha1": "3f9377a187137c61808cacf852367e19c785cf4a",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:02.828534683Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Llama": 1,
+        "Deepmind": 1,
+        "Gemini": 10
+      }
+    },
+    "NVIDIA Omniverse.md": {
+      "fileName": "NVIDIA Omniverse.md",
+      "fileSize": 8803,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "c75db8022df635790212415dd45912c4faf0627d",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:14.628117500Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Spatial Computing": 2,
+        "collaborative": 2,
+        "Blender": 7,
+        "Interfaces": 1,
+        "NVIDIA Omniverse": 1
+      }
+    },
+    "Vesuvian Scrolls.md": {
+      "fileName": "Vesuvian Scrolls.md",
+      "fileSize": 2741,
+      "nodeSize": 29.669,
+      "hyperlinkCount": 3,
+      "sha1": "68081aa4856d1e568aff2fc04622dba695a36b73",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:56.550447659Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "State Space and Other Approaches.md": {
+      "fileName": "State Space and Other Approaches.md",
+      "fileSize": 28558,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 5,
+      "sha1": "8d9a5d9f6cf452e34f974cd4a6f21b3be285d210",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:30.331744743Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 2,
+        "Gemini": 2,
+        "Transformers": 17,
+        "Artificial Intelligence": 1,
+        "Robotics": 1
+      }
+    },
+    "OpenAI.md": {
+      "fileName": "OpenAI.md",
+      "fileSize": 59,
+      "nodeSize": 5.531,
+      "hyperlinkCount": 0,
+      "sha1": "c57f67f385311e21f99ab67644e7255e55f527f8",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:22.212485169Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {}
+    },
+    "Introduction to me.md": {
+      "fileName": "Introduction to me.md",
+      "fileSize": 5006,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 12,
+      "sha1": "fac7bda18f6960d752787d0ee522eb84567f7729",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:25.941391561Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Agentic Alliance": 1,
+        "Visionflow": 3,
+        "Interfaces": 1,
+        "Singularity": 1,
+        "Social contract and jobs": 1,
+        "Recent Projects": 1,
+        "Convergence": 2,
+        "Knowledge Graphing and RAG": 2,
+        "flossverse": 4,
+        "Bitcoin": 2,
+        "Money": 1
+      }
+    },
+    "Base models.md": {
+      "fileName": "Base models.md",
+      "fileSize": 84942,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 1,
+      "sha1": "698dff0c0889c174e01a4d09544f176c2a7edd22",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:36.535334852Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Base models": 1,
+        "OpenAI": 12,
+        "Depth Estimation": 1,
+        "Diffusion Models": 7,
+        "license": 11,
+        "Transformers": 7,
+        "Money": 1,
+        "Large language models": 8,
+        "Inpainting": 3,
+        "ChatGPT": 21,
+        "Stable Diffusion": 9,
+        "Deep Learning": 6,
+        "multimodal": 4,
+        "Llama": 30,
+        "Reasoning": 1,
+        "Prompt Engineering": 4,
+        "Landscape": 1,
+        "Machine Learning": 8,
+        "Accessibility": 2,
+        "Artificial Intelligence": 3,
+        "Apple": 2
+      }
+    },
+    "Semantic Web.md": {
+      "fileName": "Semantic Web.md",
+      "fileSize": 15524,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 5,
+      "sha1": "8c26c2cbc21a0b22630ca576d766390a9bd851ce",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:17.650758345Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Transformers": 1,
+        "Agents": 1,
+        "infrastructure": 1,
+        "nostr": 1,
+        "Bitcoin": 1,
+        "Reasoning": 8,
+        "Apple": 1,
+        "Blockchain": 3,
+        "Large language models": 3,
+        "Semantic Web": 9
+      }
+    },
+    "Geopolitical hot takes.md": {
+      "fileName": "Geopolitical hot takes.md",
+      "fileSize": 15425,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 0,
+      "sha1": "cbf1b708951e324b173b654c2a398075b514bdc2",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:04.376057503Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 10
+      }
+    },
+    "Social contract and jobs.md": {
+      "fileName": "Social contract and jobs.md",
+      "fileSize": 44932,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 71,
+      "sha1": "11a943ece9b32e32b194cc0cd95d09ee7c66498e",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:21.095761947Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Politics, Law, Privacy": 1,
+        "Deep Learning": 1,
+        "Llama": 1,
+        "infrastructure": 1,
+        "Cyber Security and Military": 1,
+        "Accessibility": 1,
+        "Hyper personalisation": 1,
+        "Landscape": 4,
+        "Layoff tracker and threatened roles": 2,
+        "Agents": 1,
+        "Artificial Intelligence": 7,
+        "OpenAI": 4,
+        "Singularity": 1,
+        "Money": 2,
+        "AI Video": 1,
+        "Mixed reality": 1,
+        "Privacy, Trust and Safety": 1,
+        "Robotics": 1,
+        "ChatGPT": 4,
+        "Humans, Avatars , Character": 1,
+        "Social contract and jobs": 15
+      }
+    },
+    "infrastructure.md": {
+      "fileName": "infrastructure.md",
+      "fileSize": 5571,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 9,
+      "sha1": "83ead488680945dbe08a356b008dbcee6000f990",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:28.783870693Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Privacy, Trust and Safety": 1,
+        "Money": 2
+      }
+    },
+    "AnimateDiff.md": {
+      "fileName": "AnimateDiff.md",
+      "fileSize": 298,
+      "nodeSize": 7.682,
+      "hyperlinkCount": 1,
+      "sha1": "4925127460d01f5ee29b7f566b29b11f841bdd0c",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:26.036348101Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "AnimateDiff": 1
+      }
+    },
+    "Agentic Mycelia.md": {
+      "fileName": "Agentic Mycelia.md",
+      "fileSize": 28645,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 4,
+      "sha1": "eba2a13d1cdcf1381b9355cb6cdda602f7df7c63",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:08:22.667701850Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 3,
+        "Accessibility": 1,
+        "Large language models": 2,
+        "Anthropic Claude": 1,
+        "Metaverse Ontology": 1,
+        "Gemini": 5,
+        "Agentic Mycelia": 7,
+        "Agents": 29,
+        "Prompt Engineering": 1,
+        "Money": 1,
+        "Bitcoin": 4,
+        "nostr": 17,
+        "Diagrams as Code": 3,
+        "Interfaces": 4
+      }
+    },
+    "Large language models.md": {
+      "fileName": "Large language models.md",
+      "fileSize": 63087,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 192,
+      "sha1": "dd952178ab8d4ea5d4be12320beb66ceec672264",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:35.646324435Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "collaborative": 2,
+        "ChatGPT": 19,
+        "Base models": 1,
+        "Deep Learning": 15,
+        "Llama": 7,
+        "Diffusion Models": 1,
+        "OpenAI": 10,
+        "infrastructure": 3,
+        "Digital Objects": 1,
+        "Interfaces": 9,
+        "Prompt Engineering": 1,
+        "Transformers": 2,
+        "multimodal": 5,
+        "Artificial Intelligence": 3,
+        "Large language models": 15,
+        "Machine Learning": 2,
+        "Reasoning": 2,
+        "license": 2,
+        "Accessibility": 2
+      }
+    },
+    "Hyper personalisation.md": {
+      "fileName": "Hyper personalisation.md",
+      "fileSize": 3115,
+      "nodeSize": 33.035000000000004,
+      "hyperlinkCount": 1,
+      "sha1": "81e179362c4fd474c67104b9eb3fed70e733bdba",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:18.978104130Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 1,
+        "Stable Diffusion": 1,
+        "ChatGPT": 1,
+        "Large language models": 1
+      }
+    },
+    "Distributed Identity.md": {
+      "fileName": "Distributed Identity.md",
+      "fileSize": 59124,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 57,
+      "sha1": "6bb3713d9a67ab162c1e85746b1dd741b8bfa663",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:34.405788583Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 23,
+        "Agents": 1,
+        "nostr": 78,
+        "Mixed reality": 2,
+        "Blockchain": 2,
+        "Money": 4,
+        "infrastructure": 2,
+        "Digital Objects": 1,
+        "Product Design": 2,
+        "Distributed Identity": 8,
+        "collaborative": 3
+      }
+    },
+    "Metaverse as Markets.md": {
+      "fileName": "Metaverse as Markets.md",
+      "fileSize": 11006,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 7,
+      "sha1": "1084bcea8cecdc3b3d6bcbd4ace9788d800b5dd3",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:01.136771278Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Money": 1,
+        "Bitcoin": 1,
+        "Blockchain": 2
+      }
+    },
+    "latent space.md": {
+      "fileName": "latent space.md",
+      "fileSize": 1626,
+      "nodeSize": 19.634,
+      "hyperlinkCount": 0,
+      "sha1": "f07817e32235a6342d1d9c0c7393b80fd045b7ff",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:13:32.264176142Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 1,
+        "Artificial Intelligence": 1,
+        "latent space": 7
+      }
+    },
+    "Gold.md": {
+      "fileName": "Gold.md",
+      "fileSize": 5494,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 2,
+      "sha1": "335a427e3d14b167293ad21087ff24500f64c4f6",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:10:05.855617981Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Gold": 30
+      }
+    },
+    "Financialised Agentic Memetics.md": {
+      "fileName": "Financialised Agentic Memetics.md",
+      "fileSize": 2442,
+      "nodeSize": 26.978,
+      "hyperlinkCount": 1,
+      "sha1": "7e32c48849f9bbabc5a9004d1c97fceb0e78510a",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:09:54.400339386Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Bitcoin": 1,
+        "Blockchain": 1,
+        "Tokenisation": 1,
+        "Agents": 1
+      }
+    },
+    "Rust.md": {
+      "fileName": "Rust.md",
+      "fileSize": 3324,
+      "nodeSize": 34.916,
+      "hyperlinkCount": 0,
+      "sha1": "904052bcb6c40ea9f5cbe7762cba6470409b39e3",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:10.030655380Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "Rust": 2
+      }
+    },
+    "Speech and voice.md": {
+      "fileName": "Speech and voice.md",
+      "fileSize": 13439,
+      "nodeSize": 50.0,
+      "hyperlinkCount": 43,
+      "sha1": "12af93d19c15bd4210789c0ead6e5d40f70fa902",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:12:26.828227281Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "OpenAI": 5,
+        "ChatGPT": 6,
+        "AI Companies": 1,
+        "Product Design": 1,
+        "NVIDIA Omniverse": 1,
+        "Artificial Intelligence": 1,
+        "Agents": 1,
+        "Speech and voice": 11,
+        "Accessibility": 1,
+        "Large language models": 2,
+        "license": 1,
+        "Social contract and jobs": 1
+      }
+    },
+    "Microsoft CoPilot.md": {
+      "fileName": "Microsoft CoPilot.md",
+      "fileSize": 4569,
+      "nodeSize": 46.120999999999995,
+      "hyperlinkCount": 7,
+      "sha1": "7036139cdbe327bf3f2d5a3aec96f73efed1f7e9",
+      "nodeId": "0",
+      "lastModified": "2025-02-15T16:11:02.612759857Z",
+      "perplexityLink": "",
+      "lastPerplexityProcess": null,
+      "topicCounts": {
+        "infrastructure": 2,
+        "Microsoft CoPilot": 1,
+        "Artificial Intelligence": 1,
+        "OpenAI": 5,
+        "Deep Learning": 1,
+        "ChatGPT": 3
+      }
+    }
+  },
+  "lastValidated": "2025-03-13T19:14:18.961290096Z"
+}
\ No newline at end of file
diff --git a/data/metadata/layout.json b/data/metadata/layout.json
new file mode 100644
index 00000000..8f5c7fac
--- /dev/null
+++ b/data/metadata/layout.json
@@ -0,0 +1,1064 @@
+[
+  [
+    "1",
+    1.5795143,
+    0.026690919,
+    0.46384197
+  ],
+  [
+    "2",
+    -0.55445606,
+    -0.31477875,
+    0.47859833
+  ],
+  [
+    "3",
+    0.13656881,
+    0.1571115,
+    0.505667
+  ],
+  [
+    "4",
+    -0.058380112,
+    -0.8399546,
+    -0.7819426
+  ],
+  [
+    "5",
+    -0.112085514,
+    0.5312964,
+    -0.2242438
+  ],
+  [
+    "6",
+    1.2636701,
+    -0.4072294,
+    0.70267683
+  ],
+  [
+    "7",
+    0.018244248,
+    -0.30152526,
+    0.19804314
+  ],
+  [
+    "8",
+    -0.09946747,
+    -0.84632796,
+    0.48358825
+  ],
+  [
+    "9",
+    0.8320425,
+    -0.061668746,
+    -0.20655264
+  ],
+  [
+    "10",
+    1.0578811,
+    0.1503851,
+    0.29707015
+  ],
+  [
+    "11",
+    -0.6572219,
+    0.0378147,
+    0.35063517
+  ],
+  [
+    "12",
+    -0.42513028,
+    -0.31673804,
+    0.30182862
+  ],
+  [
+    "13",
+    -0.29614502,
+    -1.356526,
+    0.6971576
+  ],
+  [
+    "14",
+    0.30711937,
+    -0.86871064,
+    -0.09715061
+  ],
+  [
+    "15",
+    0.43790314,
+    0.06735327,
+    -1.4219497
+  ],
+  [
+    "16",
+    0.46449104,
+    -0.25437784,
+    -0.80804205
+  ],
+  [
+    "17",
+    0.7120244,
+    -0.6939046,
+    -0.08063056
+  ],
+  [
+    "18",
+    0.6343921,
+    -1.1383508,
+    -0.6503
+  ],
+  [
+    "19",
+    -0.32974756,
+    1.4037542,
+    0.59417427
+  ],
+  [
+    "20",
+    -0.0068727974,
+    0.58405936,
+    0.07271266
+  ],
+  [
+    "21",
+    0.5004235,
+    -0.10906485,
+    -0.43949595
+  ],
+  [
+    "22",
+    1.5148059,
+    0.082061,
+    -1.4915506
+  ],
+  [
+    "23",
+    0.60770625,
+    -0.6829184,
+    -0.62492687
+  ],
+  [
+    "24",
+    0.51469725,
+    0.115909085,
+    -0.45567384
+  ],
+  [
+    "25",
+    -0.042375907,
+    0.29577067,
+    -0.5751043
+  ],
+  [
+    "26",
+    0.9626573,
+    -0.32050094,
+    0.9451031
+  ],
+  [
+    "27",
+    -0.7834667,
+    0.57830155,
+    0.03396564
+  ],
+  [
+    "28",
+    0.022613073,
+    0.21648404,
+    -0.8989357
+  ],
+  [
+    "29",
+    0.2930559,
+    0.37371197,
+    -0.52509886
+  ],
+  [
+    "30",
+    0.32159227,
+    -0.6567169,
+    -0.44906142
+  ],
+  [
+    "31",
+    -0.56681377,
+    -0.3569784,
+    1.0744745
+  ],
+  [
+    "32",
+    0.84575546,
+    -0.4252595,
+    -0.8848612
+  ],
+  [
+    "33",
+    -0.12340371,
+    -1.2074398,
+    -0.27647528
+  ],
+  [
+    "34",
+    0.4332752,
+    -0.28676948,
+    -0.2711503
+  ],
+  [
+    "35",
+    1.2263722,
+    -0.48613617,
+    -0.0051767663
+  ],
+  [
+    "36",
+    0.5488623,
+    0.011897069,
+    -0.7700375
+  ],
+  [
+    "37",
+    -0.5027484,
+    -0.035434317,
+    0.2783376
+  ],
+  [
+    "38",
+    0.08988686,
+    0.3000549,
+    -0.2935092
+  ],
+  [
+    "39",
+    0.39027297,
+    0.73062605,
+    0.7634836
+  ],
+  [
+    "40",
+    -0.54586005,
+    0.42742756,
+    0.58581483
+  ],
+  [
+    "41",
+    -0.19269149,
+    -0.58207387,
+    0.17486712
+  ],
+  [
+    "42",
+    0.1470549,
+    -0.37287465,
+    -0.40632316
+  ],
+  [
+    "43",
+    -0.3018472,
+    -0.11828339,
+    -0.06456726
+  ],
+  [
+    "44",
+    -0.24256457,
+    -0.67518854,
+    -0.38631535
+  ],
+  [
+    "45",
+    0.11980341,
+    -0.10463985,
+    -0.07264491
+  ],
+  [
+    "46",
+    -0.14311416,
+    0.2275989,
+    -0.06300835
+  ],
+  [
+    "47",
+    -0.05479754,
+    0.7903985,
+    -0.45877448
+  ],
+  [
+    "48",
+    0.010234579,
+    1.4244546,
+    -1.0530585
+  ],
+  [
+    "49",
+    -0.46500373,
+    -0.42693388,
+    0.08210599
+  ],
+  [
+    "50",
+    0.13328284,
+    -0.11313675,
+    -0.33899942
+  ],
+  [
+    "51",
+    -0.09019398,
+    -0.41549176,
+    -0.18308677
+  ],
+  [
+    "52",
+    -0.8717917,
+    -0.27205828,
+    0.10652627
+  ],
+  [
+    "53",
+    0.2910176,
+    0.12839273,
+    -0.666585
+  ],
+  [
+    "54",
+    -0.8502566,
+    0.034294933,
+    0.06681275
+  ],
+  [
+    "55",
+    0.2740456,
+    -0.74971133,
+    0.13021566
+  ],
+  [
+    "56",
+    0.2166642,
+    -0.10677025,
+    -1.231093
+  ],
+  [
+    "57",
+    -0.98285365,
+    -0.600415,
+    -1.078208
+  ],
+  [
+    "58",
+    -0.29165697,
+    0.95144516,
+    0.06622453
+  ],
+  [
+    "59",
+    -0.68165886,
+    -0.020416552,
+    0.12414788
+  ],
+  [
+    "60",
+    -0.8072368,
+    -0.14507338,
+    0.37178677
+  ],
+  [
+    "61",
+    0.123762205,
+    -0.15819223,
+    0.7366294
+  ],
+  [
+    "62",
+    -0.15067616,
+    -0.056206614,
+    0.058230884
+  ],
+  [
+    "63",
+    -0.55525327,
+    0.3590757,
+    -0.27476752
+  ],
+  [
+    "64",
+    0.3593603,
+    -0.07229012,
+    0.1529537
+  ],
+  [
+    "65",
+    -0.44816002,
+    -0.83089256,
+    0.103576586
+  ],
+  [
+    "66",
+    0.20224941,
+    0.9400997,
+    -0.7193383
+  ],
+  [
+    "67",
+    0.888083,
+    0.021979516,
+    0.008545391
+  ],
+  [
+    "68",
+    0.6099294,
+    0.61174136,
+    -0.74959457
+  ],
+  [
+    "69",
+    -0.85149467,
+    -0.05897879,
+    -1.0434359
+  ],
+  [
+    "70",
+    1.1953585,
+    -0.2097832,
+    0.83442986
+  ],
+  [
+    "71",
+    0.1799957,
+    0.29822397,
+    1.0125985
+  ],
+  [
+    "72",
+    0.17477556,
+    -0.01993675,
+    -0.99799895
+  ],
+  [
+    "73",
+    0.81317776,
+    -0.55091983,
+    0.31795204
+  ],
+  [
+    "74",
+    -1.5608526,
+    0.15281326,
+    -0.7640874
+  ],
+  [
+    "75",
+    0.007045948,
+    -0.48094139,
+    -1.3349397
+  ],
+  [
+    "76",
+    -0.45641944,
+    -0.22341791,
+    -1.0815632
+  ],
+  [
+    "77",
+    0.46851927,
+    -0.74502444,
+    0.4939618
+  ],
+  [
+    "78",
+    -1.0314721,
+    0.5269503,
+    -0.28269976
+  ],
+  [
+    "79",
+    -1.4079226,
+    -0.6398423,
+    -0.17392027
+  ],
+  [
+    "80",
+    0.24076524,
+    0.6325342,
+    0.3120385
+  ],
+  [
+    "81",
+    0.6703531,
+    -0.2819264,
+    -1.1653873
+  ],
+  [
+    "82",
+    0.6267869,
+    0.1798911,
+    0.0059648002
+  ],
+  [
+    "83",
+    -0.58625126,
+    0.84905845,
+    0.5830656
+  ],
+  [
+    "84",
+    -1.2475775,
+    -0.42896843,
+    0.79030097
+  ],
+  [
+    "85",
+    1.1226736,
+    -0.93204534,
+    0.19525345
+  ],
+  [
+    "86",
+    0.73553526,
+    -0.91185844,
+    0.17817071
+  ],
+  [
+    "87",
+    -0.4482243,
+    1.4461643,
+    -0.25781205
+  ],
+  [
+    "88",
+    -0.096594855,
+    -0.10041877,
+    0.16210106
+  ],
+  [
+    "89",
+    -0.5870664,
+    -0.33671018,
+    -0.11245844
+  ],
+  [
+    "90",
+    0.1321456,
+    -0.07699054,
+    0.4479199
+  ],
+  [
+    "91",
+    1.2916832,
+    -0.0056515234,
+    -0.539543
+  ],
+  [
+    "92",
+    -0.50569195,
+    -0.19858076,
+    0.16030574
+  ],
+  [
+    "93",
+    0.2397085,
+    -0.3353877,
+    0.17636493
+  ],
+  [
+    "94",
+    0.9033043,
+    -0.21506694,
+    0.3690493
+  ],
+  [
+    "95",
+    0.42411575,
+    -0.76154655,
+    0.8901563
+  ],
+  [
+    "96",
+    -1.10355,
+    -0.11652967,
+    0.26547003
+  ],
+  [
+    "97",
+    0.43845814,
+    0.31058463,
+    0.45436344
+  ],
+  [
+    "98",
+    0.7536758,
+    0.3075368,
+    -0.55741274
+  ],
+  [
+    "99",
+    -0.4786193,
+    0.8339933,
+    -0.4110265
+  ],
+  [
+    "100",
+    0.5495662,
+    1.5209508,
+    -1.957235
+  ],
+  [
+    "101",
+    -0.7718838,
+    0.7151625,
+    -0.7399421
+  ],
+  [
+    "102",
+    -0.06951529,
+    -0.94095486,
+    -1.3014736
+  ],
+  [
+    "103",
+    0.9974238,
+    0.53906405,
+    -1.1019276
+  ],
+  [
+    "104",
+    -1.9466233,
+    0.9194306,
+    1.4533753
+  ],
+  [
+    "105",
+    0.9843109,
+    0.5653747,
+    -0.2509083
+  ],
+  [
+    "106",
+    0.3860121,
+    0.0441978,
+    -0.29098028
+  ],
+  [
+    "107",
+    -1.0203599,
+    -0.22574662,
+    -0.42372635
+  ],
+  [
+    "108",
+    0.47104973,
+    0.26910672,
+    -0.27037597
+  ],
+  [
+    "109",
+    0.9613532,
+    -0.5950097,
+    -0.46542823
+  ],
+  [
+    "110",
+    -0.5818014,
+    -0.151768,
+    -0.27953598
+  ],
+  [
+    "111",
+    0.9326172,
+    -0.12105172,
+    -0.3534946
+  ],
+  [
+    "112",
+    -0.2122031,
+    -0.06423136,
+    0.77363497
+  ],
+  [
+    "113",
+    -0.43949232,
+    -0.26899078,
+    -0.15678497
+  ],
+  [
+    "114",
+    0.23760103,
+    0.08783481,
+    -0.41953412
+  ],
+  [
+    "115",
+    0.30729887,
+    -0.37989727,
+    -0.5228486
+  ],
+  [
+    "116",
+    -0.76245177,
+    0.085253134,
+    -0.41400284
+  ],
+  [
+    "117",
+    0.6964897,
+    -0.36725876,
+    -0.23418714
+  ],
+  [
+    "118",
+    -1.0290704,
+    1.1559405,
+    0.100126185
+  ],
+  [
+    "119",
+    1.0161965,
+    -0.31591907,
+    -0.26194203
+  ],
+  [
+    "120",
+    -0.11986353,
+    0.29003888,
+    0.7191904
+  ],
+  [
+    "121",
+    0.3682872,
+    -0.38840702,
+    0.5914874
+  ],
+  [
+    "122",
+    -0.51337105,
+    0.04154814,
+    0.5984922
+  ],
+  [
+    "123",
+    -0.045363456,
+    0.9283164,
+    0.49688306
+  ],
+  [
+    "124",
+    -1.236247,
+    -2.069741,
+    -0.64682233
+  ],
+  [
+    "125",
+    -1.1493204,
+    0.25808445,
+    0.9077236
+  ],
+  [
+    "126",
+    0.19743909,
+    0.31880125,
+    0.11308485
+  ],
+  [
+    "127",
+    -0.7834038,
+    0.2913564,
+    0.2744769
+  ],
+  [
+    "128",
+    -0.14113404,
+    -0.09367021,
+    -0.89359367
+  ],
+  [
+    "129",
+    0.016104786,
+    0.15495113,
+    0.048856076
+  ],
+  [
+    "130",
+    0.38108808,
+    -0.1635777,
+    -0.15759605
+  ],
+  [
+    "131",
+    0.54227865,
+    1.3159661,
+    -0.21331611
+  ],
+  [
+    "132",
+    0.29223356,
+    -0.36379084,
+    -0.036180165
+  ],
+  [
+    "133",
+    1.2739033,
+    0.11691908,
+    -1.2629381
+  ],
+  [
+    "134",
+    -0.44721192,
+    -0.4659828,
+    -0.50405717
+  ],
+  [
+    "135",
+    -0.40192246,
+    0.078861475,
+    -0.06305328
+  ],
+  [
+    "136",
+    -0.31342927,
+    -0.15201332,
+    -0.43619645
+  ],
+  [
+    "137",
+    0.20096733,
+    0.54031336,
+    -0.13783774
+  ],
+  [
+    "138",
+    0.37126452,
+    -0.67803454,
+    -0.9657513
+  ],
+  [
+    "139",
+    0.025695665,
+    1.1520084,
+    -0.091036655
+  ],
+  [
+    "140",
+    -0.025893405,
+    -0.017036464,
+    -0.5400795
+  ],
+  [
+    "141",
+    -0.61823887,
+    0.4222304,
+    -0.9613979
+  ],
+  [
+    "142",
+    -0.95077485,
+    -0.9834823,
+    -0.6754005
+  ],
+  [
+    "143",
+    0.8041748,
+    0.69693434,
+    0.34074506
+  ],
+  [
+    "144",
+    0.9318581,
+    -0.41005385,
+    -0.058049496
+  ],
+  [
+    "145",
+    1.6739432,
+    -1.5353239,
+    1.1857941
+  ],
+  [
+    "146",
+    -0.07973724,
+    -0.3889575,
+    0.4268699
+  ],
+  [
+    "147",
+    -0.9736018,
+    -0.15759732,
+    -0.22832872
+  ],
+  [
+    "148",
+    0.5797756,
+    0.5280725,
+    -0.19616811
+  ],
+  [
+    "149",
+    -0.79488075,
+    1.6559656,
+    -1.6485506
+  ],
+  [
+    "150",
+    -0.22616704,
+    -0.0011173387,
+    -0.30512744
+  ],
+  [
+    "151",
+    -0.6846969,
+    -0.1508973,
+    0.1478086
+  ],
+  [
+    "152",
+    0.28124863,
+    -0.17048842,
+    -0.44864365
+  ],
+  [
+    "153",
+    0.59538615,
+    -0.2809976,
+    0.39131376
+  ],
+  [
+    "154",
+    0.2370835,
+    0.46689132,
+    -0.8752177
+  ],
+  [
+    "155",
+    -0.6895644,
+    -0.9643963,
+    0.28965545
+  ],
+  [
+    "156",
+    0.121590964,
+    -0.33712035,
+    -0.74100673
+  ],
+  [
+    "157",
+    0.021038473,
+    -0.5754699,
+    0.7554841
+  ],
+  [
+    "158",
+    -0.1216246,
+    0.032120246,
+    0.38284677
+  ],
+  [
+    "159",
+    0.6306159,
+    -0.1599371,
+    -0.11904197
+  ],
+  [
+    "160",
+    -0.7341079,
+    -0.33686638,
+    0.25186422
+  ],
+  [
+    "161",
+    -1.0888193,
+    -1.0026097,
+    0.0440253
+  ],
+  [
+    "162",
+    0.3788194,
+    0.97080237,
+    0.08506854
+  ],
+  [
+    "163",
+    -0.3396719,
+    0.6653908,
+    -1.5135844
+  ],
+  [
+    "164",
+    0.30091953,
+    -1.1024879,
+    0.2919827
+  ],
+  [
+    "165",
+    -0.14062887,
+    -0.4616007,
+    -0.94244415
+  ],
+  [
+    "166",
+    -0.33772996,
+    0.5030688,
+    -0.04450913
+  ],
+  [
+    "167",
+    0.33413357,
+    0.64680487,
+    -1.3688482
+  ],
+  [
+    "168",
+    -0.44651327,
+    0.16662939,
+    -0.7225683
+  ],
+  [
+    "169",
+    -0.21886165,
+    0.6714884,
+    -0.84723336
+  ],
+  [
+    "170",
+    -0.78896344,
+    -0.58137274,
+    -0.19048798
+  ],
+  [
+    "171",
+    0.26108214,
+    -0.9106933,
+    -0.46838158
+  ],
+  [
+    "172",
+    1.1809835,
+    0.07788993,
+    -0.19239926
+  ],
+  [
+    "173",
+    0.38329834,
+    0.9107752,
+    -0.4057328
+  ],
+  [
+    "174",
+    0.6585081,
+    0.19358255,
+    0.70896614
+  ],
+  [
+    "175",
+    -1.0587527,
+    -0.7127123,
+    0.7602837
+  ],
+  [
+    "176",
+    -0.23210825,
+    0.5274143,
+    0.28309092
+  ],
+  [
+    "177",
+    1.3393708,
+    -0.4493064,
+    -0.4412903
+  ]
+]
\ No newline at end of file
diff --git a/data/metadata/metadata.json b/data/metadata/metadata.json
new file mode 100755
index 00000000..dcc3da08
--- /dev/null
+++ b/data/metadata/metadata.json
@@ -0,0 +1,3355 @@
+{
+  "Scene Capture and Reconstruction.md": {
+    "fileName": "Scene Capture and Reconstruction.md",
+    "fileSize": 12426,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 86,
+    "sha1": "0b21539e1df68d82a543aef926347dbf55a7ebe1",
+    "lastModified": "2025-02-15T16:12:15.435590380Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Apple": 2,
+      "Blender": 2,
+      "SLAM": 7,
+      "Gaussian splatting and Similar": 2
+    }
+  },
+  "Transformers.md": {
+    "fileName": "Transformers.md",
+    "fileSize": 2437,
+    "nodeSize": 26.933,
+    "hyperlinkCount": 5,
+    "sha1": "b2f0d608cd9dfe8305270612f07063e909eb9fa0",
+    "lastModified": "2025-02-15T16:12:47.186631332Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "OpenAI": 1,
+      "Transformers": 2
+    }
+  },
+  "Gaussian splatting and Similar.md": {
+    "fileName": "Gaussian splatting and Similar.md",
+    "fileSize": 7756,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 15,
+    "sha1": "8359eca4d53913b6ef6d8e537cd12afed9c2a69b",
+    "lastModified": "2025-02-15T16:10:01.561497027Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Text to 3D and 4D": 1,
+      "Transformers": 1,
+      "Scene Capture and Reconstruction": 1,
+      "Human tracking and SLAM capture": 1,
+      "Gaussian splatting and Similar": 7,
+      "SLAM": 8
+    }
+  },
+  "Layoff tracker and threatened roles.md": {
+    "fileName": "Layoff tracker and threatened roles.md",
+    "fileSize": 3408,
+    "nodeSize": 35.672,
+    "hyperlinkCount": 6,
+    "sha1": "41bce0decc00e5dbf9d0dd3004275157ce59b3e8",
+    "lastModified": "2025-02-15T16:10:37.639719073Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1
+    }
+  },
+  "Call Centres.md": {
+    "fileName": "Call Centres.md",
+    "fileSize": 23898,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 27,
+    "sha1": "0ab50f04ced83606b3f489360ebd7f3c56a906d8",
+    "lastModified": "2025-02-15T16:08:49.851526065Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Reasoning": 1,
+      "Artificial Intelligence": 2,
+      "Landscape": 1,
+      "Agents": 15,
+      "Interfaces": 1
+    }
+  },
+  "Metaverse Ontology.md": {
+    "fileName": "Metaverse Ontology.md",
+    "fileSize": 44869,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 12,
+    "sha1": "b63194e702dfa794f1529841ed9f0dc3632eda9e",
+    "lastModified": "2025-02-15T16:10:58.420515750Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Mixed reality": 1,
+      "NVIDIA Omniverse": 2,
+      "Large language models": 1,
+      "nostr": 16,
+      "Convergence": 2,
+      "infrastructure": 3,
+      "Agents": 15,
+      "Bitcoin": 16,
+      "Knowledge Graphing and RAG": 1,
+      "Cashu": 8,
+      "Money": 1,
+      "ChatGPT": 1,
+      "ecash": 8,
+      "Metaverse Ontology": 3,
+      "collaborative": 2,
+      "Agentic Mycelia": 1,
+      "RGB and Client Side Validation": 2,
+      "Gemini": 1,
+      "Semantic Web": 2,
+      "Anthropic Claude": 1,
+      "multimodal": 2,
+      "Blockchain": 7
+    }
+  },
+  "Controlnet and similar.md": {
+    "fileName": "Controlnet and similar.md",
+    "fileSize": 8004,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 3,
+    "sha1": "fdefdedc0ba6c22da4a94905e11fbae173813092",
+    "lastModified": "2025-02-15T16:09:05.893957305Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Stable Diffusion": 2,
+      "Diffusion Models": 4
+    }
+  },
+  "Decentralised Web.md": {
+    "fileName": "Decentralised Web.md",
+    "fileSize": 68332,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 116,
+    "sha1": "7a65ac69cb570feca301124dada1750772e4c1f4",
+    "lastModified": "2025-02-15T16:09:20.264883243Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Rust": 2,
+      "Distributed Identity": 4,
+      "Decentralised Web": 2,
+      "Landscape": 7,
+      "Tokenisation": 2,
+      "Apple": 2,
+      "Ethereum": 10,
+      "collaborative": 2,
+      "Agents": 2,
+      "license": 2,
+      "Gold": 1,
+      "Semantic Web": 8,
+      "nostr": 6,
+      "Bitcoin": 24,
+      "infrastructure": 4,
+      "Mixed reality": 1,
+      "Money": 12,
+      "Blockchain": 9
+    }
+  },
+  "AI Scrapers.md": {
+    "fileName": "AI Scrapers.md",
+    "fileSize": 3595,
+    "nodeSize": 37.355000000000004,
+    "hyperlinkCount": 6,
+    "sha1": "c40d851b73a53207c202885fb87f8a254c48e3d0",
+    "lastModified": "2025-02-15T16:08:10.325289187Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1,
+      "Knowledge Graphing and RAG": 1,
+      "Machine Learning": 1,
+      "AI Scrapers": 7,
+      "Privacy, Trust and Safety": 1
+    }
+  },
+  "Microsoft Work Trends Impact 2024.md": {
+    "fileName": "Microsoft Work Trends Impact 2024.md",
+    "fileSize": 7664,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "553423c8164077d6cb3f9abd1aec5b2956e108c3",
+    "lastModified": "2025-02-15T16:11:03.354476599Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Artificial Intelligence": 1
+    }
+  },
+  "NVIDIA Omniverse.md": {
+    "fileName": "NVIDIA Omniverse.md",
+    "fileSize": 8803,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "c75db8022df635790212415dd45912c4faf0627d",
+    "lastModified": "2025-02-15T16:11:14.628117500Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Blender": 7,
+      "Spatial Computing": 2,
+      "Interfaces": 1,
+      "collaborative": 2,
+      "NVIDIA Omniverse": 1
+    }
+  },
+  "Accessibility.md": {
+    "fileName": "Accessibility.md",
+    "fileSize": 17789,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 14,
+    "sha1": "4a73e2c254231436de5c0540a1864169f7b075bc",
+    "lastModified": "2025-02-15T16:08:17.847536999Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Accessibility": 63,
+      "Interfaces": 4,
+      "Machine Learning": 1,
+      "Llama": 2
+    }
+  },
+  "Agentic Alliance.md": {
+    "fileName": "Agentic Alliance.md",
+    "fileSize": 8731,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 3,
+    "sha1": "ceb39eb3f435bec4fdeca4f288c45bb0d53b0f3c",
+    "lastModified": "2025-02-15T16:08:21.238878106Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agentic Alliance": 2,
+      "nostr": 6,
+      "Agents": 8,
+      "Bitcoin": 6,
+      "Distributed Identity": 3
+    }
+  },
+  "Privacy, Trust and Safety.md": {
+    "fileName": "Privacy, Trust and Safety.md",
+    "fileSize": 20401,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 11,
+    "sha1": "edfbc5f7def1d610a1c4149d40963bdbca0e200e",
+    "lastModified": "2025-02-15T16:11:40.542109377Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1,
+      "Facebook Meta": 1,
+      "infrastructure": 3,
+      "Global Inequality": 1,
+      "nostr": 1,
+      "flossverse": 2,
+      "Conspiracies": 1,
+      "NVIDIA Omniverse": 1,
+      "collaborative": 1,
+      "Machine Learning": 1,
+      "Large language models": 1,
+      "Accessibility": 2,
+      "Digital Society Harms": 1,
+      "Landscape": 1,
+      "Llama": 1,
+      "Money": 2
+    }
+  },
+  "Digital Objects.md": {
+    "fileName": "Digital Objects.md",
+    "fileSize": 62939,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 132,
+    "sha1": "dca2c7ca0406854cc6314a6c307e82befc33cbe9",
+    "lastModified": "2025-02-15T16:09:30.116459541Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Digital Asset Risks": 1,
+      "Digital Objects": 4,
+      "nostr": 3,
+      "infrastructure": 1,
+      "Mixed reality": 2,
+      "license": 2,
+      "Ethereum": 19,
+      "Bitcoin": 37,
+      "collaborative": 2,
+      "Blockchain": 27,
+      "Money": 5,
+      "Landscape": 1
+    }
+  },
+  "Robotics.md": {
+    "fileName": "Robotics.md",
+    "fileSize": 1753,
+    "nodeSize": 20.776999999999997,
+    "hyperlinkCount": 10,
+    "sha1": "fb5790a6ec0327b53634a26c7579d6b3d9716c32",
+    "lastModified": "2025-02-15T16:12:05.773520935Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Robotics": 1,
+      "ChatGPT": 1
+    }
+  },
+  "Agents.md": {
+    "fileName": "Agents.md",
+    "fileSize": 5445,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 8,
+    "sha1": "fe1012e118dbebc31844f42e28f0f434ec741c16",
+    "lastModified": "2025-02-15T16:08:23.387552229Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Accessibility": 1,
+      "Agents": 24,
+      "ChatGPT": 1,
+      "OpenAI": 5,
+      "multimodal": 2,
+      "Reasoning": 2,
+      "Social contract and jobs": 1,
+      "Interfaces": 2,
+      "collaborative": 1,
+      "Microsoft CoPilot": 1
+    }
+  },
+  "AI privacy at the 2024 Olympics.md": {
+    "fileName": "AI privacy at the 2024 Olympics.md",
+    "fileSize": 8139,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 0,
+    "sha1": "83c457c54a6b1a1002b99c2925a3932566065000",
+    "lastModified": "2025-02-15T16:08:15.129064190Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "infrastructure": 2
+    }
+  },
+  "Depth Estimation.md": {
+    "fileName": "Depth Estimation.md",
+    "fileSize": 862,
+    "nodeSize": 12.758,
+    "hyperlinkCount": 3,
+    "sha1": "93ccc35608e3d73d3b8bef413ebfb6951a2f41bd",
+    "lastModified": "2025-02-15T16:09:27.127709700Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Depth Estimation": 3
+    }
+  },
+  "Digital Asset Risks.md": {
+    "fileName": "Digital Asset Risks.md",
+    "fileSize": 38439,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 44,
+    "sha1": "4b0855a9765e3cec9a09d4fe839d8d527307ad8f",
+    "lastModified": "2025-02-15T16:09:29.355707483Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Ethereum": 2,
+      "Stable Coins": 1,
+      "Money": 17,
+      "Blockchain": 3,
+      "Bitcoin": 72,
+      "Convergence": 1,
+      "Agents": 1,
+      "Bitcoin ETF": 1
+    }
+  },
+  "Proprietary AI Video.md": {
+    "fileName": "Proprietary AI Video.md",
+    "fileSize": 5154,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 4,
+    "sha1": "02045730ff4fd31d448cc16b1833d156e193ff8f",
+    "lastModified": "2025-02-15T16:11:45.451639030Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Transformers": 1,
+      "Deepmind": 1,
+      "AI Video": 2,
+      "latent space": 1,
+      "OpenAI": 5
+    }
+  },
+  "Social contract and jobs.md": {
+    "fileName": "Social contract and jobs.md",
+    "fileSize": 44932,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 71,
+    "sha1": "11a943ece9b32e32b194cc0cd95d09ee7c66498e",
+    "lastModified": "2025-02-15T16:12:21.095761947Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Cyber Security and Military": 1,
+      "Hyper personalisation": 1,
+      "Singularity": 1,
+      "Humans, Avatars , Character": 1,
+      "Money": 2,
+      "infrastructure": 1,
+      "Mixed reality": 1,
+      "Landscape": 4,
+      "Accessibility": 1,
+      "OpenAI": 4,
+      "Privacy, Trust and Safety": 1,
+      "Artificial Intelligence": 7,
+      "Layoff tracker and threatened roles": 2,
+      "AI Video": 1,
+      "Social contract and jobs": 15,
+      "ChatGPT": 4,
+      "Agents": 1,
+      "Deep Learning": 1,
+      "Robotics": 1,
+      "Llama": 1,
+      "Politics, Law, Privacy": 1
+    }
+  },
+  "Hyper personalisation.md": {
+    "fileName": "Hyper personalisation.md",
+    "fileSize": 3115,
+    "nodeSize": 33.035000000000004,
+    "hyperlinkCount": 1,
+    "sha1": "81e179362c4fd474c67104b9eb3fed70e733bdba",
+    "lastModified": "2025-02-15T16:10:18.978104130Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "infrastructure": 1,
+      "ChatGPT": 1,
+      "Stable Diffusion": 1,
+      "Large language models": 1
+    }
+  },
+  "State Space and Other Approaches.md": {
+    "fileName": "State Space and Other Approaches.md",
+    "fileSize": 28558,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 5,
+    "sha1": "8d9a5d9f6cf452e34f974cd4a6f21b3be285d210",
+    "lastModified": "2025-02-15T16:12:30.331744743Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Gemini": 2,
+      "Transformers": 17,
+      "infrastructure": 2,
+      "Artificial Intelligence": 1,
+      "Robotics": 1
+    }
+  },
+  "Vesuvian Scrolls.md": {
+    "fileName": "Vesuvian Scrolls.md",
+    "fileSize": 2741,
+    "nodeSize": 29.669,
+    "hyperlinkCount": 3,
+    "sha1": "68081aa4856d1e568aff2fc04622dba695a36b73",
+    "lastModified": "2025-02-15T16:12:56.550447659Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Debug Test Page.md": {
+    "fileName": "Debug Test Page.md",
+    "fileSize": 303,
+    "nodeSize": 7.727,
+    "hyperlinkCount": 0,
+    "sha1": "1e4f5b8e935780ed5ca723acc8d836ef2473a3bb",
+    "lastModified": "2025-02-15T16:09:19.542574920Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "debug linked node": 1,
+      "OpenAI": 1
+    }
+  },
+  "Comparison of SDXL and Midjourney v6.md": {
+    "fileName": "Comparison of SDXL and Midjourney v6.md",
+    "fileSize": 731,
+    "nodeSize": 11.578999999999999,
+    "hyperlinkCount": 7,
+    "sha1": "dae15fcc817642ee05550e389a1d9de4987a5f15",
+    "lastModified": "2025-02-15T16:09:00.266222054Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "BroBots.md": {
+    "fileName": "BroBots.md",
+    "fileSize": 351,
+    "nodeSize": 8.158999999999999,
+    "hyperlinkCount": 0,
+    "sha1": "bce4fb5a2e262d02c88d33ab2bb7487db0425779",
+    "lastModified": "2025-02-15T16:08:46.463795350Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Digital Society Harms": 1,
+      "Agents": 1,
+      "Llama": 1,
+      "Agentic Alliance": 1,
+      "Death of the Internet": 1,
+      "ollama": 1
+    }
+  },
+  "AnimateDiff.md": {
+    "fileName": "AnimateDiff.md",
+    "fileSize": 298,
+    "nodeSize": 7.682,
+    "hyperlinkCount": 1,
+    "sha1": "4925127460d01f5ee29b7f566b29b11f841bdd0c",
+    "lastModified": "2025-02-15T16:08:26.036348101Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "AnimateDiff": 1
+    }
+  },
+  "Deep Learning.md": {
+    "fileName": "Deep Learning.md",
+    "fileSize": 18831,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 0,
+    "sha1": "56f4b96b652143560c18c0129ce786622c91a856",
+    "lastModified": "2025-02-15T16:09:22.970285867Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Landscape": 2
+    }
+  },
+  "Open Generative AI tools.md": {
+    "fileName": "Open Generative AI tools.md",
+    "fileSize": 2630,
+    "nodeSize": 28.669999999999998,
+    "hyperlinkCount": 5,
+    "sha1": "fdab291f326cd1b0dc4268998f2c89e088ba6020",
+    "lastModified": "2025-02-15T16:11:19.533355410Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "ComfyUI": 1,
+      "Stable Diffusion": 1,
+      "Large language models": 1,
+      "Llama": 1,
+      "OpenAI": 2,
+      "Text to 3D and 4D": 1
+    }
+  },
+  "Convergence.md": {
+    "fileName": "Convergence.md",
+    "fileSize": 10595,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 2,
+    "sha1": "d9b6b97f4a72285712c15bb6dafa33af975bcded",
+    "lastModified": "2025-02-15T16:09:06.807701360Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 2,
+      "Singularity": 1,
+      "collaborative": 1,
+      "Mixed reality": 1,
+      "artificial superintelligence": 1,
+      "Spatial Computing": 3,
+      "Artificial Intelligence": 1,
+      "Convergence": 3,
+      "Landscape": 1,
+      "Interfaces": 3,
+      "Blockchain": 3,
+      "Digital Objects": 1,
+      "Bitcoin": 3
+    }
+  },
+  "debug linked node.md": {
+    "fileName": "debug linked node.md",
+    "fileSize": 63,
+    "nodeSize": 5.567,
+    "hyperlinkCount": 0,
+    "sha1": "d33bc80ce9d690c8c64301ce5346f36923791a44",
+    "lastModified": "2025-02-15T16:13:18.811983489Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Debug Test Page": 1
+    }
+  },
+  "Machine Learning.md": {
+    "fileName": "Machine Learning.md",
+    "fileSize": 13286,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 2,
+    "sha1": "7b913576c8bfd54db847194b7fd4954a4d278a81",
+    "lastModified": "2025-02-15T16:10:54.945571374Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 2,
+      "Gemini": 2,
+      "Llama": 2,
+      "Reasoning": 6,
+      "Machine Learning": 1,
+      "Accessibility": 1
+    }
+  },
+  "Proprietary Large Language Models.md": {
+    "fileName": "Proprietary Large Language Models.md",
+    "fileSize": 6317,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 9,
+    "sha1": "5e018d1e235c07b4add752d24c1349f73a95cac8",
+    "lastModified": "2025-02-15T16:11:47.429408415Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Prompt Engineering": 2,
+      "Microsoft CoPilot": 1,
+      "Proprietary Image Generation": 1,
+      "OpenAI": 9,
+      "Robotics": 1,
+      "Gemini": 3,
+      "Proprietary Large Language Models": 1,
+      "ChatGPT": 3,
+      "Large language models": 2,
+      "Agents": 3,
+      "artificial superintelligence": 1,
+      "multimodal": 2,
+      "AI Companies": 1,
+      "Landscape": 1,
+      "Artificial Intelligence": 1
+    }
+  },
+  "Courses and Training.md": {
+    "fileName": "Courses and Training.md",
+    "fileSize": 7329,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 39,
+    "sha1": "10708b433ab7959e67cb38abe013d41af9d05afb",
+    "lastModified": "2025-02-15T16:09:09.064051335Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "OpenAI": 2,
+      "Artificial Intelligence": 3,
+      "latent space": 2,
+      "Prompt Engineering": 7,
+      "Deep Learning": 3,
+      "ChatGPT": 4,
+      "Stable Diffusion": 1,
+      "Machine Learning": 5,
+      "Large language models": 2
+    }
+  },
+  "LoRA DoRA etc.md": {
+    "fileName": "LoRA DoRA etc.md",
+    "fileSize": 1519,
+    "nodeSize": 18.671,
+    "hyperlinkCount": 5,
+    "sha1": "f2ca6b16d5c13d756118bbaef014d35e338fa585",
+    "lastModified": "2025-02-15T16:10:48.006668500Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "LoRA DoRA etc": 2,
+      "Large language models": 2
+    }
+  },
+  "Llama.md": {
+    "fileName": "Llama.md",
+    "fileSize": 3432,
+    "nodeSize": 35.888,
+    "hyperlinkCount": 4,
+    "sha1": "17bedfd3acc866c641f2d5d5b0afea83475ca516",
+    "lastModified": "2025-02-15T16:10:47.270258004Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Accessibility": 1,
+      "Large language models": 1,
+      "Llama": 12,
+      "license": 5
+    }
+  },
+  "Music and audio.md": {
+    "fileName": "Music and audio.md",
+    "fileSize": 8182,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 28,
+    "sha1": "1d71d9318b31a0438bfbbeff31e5e9f9967bf760",
+    "lastModified": "2025-02-15T16:11:13.882813409Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "license": 1,
+      "Stable Diffusion": 1,
+      "Music and audio": 1,
+      "Deepmind": 2,
+      "Microsoft CoPilot": 1
+    }
+  },
+  "National Industrial Centre for Virtual Environments.md": {
+    "fileName": "National Industrial Centre for Virtual Environments.md",
+    "fileSize": 2721,
+    "nodeSize": 29.489,
+    "hyperlinkCount": 12,
+    "sha1": "871f25b09501b0b72b75d6c8547dc704169fe3e1",
+    "lastModified": "2025-02-15T16:11:16.090958164Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Research Tools.md": {
+    "fileName": "Research Tools.md",
+    "fileSize": 8185,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 8,
+    "sha1": "5ee11413b4e4ba0d6004ed2846bab5404581d0b0",
+    "lastModified": "2025-02-15T16:12:02.225944520Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Research Tools": 2,
+      "Reasoning": 4
+    }
+  },
+  "GANs.md": {
+    "fileName": "GANs.md",
+    "fileSize": 14,
+    "nodeSize": 5.126,
+    "hyperlinkCount": 0,
+    "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+    "lastModified": "2025-02-15T16:09:59.355581856Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Politics, Law, Privacy.md": {
+    "fileName": "Politics, Law, Privacy.md",
+    "fileSize": 33644,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 48,
+    "sha1": "ab6d364b607f0f088756f24ecb2c02919fb0c14f",
+    "lastModified": "2025-02-15T16:11:36.375248256Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Artificial Intelligence": 5,
+      "Distributed Identity": 1,
+      "Privacy, Trust and Safety": 2,
+      "Bitcoin": 2,
+      "Politics, Law, Privacy": 1,
+      "ChatGPT": 1,
+      "Blockchain": 3,
+      "Transformers": 1,
+      "Landscape": 3,
+      "Education and AI": 1,
+      "EU AI Act": 2,
+      "Accessibility": 3,
+      "license": 1,
+      "Money": 1,
+      "Large language models": 1
+    }
+  },
+  "Blockchain.md": {
+    "fileName": "Blockchain.md",
+    "fileSize": 15132,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 21,
+    "sha1": "5c0a8a95b0cb6348580015f65949f5d8caa6a048",
+    "lastModified": "2025-02-15T16:08:45.038036525Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Bitcoin": 15,
+      "infrastructure": 3,
+      "Bitcoin As Money": 1,
+      "Stable Coins": 1,
+      "Blockchain": 11,
+      "Bitcoin Technical Overview": 1,
+      "Agents": 2,
+      "Global Inequality": 1,
+      "ecash": 2,
+      "Digital Society Surveillance": 2,
+      "Agentic Metaverse for Global Creatives": 1,
+      "Money": 4,
+      "Interfaces": 1,
+      "Bitcoin Value Proposition": 2,
+      "Artificial Intelligence": 1,
+      "Deepfakes and fraudulent content": 1,
+      "Energy and Power": 1,
+      "Digital Asset Risks": 1,
+      "artificial superintelligence": 1,
+      "cypherpunk": 2,
+      "Agentic Mycelia": 1
+    }
+  },
+  "OpenAI.md": {
+    "fileName": "OpenAI.md",
+    "fileSize": 59,
+    "nodeSize": 5.531,
+    "hyperlinkCount": 0,
+    "sha1": "c57f67f385311e21f99ab67644e7255e55f527f8",
+    "lastModified": "2025-02-15T16:11:22.212485169Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Digital Society Surveillance.md": {
+    "fileName": "Digital Society Surveillance.md",
+    "fileSize": 52788,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 71,
+    "sha1": "6498fbb9ed954e41ab3fe2e12306de948e8a08ff",
+    "lastModified": "2025-02-15T16:09:32.175272225Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Artificial Intelligence": 1,
+      "ChatGPT": 1,
+      "Agents": 1,
+      "Bitcoin": 7,
+      "Money": 2,
+      "OpenAI": 4,
+      "Anthropic Claude": 1,
+      "infrastructure": 2,
+      "Ethereum": 1,
+      "Landscape": 1,
+      "Blockchain": 2,
+      "license": 1
+    }
+  },
+  "Spatial Computing.md": {
+    "fileName": "Spatial Computing.md",
+    "fileSize": 1826,
+    "nodeSize": 21.434,
+    "hyperlinkCount": 0,
+    "sha1": "d64ca32560b184a8eb58641bc7d75581719dd690",
+    "lastModified": "2025-02-15T16:12:25.359072746Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Spatial Computing": 11,
+      "infrastructure": 3,
+      "Robotics": 1
+    }
+  },
+  "Agentic Mycelia.md": {
+    "fileName": "Agentic Mycelia.md",
+    "fileSize": 28645,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 4,
+    "sha1": "eba2a13d1cdcf1381b9355cb6cdda602f7df7c63",
+    "lastModified": "2025-02-15T16:08:22.667701850Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Large language models": 2,
+      "Bitcoin": 4,
+      "Diagrams as Code": 3,
+      "Interfaces": 4,
+      "Agents": 29,
+      "nostr": 17,
+      "Gemini": 5,
+      "infrastructure": 3,
+      "Accessibility": 1,
+      "Agentic Mycelia": 7,
+      "Anthropic Claude": 1,
+      "Prompt Engineering": 1,
+      "Money": 1,
+      "Metaverse Ontology": 1
+    }
+  },
+  "Bitcoin.md": {
+    "fileName": "Bitcoin.md",
+    "fileSize": 97286,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 214,
+    "sha1": "6d06c8f8136a9e87b0d7cb31e76b8af8ede055c3",
+    "lastModified": "2025-02-15T16:08:42.966127363Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Cashu": 2,
+      "collaborative": 1,
+      "Politics, Law, Privacy": 1,
+      "nostr": 4,
+      "cypherpunk": 1,
+      "BTC Layer 3": 1,
+      "Bitcoin": 202,
+      "Money": 27,
+      "Stable Coins": 2,
+      "Bitcoin Technical Overview": 1,
+      "Landscape": 1,
+      "ecash": 2,
+      "infrastructure": 10,
+      "Blockchain": 14,
+      "Bitcoin ETF": 1,
+      "Gold": 4,
+      "Rust": 3,
+      "Digital Asset Risks": 1,
+      "flossverse": 1,
+      "Ethereum": 8
+    }
+  },
+  "Inpainting.md": {
+    "fileName": "Inpainting.md",
+    "fileSize": 59,
+    "nodeSize": 5.531,
+    "hyperlinkCount": 0,
+    "sha1": "c57f67f385311e21f99ab67644e7255e55f527f8",
+    "lastModified": "2025-02-15T16:10:22.504679687Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Mixed reality.md": {
+    "fileName": "Mixed reality.md",
+    "fileSize": 59923,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 87,
+    "sha1": "fe23c08d8a0f03137339f6ef778602fa3936667c",
+    "lastModified": "2025-02-15T16:11:06.870967751Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Vision Pro": 5,
+      "Ethereum": 1,
+      "ChatGPT": 1,
+      "Education and AI": 1,
+      "Virtual Production": 1,
+      "Blockchain": 15,
+      "Apple": 13,
+      "Humans, Avatars , Character": 1,
+      "Diffusion Models": 4,
+      "Mixed reality": 5,
+      "Blender": 6,
+      "Depth Estimation": 3,
+      "Large language models": 1,
+      "Interfaces": 1,
+      "Accessibility": 3,
+      "license": 5,
+      "Artificial Intelligence": 2,
+      "infrastructure": 4,
+      "Bitcoin": 1,
+      "Rust": 1,
+      "Machine Learning": 4,
+      "Convergence": 3,
+      "OpenAI": 1,
+      "Landscape": 2,
+      "Stable Diffusion": 6
+    }
+  },
+  "Tokenisation.md": {
+    "fileName": "Tokenisation.md",
+    "fileSize": 2570,
+    "nodeSize": 28.13,
+    "hyperlinkCount": 2,
+    "sha1": "5b5ba3f8cabcfa6cbe0dec028c4604bb2492e709",
+    "lastModified": "2025-02-15T16:12:45.706966568Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Money": 1,
+      "Tokenisation": 6,
+      "Blockchain": 1
+    }
+  },
+  "BTC Layer 3.md": {
+    "fileName": "BTC Layer 3.md",
+    "fileSize": 26265,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 35,
+    "sha1": "51393bdec64373a9e480c1bedaa0da3867d07876",
+    "lastModified": "2025-02-15T16:08:33.871454190Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "infrastructure": 1,
+      "Rust": 2,
+      "Bitcoin": 86,
+      "Blockchain": 12
+    }
+  },
+  "Facebook Meta.md": {
+    "fileName": "Facebook Meta.md",
+    "fileSize": 4010,
+    "nodeSize": 41.089999999999996,
+    "hyperlinkCount": 0,
+    "sha1": "3e69fe704332a5acd97ef2f7fe33316435746521",
+    "lastModified": "2025-02-15T16:09:51.664742754Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Reasoning": 1,
+      "Llama": 2
+    }
+  },
+  "AI Risks.md": {
+    "fileName": "AI Risks.md",
+    "fileSize": 5071,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 2,
+    "sha1": "fc156c54813de56f665ebad8fd26be1be2be5cda",
+    "lastModified": "2025-02-15T16:08:09.556088833Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Safety and alignment": 1,
+      "Death of the Internet": 1,
+      "Social contract and jobs": 1,
+      "Landscape": 1,
+      "Cyber Security and Military": 2,
+      "Cyber security and Cryptography": 1
+    }
+  },
+  "Introduction to me.md": {
+    "fileName": "Introduction to me.md",
+    "fileSize": 5006,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 12,
+    "sha1": "fac7bda18f6960d752787d0ee522eb84567f7729",
+    "lastModified": "2025-02-15T16:10:25.941391561Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Knowledge Graphing and RAG": 2,
+      "Singularity": 1,
+      "Agentic Alliance": 1,
+      "Money": 1,
+      "Bitcoin": 2,
+      "flossverse": 4,
+      "Interfaces": 1,
+      "Visionflow": 3,
+      "Social contract and jobs": 1,
+      "Recent Projects": 1,
+      "Convergence": 2
+    }
+  },
+  "Cyber security and Cryptography.md": {
+    "fileName": "Cyber security and Cryptography.md",
+    "fileSize": 16387,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 33,
+    "sha1": "ace29f98d0f2146bf80e622130e739488ce7ad10",
+    "lastModified": "2025-02-15T16:09:13.298803947Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Large language models": 3,
+      "ComfyUI": 2,
+      "infrastructure": 2,
+      "Landscape": 1,
+      "AI Risks": 1,
+      "Jailbreaking": 4,
+      "license": 2,
+      "Artificial Intelligence": 4,
+      "OpenAI": 5,
+      "Open Generative AI tools": 2,
+      "Stable Diffusion": 8,
+      "Machine Learning": 9,
+      "ChatGPT": 5,
+      "Gemini": 3,
+      "Cyber security and Cryptography": 1
+    }
+  },
+  "license.md": {
+    "fileName": "license.md",
+    "fileSize": 356,
+    "nodeSize": 8.204,
+    "hyperlinkCount": 4,
+    "sha1": "4443a3aff6398c220a624c669be78218a91f796f",
+    "lastModified": "2025-02-15T16:13:33.724017802Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Landscape.md": {
+    "fileName": "Landscape.md",
+    "fileSize": 308,
+    "nodeSize": 7.772,
+    "hyperlinkCount": 2,
+    "sha1": "89a1ba3cd3894d3c820e7d8a42ce7a0deef1346d",
+    "lastModified": "2025-02-15T16:10:34.176721811Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Landscape": 3
+    }
+  },
+  "Virtual Production.md": {
+    "fileName": "Virtual Production.md",
+    "fileSize": 2609,
+    "nodeSize": 28.481,
+    "hyperlinkCount": 6,
+    "sha1": "f9f234812f66506b78e20ef08ce993a37fabb292",
+    "lastModified": "2025-02-15T16:13:00.019129649Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Virtual Production": 4,
+      "Mixed reality": 1,
+      "Interfaces": 1,
+      "collaborative": 1,
+      "Accessibility": 3
+    }
+  },
+  "Base models.md": {
+    "fileName": "Base models.md",
+    "fileSize": 84942,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "698dff0c0889c174e01a4d09544f176c2a7edd22",
+    "lastModified": "2025-02-15T16:08:36.535334852Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Machine Learning": 8,
+      "Stable Diffusion": 9,
+      "Landscape": 1,
+      "license": 11,
+      "Llama": 30,
+      "Diffusion Models": 7,
+      "Transformers": 7,
+      "Accessibility": 2,
+      "Base models": 1,
+      "Depth Estimation": 1,
+      "OpenAI": 12,
+      "multimodal": 4,
+      "Prompt Engineering": 4,
+      "Money": 1,
+      "Reasoning": 1,
+      "Large language models": 8,
+      "Inpainting": 3,
+      "Deep Learning": 6,
+      "Artificial Intelligence": 3,
+      "Apple": 2,
+      "ChatGPT": 21
+    }
+  },
+  "p(doom).md": {
+    "fileName": "p(doom).md",
+    "fileSize": 556,
+    "nodeSize": 10.004000000000001,
+    "hyperlinkCount": 0,
+    "sha1": "4bcd6cb13573f66ddaf86100d979acd006520f0c",
+    "lastModified": "2025-02-15T16:13:43.182746217Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Automated Podcast Project.md": {
+    "fileName": "Automated Podcast Project.md",
+    "fileSize": 10866,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "7f2b6e7a9d0ee3e2ea7ed7aff67d22ceae6180c4",
+    "lastModified": "2025-02-15T16:08:33.168468016Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1
+    }
+  },
+  "Global Inequality.md": {
+    "fileName": "Global Inequality.md",
+    "fileSize": 35143,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 11,
+    "sha1": "5436bf1482d2b5e597e60cf92aafaffbb4915bf0",
+    "lastModified": "2025-02-15T16:10:05.108073687Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Money": 9,
+      "Landscape": 1,
+      "Artificial Intelligence": 1,
+      "Blockchain": 2,
+      "Stable Coins": 1,
+      "license": 1,
+      "infrastructure": 1
+    }
+  },
+  "Proprietary Video.md": {
+    "fileName": "Proprietary Video.md",
+    "fileSize": 6701,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 17,
+    "sha1": "40e0eafbd4bdd8079761b3e807030f4934093222",
+    "lastModified": "2025-02-15T16:11:48.156871075Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Virtual Production": 3,
+      "AI Video": 4,
+      "NVIDIA Omniverse": 1,
+      "flossverse": 2,
+      "Open Generative AI tools": 1
+    }
+  },
+  "Papers Of Note.md": {
+    "fileName": "Papers Of Note.md",
+    "fileSize": 119797,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 478,
+    "sha1": "5b327c4178037b4f6eacfd45d7b350497135941d",
+    "lastModified": "2025-02-15T16:11:28.678166519Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Jailbreaking": 1,
+      "Agents": 3,
+      "Large language models": 61,
+      "Llama": 12,
+      "Reasoning": 18,
+      "Transformers": 17,
+      "multimodal": 22,
+      "OpenAI": 1,
+      "Parametric": 1,
+      "Diffusion Models": 4,
+      "Machine Learning": 1,
+      "Apple": 1,
+      "Gemini": 2,
+      "Prompt Engineering": 3
+    }
+  },
+  "Time Series Forecasting.md": {
+    "fileName": "Time Series Forecasting.md",
+    "fileSize": 865,
+    "nodeSize": 12.785,
+    "hyperlinkCount": 5,
+    "sha1": "d1712dadeb12099575ad272cd845ee9d6a24fcad",
+    "lastModified": "2025-02-15T16:12:43.701766057Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Time Series Forecasting": 2,
+      "Transformers": 2,
+      "Llama": 2
+    }
+  },
+  "multimodal.md": {
+    "fileName": "multimodal.md",
+    "fileSize": 4601,
+    "nodeSize": 46.409,
+    "hyperlinkCount": 12,
+    "sha1": "b47a1d2ce1b2295a7b830bc6c223b667c4bd6fc4",
+    "lastModified": "2025-02-15T16:13:38.240059381Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Apple": 4,
+      "Large language models": 3,
+      "multimodal": 4,
+      "Transformers": 1,
+      "latent space": 1,
+      "OpenAI": 1,
+      "Gemini": 3,
+      "Deepmind": 1,
+      "ChatGPT": 1
+    }
+  },
+  "Semantic Web.md": {
+    "fileName": "Semantic Web.md",
+    "fileSize": 15524,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 5,
+    "sha1": "8c26c2cbc21a0b22630ca576d766390a9bd851ce",
+    "lastModified": "2025-02-15T16:12:17.650758345Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Large language models": 3,
+      "Agents": 1,
+      "Bitcoin": 1,
+      "nostr": 1,
+      "Apple": 1,
+      "Transformers": 1,
+      "Reasoning": 8,
+      "infrastructure": 1,
+      "Blockchain": 3,
+      "Semantic Web": 9
+    }
+  },
+  "Large language models.md": {
+    "fileName": "Large language models.md",
+    "fileSize": 63087,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 192,
+    "sha1": "dd952178ab8d4ea5d4be12320beb66ceec672264",
+    "lastModified": "2025-02-15T16:10:35.646324435Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Interfaces": 9,
+      "Reasoning": 2,
+      "multimodal": 5,
+      "Diffusion Models": 1,
+      "collaborative": 2,
+      "OpenAI": 10,
+      "Deep Learning": 15,
+      "Transformers": 2,
+      "ChatGPT": 19,
+      "Llama": 7,
+      "Digital Objects": 1,
+      "Prompt Engineering": 1,
+      "Artificial Intelligence": 3,
+      "Accessibility": 2,
+      "license": 2,
+      "Large language models": 15,
+      "infrastructure": 3,
+      "Machine Learning": 2,
+      "Base models": 1
+    }
+  },
+  "Haptics.md": {
+    "fileName": "Haptics.md",
+    "fileSize": 16,
+    "nodeSize": 5.144,
+    "hyperlinkCount": 0,
+    "sha1": "b729c028abdf7b08d903806bd908f8f5ec382581",
+    "lastModified": "2025-02-15T16:10:11.347235432Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Human vs AI.md": {
+    "fileName": "Human vs AI.md",
+    "fileSize": 5108,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 2,
+    "sha1": "b58000500c57498c0185bae55711f3c39a6e4b80",
+    "lastModified": "2025-02-15T16:10:16.347956259Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Landscape": 1
+    }
+  },
+  "Procedural and Hybrid 4D.md": {
+    "fileName": "Procedural and Hybrid 4D.md",
+    "fileSize": 61,
+    "nodeSize": 5.549,
+    "hyperlinkCount": 1,
+    "sha1": "acdf93b3d0575cfa737136aace02dff3c6c015e9",
+    "lastModified": "2025-02-15T16:11:41.278603964Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Vision Pro.md": {
+    "fileName": "Vision Pro.md",
+    "fileSize": 2841,
+    "nodeSize": 30.569000000000003,
+    "hyperlinkCount": 2,
+    "sha1": "4f24bd713c8a82f0ee7a3867f0dfd4e265fb2a1e",
+    "lastModified": "2025-02-15T16:13:00.750940304Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Apple": 3,
+      "Money": 1,
+      "Vision Pro": 2
+    }
+  },
+  "Blender.md": {
+    "fileName": "Blender.md",
+    "fileSize": 168,
+    "nodeSize": 6.5120000000000005,
+    "hyperlinkCount": 0,
+    "sha1": "0df1342462b955899508959a47cfca64c8a28048",
+    "lastModified": "2025-02-15T16:08:43.801202951Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Text to 3D and 4D": 1
+    }
+  },
+  "Apple.md": {
+    "fileName": "Apple.md",
+    "fileSize": 9598,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 6,
+    "sha1": "87a7b91113b19f4a322190d329bc8e30aa366200",
+    "lastModified": "2025-02-15T16:08:29.030374909Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Apple": 27,
+      "Gaussian splatting and Similar": 1,
+      "Hardware and Edge": 2,
+      "OpenAI": 4,
+      "Large language models": 1,
+      "infrastructure": 1,
+      "Machine Learning": 2,
+      "legacy media": 1,
+      "Money": 1,
+      "ChatGPT": 2
+    }
+  },
+  "Comfy UI for Fashion and Brands.md": {
+    "fileName": "Comfy UI for Fashion and Brands.md",
+    "fileSize": 11244,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 22,
+    "sha1": "7384b47977d8ab00d025bfaecb493c12a246b74b",
+    "lastModified": "2025-02-15T16:08:56.125990767Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Llama": 2,
+      "ComfyUI": 24,
+      "license": 1,
+      "ollama": 6,
+      "Diffusion Models": 2,
+      "infrastructure": 1,
+      "Apple": 2,
+      "IPAdapter": 1,
+      "Overview of Machine Learning Techniques": 1,
+      "Machine Learning": 1,
+      "Product Design": 1
+    }
+  },
+  "RGB and Client Side Validation.md": {
+    "fileName": "RGB and Client Side Validation.md",
+    "fileSize": 8861,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 29,
+    "sha1": "daa7038a18ff53c3e567f440755a67b51ab9a370",
+    "lastModified": "2025-02-15T16:11:57.293154399Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Bitcoin": 5,
+      "Blockchain": 2,
+      "Interfaces": 7,
+      "Rust": 6
+    }
+  },
+  "Calculating Empires.md": {
+    "fileName": "Calculating Empires.md",
+    "fileSize": 2064,
+    "nodeSize": 23.576,
+    "hyperlinkCount": 5,
+    "sha1": "ab61c3b4fec2962cb8ce3ecde187d9650cc0117e",
+    "lastModified": "2025-02-15T16:08:47.908344612Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Interfaces": 1,
+      "Cyber Security and Military": 1,
+      "Education and AI": 1,
+      "Flux": 1,
+      "Calculating Empires": 2,
+      "Politics, Law, Privacy": 1,
+      "Artificial Intelligence": 1,
+      "Digital Society Surveillance": 1
+    }
+  },
+  "Energy and Power.md": {
+    "fileName": "Energy and Power.md",
+    "fileSize": 26099,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 59,
+    "sha1": "af993f160d3f02d60e4ad699373e8dd26258829b",
+    "lastModified": "2025-02-15T16:09:43.223594051Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Energy and Power": 1,
+      "Blockchain": 3,
+      "Gold": 2,
+      "Convergence": 1,
+      "Bitcoin": 72,
+      "Money": 7,
+      "infrastructure": 8,
+      "Artificial Intelligence": 1
+    }
+  },
+  "Deepfakes and fraudulent content.md": {
+    "fileName": "Deepfakes and fraudulent content.md",
+    "fileSize": 1457,
+    "nodeSize": 18.113,
+    "hyperlinkCount": 8,
+    "sha1": "3647f419f6285abdc0a5313bf8375a5df40bd68d",
+    "lastModified": "2025-02-15T16:09:23.689444291Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1,
+      "Cyber security and Cryptography": 1
+    }
+  },
+  "Humans, Avatars , Character.md": {
+    "fileName": "Humans, Avatars , Character.md",
+    "fileSize": 14756,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 71,
+    "sha1": "9487a7196405682044523f72286aa7599d279d1d",
+    "lastModified": "2025-02-15T16:10:17.488159103Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "GANs": 1,
+      "Landscape": 1,
+      "SLAM": 2,
+      "Stable Diffusion": 2,
+      "AI Video": 1,
+      "Human tracking and SLAM capture": 2,
+      "ComfyUI": 8,
+      "Singularity": 1
+    }
+  },
+  "Segmentation and Identification.md": {
+    "fileName": "Segmentation and Identification.md",
+    "fileSize": 6843,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 24,
+    "sha1": "e480903264d84b2b44a81f74f0610b9dd34e1bf0",
+    "lastModified": "2025-02-15T16:12:16.925793627Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "SLAM": 1,
+      "Segmentation and Identification": 9,
+      "Llama": 2,
+      "Product Design": 2,
+      "Hardware and Edge": 1,
+      "license": 1,
+      "Inpainting": 1,
+      "Transformers": 1,
+      "Large language models": 1,
+      "Human tracking and SLAM capture": 1,
+      "AI Video": 1,
+      "Depth Estimation": 1
+    }
+  },
+  "EU AI Act.md": {
+    "fileName": "EU AI Act.md",
+    "fileSize": 3083,
+    "nodeSize": 32.747,
+    "hyperlinkCount": 3,
+    "sha1": "8011544e9477ea2abff18e4ef87491413610bb83",
+    "lastModified": "2025-02-15T16:09:37.110117398Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Diagrams as Code.md": {
+    "fileName": "Diagrams as Code.md",
+    "fileSize": 19571,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 21,
+    "sha1": "b0b33a7a5a3673e8dc88905b52611c54628c2379",
+    "lastModified": "2025-02-15T16:09:27.886915334Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Transformers": 4,
+      "Agents": 11,
+      "NVIDIA Omniverse": 1,
+      "Accessibility": 1,
+      "Gemini": 1,
+      "Bitcoin": 6,
+      "Virtual Production": 2,
+      "nostr": 6,
+      "Cashu": 1,
+      "Stable Diffusion": 2,
+      "Prompt Engineering": 1,
+      "Blockchain": 4,
+      "GANs": 4,
+      "OpenAI": 2,
+      "Spatial Computing": 1
+    }
+  },
+  "Cyber Security and Military.md": {
+    "fileName": "Cyber Security and Military.md",
+    "fileSize": 7660,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 5,
+    "sha1": "0d77069c4652291b0b72eba82c76b348a98f5e6c",
+    "lastModified": "2025-02-15T16:09:12.521706348Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Landscape": 1,
+      "Machine Learning": 1,
+      "Large language models": 2,
+      "Accessibility": 1,
+      "OpenAI": 2,
+      "Money": 1,
+      "infrastructure": 2
+    }
+  },
+  "Stable Diffusion.md": {
+    "fileName": "Stable Diffusion.md",
+    "fileSize": 37561,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 204,
+    "sha1": "e6835717a41c00c21b58e1f628a418bce502249e",
+    "lastModified": "2025-02-15T16:12:29.570774420Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Inpainting": 2,
+      "Stable Diffusion": 48,
+      "ComfyUI": 5,
+      "Controlnet and similar": 1,
+      "Interfaces": 3,
+      "Machine Learning": 2,
+      "Artificial Intelligence": 2,
+      "Diffusion Models": 5,
+      "collaborative": 1,
+      "ChatGPT": 1,
+      "Transformers": 1,
+      "Landscape": 1,
+      "AI Video": 1,
+      "OpenAI": 1,
+      "Blender": 2,
+      "AnimateDiff": 2,
+      "LoRA DoRA etc": 1,
+      "Prompt Engineering": 4,
+      "AI Companies": 1
+    }
+  },
+  "Bitcoin As Money.md": {
+    "fileName": "Bitcoin As Money.md",
+    "fileSize": 18467,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 23,
+    "sha1": "857a8a3444a7eb88d4ece3ba31fa427a953d16da",
+    "lastModified": "2025-02-15T16:08:37.981321291Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "infrastructure": 1,
+      "Stable Coins": 1,
+      "Money": 61,
+      "Gold": 4,
+      "Blockchain": 2,
+      "Bitcoin": 52,
+      "Accessibility": 1
+    }
+  },
+  "Product Design.md": {
+    "fileName": "Product Design.md",
+    "fileSize": 81911,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 12,
+    "sha1": "22ffc2508d3dcbf8d8dc01faeebd565744d2d489",
+    "lastModified": "2025-02-15T16:11:42.535919767Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Digital Objects": 5,
+      "Agents": 32,
+      "infrastructure": 20,
+      "Stable Diffusion": 6,
+      "Prompt Engineering": 1,
+      "Large language models": 2,
+      "Vision Pro": 1,
+      "ecash": 1,
+      "Cashu": 1,
+      "Machine Learning": 9,
+      "Mixed reality": 8,
+      "Knowhere": 3,
+      "Blockchain": 6,
+      "collaborative": 24,
+      "NVIDIA Omniverse": 1,
+      "Money": 8,
+      "ChatGPT": 3,
+      "Visionflow": 14,
+      "flossverse": 4,
+      "Accessibility": 9,
+      "Interfaces": 4,
+      "Virtual Production": 13,
+      "Apple": 1,
+      "Robotics": 2,
+      "Bitcoin": 19,
+      "Landscape": 6,
+      "nostr": 29,
+      "Gemini": 1
+    }
+  },
+  "Visionflow.md": {
+    "fileName": "Visionflow.md",
+    "fileSize": 5188,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "6adb7b439a04e51b13d9829d9a7deed97a8a9c50",
+    "lastModified": "2025-02-15T16:13:02.029776447Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "flossverse": 2,
+      "Machine Learning": 2,
+      "Landscape": 1,
+      "Virtual Production": 11,
+      "Visionflow": 5,
+      "Robotics": 4
+    }
+  },
+  "Diffusion Models.md": {
+    "fileName": "Diffusion Models.md",
+    "fileSize": 14,
+    "nodeSize": 5.126,
+    "hyperlinkCount": 0,
+    "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+    "lastModified": "2025-02-15T16:09:28.633189955Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Model Optimisation and Performance.md": {
+    "fileName": "Model Optimisation and Performance.md",
+    "fileSize": 10270,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 17,
+    "sha1": "ea57b42268867df3930c1c25869b5cd10e8a79db",
+    "lastModified": "2025-02-15T16:11:08.337700305Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Reasoning": 3,
+      "Transformers": 1,
+      "Large language models": 2,
+      "Machine Learning": 3
+    }
+  },
+  "Geopolitical hot takes.md": {
+    "fileName": "Geopolitical hot takes.md",
+    "fileSize": 15425,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 0,
+    "sha1": "cbf1b708951e324b173b654c2a398075b514bdc2",
+    "lastModified": "2025-02-15T16:10:04.376057503Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "infrastructure": 10
+    }
+  },
+  "Interfaces.md": {
+    "fileName": "Interfaces.md",
+    "fileSize": 5576,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 20,
+    "sha1": "cbf3df4603ca76633ebeb70927ac2193ed85d06d",
+    "lastModified": "2025-02-15T16:10:25.198133670Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Diffusion Models": 1,
+      "ComfyUI": 1,
+      "infrastructure": 1,
+      "Llama": 6,
+      "Large language models": 3,
+      "Hardware and Edge": 1,
+      "Agents": 1,
+      "OpenAI": 2,
+      "ChatGPT": 1,
+      "multimodal": 5,
+      "Interfaces": 4,
+      "Stable Diffusion": 1
+    }
+  },
+  "Product and Risk Management.md": {
+    "fileName": "Product and Risk Management.md",
+    "fileSize": 4320,
+    "nodeSize": 43.88,
+    "hyperlinkCount": 2,
+    "sha1": "dcbee3ca4172ec238ef137ced777ec66b223ee49",
+    "lastModified": "2025-02-15T16:11:43.259750170Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Politics, Law, Privacy": 1,
+      "Product Design": 1,
+      "Landscape": 1,
+      "infrastructure": 1,
+      "Safety and alignment": 1,
+      "Machine Learning": 1
+    }
+  },
+  "Evaluation benchmarks and leaderboards.md": {
+    "fileName": "Evaluation benchmarks and leaderboards.md",
+    "fileSize": 1148,
+    "nodeSize": 15.331999999999999,
+    "hyperlinkCount": 11,
+    "sha1": "abe179288d5847d0574dc559988a202c5b12442a",
+    "lastModified": "2025-02-15T16:09:45.921587518Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Hardware and Edge.md": {
+    "fileName": "Hardware and Edge.md",
+    "fileSize": 32615,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 70,
+    "sha1": "c2a9767c9ac8040522a7f6af45bc343f7072f7dc",
+    "lastModified": "2025-02-15T16:10:12.099057661Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Transformers": 2,
+      "Mixed reality": 2,
+      "Landscape": 1,
+      "Llama": 6,
+      "Digital Objects": 1,
+      "Interfaces": 7,
+      "Hardware and Edge": 2,
+      "Machine Learning": 1,
+      "Vision Pro": 1,
+      "Proprietary Large Language Models": 1,
+      "Apple": 7,
+      "ollama": 6,
+      "ChatGPT": 4,
+      "OpenAI": 2,
+      "Money": 1,
+      "Spatial Computing": 2,
+      "Stable Diffusion": 1,
+      "Artificial Intelligence": 2,
+      "Large language models": 3
+    }
+  },
+  "ollama.md": {
+    "fileName": "ollama.md",
+    "fileSize": 1924,
+    "nodeSize": 22.316,
+    "hyperlinkCount": 6,
+    "sha1": "6b576d3460d1633e9623990ebbe8adb4f2d596ba",
+    "lastModified": "2025-02-15T16:13:42.433099358Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1,
+      "OpenAI": 1,
+      "Knowledge Graphing and RAG": 1,
+      "Llama": 2,
+      "ollama": 7,
+      "Prompt Engineering": 1,
+      "Large language models": 1,
+      "ComfyUI": 3
+    }
+  },
+  "Bitcoin Value Proposition.md": {
+    "fileName": "Bitcoin Value Proposition.md",
+    "fileSize": 53300,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 24,
+    "sha1": "e8ae399e02acdaae009b6c3a4777156d4cedf80d",
+    "lastModified": "2025-02-15T16:08:41.410244845Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1,
+      "Money": 12,
+      "Blockchain": 5,
+      "RGB and Client Side Validation": 1,
+      "infrastructure": 6,
+      "Cashu": 1,
+      "Ethereum": 3,
+      "Gold": 9,
+      "collaborative": 1,
+      "Bitcoin": 186,
+      "Accessibility": 1,
+      "Convergence": 1,
+      "Mixed reality": 1,
+      "Landscape": 3
+    }
+  },
+  "Adoption of Convergent Technologies.md": {
+    "fileName": "Adoption of Convergent Technologies.md",
+    "fileSize": 20064,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 46,
+    "sha1": "2c9159b57ab3151511a44b3eae989aff94ed9ca0",
+    "lastModified": "2025-02-15T16:08:19.295150706Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Blockchain": 2,
+      "OpenAI": 1,
+      "Bitcoin": 17,
+      "Microsoft Work Trends Impact 2024": 1,
+      "Gemini": 1,
+      "ChatGPT": 1,
+      "Money": 1
+    }
+  },
+  "relighting.md": {
+    "fileName": "relighting.md",
+    "fileSize": 1368,
+    "nodeSize": 17.312,
+    "hyperlinkCount": 8,
+    "sha1": "a24ca5fed1ec96c1e33cd6199964eb152077dc3a",
+    "lastModified": "2025-02-15T16:13:45.174176857Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "AI Video": 1,
+      "relighting": 14,
+      "ComfyUI": 3,
+      "Apple": 4
+    }
+  },
+  "Bitcoin ETF.md": {
+    "fileName": "Bitcoin ETF.md",
+    "fileSize": 6185,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 2,
+    "sha1": "d19a4e9a7d54f3278dd7a1432916260efd1e833e",
+    "lastModified": "2025-02-15T16:08:38.701106780Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Bitcoin": 31,
+      "Bitcoin ETF": 1,
+      "Money": 1
+    }
+  },
+  "artificial superintelligence.md": {
+    "fileName": "artificial superintelligence.md",
+    "fileSize": 2628,
+    "nodeSize": 28.652,
+    "hyperlinkCount": 6,
+    "sha1": "1d0c2ef96a2fd56a69ab6036b1fa7e1d348e4259",
+    "lastModified": "2025-02-15T16:13:11.169885397Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "OpenAI": 2
+    }
+  },
+  "cypherpunk.md": {
+    "fileName": "cypherpunk.md",
+    "fileSize": 5430,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 3,
+    "sha1": "7dcc1520963f17ce76ce5431643f30f8bc65945c",
+    "lastModified": "2025-02-15T16:13:17.547033376Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "cypherpunk": 5,
+      "Money": 1
+    }
+  },
+  "nostr.md": {
+    "fileName": "nostr.md",
+    "fileSize": 41170,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 31,
+    "sha1": "d86ac5484f8006122b60f43c3355e07b484b3313",
+    "lastModified": "2025-02-15T16:13:41.696878030Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 2,
+      "Digital Objects": 7,
+      "Landscape": 1,
+      "Distributed Identity": 2,
+      "infrastructure": 4,
+      "Mixed reality": 1,
+      "collaborative": 2,
+      "nostr": 134,
+      "Bitcoin": 14,
+      "Accessibility": 1
+    }
+  },
+  "Gemini.md": {
+    "fileName": "Gemini.md",
+    "fileSize": 1958,
+    "nodeSize": 22.622,
+    "hyperlinkCount": 7,
+    "sha1": "3f9377a187137c61808cacf852367e19c785cf4a",
+    "lastModified": "2025-02-15T16:10:02.828534683Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Gemini": 10,
+      "Deepmind": 1,
+      "Llama": 1
+    }
+  },
+  "Gold.md": {
+    "fileName": "Gold.md",
+    "fileSize": 5494,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 2,
+    "sha1": "335a427e3d14b167293ad21087ff24500f64c4f6",
+    "lastModified": "2025-02-15T16:10:05.855617981Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Gold": 30
+    }
+  },
+  "Money.md": {
+    "fileName": "Money.md",
+    "fileSize": 85818,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 79,
+    "sha1": "976d46eeeef05fac30fb8423dc8ecf8f5af1cc1b",
+    "lastModified": "2025-02-15T16:11:11.147875345Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Gemini": 1,
+      "infrastructure": 5,
+      "Convergence": 1,
+      "Bitcoin": 23,
+      "Apple": 9,
+      "Money": 128,
+      "Ethereum": 5,
+      "Blockchain": 8,
+      "Stable Coins": 1,
+      "collaborative": 1,
+      "Landscape": 3,
+      "Gold": 8
+    }
+  },
+  "infrastructure.md": {
+    "fileName": "infrastructure.md",
+    "fileSize": 5571,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 9,
+    "sha1": "83ead488680945dbe08a356b008dbcee6000f990",
+    "lastModified": "2025-02-15T16:13:28.783870693Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Money": 2,
+      "Privacy, Trust and Safety": 1
+    }
+  },
+  "legacy media.md": {
+    "fileName": "legacy media.md",
+    "fileSize": 355,
+    "nodeSize": 8.195,
+    "hyperlinkCount": 2,
+    "sha1": "0aacca2e2a9a74108599260b3f8a08316b9d9aa0",
+    "lastModified": "2025-02-15T16:13:32.982191741Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Artificial Intelligence": 1
+    }
+  },
+  "Prompt Engineering.md": {
+    "fileName": "Prompt Engineering.md",
+    "fileSize": 33404,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 68,
+    "sha1": "0d7b1fd8f9acf47e96641a3ab34fd5d107a71eaf",
+    "lastModified": "2025-02-15T16:11:44.724314374Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Apple": 2,
+      "OpenAI": 9,
+      "multimodal": 1,
+      "Courses and Training": 2,
+      "Diffusion Models": 3,
+      "Diagrams as Code": 3,
+      "Evaluation benchmarks and leaderboards": 1,
+      "Llama": 4,
+      "Prompt Engineering": 60,
+      "Reasoning": 6,
+      "ChatGPT": 19,
+      "Large language models": 15,
+      "Gold": 3,
+      "AI Video": 2,
+      "Anthropic Claude": 1,
+      "artificial superintelligence": 1,
+      "ollama": 4,
+      "Stable Diffusion": 2,
+      "Model Optimisation and Performance": 1,
+      "Training and fine tuning": 1,
+      "ComfyUI": 17,
+      "Adoption of Convergent Technologies": 1,
+      "Artificial Intelligence": 1
+    }
+  },
+  "Proprietary Image Generation.md": {
+    "fileName": "Proprietary Image Generation.md",
+    "fileSize": 3077,
+    "nodeSize": 32.693,
+    "hyperlinkCount": 9,
+    "sha1": "5801d9feea43c5f3f231bc5108f3054a777937fb",
+    "lastModified": "2025-02-15T16:11:46.684507556Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "OpenAI": 1,
+      "ChatGPT": 5,
+      "Landscape": 1,
+      "Proprietary Video": 1
+    }
+  },
+  "Reasoning.md": {
+    "fileName": "Reasoning.md",
+    "fileSize": 2937,
+    "nodeSize": 31.433,
+    "hyperlinkCount": 4,
+    "sha1": "d4905c447b0816f0aa649309ecead65686bd51c6",
+    "lastModified": "2025-02-15T16:11:59.992686805Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Large language models": 1,
+      "Reasoning": 11
+    }
+  },
+  "Speech and voice.md": {
+    "fileName": "Speech and voice.md",
+    "fileSize": 13439,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 43,
+    "sha1": "12af93d19c15bd4210789c0ead6e5d40f70fa902",
+    "lastModified": "2025-02-15T16:12:26.828227281Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "OpenAI": 5,
+      "Large language models": 2,
+      "Social contract and jobs": 1,
+      "Speech and voice": 11,
+      "Agents": 1,
+      "ChatGPT": 6,
+      "license": 1,
+      "Artificial Intelligence": 1,
+      "Product Design": 1,
+      "AI Companies": 1,
+      "NVIDIA Omniverse": 1,
+      "Accessibility": 1
+    }
+  },
+  "Definitions and frameworks for Metaverse.md": {
+    "fileName": "Definitions and frameworks for Metaverse.md",
+    "fileSize": 48177,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 43,
+    "sha1": "6d56ab61e4410d87a12d67ffebc2ee03ddf7ae2c",
+    "lastModified": "2025-02-15T16:09:25.151720860Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Bitcoin": 2,
+      "Machine Learning": 1,
+      "Metaverse Ontology": 1,
+      "multimodal": 1,
+      "OpenAI": 1,
+      "Mixed reality": 6,
+      "Money": 5,
+      "Blockchain": 1,
+      "Spatial Computing": 2,
+      "Agents": 3,
+      "infrastructure": 2,
+      "Landscape": 1,
+      "collaborative": 4,
+      "Ethereum": 1,
+      "Digital Objects": 2,
+      "Convergence": 2,
+      "license": 2,
+      "Vision Pro": 1,
+      "Apple": 7
+    }
+  },
+  "Lead Poisoning Hypothesis.md": {
+    "fileName": "Lead Poisoning Hypothesis.md",
+    "fileSize": 3998,
+    "nodeSize": 40.982,
+    "hyperlinkCount": 1,
+    "sha1": "ac2e67660cef93025f7583d726ad4bfb083ad9c0",
+    "lastModified": "2025-02-15T16:10:38.678293360Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "infrastructure": 1
+    }
+  },
+  "Soon-Next-Later (AI futurology).md": {
+    "fileName": "Soon-Next-Later (AI futurology).md",
+    "fileSize": 12919,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 7,
+    "sha1": "97430e99a9729dff31703fdea9ca54aa9956e021",
+    "lastModified": "2025-02-15T16:12:23.833211039Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Distributed Identity": 1,
+      "Interfaces": 5,
+      "Education and AI": 3,
+      "Cyber security and Cryptography": 1,
+      "Diagrams as Code": 1,
+      "OpenAI": 1,
+      "Social contract and jobs": 1,
+      "multimodal": 4,
+      "Politics, Law, Privacy": 1,
+      "Sam Hammond": 1,
+      "Mixed reality": 1,
+      "Death of the Internet": 2,
+      "collaborative": 4,
+      "Money": 1,
+      "Agents": 5
+    }
+  },
+  "Knowledge Graphing and RAG.md": {
+    "fileName": "Knowledge Graphing and RAG.md",
+    "fileSize": 21956,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 55,
+    "sha1": "c48d841caab406b50406cd244d13b0df4204989a",
+    "lastModified": "2025-02-15T16:10:33.425704688Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Multi Agent RAG scrapbook": 1,
+      "Music and audio": 1,
+      "multimodal": 3,
+      "Interfaces": 1,
+      "ollama": 3,
+      "Knowledge Graphing and RAG": 40,
+      "infrastructure": 1,
+      "Semantic Web": 1,
+      "Courses and Training": 1,
+      "Evaluation benchmarks and leaderboards": 1,
+      "Diagrams as Code": 1,
+      "ChatGPT": 4,
+      "Agents": 11,
+      "Agentic Mycelia": 1,
+      "Decentralised Web": 1,
+      "Large language models": 6,
+      "Metaverse Ontology": 1,
+      "Llama": 2,
+      "OpenAI": 7,
+      "Reasoning": 1,
+      "Agentic Metaverse for Global Creatives": 1,
+      "Training and fine tuning": 1
+    }
+  },
+  "Digital Society Harms.md": {
+    "fileName": "Digital Society Harms.md",
+    "fileSize": 2052,
+    "nodeSize": 23.468,
+    "hyperlinkCount": 11,
+    "sha1": "621a54f748119add788b95ffbba6c08452036258",
+    "lastModified": "2025-02-15T16:09:31.421111458Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Sam Hammond.md": {
+    "fileName": "Sam Hammond.md",
+    "fileSize": 17935,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "6d6e2566f510254770291bdad5e4300623341fbf",
+    "lastModified": "2025-02-15T16:12:13.469982026Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Social contract and jobs": 1,
+      "Accessibility": 1,
+      "Deep Learning": 1,
+      "Landscape": 4,
+      "OpenAI": 1,
+      "Sam Hammond": 1,
+      "AI Risks": 3
+    }
+  },
+  "Cashu.md": {
+    "fileName": "Cashu.md",
+    "fileSize": 4261,
+    "nodeSize": 43.349000000000004,
+    "hyperlinkCount": 7,
+    "sha1": "5c3ac6108ac3f371b8de92aa117e3c45bea30f5d",
+    "lastModified": "2025-02-15T16:08:50.556219562Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "ecash": 14,
+      "Cashu": 4,
+      "Bitcoin": 3
+    }
+  },
+  "Text to 3D and 4D.md": {
+    "fileName": "Text to 3D and 4D.md",
+    "fileSize": 8515,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 48,
+    "sha1": "60d3e231f8ce48115b7b45607c315b51aab36b90",
+    "lastModified": "2025-02-15T16:12:41.499155472Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Stable Diffusion": 3,
+      "Diffusion Models": 1,
+      "OpenAI": 1,
+      "Blender": 6,
+      "collaborative": 1,
+      "ComfyUI": 4
+    }
+  },
+  "Jailbreaking.md": {
+    "fileName": "Jailbreaking.md",
+    "fileSize": 911,
+    "nodeSize": 13.199000000000002,
+    "hyperlinkCount": 3,
+    "sha1": "6fa1bba1681cfa8ce33c5055fd26cea85af70d43",
+    "lastModified": "2025-02-15T16:10:26.694155106Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Jailbreaking": 1,
+      "Bitcoin": 1,
+      "Large language models": 1
+    }
+  },
+  "Artificial Intelligence.md": {
+    "fileName": "Artificial Intelligence.md",
+    "fileSize": 5855,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 3,
+    "sha1": "fac1de351c9748757d44ab1f29cfac303375f5c8",
+    "lastModified": "2025-02-15T16:08:30.499678098Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Artificial Intelligence": 2,
+      "Bitcoin": 1,
+      "Machine Learning": 1
+    }
+  },
+  "Distributed Identity.md": {
+    "fileName": "Distributed Identity.md",
+    "fileSize": 59124,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 57,
+    "sha1": "6bb3713d9a67ab162c1e85746b1dd741b8bfa663",
+    "lastModified": "2025-02-15T16:09:34.405788583Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Mixed reality": 2,
+      "Product Design": 2,
+      "Bitcoin": 23,
+      "nostr": 78,
+      "Distributed Identity": 8,
+      "collaborative": 3,
+      "Agents": 1,
+      "Digital Objects": 1,
+      "Blockchain": 2,
+      "infrastructure": 2,
+      "Money": 4
+    }
+  },
+  "Leopold Aschenbrenner.md": {
+    "fileName": "Leopold Aschenbrenner.md",
+    "fileSize": 8770,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 2,
+    "sha1": "b5949a72d7b4c0fc5e18120b6480c062ad8d1bbc",
+    "lastModified": "2025-02-15T16:10:40.181085166Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Leopold Aschenbrenner": 1,
+      "infrastructure": 2,
+      "AI Companies": 2,
+      "Energy and Power": 1,
+      "Hardware and Edge": 1,
+      "Politics, Law, Privacy": 1,
+      "artificial superintelligence": 1,
+      "Artificial Intelligence": 1
+    }
+  },
+  "IPAdapter.md": {
+    "fileName": "IPAdapter.md",
+    "fileSize": 4117,
+    "nodeSize": 42.053,
+    "hyperlinkCount": 1,
+    "sha1": "154e12b1e3ee28b15b101471b692dee7eb8026ff",
+    "lastModified": "2025-02-15T16:10:20.220151871Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Inpainting": 2,
+      "Base models": 1,
+      "multimodal": 4,
+      "Prompt Engineering": 1,
+      "Diffusion Models": 3
+    }
+  },
+  "Human tracking and SLAM capture.md": {
+    "fileName": "Human tracking and SLAM capture.md",
+    "fileSize": 1761,
+    "nodeSize": 20.848999999999997,
+    "hyperlinkCount": 9,
+    "sha1": "ca73b996878f9a362b5bd77ddb322a3321dee834",
+    "lastModified": "2025-02-15T16:10:15.618163478Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Recent Projects.md": {
+    "fileName": "Recent Projects.md",
+    "fileSize": 1485,
+    "nodeSize": 18.365000000000002,
+    "hyperlinkCount": 14,
+    "sha1": "f725558205279fcaacd1c0c080db336bd8453b88",
+    "lastModified": "2025-02-15T16:12:00.729792655Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Artificial Intelligence": 1,
+      "Bitcoin": 1,
+      "Hardware and Edge": 1,
+      "Robotics": 1,
+      "Virtual Production": 1
+    }
+  },
+  "Robin Hanson.md": {
+    "fileName": "Robin Hanson.md",
+    "fileSize": 4255,
+    "nodeSize": 43.295,
+    "hyperlinkCount": 1,
+    "sha1": "156d623073ac4c43ca74ddc759d08dc3278f2ec3",
+    "lastModified": "2025-02-15T16:12:05.020736083Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Gemini": 2,
+      "Lead Poisoning Hypothesis": 1,
+      "Robin Hanson": 1,
+      "Artificial Intelligence": 1
+    }
+  },
+  "Competition in AI.md": {
+    "fileName": "Competition in AI.md",
+    "fileSize": 2339,
+    "nodeSize": 26.051,
+    "hyperlinkCount": 1,
+    "sha1": "883b2c86288efd73e2ecfc008638840f9d9237a0",
+    "lastModified": "2025-02-15T16:09:01.494474893Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "latent space": 1,
+      "multimodal": 1,
+      "OpenAI": 4,
+      "Deepmind": 1,
+      "infrastructure": 2,
+      "Apple": 2,
+      "AI Companies": 1,
+      "ChatGPT": 2
+    }
+  },
+  "Knowhere.md": {
+    "fileName": "Knowhere.md",
+    "fileSize": 15800,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 6,
+    "sha1": "3b34a6640636d10e96ef28d9d716172103a1751e",
+    "lastModified": "2025-02-15T16:10:32.526248600Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "NVIDIA Omniverse": 1,
+      "OpenAI": 2,
+      "Segmentation and Identification": 1,
+      "Knowhere": 4,
+      "ChatGPT": 1
+    }
+  },
+  "Coding support.md": {
+    "fileName": "Coding support.md",
+    "fileSize": 15162,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 38,
+    "sha1": "40669d5f91734607fb5a850e03fba49615e8dc15",
+    "lastModified": "2025-02-15T16:08:54.708446370Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Microsoft CoPilot": 2,
+      "Llama": 3,
+      "ChatGPT": 5,
+      "Gemini": 1,
+      "infrastructure": 1,
+      "Spatial Computing": 1,
+      "Agents": 6,
+      "Large language models": 2,
+      "Machine Learning": 2,
+      "Interfaces": 3,
+      "Prompt Engineering": 1
+    }
+  },
+  "SLAM.md": {
+    "fileName": "SLAM.md",
+    "fileSize": 312,
+    "nodeSize": 7.808,
+    "hyperlinkCount": 1,
+    "sha1": "d6805bce5393bcfecde2d257b339882c9cb4bcca",
+    "lastModified": "2025-02-15T16:12:11.973980434Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "SLAM": 3
+    }
+  },
+  "Singularity.md": {
+    "fileName": "Singularity.md",
+    "fileSize": 5040,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "c35e7f287027707c97f1ed684c9c3e0654152b42",
+    "lastModified": "2025-02-15T16:12:20.372243704Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "collaborative": 1,
+      "Singularity": 10
+    }
+  },
+  "Bitcoin Technical Overview.md": {
+    "fileName": "Bitcoin Technical Overview.md",
+    "fileSize": 34697,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 65,
+    "sha1": "8e936a1e64b786b9d96fff6bb9f10124ced9b58a",
+    "lastModified": "2025-02-15T16:08:40.682655612Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Ethereum": 1,
+      "nostr": 5,
+      "Money": 8,
+      "Bitcoin": 81,
+      "Mixed reality": 1,
+      "flossverse": 2,
+      "Distributed Identity": 1,
+      "Blockchain": 7,
+      "collaborative": 1
+    }
+  },
+  "Suggested Reading Order.md": {
+    "fileName": "Suggested Reading Order.md",
+    "fileSize": 2782,
+    "nodeSize": 30.038,
+    "hyperlinkCount": 2,
+    "sha1": "dd52efde2f9d59e0c7d88a1eff9cf54a169e0a76",
+    "lastModified": "2025-02-15T16:12:33.058829406Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "State of the art in AI": 1,
+      "Spatial Computing": 1,
+      "collaborative": 1,
+      "Proprietary Large Language Models": 1,
+      "Convergence": 1,
+      "Distributed Identity": 1,
+      "Digital Asset Risks": 1,
+      "Metaverse and Spatial Risks": 1,
+      "Artificial Intelligence": 1,
+      "Adoption of Convergent Technologies": 1,
+      "Octave Multi Model Laboratory": 1,
+      "Machine Learning": 1,
+      "National Industrial Centre for Virtual Environments": 1,
+      "nostr": 1,
+      "Decentralised Web": 1,
+      "Money": 3,
+      "Definitions and frameworks for Metaverse": 1,
+      "BTC Layer 3": 1,
+      "Agents": 1,
+      "Ethereum": 1,
+      "Bitcoin": 2,
+      "Overview of Machine Learning Techniques": 1,
+      "Bitcoin As Money": 1,
+      "Proprietary Video": 1,
+      "Open Generative AI tools": 1,
+      "Large language models": 1,
+      "Blockchain": 1,
+      "Proprietary Image Generation": 1,
+      "Digital Objects": 3,
+      "Semantic Web": 1,
+      "Politics, Law, Privacy": 1,
+      "Introduction to me": 1
+    }
+  },
+  "Ethereum.md": {
+    "fileName": "Ethereum.md",
+    "fileSize": 15310,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 29,
+    "sha1": "2e8f4c1a3a736a74b6a5ee4d04beb22b3020a400",
+    "lastModified": "2025-02-15T16:09:44.695188663Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Bitcoin": 6,
+      "infrastructure": 2,
+      "Money": 7,
+      "Ethereum": 38,
+      "Blockchain": 4,
+      "Mixed reality": 1
+    }
+  },
+  "latent space.md": {
+    "fileName": "latent space.md",
+    "fileSize": 1626,
+    "nodeSize": 19.634,
+    "hyperlinkCount": 0,
+    "sha1": "f07817e32235a6342d1d9c0c7393b80fd045b7ff",
+    "lastModified": "2025-02-15T16:13:32.264176142Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "latent space": 7,
+      "OpenAI": 1,
+      "Artificial Intelligence": 1
+    }
+  },
+  "Stable Coins.md": {
+    "fileName": "Stable Coins.md",
+    "fileSize": 18917,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 33,
+    "sha1": "552f0f022b34904a3a5279fba93d708826ef0a75",
+    "lastModified": "2025-02-15T16:12:28.081304407Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Gemini": 3,
+      "infrastructure": 6,
+      "Blockchain": 7,
+      "Bitcoin": 3,
+      "Money": 6,
+      "Ethereum": 5,
+      "Stable Coins": 3
+    }
+  },
+  "State of the art in AI.md": {
+    "fileName": "State of the art in AI.md",
+    "fileSize": 8137,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 19,
+    "sha1": "ae78904f3bd3432f308da79442be04beb5bcab46",
+    "lastModified": "2025-02-15T16:12:31.064072045Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Interfaces": 2,
+      "Money": 3,
+      "infrastructure": 1,
+      "Death of the Internet": 1,
+      "Artificial Intelligence": 1,
+      "Politics, Law, Privacy": 1,
+      "Hardware and Edge": 1,
+      "Education and AI": 1,
+      "Proprietary Large Language Models": 1,
+      "Agents": 1,
+      "Privacy, Trust and Safety": 2,
+      "Large language models": 1,
+      "Social contract and jobs": 2,
+      "OpenAI": 5
+    }
+  },
+  "Parametric.md": {
+    "fileName": "Parametric.md",
+    "fileSize": 6574,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 4,
+    "sha1": "d3c14a3ee65e689a3d76a5aed5bb53177bf71376",
+    "lastModified": "2025-02-15T16:11:29.425478711Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "NVIDIA Omniverse": 4,
+      "Interfaces": 1,
+      "GANs": 1,
+      "Parametric": 7
+    }
+  },
+  "ecash.md": {
+    "fileName": "ecash.md",
+    "fileSize": 4860,
+    "nodeSize": 48.74,
+    "hyperlinkCount": 0,
+    "sha1": "c506dbc045207de680663a775cad988f77bf9018",
+    "lastModified": "2025-02-15T16:13:19.564911966Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Accessibility": 1,
+      "Cashu": 2,
+      "Bitcoin": 8,
+      "Blockchain": 4,
+      "ecash": 3
+    }
+  },
+  "collaborative.md": {
+    "fileName": "collaborative.md",
+    "fileSize": 14,
+    "nodeSize": 5.126,
+    "hyperlinkCount": 0,
+    "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+    "lastModified": "2025-02-15T16:13:15.322362153Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Metaverse as Markets.md": {
+    "fileName": "Metaverse as Markets.md",
+    "fileSize": 11006,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 7,
+    "sha1": "1084bcea8cecdc3b3d6bcbd4ace9788d800b5dd3",
+    "lastModified": "2025-02-15T16:11:01.136771278Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Blockchain": 2,
+      "Bitcoin": 1,
+      "Money": 1
+    }
+  },
+  "Revision List.md": {
+    "fileName": "Revision List.md",
+    "fileSize": 3977,
+    "nodeSize": 40.793,
+    "hyperlinkCount": 1,
+    "sha1": "9de5dc3743751d34db958f0e3b1463d6605464a2",
+    "lastModified": "2025-02-15T16:12:04.240890561Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Time Series Forecasting": 1,
+      "Deep Learning": 2,
+      "Agents": 1,
+      "Prompt Engineering": 1,
+      "Machine Learning": 6
+    }
+  },
+  "Safety and alignment.md": {
+    "fileName": "Safety and alignment.md",
+    "fileSize": 20446,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 12,
+    "sha1": "b5b56905d6989e3d22896938603efceef2f2c4b3",
+    "lastModified": "2025-02-15T16:12:12.712173362Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "OpenAI": 9,
+      "AI Risks": 1,
+      "Safety and alignment": 3,
+      "AI Companies": 1,
+      "Machine Learning": 1,
+      "Reasoning": 9,
+      "Jailbreaking": 1,
+      "Social contract and jobs": 1,
+      "Large language models": 1,
+      "infrastructure": 1,
+      "Artificial Intelligence": 2
+    }
+  },
+  "Death of the Internet.md": {
+    "fileName": "Death of the Internet.md",
+    "fileSize": 31877,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 83,
+    "sha1": "5043440f98edf274d734dbfdfba7d705e2cd3936",
+    "lastModified": "2025-02-15T16:09:18.796768914Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "latent space": 1,
+      "Artificial Intelligence": 3,
+      "Agents": 4,
+      "Human vs AI": 1,
+      "Deepfakes and fraudulent content": 1,
+      "Politics, Law, Privacy": 1,
+      "Large language models": 1,
+      "infrastructure": 6,
+      "Singularity": 1,
+      "Social contract and jobs": 2,
+      "Decentralised Web": 1,
+      "Privacy, Trust and Safety": 2,
+      "Death of the Internet": 7,
+      "Accessibility": 2,
+      "Blockchain": 1,
+      "Landscape": 2,
+      "ChatGPT": 2,
+      "OpenAI": 7,
+      "Digital Society Surveillance": 1,
+      "legacy media": 2,
+      "Global Inequality": 1,
+      "Leopold Aschenbrenner": 1
+    }
+  },
+  "Financialised Agentic Memetics.md": {
+    "fileName": "Financialised Agentic Memetics.md",
+    "fileSize": 2442,
+    "nodeSize": 26.978,
+    "hyperlinkCount": 1,
+    "sha1": "7e32c48849f9bbabc5a9004d1c97fceb0e78510a",
+    "lastModified": "2025-02-15T16:09:54.400339386Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 1,
+      "Tokenisation": 1,
+      "Bitcoin": 1,
+      "Blockchain": 1
+    }
+  },
+  "AI Video.md": {
+    "fileName": "AI Video.md",
+    "fileSize": 18535,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 90,
+    "sha1": "a64b5679fbe11d0250919f9beb56affce22f812b",
+    "lastModified": "2025-02-15T16:08:12.269348248Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "AI Video": 5,
+      "Stable Diffusion": 6,
+      "LoRA DoRA etc": 1,
+      "Diffusion Models": 7,
+      "collaborative": 1,
+      "Inpainting": 5,
+      "ComfyUI": 7,
+      "AnimateDiff": 10,
+      "latent space": 1,
+      "Blender": 1
+    }
+  },
+  "Tim Reutermann.md": {
+    "fileName": "Tim Reutermann.md",
+    "fileSize": 3622,
+    "nodeSize": 37.598,
+    "hyperlinkCount": 2,
+    "sha1": "a7637194be7fb2c58b8cf8fa927ef7a1373a8f85",
+    "lastModified": "2025-02-15T16:12:42.963107984Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Blockchain": 2,
+      "Bitcoin": 2,
+      "cypherpunk": 3
+    }
+  },
+  "California AI bill.md": {
+    "fileName": "California AI bill.md",
+    "fileSize": 5403,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 0,
+    "sha1": "24bb18205e4e37e20704b73f32b1c2b28b7dae3f",
+    "lastModified": "2025-02-15T16:08:49.132625279Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Landscape": 2,
+      "collaborative": 2
+    }
+  },
+  "Agentic Metaverse for Global Creatives.md": {
+    "fileName": "Agentic Metaverse for Global Creatives.md",
+    "fileSize": 30730,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "4d086bdfcecbc35fc2d6596b5dc6dabf082696b1",
+    "lastModified": "2025-02-15T16:08:21.949625703Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Metaverse Ontology": 1,
+      "nostr": 29,
+      "Interfaces": 1,
+      "Machine Learning": 2,
+      "Money": 6,
+      "Privacy, Trust and Safety": 1,
+      "Stable Diffusion": 1,
+      "Large language models": 2,
+      "ecash": 1,
+      "ChatGPT": 1,
+      "Agents": 12,
+      "Bitcoin": 13,
+      "Virtual Production": 2,
+      "Mixed reality": 3,
+      "Blockchain": 3,
+      "collaborative": 9,
+      "NVIDIA Omniverse": 1,
+      "Accessibility": 7,
+      "Digital Objects": 2,
+      "Landscape": 5,
+      "infrastructure": 6
+    }
+  },
+  "Ai in Games.md": {
+    "fileName": "Ai in Games.md",
+    "fileSize": 3232,
+    "nodeSize": 34.088,
+    "hyperlinkCount": 12,
+    "sha1": "eae8c355131e3fa2ca3588f4ab9ec6965285e500",
+    "lastModified": "2025-02-15T16:08:24.599117478Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "ComfyUI": 1,
+      "Stable Diffusion": 1,
+      "Transformers": 1,
+      "NVIDIA Omniverse": 1,
+      "Blender": 1
+    }
+  },
+  "Comparison of GPT4 and Gemini Ultra.md": {
+    "fileName": "Comparison of GPT4 and Gemini Ultra.md",
+    "fileSize": 3048,
+    "nodeSize": 32.432,
+    "hyperlinkCount": 0,
+    "sha1": "98ef9ac102777f21411b105b6b3ef860af297228",
+    "lastModified": "2025-02-15T16:08:59.540459045Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Gemini": 12,
+      "ChatGPT": 13
+    }
+  },
+  "Multi Agent RAG scrapbook.md": {
+    "fileName": "Multi Agent RAG scrapbook.md",
+    "fileSize": 6497,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "34e5bfbbd0d31a1c9b90ef203f1eb0cd16c54d2f",
+    "lastModified": "2025-02-15T16:11:12.658604680Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Prompt Engineering": 1,
+      "Reasoning": 1,
+      "Large language models": 1,
+      "Transformers": 1,
+      "Diagrams as Code": 1
+    }
+  },
+  "Anthropic Claude.md": {
+    "fileName": "Anthropic Claude.md",
+    "fileSize": 1398,
+    "nodeSize": 17.582,
+    "hyperlinkCount": 5,
+    "sha1": "65cf23d3d5b32eaf4721a5f7004e42101a1b4dfb",
+    "lastModified": "2025-02-15T16:08:26.744968346Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Rust.md": {
+    "fileName": "Rust.md",
+    "fileSize": 3324,
+    "nodeSize": 34.916,
+    "hyperlinkCount": 0,
+    "sha1": "904052bcb6c40ea9f5cbe7762cba6470409b39e3",
+    "lastModified": "2025-02-15T16:12:10.030655380Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Rust": 2
+    }
+  },
+  "Runes and Glyphs.md": {
+    "fileName": "Runes and Glyphs.md",
+    "fileSize": 1840,
+    "nodeSize": 21.56,
+    "hyperlinkCount": 15,
+    "sha1": "a2a25a678dabe813bd618db55310495c1b877649",
+    "lastModified": "2025-02-15T16:12:09.306148260Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Bitcoin": 2,
+      "Digital Objects": 1,
+      "Blockchain": 1,
+      "Runes and Glyphs": 8,
+      "flossverse": 2
+    }
+  },
+  "ComfyUI.md": {
+    "fileName": "ComfyUI.md",
+    "fileSize": 36608,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 126,
+    "sha1": "14934e91d17fdd724433532a6b7261a04463a59c",
+    "lastModified": "2025-02-15T16:08:57.363689285Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Inpainting": 5,
+      "Apple": 2,
+      "LoRA DoRA etc": 4,
+      "IPAdapter": 3,
+      "Gemini": 24,
+      "Courses and Training": 1,
+      "Diffusion Models": 3,
+      "OpenAI": 2,
+      "license": 1,
+      "Stable Diffusion": 19,
+      "Artificial Intelligence": 1,
+      "collaborative": 1,
+      "Upscaling": 9,
+      "Large language models": 2,
+      "AnimateDiff": 1,
+      "ComfyUI": 151,
+      "ChatGPT": 3
+    }
+  },
+  "Medical AI.md": {
+    "fileName": "Medical AI.md",
+    "fileSize": 18110,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 17,
+    "sha1": "dd458f6f92dec20c2a90787ec3b66a15c228f2f8",
+    "lastModified": "2025-02-15T16:10:55.678053979Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Landscape": 1,
+      "Deep Learning": 2,
+      "Convergence": 1,
+      "Transformers": 1,
+      "Machine Learning": 3,
+      "OpenAI": 3,
+      "Large language models": 2,
+      "Gemini": 1,
+      "Medical AI": 2,
+      "Agents": 7,
+      "Deepmind": 3
+    }
+  },
+  "ChatGPT.md": {
+    "fileName": "ChatGPT.md",
+    "fileSize": 16012,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 65,
+    "sha1": "53c14138461a0909964f8b592e54218416b533c2",
+    "lastModified": "2025-02-15T16:08:51.289460693Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "multimodal": 5,
+      "Blender": 5,
+      "ChatGPT": 36,
+      "collaborative": 1,
+      "Accessibility": 1,
+      "Robotics": 1,
+      "OpenAI": 17,
+      "Stable Diffusion": 8
+    }
+  },
+  "Conspiracies.md": {
+    "fileName": "Conspiracies.md",
+    "fileSize": 13147,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 9,
+    "sha1": "a2952b45f94d6f7579fca999d55c6f3049f95cde",
+    "lastModified": "2025-02-15T16:09:02.929383613Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Agents": 2,
+      "Artificial Intelligence": 1,
+      "Politics, Law, Privacy": 1,
+      "Safety and alignment": 1,
+      "California AI bill": 1,
+      "Bitcoin": 9,
+      "Conspiracies": 1,
+      "AI Companies": 1
+    }
+  },
+  "Overview of Machine Learning Techniques.md": {
+    "fileName": "Overview of Machine Learning Techniques.md",
+    "fileSize": 7147,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 18,
+    "sha1": "b42c90f063ac83bfc71ca3fc133eef422505162f",
+    "lastModified": "2025-02-15T16:11:24.436528238Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Artificial Intelligence": 1,
+      "State Space and Other Approaches": 1,
+      "GANs": 1,
+      "Machine Learning": 2,
+      "Large language models": 2,
+      "Proprietary Large Language Models": 2,
+      "Deep Learning": 3,
+      "Transformers": 2,
+      "Diffusion Models": 2
+    }
+  },
+  "Training and fine tuning.md": {
+    "fileName": "Training and fine tuning.md",
+    "fileSize": 4404,
+    "nodeSize": 44.636,
+    "hyperlinkCount": 0,
+    "sha1": "f8e7d4b12dc95f1b29a2f004a0b987d2e96a5696",
+    "lastModified": "2025-02-15T16:12:46.439870219Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Large language models": 2,
+      "Semantic Web": 1,
+      "Transformers": 2,
+      "multimodal": 2,
+      "Safety and alignment": 1
+    }
+  },
+  "Deepmind.md": {
+    "fileName": "Deepmind.md",
+    "fileSize": 14,
+    "nodeSize": 5.126,
+    "hyperlinkCount": 0,
+    "sha1": "9729142a9e9032bf1ed85b9334e45cf9c2e3d276",
+    "lastModified": "2025-02-15T16:09:24.417595714Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {}
+  },
+  "Octave Multi Model Laboratory.md": {
+    "fileName": "Octave Multi Model Laboratory.md",
+    "fileSize": 2325,
+    "nodeSize": 25.925000000000004,
+    "hyperlinkCount": 6,
+    "sha1": "34ea203172ccadf208dda2aa1cb8036ebe6ee74b",
+    "lastModified": "2025-02-15T16:11:18.061917637Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Hardware and Edge": 1,
+      "Mixed reality": 4,
+      "Money": 1,
+      "Convergence": 1,
+      "Machine Learning": 1,
+      "Digital Objects": 1,
+      "collaborative": 1,
+      "National Industrial Centre for Virtual Environments": 1
+    }
+  },
+  "Norbert Wiener.md": {
+    "fileName": "Norbert Wiener.md",
+    "fileSize": 2434,
+    "nodeSize": 26.906,
+    "hyperlinkCount": 0,
+    "sha1": "073af281929b120abb910c60dc1d39ba3df1c908",
+    "lastModified": "2025-02-15T16:11:16.828099714Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Norbert Wiener": 1,
+      "Artificial Intelligence": 1
+    }
+  },
+  "AI Companies.md": {
+    "fileName": "AI Companies.md",
+    "fileSize": 7132,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 6,
+    "sha1": "f3e0fd1d16eb22fb2dda1cc95d246869e0759f69",
+    "lastModified": "2025-02-15T16:08:08.045852866Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Reasoning": 1,
+      "infrastructure": 1,
+      "Llama": 2,
+      "Machine Learning": 6,
+      "Interfaces": 1,
+      "Robotics": 1,
+      "OpenAI": 5,
+      "Large language models": 1,
+      "Gemini": 9,
+      "Comparison of GPT4 and Gemini Ultra": 1,
+      "Knowledge Graphing and RAG": 1,
+      "ChatGPT": 2,
+      "Politics, Law, Privacy": 1
+    }
+  },
+  "Education and AI.md": {
+    "fileName": "Education and AI.md",
+    "fileSize": 15391,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 17,
+    "sha1": "f8162d1c848cb858cc121d2f5a39f9b6555cd667",
+    "lastModified": "2025-02-15T16:09:38.560726838Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Social contract and jobs": 1,
+      "Landscape": 2,
+      "Large language models": 1,
+      "collaborative": 1,
+      "ChatGPT": 3,
+      "Facebook Meta": 1,
+      "Deepfakes and fraudulent content": 1,
+      "Diagrams as Code": 1,
+      "Privacy, Trust and Safety": 1,
+      "Money": 1,
+      "Education and AI": 7
+    }
+  },
+  "Flux.md": {
+    "fileName": "Flux.md",
+    "fileSize": 27922,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 18,
+    "sha1": "8b5e456430dadbc8eca8e732ab6a14da4eb7d905",
+    "lastModified": "2025-02-15T16:09:55.892726558Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "license": 1,
+      "Death of the Internet": 1,
+      "Upscaling": 1,
+      "Deep Learning": 1,
+      "Stable Diffusion": 2,
+      "Landscape": 1,
+      "Controlnet and similar": 3,
+      "LoRA DoRA etc": 1,
+      "Convergence": 2,
+      "Artificial Intelligence": 2,
+      "Segmentation and Identification": 1,
+      "Visionflow": 1,
+      "Model Optimisation and Performance": 3,
+      "Open Generative AI tools": 1,
+      "Prompt Engineering": 3,
+      "AI Video": 1,
+      "ComfyUI": 40,
+      "Flux": 87,
+      "Inpainting": 9,
+      "IPAdapter": 1,
+      "collaborative": 1
+    }
+  },
+  "flossverse.md": {
+    "fileName": "flossverse.md",
+    "fileSize": 3984,
+    "nodeSize": 40.856,
+    "hyperlinkCount": 4,
+    "sha1": "a8b2f934290c28035ba5f53737e36dd1e3d4997f",
+    "lastModified": "2025-02-15T16:13:23.035476641Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Machine Learning": 1,
+      "flossverse": 1,
+      "collaborative": 1,
+      "infrastructure": 1,
+      "Money": 2,
+      "Mixed reality": 1
+    }
+  },
+  "Client side DCO.md": {
+    "fileName": "Client side DCO.md",
+    "fileSize": 14735,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 1,
+    "sha1": "e49762efad2e1d5cbfc77eef626bd48f4056ebaa",
+    "lastModified": "2025-02-15T16:08:53.971973824Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "NVIDIA Omniverse": 1,
+      "nostr": 25,
+      "Training and fine tuning": 1,
+      "multimodal": 3,
+      "Decentralised Web": 1,
+      "Hyper personalisation": 2,
+      "latent space": 4,
+      "Hardware and Edge": 1,
+      "infrastructure": 3,
+      "Politics, Law, Privacy": 1,
+      "Transformers": 1
+    }
+  },
+  "Algorithmic Bias and Variance.md": {
+    "fileName": "Algorithmic Bias and Variance.md",
+    "fileSize": 8489,
+    "nodeSize": 50.0,
+    "hyperlinkCount": 22,
+    "sha1": "4a91499602b3f84d116606d1e29d81bc9e1255e7",
+    "lastModified": "2025-02-15T16:08:25.316091890Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Convergence": 1,
+      "Machine Learning": 1,
+      "ChatGPT": 6,
+      "Large language models": 1
+    }
+  },
+  "Metaverse and Spatial Risks.md": {
+    "fileName": "Metaverse and Spatial Risks.md",
+    "fileSize": 2443,
+    "nodeSize": 26.987000000000002,
+    "hyperlinkCount": 2,
+    "sha1": "b9ef186e5294a38d70878f2c6aed99422c9df532",
+    "lastModified": "2025-02-15T16:10:59.176766764Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Machine Learning": 3
+    }
+  },
+  "Upscaling.md": {
+    "fileName": "Upscaling.md",
+    "fileSize": 1184,
+    "nodeSize": 15.655999999999999,
+    "hyperlinkCount": 7,
+    "sha1": "2e5ac91fce4545f7c42fcb0bc52459fddf3244a2",
+    "lastModified": "2025-02-15T16:12:53.611066677Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "ComfyUI": 9,
+      "Upscaling": 3,
+      "Stable Diffusion": 1
+    }
+  },
+  "Microsoft CoPilot.md": {
+    "fileName": "Microsoft CoPilot.md",
+    "fileSize": 4569,
+    "nodeSize": 46.120999999999995,
+    "hyperlinkCount": 7,
+    "sha1": "7036139cdbe327bf3f2d5a3aec96f73efed1f7e9",
+    "lastModified": "2025-02-15T16:11:02.612759857Z",
+    "perplexityLink": "",
+    "lastPerplexityProcess": null,
+    "topicCounts": {
+      "Microsoft CoPilot": 1,
+      "ChatGPT": 3,
+      "OpenAI": 5,
+      "infrastructure": 2,
+      "Deep Learning": 1,
+      "Artificial Intelligence": 1
+    }
+  }
+}
\ No newline at end of file
diff --git a/docker-compose.yml b/docker-compose.yml
new file mode 100755
index 00000000..d9300c92
--- /dev/null
+++ b/docker-compose.yml
@@ -0,0 +1,101 @@
+name: logseq-xr
+
+services:
+  webxr:
+    build: .
+    image: logseq-xr-image:latest
+    container_name: logseq-xr-webxr
+    read_only: false
+    networks:
+      ragflow:
+        aliases:
+          - logseq-xr-webxr
+          - webxr-client
+    deploy:
+      resources:
+        limits:
+          cpus: '16.0'
+          memory: 64G
+        reservations:
+          devices:
+            - driver: nvidia
+              device_ids: ['0']  # Explicitly use GPU 0
+              capabilities: [compute, utility]
+    expose:
+      - "4000"
+    ports:
+      - "4000:4000"  # Map container nginx port 4000 to host port 4000
+    environment:
+      - RUST_LOG=info
+      - RUST_BACKTRACE=1
+      - BIND_ADDRESS=0.0.0.0
+      - PORT=3001  # Explicitly set Rust backend to use port 3001
+      - NGINX_PORT=4000  # Set nginx to use port 4000
+      - NVIDIA_GPU_UUID=GPU-553dc306-dab3-32e2-c69b-28175a6f4da6  # Direct UUID value for the specific GPU
+      - NVIDIA_VISIBLE_DEVICES=GPU-553dc306-dab3-32e2-c69b-28175a6f4da6  # Pass the GPU UUID directly
+      - NVIDIA_DRIVER_CAPABILITIES=compute,utility
+      - NODE_ENV=production
+      - GIT_HASH=${GIT_HASH:-development}  # Pass GIT_HASH from build environment
+      - DEBUG_MODE=${DEBUG_MODE:-false}  # Control whether to start webxr or not
+    env_file:
+      - .env
+    volumes:
+      - ./data/markdown:/app/data/markdown
+      - ./data/metadata:/app/data/metadata  # Added metadata volume mount
+      - ./data/user_settings:/app/user_settings  # Added user settings volume mount
+      - type: bind
+        source: ${PWD}/settings.yaml
+        target: /app/settings.yaml
+        read_only: false
+      - type: tmpfs
+        target: /tmp
+        tmpfs:
+          size: 4G
+    user: "${UID:-1000}:${GID:-1000}"  # Use host user's UID/GID or default to 1000
+    restart: unless-stopped
+    stop_grace_period: 30s
+    command: sh -c 'exec /app/start.sh'  # Always start WebXR with GPU enabled (via modified start.sh)
+    init: true
+    logging:
+      driver: "json-file"
+      options:
+        max-size: "1g"
+        max-file: "5"
+    healthcheck:
+      test: ["CMD", "curl", "-f", "http://localhost:4000/"]
+      interval: 10s
+      timeout: 5s
+      retries: 3
+      start_period: 10s
+
+  cloudflared:
+    image: cloudflare/cloudflared:latest
+    container_name: cloudflared-tunnel
+    networks:
+      ragflow:
+        aliases:
+          - cloudflared
+    volumes:
+      - ./config.yml:/etc/cloudflared/config.yml:ro
+    command: tunnel --loglevel info --config /etc/cloudflared/config.yml run
+    restart: unless-stopped
+    stop_grace_period: 10s
+    init: true
+    depends_on: []  # Remove dependency on webxr
+    environment:
+      - TUNNEL_TOKEN=$TUNNEL_TOKEN
+      - TUNNEL_METRICS=0.0.0.0:2000
+      - TUNNEL_DNS_UPSTREAM=https://1.1.1.1/dns-query,https://1.0.0.1/dns-query
+      - TUNNEL_TRANSPORT_PROTOCOL=http2
+      - TUNNEL_ORIGIN_SERVER=http://logseq-xr-webxr:4000  # Use container name to ensure proper DNS resolution
+      - TUNNEL_WEBSOCKET_ENABLE=true
+      - TUNNEL_WEBSOCKET_HEARTBEAT_INTERVAL=30s  # Match our heartbeat interval
+      - TUNNEL_WEBSOCKET_TIMEOUT=3600s  # Match our max timeout
+      - TUNNEL_RETRIES=5
+      - TUNNEL_GRACE_PERIOD=30s
+    env_file:
+      - .env
+networks:
+  ragflow:
+    external: true
+    name: docker_ragflow  # RAGFlow's network name from docker network ls
diff --git a/docs/api/index.md b/docs/api/index.md
new file mode 100644
index 00000000..22f08aa9
--- /dev/null
+++ b/docs/api/index.md
@@ -0,0 +1,62 @@
+# LogseqXR API Documentation
+
+This section provides comprehensive documentation for all APIs available in LogseqXR.
+
+## Available APIs
+
+### REST API
+
+The [REST API](rest.md) provides HTTP endpoints for managing files, graph data, settings, and more. It's primarily used for:
+
+- File operations (fetching, processing, updating)
+- Graph management
+- Settings configuration
+- Health monitoring
+- Authentication
+
+### WebSocket API
+
+The [WebSocket API](websocket.md) enables real-time communication between the client and server. It's used for:
+
+- Real-time node position updates
+- Binary data streaming for efficient 3D visualization
+- Connection management
+- Settings synchronization
+
+## Authentication
+
+Both APIs use the same authentication mechanism based on Nostr. Include the authentication token in the Authorization header:
+
+```
+Authorization: Bearer <token>
+```
+
+## API Versioning
+
+The current API version is v1. All endpoints are prefixed with `/api/v1/` except for WebSocket connections which use `/wss`.
+
+## Error Handling
+
+All APIs follow a consistent error format:
+
+```json
+{
+  "error": "error_code",
+  "message": "Human-readable error message",
+  "details": {
+    "field": "specific error information"
+  }
+}
+```
+
+## Rate Limiting
+
+API endpoints are rate-limited to prevent abuse. The current limits are:
+
+- REST API: 100 requests per minute per IP
+- WebSocket: 60 messages per minute per connection
+
+## Further Reading
+
+- [Binary Protocol](../technical/binary-protocol.md) - Details on the binary format used for WebSocket communication
+- [WebSocket Implementation](../technical/websockets.md) - In-depth documentation on the WebSocket implementation
diff --git a/docs/api/rest.md b/docs/api/rest.md
new file mode 100644
index 00000000..020547f3
--- /dev/null
+++ b/docs/api/rest.md
@@ -0,0 +1,198 @@
+# REST API Reference
+
+## Authentication
+
+### Login
+```http
+POST /api/auth/nostr
+```
+
+**Request Body:**
+```json
+{
+  "pubkey": "your_public_key",
+  "signature": "signed_challenge"
+}
+```
+
+**Response:**
+```json
+{
+  "user": {
+    "pubkey": "user_public_key",
+    "npub": "user_npub",
+    "is_power_user": boolean,
+    "last_seen": 1234567890
+  },
+  "token": "session_token",
+  "expires_at": 1234567890,
+  "features": ["feature1", "feature2"]
+}
+```
+
+### Verify Token
+```http
+POST /api/auth/nostr/verify
+```
+
+**Request Body:**
+```json
+{
+  "pubkey": "your_public_key",
+  "token": "your_token"
+}
+```
+
+### Logout
+```http
+DELETE /api/auth/nostr
+```
+
+## Files API
+
+### Process Files
+```http
+POST /api/files/process
+```
+
+Triggers fetching and processing of Markdown files.
+
+**Response:**
+```json
+{
+  "status": "success",
+  "processed_files": ["file1.md", "file2.md"]
+}
+```
+
+### Get File Content
+```http
+GET /api/files/get_content/{filename}
+```
+
+## Graph API
+
+### Get Graph Data
+```http
+GET /api/graph/data
+```
+
+Returns complete graph structure.
+
+### Get Paginated Graph Data
+```http
+GET /api/graph/data/paginated
+```
+
+**Query Parameters:**
+- `page`: Page number (default: 1)
+- `page_size`: Items per page (default: 100)
+- `sort`: Sort field
+- `filter`: Filter expression
+
+### Update Graph
+```http
+POST /api/graph/update
+```
+
+**Request Body:**
+```json
+{
+  "nodes": [...],
+  "edges": [...]
+}
+```
+
+### Refresh Graph
+```http
+POST /api/graph/refresh
+```
+
+## Settings API
+
+### Get Visualization Settings
+```http
+GET /api/user-settings/visualization
+```
+
+### Update API Keys
+```http
+POST /api/auth/nostr/api-keys
+```
+
+**Request Body:**
+```json
+{
+  "perplexity": "api_key",
+  "openai": "api_key",
+  "ragflow": "api_key"
+}
+```
+
+## AI Services
+
+### Perplexity Query
+```http
+POST /api/perplexity
+```
+
+**Request Body:**
+```json
+{
+  "query": "Your question here",
+  "conversation_id": "optional-previous-conversation-id"
+}
+```
+
+**Response:**
+```json
+{
+  "answer": "The response from Perplexity AI",
+  "conversation_id": "conversation-id-for-follow-up-queries"
+}
+```
+
+## Error Responses
+
+All endpoints may return the following error responses:
+
+#### 400 Bad Request
+```json
+{
+  "error": "bad_request",
+  "message": "Invalid parameters",
+  "details": {
+    "field": "reason for error"
+  }
+}
+```
+
+#### 401 Unauthorized
+```json
+{
+  "error": "unauthorized",
+  "message": "Invalid or missing authentication token"
+}
+```
+
+#### 404 Not Found
+```json
+{
+  "error": "not_found",
+  "message": "Resource not found"
+}
+```
+
+#### 500 Internal Server Error
+```json
+{
+  "error": "internal_error",
+  "message": "An internal error occurred",
+  "request_id": "abc-123"
+}
+```
+
+## Related Documentation
+- [WebSocket API](./websocket.md)
+- [Development Setup](../development/setup.md)
+- [Technical Architecture](../overview/architecture.md)
\ No newline at end of file
diff --git a/docs/api/websocket.md b/docs/api/websocket.md
new file mode 100644
index 00000000..708ba64c
--- /dev/null
+++ b/docs/api/websocket.md
@@ -0,0 +1,88 @@
+# WebSocket API Reference
+
+## Connection
+
+Connect to: `wss://your-domain/wss`
+
+## Authentication
+
+Send authentication message immediately after connection:
+
+```json
+{
+  "type": "auth",
+  "token": "your_nostr_token"
+}
+```
+
+## Message Types
+
+### Control Messages
+
+1. Connection Established
+```json
+{
+  "type": "connection_established"
+}
+```
+
+2. Request Initial Data
+```json
+{
+  "type": "requestInitialData"
+}
+```
+
+3. Updates Started
+```json
+{
+  "type": "updatesStarted"
+}
+```
+
+### Binary Messages
+
+Node position updates are sent as binary messages:
+
+- Each node update is 26 bytes
+- Format: [Node ID (2 bytes)][Position (12 bytes)][Velocity (12 bytes)]
+- Position and Velocity are float32[3] arrays
+
+### Settings Synchronization
+
+```json
+{
+  "type": "settings_update",
+  "category": "visualization",
+  "settings": {
+    "edges": {
+      "scaleFactor": 2.0
+    }
+  }
+}
+```
+
+## Error Handling
+
+1. Connection Error
+```json
+{
+  "type": "error",
+  "code": "connection_error",
+  "message": "Connection failed"
+}
+```
+
+2. Authentication Error
+```json
+{
+  "type": "error",
+  "code": "auth_error",
+  "message": "Invalid token"
+}
+```
+
+## Rate Limiting
+
+- 60 messages per minute per connection
+- Binary updates don't count towards rate limit
diff --git a/docs/clientdocs/apis/authentication.md b/docs/clientdocs/apis/authentication.md
new file mode 100644
index 00000000..a47020af
--- /dev/null
+++ b/docs/clientdocs/apis/authentication.md
@@ -0,0 +1,462 @@
+# Authentication
+
+This document details the authentication mechanisms used in the client application, including the Nostr-based authentication flow, token handling, and authorization procedures.
+
+## Authentication Overview
+
+The application uses Nostr for authentication, providing a decentralized authentication mechanism. The authentication flow involves a challenge-response pattern using Nostr public keys and digital signatures.
+
+```mermaid
+sequenceDiagram
+    participant User
+    participant Client
+    participant Server
+    participant NostrRelays
+    
+    User->>Client: Initiate Login
+    Client->>Server: Request Challenge (POST /api/auth/nostr)
+    Server-->>Client: Return Challenge
+    Client->>Client: Generate Signature (Sign Challenge with Nostr Key)
+    Client->>Server: Submit Signature (POST /api/auth/nostr/verify)
+    Server->>Server: Verify Signature
+    Server-->>Client: Return JWT Token
+    Client->>Client: Store Token in localStorage
+    Client->>Client: Include Token in Subsequent Requests
+```
+
+## Nostr Authentication
+
+[Nostr (Notes and Other Stuff Transmitted by Relays)](https://github.com/nostr-protocol/nostr) is a decentralized protocol that enables censorship-resistant and globally-distributed social media. In this application, Nostr is used for authentication.
+
+### Nostr Keys
+
+Nostr uses public key cryptography:
+
+- **Public Key**: Serves as the user's identity (converted to npub format for user-facing display)
+- **Private Key**: Used to sign messages (kept secret, never shared with the server)
+
+### Authentication Flow
+
+#### 1. Request Challenge
+
+The client requests a challenge from the server:
+
+```typescript
+async function requestNostrChallenge(pubkey: string): Promise<string> {
+  const response = await fetch(buildApiUrl(API_ENDPOINTS.AUTH_NOSTR), {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json'
+    },
+    body: JSON.stringify({ pubkey })
+  });
+  
+  if (!response.ok) {
+    throw new Error(`Failed to request challenge: ${response.status} ${response.statusText}`);
+  }
+  
+  const data = await response.json();
+  return data.challenge;
+}
+```
+
+#### 2. Sign Challenge
+
+The client signs the challenge using the Nostr private key:
+
+```typescript
+async function signChallenge(challenge: string, privateKey: string): Promise<string> {
+  // Convert hex private key to Uint8Array if needed
+  const privateKeyBytes = typeof privateKey === 'string' && privateKey.startsWith('nsec')
+    ? nip19.decode(privateKey).data
+    : privateKey;
+  
+  // Sign the challenge
+  const signatureBytes = await nobleSecp256k1.schnorr.sign(
+    Buffer.from(challenge, 'utf8'),
+    privateKeyBytes
+  );
+  
+  // Convert to hex
+  return Buffer.from(signatureBytes).toString('hex');
+}
+```
+
+#### 3. Verify Signature
+
+The client sends the signature to the server for verification:
+
+```typescript
+async function verifyNostrSignature(pubkey: string, challenge: string, signature: string): Promise<AuthToken> {
+  const response = await fetch(buildApiUrl(API_ENDPOINTS.AUTH_NOSTR_VERIFY), {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json'
+    },
+    body: JSON.stringify({
+      pubkey,
+      challenge,
+      signature
+    })
+  });
+  
+  if (!response.ok) {
+    throw new Error(`Failed to verify signature: ${response.status} ${response.statusText}`);
+  }
+  
+  const data = await response.json();
+  return {
+    token: data.token,
+    expiresAt: data.expiresAt
+  };
+}
+```
+
+#### 4. Store Token
+
+Upon successful verification, the client stores the token:
+
+```typescript
+function storeAuthToken(pubkey: string, token: string): void {
+  localStorage.setItem('nostr_pubkey', pubkey);
+  localStorage.setItem('nostr_token', token);
+}
+```
+
+## Nostr Auth Service (`client/services/NostrAuthService.ts`)
+
+The Nostr Auth Service manages the authentication flow:
+
+```typescript
+class NostrAuthService {
+  private static instance: NostrAuthService;
+  private pubkey: string | null = null;
+  private token: string | null = null;
+  private expiresAt: number | null = null;
+  private authStatusListeners: Set<(isAuthenticated: boolean) => void> = new Set();
+  
+  private constructor() {
+    // Load from local storage if available
+    this.pubkey = localStorage.getItem('nostr_pubkey');
+    this.token = localStorage.getItem('nostr_token');
+    const expiresAtStr = localStorage.getItem('nostr_token_expires');
+    this.expiresAt = expiresAtStr ? parseInt(expiresAtStr, 10) : null;
+  }
+  
+  static getInstance(): NostrAuthService {
+    if (!NostrAuthService.instance) {
+      NostrAuthService.instance = new NostrAuthService();
+    }
+    return NostrAuthService.instance;
+  }
+  
+  // Check if authenticated
+  isAuthenticated(): boolean {
+    // Check if token exists
+    if (!this.token || !this.pubkey) {
+      return false;
+    }
+    
+    // Check if token is expired
+    if (this.expiresAt && Date.now() > this.expiresAt) {
+      this.logout(); // Auto-logout if token is expired
+      return false;
+    }
+    
+    return true;
+  }
+  
+  // Get public key
+  getPubkey(): string | null {
+    return this.pubkey;
+  }
+  
+  // Login with Nostr
+  async login(privateKey: string): Promise<boolean> {
+    try {
+      // Decode private key if in nsec format
+      const privateKeyBytes = privateKey.startsWith('nsec')
+        ? nip19.decode(privateKey).data
+        : privateKey;
+      
+      // Get public key from private key
+      const pubkey = nobleSecp256k1.schnorr.getPublicKey(privateKeyBytes);
+      const pubkeyHex = Buffer.from(pubkey).toString('hex');
+      
+      // Request challenge
+      const challenge = await requestNostrChallenge(pubkeyHex);
+      
+      // Sign challenge
+      const signature = await signChallenge(challenge, privateKeyBytes);
+      
+      // Verify signature
+      const { token, expiresAt } = await verifyNostrSignature(pubkeyHex, challenge, signature);
+      
+      // Store token
+      this.pubkey = pubkeyHex;
+      this.token = token;
+      this.expiresAt = expiresAt;
+      
+      // Save to local storage
+      localStorage.setItem('nostr_pubkey', pubkeyHex);
+      localStorage.setItem('nostr_token', token);
+      localStorage.setItem('nostr_token_expires', expiresAt.toString());
+      
+      // Notify listeners
+      this.notifyStatusChange(true);
+      
+      return true;
+    } catch (error) {
+      logger.error('Login failed:', error);
+      return false;
+    }
+  }
+  
+  // Logout
+  async logout(): Promise<void> {
+    // Skip if not authenticated
+    if (!this.isAuthenticated()) {
+      return;
+    }
+    
+    try {
+      // Call logout endpoint
+      await fetch(buildApiUrl(API_ENDPOINTS.AUTH_NOSTR_LOGOUT), {
+        method: 'POST',
+        headers: getAuthHeaders()
+      });
+    } catch (error) {
+      logger.error('Logout request failed:', error);
+    }
+    
+    // Clear local storage
+    localStorage.removeItem('nostr_pubkey');
+    localStorage.removeItem('nostr_token');
+    localStorage.removeItem('nostr_token_expires');
+    
+    // Clear memory
+    this.pubkey = null;
+    this.token = null;
+    this.expiresAt = null;
+    
+    // Notify listeners
+    this.notifyStatusChange(false);
+  }
+  
+  // Add authentication status listener
+  addStatusListener(listener: (isAuthenticated: boolean) => void): () => void {
+    this.authStatusListeners.add(listener);
+    
+    // Call listener with current status
+    listener(this.isAuthenticated());
+    
+    // Return unsubscribe function
+    return () => {
+      this.authStatusListeners.delete(listener);
+    };
+  }
+  
+  // Notify status change
+  private notifyStatusChange(isAuthenticated: boolean): void {
+    this.authStatusListeners.forEach(listener => {
+      try {
+        listener(isAuthenticated);
+      } catch (error) {
+        logger.error('Error in auth status listener:', error);
+      }
+    });
+  }
+}
+```
+
+## Authentication Headers
+
+The application includes authentication headers in all authenticated requests:
+
+```typescript
+// From client/core/api.ts
+export function getAuthHeaders(): HeadersInit {
+    const headers: HeadersInit = {
+        'Content-Type': 'application/json'
+    };
+    
+    const pubkey = localStorage.getItem('nostr_pubkey');
+    const token = localStorage.getItem('nostr_token');
+    if (pubkey && token) {
+        headers['X-Nostr-Pubkey'] = pubkey;
+        headers['Authorization'] = `Bearer ${token}`;
+    }
+    return headers;
+}
+```
+
+## Token Format
+
+The JWT token returned by the server has the following structure:
+
+```
+header.payload.signature
+```
+
+### Header
+```json
+{
+  "alg": "HS256",
+  "typ": "JWT"
+}
+```
+
+### Payload
+```json
+{
+  "sub": "npub...", // Nostr public key (npub format)
+  "iat": 1615479082, // Issued at timestamp
+  "exp": 1615565482, // Expiration timestamp
+  "nbf": 1615479082  // Not before timestamp
+}
+```
+
+The token is signed by the server using a secret key.
+
+## Authentication UI
+
+The authentication UI includes:
+
+1. Login form that accepts Nostr private key (nsec) or extension connection
+2. Logout button when authenticated
+3. Authentication status indicator
+
+```typescript
+// Login form component
+function LoginForm({ onLogin }: { onLogin: () => void }) {
+  const [privateKey, setPrivateKey] = useState('');
+  const [isLoading, setIsLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  
+  const handleSubmit = async (e: React.FormEvent) => {
+    e.preventDefault();
+    setIsLoading(true);
+    setError(null);
+    
+    try {
+      const success = await NostrAuthService.getInstance().login(privateKey);
+      
+      if (success) {
+        onLogin();
+      } else {
+        setError('Login failed. Please check your private key and try again.');
+      }
+    } catch (error) {
+      setError('An error occurred during login. Please try again.');
+    } finally {
+      setIsLoading(false);
+    }
+  };
+  
+  return (
+    <form onSubmit={handleSubmit}>
+      <h2>Login with Nostr</h2>
+      <div>
+        <label htmlFor="privateKey">Private Key (nsec):</label>
+        <input
+          type="password"
+          id="privateKey"
+          value={privateKey}
+          onChange={(e) => setPrivateKey(e.target.value)}
+          required
+        />
+      </div>
+      {error && <div className="error">{error}</div>}
+      <button type="submit" disabled={isLoading}>
+        {isLoading ? 'Logging in...' : 'Login'}
+      </button>
+    </form>
+  );
+}
+```
+
+## Security Considerations
+
+### Private Key Handling
+
+Private keys are sensitive data and should be handled carefully:
+
+1. Never store private keys in local storage or cookies
+2. Only use private keys temporarily in memory during the signing process
+3. Encourage users to use browser extensions that handle key management securely
+
+### Token Security
+
+JWT tokens are stored in localStorage, which has some security implications:
+
+1. Tokens are vulnerable to XSS attacks
+2. Tokens should have a relatively short expiration time
+3. The server should maintain a token blacklist for revoked tokens
+
+### Cross-Origin Considerations
+
+To protect against CSRF and other cross-origin attacks:
+
+1. Use SameSite=Strict cookies if cookie-based authentication is added
+2. Implement proper CORS headers on the server
+3. Use CSRF tokens for state-changing operations
+
+## Authentication Integration
+
+The authentication service integrates with the application in several ways:
+
+### API Requests
+
+```typescript
+async function fetchProtectedResource() {
+  const response = await fetch(buildApiUrl('/api/protected-resource'), {
+    headers: getAuthHeaders()
+  });
+  
+  if (response.status === 401) {
+    // Handle authentication error
+    NostrAuthService.getInstance().logout();
+    window.location.href = '/login';
+    return;
+  }
+  
+  return await response.json();
+}
+```
+
+### UI Components
+
+```typescript
+function AuthStatusIndicator() {
+  const [isAuthenticated, setIsAuthenticated] = useState(false);
+  
+  useEffect(() => {
+    const authService = NostrAuthService.getInstance();
+    
+    // Subscribe to auth status changes
+    const unsubscribe = authService.addStatusListener((status) => {
+      setIsAuthenticated(status);
+    });
+    
+    // Cleanup
+    return unsubscribe;
+  }, []);
+  
+  return (
+    <div className="auth-status">
+      {isAuthenticated ? (
+        <span className="status-authenticated">Authenticated</span>
+      ) : (
+        <span className="status-unauthenticated">Not Authenticated</span>
+      )}
+    </div>
+  );
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [REST Endpoints](rest-endpoints.md) - REST API details
+- [WebSocket Protocol](websocket-protocol.md) - WebSocket protocol details
+- [Error Handling](../core/error-handling.md) - Error handling patterns
\ No newline at end of file
diff --git a/docs/clientdocs/apis/payload-formats.md b/docs/clientdocs/apis/payload-formats.md
new file mode 100644
index 00000000..9472d2fa
--- /dev/null
+++ b/docs/clientdocs/apis/payload-formats.md
@@ -0,0 +1,649 @@
+# Payload Formats
+
+This document provides a comprehensive specification of the payload formats used in API communications between the client and server. Well-defined payload formats are essential for ensuring consistent data exchange and interoperability between components.
+
+## API Payload Format Specifications
+
+### Common Format Conventions
+
+All API payloads follow these general conventions:
+
+1. **JSON Format**: All REST API requests and responses use JSON format
+2. **Consistent Naming**: Snake_case is used for server responses, camelCase for client requests
+3. **Error Format**: Standard error response format across all endpoints
+4. **Timestamps**: ISO 8601 format (YYYY-MM-DDTHH:MM:SS.sssZ)
+5. **IDs**: String IDs for all resources, even if they are numeric
+
+### Error Response Format
+
+All API errors follow a standard format:
+
+```json
+{
+  "error": true,
+  "code": "ERROR_CODE",
+  "message": "Human-readable error message",
+  "details": {
+    // Additional error-specific details
+  }
+}
+```
+
+Common error codes:
+- `INVALID_REQUEST` - Request format or parameters are invalid
+- `UNAUTHORIZED` - Authentication required or failed
+- `FORBIDDEN` - Permission denied
+- `NOT_FOUND` - Requested resource not found
+- `SERVER_ERROR` - Internal server error
+- `VALIDATION_ERROR` - Input validation failed
+
+### Graph API Payloads
+
+#### Graph Data Request
+
+**Endpoint**: `GET /api/graph/data`
+
+**Response Format**:
+```json
+{
+  "nodes": [
+    {
+      "id": "1",
+      "data": {
+        "position": {
+          "x": 0,
+          "y": 0,
+          "z": 0
+        },
+        "velocity": {
+          "x": 0,
+          "y": 0,
+          "z": 0
+        },
+        "metadata": {
+          "name": "Node Name",
+          "lastModified": 1615478982,
+          "links": ["2", "3"],
+          "references": ["ref1", "ref2"],
+          "fileSize": 1024,
+          "hyperlinkCount": 5
+        }
+      }
+    }
+  ],
+  "edges": [
+    {
+      "source": "1",
+      "target": "2",
+      "data": {
+        "weight": 1,
+        "type": "reference"
+      }
+    }
+  ],
+  "metadata": {
+    "timestamp": 1615478982,
+    "version": "1.0"
+  }
+}
+```
+
+#### Paginated Graph Data Request
+
+**Endpoint**: `GET /api/graph/data/paginated?page=1&pageSize=100`
+
+**Response Format**:
+```json
+{
+  "nodes": [
+    {
+      "id": "1",
+      "data": {
+        "position": {"x": 0, "y": 0, "z": 0},
+        "velocity": {"x": 0, "y": 0, "z": 0},
+        "metadata": {
+          "name": "Node Name",
+          "lastModified": 1615478982,
+          "links": ["2", "3"],
+          "references": ["ref1", "ref2"],
+          "fileSize": 1024,
+          "hyperlinkCount": 5
+        }
+      }
+    }
+  ],
+  "edges": [
+    {
+      "source": "1",
+      "target": "2",
+      "data": {
+        "weight": 1,
+        "type": "reference"
+      }
+    }
+  ],
+  "metadata": {
+    "timestamp": 1615478982,
+    "version": "1.0"
+  },
+  "totalPages": 10,
+  "currentPage": 1,
+  "totalItems": 987,
+  "pageSize": 100
+}
+```
+
+#### Graph Update Request
+
+**Endpoint**: `POST /api/graph/update`
+
+**Request Format**:
+```json
+{
+  "nodes": [
+    {
+      "id": "1",
+      "data": {
+        "position": {"x": 10, "y": 5, "z": 3},
+        "velocity": {"x": 0, "y": 0, "z": 0}
+      }
+    }
+  ]
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "updated_nodes": 1,
+  "timestamp": 1615479082
+}
+```
+
+### Settings API Payloads
+
+#### Get Settings Request
+
+**Endpoint**: `GET /api/user-settings`
+
+**Response Format**:
+```json
+{
+  "visualization": {
+    "nodes": {
+      "size": 1,
+      "color": "#4CAF50"
+    },
+    "edges": {
+      "thickness": 0.25,
+      "color": "#E0E0E0"
+    },
+    "labels": {
+      "visible": true,
+      "size": 1,
+      "color": "#FFFFFF",
+      "visibilityThreshold": 0.5
+    }
+  },
+  "physics": {
+    "enabled": true,
+    "gravity": 0.1,
+    "friction": 0.1
+  },
+  "network": {
+    "reconnectDelay": 1000
+  }
+}
+```
+
+#### Update Settings Request
+
+**Endpoint**: `POST /api/user-settings`
+
+**Request Format**:
+```json
+{
+  "visualization": {
+    "nodes": {
+      "size": 1.5,
+      "color": "#FF4444"
+    }
+  }
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "timestamp": 1615479082
+}
+```
+
+### Authentication API Payloads
+
+#### Nostr Authentication Request
+
+**Endpoint**: `POST /api/auth/nostr`
+
+**Request Format**:
+```json
+{
+  "pubkey": "npub..."
+}
+```
+
+**Response Format**:
+```json
+{
+  "challenge": "...",
+  "timestamp": 1615479082
+}
+```
+
+#### Verify Nostr Authentication
+
+**Endpoint**: `POST /api/auth/nostr/verify`
+
+**Request Format**:
+```json
+{
+  "pubkey": "npub...",
+  "signature": "...",
+  "challenge": "..."
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "token": "jwt-token-here",
+  "expires_at": 1615565482
+}
+```
+
+## WebSocket Payload Formats
+
+### Text Message Formats
+
+WebSocket communication uses both text (JSON) and binary messages. Text messages are used for control messages and metadata:
+
+#### Request Initial Data
+
+**Client  Server**:
+```json
+{
+  "type": "requestInitialData",
+  "timestamp": 1615479082
+}
+```
+
+#### Loading Status
+
+**Server  Client**:
+```json
+{
+  "type": "loading",
+  "message": "Loading graph data...",
+  "timestamp": 1615479082
+}
+```
+
+#### Updates Started
+
+**Server  Client**:
+```json
+{
+  "type": "updatesStarted",
+  "timestamp": 1615479082
+}
+```
+
+#### Connection Established
+
+**Server  Client**:
+```json
+{
+  "type": "connection_established",
+  "timestamp": 1615479082
+}
+```
+
+#### Enable Randomization
+
+**Client  Server**:
+```json
+{
+  "type": "enableRandomization",
+  "enabled": true,
+  "timestamp": 1615479082
+}
+```
+
+#### Heartbeat (Ping)
+
+**Client  Server**:
+```json
+{
+  "type": "ping",
+  "timestamp": 1615479082
+}
+```
+
+### Binary Message Format
+
+Binary messages are used for efficient position updates:
+
+#### Binary Position Update Format
+
+Each node's position data is encoded in a fixed-length binary format:
+
+| Field      | Type    | Size (bytes) | Description               |
+|------------|---------|--------------|---------------------------|
+| Node ID    | uint16  | 2            | Numeric ID for the node   |
+| Position X | float32 | 4            | X coordinate              |
+| Position Y | float32 | 4            | Y coordinate              |
+| Position Z | float32 | 4            | Z coordinate              |
+| Velocity X | float32 | 4            | X velocity component      |
+| Velocity Y | float32 | 4            | Y velocity component      |
+| Velocity Z | float32 | 4            | Z velocity component      |
+| **Total**  |         | **26**       | **Bytes per node**        |
+
+The binary message consists of multiple node entries concatenated together:
+
+```
+[Node1][Node2][Node3]...
+```
+
+Where each `[NodeN]` is 26 bytes as specified above.
+
+## Data Transformation
+
+The client applies transformations to convert between the API payload formats and the internal data structures:
+
+### Graph Data Transformation
+
+```typescript
+// From client/core/types.ts
+export function transformGraphData(data: any): GraphData {
+  // Transform nodes
+  const nodes = data.nodes.map(node => ({
+    id: node.id,
+    data: {
+      position: new Vector3(
+        node.data.position.x,
+        node.data.position.y,
+        node.data.position.z
+      ),
+      velocity: new Vector3(
+        node.data.velocity?.x || 0,
+        node.data.velocity?.y || 0,
+        node.data.velocity?.z || 0
+      ),
+      metadata: node.data.metadata
+    }
+  }));
+  
+  // Transform edges
+  const edges = data.edges.map(edge => ({
+    source: edge.source,
+    target: edge.target,
+    data: edge.data || {}
+  }));
+  
+  return {
+    nodes,
+    edges,
+    metadata: data.metadata || {}
+  };
+}
+```
+
+### Settings Transformation
+
+```typescript
+// From client/state/settings.ts
+export function transformSettings(data: any): Settings {
+  // Apply default values for missing properties
+  return deepMerge(defaultSettings, data);
+}
+
+// Helper function to perform deep merge
+function deepMerge<T>(target: T, source: any): T {
+  const result = { ...target };
+  
+  // For each property in source
+  for (const key in source) {
+    // If property is an object, recursively merge
+    if (isObject(source[key]) && isObject(result[key])) {
+      result[key] = deepMerge(result[key], source[key]);
+    } else if (source[key] !== undefined) {
+      // Otherwise directly assign if not undefined
+      result[key] = source[key];
+    }
+  }
+  
+  return result;
+}
+```
+
+## Validation
+
+Payload validation is performed to ensure data integrity:
+
+### Request Validation
+
+```typescript
+// Validate settings update payload
+function validateSettingsPayload(data: any): ValidationResult {
+  const errors = [];
+  
+  // Check that data is an object
+  if (!data || typeof data !== 'object') {
+    return {
+      valid: false,
+      errors: [{ message: 'Settings must be an object' }]
+    };
+  }
+  
+  // Validate visualization settings
+  if (data.visualization) {
+    if (data.visualization.nodes) {
+      // Validate node size
+      if (data.visualization.nodes.size !== undefined) {
+        const size = data.visualization.nodes.size;
+        if (typeof size !== 'number' || size < 0.1 || size > 10) {
+          errors.push({
+            path: 'visualization.nodes.size',
+            message: 'Node size must be a number between 0.1 and 10'
+          });
+        }
+      }
+      
+      // Validate node color
+      if (data.visualization.nodes.color !== undefined) {
+        const color = data.visualization.nodes.color;
+        if (typeof color !== 'string' || !color.match(/^#[0-9A-F]{6}$/i)) {
+          errors.push({
+            path: 'visualization.nodes.color',
+            message: 'Node color must be a valid hex color (e.g., "#FF0000")'
+          });
+        }
+      }
+    }
+    
+    // Similar validation for other settings...
+  }
+  
+  return {
+    valid: errors.length === 0,
+    errors
+  };
+}
+```
+
+### Response Validation
+
+```typescript
+// Validate graph data response
+function validateGraphDataResponse(data: any): ValidationResult {
+  const errors = [];
+  
+  // Check that data is an object
+  if (!data || typeof data !== 'object') {
+    return {
+      valid: false,
+      errors: [{ message: 'Response must be an object' }]
+    };
+  }
+  
+  // Check nodes array
+  if (!Array.isArray(data.nodes)) {
+    errors.push({
+      path: 'nodes',
+      message: 'Nodes must be an array'
+    });
+  } else {
+    // Validate each node
+    data.nodes.forEach((node, index) => {
+      if (!node.id) {
+        errors.push({
+          path: `nodes[${index}].id`,
+          message: 'Node must have an ID'
+        });
+      }
+      
+      if (!node.data || typeof node.data !== 'object') {
+        errors.push({
+          path: `nodes[${index}].data`,
+          message: 'Node must have data object'
+        });
+      } else {
+        // Validate position
+        if (!node.data.position || 
+            typeof node.data.position !== 'object' ||
+            typeof node.data.position.x !== 'number' ||
+            typeof node.data.position.y !== 'number' ||
+            typeof node.data.position.z !== 'number') {
+          errors.push({
+            path: `nodes[${index}].data.position`,
+            message: 'Node position must be an object with numeric x, y, z properties'
+          });
+        }
+      }
+    });
+  }
+  
+  // Check edges array
+  if (!Array.isArray(data.edges)) {
+    errors.push({
+      path: 'edges',
+      message: 'Edges must be an array'
+    });
+  } else {
+    // Validate each edge
+    data.edges.forEach((edge, index) => {
+      if (!edge.source) {
+        errors.push({
+          path: `edges[${index}].source`,
+          message: 'Edge must have a source'
+        });
+      }
+      
+      if (!edge.target) {
+        errors.push({
+          path: `edges[${index}].target`,
+          message: 'Edge must have a target'
+        });
+      }
+    });
+  }
+  
+  return {
+    valid: errors.length === 0,
+    errors
+  };
+}
+```
+
+## Binary Data Encoding/Decoding
+
+For efficient communication, binary data formats are used:
+
+### Binary Position Encoding
+
+```typescript
+// Encode node positions to binary
+function encodeNodePositions(nodes: NodePositionUpdate[]): ArrayBuffer {
+  const buffer = new ArrayBuffer(nodes.length * 26); // 26 bytes per node
+  const view = new DataView(buffer);
+  
+  nodes.forEach((node, index) => {
+    const offset = index * 26;
+    
+    // Write node ID as u16
+    view.setUint16(offset, parseInt(node.id, 10), true);
+    
+    // Write position (3 x f32)
+    view.setFloat32(offset + 2, node.position.x, true);
+    view.setFloat32(offset + 6, node.position.y, true);
+    view.setFloat32(offset + 10, node.position.z, true);
+    
+    // Write velocity (3 x f32)
+    view.setFloat32(offset + 14, node.velocity?.x || 0, true);
+    view.setFloat32(offset + 18, node.velocity?.y || 0, true);
+    view.setFloat32(offset + 22, node.velocity?.z || 0, true);
+  });
+  
+  return buffer;
+}
+```
+
+### Binary Position Decoding
+
+```typescript
+// Decode binary position data
+function decodeNodePositions(buffer: ArrayBuffer): NodePositionUpdate[] {
+  const view = new DataView(buffer);
+  const nodeCount = Math.floor(buffer.byteLength / 26);
+  const nodes: NodePositionUpdate[] = [];
+  
+  for (let i = 0; i < nodeCount; i++) {
+    const offset = i * 26;
+    
+    // Read node ID
+    const id = view.getUint16(offset, true).toString();
+    
+    // Read position
+    const position = new Vector3(
+      view.getFloat32(offset + 2, true),
+      view.getFloat32(offset + 6, true),
+      view.getFloat32(offset + 10, true)
+    );
+    
+    // Read velocity
+    const velocity = new Vector3(
+      view.getFloat32(offset + 14, true),
+      view.getFloat32(offset + 18, true),
+      view.getFloat32(offset + 22, true)
+    );
+    
+    nodes.push({
+      id,
+      position,
+      velocity
+    });
+  }
+  
+  return nodes;
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [REST Endpoints](rest-endpoints.md) - REST API details
+- [WebSocket Protocol](websocket-protocol.md) - WebSocket protocol details
+- [Authentication](authentication.md) - Authentication mechanisms
\ No newline at end of file
diff --git a/docs/clientdocs/apis/rest-endpoints.md b/docs/clientdocs/apis/rest-endpoints.md
new file mode 100644
index 00000000..8b031672
--- /dev/null
+++ b/docs/clientdocs/apis/rest-endpoints.md
@@ -0,0 +1,546 @@
+# REST API Endpoints
+
+This document provides comprehensive documentation of the REST API endpoints used by the client to communicate with the server. Each endpoint is fully documented with its URL, method, parameters, request format, response format, error handling, and example usage.
+
+## API Base URL
+
+The API base URL is constructed dynamically based on the environment:
+
+```typescript
+// From client/core/api.ts
+export function buildApiUrl(path: string): string {
+    const protocol = window.location.protocol;
+    const host = window.location.hostname;
+    // Check if we're in production (any visionflow.info domain)
+    const isProduction = host.endsWith('visionflow.info');
+    const base = isProduction 
+        ? `${protocol}//${host}`
+        : `${protocol}//${host}:4000`;
+    return `${base}${path}`;
+}
+```
+
+- Production: `https://[hostname]/api/...`
+- Development: `http://[hostname]:4000/api/...`
+
+## Authentication
+
+Many API endpoints require authentication. The client handles this through the `getAuthHeaders` function:
+
+```typescript
+// From client/core/api.ts
+export function getAuthHeaders(): HeadersInit {
+    const headers: HeadersInit = {
+        'Content-Type': 'application/json'
+    };
+    
+    const pubkey = localStorage.getItem('nostr_pubkey');
+    const token = localStorage.getItem('nostr_token');
+    if (pubkey && token) {
+        headers['X-Nostr-Pubkey'] = pubkey;
+        headers['Authorization'] = `Bearer ${token}`;
+    }
+    return headers;
+}
+```
+
+Authentication is handled through Nostr authentication tokens, which are included in the request headers.
+
+## API Endpoints
+
+### Graph Data Endpoints
+
+#### Get Graph Data
+
+Retrieves the complete graph data structure.
+
+**Endpoint**: `/api/graph/data`
+**Method**: `GET`
+**Authentication**: Required
+
+**Response Format**:
+```json
+{
+  "nodes": [
+    {
+      "id": "1",
+      "data": {
+        "position": {"x": 0, "y": 0, "z": 0},
+        "velocity": {"x": 0, "y": 0, "z": 0},
+        "metadata": {
+          "name": "Node Name",
+          "lastModified": 1615478982,
+          "links": ["2", "3"],
+          "references": ["ref1", "ref2"],
+          "fileSize": 1024,
+          "hyperlinkCount": 5
+        }
+      }
+    }
+  ],
+  "edges": [
+    {
+      "source": "1",
+      "target": "2",
+      "data": {
+        "weight": 1,
+        "type": "reference"
+      }
+    }
+  ],
+  "metadata": {
+    "timestamp": 1615478982,
+    "version": "1.0"
+  }
+}
+```
+
+**Error Responses**:
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Get Paginated Graph Data
+
+Retrieves graph data with pagination support for handling large datasets.
+
+**Endpoint**: `/api/graph/data/paginated`
+**Method**: `GET`
+**Authentication**: Required
+
+**Query Parameters**:
+- `page` (number, required): Page number, starting from 1
+- `pageSize` (number, optional): Number of items per page, default 100
+
+**Response Format**:
+```json
+{
+  "nodes": [...],
+  "edges": [...],
+  "metadata": {...},
+  "totalPages": 10,
+  "currentPage": 1,
+  "totalItems": 987,
+  "pageSize": 100
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid pagination parameters
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Update Graph
+
+Updates graph data on the server.
+
+**Endpoint**: `/api/graph/update`
+**Method**: `POST`
+**Authentication**: Required
+
+**Request Body**:
+```json
+{
+  "nodes": [
+    {
+      "id": "1",
+      "data": {
+        "position": {"x": 10, "y": 5, "z": 3},
+        "velocity": {"x": 0, "y": 0, "z": 0}
+      }
+    }
+  ]
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "updatedCount": 1,
+  "timestamp": 1615479082
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid update data
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+### Settings Endpoints
+
+#### Get User Settings
+
+Retrieves the user's settings.
+
+**Endpoint**: `/api/user-settings`
+**Method**: `GET`
+**Authentication**: Required
+
+**Response Format**:
+```json
+{
+  "visualization": {
+    "nodes": {
+      "size": 1,
+      "color": "#4CAF50"
+    },
+    "edges": {
+      "thickness": 0.25,
+      "color": "#E0E0E0"
+    },
+    "labels": {
+      "visible": true,
+      "size": 1,
+      "color": "#FFFFFF",
+      "visibilityThreshold": 0.5
+    }
+  },
+  "physics": {
+    "enabled": true,
+    "gravity": 0.1,
+    "friction": 0.1
+  },
+  "network": {
+    "reconnectDelay": 1000
+  }
+}
+```
+
+**Error Responses**:
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Update User Settings
+
+Updates the user's settings.
+
+**Endpoint**: `/api/user-settings`
+**Method**: `POST`
+**Authentication**: Required
+
+**Request Body**:
+```json
+{
+  "visualization": {
+    "nodes": {
+      "size": 1.5,
+      "color": "#FF4444"
+    }
+  }
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "timestamp": 1615479082
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid settings data
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Get Visualization Settings
+
+Retrieves visualization-specific settings.
+
+**Endpoint**: `/api/user-settings/visualization`
+**Method**: `GET`
+**Authentication**: Required
+
+**Response Format**:
+```json
+{
+  "nodes": {
+    "size": 1,
+    "color": "#4CAF50"
+  },
+  "edges": {
+    "thickness": 0.25,
+    "color": "#E0E0E0"
+  },
+  "labels": {
+    "visible": true,
+    "size": 1,
+    "color": "#FFFFFF",
+    "visibilityThreshold": 0.5
+  }
+}
+```
+
+**Error Responses**:
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Update Visualization Settings
+
+Updates visualization-specific settings.
+
+**Endpoint**: `/api/user-settings/visualization`
+**Method**: `POST`
+**Authentication**: Required
+
+**Request Body**:
+```json
+{
+  "nodes": {
+    "size": 1.5,
+    "color": "#FF4444"
+  }
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "timestamp": 1615479082
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid settings data
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+### WebSocket Control Endpoints
+
+#### Get WebSocket Settings
+
+Retrieves WebSocket connection settings.
+
+**Endpoint**: `/api/settings/websocket`
+**Method**: `GET`
+**Authentication**: Required
+
+**Response Format**:
+```json
+{
+  "reconnectDelay": 1000,
+  "maxReconnectAttempts": 5,
+  "compressionEnabled": true,
+  "binaryProtocolEnabled": true
+}
+```
+
+**Error Responses**:
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Update WebSocket Settings
+
+Updates WebSocket connection settings.
+
+**Endpoint**: `/api/settings/websocket`
+**Method**: `POST`
+**Authentication**: Required
+
+**Request Body**:
+```json
+{
+  "reconnectDelay": 2000,
+  "compressionEnabled": false
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "timestamp": 1615479082
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid settings data
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+#### WebSocket Control
+
+Controls WebSocket server behavior.
+
+**Endpoint**: `/api/websocket/control`
+**Method**: `POST`
+**Authentication**: Required
+
+**Request Body**:
+```json
+{
+  "command": "restart",
+  "parameters": {
+    "clearCache": true
+  }
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "message": "WebSocket server restarting",
+  "timestamp": 1615479082
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid command
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+### File Endpoints
+
+#### Get File Content
+
+Retrieves file content from the server.
+
+**Endpoint**: `/api/files/{path}`
+**Method**: `GET`
+**Authentication**: Required
+
+**Path Parameters**:
+- `path` (string, required): Path to the file
+
+**Response Format**: File content with appropriate MIME type
+
+**Error Responses**:
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `404 Not Found`: File not found
+- `500 Internal Server Error`: Server-side error occurred
+
+### Authentication Endpoints
+
+#### Nostr Authentication
+
+Initiates Nostr authentication.
+
+**Endpoint**: `/api/auth/nostr`
+**Method**: `POST`
+**Authentication**: Not required
+
+**Request Body**:
+```json
+{
+  "pubkey": "npub..."
+}
+```
+
+**Response Format**:
+```json
+{
+  "challenge": "...",
+  "timestamp": 1615479082
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid public key
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Verify Nostr Authentication
+
+Verifies Nostr authentication.
+
+**Endpoint**: `/api/auth/nostr/verify`
+**Method**: `POST`
+**Authentication**: Not required
+
+**Request Body**:
+```json
+{
+  "pubkey": "npub...",
+  "signature": "...",
+  "challenge": "..."
+}
+```
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "token": "jwt-token-here",
+  "expiresAt": 1615565482
+}
+```
+
+**Error Responses**:
+- `400 Bad Request`: Invalid verification data
+- `401 Unauthorized`: Signature verification failed
+- `500 Internal Server Error`: Server-side error occurred
+
+#### Logout
+
+Logs out the user by invalidating the current token.
+
+**Endpoint**: `/api/auth/nostr/logout`
+**Method**: `POST`
+**Authentication**: Required
+
+**Response Format**:
+```json
+{
+  "success": true,
+  "message": "Logged out successfully"
+}
+```
+
+**Error Responses**:
+- `401 Unauthorized`: Authentication token is missing or invalid
+- `500 Internal Server Error`: Server-side error occurred
+
+## Error Handling
+
+All API responses follow a consistent error format:
+
+```json
+{
+  "error": true,
+  "code": "RESOURCE_NOT_FOUND",
+  "message": "The requested resource was not found",
+  "details": {
+    "resource": "file",
+    "path": "/path/to/file"
+  }
+}
+```
+
+Common error codes:
+- `UNAUTHORIZED`: Authentication required or failed
+- `INVALID_REQUEST`: Request format is invalid
+- `RESOURCE_NOT_FOUND`: Requested resource does not exist
+- `SERVER_ERROR`: Internal server error occurred
+- `VALIDATION_ERROR`: Request validation failed
+
+## Client Implementation
+
+In the client code, API requests are typically made using the Fetch API with helper functions:
+
+```typescript
+async function fetchGraphData(page = 1, pageSize = 100) {
+  const url = buildApiUrl(`${API_ENDPOINTS.GRAPH_PAGINATED}?page=${page}&pageSize=${pageSize}`);
+  const response = await fetch(url, {
+    method: 'GET',
+    headers: getAuthHeaders()
+  });
+  
+  if (!response.ok) {
+    throw new Error(`Failed to fetch graph data: ${response.status} ${response.statusText}`);
+  }
+  
+  return await response.json();
+}
+```
+
+## API Versioning
+
+The current API does not use explicit versioning in the URL path. Future API versions may include version numbers in the path (e.g., `/api/v2/graph/data`).
+
+## Next Sections
+
+For more detailed information, refer to:
+- [WebSocket Protocol](websocket-protocol.md) - WebSocket communication details
+- [Payload Formats](payload-formats.md) - Request/response payload formats
+- [Authentication](authentication.md) - Authentication mechanisms
\ No newline at end of file
diff --git a/docs/clientdocs/apis/websocket-protocol.md b/docs/clientdocs/apis/websocket-protocol.md
new file mode 100644
index 00000000..bf28e536
--- /dev/null
+++ b/docs/clientdocs/apis/websocket-protocol.md
@@ -0,0 +1,502 @@
+# WebSocket Protocol
+
+This document provides a comprehensive specification of the WebSocket protocol used for real-time communication between the client and server. It covers connection management, message formats, binary protocols, and error handling.
+
+## Connection Establishment
+
+The WebSocket connection URL is constructed dynamically based on the environment:
+
+```typescript
+// From client/core/api.ts
+export function buildWsUrl(): string {
+    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
+    const host = window.location.hostname;
+    // Check if we're in production (any visionflow.info domain)
+    const isProduction = host.endsWith('visionflow.info');
+    
+    if (isProduction) {
+        // For production, use relative path to ensure proper proxy handling
+        return `${protocol}//${host}/wss`;
+    } else {
+        // For development, use port 4000 as specified in the documentation
+        return `${protocol}//${host}:4000/wss`;
+    }
+}
+```
+
+- Production: `wss://[hostname]/wss`
+- Development: `ws://[hostname]:4000/wss`
+
+### Connection States
+
+The WebSocket connection goes through several states:
+
+```mermaid
+stateDiagram-v2
+    [*] --> DISCONNECTED
+    DISCONNECTED --> CONNECTING: connect()
+    CONNECTING --> CONNECTED: onopen
+    CONNECTED --> RECONNECTING: onclose / connection lost
+    RECONNECTING --> CONNECTING: retry
+    RECONNECTING --> FAILED: max retries
+    FAILED --> DISCONNECTED: manual reconnect
+    CONNECTING --> FAILED: connection error
+```
+
+### Reconnection Strategy
+
+The client implements an exponential backoff reconnection strategy:
+
+```typescript
+private getReconnectDelay(): number {
+    // Exponential backoff with max delay
+    const delay = Math.min(
+        this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts),
+        this.maxReconnectDelay
+    );
+    // Add some jitter
+    return delay + (Math.random() * 500);
+}
+```
+
+- Initial delay: 1000ms (1 second)
+- Max delay: 30000ms (30 seconds)
+- Max reconnection attempts: 5
+
+## Message Types
+
+The WebSocket protocol supports both text and binary messages:
+
+### Text Messages (JSON)
+
+Text messages use JSON format for control messages and metadata:
+
+#### Request for Initial Data
+
+**Client  Server**:
+```json
+{
+  "type": "requestInitialData",
+  "timestamp": 1615479082
+}
+```
+
+#### Loading Status
+
+**Server  Client**:
+```json
+{
+  "type": "loading",
+  "message": "Loading graph data...",
+  "timestamp": 1615479082
+}
+```
+
+#### Updates Started
+
+**Server  Client**:
+```json
+{
+  "type": "updatesStarted",
+  "timestamp": 1615479082
+}
+```
+
+#### Connection Established
+
+**Server  Client**:
+```json
+{
+  "type": "connection_established",
+  "timestamp": 1615479082
+}
+```
+
+#### Enable Randomization
+
+**Client  Server**:
+```json
+{
+  "type": "enableRandomization",
+  "enabled": true,
+  "timestamp": 1615479082
+}
+```
+
+#### Heartbeat (Ping)
+
+**Client  Server**:
+```json
+{
+  "type": "ping",
+  "timestamp": 1615479082
+}
+```
+
+### Binary Messages
+
+Binary messages are used for efficient transmission of position data. The binary protocol is designed for high performance with minimal overhead.
+
+#### Binary Format Specification
+
+Each node's position data is encoded in a fixed-length binary format:
+
+| Field      | Type    | Size (bytes) | Description                   |
+|------------|---------|--------------|-------------------------------|
+| Node ID    | uint16  | 2            | Numeric ID for the node       |
+| Position X | float32 | 4            | X coordinate                  |
+| Position Y | float32 | 4            | Y coordinate                  |
+| Position Z | float32 | 4            | Z coordinate                  |
+| Velocity X | float32 | 4            | X velocity component          |
+| Velocity Y | float32 | 4            | Y velocity component          |
+| Velocity Z | float32 | 4            | Z velocity component          |
+| **Total**  |         | **26**       | **Bytes per node**            |
+
+The binary message consists of multiple node entries concatenated together:
+
+```
+[Node1][Node2][Node3]...
+```
+
+Where each `[NodeN]` is 26 bytes as specified above.
+
+#### Binary Message Encoding
+
+```typescript
+// Calculate buffer size based on node count (26 bytes per node)
+const bufferSize = updates.length * BYTES_PER_NODE;
+const buffer = new ArrayBuffer(bufferSize);
+const dataView = new DataView(buffer);
+
+// Start writing node data from the beginning
+let offset = 0;
+
+updates.forEach(update => {
+    const id = parseInt(update.id, 10); 
+    
+    // Write node ID as u16 
+    dataView.setUint16(offset, id, true);
+    offset += 2;
+
+    // Write position
+    dataView.setFloat32(offset, position.x, true);
+    dataView.setFloat32(offset + 4, position.y, true);
+    dataView.setFloat32(offset + 8, position.z, true);
+    offset += 12;
+    
+    // Write velocity
+    dataView.setFloat32(offset, velocity.x, true);
+    dataView.setFloat32(offset + 4, velocity.y, true);
+    dataView.setFloat32(offset + 8, velocity.z, true);
+    offset += 12;
+});
+```
+
+#### Binary Message Decoding
+
+```typescript
+const dataView = new DataView(decompressedBuffer);
+            
+// Calculate how many complete nodes we can read
+const nodeCount = Math.floor(decompressedBuffer.byteLength / BYTES_PER_NODE);
+const nodes = [];
+
+for (let i = 0; i < nodeCount; i++) {
+    // Calculate offset for this node
+    const offset = i * BYTES_PER_NODE;
+    
+    // Read node ID (u16)
+    const id = dataView.getUint16(offset, true);
+    
+    // Create Vector3 objects for position and velocity
+    const position = new Vector3(
+        dataView.getFloat32(offset + 2, true),      // x
+        dataView.getFloat32(offset + 6, true),      // y
+        dataView.getFloat32(offset + 10, true)      // z
+    );
+    
+    const velocity = new Vector3(
+        dataView.getFloat32(offset + 14, true),     // x
+        dataView.getFloat32(offset + 18, true),     // y
+        dataView.getFloat32(offset + 22, true)      // z
+    );
+    
+    nodes.push({ id, position, velocity });
+}
+```
+
+## Compression
+
+For larger messages, compression is applied to reduce bandwidth:
+
+```typescript
+private compressIfNeeded(buffer: ArrayBuffer): ArrayBuffer {
+    if (buffer.byteLength > COMPRESSION_THRESHOLD) {
+        try {
+            const compressed = pako.deflate(new Uint8Array(buffer));
+            return compressed.buffer;
+        } catch (error) {
+            logger.warn('Compression failed, using original data:', createErrorMetadata(error));
+            return buffer;
+        }
+    }
+    return buffer;
+}
+
+private tryDecompress(buffer: ArrayBuffer): ArrayBuffer {
+    try {
+        const decompressed = pako.inflate(new Uint8Array(buffer));
+        if (decompressed.length < 8 || decompressed.length % 4 !== 0) {
+            return buffer;
+        }
+        return decompressed.buffer;
+    } catch (error) {
+        return buffer;
+    }
+}
+```
+
+- Compression is applied to messages larger than 1KB
+- The pako library (zlib implementation) is used for compression
+- Decompression is attempted on all incoming binary messages
+- If decompression fails, the original buffer is used
+
+## Message Flow Sequence
+
+The typical message flow sequence follows this pattern:
+
+```mermaid
+sequenceDiagram
+    participant Client
+    participant Server
+    
+    Client->>Server: WebSocket Connection
+    Server-->>Client: connection_established
+    Client->>Server: requestInitialData
+    Server-->>Client: loading
+    Server-->>Client: Binary Position Data
+    Server-->>Client: updatesStarted
+    
+    loop Real-time Updates
+        Server-->>Client: Binary Position Data
+        Client->>Server: Binary Position Updates
+    end
+    
+    loop Heartbeat
+        Client->>Server: ping
+    end
+```
+
+## Connection Maintenance
+
+### Heartbeat Mechanism
+
+A heartbeat mechanism is used to keep the connection alive and detect disconnections:
+
+```typescript
+private setupHeartbeat(): void {
+    this.clearHeartbeat(); // Clear any existing heartbeat
+    this.heartbeatInterval = window.setInterval(() => {
+        // Send a simple ping message to keep the connection alive
+        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
+            try {
+                this.sendMessage({ type: 'ping', timestamp: Date.now() });
+            } catch (err) {
+                logger.error('Failed to send heartbeat ping:', createErrorMetadata(err));
+            }
+        } else if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
+            // If socket is closed but heartbeat still running, attempt reconnect
+            logger.warn('Heartbeat detected closed socket, attempting reconnect');
+            this.handleReconnect();
+        }
+    }, 10000); // Send ping every 10 seconds
+}
+```
+
+- Heartbeat interval: 10 seconds
+- The heartbeat is used to detect zombie connections
+- If a heartbeat fails to send, reconnection is attempted
+
+## Performance Optimizations
+
+The WebSocket implementation includes several performance optimizations:
+
+### Position Deadbanding
+
+To reduce the number of updates sent, position changes below a threshold are filtered out:
+
+```typescript
+// Position update deadband threshold
+const POSITION_DEADBAND = 0.15; // Units in world space (0.15 = 15cm)
+
+// Apply deadband filtering - only include if position has changed significantly
+const lastPosition = this.lastNodePositions.get(id);
+let positionChanged = true;
+
+if (lastPosition) {
+    // Calculate squared distance to avoid unnecessary sqrt
+    const dx = position.x - lastPosition.x;
+    const dy = position.y - lastPosition.y;
+    const dz = position.z - lastPosition.z;
+    const distanceSquared = dx*dx + dy*dy + dz*dz;
+    
+    // Only consider position changed if it exceeds our threshold
+    positionChanged = distanceSquared > (POSITION_DEADBAND * POSITION_DEADBAND);
+}
+```
+
+### Update Throttling
+
+Updates are throttled to prevent overwhelming the network or rendering:
+
+```typescript
+// Process updates with throttling
+if (this.updateThrottler.shouldUpdate()) {
+    this.processPendingNodeUpdates();
+} else {
+    // Schedule processing if not already scheduled
+    if (this.nodeUpdateTimer === null) {
+        this.nodeUpdateTimer = window.setTimeout(() => {
+            this.processPendingNodeUpdates();
+            this.nodeUpdateTimer = null;
+        }, this.updateThrottler.getTimeUntilNextUpdate());
+    }
+}
+```
+
+- Update throttle rate: 150ms (~6-7fps)
+- Updates are batched to improve performance
+
+## Error Handling
+
+The WebSocket implementation includes robust error handling:
+
+### Connection Errors
+
+```typescript
+this.ws.onerror = (event: Event): void => {
+    logger.error('WebSocket error:', createDataMetadata(event));
+    // onerror is typically followed by onclose, so handling reconnection there
+};
+
+this.ws.onclose = (event: CloseEvent): void => {
+    logger.warn('WebSocket closed', createDataMetadata({
+        code: event.code,
+        reason: event.reason || "No reason provided",
+        initialDataReceived: this.initialDataReceived,
+        wasConnected: this.connectionState === ConnectionState.CONNECTED,
+        url: this.url
+    }));
+    
+    // Clear heartbeat on connection close
+    this.clearHeartbeat();
+    
+    if (this.connectionStatusHandler) {
+        this.connectionStatusHandler(false);
+    }
+    
+    this.handleReconnect();
+};
+```
+
+### Message Processing Errors
+
+```typescript
+try {
+    // Process message
+} catch (error) {
+    logger.error('Failed to process binary message:', createErrorMetadata(error));
+}
+```
+
+## Debugging and Monitoring
+
+The WebSocket implementation includes extensive debugging and monitoring capabilities:
+
+### Debug Logging
+
+```typescript
+if (debugState.isWebsocketDebugEnabled()) {
+    logger.debug('WebSocket message received:', message);
+}
+```
+
+### Connection Status Tracking
+
+```typescript
+public onConnectionStatusChange(handler: (status: boolean) => void): void {
+    this.connectionStatusHandler = handler;
+    if (this.connectionState === ConnectionState.CONNECTED && handler) {
+        handler(true);
+    }
+}
+```
+
+### Loading Status Tracking
+
+```typescript
+public onLoadingStatusChange(handler: (isLoading: boolean, message?: string) => void): void {
+    this.loadingStatusHandler = handler;
+    
+    // Immediately notify with current state if already loading
+    if (this.isLoading && handler) {
+        handler(true);
+    }
+}
+```
+
+## WebSocket Service Implementation
+
+The WebSocket service is implemented as a singleton to ensure a single connection is maintained:
+
+```typescript
+export class WebSocketService {
+    private static instance: WebSocketService | null = null;
+    
+    public static getInstance(): WebSocketService {
+        if (!WebSocketService.instance) {
+            WebSocketService.instance = new WebSocketService();
+        }
+        return WebSocketService.instance;
+    }
+    
+    // ...implementation details...
+}
+```
+
+## Server-Side Randomization
+
+The client can control server-side node position randomization:
+
+```typescript
+public enableRandomization(enabled: boolean): void {
+    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
+        if (enabled) {
+            logger.warn('WebSocket not connected, attempting to reconnect before enabling randomization');
+            // Try to reconnect
+            this.connect().then(() => {
+                // If connection succeeded, try again
+                if (this.ws?.readyState === WebSocket.OPEN) {
+                    logger.info(`${enabled ? 'Enabling' : 'Disabling'} server-side position randomization after reconnection`);
+                    this.sendMessage({ type: 'enableRandomization', enabled });
+                }
+            }).catch(e => {
+                logger.error('Failed to reconnect for randomization:', createErrorMetadata(e));
+            });
+        } else {
+            logger.warn('WebSocket not connected, cannot disable randomization');
+        }
+        return;
+    }
+
+    logger.info(`${enabled ? 'Enabling' : 'Disabling'} server-side position randomization`);
+    this.sendMessage({ type: 'enableRandomization', enabled });
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [REST Endpoints](rest-endpoints.md) - REST API details
+- [Payload Formats](payload-formats.md) - Request/response payload formats
+- [Authentication](authentication.md) - Authentication mechanisms
\ No newline at end of file
diff --git a/docs/clientdocs/architecture/component-architecture.md b/docs/clientdocs/architecture/component-architecture.md
new file mode 100644
index 00000000..7088278a
--- /dev/null
+++ b/docs/clientdocs/architecture/component-architecture.md
@@ -0,0 +1,388 @@
+# Component Architecture
+
+This document details the client component architecture, describing the relationships between major components, their responsibilities, and dependencies.
+
+## Component Overview
+
+The client is organized into a modular component architecture with clear separation of concerns. Each component has well-defined responsibilities and interfaces.
+
+```mermaid
+flowchart TB
+    subgraph Core
+        API[API Client]
+        State[State Store]
+        Events[Event Emitter]
+        Logger[Logger]
+        Constants[Constants]
+        Types[Types]
+        Utils[Utilities]
+    end
+    
+    subgraph Rendering
+        RenderManager[Render Manager]
+        Scene[Scene]
+        NodeManager[Node Manager]
+        EdgeManager[Edge Manager]
+        TextRenderer[Text Renderer]
+        MetadataViz[Metadata Visualizer]
+        Materials[Materials]
+        Factories[Factories]
+    end
+    
+    subgraph UI
+        ControlPanel[Control Panel]
+        Settings[Settings UI]
+        Styles[Styles]
+    end
+    
+    subgraph XR
+        XRInit[XR Initializer]
+        Hands[Hand Interaction]
+        XRSession[XR Session Manager]
+    end
+    
+    subgraph Network
+        WSService[WebSocket Service]
+        GraphDataManager[Graph Data Manager]
+    end
+    
+    API <--> State
+    State --> Events
+    Events --> RenderManager
+    Events --> NodeManager
+    Events --> EdgeManager
+    Events --> ControlPanel
+    
+    WSService --> GraphDataManager
+    GraphDataManager --> State
+    
+    NodeManager --> MetadataViz
+    NodeManager --> TextRenderer
+    
+    RenderManager --> Scene
+    RenderManager --> NodeManager
+    RenderManager --> EdgeManager
+    
+    XRInit --> XRSession
+    XRSession --> Hands
+    Hands --> NodeManager
+    
+    Settings --> State
+    
+    Logger -.-> API
+    Logger -.-> WSService
+    Logger -.-> RenderManager
+    Logger -.-> NodeManager
+    Logger -.-> XRSession
+    
+    Utils -.-> API
+    Utils -.-> WSService
+    Utils -.-> RenderManager
+    Utils -.-> NodeManager
+```
+
+## Core Components
+
+### API Client (`client/core/api.ts`)
+Provides a centralized interface for communicating with the server REST API.
+
+**Responsibilities:**
+- Build API URLs for different endpoints
+- Handle authentication headers
+- Provide helper functions for API requests
+
+**Key Dependencies:**
+- Constants for API endpoints
+- Types for request/response formats
+
+### State Management
+Manages application state and provides reactive updates.
+
+**Key Components:**
+- `SettingsStore` (`client/state/SettingsStore.ts`) - Manages application settings
+- `GraphData` (`client/state/graphData.ts`) - Manages graph data state
+- `SettingsObserver` (`client/state/SettingsObserver.ts`) - Observes setting changes
+
+**Responsibilities:**
+- Store and validate application settings
+- Track graph data and node positions
+- Propagate state changes to subscribers
+
+### Event Emitter (`client/utils/eventEmitter.ts`)
+Provides a pub/sub mechanism for cross-component communication.
+
+**Responsibilities:**
+- Register event listeners
+- Dispatch events to listeners
+- Unregister listeners when no longer needed
+
+### Logger (`client/core/logger.ts`)
+Provides centralized logging with different levels.
+
+**Responsibilities:**
+- Log messages with appropriate severity
+- Add metadata to log messages
+- Control log output based on debug settings
+
+## Rendering Components
+
+### Render Manager (`client/rendering/renderManager.ts`)
+Orchestrates the rendering pipeline and manages Three.js integration.
+
+**Responsibilities:**
+- Initialize Three.js scene, camera, and renderer
+- Manage render loop and animation frame requests
+- Coordinate between different rendering components
+
+**Key Dependencies:**
+- Three.js
+- Node Manager
+- Edge Manager
+- Scene setup
+
+### Node Manager Facade (`client/rendering/node/NodeManagerFacade.ts`)
+Provides a unified interface to the node management subsystem.
+
+**Responsibilities:**
+- Coordinate between node geometry, instance, metadata, and interaction managers
+- Update node positions and states
+- Handle XR interactions with nodes
+
+**Component Structure:**
+```mermaid
+flowchart TB
+    NodeManagerFacade --> NodeGeometryManager
+    NodeManagerFacade --> NodeInstanceManager
+    NodeManagerFacade --> NodeMetadataManager
+    NodeManagerFacade --> NodeInteractionManager
+    NodeManagerFacade --> NodeIdentityManager
+    
+    NodeInstanceManager --> THREE.InstancedMesh
+    NodeMetadataManager --> TextRenderer
+    NodeInteractionManager --> XRHandInteraction
+```
+
+**Key Dependencies:**
+- Three.js
+- WebSocket for position updates
+- Settings for visual configuration
+
+### Edge Manager (`client/rendering/EdgeManager.ts`)
+Manages the visual representation of edges connecting nodes.
+
+**Responsibilities:**
+- Create and update edge geometries
+- Manage edge materials and appearance
+- Update edge positions based on connected nodes
+
+**Key Dependencies:**
+- Three.js
+- Node Manager (for node positions)
+- Settings for visual configuration
+
+### Text Renderer (`client/rendering/textRenderer.ts`)
+Renders text labels in 3D space.
+
+**Responsibilities:**
+- Create and position text elements
+- Manage text appearance and visibility
+- Handle SDF font rendering for crisp text
+
+**Key Dependencies:**
+- Three.js
+- SDF font generation
+- Settings for text configuration
+
+## Network Components
+
+### WebSocket Service (`client/websocket/websocketService.ts`)
+Manages WebSocket connection and communication with the server.
+
+**Responsibilities:**
+- Establish and maintain WebSocket connection
+- Send and receive WebSocket messages
+- Handle binary protocol for position updates
+- Manage reconnection on connection loss
+
+**Key Dependencies:**
+- Browser WebSocket API
+- Binary data handling for position updates
+- Settings for connection configuration
+
+### Graph Data Manager (`client/state/graphData.ts`)
+Manages graph data loading, updates, and state.
+
+**Responsibilities:**
+- Load initial graph data
+- Process graph updates
+- Track node and edge data
+- Manage binary position updates
+
+**Key Dependencies:**
+- WebSocket Service
+- API Client
+- Settings for graph configuration
+
+## XR Components
+
+### XR Initializer (`client/xr/xrInitializer.ts`)
+Initializes WebXR capabilities and sessions.
+
+**Responsibilities:**
+- Check WebXR availability
+- Initialize WebXR sessions
+- Set up XR reference space
+
+**Key Dependencies:**
+- Three.js
+- WebXR API
+- XR Session Manager
+
+### XR Session Manager (`client/xr/xrSessionManager.ts`)
+Manages WebXR sessions and state.
+
+**Responsibilities:**
+- Start and end XR sessions
+- Track XR session state
+- Manage XR reference spaces
+
+**Key Dependencies:**
+- Three.js WebXR integration
+- Hand Interaction manager
+- WebXR API
+
+### Hand Interaction (`client/xr/handInteraction.ts`)
+Handles XR hand tracking and interactions.
+
+**Responsibilities:**
+- Track hand positions
+- Handle grabbing and manipulation gestures
+- Interact with nodes and UI elements in XR
+
+**Key Dependencies:**
+- WebXR Hand Input API
+- Node Manager
+- XR Session Manager
+
+## UI Components
+
+### Control Panel (`client/ui/ModularControlPanel.ts`)
+Provides user interface controls for the application.
+
+**Responsibilities:**
+- Display control panels
+- Handle user input
+- Update application state based on input
+
+**Key Dependencies:**
+- DOM manipulation
+- Settings Store
+- Event Emitter
+
+### Settings UI
+Provides interfaces for configuring application settings.
+
+**Responsibilities:**
+- Display settings options
+- Validate user input
+- Update settings in Settings Store
+
+**Key Dependencies:**
+- DOM manipulation
+- Settings Store
+- Settings validation
+
+## Component Initialization Sequence
+
+The following sequence diagram shows the initialization flow of major components:
+
+```mermaid
+sequenceDiagram
+    participant App
+    participant API
+    participant WSService
+    participant RenderManager
+    participant NodeManager
+    participant GraphDataManager
+    
+    App->>API: Initialize
+    App->>WSService: Initialize
+    App->>RenderManager: Initialize
+    RenderManager->>NodeManager: Initialize
+    App->>GraphDataManager: Initialize
+    GraphDataManager->>API: Fetch initial data
+    GraphDataManager->>WSService: Register for updates
+    WSService-->>GraphDataManager: Real-time updates
+    GraphDataManager-->>NodeManager: Node position updates
+    NodeManager-->>RenderManager: Render updates
+```
+
+## Component Communication Patterns
+
+The application uses several communication patterns:
+
+1. **Direct method calls** - For tightly coupled components
+2. **Event-based communication** - For loosely coupled components
+3. **State subscriptions** - For components that need to react to state changes
+4. **WebSocket messages** - For server-client communication
+
+## Interface Contracts
+
+Key interface contracts between components:
+
+### Node Manager Interface
+```typescript
+interface NodeManagerInterface {
+  updateNodes(nodes: { id: string, data: NodeData }[]): void;
+  updateNodePositions(nodes: { id: string, data: { position: Vector3, velocity?: Vector3 } }[]): void;
+  handleHandInteraction(hand: XRHandWithHaptics): void;
+  update(deltaTime: number): void;
+  setXRMode(enabled: boolean): void;
+  handleSettingsUpdate(settings: Settings): void;
+  dispose(): void;
+}
+```
+
+### WebSocket Service Interface
+```typescript
+interface WebSocketServiceInterface {
+  connect(): Promise<void>;
+  sendMessage(message: any): void;
+  onBinaryMessage(callback: BinaryMessageCallback): void;
+  onConnectionStatusChange(handler: (status: boolean) => void): void;
+  enableRandomization(enabled: boolean): void;
+  sendNodeUpdates(updates: NodeUpdate[]): void;
+  getConnectionStatus(): ConnectionState;
+  dispose(): void;
+}
+```
+
+### Graph Data Manager Interface
+```typescript
+interface GraphDataManagerInterface {
+  fetchInitialData(): Promise<void>;
+  updateGraphData(data: any): void;
+  enableBinaryUpdates(): void;
+  updateNodePositions(positions: Float32Array): void;
+  getGraphData(): GraphData;
+  getNode(id: string): Node | undefined;
+  subscribe(listener: (data: GraphData) => void): () => void;
+  subscribeToPositionUpdates(listener: (positions: Float32Array) => void): () => void;
+  clear(): void;
+}
+```
+
+## Dependency Injection
+
+The application uses a mix of dependency injection patterns:
+
+1. **Singleton Registry** - Most manager classes provide static getInstance() methods
+2. **Constructor Injection** - Some components take dependencies in constructors
+3. **Method Injection** - Some methods accept dependencies as parameters
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Data Flow](data-flow.md) - Detailed data flow patterns
+- [State Management](state-management.md) - State management approach
+- [Rendering Pipeline](../components/rendering-pipeline.md) - Rendering component details
\ No newline at end of file
diff --git a/docs/clientdocs/architecture/data-flow.md b/docs/clientdocs/architecture/data-flow.md
new file mode 100644
index 00000000..416ede06
--- /dev/null
+++ b/docs/clientdocs/architecture/data-flow.md
@@ -0,0 +1,342 @@
+# Data Flow
+
+This document details the flow of data through the client application, including request/response patterns, real-time updates, and internal data transformations.
+
+## High-Level Data Flow
+
+The client application follows several distinct data flow patterns based on the type of interaction:
+
+1. **Initial Data Loading** - Loading graph data when the application starts
+2. **Real-time Updates** - Streaming position updates via WebSocket
+3. **User Interaction** - User-initiated changes through the UI or XR
+4. **Settings Changes** - Updates to application settings
+5. **Rendering Loop** - Continuous rendering and state updates
+
+```mermaid
+flowchart TB
+    subgraph Input Sources
+        UserInput[User Input]
+        ServerData[Server Data]
+        XRInput[XR Input]
+        InitialLoad[Initial Load]
+    end
+
+    subgraph Processing
+        State[State Management]
+        Physics[Physics Calculation]
+        GraphManager[Graph Data Manager]
+        NodeManager[Node Manager]
+    end
+
+    subgraph Output
+        Renderer[Renderer]
+        ServerUpdate[Server Update]
+        UI[UI Update]
+    end
+
+    InitialLoad --> GraphManager
+    UserInput --> State
+    ServerData --> GraphManager
+    XRInput --> State
+
+    GraphManager --> State
+    State --> NodeManager
+    State --> Physics
+    Physics --> NodeManager
+    NodeManager --> Renderer
+    State --> UI
+    NodeManager --> ServerUpdate
+```
+
+## Initial Data Loading Flow
+
+When the application starts, it loads initial graph data from the server.
+
+```mermaid
+sequenceDiagram
+    participant Client
+    participant API
+    participant GraphDataManager
+    participant State
+    participant NodeManager
+    participant Renderer
+
+    Client->>GraphDataManager: fetchInitialData()
+    GraphDataManager->>API: GET /api/graph/data/paginated?page=1
+    API-->>GraphDataManager: Response (first page of data)
+    GraphDataManager->>State: updateGraphData()
+    State-->>NodeManager: updateNodes()
+    NodeManager-->>Renderer: updateNodePositions()
+    
+    GraphDataManager->>API: GET /api/graph/data/paginated?page=2...n
+    API-->>GraphDataManager: Response (additional pages)
+    GraphDataManager->>State: updateGraphData()
+    State-->>NodeManager: updateNodes()
+    NodeManager-->>Renderer: updateNodePositions()
+```
+
+### Pagination Strategy
+
+The client uses pagination to load large datasets efficiently:
+
+1. First, load page 1 with a small page size (typically 100 items)
+2. Notify UI to start showing data immediately
+3. Load remaining pages in the background
+4. Aggregate data as pages arrive
+5. Process any edges with missing nodes when all pages are loaded
+
+This approach balances initial load performance with completeness of data.
+
+## WebSocket Real-time Updates
+
+Real-time position updates occur through a binary WebSocket protocol.
+
+```mermaid
+sequenceDiagram
+    participant Server
+    participant WebSocketService
+    participant GraphDataManager
+    participant NodeManager
+    participant Renderer
+
+    Server->>WebSocketService: Binary Position Data
+    WebSocketService->>WebSocketService: Decompress Data
+    WebSocketService->>WebSocketService: Parse Binary Format
+    WebSocketService->>GraphDataManager: Process Node Updates
+    GraphDataManager->>NodeManager: updateNodePositions()
+    NodeManager->>Renderer: Update Instanced Mesh
+```
+
+### Binary Protocol
+
+The WebSocket binary protocol has a compact format:
+
+- **Node ID**: 2 bytes (u16)
+- **Position**: 12 bytes (3  f32 for X, Y, Z)
+- **Velocity**: 12 bytes (3  f32 for X, Y, Z)
+
+Total bytes per node: 26 bytes
+
+This compact format allows efficient transmission of position updates for many nodes.
+
+### Throttling and Batching
+
+Position updates are throttled and batched to balance responsiveness with performance:
+
+1. Updates are collected in a buffer
+2. Updates are processed at most every 16ms (approximately 60fps)
+3. Position deadbanding filters out minor changes
+4. Binary updates are compressed when over 1KB
+
+## User Interaction Flow
+
+User interaction through UI or XR controllers triggers changes that propagate through the system.
+
+```mermaid
+sequenceDiagram
+    participant User
+    participant UI
+    participant XRController
+    participant NodeManager
+    participant GraphDataManager
+    participant WebSocketService
+    participant Server
+
+    alt UI Interaction
+        User->>UI: Trigger Action
+        UI->>NodeManager: updateNode()
+    else XR Interaction
+        User->>XRController: Move Controller
+        XRController->>NodeManager: handleHandInteraction()
+    end
+    
+    NodeManager->>GraphDataManager: queueNodeUpdate()
+    GraphDataManager->>WebSocketService: sendNodeUpdates()
+    WebSocketService->>Server: Binary Position Update
+    Server-->>WebSocketService: Acknowledge Update
+```
+
+### Node Selection and Manipulation
+
+When a user selects and manipulates a node:
+
+1. Selection is tracked in NodeInteractionManager
+2. Position changes are applied locally first for immediate feedback
+3. Changes are sent to the server via WebSocket
+4. Server validates and broadcasts changes
+5. Changes are received back by all clients including the originator
+
+## Settings Changes Flow
+
+Settings changes follow a validation and notification pattern.
+
+```mermaid
+sequenceDiagram
+    participant User
+    participant SettingsUI
+    participant SettingsStore
+    participant SettingsObserver
+    participant Components
+    participant API
+
+    User->>SettingsUI: Change Setting
+    SettingsUI->>SettingsStore: updateSetting()
+    SettingsStore->>SettingsStore: validateSetting()
+    SettingsStore->>SettingsObserver: notifyChange()
+    SettingsObserver->>Components: handleSettingsUpdate()
+    SettingsStore->>API: POST /api/user-settings
+    API-->>SettingsStore: Response
+```
+
+### Settings Validation and Persistence
+
+Settings changes undergo several steps:
+
+1. Validation against schema
+2. Local state update
+3. Notification to observers
+4. Persistence to server
+5. Acknowledgment from server
+
+## Rendering Loop Data Flow
+
+The rendering loop continuously updates the visual representation based on current state.
+
+```mermaid
+sequenceDiagram
+    participant RenderLoop
+    participant NodeManager
+    participant EdgeManager
+    participant MetadataManager
+    participant Renderer
+
+    loop Animation Frame
+        RenderLoop->>NodeManager: update(deltaTime)
+        NodeManager->>EdgeManager: updateEdgePositions()
+        NodeManager->>MetadataManager: updateLabelPositions()
+        RenderLoop->>Renderer: render()
+    end
+```
+
+### Performance Optimization
+
+The rendering loop implements several optimization techniques:
+
+1. Request Animation Frame for timing
+2. Level of Detail (LOD) based on camera distance
+3. Visibility culling for off-screen objects
+4. Throttling of metadata updates
+5. Instanced rendering for nodes
+
+## State Management Flow
+
+The application state flows through a central state management system.
+
+```mermaid
+flowchart TB
+    subgraph StateManagement
+        SettingsStore
+        GraphDataManager
+        EventEmitter
+    end
+    
+    subgraph Sources
+        API
+        WebSocket
+        UserInput
+    end
+    
+    subgraph Consumers
+        RenderManager
+        NodeManager
+        EdgeManager
+        UIComponents
+    end
+    
+    API --> SettingsStore
+    API --> GraphDataManager
+    WebSocket --> GraphDataManager
+    UserInput --> SettingsStore
+    
+    SettingsStore --> EventEmitter
+    GraphDataManager --> EventEmitter
+    
+    EventEmitter --> RenderManager
+    EventEmitter --> NodeManager
+    EventEmitter --> EdgeManager
+    EventEmitter --> UIComponents
+```
+
+### State Synchronization
+
+Multiple strategies ensure state remains synchronized:
+
+1. Event-based notifications for state changes
+2. Subscription-based observation
+3. Polling for certain time-dependent updates
+4. WebSocket for server-initiated updates
+
+## Error Handling Flow
+
+Error handling follows a specific flow to ensure reliability.
+
+```mermaid
+flowchart TD
+    Error{Error Type}
+    Error -->|Network Error| RetryStrategy[Retry with Backoff]
+    Error -->|Data Error| DataValidation[Validate & Fix Data]
+    Error -->|Rendering Error| FallbackRender[Use Fallback Rendering]
+    
+    RetryStrategy -->|Success| NormalOperation[Resume Normal Operation]
+    RetryStrategy -->|Failure| Notification[Notify User]
+    
+    DataValidation -->|Recoverable| FixData[Fix Data Structure]
+    DataValidation -->|Unrecoverable| LogError[Log Error]
+    
+    FixData --> NormalOperation
+    FallbackRender --> NormalOperation
+```
+
+### Retry Strategies
+
+Network operations implement retry strategies:
+
+1. Exponential backoff with jitter
+2. Maximum retry count (typically 5)
+3. Circuit breaking to prevent cascading failures
+4. Graceful degradation for non-critical features
+
+## Data Transformation
+
+Several key data transformations occur within the application:
+
+### Graph Data Transformation
+
+```mermaid
+flowchart LR
+    RawServerData[Raw Server Data] --> ParseJSON[Parse JSON]
+    ParseJSON --> ValidateSchema[Validate Schema]
+    ValidateSchema --> TransformNodes[Transform Nodes]
+    TransformNodes --> TransformEdges[Transform Edges]
+    TransformEdges --> NormalizeIDs[Normalize IDs]
+    NormalizeIDs --> StoreInMap[Store in Maps]
+```
+
+### Binary Format Transformation
+
+```mermaid
+flowchart LR
+    BinaryData[Binary Data] --> Decompress[Decompress]
+    Decompress --> ParseHeader[Parse Header]
+    ParseHeader --> ReadNodeData[Read Node Data]
+    ReadNodeData --> CreateVectors[Create Vector3 Objects]
+    CreateVectors --> ApplyDeadband[Apply Deadband Filter]
+    ApplyDeadband --> BatchUpdates[Batch Updates]
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [State Management](state-management.md) - State management approach
+- [WebSocket Protocol](../apis/websocket-protocol.md) - WebSocket protocol details
+- [REST Endpoints](../apis/rest-endpoints.md) - REST API details
\ No newline at end of file
diff --git a/docs/clientdocs/architecture/overview.md b/docs/clientdocs/architecture/overview.md
new file mode 100644
index 00000000..013a7c09
--- /dev/null
+++ b/docs/clientdocs/architecture/overview.md
@@ -0,0 +1,167 @@
+# Client Architecture Overview
+
+This document provides a high-level overview of the LogseqSpringThing client architecture, its major components, and their interactions.
+
+## System Architecture
+
+The client is built as a modern TypeScript application that follows a component-based architecture. It integrates with Three.js for 3D rendering, WebXR for VR/AR capabilities, and communicates with the Rust backend server through REST APIs and WebSocket connections.
+
+```mermaid
+graph TB
+    subgraph Client Architecture
+        UI[User Interface Layer]
+        State[State Management]
+        API[API Layer]
+        Rendering[Rendering Engine]
+        WebSocket[WebSocket Client]
+        XR[XR Module]
+        
+        UI --> State
+        State --> Rendering
+        State --> API
+        API --> WebSocket
+        XR --> Rendering
+        XR --> State
+        WebSocket --> State
+    end
+    
+    subgraph Server Interface
+        REST[REST API]
+        WS[WebSocket Server]
+        Auth[Authentication]
+        
+        API --> REST
+        WebSocket --> WS
+        API --> Auth
+        WebSocket --> Auth
+    end
+```
+
+## Key Components
+
+### User Interface Layer
+The UI layer consists of modular components for controlling the application, configuring settings, and interacting with the 3D visualization. It includes the Modular Control Panel, settings interfaces, and visualization controls.
+
+### State Management
+State management is handled through a combination of state stores, event emitters, and observers. The primary state components include:
+- `SettingsStore` - Manages application settings with validation
+- `GraphData` - Manages the graph data structure
+- Various observers for state changes
+
+### API Layer
+The API layer handles communication with the server through REST endpoints, providing abstracted access to server functionality:
+- Authentication and authorization
+- Graph data retrieval and updates
+- File and settings management
+
+### Rendering Engine
+The rendering engine is built on Three.js and provides high-performance visualization of graph data:
+- Node and edge rendering with instancing for performance
+- Text rendering with SDF fonts
+- Metadata visualization
+- Camera controls and scene management
+
+### WebSocket Client
+The WebSocket client provides real-time communication with the server for:
+- Live position updates using binary protocol
+- Graph data synchronization
+- Event notifications
+
+### XR Module
+The XR module integrates WebXR capabilities for VR/AR experiences:
+- Hand tracking and interaction
+- XR session management
+- Spatial UI elements
+- XR-specific rendering optimizations
+
+## High-Level Data Flow
+
+```mermaid
+flowchart TB
+    subgraph Input
+        UserInput[User Input]
+        ServerData[Server Data]
+        XRInput[XR Input]
+    end
+    
+    subgraph Processing
+        State[State Management]
+        GraphCalculation[Graph Calculation]
+        PhysicsUpdate[Physics Update]
+    end
+    
+    subgraph Output
+        Rendering[Rendering]
+        ServerUpdate[Server Update]
+        UIUpdate[UI Update]
+    end
+    
+    UserInput --> State
+    ServerData --> State
+    XRInput --> State
+    
+    State --> GraphCalculation
+    State --> PhysicsUpdate
+    
+    GraphCalculation --> Rendering
+    PhysicsUpdate --> Rendering
+    State --> UIUpdate
+    State --> ServerUpdate
+```
+
+## Core Technology Stack
+
+- **TypeScript** - Primary development language
+- **Three.js** - 3D rendering engine
+- **WebGL** - Hardware-accelerated graphics
+- **WebXR** - VR/AR integration
+- **WebSockets** - Real-time communication
+- **Custom Shaders** - GLSL shaders for specialized rendering effects
+
+## Key Architectural Patterns
+
+1. **Singleton Pattern** - Used for manager classes to ensure single instance
+2. **Observer Pattern** - Used for state change notifications
+3. **Facade Pattern** - Used to simplify complex subsystems (e.g., NodeManagerFacade)
+4. **Factory Pattern** - Used for creating complex objects
+5. **Composition** - Used to build complex behaviors from simpler components
+
+## Cross-Cutting Concerns
+
+- **Logging** - Centralized logging system with multiple levels
+- **Error Handling** - Comprehensive error capture and recovery
+- **Performance Monitoring** - Resource and performance monitoring
+- **Caching** - Strategic caching of data and assets
+
+## Application Lifecycle
+
+```mermaid
+stateDiagram-v2
+    [*] --> Initialization
+    Initialization --> Loading: Configure
+    Loading --> Running: Assets Loaded
+    Running --> XR: Enter XR Mode
+    XR --> Running: Exit XR Mode
+    Running --> [*]: Shutdown
+    
+    Running --> Error: Exception
+    Error --> Running: Recover
+    Error --> Shutdown: Fatal Error
+    Shutdown --> [*]
+```
+
+## Communication with Server
+
+The client communicates with the server through two primary channels:
+
+1. **REST API** - For configuration, authentication, and data operations
+2. **WebSocket** - For real-time updates and streaming data
+
+This dual-channel approach allows for efficient communication patterns based on the nature of the data being exchanged.
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Component Architecture](component-architecture.md) - Detailed component relationships
+- [Data Flow](data-flow.md) - Detailed data flow patterns
+- [State Management](state-management.md) - State management approach
\ No newline at end of file
diff --git a/docs/clientdocs/architecture/state-management.md b/docs/clientdocs/architecture/state-management.md
new file mode 100644
index 00000000..2ac550c2
--- /dev/null
+++ b/docs/clientdocs/architecture/state-management.md
@@ -0,0 +1,355 @@
+# State Management
+
+This document details the state management patterns and mechanisms used throughout the client application. The application uses several complementary approaches to state management to handle different types of state.
+
+## State Management Overview
+
+The client application manages several types of state:
+
+1. **Application Settings** - User preferences and application configuration
+2. **Graph Data** - Nodes, edges, and metadata for the visualization
+3. **UI State** - Control panel state, selected items, and UI configuration
+4. **Rendering State** - Camera position, visibility settings, and rendering options
+5. **XR State** - XR session status, controller positions, and interaction state
+
+```mermaid
+flowchart TB
+    subgraph ApplicationState
+        Settings[Settings Store]
+        GraphData[Graph Data]
+        UIState[UI State]
+        RenderState[Rendering State]
+        XRState[XR State]
+    end
+    
+    subgraph StateConsumers
+        RenderManager
+        NodeManager
+        EdgeManager
+        ControlPanel
+        XRManager
+    end
+    
+    Settings --> RenderManager
+    Settings --> NodeManager
+    Settings --> EdgeManager
+    Settings --> ControlPanel
+    
+    GraphData --> NodeManager
+    GraphData --> EdgeManager
+    
+    UIState --> ControlPanel
+    RenderState --> RenderManager
+    XRState --> XRManager
+```
+
+## Key State Management Components
+
+### Settings Store (`client/state/SettingsStore.ts`)
+
+The Settings Store manages application settings with validation, persistence, and observation.
+
+**Key Features:**
+- Schema-based validation of settings
+- Persistence to local storage and server
+- Observable changes through subscribers
+- Default values for all settings
+
+**Implementation Pattern:**
+```typescript
+class SettingsStore {
+  private settings: Settings;
+  private observers: Set<Observer>;
+  
+  updateSetting(path: string, value: any): boolean {
+    // Validate against schema
+    // Update if valid
+    // Notify observers
+    // Persist to storage
+  }
+  
+  subscribe(observer: Observer): () => void {
+    // Add observer to set
+    // Return unsubscribe function
+  }
+}
+```
+
+### Graph Data Manager (`client/state/graphData.ts`)
+
+The Graph Data Manager maintains the state of the graph visualization data.
+
+**Key Features:**
+- Loads and processes graph data from server
+- Manages node and edge collections
+- Handles real-time position updates
+- Provides subscription mechanism for changes
+
+**State Transitions:**
+```mermaid
+stateDiagram-v2
+    [*] --> Empty
+    Empty --> Loading: fetchInitialData()
+    Loading --> PartiallyLoaded: First page loaded
+    PartiallyLoaded --> FullyLoaded: All pages loaded
+    FullyLoaded --> LiveUpdates: WebSocket connected
+    LiveUpdates --> FullyLoaded: WebSocket disconnected
+    LiveUpdates --> LiveUpdates: Position update
+    FullyLoaded --> Empty: clear()
+    LiveUpdates --> Empty: clear()
+```
+
+### Settings Observer (`client/state/SettingsObserver.ts`)
+
+The Settings Observer implements the Observer pattern to propagate settings changes.
+
+**Key Features:**
+- Subscribes to Settings Store
+- Filters and transforms settings updates
+- Distributes settings to appropriate components
+
+**Observer Pattern Implementation:**
+```mermaid
+sequenceDiagram
+    participant SettingsStore
+    participant SettingsObserver
+    participant Component
+    
+    Component->>SettingsObserver: subscribe(path, callback)
+    SettingsObserver->>SettingsStore: subscribe()
+    
+    Note over SettingsStore: Setting changes
+    
+    SettingsStore->>SettingsObserver: notifyUpdate(path, value)
+    SettingsObserver->>SettingsObserver: filterRelevantUpdates()
+    SettingsObserver->>Component: callback(value)
+```
+
+### Debug State (`client/core/debugState.ts`)
+
+Debug State manages debug flags and settings that control logging and development features.
+
+**Key Features:**
+- Feature flags for debug capabilities
+- Controlled access to debug state
+- Persistence of debug settings
+
+## State Persistence
+
+The application persists state in several ways:
+
+1. **Local Storage** - User preferences and UI state
+2. **Server Storage** - User settings synchronized to server
+3. **URL Parameters** - Shareable state in URL
+
+### Persistence Flow
+
+```mermaid
+flowchart TD
+    StateChange[State Change] --> ValidState{Is Valid?}
+    ValidState -->|Yes| LocalStorage[Store in Local Storage]
+    ValidState -->|Yes| SyncToServer{Sync to Server?}
+    ValidState -->|No| LogError[Log Error]
+    
+    SyncToServer -->|Yes| APICall[POST to API]
+    SyncToServer -->|No| Complete[Complete]
+    
+    APICall --> ServerResponse{Success?}
+    ServerResponse -->|Yes| Complete
+    ServerResponse -->|No| RetryStrategy[Apply Retry Strategy]
+    
+    RetryStrategy --> APICall
+```
+
+## State Change Propagation
+
+The application uses several mechanisms to propagate state changes:
+
+### Event Emitter (`client/utils/eventEmitter.ts`)
+
+A publish-subscribe system for loose coupling between components.
+
+**Key Features:**
+- Named events with typed payloads
+- Multiple subscribers per event
+- Ability to unsubscribe
+- Debugging and tracing capabilities
+
+**Usage Pattern:**
+```typescript
+// Publisher
+eventEmitter.emit('settings:changed', { path: 'rendering.quality', value: 'high' });
+
+// Subscriber
+const unsubscribe = eventEmitter.on('settings:changed', (data) => {
+  // Handle event
+});
+
+// Later
+unsubscribe();
+```
+
+### Direct Subscriptions
+
+Components can subscribe directly to state stores.
+
+**Example:**
+```typescript
+// Subscribe to graph data changes
+const unsubscribe = graphDataManager.subscribe((data) => {
+  // Update component based on new data
+});
+
+// Subscribe to settings changes
+const unsubscribe = settingsStore.subscribe((settings) => {
+  // Update component based on new settings
+});
+```
+
+### DOM Events
+
+Used for global application events and cross-component communication.
+
+**Example:**
+```typescript
+// Dispatch event
+window.dispatchEvent(new CustomEvent('graph-data-reset', { detail: {} }));
+
+// Listen for event
+window.addEventListener('graph-data-reset', () => {
+  // Handle event
+});
+```
+
+## State Initialization Sequence
+
+```mermaid
+sequenceDiagram
+    participant App
+    participant SettingsStore
+    participant GraphDataManager
+    participant WebSocketService
+    
+    App->>SettingsStore: initialize()
+    SettingsStore->>SettingsStore: loadDefaults()
+    SettingsStore->>SettingsStore: loadFromLocalStorage()
+    SettingsStore->>App: settingsLoaded
+    
+    App->>GraphDataManager: initialize()
+    App->>WebSocketService: initialize()
+    WebSocketService->>WebSocketService: connect()
+    
+    App->>GraphDataManager: fetchInitialData()
+    GraphDataManager->>App: initialDataLoaded
+    
+    WebSocketService->>WebSocketService: sendRequestInitialData()
+```
+
+## Settings Structure
+
+The settings are organized hierarchically by domain:
+
+```typescript
+interface Settings {
+  visualization: {
+    nodes: {
+      size: number;
+      color: string;
+      // ...
+    };
+    edges: {
+      thickness: number;
+      color: string;
+      // ...
+    };
+    labels: {
+      visible: boolean;
+      size: number;
+      // ...
+    };
+    // ...
+  };
+  physics: {
+    enabled: boolean;
+    gravity: number;
+    // ...
+  };
+  network: {
+    reconnectDelay: number;
+    // ...
+  };
+  // ...
+}
+```
+
+### Settings Validation
+
+Settings are validated against schemas that define:
+- Type constraints
+- Range constraints
+- Required properties
+- Default values
+
+Invalid settings are rejected with error messages.
+
+## State Immutability
+
+The application uses immutability patterns to prevent unexpected state changes:
+
+1. Creating new objects or arrays when updating state
+2. Using spread operators for shallow copies
+3. Using deep copy functions for nested structures
+4. Using getters without setters for read-only access
+
+**Example of Immutable Update:**
+```typescript
+// Instead of modifying state directly
+this.state.user.name = "New Name"; // BAD
+
+// Create a new state object
+this.state = {
+  ...this.state,
+  user: {
+    ...this.state.user,
+    name: "New Name"
+  }
+}; // GOOD
+```
+
+## Common State Patterns
+
+### State Initialization
+
+Components initialize state in a consistent pattern:
+
+1. Create with default values
+2. Load from persistent storage if available
+3. Subscribe to relevant state updates
+4. Initialize async resources
+5. Signal readiness
+
+### Error State Management
+
+Error states are managed through:
+
+1. Try-catch blocks for synchronous operations
+2. Promise catch handlers for async operations
+3. Error objects with type information
+4. Centralized error logging
+5. State flags to indicate error conditions
+
+### Loading State Management
+
+Loading states are tracked to improve user experience:
+
+1. Boolean flags for loading status
+2. Progress indicators for long operations
+3. Throttling to prevent UI flicker
+4. Timeout detection for stuck operations
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Data Flow](data-flow.md) - How data flows through the application
+- [Component Architecture](component-architecture.md) - Component relationships
+- [Business Logic](../core/business-logic.md) - Core business rules and logic
\ No newline at end of file
diff --git a/docs/clientdocs/components/node-management.md b/docs/clientdocs/components/node-management.md
new file mode 100644
index 00000000..41d0bbdb
--- /dev/null
+++ b/docs/clientdocs/components/node-management.md
@@ -0,0 +1,647 @@
+# Node Management
+
+This document provides a detailed overview of the node management system in the client application. The node management system is responsible for creating, updating, and rendering nodes in the 3D visualization.
+
+## Node Management Architecture
+
+The node management system uses a facade pattern to provide a unified interface to several specialized components:
+
+```mermaid
+flowchart TB
+    subgraph NodeManagementSystem
+        NodeManagerFacade[Node Manager Facade]
+        NodeGeometryManager[Node Geometry Manager]
+        NodeInstanceManager[Node Instance Manager]
+        NodeMetadataManager[Node Metadata Manager]
+        NodeInteractionManager[Node Interaction Manager]
+        NodeIdentityManager[Node Identity Manager]
+    end
+    
+    subgraph ExternalSystems
+        GraphDataManager[Graph Data Manager]
+        WebSocketService[WebSocket Service]
+        RenderManager[Render Manager]
+        XRSystem[XR System]
+    end
+    
+    NodeManagerFacade --> NodeGeometryManager
+    NodeManagerFacade --> NodeInstanceManager
+    NodeManagerFacade --> NodeMetadataManager
+    NodeManagerFacade --> NodeInteractionManager
+    NodeManagerFacade --> NodeIdentityManager
+    
+    GraphDataManager --> NodeManagerFacade
+    WebSocketService --> NodeManagerFacade
+    NodeManagerFacade --> RenderManager
+    XRSystem --> NodeInteractionManager
+```
+
+### Key Components
+
+#### Node Manager Facade (`client/rendering/node/NodeManagerFacade.ts`)
+
+The Node Manager Facade is the central coordinator of the node management system. It provides a unified interface to the specialized components and coordinates their activities.
+
+**Key Responsibilities:**
+- Coordinate between the specialized node managers
+- Handle node updates from the Graph Data Manager
+- Process node position updates from the WebSocket Service
+- Update node metadata and labels
+- Handle XR interactions with nodes
+
+**Interface:**
+```typescript
+interface NodeManagerInterface {
+  updateNodes(nodes: { id: string, data: NodeData }[]): void;
+  updateNodePositions(nodes: { id: string, data: { position: Vector3, velocity?: Vector3 } }[]): void;
+  handleHandInteraction(hand: XRHandWithHaptics): void;
+  update(deltaTime: number): void;
+  setXRMode(enabled: boolean): void;
+  handleSettingsUpdate(settings: Settings): void;
+  dispose(): void;
+}
+```
+
+#### Node Geometry Manager (`client/rendering/node/geometry/NodeGeometryManager.ts`)
+
+The Node Geometry Manager handles the creation and management of node geometries.
+
+**Key Responsibilities:**
+- Create node geometries with different detail levels
+- Optimize geometries for performance
+- Cache geometries for reuse
+
+**Implementation Details:**
+```typescript
+class NodeGeometryManager {
+  private geometries: Map<string, BufferGeometry>;
+  
+  // Create or get node geometry
+  getGeometry(detail: NodeGeometryDetail): BufferGeometry {
+    const key = this.getGeometryKey(detail);
+    
+    if (!this.geometries.has(key)) {
+      // Create new geometry based on detail level
+      const geometry = this.createGeometry(detail);
+      this.geometries.set(key, geometry);
+    }
+    
+    return this.geometries.get(key)!;
+  }
+  
+  // Create geometry with specified detail
+  private createGeometry(detail: NodeGeometryDetail): BufferGeometry {
+    switch (detail) {
+      case NodeGeometryDetail.High:
+        return new SphereGeometry(1, 32, 32);
+      case NodeGeometryDetail.Medium:
+        return new SphereGeometry(1, 16, 16);
+      case NodeGeometryDetail.Low:
+        return new SphereGeometry(1, 8, 8);
+      default:
+        return new SphereGeometry(1, 8, 8);
+    }
+  }
+}
+```
+
+#### Node Instance Manager (`client/rendering/node/instance/NodeInstanceManager.ts`)
+
+The Node Instance Manager handles the instanced rendering of nodes, which allows rendering many nodes with a single draw call.
+
+**Key Responsibilities:**
+- Create and manage instanced mesh for nodes
+- Update node positions, rotations, and scales
+- Handle node visibility and level of detail
+- Map between node IDs and instance indices
+
+**Implementation Details:**
+```typescript
+class NodeInstanceManager {
+  private instancedMesh: InstancedMesh;
+  private nodeIdToInstanceIndex: Map<string, number>;
+  private instanceIndexToNodeId: Map<number, string>;
+  private nodePositions: Map<string, Vector3>;
+  
+  // Create instanced mesh
+  constructor(scene: Scene, material: Material) {
+    // Create geometry
+    const geometry = new SphereGeometry(1, 16, 16);
+    
+    // Create instanced mesh
+    this.instancedMesh = new InstancedMesh(
+      geometry,
+      material,
+      MAX_NODES
+    );
+    
+    // Add to scene
+    scene.add(this.instancedMesh);
+  }
+  
+  // Update node positions
+  updateNodePositions(updates: NodeUpdate[]): void {
+    // Create dummy objects for matrix composition
+    const position = new Vector3();
+    const quaternion = new Quaternion();
+    const scale = new Vector3(1, 1, 1);
+    const matrix = new Matrix4();
+    
+    // Process each update
+    updates.forEach(update => {
+      // Get instance index
+      const instanceIndex = this.getInstanceIndex(update.id);
+      if (instanceIndex === undefined) return;
+      
+      // Update position
+      position.copy(update.position);
+      this.nodePositions.set(update.id, position.clone());
+      
+      // Update matrix
+      scale.setScalar(update.metadata?.nodeSize || DEFAULT_NODE_SIZE);
+      matrix.compose(position, quaternion, scale);
+      this.instancedMesh.setMatrixAt(instanceIndex, matrix);
+    });
+    
+    // Mark instance matrix as needing update
+    this.instancedMesh.instanceMatrix.needsUpdate = true;
+  }
+  
+  // Get node position
+  getNodePosition(nodeId: string): Vector3 | undefined {
+    return this.nodePositions.get(nodeId);
+  }
+  
+  // Get instance index for node ID
+  private getInstanceIndex(nodeId: string): number | undefined {
+    // Check if node already has an instance
+    if (this.nodeIdToInstanceIndex.has(nodeId)) {
+      return this.nodeIdToInstanceIndex.get(nodeId);
+    }
+    
+    // Create new instance if possible
+    if (this.nextInstanceIndex < MAX_NODES) {
+      const instanceIndex = this.nextInstanceIndex++;
+      this.nodeIdToInstanceIndex.set(nodeId, instanceIndex);
+      this.instanceIndexToNodeId.set(instanceIndex, nodeId);
+      return instanceIndex;
+    }
+    
+    // No available instances
+    return undefined;
+  }
+}
+```
+
+#### Node Metadata Manager (`client/rendering/node/metadata/NodeMetadataManager.ts`)
+
+The Node Metadata Manager handles node metadata, including labels and visualization properties.
+
+**Key Responsibilities:**
+- Create and update node labels
+- Visualize node metadata (size, color, etc.)
+- Handle label visibility based on camera distance
+- Update label positions when nodes move
+
+**Implementation Details:**
+```typescript
+class NodeMetadataManager {
+  private labels: Map<string, Object3D>;
+  private labelData: Map<string, NodeLabelData>;
+  private textRenderer: TextRenderer;
+  private labelVisibilityThreshold: number;
+  
+  // Update metadata for node
+  updateMetadata(nodeId: string, metadata: NodeMetadata): void {
+    // Skip if no metadata
+    if (!metadata) return;
+    
+    // Create or update label
+    if (!this.labels.has(nodeId)) {
+      // Create new label
+      const label = this.createLabel(nodeId, metadata);
+      this.labels.set(nodeId, label);
+      this.scene.add(label);
+    } else {
+      // Update existing label
+      const label = this.labels.get(nodeId)!;
+      this.updateLabel(label, metadata);
+    }
+    
+    // Store label data
+    this.labelData.set(nodeId, {
+      name: metadata.name,
+      position: metadata.position.clone(),
+      importance: metadata.importance || 0,
+      nodeSize: metadata.nodeSize || 1,
+    });
+  }
+  
+  // Update label position
+  updatePosition(nodeId: string, position: Vector3): void {
+    // Skip if label doesn't exist
+    if (!this.labels.has(nodeId)) return;
+    
+    // Get label
+    const label = this.labels.get(nodeId)!;
+    
+    // Update position
+    label.position.copy(position);
+    label.position.y += 0.5; // Offset above node
+    
+    // Update label data
+    const labelData = this.labelData.get(nodeId);
+    if (labelData) {
+      labelData.position.copy(position);
+    }
+  }
+  
+  // Update label visibility based on camera distance
+  update(camera: Camera): void {
+    // Skip if no labels
+    if (this.labels.size === 0) return;
+    
+    // Get camera position
+    const cameraPosition = camera.position;
+    
+    // Update label visibility
+    this.labels.forEach((label, nodeId) => {
+      const labelData = this.labelData.get(nodeId);
+      if (!labelData) return;
+      
+      // Calculate distance to camera
+      const distance = cameraPosition.distanceTo(labelData.position);
+      
+      // Calculate visibility threshold based on importance
+      const threshold = this.labelVisibilityThreshold * (1 + labelData.importance * 0.5);
+      
+      // Set visibility
+      label.visible = distance < threshold;
+    });
+  }
+}
+```
+
+#### Node Interaction Manager (`client/rendering/node/interaction/NodeInteractionManager.ts`)
+
+The Node Interaction Manager handles interactions with nodes, such as selection, dragging, and XR interactions.
+
+**Key Responsibilities:**
+- Handle node selection
+- Process XR interactions with nodes
+- Handle node dragging and manipulation
+- Communicate node interactions to other components
+
+**Implementation Details:**
+```typescript
+class NodeInteractionManager {
+  private instancedMesh: InstancedMesh;
+  private selectedNode: string | null = null;
+  private raycaster: Raycaster;
+  private tempVector: Vector3;
+  
+  // Handle mouse interaction
+  handleMouseInteraction(event: MouseEvent, camera: Camera): void {
+    // Skip if no instanced mesh
+    if (!this.instancedMesh) return;
+    
+    // Calculate mouse position
+    const mouse = new Vector2(
+      (event.clientX / window.innerWidth) * 2 - 1,
+      -(event.clientY / window.innerHeight) * 2 + 1
+    );
+    
+    // Update raycaster
+    this.raycaster.setFromCamera(mouse, camera);
+    
+    // Intersect objects
+    const intersects = this.raycaster.intersectObject(this.instancedMesh, true);
+    
+    // Handle intersection
+    if (intersects.length > 0) {
+      // Get instance ID
+      const instanceId = intersects[0].instanceId;
+      
+      // Get node ID
+      const nodeId = this.getNodeId(instanceId!);
+      
+      // Select node
+      this.selectNode(nodeId);
+    } else {
+      // Deselect node
+      this.deselectNode();
+    }
+  }
+  
+  // Handle XR hand interaction
+  handleHandInteraction(hand: XRHandWithHaptics): void {
+    // Skip if no instanced mesh or hand
+    if (!this.instancedMesh || !hand) return;
+    
+    // Get hand position
+    const handPosition = new Vector3();
+    hand.position.getWorldPosition(handPosition);
+    
+    // Get hand direction
+    const handDirection = new Vector3();
+    hand.direction.getWorldDirection(handDirection);
+    
+    // Update raycaster
+    this.raycaster.set(handPosition, handDirection);
+    
+    // Intersect objects
+    const intersects = this.raycaster.intersectObject(this.instancedMesh, true);
+    
+    // Handle intersection
+    if (intersects.length > 0) {
+      // Get instance ID
+      const instanceId = intersects[0].instanceId;
+      
+      // Get node ID
+      const nodeId = this.getNodeId(instanceId!);
+      
+      // Select node
+      this.selectNode(nodeId);
+      
+      // Trigger haptic feedback
+      hand.hapticActuators[0]?.pulse(0.5, 100);
+    }
+  }
+  
+  // Select node
+  private selectNode(nodeId: string | null): void {
+    // Skip if already selected
+    if (this.selectedNode === nodeId) return;
+    
+    // Deselect previous node
+    if (this.selectedNode) {
+      this.deselectNode();
+    }
+    
+    // Select new node
+    this.selectedNode = nodeId;
+    
+    // Dispatch selection event
+    if (nodeId) {
+      this.dispatchEvent('node-selected', { nodeId });
+    }
+  }
+  
+  // Deselect node
+  private deselectNode(): void {
+    // Skip if no selected node
+    if (!this.selectedNode) return;
+    
+    // Dispatch deselection event
+    this.dispatchEvent('node-deselected', { nodeId: this.selectedNode });
+    
+    // Clear selected node
+    this.selectedNode = null;
+  }
+}
+```
+
+#### Node Identity Manager (`client/rendering/node/identity/NodeIdentityManager.ts`)
+
+The Node Identity Manager manages node identities, including mapping between different identifier types and handling label generation.
+
+**Key Responsibilities:**
+- Map between node IDs and display labels
+- Ensure unique labels for nodes
+- Handle node ID validation
+- Track all known nodes
+
+**Implementation Details:**
+```typescript
+class NodeIdentityManager {
+  private nodeLabels: Map<string, string>;
+  private labelToNodeIds: Map<string, Set<string>>;
+  private allNodeIds: Set<string>;
+  
+  // Get label for node
+  getLabel(nodeId: string): string {
+    // Return existing label if available
+    if (this.nodeLabels.has(nodeId)) {
+      return this.nodeLabels.get(nodeId)!;
+    }
+    
+    // Default to node ID itself
+    return `Node_${nodeId}`;
+  }
+  
+  // Force a specific label for a node
+  forceNodeLabel(nodeId: string, label: string): void {
+    // Skip if null or undefined
+    if (!nodeId || !label) return;
+    
+    // Get old label
+    const oldLabel = this.nodeLabels.get(nodeId);
+    
+    // Skip if label is unchanged
+    if (oldLabel === label) return;
+    
+    // Remove from old label mapping
+    if (oldLabel && this.labelToNodeIds.has(oldLabel)) {
+      const nodeIds = this.labelToNodeIds.get(oldLabel)!;
+      nodeIds.delete(nodeId);
+      if (nodeIds.size === 0) {
+        this.labelToNodeIds.delete(oldLabel);
+      }
+    }
+    
+    // Set new label
+    this.nodeLabels.set(nodeId, label);
+    
+    // Add to label mapping
+    if (!this.labelToNodeIds.has(label)) {
+      this.labelToNodeIds.set(label, new Set());
+    }
+    this.labelToNodeIds.get(label)!.add(nodeId);
+    
+    // Add to all node IDs
+    this.allNodeIds.add(nodeId);
+  }
+  
+  // Process nodes to detect duplicates
+  processNodes(nodes: { id: string }[]): { duplicateLabels: Map<string, string[]> } {
+    const duplicateLabels = new Map<string, string[]>();
+    
+    // Process nodes
+    nodes.forEach(node => {
+      // Add to all node IDs
+      this.allNodeIds.add(node.id);
+      
+      // Skip if no label
+      const label = this.nodeLabels.get(node.id);
+      if (!label) return;
+      
+      // Check for duplicates
+      const nodeIds = this.labelToNodeIds.get(label);
+      if (nodeIds && nodeIds.size > 1) {
+        duplicateLabels.set(label, Array.from(nodeIds));
+      }
+    });
+    
+    return { duplicateLabels };
+  }
+  
+  // Check if ID is a valid numeric ID
+  isValidNumericId(id: string): boolean {
+    return id !== undefined && id !== null && /^\d+$/.test(id);
+  }
+  
+  // Get all known node IDs
+  getAllNodeIds(): string[] {
+    return Array.from(this.allNodeIds);
+  }
+}
+```
+
+## Node Data Structure
+
+The node data structure is defined in `client/core/types.ts`:
+
+```typescript
+interface Node {
+  id: string;
+  data: NodeData;
+}
+
+interface NodeData {
+  position: Vector3;
+  velocity?: Vector3;
+  metadata?: NodeMetadata;
+}
+
+interface NodeMetadata {
+  name?: string;
+  file_name?: string;
+  lastModified?: number;
+  links?: string[];
+  references?: string[];
+  fileSize?: number;
+  hyperlinkCount?: number;
+  importance?: number;
+  nodeSize?: number;
+}
+```
+
+## Node Update Flow
+
+The node update flow follows these steps:
+
+```mermaid
+sequenceDiagram
+    participant GraphDataManager
+    participant NodeManagerFacade
+    participant NodeIdentityManager
+    participant NodeInstanceManager
+    participant NodeMetadataManager
+    
+    GraphDataManager->>NodeManagerFacade: updateNodes(nodes)
+    NodeManagerFacade->>NodeIdentityManager: processNodes(nodes)
+    NodeManagerFacade->>NodeIdentityManager: getLabel(nodeId)
+    NodeManagerFacade->>NodeInstanceManager: updateNodePositions(nodePositions)
+    NodeManagerFacade->>NodeMetadataManager: updateMetadata(nodeId, metadata)
+```
+
+### Initial Node Loading
+
+When nodes are initially loaded:
+
+1. GraphDataManager fetches node data from the server
+2. GraphDataManager transforms the data into a usable format
+3. GraphDataManager calls NodeManagerFacade.updateNodes()
+4. NodeManagerFacade processes the nodes:
+   a. Validates node IDs
+   b. Processes node metadata
+   c. Generates or retrieves node labels
+   d. Updates node positions
+   e. Updates node metadata and labels
+
+### Real-time Node Updates
+
+When nodes are updated in real-time:
+
+1. WebSocketService receives binary position data
+2. WebSocketService decodes the binary format
+3. WebSocketService calls GraphDataManager.updateNodePositions()
+4. GraphDataManager calls NodeManagerFacade.updateNodePositions()
+5. NodeManagerFacade updates node positions
+6. During the render loop, NodeManagerFacade updates label positions
+
+## Node Rendering
+
+Nodes are rendered using instanced rendering for performance:
+
+```typescript
+// Create instanced mesh
+this.instancedMesh = new InstancedMesh(
+  geometry,
+  material,
+  maxInstances
+);
+
+// Update instance matrices
+updates.forEach(update => {
+  const instanceIndex = this.getInstanceIndex(update.id);
+  if (instanceIndex === undefined) return;
+  
+  position.copy(update.position);
+  scale.setScalar(update.metadata?.nodeSize || DEFAULT_NODE_SIZE);
+  matrix.compose(position, quaternion, scale);
+  this.instancedMesh.setMatrixAt(instanceIndex, matrix);
+});
+this.instancedMesh.instanceMatrix.needsUpdate = true;
+```
+
+This approach allows rendering thousands of nodes with minimal draw calls, significantly improving performance.
+
+## Node Selection and Interaction
+
+Nodes can be selected and interacted with using mouse, touch, or XR controllers:
+
+```typescript
+// Mouse selection
+renderer.domElement.addEventListener('mousedown', (event) => {
+  this.interactionManager.handleMouseInteraction(event, camera);
+});
+
+// XR controller interaction
+xrController.addEventListener('select', (event) => {
+  this.interactionManager.handleXRInteraction(event.controller);
+});
+```
+
+Selected nodes can be manipulated:
+
+```typescript
+// Node manipulation
+renderer.domElement.addEventListener('mousemove', (event) => {
+  if (this.interactionManager.hasSelectedNode()) {
+    const movement = new Vector2(
+      event.movementX / window.innerWidth,
+      -event.movementY / window.innerHeight
+    );
+    this.interactionManager.moveSelectedNode(movement, camera);
+  }
+});
+```
+
+## Node Performance Considerations
+
+Several optimizations are used to maintain performance with large node counts:
+
+1. **Instanced Rendering**: All nodes share the same geometry and material, significantly reducing draw calls
+2. **Level of Detail**: Node geometry detail is reduced based on distance from camera
+3. **Visibility Culling**: Nodes outside the camera frustum are not processed
+4. **Position Deadbanding**: Small position changes are ignored to reduce update frequency
+5. **Label Throttling**: Label updates are throttled to reduce update frequency
+6. **Binary Protocol**: A compact binary format is used for position updates
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Rendering Pipeline](rendering-pipeline.md) - Rendering pipeline overview
+- [Metadata Visualization](metadata-visualization.md) - Metadata visualization details
+- [XR Integration](xr-integration.md) - WebXR integration
\ No newline at end of file
diff --git a/docs/clientdocs/components/rendering-pipeline.md b/docs/clientdocs/components/rendering-pipeline.md
new file mode 100644
index 00000000..babc8949
--- /dev/null
+++ b/docs/clientdocs/components/rendering-pipeline.md
@@ -0,0 +1,631 @@
+# Rendering Pipeline
+
+This document provides a comprehensive overview of the client rendering pipeline, which is built on Three.js and WebGL. It covers scene setup, rendering optimization, material management, and the overall rendering architecture.
+
+## Rendering Architecture Overview
+
+The client rendering pipeline is designed for efficient visualization of large graph data structures in 3D space. It uses instanced rendering for nodes, optimized line rendering for edges, and SDF (Signed Distance Field) text rendering for labels.
+
+```mermaid
+flowchart TB
+    subgraph Initialization
+        SceneSetup[Scene Setup]
+        CameraSetup[Camera Setup]
+        RendererSetup[Renderer Setup]
+        MaterialSetup[Material Setup]
+    end
+    
+    subgraph CoreRendering
+        RenderManager[Render Manager]
+        NodeManager[Node Manager]
+        EdgeManager[Edge Manager]
+        TextRenderer[Text Renderer]
+    end
+    
+    subgraph RenderLoop
+        UpdatePositions[Update Positions]
+        UpdateEdges[Update Edges]
+        UpdateLabels[Update Labels]
+        ApplySettings[Apply Settings]
+        RenderFrame[Render Frame]
+    end
+    
+    SceneSetup --> RenderManager
+    CameraSetup --> RenderManager
+    RendererSetup --> RenderManager
+    MaterialSetup --> NodeManager
+    MaterialSetup --> EdgeManager
+    
+    RenderManager --> NodeManager
+    RenderManager --> EdgeManager
+    RenderManager --> TextRenderer
+    
+    NodeManager --> UpdatePositions
+    EdgeManager --> UpdateEdges
+    TextRenderer --> UpdateLabels
+    
+    UpdatePositions --> RenderFrame
+    UpdateEdges --> RenderFrame
+    UpdateLabels --> RenderFrame
+    ApplySettings --> RenderFrame
+```
+
+## Key Components
+
+### Render Manager (`client/rendering/renderManager.ts`)
+
+The Render Manager is the central orchestrator of the rendering pipeline. It initializes the Three.js environment and coordinates between rendering components.
+
+**Responsibilities:**
+- Initialize and configure the Three.js renderer
+- Create and manage the scene graph
+- Handle the render loop
+- Coordinate camera controls
+- Handle window resizing
+- Manage rendering quality settings
+
+**Core Architecture:**
+```typescript
+class RenderManager {
+  private scene: Scene;
+  private camera: PerspectiveCamera;
+  private renderer: WebGLRenderer;
+  private nodeManager: NodeManagerFacade;
+  private edgeManager: EdgeManager;
+  private textRenderer: TextRenderer;
+  private controls: OrbitControls;
+  
+  constructor() {
+    // Initialize Three.js components
+    this.initRenderer();
+    this.initScene();
+    this.initCamera();
+    this.initControls();
+    
+    // Initialize rendering components
+    this.initNodeManager();
+    this.initEdgeManager();
+    this.initTextRenderer();
+    
+    // Start render loop
+    this.startRenderLoop();
+  }
+  
+  private render(time: number): void {
+    // Update delta time
+    const deltaTime = this.clock.getDelta();
+    
+    // Update components
+    this.nodeManager.update(deltaTime);
+    this.edgeManager.update(deltaTime);
+    this.controls.update();
+    
+    // Render the scene
+    this.renderer.render(this.scene, this.camera);
+  }
+}
+```
+
+### Node Manager Facade (`client/rendering/node/NodeManagerFacade.ts`)
+
+The Node Manager Facade provides a unified interface to the node management subsystem, which handles the rendering of nodes.
+
+**Component Hierarchy:**
+```mermaid
+flowchart TB
+    NodeManagerFacade --> NodeGeometryManager
+    NodeManagerFacade --> NodeInstanceManager
+    NodeManagerFacade --> NodeMetadataManager
+    NodeManagerFacade --> NodeInteractionManager
+    NodeManagerFacade --> NodeIdentityManager
+    
+    NodeGeometryManager --> THREE.BufferGeometry
+    NodeInstanceManager --> THREE.InstancedMesh
+    NodeMetadataManager --> TextRenderer
+    NodeInteractionManager --> XRHandInteraction
+```
+
+**Key Responsibilities:**
+- Manage node geometries and materials
+- Handle instanced rendering for performance
+- Update node positions and metadata
+- Handle node interactions
+- Manage node visibility and level of detail
+
+### Instanced Rendering
+
+The rendering pipeline uses instanced rendering for efficient node visualization:
+
+```typescript
+// Create an instanced mesh for all nodes
+this.instancedMesh = new THREE.InstancedMesh(
+  geometry,
+  material,
+  maxInstances
+);
+
+// Update a specific instance matrix
+const matrix = new THREE.Matrix4();
+matrix.compose(
+  position,         // Vector3 position
+  quaternion,       // Quaternion rotation
+  new THREE.Vector3(scale, scale, scale) // Vector3 scale
+);
+this.instancedMesh.setMatrixAt(instanceId, matrix);
+
+// Mark instance matrices as needing update
+this.instancedMesh.instanceMatrix.needsUpdate = true;
+```
+
+This approach allows rendering thousands of nodes with minimal draw calls, significantly improving performance.
+
+### Edge Manager (`client/rendering/EdgeManager.ts`)
+
+The Edge Manager handles the rendering of edges (connections between nodes).
+
+**Key Responsibilities:**
+- Create and update edge geometries
+- Manage edge materials and appearance
+- Update edge positions based on connected nodes
+- Handle edge visibility and level of detail
+
+**Implementation Approach:**
+```typescript
+class EdgeManager {
+  private edges: Map<string, LineSegments>;
+  private material: LineBasicMaterial;
+  
+  // Create an edge between two nodes
+  createEdge(sourceId: string, targetId: string): void {
+    // Create geometry
+    const geometry = new BufferGeometry();
+    
+    // Set initial positions
+    const positions = new Float32Array(6); // 2 vertices  3 coordinates
+    geometry.setAttribute('position', new BufferAttribute(positions, 3));
+    
+    // Create line
+    const line = new LineSegments(geometry, this.material);
+    this.edges.set(this.createEdgeId(sourceId, targetId), line);
+    this.scene.add(line);
+  }
+  
+  // Update edge positions based on node positions
+  updateEdgePositions(nodePositions: Map<string, Vector3>): void {
+    this.edges.forEach((line, edgeId) => {
+      const [sourceId, targetId] = this.parseEdgeId(edgeId);
+      const sourcePos = nodePositions.get(sourceId);
+      const targetPos = nodePositions.get(targetId);
+      
+      if (sourcePos && targetPos) {
+        // Update buffer geometry
+        const positions = line.geometry.attributes.position.array as Float32Array;
+        
+        // Source position
+        positions[0] = sourcePos.x;
+        positions[1] = sourcePos.y;
+        positions[2] = sourcePos.z;
+        
+        // Target position
+        positions[3] = targetPos.x;
+        positions[4] = targetPos.y;
+        positions[5] = targetPos.z;
+        
+        // Mark positions as needing update
+        line.geometry.attributes.position.needsUpdate = true;
+      }
+    });
+  }
+}
+```
+
+### Text Renderer (`client/rendering/textRenderer.ts` and `client/rendering/UnifiedTextRenderer.ts`)
+
+The Text Renderer handles the rendering of text labels in 3D space using SDF fonts.
+
+**Key Responsibilities:**
+- Load and process fonts
+- Create SDF textures for crisp text rendering
+- Position text labels in 3D space
+- Handle text visibility and level of detail
+
+**SDF Font Rendering:**
+```typescript
+// Generate SDF texture
+const fontAtlas = new SDFFontAtlasGenerator();
+const texture = fontAtlas.generateAtlas(font, chars);
+
+// Create text material
+const material = new ShaderMaterial({
+  uniforms: {
+    map: { value: texture },
+    color: { value: new Color(color) },
+    threshold: { value: threshold },
+    smoothing: { value: smoothing }
+  },
+  vertexShader: textVertexShader,
+  fragmentShader: textFragmentShader,
+  transparent: true,
+  side: DoubleSide
+});
+
+// Create text mesh
+const geometry = new PlaneGeometry(width, height);
+const mesh = new Mesh(geometry, material);
+```
+
+## Material Management
+
+### Material Factory (`client/rendering/factories/MaterialFactory.ts`)
+
+The Material Factory creates and manages materials for the rendering pipeline.
+
+**Key Responsibilities:**
+- Create node materials
+- Create edge materials
+- Create label materials
+- Handle material updates based on settings
+
+**Implementation Pattern:**
+```typescript
+class MaterialFactory {
+  // Create node material
+  createNodeMaterial(options: NodeMaterialOptions): Material {
+    // Basic material for standard rendering
+    if (options.renderingMode === 'standard') {
+      return new MeshStandardMaterial({
+        color: options.color,
+        roughness: options.roughness,
+        metalness: options.metalness,
+        transparent: options.transparent,
+        opacity: options.opacity
+      });
+    }
+    
+    // Custom shader material for advanced effects
+    return new ShaderMaterial({
+      uniforms: {
+        color: { value: new Color(options.color) },
+        opacity: { value: options.opacity }
+        // Other uniforms...
+      },
+      vertexShader: nodeVertexShader,
+      fragmentShader: nodeFragmentShader,
+      transparent: options.transparent
+    });
+  }
+}
+```
+
+### Custom Shaders
+
+The rendering pipeline uses custom shaders for various effects:
+
+**Edge Shader Material (`client/rendering/materials/EdgeShaderMaterial.ts`)**:
+```glsl
+// Vertex shader
+varying vec3 vPosition;
+
+void main() {
+  vPosition = position;
+  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+}
+
+// Fragment shader
+uniform vec3 color;
+uniform float opacity;
+varying vec3 vPosition;
+
+void main() {
+  float intensity = 1.0 - abs(vPosition.y);
+  gl_FragColor = vec4(color, opacity * intensity);
+}
+```
+
+**Hologram Shader Material (`client/rendering/materials/HologramShaderMaterial.ts`)**:
+```glsl
+// Vertex shader
+varying vec2 vUv;
+varying vec3 vPosition;
+
+void main() {
+  vUv = uv;
+  vPosition = position;
+  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+}
+
+// Fragment shader
+uniform vec3 color;
+uniform float time;
+uniform float opacity;
+uniform float scanlineIntensity;
+varying vec2 vUv;
+varying vec3 vPosition;
+
+void main() {
+  // Scanline effect
+  float scanline = sin(vUv.y * 30.0 + time) * 0.5 + 0.5;
+  scanline = mix(1.0, scanline, scanlineIntensity);
+  
+  // Edge glow
+  float edge = 1.0 - max(abs(vUv.x - 0.5), abs(vUv.y - 0.5)) * 2.0;
+  edge = smoothstep(0.0, 0.5, edge);
+  
+  // Final color
+  vec3 finalColor = color * scanline;
+  float finalOpacity = opacity * edge;
+  
+  gl_FragColor = vec4(finalColor, finalOpacity);
+}
+```
+
+## Scene Setup
+
+The rendering pipeline sets up a Three.js scene with the following components:
+
+```typescript
+// Create scene
+this.scene = new Scene();
+this.scene.background = new Color(BACKGROUND_COLOR);
+
+// Create camera
+this.camera = new PerspectiveCamera(
+  75, // Field of view
+  window.innerWidth / window.innerHeight, // Aspect ratio
+  0.1, // Near plane
+  1000 // Far plane
+);
+this.camera.position.z = 5;
+
+// Create renderer
+this.renderer = new WebGLRenderer({
+  antialias: true,
+  alpha: true,
+  logarithmicDepthBuffer: true
+});
+this.renderer.setSize(window.innerWidth, window.innerHeight);
+this.renderer.setPixelRatio(window.devicePixelRatio);
+this.renderer.shadowMap.enabled = true;
+this.renderer.shadowMap.type = PCFSoftShadowMap;
+
+// Create lights
+const ambientLight = new AmbientLight(0xffffff, 0.5);
+this.scene.add(ambientLight);
+
+const directionalLight = new DirectionalLight(0xffffff, 0.5);
+directionalLight.position.set(10, 10, 10);
+directionalLight.castShadow = true;
+this.scene.add(directionalLight);
+```
+
+## Render Loop
+
+The render loop continuously updates and renders the scene:
+
+```typescript
+private startRenderLoop(): void {
+  // Animation loop function
+  const animate = (time: number) => {
+    // Request next frame
+    this.animationFrameId = requestAnimationFrame(animate);
+    
+    // Update delta time
+    const deltaTime = this.clock.getDelta();
+    
+    // Update components
+    this.nodeManager.update(deltaTime);
+    this.edgeManager.update(deltaTime);
+    
+    // Update controls
+    this.controls.update();
+    
+    // Render the scene
+    this.renderer.render(this.scene, this.camera);
+  };
+  
+  // Start the animation loop
+  this.animationFrameId = requestAnimationFrame(animate);
+}
+```
+
+## Performance Optimizations
+
+The rendering pipeline includes various performance optimizations:
+
+### Level of Detail (LOD)
+
+The rendering pipeline implements LOD based on camera distance:
+
+```typescript
+private updateLOD(): void {
+  const cameraPosition = this.camera.position;
+  
+  // Iterate through instances
+  for (let i = 0; i < this.instanceCount; i++) {
+    const position = this.getNodePosition(i);
+    if (!position) continue;
+    
+    // Calculate distance to camera
+    const distanceToCamera = position.distanceTo(cameraPosition);
+    
+    // Determine detail level
+    let detailLevel = 0; // Highest detail
+    if (distanceToCamera > this.highDetailThreshold) {
+      detailLevel = 1; // Medium detail
+    }
+    if (distanceToCamera > this.mediumDetailThreshold) {
+      detailLevel = 2; // Low detail
+    }
+    
+    // Apply detail level
+    this.setNodeDetailLevel(i, detailLevel);
+  }
+}
+```
+
+### Visibility Culling
+
+The rendering pipeline culls invisible objects:
+
+```typescript
+private updateVisibility(): void {
+  const frustum = new Frustum();
+  frustum.setFromProjectionMatrix(
+    new Matrix4().multiplyMatrices(
+      this.camera.projectionMatrix,
+      this.camera.matrixWorldInverse
+    )
+  );
+  
+  // Iterate through instances
+  for (let i = 0; i < this.instanceCount; i++) {
+    const position = this.getNodePosition(i);
+    if (!position) continue;
+    
+    // Check if in frustum
+    const sphere = new Sphere(position, this.nodeSize);
+    const visible = frustum.intersectsSphere(sphere);
+    
+    // Set visibility
+    this.setNodeVisible(i, visible);
+  }
+}
+```
+
+### Instanced Rendering
+
+The rendering pipeline uses instanced rendering for nodes:
+
+```typescript
+// Create instanced mesh
+this.instancedMesh = new InstancedMesh(
+  this.geometry,
+  this.material,
+  maxInstances
+);
+
+// Set instance transforms
+for (let i = 0; i < instances.length; i++) {
+  const matrix = new Matrix4();
+  matrix.compose(
+    instances[i].position,
+    instances[i].quaternion,
+    instances[i].scale
+  );
+  this.instancedMesh.setMatrixAt(i, matrix);
+}
+this.instancedMesh.instanceMatrix.needsUpdate = true;
+```
+
+## WebGL Resource Management
+
+The rendering pipeline carefully manages WebGL resources:
+
+```typescript
+public dispose(): void {
+  // Dispose geometry
+  if (this.geometry) {
+    this.geometry.dispose();
+  }
+  
+  // Dispose material
+  if (this.material) {
+    this.material.dispose();
+  }
+  
+  // Dispose instanced mesh
+  if (this.instancedMesh) {
+    // Remove from scene
+    this.scene.remove(this.instancedMesh);
+    
+    // Dispose instanced mesh
+    if (this.instancedMesh.geometry) {
+      this.instancedMesh.geometry.dispose();
+    }
+    if (this.instancedMesh.material) {
+      if (Array.isArray(this.instancedMesh.material)) {
+        this.instancedMesh.material.forEach(material => material.dispose());
+      } else {
+        this.instancedMesh.material.dispose();
+      }
+    }
+  }
+}
+```
+
+## Metadata Visualization
+
+The rendering pipeline includes metadata visualization:
+
+```typescript
+class MetadataVisualizer {
+  private textLabels: Map<string, Object3D>;
+  
+  // Create label for node
+  createLabel(nodeId: string, metadata: NodeMetadata): void {
+    // Create text geometry
+    const text = this.createText(metadata.name);
+    
+    // Position label
+    text.position.copy(metadata.position);
+    text.position.y += 0.5; // Offset above node
+    
+    // Add to scene
+    this.scene.add(text);
+    this.textLabels.set(nodeId, text);
+  }
+  
+  // Update label positions
+  updatePositions(nodePositions: Map<string, Vector3>): void {
+    this.textLabels.forEach((label, nodeId) => {
+      const position = nodePositions.get(nodeId);
+      if (position) {
+        label.position.copy(position);
+        label.position.y += 0.5; // Offset above node
+      }
+    });
+  }
+}
+```
+
+## Post-Processing Effects
+
+The rendering pipeline supports post-processing effects:
+
+```typescript
+class PostProcessingManager {
+  private composer: EffectComposer;
+  private renderPass: RenderPass;
+  private bloomPass: UnrealBloomPass;
+  
+  constructor(renderer: WebGLRenderer, scene: Scene, camera: Camera) {
+    // Create composer
+    this.composer = new EffectComposer(renderer);
+    
+    // Add render pass
+    this.renderPass = new RenderPass(scene, camera);
+    this.composer.addPass(this.renderPass);
+    
+    // Add bloom pass
+    this.bloomPass = new UnrealBloomPass(
+      new Vector2(window.innerWidth, window.innerHeight),
+      1.5, // Strength
+      0.4, // Radius
+      0.85 // Threshold
+    );
+    this.composer.addPass(this.bloomPass);
+  }
+  
+  // Render with post-processing
+  render(): void {
+    this.composer.render();
+  }
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Node Management](node-management.md) - Node rendering details
+- [Metadata Visualization](metadata-visualization.md) - Metadata visualization details
+- [XR Integration](xr-integration.md) - WebXR integration
\ No newline at end of file
diff --git a/docs/clientdocs/components/xr-integration.md b/docs/clientdocs/components/xr-integration.md
new file mode 100644
index 00000000..637a0723
--- /dev/null
+++ b/docs/clientdocs/components/xr-integration.md
@@ -0,0 +1,818 @@
+# WebXR Integration
+
+This document provides a comprehensive overview of the WebXR integration in the client application. The WebXR integration enables immersive Virtual Reality (VR) and Augmented Reality (AR) experiences, allowing users to interact with the 3D graph visualization using VR headsets and controllers.
+
+## WebXR Architecture Overview
+
+The WebXR integration is built using the WebXR Device API and is integrated with Three.js for rendering. The integration follows a modular design to handle various aspects of XR interactions:
+
+```mermaid
+flowchart TB
+    subgraph XRSystem
+        XRInitializer[XR Initializer]
+        XRSessionManager[XR Session Manager]
+        XRInteraction[XR Interaction]
+        HandInteraction[Hand Interaction]
+    end
+    
+    subgraph RenderingSystem
+        RenderManager[Render Manager]
+        NodeManager[Node Manager]
+        EdgeManager[Edge Manager]
+    end
+    
+    subgraph InputSystem
+        Controllers[XR Controllers]
+        Hands[Hand Tracking]
+    end
+    
+    XRInitializer --> XRSessionManager
+    XRSessionManager --> XRInteraction
+    XRInteraction --> HandInteraction
+    
+    XRSessionManager --> RenderManager
+    XRInteraction --> NodeManager
+    HandInteraction --> NodeManager
+    
+    Controllers --> XRInteraction
+    Hands --> HandInteraction
+```
+
+## Key Components
+
+### XR Initializer (`client/xr/xrInitializer.ts`)
+
+The XR Initializer is responsible for initializing WebXR capabilities and checking device compatibility.
+
+**Key Responsibilities:**
+- Check WebXR compatibility
+- Initialize the WebXR session
+- Handle XR session creation and termination
+- Provide entry points for immersive XR experiences
+
+**Implementation Pattern:**
+```typescript
+class XRInitializer {
+  private renderer: WebGLRenderer;
+  private scene: Scene;
+  private camera: PerspectiveCamera;
+  
+  // Initialize XR
+  async initialize(): Promise<boolean> {
+    if (!this.isXRSupported()) {
+      logger.warn('WebXR not supported in this browser');
+      return false;
+    }
+    
+    try {
+      // Set up XR compatible renderer
+      this.renderer.xr.enabled = true;
+      
+      // Add XR button to UI
+      const xrButton = this.createXRButton();
+      document.body.appendChild(xrButton);
+      
+      logger.info('WebXR initialized successfully');
+      return true;
+    } catch (error) {
+      logger.error('Failed to initialize WebXR:', error);
+      return false;
+    }
+  }
+  
+  // Check if XR is supported
+  private isXRSupported(): boolean {
+    return 'xr' in navigator && 'isSessionSupported' in (navigator as any).xr;
+  }
+  
+  // Create XR session
+  async createXRSession(sessionMode: XRSessionMode = 'immersive-vr'): Promise<XRSession | null> {
+    if (!this.isXRSupported()) {
+      return null;
+    }
+    
+    try {
+      // Check if session mode is supported
+      const isSupported = await (navigator as any).xr.isSessionSupported(sessionMode);
+      if (!isSupported) {
+        logger.warn(`XR session mode '${sessionMode}' not supported`);
+        return null;
+      }
+      
+      // Request session
+      const session = await (navigator as any).xr.requestSession(sessionMode, {
+        requiredFeatures: ['local-floor', 'hand-tracking'],
+        optionalFeatures: ['bounded-floor', 'layers']
+      });
+      
+      // Initialize session
+      await this.renderer.xr.setSession(session);
+      
+      logger.info(`XR session '${sessionMode}' created successfully`);
+      return session;
+    } catch (error) {
+      logger.error(`Failed to create XR session '${sessionMode}':`, error);
+      return null;
+    }
+  }
+}
+```
+
+### XR Session Manager (`client/xr/xrSessionManager.ts`)
+
+The XR Session Manager handles the lifecycle of XR sessions and provides a central point for XR state management.
+
+**Key Responsibilities:**
+- Manage XR session lifecycle
+- Configure XR reference spaces
+- Setup XR rendering pipeline
+- Handle XR session events
+
+**Implementation Pattern:**
+```typescript
+class XRSessionManager {
+  private session: XRSession | null = null;
+  private referenceSpace: XRReferenceSpace | null = null;
+  private isPresenting: boolean = false;
+  private renderer: WebGLRenderer;
+  private camera: Camera;
+  private scene: Scene;
+  
+  // Start XR session
+  async startSession(sessionMode: XRSessionMode = 'immersive-vr'): Promise<boolean> {
+    if (this.isPresenting) {
+      logger.warn('XR session already active');
+      return false;
+    }
+    
+    try {
+      // Create session
+      this.session = await XRInitializer.getInstance().createXRSession(sessionMode);
+      if (!this.session) {
+        return false;
+      }
+      
+      // Set up reference space
+      this.referenceSpace = await this.session.requestReferenceSpace('local-floor');
+      
+      // Configure renderer for XR
+      this.renderer.xr.setReferenceSpace(this.referenceSpace);
+      this.renderer.xr.setSession(this.session);
+      
+      // Set up event listeners
+      this.session.addEventListener('end', this.handleSessionEnd);
+      
+      // Update state
+      this.isPresenting = true;
+      
+      // Notify components of XR mode
+      this.dispatchEvent('xr-session-started', { session: this.session });
+      
+      logger.info('XR session started successfully');
+      return true;
+    } catch (error) {
+      logger.error('Failed to start XR session:', error);
+      return false;
+    }
+  }
+  
+  // End XR session
+  async endSession(): Promise<void> {
+    if (!this.isPresenting || !this.session) {
+      logger.warn('No active XR session to end');
+      return;
+    }
+    
+    try {
+      // End session
+      await this.session.end();
+      
+      // Session end event will clean up
+    } catch (error) {
+      logger.error('Failed to end XR session:', error);
+      
+      // Clean up anyway
+      this.handleSessionEnd();
+    }
+  }
+  
+  // Handle session end
+  private handleSessionEnd = (): void => {
+    // Clean up session
+    this.session = null;
+    this.referenceSpace = null;
+    
+    // Update state
+    this.isPresenting = false;
+    
+    // Notify components
+    this.dispatchEvent('xr-session-ended', {});
+    
+    logger.info('XR session ended');
+  };
+  
+  // Check if presenting
+  isInXR(): boolean {
+    return this.isPresenting;
+  }
+  
+  // Get reference space
+  getReferenceSpace(): XRReferenceSpace | null {
+    return this.referenceSpace;
+  }
+}
+```
+
+### XR Interaction (`client/xr/xrInteraction.ts`)
+
+The XR Interaction component handles user interactions in XR mode, such as controller inputs and spatial UI interactions.
+
+**Key Responsibilities:**
+- Handle controller inputs
+- Process XR selection events
+- Manage XR-specific UI elements
+- Coordinate between XR inputs and application actions
+
+**Implementation Pattern:**
+```typescript
+class XRInteraction {
+  private sessionManager: XRSessionManager;
+  private controllers: Map<number, XRController> = new Map();
+  private raycaster: Raycaster = new Raycaster();
+  private tempMatrix: Matrix4 = new Matrix4();
+  
+  // Initialize controllers
+  initializeControllers(session: XRSession): void {
+    // Get input sources
+    const inputSources = session.inputSources;
+    
+    // Process each input source
+    inputSources.forEach((inputSource, index) => {
+      // Create controller
+      const controller = this.renderer.xr.getController(index);
+      
+      // Add to scene
+      this.scene.add(controller);
+      
+      // Store controller
+      this.controllers.set(index, {
+        object: controller,
+        inputSource
+      });
+      
+      // Add event listeners
+      controller.addEventListener('selectstart', this.handleSelectStart);
+      controller.addEventListener('selectend', this.handleSelectEnd);
+      
+      // Add visual representation
+      this.addControllerModel(controller, inputSource);
+      
+      logger.info(`XR controller ${index} initialized`);
+    });
+  }
+  
+  // Handle controller select start
+  private handleSelectStart = (event: any): void => {
+    const controller = event.target;
+    
+    // Get controller index
+    const controllerIndex = this.getControllerIndex(controller);
+    if (controllerIndex === -1) return;
+    
+    // Get controller data
+    const controllerData = this.controllers.get(controllerIndex);
+    if (!controllerData) return;
+    
+    // Perform raycasting
+    this.tempMatrix.identity().extractRotation(controller.matrixWorld);
+    this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
+    this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
+    
+    // Find intersections
+    const intersects = this.raycaster.intersectObjects(this.scene.children, true);
+    
+    // Handle intersection
+    if (intersects.length > 0) {
+      const intersection = intersects[0];
+      this.dispatchEvent('xr-select', {
+        controller: controllerData,
+        intersection
+      });
+    }
+  };
+  
+  // Handle controller select end
+  private handleSelectEnd = (event: any): void => {
+    const controller = event.target;
+    
+    // Get controller index
+    const controllerIndex = this.getControllerIndex(controller);
+    if (controllerIndex === -1) return;
+    
+    // Get controller data
+    const controllerData = this.controllers.get(controllerIndex);
+    if (!controllerData) return;
+    
+    // Dispatch event
+    this.dispatchEvent('xr-selectend', {
+      controller: controllerData
+    });
+  };
+  
+  // Update controllers
+  update(): void {
+    // Skip if not in XR
+    if (!this.sessionManager.isInXR()) return;
+    
+    // Update controller positions and interactions
+    this.controllers.forEach((controllerData, index) => {
+      // Handle controller-specific updates
+    });
+  }
+}
+```
+
+### Hand Interaction (`client/xr/handInteraction.ts`)
+
+The Hand Interaction component handles hand tracking-based interactions, allowing users to use their hands in XR mode.
+
+**Key Responsibilities:**
+- Process hand tracking data
+- Handle gesture recognition
+- Manage hand-based interactions with nodes
+- Provide haptic feedback for interactions
+
+**Implementation Pattern:**
+```typescript
+class HandInteraction {
+  private sessionManager: XRSessionManager;
+  private hands: Map<XRHandedness, XRHandWithHaptics> = new Map();
+  private jointMeshes: Map<string, Mesh> = new Map();
+  private pinchState: Map<XRHandedness, boolean> = new Map();
+  private nodeManager: NodeManagerFacade;
+  
+  // Initialize hand tracking
+  initializeHandTracking(session: XRSession): void {
+    // Check if hand tracking is supported
+    if (!session.inputSources || !session.inputSources.some(inputSource => inputSource.hand)) {
+      logger.warn('Hand tracking not supported or enabled');
+      return;
+    }
+    
+    // Initialize hands
+    session.inputSources.forEach(inputSource => {
+      if (inputSource.hand && inputSource.handedness) {
+        // Create hand object
+        const controller = this.renderer.xr.getControllerGrip(
+          inputSource.handedness === 'left' ? 0 : 1
+        );
+        
+        // Create hand with haptics
+        const hand: XRHandWithHaptics = {
+          inputSource,
+          controller,
+          hand: inputSource.hand,
+          position: controller,
+          direction: this.createDirectionObject(controller),
+          handedness: inputSource.handedness,
+          hapticActuators: inputSource.gamepad?.hapticActuators || []
+        };
+        
+        // Store hand
+        this.hands.set(inputSource.handedness, hand);
+        
+        // Initialize pinch state
+        this.pinchState.set(inputSource.handedness, false);
+        
+        // Create joint meshes
+        this.createJointMeshes(hand);
+        
+        logger.info(`Hand tracking initialized for ${inputSource.handedness} hand`);
+      }
+    });
+  }
+  
+  // Create joint meshes
+  private createJointMeshes(hand: XRHandWithHaptics): void {
+    // Create joint meshes for visualization
+    const geometry = new SphereGeometry(0.008, 8, 8);
+    const material = new MeshStandardMaterial({
+      color: hand.handedness === 'left' ? 0x00ffff : 0xff00ff,
+      roughness: 0.7,
+      metalness: 0.1
+    });
+    
+    // For each joint in the hand
+    HAND_JOINTS.forEach(jointName => {
+      // Create mesh
+      const mesh = new Mesh(geometry, material);
+      mesh.visible = false;
+      
+      // Add to scene
+      this.scene.add(mesh);
+      
+      // Store mesh
+      const key = `${hand.handedness}-${jointName}`;
+      this.jointMeshes.set(key, mesh);
+    });
+  }
+  
+  // Update hand positions
+  update(frame: XRFrame, referenceSpace: XRReferenceSpace): void {
+    // Skip if not in XR
+    if (!this.sessionManager.isInXR()) return;
+    
+    // Update each hand
+    this.hands.forEach((hand, handedness) => {
+      // Get hand data
+      const xrHand = hand.hand;
+      
+      // Update joint positions
+      HAND_JOINTS.forEach(jointName => {
+        const joint = xrHand.get(jointName as XRHandJoint);
+        if (joint) {
+          // Get joint pose
+          const jointPose = frame.getJointPose(joint, referenceSpace);
+          
+          // Update joint mesh
+          if (jointPose) {
+            const key = `${handedness}-${jointName}`;
+            const mesh = this.jointMeshes.get(key);
+            
+            if (mesh) {
+              // Update position
+              mesh.position.set(
+                jointPose.transform.position.x,
+                jointPose.transform.position.y,
+                jointPose.transform.position.z
+              );
+              
+              // Update rotation
+              mesh.quaternion.set(
+                jointPose.transform.orientation.x,
+                jointPose.transform.orientation.y,
+                jointPose.transform.orientation.z,
+                jointPose.transform.orientation.w
+              );
+              
+              // Show mesh
+              mesh.visible = true;
+            }
+          }
+        }
+      });
+      
+      // Check for pinch gesture
+      this.checkPinchGesture(hand, handedness);
+      
+      // Send hand data to node manager for interactions
+      this.nodeManager.handleHandInteraction(hand);
+    });
+  }
+  
+  // Check for pinch gesture
+  private checkPinchGesture(hand: XRHandWithHaptics, handedness: XRHandedness): void {
+    // Get thumb and index finger positions
+    const thumbTip = this.jointMeshes.get(`${handedness}-thumb-tip`);
+    const indexTip = this.jointMeshes.get(`${handedness}-index-finger-tip`);
+    
+    if (thumbTip && indexTip) {
+      // Calculate distance
+      const distance = thumbTip.position.distanceTo(indexTip.position);
+      
+      // Detect pinch gesture
+      const isPinching = distance < 0.03; // 3cm threshold
+      
+      // Check for state change
+      const wasPinching = this.pinchState.get(handedness) || false;
+      
+      if (isPinching !== wasPinching) {
+        // Update state
+        this.pinchState.set(handedness, isPinching);
+        
+        // Dispatch events
+        if (isPinching) {
+          this.dispatchEvent('hand-pinchstart', { hand, handedness });
+          
+          // Trigger haptic feedback
+          hand.hapticActuators[0]?.pulse(0.7, 50);
+        } else {
+          this.dispatchEvent('hand-pinchend', { hand, handedness });
+          
+          // Trigger haptic feedback
+          hand.hapticActuators[0]?.pulse(0.3, 30);
+        }
+      }
+    }
+  }
+}
+```
+
+### XR Types (`client/xr/xrTypes.ts`)
+
+The XR Types file defines TypeScript interfaces for XR-related data structures:
+
+```typescript
+// XR Controller interface
+export interface XRController {
+  object: Object3D;
+  inputSource: XRInputSource;
+}
+
+// XR Hand with haptics
+export interface XRHandWithHaptics {
+  inputSource: XRInputSource;
+  controller: Object3D;
+  hand: XRHand;
+  position: Object3D;
+  direction: Object3D;
+  handedness: XRHandedness;
+  hapticActuators: any[];
+}
+
+// Hand joint names
+export const HAND_JOINTS = [
+  'wrist',
+  'thumb-metacarpal',
+  'thumb-phalanx-proximal',
+  'thumb-phalanx-distal',
+  'thumb-tip',
+  'index-finger-metacarpal',
+  'index-finger-phalanx-proximal',
+  'index-finger-phalanx-intermediate',
+  'index-finger-phalanx-distal',
+  'index-finger-tip',
+  'middle-finger-metacarpal',
+  'middle-finger-phalanx-proximal',
+  'middle-finger-phalanx-intermediate',
+  'middle-finger-phalanx-distal',
+  'middle-finger-tip',
+  'ring-finger-metacarpal',
+  'ring-finger-phalanx-proximal',
+  'ring-finger-phalanx-intermediate',
+  'ring-finger-phalanx-distal',
+  'ring-finger-tip',
+  'pinky-finger-metacarpal',
+  'pinky-finger-phalanx-proximal',
+  'pinky-finger-phalanx-intermediate',
+  'pinky-finger-phalanx-distal',
+  'pinky-finger-tip'
+];
+```
+
+## XR Integration Flow
+
+The WebXR integration follows this flow:
+
+```mermaid
+sequenceDiagram
+    participant User
+    participant UIButton
+    participant XRInitializer
+    participant XRSessionManager
+    participant XRInteraction
+    participant HandInteraction
+    participant NodeManager
+    
+    User->>UIButton: Click "Enter VR"
+    UIButton->>XRInitializer: requestXRSession()
+    XRInitializer->>XRSessionManager: startSession("immersive-vr")
+    
+    XRSessionManager->>XRSessionManager: Set up Reference Space
+    XRSessionManager->>XRInteraction: initializeControllers()
+    XRSessionManager->>HandInteraction: initializeHandTracking()
+    
+    XRSessionManager-->>NodeManager: setXRMode(true)
+    
+    loop XR Animation Frame
+        XRSessionManager->>XRInteraction: update()
+        XRSessionManager->>HandInteraction: update()
+        HandInteraction->>NodeManager: handleHandInteraction()
+    end
+    
+    User->>UIButton: Click "Exit VR"
+    UIButton->>XRSessionManager: endSession()
+    XRSessionManager-->>NodeManager: setXRMode(false)
+```
+
+## WebXR Initialization
+
+When the application starts, it checks for WebXR compatibility:
+
+```typescript
+// Check WebXR support
+const xrInitializer = XRInitializer.getInstance();
+const isXRSupported = await xrInitializer.initialize();
+
+// Update UI based on XR support
+if (isXRSupported) {
+  // Show VR button
+  document.getElementById('vr-button')?.classList.remove('hidden');
+} else {
+  // Hide VR button
+  document.getElementById('vr-button')?.classList.add('hidden');
+}
+```
+
+## Entering XR Mode
+
+When the user enters XR mode:
+
+1. The application requests an XR session
+2. Three.js is configured for XR rendering
+3. Controllers and hand tracking are initialized
+4. The scene is configured for optimal XR viewing
+5. Node and edge rendering is adjusted for XR
+
+```typescript
+// Enter XR
+async function enterXR() {
+  try {
+    // Start session
+    const success = await xrSessionManager.startSession('immersive-vr');
+    
+    if (success) {
+      logger.info('Entered XR mode successfully');
+      
+      // Configure scene for XR
+      configureSceneForXR();
+      
+      // Set XR mode for renderers
+      nodeManager.setXRMode(true);
+      edgeManager.setXRMode(true);
+      
+      // Show VR-specific UI
+      showVRUI();
+    } else {
+      logger.error('Failed to enter XR mode');
+    }
+  } catch (error) {
+    logger.error('Error entering XR mode:', error);
+  }
+}
+```
+
+## XR Interaction Handling
+
+XR interactions include controller inputs and hand gestures:
+
+### Controller Interactions
+
+```typescript
+// Handle controller selection
+controller.addEventListener('selectstart', (event) => {
+  // Perform raycasting from controller
+  raycaster.set(
+    controllerWorldPosition,
+    controllerWorldDirection
+  );
+  
+  // Find intersections
+  const intersects = raycaster.intersectObject(nodeManager.getInstancedMesh());
+  
+  if (intersects.length > 0) {
+    // Get instance ID
+    const instanceId = intersects[0].instanceId;
+    
+    // Get node ID from instance ID
+    const nodeId = nodeManager.getNodeId(instanceId);
+    
+    // Select node
+    selectNode(nodeId);
+    
+    // Trigger haptic feedback
+    const gamepad = event.data.gamepad;
+    if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
+      gamepad.hapticActuators[0].pulse(0.7, 100);
+    }
+  }
+});
+```
+
+### Hand Interactions
+
+```typescript
+// Handle pinch gesture
+function handlePinchGesture(hand, isPinching) {
+  if (isPinching) {
+    // Get hand position
+    const handPosition = hand.position.position;
+    
+    // Find closest node
+    const closestNode = findClosestNode(handPosition, 0.1); // 10cm radius
+    
+    if (closestNode) {
+      // Select node
+      selectNode(closestNode.id);
+      
+      // Trigger haptic feedback
+      hand.hapticActuators[0]?.pulse(0.7, 100);
+    }
+  } else {
+    // Release node
+    releaseNode();
+  }
+}
+```
+
+## Node Manipulation in XR
+
+Nodes can be manipulated in XR mode:
+
+```typescript
+// Handle node manipulation in XR
+function manipulateNode(nodeId, hand) {
+  // Get node position
+  const nodePosition = nodeManager.getNodePosition(nodeId);
+  
+  // Get hand position
+  const handPosition = hand.position.position;
+  
+  // Calculate new position
+  const newPosition = new Vector3(
+    handPosition.x,
+    handPosition.y,
+    handPosition.z
+  );
+  
+  // Update node position
+  nodeManager.updateNodePosition(nodeId, newPosition);
+  
+  // Send update to server
+  graphDataManager.updateNodePosition(nodeId, newPosition);
+}
+```
+
+## XR UI Design
+
+In XR mode, the UI is adapted for spatial interaction:
+
+```typescript
+// Create spatial UI element
+function createSpatialUIElement(options) {
+  // Create text geometry
+  const text = textRenderer.createText(options.text);
+  
+  // Create panel
+  const panel = new Mesh(
+    new PlaneGeometry(options.width, options.height),
+    new MeshBasicMaterial({ color: options.color, opacity: 0.7, transparent: true })
+  );
+  
+  // Add text to panel
+  panel.add(text);
+  
+  // Position panel
+  panel.position.copy(options.position);
+  panel.quaternion.copy(options.quaternion);
+  
+  // Add to XR scene
+  scene.add(panel);
+  
+  // Make interactive
+  panel.userData.interactive = true;
+  panel.userData.callback = options.callback;
+  
+  return panel;
+}
+```
+
+## Performance Considerations in XR
+
+XR rendering has specific performance requirements:
+
+1. **Frame Rate**: Maintaining 72-90fps is critical in VR
+2. **Stereo Rendering**: Content is rendered twice (once for each eye)
+3. **Batching**: Draw calls must be minimized
+4. **LOD**: More aggressive level-of-detail may be needed
+
+```typescript
+// Optimize for XR
+function optimizeForXR(enabled) {
+  if (enabled) {
+    // Reduce draw distance
+    nodeManager.setDrawDistance(75);
+    
+    // Reduce geometry detail
+    nodeManager.setDetailLevel(0.7);
+    
+    // Disable expensive post-processing
+    postProcessor.setEnabled(false);
+    
+    // Use instanced rendering
+    nodeManager.useInstancing(true);
+  } else {
+    // Restore normal settings
+    nodeManager.setDrawDistance(100);
+    nodeManager.setDetailLevel(1.0);
+    postProcessor.setEnabled(true);
+  }
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Node Management](node-management.md) - Node rendering details
+- [Rendering Pipeline](rendering-pipeline.md) - Rendering pipeline overview
+- [UI Components](ui-components.md) - User interface components
\ No newline at end of file
diff --git a/docs/clientdocs/core/business-logic.md b/docs/clientdocs/core/business-logic.md
new file mode 100644
index 00000000..858f4321
--- /dev/null
+++ b/docs/clientdocs/core/business-logic.md
@@ -0,0 +1,1005 @@
+# Business Logic
+
+This document provides a comprehensive overview of the core business logic in the client application. It details the central rules, algorithms, and data processing that form the foundation of the application's functionality.
+
+## Core Business Domains
+
+The application's business logic is divided into several domains:
+
+```mermaid
+graph TD
+    BL[Business Logic] --> Graph[Graph Management]
+    BL --> Visualization[Visualization Logic]
+    BL --> Settings[Settings Management]
+    BL --> Auth[Authentication & Authorization]
+    BL --> XR[XR Interaction Logic]
+    
+    Graph --> NodeProcessing[Node Processing]
+    Graph --> EdgeProcessing[Edge Processing]
+    Graph --> DataTransformation[Data Transformation]
+    
+    Visualization --> LayoutCalculation[Layout Calculation]
+    Visualization --> RenderingRules[Rendering Rules]
+    Visualization --> MetadataVisualization[Metadata Visualization]
+    
+    Settings --> Validation[Settings Validation]
+    Settings --> DefaultValues[Default Values]
+    Settings --> PersistenceRules[Persistence Rules]
+```
+
+## Graph Data Management
+
+The graph data management domain handles the core functionality related to the graph structure, including nodes, edges, and metadata.
+
+### Node Identity Rules
+
+```typescript
+// Node identity rules from NodeIdentityManager
+export class NodeIdentityManager {
+  // Rules for generating node labels
+  private generateNodeLabel(nodeId: string, metadata?: NodeMetadata): string {
+    // Rule 1: Use metadata.name if available
+    if (metadata?.name && 
+        typeof metadata.name === 'string' && 
+        metadata.name !== 'undefined' &&
+        metadata.name !== 'null') {
+      return metadata.name;
+    }
+    
+    // Rule 2: Use metadata.file_name if available
+    if (metadata?.file_name && 
+        typeof metadata.file_name === 'string' && 
+        metadata.file_name !== 'undefined' &&
+        metadata.file_name !== 'null') {
+      return metadata.file_name;
+    }
+    
+    // Rule 3: Use node ID with prefix
+    return `Node_${nodeId}`;
+  }
+  
+  // Rules for validating node IDs
+  public isValidNumericId(id: string): boolean {
+    // Ensure the ID is a string and contains only digits
+    return id !== undefined && id !== null && /^\d+$/.test(id);
+  }
+  
+  // Rules for handling duplicate labels
+  private handleDuplicateLabel(label: string, nodeId: string): string {
+    const existingNodes = this.labelToNodeIds.get(label);
+    
+    // If no duplicates exist, use the original label
+    if (!existingNodes || existingNodes.size === 0) {
+      return label;
+    }
+    
+    // If the node is already in the set, use the original label
+    if (existingNodes.has(nodeId)) {
+      return label;
+    }
+    
+    // Add a numeric suffix to make the label unique
+    let counter = 1;
+    let uniqueLabel = `${label} (${counter})`;
+    
+    // Keep incrementing the counter until we find a unique label
+    while (this.labelToNodeIds.has(uniqueLabel)) {
+      counter++;
+      uniqueLabel = `${label} (${counter})`;
+    }
+    
+    return uniqueLabel;
+  }
+}
+```
+
+### Edge Creation Rules
+
+```typescript
+// Rules for creating edges
+export class EdgeManager {
+  // Rules for generating edge IDs
+  private createEdgeId(source: string, target: string): string {
+    // Sort the node IDs to ensure consistent edge IDs regardless of direction
+    // This implements a non-directional edge in the visualization
+    return [source, target].sort().join('_');
+  }
+  
+  // Rules for creating edges
+  public createEdge(source: string, target: string, data?: EdgeData): boolean {
+    // Rule 1: Both source and target nodes must exist
+    if (!this.nodeManager.hasNode(source) || !this.nodeManager.hasNode(target)) {
+      logger.warn(`Cannot create edge: source or target node does not exist (${source}->${target})`);
+      return false;
+    }
+    
+    // Rule 2: Self-loops are not allowed
+    if (source === target) {
+      logger.warn(`Cannot create self-loop edge for node ${source}`);
+      return false;
+    }
+    
+    // Rule 3: Duplicate edges are not allowed
+    const edgeId = this.createEdgeId(source, target);
+    if (this.edges.has(edgeId)) {
+      logger.warn(`Edge already exists between ${source} and ${target}`);
+      return false;
+    }
+    
+    // Create the edge
+    const edge: EdgeWithId = {
+      source,
+      target,
+      data: data || {},
+      id: edgeId
+    };
+    
+    this.edges.set(edgeId, edge);
+    return true;
+  }
+}
+```
+
+### Graph Data Transformation
+
+The application applies several transformations to graph data:
+
+```typescript
+// From client/core/types.ts
+export function transformGraphData(data: any): GraphData {
+  // Ensure nodes is an array
+  const nodes = Array.isArray(data.nodes) ? data.nodes : [];
+  
+  // Ensure edges is an array
+  const edges = Array.isArray(data.edges) ? data.edges : [];
+  
+  // Transform nodes
+  const transformedNodes = nodes.map((node: any) => {
+    // Ensure node has an ID
+    if (!node.id) {
+      logger.warn('Node missing ID:', node);
+      node.id = generateRandomId();
+    }
+    
+    // Ensure node has data object
+    if (!node.data) {
+      node.data = {};
+    }
+    
+    // Ensure position is a Vector3
+    if (!node.data.position) {
+      node.data.position = new Vector3(0, 0, 0);
+    } else if (!(node.data.position instanceof Vector3)) {
+      node.data.position = new Vector3(
+        node.data.position.x || 0,
+        node.data.position.y || 0,
+        node.data.position.z || 0
+      );
+    }
+    
+    // Ensure velocity is a Vector3
+    if (!node.data.velocity) {
+      node.data.velocity = new Vector3(0, 0, 0);
+    } else if (!(node.data.velocity instanceof Vector3)) {
+      node.data.velocity = new Vector3(
+        node.data.velocity.x || 0,
+        node.data.velocity.y || 0,
+        node.data.velocity.z || 0
+      );
+    }
+    
+    return node;
+  });
+  
+  // Transform edges
+  const transformedEdges = edges.map((edge: any) => {
+    // Ensure edge has source and target
+    if (!edge.source || !edge.target) {
+      logger.warn('Edge missing source or target:', edge);
+      return null;
+    }
+    
+    // Ensure edge has data object
+    if (!edge.data) {
+      edge.data = {};
+    }
+    
+    return edge;
+  }).filter(Boolean); // Remove null entries
+  
+  return {
+    nodes: transformedNodes,
+    edges: transformedEdges,
+    metadata: data.metadata || {}
+  };
+}
+```
+
+## Settings Management
+
+The settings management domain handles application configuration, including validation, defaults, and persistence.
+
+### Settings Validation Rules
+
+```typescript
+// From client/types/settings/validation.ts
+export function validateSettings(settings: Partial<Settings>, schema: SettingsSchema): ValidationResult {
+  const errors: ValidationError[] = [];
+  
+  // Validate against schema
+  for (const [path, field] of Object.entries(schema.fields)) {
+    // Get value from nested path
+    const value = getValueAtPath(settings, path);
+    
+    // Skip validation if value is undefined and not required
+    if (value === undefined && !field.required) {
+      continue;
+    }
+    
+    // Check required fields
+    if (field.required && (value === undefined || value === null)) {
+      errors.push({
+        path,
+        message: `${path} is required`,
+        code: 'required'
+      });
+      continue;
+    }
+    
+    // Skip remaining validation if value is undefined or null
+    if (value === undefined || value === null) {
+      continue;
+    }
+    
+    // Type validation
+    if (field.type && typeof value !== field.type) {
+      errors.push({
+        path,
+        message: `${path} must be of type ${field.type}`,
+        code: 'type',
+        details: {
+          expected: field.type,
+          received: typeof value
+        }
+      });
+      continue;
+    }
+    
+    // Numeric validations
+    if (field.type === 'number' && typeof value === 'number') {
+      // Minimum value
+      if (field.min !== undefined && value < field.min) {
+        errors.push({
+          path,
+          message: `${path} must be at least ${field.min}`,
+          code: 'min',
+          details: {
+            min: field.min,
+            value
+          }
+        });
+      }
+      
+      // Maximum value
+      if (field.max !== undefined && value > field.max) {
+        errors.push({
+          path,
+          message: `${path} must be at most ${field.max}`,
+          code: 'max',
+          details: {
+            max: field.max,
+            value
+          }
+        });
+      }
+    }
+    
+    // String validations
+    if (field.type === 'string' && typeof value === 'string') {
+      // Minimum length
+      if (field.minLength !== undefined && value.length < field.minLength) {
+        errors.push({
+          path,
+          message: `${path} must be at least ${field.minLength} characters`,
+          code: 'minLength',
+          details: {
+            minLength: field.minLength,
+            length: value.length
+          }
+        });
+      }
+      
+      // Maximum length
+      if (field.maxLength !== undefined && value.length > field.maxLength) {
+        errors.push({
+          path,
+          message: `${path} must be at most ${field.maxLength} characters`,
+          code: 'maxLength',
+          details: {
+            maxLength: field.maxLength,
+            length: value.length
+          }
+        });
+      }
+      
+      // Pattern
+      if (field.pattern && !new RegExp(field.pattern).test(value)) {
+        errors.push({
+          path,
+          message: `${path} must match pattern ${field.pattern}`,
+          code: 'pattern',
+          details: {
+            pattern: field.pattern,
+            value
+          }
+        });
+      }
+    }
+    
+    // Enum validation
+    if (field.enum && !field.enum.includes(value)) {
+      errors.push({
+        path,
+        message: `${path} must be one of: ${field.enum.join(', ')}`,
+        code: 'enum',
+        details: {
+          allowed: field.enum,
+          value
+        }
+      });
+    }
+  }
+  
+  return {
+    valid: errors.length === 0,
+    errors
+  };
+}
+```
+
+### Default Settings
+
+The application provides default settings for various components:
+
+```typescript
+// From client/state/defaultSettings.ts
+export const defaultSettings: Settings = {
+  visualization: {
+    nodes: {
+      size: 1,
+      color: '#4CAF50',
+      opacity: 0.8,
+      detail: 'medium',
+      highlighted: {
+        color: '#FF4444',
+        scale: 1.2
+      }
+    },
+    edges: {
+      thickness: 0.25,
+      color: '#E0E0E0',
+      opacity: 0.6,
+      highlight: {
+        color: '#FFFF00',
+        thickness: 0.5
+      }
+    },
+    labels: {
+      visible: true,
+      size: 1,
+      color: '#FFFFFF',
+      backgroundColor: 'rgba(0,0,0,0.3)',
+      visibilityThreshold: 15,
+      font: 'Roboto'
+    },
+    rendering: {
+      quality: 'high',
+      antialiasing: true,
+      shadows: false,
+      bloomEffect: false,
+      outlineEffect: true
+    },
+    animations: {
+      enabled: true,
+      duration: 0.5,
+      easing: 'easeInOutCubic'
+    },
+    background: {
+      color: '#212121',
+      opacity: 1
+    },
+    bloom: {
+      enabled: false,
+      strength: 1.5,
+      threshold: 0.85,
+      radius: 0.4
+    },
+    hologram: {
+      enabled: false,
+      color: '#00FFFF',
+      opacity: 0.8,
+      scanlineIntensity: 0.5,
+      glowIntensity: 0.3
+    }
+  },
+  physics: {
+    enabled: true,
+    gravity: 0,
+    friction: 0.1,
+    attractionForce: 0.01,
+    repulsionForce: 0.1,
+    maxSpeed: 1,
+    defaultMass: 1
+  },
+  camera: {
+    fov: 75,
+    near: 0.1,
+    far: 1000,
+    position: { x: 0, y: 0, z: 50 },
+    lookAt: { x: 0, y: 0, z: 0 },
+    controls: {
+      rotateSpeed: 1,
+      zoomSpeed: 1.2,
+      panSpeed: 0.8,
+      dampingFactor: 0.2,
+      enableDamping: true
+    }
+  },
+  xr: {
+    enabled: true,
+    handTracking: true,
+    defaultReferenceSpace: 'local-floor',
+    controllerModelEnabled: true,
+    interactionDistance: 0.5,
+    locomotion: {
+      enabled: true,
+      type: 'teleport',
+      speed: 2
+    }
+  },
+  network: {
+    reconnectDelay: 1000,
+    maxReconnectAttempts: 5,
+    compressionEnabled: true,
+    binaryProtocolEnabled: true
+  },
+  debug: {
+    enabled: false,
+    showPerformanceStats: false,
+    logLevel: 'warn',
+    showBoundingBoxes: false,
+    showNodeIds: false,
+    showPositions: false
+  }
+};
+```
+
+### Settings Persistence Rules
+
+```typescript
+// From client/services/SettingsPersistenceService.ts
+export class SettingsPersistenceService {
+  private static instance: SettingsPersistenceService;
+  private serverPersistenceEnabled: boolean = true;
+  private localPersistenceEnabled: boolean = true;
+  
+  // Get instance (singleton pattern)
+  public static getInstance(): SettingsPersistenceService {
+    if (!SettingsPersistenceService.instance) {
+      SettingsPersistenceService.instance = new SettingsPersistenceService();
+    }
+    return SettingsPersistenceService.instance;
+  }
+  
+  // Save settings
+  public async saveSettings(settings: Settings): Promise<boolean> {
+    try {
+      // Local persistence
+      if (this.localPersistenceEnabled) {
+        this.saveToLocalStorage(settings);
+      }
+      
+      // Server persistence
+      if (this.serverPersistenceEnabled) {
+        await this.saveToServer(settings);
+      }
+      
+      return true;
+    } catch (error) {
+      logger.error('Failed to save settings:', createErrorMetadata(error));
+      return false;
+    }
+  }
+  
+  // Load settings
+  public async loadSettings(): Promise<Settings | null> {
+    try {
+      // Try server first
+      if (this.serverPersistenceEnabled) {
+        const serverSettings = await this.loadFromServer();
+        if (serverSettings) {
+          return serverSettings;
+        }
+      }
+      
+      // Fall back to local storage
+      if (this.localPersistenceEnabled) {
+        const localSettings = this.loadFromLocalStorage();
+        if (localSettings) {
+          return localSettings;
+        }
+      }
+      
+      // Return default settings
+      return null;
+    } catch (error) {
+      logger.error('Failed to load settings:', createErrorMetadata(error));
+      return null;
+    }
+  }
+  
+  // Save to local storage
+  private saveToLocalStorage(settings: Settings): void {
+    try {
+      localStorage.setItem('app_settings', JSON.stringify(settings));
+    } catch (error) {
+      logger.error('Failed to save settings to local storage:', createErrorMetadata(error));
+      throw error;
+    }
+  }
+  
+  // Load from local storage
+  private loadFromLocalStorage(): Settings | null {
+    try {
+      const settingsJson = localStorage.getItem('app_settings');
+      if (!settingsJson) {
+        return null;
+      }
+      
+      return JSON.parse(settingsJson);
+    } catch (error) {
+      logger.error('Failed to load settings from local storage:', createErrorMetadata(error));
+      return null;
+    }
+  }
+  
+  // Save to server
+  private async saveToServer(settings: Settings): Promise<void> {
+    try {
+      const response = await fetch(buildApiUrl(API_ENDPOINTS.SETTINGS_ROOT), {
+        method: 'POST',
+        headers: getAuthHeaders(),
+        body: JSON.stringify(settings)
+      });
+      
+      if (!response.ok) {
+        throw new Error(`Failed to save settings to server: ${response.status} ${response.statusText}`);
+      }
+    } catch (error) {
+      logger.error('Failed to save settings to server:', createErrorMetadata(error));
+      throw error;
+    }
+  }
+  
+  // Load from server
+  private async loadFromServer(): Promise<Settings | null> {
+    try {
+      const response = await fetch(buildApiUrl(API_ENDPOINTS.SETTINGS_ROOT), {
+        method: 'GET',
+        headers: getAuthHeaders()
+      });
+      
+      if (!response.ok) {
+        if (response.status === 404) {
+          // Settings not found on server, but not an error
+          return null;
+        }
+        throw new Error(`Failed to load settings from server: ${response.status} ${response.statusText}`);
+      }
+      
+      return await response.json();
+    } catch (error) {
+      logger.error('Failed to load settings from server:', createErrorMetadata(error));
+      return null;
+    }
+  }
+}
+```
+
+## Visualization Logic
+
+The visualization logic domain handles the rules and algorithms for visualizing the graph data.
+
+### Node Size Calculation
+
+```typescript
+// From client/rendering/node/NodeManagerFacade.ts
+private calculateNodeSize(fileSize: number = DEFAULT_FILE_SIZE): number {
+  // Map file size logarithmically to 0-1 range
+  const normalizedSize = Math.log(Math.min(fileSize, MAX_FILE_SIZE)) / Math.log(MAX_FILE_SIZE);
+  // Map to node size range
+  return MIN_NODE_SIZE + normalizedSize * (MAX_NODE_SIZE - MIN_NODE_SIZE);
+}
+```
+
+### Label Visibility Logic
+
+```typescript
+// From client/rendering/node/metadata/NodeMetadataManager.ts
+public updateVisibility(camera: Camera): void {
+  // Skip if no camera
+  if (!camera) return;
+  
+  // Get camera position
+  const cameraPosition = camera.position;
+  
+  // Update each label
+  this.labels.forEach((label, nodeId) => {
+    // Get label data
+    const labelData = this.labelData.get(nodeId);
+    if (!labelData || !labelData.position) return;
+    
+    // Calculate distance to camera
+    const distance = cameraPosition.distanceTo(labelData.position);
+    
+    // Calculate visibility threshold based on label importance
+    const importanceFactor = 1 + (labelData.importance || 0) * 0.5;
+    const threshold = this.visibilityThreshold * importanceFactor;
+    
+    // Update visibility
+    const visible = distance < threshold;
+    if (label.visible !== visible) {
+      label.visible = visible;
+    }
+  });
+}
+```
+
+### Node Highlight Logic
+
+```typescript
+// From client/rendering/node/interaction/NodeInteractionManager.ts
+private highlightNode(nodeId: string, highlighted: boolean): void {
+  // Get node instance index
+  const instanceIndex = this.nodeManager.getInstanceIndex(nodeId);
+  if (instanceIndex === undefined) return;
+  
+  // Get current node color and size
+  const currentColor = new Color();
+  this.instancedMesh.getColorAt(instanceIndex, currentColor);
+  
+  // Get highlight settings
+  const highlightColor = new Color(this.settings.visualization.nodes.highlighted.color);
+  const normalColor = new Color(this.settings.visualization.nodes.color);
+  
+  // Set color
+  const targetColor = highlighted ? highlightColor : normalColor;
+  this.instancedMesh.setColorAt(instanceIndex, targetColor);
+  
+  // Update instance color attribute
+  if (this.instancedMesh.instanceColor) {
+    this.instancedMesh.instanceColor.needsUpdate = true;
+  }
+  
+  // Update scale in matrix
+  this.updateNodeScale(nodeId, highlighted ? 
+    this.settings.visualization.nodes.highlighted.scale : 1);
+}
+```
+
+## XR Interaction Logic
+
+The XR interaction domain handles the rules and algorithms for interacting with the application in XR mode.
+
+### Hand Gesture Recognition
+
+```typescript
+// From client/xr/handInteraction.ts
+private detectPinchGesture(hand: XRHand): boolean {
+  // Get joint positions
+  const thumbTip = hand.get('thumb-tip');
+  const indexTip = hand.get('index-finger-tip');
+  
+  // Skip if either joint is missing
+  if (!thumbTip || !indexTip) return false;
+  
+  // Get joint poses
+  const thumbPose = this.frame.getJointPose(thumbTip, this.referenceSpace);
+  const indexPose = this.frame.getJointPose(indexTip, this.referenceSpace);
+  
+  // Skip if either pose is missing
+  if (!thumbPose || !indexPose) return false;
+  
+  // Calculate distance between thumb and index finger
+  const thumbPosition = new Vector3(
+    thumbPose.transform.position.x,
+    thumbPose.transform.position.y,
+    thumbPose.transform.position.z
+  );
+  
+  const indexPosition = new Vector3(
+    indexPose.transform.position.x,
+    indexPose.transform.position.y,
+    indexPose.transform.position.z
+  );
+  
+  const distance = thumbPosition.distanceTo(indexPosition);
+  
+  // Pinch threshold in meters
+  const PINCH_THRESHOLD = 0.03; // 3cm
+  
+  return distance < PINCH_THRESHOLD;
+}
+```
+
+### XR Node Selection Logic
+
+```typescript
+// From client/xr/xrInteraction.ts
+private handleControllerSelection(controller: XRController): void {
+  // Create raycaster from controller
+  this.raycaster.set(
+    controller.position,
+    controller.direction.normalize()
+  );
+  
+  // Intersect with nodes
+  const intersects = this.raycaster.intersectObject(this.nodeManager.getInstancedMesh());
+  
+  // Find closest intersection
+  const closestIntersection = intersects[0];
+  if (!closestIntersection) return;
+  
+  // Get instance ID
+  const instanceId = closestIntersection.instanceId;
+  if (instanceId === undefined) return;
+  
+  // Get node ID
+  const nodeId = this.nodeManager.getNodeId(instanceId);
+  if (!nodeId) return;
+  
+  // Select node
+  this.selectNode(nodeId);
+  
+  // Trigger haptic feedback
+  this.triggerHapticFeedback(controller, 'selection');
+}
+```
+
+## Authentication Logic
+
+The authentication domain handles user authentication and authorization.
+
+### Token Validation
+
+```typescript
+// From client/services/NostrAuthService.ts
+public isAuthenticated(): boolean {
+  // Check if token exists
+  if (!this.token || !this.pubkey) {
+    return false;
+  }
+  
+  // Check if token is expired
+  if (this.expiresAt && Date.now() > this.expiresAt) {
+    this.logout(); // Auto-logout if token is expired
+    return false;
+  }
+  
+  return true;
+}
+```
+
+### Nostr Authentication Logic
+
+```typescript
+// From client/services/NostrAuthService.ts
+public async authenticate(nsec: string): Promise<boolean> {
+  try {
+    // Parse private key
+    const privateKey = nsec.startsWith('nsec') 
+      ? nip19.decode(nsec).data as Uint8Array
+      : Buffer.from(nsec, 'hex');
+    
+    // Derive public key
+    const publicKey = nobleSecp256k1.schnorr.getPublicKey(privateKey);
+    const pubkeyHex = Buffer.from(publicKey).toString('hex');
+    
+    // Request challenge
+    const challenge = await this.requestChallenge(pubkeyHex);
+    
+    // Sign challenge
+    const signature = await this.signChallenge(challenge, privateKey);
+    
+    // Verify signature
+    const result = await this.verifySignature(pubkeyHex, challenge, signature);
+    
+    if (result.success) {
+      // Store auth data
+      this.token = result.token;
+      this.pubkey = pubkeyHex;
+      this.expiresAt = result.expiresAt;
+      
+      // Save to local storage
+      localStorage.setItem('nostr_token', result.token);
+      localStorage.setItem('nostr_pubkey', pubkeyHex);
+      localStorage.setItem('nostr_expires', result.expiresAt.toString());
+      
+      // Notify listeners
+      this.notifyListeners(true);
+      
+      return true;
+    } else {
+      return false;
+    }
+  } catch (error) {
+    logger.error('Authentication failed:', createErrorMetadata(error));
+    return false;
+  }
+}
+```
+
+## Business Rules Implementation
+
+The business rules are implemented through various classes and functions. Key implementation patterns include:
+
+### Strategy Pattern
+
+```typescript
+// Abstract strategy interface
+interface LayoutStrategy {
+  calculateLayout(nodes: Node[], edges: Edge[]): void;
+  update(deltaTime: number): void;
+}
+
+// Concrete strategies
+class ForceDirectedLayout implements LayoutStrategy {
+  // Implementation
+}
+
+class GridLayout implements LayoutStrategy {
+  // Implementation
+}
+
+class RadialLayout implements LayoutStrategy {
+  // Implementation
+}
+
+// Context using the strategy
+class GraphLayoutManager {
+  private strategy: LayoutStrategy;
+  
+  constructor(strategy: LayoutStrategy) {
+    this.strategy = strategy;
+  }
+  
+  setStrategy(strategy: LayoutStrategy): void {
+    this.strategy = strategy;
+  }
+  
+  calculateLayout(nodes: Node[], edges: Edge[]): void {
+    this.strategy.calculateLayout(nodes, edges);
+  }
+  
+  update(deltaTime: number): void {
+    this.strategy.update(deltaTime);
+  }
+}
+```
+
+### Observer Pattern
+
+```typescript
+// Subject interface
+interface Subject {
+  subscribe(observer: Observer): () => void;
+  unsubscribe(observer: Observer): void;
+  notify(data: any): void;
+}
+
+// Observer interface
+interface Observer {
+  update(data: any): void;
+}
+
+// Concrete subject
+class GraphState implements Subject {
+  private observers: Set<Observer> = new Set();
+  private data: GraphData;
+  
+  subscribe(observer: Observer): () => void {
+    this.observers.add(observer);
+    return () => this.unsubscribe(observer);
+  }
+  
+  unsubscribe(observer: Observer): void {
+    this.observers.delete(observer);
+  }
+  
+  notify(data: GraphData): void {
+    this.observers.forEach(observer => {
+      try {
+        observer.update(data);
+      } catch (error) {
+        logger.error('Error notifying observer:', createErrorMetadata(error));
+      }
+    });
+  }
+  
+  updateData(data: GraphData): void {
+    this.data = data;
+    this.notify(data);
+  }
+}
+
+// Concrete observer
+class NodeRenderer implements Observer {
+  update(data: GraphData): void {
+    // Update node rendering
+  }
+}
+```
+
+### Command Pattern
+
+```typescript
+// Command interface
+interface Command {
+  execute(): void;
+  undo(): void;
+}
+
+// Concrete commands
+class AddNodeCommand implements Command {
+  private node: Node;
+  private graphManager: GraphDataManager;
+  
+  constructor(node: Node, graphManager: GraphDataManager) {
+    this.node = node;
+    this.graphManager = graphManager;
+  }
+  
+  execute(): void {
+    this.graphManager.addNode(this.node);
+  }
+  
+  undo(): void {
+    this.graphManager.removeNode(this.node.id);
+  }
+}
+
+// Command invoker
+class CommandManager {
+  private commands: Command[] = [];
+  private undoneCommands: Command[] = [];
+  
+  execute(command: Command): void {
+    command.execute();
+    this.commands.push(command);
+    this.undoneCommands = [];
+  }
+  
+  undo(): void {
+    const command = this.commands.pop();
+    if (command) {
+      command.undo();
+      this.undoneCommands.push(command);
+    }
+  }
+  
+  redo(): void {
+    const command = this.undoneCommands.pop();
+    if (command) {
+      command.execute();
+      this.commands.push(command);
+    }
+  }
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Error Handling](error-handling.md) - Error handling patterns
+- [Performance](performance.md) - Performance considerations
+- [Technical Debt](technical-debt.md) - Technical debt analysis
\ No newline at end of file
diff --git a/docs/clientdocs/core/error-handling.md b/docs/clientdocs/core/error-handling.md
new file mode 100644
index 00000000..67901f75
--- /dev/null
+++ b/docs/clientdocs/core/error-handling.md
@@ -0,0 +1,1035 @@
+# Error Handling
+
+This document provides a comprehensive overview of the error handling patterns and strategies implemented throughout the client application. Proper error handling is essential for creating a robust and user-friendly application.
+
+## Error Handling Philosophy
+
+The application follows several key principles for error handling:
+
+1. **Graceful Degradation** - Errors should not crash the application; instead, fallback behaviors should be implemented
+2. **Detailed Logging** - Errors should be logged with sufficient context for troubleshooting
+3. **User Feedback** - Users should be notified of errors when appropriate, with clear messaging
+4. **Recovery Strategies** - Where possible, the application should attempt to recover from errors
+5. **Consistent Patterns** - Error handling should follow consistent patterns throughout the codebase
+
+## Error Classification
+
+Errors in the application are classified into several categories:
+
+```mermaid
+graph TD
+    Error[Application Errors] --> Network[Network Errors]
+    Error --> Data[Data Errors]
+    Error --> Rendering[Rendering Errors]
+    Error --> State[State Management Errors]
+    Error --> WebGL[WebGL Errors]
+    Error --> XR[XR Errors]
+    Error --> UI[UI Errors]
+    
+    Network --> ConnectionErrors[Connection Errors]
+    Network --> APIErrors[API Errors]
+    Network --> WebSocketErrors[WebSocket Errors]
+    
+    Data --> ValidationErrors[Validation Errors]
+    Data --> ParsingErrors[Parsing Errors]
+    Data --> TransformationErrors[Transformation Errors]
+    
+    Rendering --> ResourceErrors[Resource Errors]
+    Rendering --> PerformanceErrors[Performance Errors]
+    Rendering --> VisibilityErrors[Visibility Errors]
+```
+
+## Error Handling Architecture
+
+The application uses a centralized error handling architecture:
+
+```mermaid
+flowchart LR
+    subgraph Application
+        Component[Component]
+        ErrorBoundary[Error Boundary]
+        Logger[Logger]
+        MonitoringService[Monitoring]
+        ErrorHandler[Error Handler]
+        UINotification[UI Notification]
+    end
+    
+    Component -- throws --> ErrorBoundary
+    Component -- logs --> Logger
+    ErrorBoundary -- reports --> Logger
+    ErrorBoundary -- displays --> UINotification
+    Logger -- sends --> MonitoringService
+    Logger -- calls --> ErrorHandler
+    ErrorHandler -- triggers --> UINotification
+```
+
+## Centralized Logging
+
+The application uses a centralized logging system defined in `client/core/logger.ts`:
+
+```typescript
+// Logger interface
+export interface Logger {
+  debug(message: string, ...meta: any[]): void;
+  info(message: string, ...meta: any[]): void;
+  warn(message: string, ...meta: any[]): void;
+  error(message: string, ...meta: any[]): void;
+}
+
+// Create logger with metadata helpers
+export function createLogger(name: string): Logger {
+  return {
+    debug: (message: string, ...meta: any[]) => {
+      if (debugState.isEnabled()) {
+        console.debug(`[${name}] ${message}`, ...meta);
+      }
+    },
+    info: (message: string, ...meta: any[]) => {
+      console.info(`[${name}] ${message}`, ...meta);
+    },
+    warn: (message: string, ...meta: any[]) => {
+      console.warn(`[${name}] ${message}`, ...meta);
+    },
+    error: (message: string, ...meta: any[]) => {
+      console.error(`[${name}] ${message}`, ...meta);
+      // Here we could also send to an error monitoring service
+    }
+  };
+}
+
+// Helper for creating error metadata
+export function createErrorMetadata(error: any): any {
+  return {
+    message: error.message || String(error),
+    stack: error.stack,
+    code: error.code,
+    name: error.name,
+    cause: error.cause
+  };
+}
+
+// Helper for creating data metadata
+export function createDataMetadata(data: any): any {
+  return data;
+}
+
+// Helper for creating message metadata
+export function createMessageMetadata(message: any): any {
+  if (typeof message === 'string') {
+    return { message };
+  }
+  return message;
+}
+```
+
+## Custom Error Types
+
+The application defines custom error types for different components:
+
+### Node Manager Errors
+
+```typescript
+// From client/rendering/node/NodeManagerInterface.ts
+export enum NodeManagerErrorType {
+  INITIALIZATION_FAILED = 'initialization_failed',
+  UPDATE_FAILED = 'update_failed',
+  RESOURCE_CLEANUP_FAILED = 'resource_cleanup_failed',
+  INVALID_NODE_ID = 'invalid_node_id',
+  XR_MODE_SWITCH_FAILED = 'xr_mode_switch_failed'
+}
+
+export class NodeManagerError extends Error {
+  type: NodeManagerErrorType;
+  cause?: any;
+  
+  constructor(type: NodeManagerErrorType, message: string, cause?: any) {
+    super(message);
+    this.name = 'NodeManagerError';
+    this.type = type;
+    this.cause = cause;
+  }
+}
+```
+
+### API Errors
+
+```typescript
+// API error handling
+export enum APIErrorType {
+  NETWORK_ERROR = 'network_error',
+  SERVER_ERROR = 'server_error',
+  AUTHENTICATION_ERROR = 'authentication_error',
+  VALIDATION_ERROR = 'validation_error',
+  NOT_FOUND = 'not_found',
+  REQUEST_TIMEOUT = 'request_timeout'
+}
+
+export class APIError extends Error {
+  type: APIErrorType;
+  statusCode?: number;
+  response?: any;
+  
+  constructor(type: APIErrorType, message: string, statusCode?: number, response?: any) {
+    super(message);
+    this.name = 'APIError';
+    this.type = type;
+    this.statusCode = statusCode;
+    this.response = response;
+  }
+}
+```
+
+## Error Handling Patterns
+
+### Try-Catch Pattern
+
+For synchronous operations, the try-catch pattern is used:
+
+```typescript
+try {
+  // Perform operation that might throw
+  const result = doSomethingRisky();
+  return result;
+} catch (error) {
+  // Log error
+  logger.error('Operation failed:', createErrorMetadata(error));
+  
+  // Handle error
+  handleError(error);
+  
+  // Return fallback or throw
+  return fallbackValue;
+}
+```
+
+### Promise Catch Pattern
+
+For asynchronous operations, promises with catch handlers are used:
+
+```typescript
+doSomethingAsync()
+  .then(result => {
+    // Process result
+    return processResult(result);
+  })
+  .catch(error => {
+    // Log error
+    logger.error('Async operation failed:', createErrorMetadata(error));
+    
+    // Handle error
+    handleAsyncError(error);
+    
+    // Return fallback or throw
+    return fallbackValue;
+  });
+```
+
+### Async/Await with Try-Catch
+
+For modern async code, async/await with try-catch is used:
+
+```typescript
+async function performOperation() {
+  try {
+    // Perform async operation
+    const result = await doSomethingAsync();
+    return processResult(result);
+  } catch (error) {
+    // Log error
+    logger.error('Async operation failed:', createErrorMetadata(error));
+    
+    // Handle error
+    await handleAsyncError(error);
+    
+    // Return fallback or throw
+    return fallbackValue;
+  }
+}
+```
+
+## Network Error Handling
+
+### API Request Error Handling
+
+```typescript
+async function fetchWithErrorHandling(url: string, options?: RequestInit): Promise<any> {
+  try {
+    // Add timeout
+    const controller = new AbortController();
+    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
+    
+    const response = await fetch(url, {
+      ...options,
+      signal: controller.signal
+    });
+    
+    // Clear timeout
+    clearTimeout(timeoutId);
+    
+    // Check for HTTP errors
+    if (!response.ok) {
+      let errorData;
+      try {
+        // Try to parse error JSON
+        errorData = await response.json();
+      } catch {
+        // If parsing fails, use status text
+        errorData = { message: response.statusText };
+      }
+      
+      // Determine error type
+      let errorType: APIErrorType;
+      switch (response.status) {
+        case 401:
+        case 403:
+          errorType = APIErrorType.AUTHENTICATION_ERROR;
+          break;
+        case 404:
+          errorType = APIErrorType.NOT_FOUND;
+          break;
+        case 422:
+          errorType = APIErrorType.VALIDATION_ERROR;
+          break;
+        default:
+          errorType = APIErrorType.SERVER_ERROR;
+          break;
+      }
+      
+      throw new APIError(
+        errorType,
+        errorData.message || `Request failed with status ${response.status}`,
+        response.status,
+        errorData
+      );
+    }
+    
+    // Parse response
+    return await response.json();
+  } catch (error) {
+    // Handle specific error types
+    if (error instanceof APIError) {
+      throw error; // Re-throw APIError
+    } else if (error.name === 'AbortError') {
+      // Timeout error
+      throw new APIError(
+        APIErrorType.REQUEST_TIMEOUT,
+        'Request timed out after 30 seconds',
+        undefined,
+        { originalError: error }
+      );
+    } else {
+      // Network or other error
+      throw new APIError(
+        APIErrorType.NETWORK_ERROR,
+        error.message || 'Network request failed',
+        undefined,
+        { originalError: error }
+      );
+    }
+  }
+}
+```
+
+### WebSocket Error Handling
+
+```typescript
+// WebSocket connection error handling
+private handleWebSocketError(event: Event): void {
+  logger.error('WebSocket error:', createDataMetadata(event));
+  
+  // Update connection state
+  this.connectionState = ConnectionState.RECONNECTING;
+  
+  // Notify status handlers
+  if (this.connectionStatusHandler) {
+    this.connectionStatusHandler(false);
+  }
+  
+  // Attempt reconnection
+  this.handleReconnect();
+}
+
+// WebSocket reconnection with exponential backoff
+private handleReconnect(): void {
+  if (this.reconnectAttempts >= this.maxReconnectAttempts) {
+    logger.error('WebSocket reconnection failed after maximum attempts');
+    this.connectionState = ConnectionState.FAILED;
+    
+    // Update UI
+    if (this.connectionStatusHandler) {
+      this.connectionStatusHandler(false);
+    }
+    
+    return;
+  }
+  
+  // Calculate delay with exponential backoff
+  const delay = Math.min(
+    this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts),
+    this.maxReconnectDelay
+  ) + (Math.random() * 1000); // Add jitter
+  
+  logger.info(`WebSocket reconnecting in ${Math.round(delay/1000)}s (attempt ${this.reconnectAttempts + 1} of ${this.maxReconnectAttempts})`);
+  
+  // Schedule reconnection
+  this.reconnectTimeout = window.setTimeout(() => {
+    this.reconnectAttempts++;
+    this.reconnectTimeout = null;
+    this.connect();
+  }, delay);
+}
+```
+
+## Rendering Error Handling
+
+### WebGL Error Detection
+
+```typescript
+function checkWebGLError(gl: WebGLRenderingContext, operation: string): boolean {
+  const error = gl.getError();
+  if (error !== gl.NO_ERROR) {
+    let errorName;
+    switch (error) {
+      case gl.INVALID_ENUM:
+        errorName = 'INVALID_ENUM';
+        break;
+      case gl.INVALID_VALUE:
+        errorName = 'INVALID_VALUE';
+        break;
+      case gl.INVALID_OPERATION:
+        errorName = 'INVALID_OPERATION';
+        break;
+      case gl.OUT_OF_MEMORY:
+        errorName = 'OUT_OF_MEMORY';
+        break;
+      case gl.CONTEXT_LOST_WEBGL:
+        errorName = 'CONTEXT_LOST_WEBGL';
+        break;
+      default:
+        errorName = `Unknown Error (${error})`;
+    }
+    
+    logger.error(`WebGL error in ${operation}: ${errorName}`);
+    return true;
+  }
+  return false;
+}
+```
+
+### WebGL Context Loss Handling
+
+```typescript
+// Set up context loss handler
+this.renderer.domElement.addEventListener('webglcontextlost', this.handleContextLoss);
+this.renderer.domElement.addEventListener('webglcontextrestored', this.handleContextRestore);
+
+// Handle WebGL context loss
+private handleContextLoss = (event: Event): void => {
+  event.preventDefault(); // Allow context to be restored
+  
+  logger.error('WebGL context lost');
+  
+  // Pause rendering
+  this.isPaused = true;
+  
+  // Notify user
+  this.showError('WebGL context lost. Attempting to restore...');
+};
+
+// Handle WebGL context restoration
+private handleContextRestore = (): void => {
+  logger.info('WebGL context restored');
+  
+  // Reinitialize resources
+  this.reinitializeResources();
+  
+  // Resume rendering
+  this.isPaused = false;
+  
+  // Clear error message
+  this.clearError();
+};
+
+// Reinitialize WebGL resources
+private reinitializeResources(): void {
+  try {
+    // Recreate materials
+    this.nodeManager.reloadMaterials();
+    this.edgeManager.reloadMaterials();
+    
+    // Recreate textures
+    this.textRenderer.reloadTextures();
+    
+    logger.info('WebGL resources reinitialized successfully');
+  } catch (error) {
+    logger.error('Failed to reinitialize WebGL resources:', createErrorMetadata(error));
+    
+    // Show fatal error
+    this.showFatalError('Failed to restore WebGL context. Please reload the page.');
+  }
+}
+```
+
+## Data Validation and Error Handling
+
+### Schema Validation
+
+```typescript
+// Validate settings against schema
+function validateSettings(settings: any, schema: SettingsSchema): ValidationResult {
+  const errors: ValidationError[] = [];
+  
+  // Check required fields
+  for (const [key, fieldSchema] of Object.entries(schema.fields)) {
+    if (fieldSchema.required && (settings[key] === undefined || settings[key] === null)) {
+      errors.push({
+        field: key,
+        message: `${key} is required`,
+        code: 'required'
+      });
+      continue;
+    }
+    
+    // Skip validation if value is undefined/null and not required
+    if (settings[key] === undefined || settings[key] === null) {
+      continue;
+    }
+    
+    // Type validation
+    if (fieldSchema.type && typeof settings[key] !== fieldSchema.type) {
+      errors.push({
+        field: key,
+        message: `${key} must be of type ${fieldSchema.type}`,
+        code: 'type',
+        expected: fieldSchema.type,
+        received: typeof settings[key]
+      });
+    }
+    
+    // Range validation for numbers
+    if (
+      fieldSchema.type === 'number' && 
+      typeof settings[key] === 'number'
+    ) {
+      if (fieldSchema.min !== undefined && settings[key] < fieldSchema.min) {
+        errors.push({
+          field: key,
+          message: `${key} must be at least ${fieldSchema.min}`,
+          code: 'min',
+          min: fieldSchema.min,
+          value: settings[key]
+        });
+      }
+      
+      if (fieldSchema.max !== undefined && settings[key] > fieldSchema.max) {
+        errors.push({
+          field: key,
+          message: `${key} must be at most ${fieldSchema.max}`,
+          code: 'max',
+          max: fieldSchema.max,
+          value: settings[key]
+        });
+      }
+    }
+    
+    // Pattern validation for strings
+    if (
+      fieldSchema.type === 'string' && 
+      typeof settings[key] === 'string' &&
+      fieldSchema.pattern && 
+      !new RegExp(fieldSchema.pattern).test(settings[key])
+    ) {
+      errors.push({
+        field: key,
+        message: `${key} does not match required pattern`,
+        code: 'pattern',
+        pattern: fieldSchema.pattern,
+        value: settings[key]
+      });
+    }
+    
+    // Enum validation
+    if (
+      fieldSchema.enum && 
+      !fieldSchema.enum.includes(settings[key])
+    ) {
+      errors.push({
+        field: key,
+        message: `${key} must be one of: ${fieldSchema.enum.join(', ')}`,
+        code: 'enum',
+        allowed: fieldSchema.enum,
+        value: settings[key]
+      });
+    }
+  }
+  
+  return {
+    valid: errors.length === 0,
+    errors
+  };
+}
+```
+
+### Input Sanitization
+
+```typescript
+// Sanitize user input
+function sanitizeInput(input: string): string {
+  // Remove HTML tags
+  let sanitized = input.replace(/<[^>]*>/g, '');
+  
+  // Remove script tags and content
+  sanitized = sanitized.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
+  
+  // Encode HTML entities
+  sanitized = sanitized
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&#039;');
+  
+  return sanitized;
+}
+```
+
+## UI Error Handling
+
+### Error Display Component
+
+```typescript
+function ErrorDisplay({ error, onRetry, onDismiss }: ErrorDisplayProps) {
+  // If no error, don't render anything
+  if (!error) return null;
+  
+  // Determine error type and message
+  let errorMessage = 'An unexpected error occurred.';
+  let errorType = 'error';
+  
+  if (typeof error === 'string') {
+    errorMessage = error;
+  } else if (error instanceof Error) {
+    errorMessage = error.message || 'An unexpected error occurred.';
+    
+    // Determine error type
+    if (error instanceof APIError) {
+      switch (error.type) {
+        case APIErrorType.NETWORK_ERROR:
+          errorType = 'network';
+          break;
+        case APIErrorType.AUTHENTICATION_ERROR:
+          errorType = 'auth';
+          break;
+        case APIErrorType.SERVER_ERROR:
+          errorType = 'server';
+          break;
+        case APIErrorType.VALIDATION_ERROR:
+          errorType = 'validation';
+          break;
+        default:
+          errorType = 'api';
+      }
+    } else if (error instanceof NodeManagerError) {
+      errorType = 'rendering';
+    }
+  }
+  
+  return (
+    <div className={`error-display error-${errorType}`}>
+      <div className="error-icon">
+        {/* Icon based on error type */}
+        {errorType === 'network' && <NetworkErrorIcon />}
+        {errorType === 'auth' && <AuthErrorIcon />}
+        {errorType === 'server' && <ServerErrorIcon />}
+        {errorType === 'validation' && <ValidationErrorIcon />}
+        {errorType === 'rendering' && <RenderingErrorIcon />}
+        {errorType === 'error' && <GenericErrorIcon />}
+      </div>
+      
+      <div className="error-content">
+        <h3 className="error-title">
+          {errorType === 'network' && 'Network Error'}
+          {errorType === 'auth' && 'Authentication Error'}
+          {errorType === 'server' && 'Server Error'}
+          {errorType === 'validation' && 'Validation Error'}
+          {errorType === 'rendering' && 'Rendering Error'}
+          {errorType === 'error' && 'Error'}
+        </h3>
+        
+        <p className="error-message">{errorMessage}</p>
+        
+        <div className="error-actions">
+          {onRetry && (
+            <button className="error-retry" onClick={onRetry}>
+              Retry
+            </button>
+          )}
+          
+          {onDismiss && (
+            <button className="error-dismiss" onClick={onDismiss}>
+              Dismiss
+            </button>
+          )}
+        </div>
+      </div>
+    </div>
+  );
+}
+```
+
+### Global Error Handling
+
+```typescript
+// Set up global error handler
+window.addEventListener('error', (event) => {
+  logger.error('Unhandled error:', createErrorMetadata({
+    message: event.message,
+    filename: event.filename,
+    lineno: event.lineno,
+    colno: event.colno,
+    error: event.error
+  }));
+  
+  // Show error notification
+  showErrorNotification(
+    'An unexpected error occurred. Please try reloading the page.'
+  );
+  
+  // Don't prevent default handling
+  return false;
+});
+
+// Set up promise rejection handler
+window.addEventListener('unhandledrejection', (event) => {
+  logger.error('Unhandled promise rejection:', createErrorMetadata({
+    reason: event.reason
+  }));
+  
+  // Show error notification
+  showErrorNotification(
+    'An unexpected error occurred. Please try reloading the page.'
+  );
+  
+  // Don't prevent default handling
+  return false;
+});
+```
+
+## Retry Strategies
+
+### Exponential Backoff
+
+```typescript
+async function fetchWithRetry(url: string, options?: RequestInit, maxRetries: number = 3): Promise<Response> {
+  let retries = 0;
+  
+  while (true) {
+    try {
+      return await fetch(url, options);
+    } catch (error) {
+      // Don't retry if we've reached max retries
+      if (retries >= maxRetries) {
+        throw error;
+      }
+      
+      // Don't retry certain errors
+      if (error instanceof APIError && error.type === APIErrorType.AUTHENTICATION_ERROR) {
+        throw error;
+      }
+      
+      // Calculate delay with exponential backoff
+      const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
+      
+      logger.warn(`Retrying failed request in ${Math.round(delay)}ms (${retries + 1}/${maxRetries})`, createDataMetadata({
+        url,
+        error: error.message
+      }));
+      
+      // Wait before retrying
+      await new Promise(resolve => setTimeout(resolve, delay));
+      
+      // Increment retry counter
+      retries++;
+    }
+  }
+}
+```
+
+### Circuit Breaker
+
+```typescript
+class CircuitBreaker {
+  private failureCount: number = 0;
+  private lastFailureTime: number = 0;
+  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
+  
+  constructor(
+    private readonly failureThreshold: number = 5,
+    private readonly resetTimeout: number = 30000
+  ) {}
+  
+  async execute<T>(fn: () => Promise<T>): Promise<T> {
+    // Check if circuit is open
+    if (this.state === 'OPEN') {
+      // Check if reset timeout has elapsed
+      const now = Date.now();
+      if (now - this.lastFailureTime >= this.resetTimeout) {
+        this.state = 'HALF_OPEN';
+      } else {
+        throw new Error('Circuit breaker is open');
+      }
+    }
+    
+    try {
+      // Execute function
+      const result = await fn();
+      
+      // Reset failure count on success
+      this.failureCount = 0;
+      this.state = 'CLOSED';
+      
+      return result;
+    } catch (error) {
+      // Record failure
+      this.failureCount++;
+      this.lastFailureTime = Date.now();
+      
+      // Open circuit if threshold is reached
+      if (this.state === 'HALF_OPEN' || this.failureCount >= this.failureThreshold) {
+        this.state = 'OPEN';
+      }
+      
+      throw error;
+    }
+  }
+  
+  get isOpen(): boolean {
+    return this.state === 'OPEN';
+  }
+  
+  reset(): void {
+    this.failureCount = 0;
+    this.state = 'CLOSED';
+  }
+}
+```
+
+## XR Error Handling
+
+```typescript
+// Handle XR session errors
+private handleXRSessionError(error: Error): void {
+  logger.error('XR session error:', createErrorMetadata(error));
+  
+  // Determine error type
+  let errorMessage = 'Failed to start XR session.';
+  
+  if (error.name === 'NotSupportedError') {
+    errorMessage = 'WebXR not supported by your browser or device.';
+  } else if (error.name === 'SecurityError') {
+    errorMessage = 'WebXR access denied due to security policy.';
+  } else if (error.name === 'AbortError') {
+    errorMessage = 'XR session was aborted.';
+  }
+  
+  // Show error to user
+  this.showXRError(errorMessage);
+  
+  // Fallback to non-XR mode
+  this.fallbackToNonXR();
+}
+
+// Fallback to non-XR mode
+private fallbackToNonXR(): void {
+  // Reset XR state
+  this.isInXR = false;
+  
+  // Update UI
+  this.updateUIForXRMode(false);
+  
+  // Update renderers
+  this.nodeManager.setXRMode(false);
+}
+```
+
+## Error Recovery
+
+### Automatic Retry for Essential Operations
+
+```typescript
+// Retry essential operations with backoff
+async function retryEssentialOperation<T>(
+  operation: () => Promise<T>,
+  options?: {
+    maxRetries?: number;
+    initialDelay?: number;
+    maxDelay?: number;
+    shouldRetry?: (error: Error) => boolean;
+  }
+): Promise<T> {
+  const maxRetries = options?.maxRetries ?? 5;
+  const initialDelay = options?.initialDelay ?? 1000;
+  const maxDelay = options?.maxDelay ?? 30000;
+  const shouldRetry = options?.shouldRetry ?? (() => true);
+  
+  let retries = 0;
+  let lastError: Error;
+  
+  while (retries <= maxRetries) {
+    try {
+      return await operation();
+    } catch (error) {
+      lastError = error;
+      
+      // Check if we should retry
+      if (!shouldRetry(error) || retries >= maxRetries) {
+        break;
+      }
+      
+      // Calculate delay with exponential backoff
+      const delay = Math.min(
+        initialDelay * Math.pow(2, retries),
+        maxDelay
+      );
+      
+      logger.warn(`Retrying essential operation in ${delay}ms (${retries + 1}/${maxRetries})`, createDataMetadata({
+        error: error.message
+      }));
+      
+      // Wait before retrying
+      await new Promise(resolve => setTimeout(resolve, delay));
+      
+      // Increment retry counter
+      retries++;
+    }
+  }
+  
+  // If we reached here, all retries failed
+  throw lastError;
+}
+```
+
+### Graceful Degradation
+
+```typescript
+// Gracefully degrade rendering quality
+private degradeRenderingQuality(): boolean {
+  // Current quality level
+  const currentQuality = this.renderingQuality;
+  
+  // Try to degrade quality
+  switch (currentQuality) {
+    case RenderingQuality.Ultra:
+      this.setRenderingQuality(RenderingQuality.High);
+      return true;
+    case RenderingQuality.High:
+      this.setRenderingQuality(RenderingQuality.Medium);
+      return true;
+    case RenderingQuality.Medium:
+      this.setRenderingQuality(RenderingQuality.Low);
+      return true;
+    case RenderingQuality.Low:
+      this.setRenderingQuality(RenderingQuality.Minimal);
+      return true;
+    case RenderingQuality.Minimal:
+      // Already at minimum quality
+      return false;
+  }
+  
+  return false;
+}
+
+// Handle performance issues
+private handlePerformanceIssue(): void {
+  // Check if we can degrade quality
+  if (this.degradeRenderingQuality()) {
+    logger.warn('Degraded rendering quality due to performance issues');
+    
+    // Notify user
+    this.showPerformanceWarning();
+  } else {
+    logger.error('Cannot degrade rendering quality further');
+    
+    // Show error to user
+    this.showPerformanceError();
+  }
+}
+```
+
+## Error Monitoring and Reporting
+
+In a production environment, errors would be sent to a monitoring service:
+
+```typescript
+// Error reporting service
+class ErrorReportingService {
+  private static instance: ErrorReportingService;
+  private isInitialized: boolean = false;
+  
+  private constructor() {}
+  
+  static getInstance(): ErrorReportingService {
+    if (!ErrorReportingService.instance) {
+      ErrorReportingService.instance = new ErrorReportingService();
+    }
+    return ErrorReportingService.instance;
+  }
+  
+  initialize(): void {
+    if (this.isInitialized) return;
+    
+    // Set up global error handlers
+    window.addEventListener('error', this.handleError);
+    window.addEventListener('unhandledrejection', this.handlePromiseRejection);
+    
+    this.isInitialized = true;
+  }
+  
+  private handleError = (event: ErrorEvent): void => {
+    this.reportError({
+      message: event.message,
+      stack: event.error?.stack,
+      source: event.filename,
+      line: event.lineno,
+      column: event.colno
+    });
+  };
+  
+  private handlePromiseRejection = (event: PromiseRejectionEvent): void => {
+    const error = event.reason;
+    
+    this.reportError({
+      message: error.message || 'Unhandled Promise Rejection',
+      stack: error.stack,
+      source: 'promise_rejection'
+    });
+  };
+  
+  reportError(errorData: any): void {
+    // In a real implementation, this would send the error to a monitoring service
+    // Such as Sentry, LogRocket, etc.
+    console.error('Would report to monitoring service:', errorData);
+    
+    // Example implementation:
+    // fetch('/api/error-reporting', {
+    //   method: 'POST',
+    //   headers: { 'Content-Type': 'application/json' },
+    //   body: JSON.stringify({
+    //     timestamp: Date.now(),
+    //     error: errorData,
+    //     userAgent: navigator.userAgent,
+    //     url: window.location.href
+    //   })
+    // }).catch(err => {
+    //   console.error('Failed to report error:', err);
+    // });
+  }
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Business Logic](business-logic.md) - Core business rules
+- [Technical Debt](technical-debt.md) - Technical debt analysis
+- [Performance](performance.md) - Performance considerations
\ No newline at end of file
diff --git a/docs/clientdocs/core/performance.md b/docs/clientdocs/core/performance.md
new file mode 100644
index 00000000..8c247725
--- /dev/null
+++ b/docs/clientdocs/core/performance.md
@@ -0,0 +1,862 @@
+# Performance
+
+This document provides a comprehensive overview of performance considerations, optimizations, and techniques used in the client application. Performance is critical for maintaining a smooth, responsive user experience, especially with large graph visualizations and in XR environments.
+
+## Performance Considerations
+
+The application faces several performance challenges:
+
+```mermaid
+graph TD
+    Performance[Performance Challenges] --> RenderPerf[Rendering Performance]
+    Performance --> DataPerf[Data Management Performance]
+    Performance --> NetworkPerf[Network Performance]
+    Performance --> XRPerf[XR Performance]
+    
+    RenderPerf --> LargeGraphs[Large Graph Rendering]
+    RenderPerf --> ComplexMaterials[Complex Materials]
+    RenderPerf --> TextRendering[Text Rendering]
+    
+    DataPerf --> LargeDatasets[Large Datasets]
+    DataPerf --> StateUpdates[State Updates]
+    DataPerf --> BinaryProcessing[Binary Data Processing]
+    
+    NetworkPerf --> PositionUpdates[Position Updates]
+    NetworkPerf --> InitialDataLoad[Initial Data Load]
+    NetworkPerf --> ConnectionReliability[Connection Reliability]
+    
+    XRPerf --> DoubleStereoRendering[Stereo Rendering]
+    XRPerf --> HighFrameRate[High Frame Rate Requirements]
+    XRPerf --> HandTracking[Hand Tracking]
+```
+
+## Rendering Optimizations
+
+### Instanced Rendering
+
+The application uses instanced rendering to draw many similar objects (nodes) with a single draw call:
+
+```typescript
+// Create instanced mesh
+this.instancedMesh = new THREE.InstancedMesh(
+  geometry,
+  material,
+  maxNodes
+);
+
+// Update all instances in a single update
+for (let i = 0; i < nodeCount; i++) {
+  const matrix = new THREE.Matrix4();
+  matrix.compose(
+    positions[i],
+    quaternions[i],
+    scales[i]
+  );
+  this.instancedMesh.setMatrixAt(i, matrix);
+}
+this.instancedMesh.instanceMatrix.needsUpdate = true;
+```
+
+This approach significantly reduces draw calls, which is one of the main performance bottlenecks in WebGL.
+
+### Level of Detail (LOD)
+
+The application implements a level of detail system to reduce geometric complexity for distant objects:
+
+```typescript
+// LOD thresholds
+private readonly HIGH_DETAIL_THRESHOLD = 20;  // Distance in world units
+private readonly MEDIUM_DETAIL_THRESHOLD = 50;
+
+// Update LOD based on camera distance
+private updateLOD(camera: THREE.Camera): void {
+  if (!this.instancedMesh) return;
+  
+  const cameraPosition = camera.position;
+  
+  this.nodes.forEach((node, nodeId) => {
+    const distance = node.position.distanceTo(cameraPosition);
+    
+    let detailLevel: NodeDetailLevel;
+    if (distance < this.HIGH_DETAIL_THRESHOLD) {
+      detailLevel = NodeDetailLevel.High;
+    } else if (distance < this.MEDIUM_DETAIL_THRESHOLD) {
+      detailLevel = NodeDetailLevel.Medium;
+    } else {
+      detailLevel = NodeDetailLevel.Low;
+    }
+    
+    // Only update if detail level changed
+    if (node.detailLevel !== detailLevel) {
+      node.detailLevel = detailLevel;
+      this.updateNodeGeometry(nodeId, detailLevel);
+    }
+  });
+}
+```
+
+### Frustum Culling
+
+Objects outside the camera's view frustum are culled to avoid rendering invisible objects:
+
+```typescript
+// Create frustum from camera
+const frustum = new THREE.Frustum();
+const projScreenMatrix = new THREE.Matrix4();
+projScreenMatrix.multiplyMatrices(
+  camera.projectionMatrix,
+  camera.matrixWorldInverse
+);
+frustum.setFromProjectionMatrix(projScreenMatrix);
+
+// Check each object against frustum
+this.objects.forEach(object => {
+  // Create bounding sphere around object
+  const boundingSphere = new THREE.Sphere(
+    object.position,
+    object.geometry.boundingSphere.radius * object.scale.x
+  );
+  
+  // Set visibility based on frustum intersection
+  object.visible = frustum.intersectsSphere(boundingSphere);
+});
+```
+
+### Occlusion Culling
+
+For dense scenes, occlusion culling is implemented to avoid rendering objects that are hidden behind other objects:
+
+```typescript
+// Use Three.js built-in occlusion culling
+renderer.setRenderListDepth(true);
+
+// Alternatively, implement manual occlusion culling for specific cases
+function isOccluded(object: THREE.Object3D, camera: THREE.Camera, occluders: THREE.Object3D[]): boolean {
+  const raycaster = new THREE.Raycaster();
+  const direction = new THREE.Vector3();
+  
+  // Get direction from camera to object
+  direction.subVectors(object.position, camera.position).normalize();
+  
+  // Set up raycaster
+  raycaster.set(camera.position, direction);
+  
+  // Cast ray and check for intersections
+  const intersections = raycaster.intersectObjects(occluders);
+  
+  // If any intersection is closer than the object, it's occluded
+  if (intersections.length > 0) {
+    const distanceToObject = camera.position.distanceTo(object.position);
+    return intersections[0].distance < distanceToObject;
+  }
+  
+  return false;
+}
+```
+
+### Efficient Text Rendering
+
+Text rendering is optimized using SDF (Signed Distance Field) fonts, which provide crisp text at any scale with minimal texture memory:
+
+```typescript
+// Generate SDF texture
+const fontAtlas = new SDFFontAtlasGenerator();
+const texture = fontAtlas.generateAtlas(font, chars);
+
+// Create material using SDF shader
+const material = new THREE.ShaderMaterial({
+  uniforms: {
+    map: { value: texture },
+    color: { value: new THREE.Color(color) },
+    smoothing: { value: 0.25 },
+    threshold: { value: 0.2 }
+  },
+  vertexShader: textVertexShader,
+  fragmentShader: textFragmentShader,
+  transparent: true,
+  side: THREE.DoubleSide
+});
+```
+
+### ShaderMaterial Optimization
+
+Custom shader materials are optimized for performance:
+
+```glsl
+// Optimized vertex shader
+void main() {
+  // Compute only what's necessary
+  vUv = uv;
+  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+}
+
+// Optimized fragment shader
+void main() {
+  // Use texture2D once and store result
+  vec4 texColor = texture2D(map, vUv);
+  
+  // Early return for transparent pixels
+  if (texColor.a < 0.01) discard;
+  
+  // Simplified calculations
+  float alpha = smoothstep(threshold - smoothing, threshold + smoothing, texColor.a);
+  gl_FragColor = vec4(color, alpha);
+}
+```
+
+## Data Management Optimizations
+
+### Binary Data Processing
+
+Binary data is processed efficiently:
+
+```typescript
+// Preallocate typed arrays to avoid garbage collection
+const positions = new Float32Array(nodeCount * 3);
+const indices = new Uint32Array(nodeCount);
+
+// Process binary data in one pass
+function processBinaryData(buffer: ArrayBuffer): void {
+  const view = new DataView(buffer);
+  let offset = 0;
+  
+  for (let i = 0; i < nodeCount; i++) {
+    // Read node ID
+    const id = view.getUint32(offset, true);
+    indices[i] = id;
+    offset += 4;
+    
+    // Read position
+    positions[i * 3] = view.getFloat32(offset, true);
+    positions[i * 3 + 1] = view.getFloat32(offset + 4, true);
+    positions[i * 3 + 2] = view.getFloat32(offset + 8, true);
+    offset += 12;
+  }
+}
+```
+
+### Object Pooling
+
+Object pooling is used to reduce garbage collection:
+
+```typescript
+class Vector3Pool {
+  private pool: THREE.Vector3[] = [];
+  private index: number = 0;
+  
+  constructor(initialSize: number = 1000) {
+    // Pre-allocate pool
+    for (let i = 0; i < initialSize; i++) {
+      this.pool.push(new THREE.Vector3());
+    }
+  }
+  
+  get(): THREE.Vector3 {
+    if (this.index >= this.pool.length) {
+      // Expand pool if needed
+      this.pool.push(new THREE.Vector3());
+    }
+    
+    return this.pool[this.index++];
+  }
+  
+  reset(): void {
+    this.index = 0;
+  }
+}
+
+// Usage
+const vectorPool = new Vector3Pool();
+
+function processVectors(count: number): void {
+  vectorPool.reset();
+  
+  for (let i = 0; i < count; i++) {
+    const vec = vectorPool.get();
+    // Use vec...
+  }
+}
+```
+
+### Immutable Data Patterns
+
+Immutable data patterns are used to optimize state updates:
+
+```typescript
+function updateState(state, path, value) {
+  // Split path into parts
+  const parts = path.split('.');
+  const key = parts[0];
+  
+  if (parts.length === 1) {
+    // Leaf property, create new object with updated value
+    return {
+      ...state,
+      [key]: value
+    };
+  } else {
+    // Nested property, recurse
+    const remainingPath = parts.slice(1).join('.');
+    return {
+      ...state,
+      [key]: updateState(state[key] || {}, remainingPath, value)
+    };
+  }
+}
+```
+
+## Network Optimizations
+
+### Binary Protocol
+
+The application uses a binary protocol for efficient position updates:
+
+```typescript
+// Define binary format
+const BYTES_PER_NODE = 26; // 2 (ID) + 12 (position) + 12 (velocity)
+
+// Encode binary message
+function encodeBinaryMessage(nodes): ArrayBuffer {
+  const buffer = new ArrayBuffer(nodes.length * BYTES_PER_NODE);
+  const view = new DataView(buffer);
+  
+  nodes.forEach((node, index) => {
+    const offset = index * BYTES_PER_NODE;
+    
+    // Write node ID
+    view.setUint16(offset, parseInt(node.id), true);
+    
+    // Write position
+    view.setFloat32(offset + 2, node.position.x, true);
+    view.setFloat32(offset + 6, node.position.y, true);
+    view.setFloat32(offset + 10, node.position.z, true);
+    
+    // Write velocity
+    view.setFloat32(offset + 14, node.velocity.x, true);
+    view.setFloat32(offset + 18, node.velocity.y, true);
+    view.setFloat32(offset + 22, node.velocity.z, true);
+  });
+  
+  return buffer;
+}
+```
+
+### Data Compression
+
+Data compression is used for large messages:
+
+```typescript
+// Compress data if over threshold
+function compressIfNeeded(buffer: ArrayBuffer): ArrayBuffer {
+  if (buffer.byteLength > COMPRESSION_THRESHOLD) {
+    return pako.deflate(new Uint8Array(buffer)).buffer;
+  }
+  return buffer;
+}
+
+// Decompress data
+function tryDecompress(buffer: ArrayBuffer): ArrayBuffer {
+  try {
+    return pako.inflate(new Uint8Array(buffer)).buffer;
+  } catch (e) {
+    // If decompression fails, return original buffer
+    return buffer;
+  }
+}
+```
+
+### Request Batching
+
+Requests are batched to reduce network overhead:
+
+```typescript
+class RequestBatcher {
+  private queue: any[] = [];
+  private timer: number | null = null;
+  private readonly delay: number;
+  
+  constructor(delay: number = 50) {
+    this.delay = delay;
+  }
+  
+  add(item: any): void {
+    this.queue.push(item);
+    
+    if (!this.timer) {
+      this.timer = window.setTimeout(() => {
+        this.flush();
+        this.timer = null;
+      }, this.delay);
+    }
+  }
+  
+  private flush(): void {
+    if (this.queue.length === 0) return;
+    
+    const items = [...this.queue];
+    this.queue = [];
+    
+    this.sendBatch(items);
+  }
+  
+  private sendBatch(items: any[]): void {
+    // Send batch request
+    fetch('/api/batch', {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json'
+      },
+      body: JSON.stringify({ items })
+    });
+  }
+}
+```
+
+### Pagination
+
+Pagination is used for loading large datasets:
+
+```typescript
+async function loadGraphData(): Promise<void> {
+  let page = 1;
+  const pageSize = 100;
+  let hasMoreData = true;
+  
+  // Load first page immediately
+  const firstPage = await fetchPage(page, pageSize);
+  processPage(firstPage);
+  
+  // Check if there are more pages
+  hasMoreData = firstPage.hasMorePages;
+  
+  // Continue loading pages in background
+  while (hasMoreData) {
+    page++;
+    
+    // Use setTimeout to avoid blocking the main thread
+    await new Promise(resolve => setTimeout(resolve, 0));
+    
+    const nextPage = await fetchPage(page, pageSize);
+    processPage(nextPage);
+    
+    hasMoreData = nextPage.hasMorePages;
+    
+    // Update progress indicator
+    updateProgress(page, nextPage.totalPages);
+  }
+}
+```
+
+## Animation and Rendering Optimizations
+
+### Request Animation Frame
+
+The application uses requestAnimationFrame for efficient animations:
+
+```typescript
+function startAnimationLoop(): void {
+  let lastTime = 0;
+  
+  function animate(time: number): void {
+    // Request next frame
+    requestAnimationFrame(animate);
+    
+    // Calculate delta time
+    const deltaTime = lastTime ? (time - lastTime) / 1000 : 0;
+    lastTime = time;
+    
+    // Update scene
+    update(deltaTime);
+    
+    // Render scene
+    render();
+  }
+  
+  // Start animation loop
+  requestAnimationFrame(animate);
+}
+```
+
+### Performance Monitoring
+
+The application includes performance monitoring to identify bottlenecks:
+
+```typescript
+class PerformanceMonitor {
+  private metrics: Map<string, number[]> = new Map();
+  private maxSamples: number;
+  
+  constructor(maxSamples: number = 100) {
+    this.maxSamples = maxSamples;
+  }
+  
+  startMeasure(name: string): () => void {
+    const startTime = performance.now();
+    
+    return () => {
+      const endTime = performance.now();
+      const duration = endTime - startTime;
+      
+      this.recordMetric(name, duration);
+    };
+  }
+  
+  recordMetric(name: string, value: number): void {
+    if (!this.metrics.has(name)) {
+      this.metrics.set(name, []);
+    }
+    
+    const values = this.metrics.get(name)!;
+    values.push(value);
+    
+    // Keep only the last maxSamples
+    if (values.length > this.maxSamples) {
+      values.shift();
+    }
+  }
+  
+  getAverageMetric(name: string): number | null {
+    if (!this.metrics.has(name)) return null;
+    
+    const values = this.metrics.get(name)!;
+    if (values.length === 0) return null;
+    
+    return values.reduce((sum, value) => sum + value, 0) / values.length;
+  }
+  
+  getMetrics(): Record<string, { average: number, min: number, max: number }> {
+    const result: Record<string, { average: number, min: number, max: number }> = {};
+    
+    this.metrics.forEach((values, name) => {
+      if (values.length === 0) return;
+      
+      const sum = values.reduce((acc, value) => acc + value, 0);
+      const min = Math.min(...values);
+      const max = Math.max(...values);
+      
+      result[name] = {
+        average: sum / values.length,
+        min,
+        max
+      };
+    });
+    
+    return result;
+  }
+}
+```
+
+### Throttling and Debouncing
+
+Throttling and debouncing are used for expensive operations:
+
+```typescript
+class UpdateThrottler {
+  private lastUpdateTime: number = 0;
+  private readonly updateInterval: number;
+  
+  constructor(updateInterval: number = 16) {
+    this.updateInterval = updateInterval;
+  }
+  
+  shouldUpdate(): boolean {
+    const now = performance.now();
+    if (now - this.lastUpdateTime >= this.updateInterval) {
+      this.lastUpdateTime = now;
+      return true;
+    }
+    return false;
+  }
+  
+  getTimeUntilNextUpdate(): number {
+    const now = performance.now();
+    return Math.max(0, this.updateInterval - (now - this.lastUpdateTime));
+  }
+  
+  getRate(): number {
+    return 1000 / this.updateInterval;
+  }
+}
+
+function debounce<T extends (...args: any[]) => any>(
+  func: T,
+  wait: number
+): (...args: Parameters<T>) => void {
+  let timeout: number | null = null;
+  
+  return function(...args: Parameters<T>): void {
+    if (timeout !== null) {
+      window.clearTimeout(timeout);
+    }
+    
+    timeout = window.setTimeout(() => {
+      func(...args);
+      timeout = null;
+    }, wait);
+  };
+}
+```
+
+## Memory Management
+
+### Resource Cleanup
+
+Resources are properly cleaned up to prevent memory leaks:
+
+```typescript
+// Dispose Three.js resources
+dispose(): void {
+  // Dispose geometries
+  this.geometries.forEach(geometry => {
+    geometry.dispose();
+  });
+  this.geometries.clear();
+  
+  // Dispose materials
+  this.materials.forEach(material => {
+    material.dispose();
+  });
+  this.materials.clear();
+  
+  // Dispose textures
+  this.textures.forEach(texture => {
+    texture.dispose();
+  });
+  this.textures.clear();
+  
+  // Remove from scene
+  if (this.instancedMesh) {
+    this.scene.remove(this.instancedMesh);
+    this.instancedMesh.dispose();
+    this.instancedMesh = null;
+  }
+  
+  // Clean up event listeners
+  window.removeEventListener('resize', this.handleResize);
+}
+```
+
+### Texture Management
+
+Textures are managed efficiently:
+
+```typescript
+class TextureManager {
+  private textures: Map<string, THREE.Texture> = new Map();
+  
+  async loadTexture(url: string): Promise<THREE.Texture> {
+    // Check if texture is already loaded
+    if (this.textures.has(url)) {
+      return this.textures.get(url)!;
+    }
+    
+    // Load texture
+    const texture = await new Promise<THREE.Texture>((resolve, reject) => {
+      new THREE.TextureLoader().load(
+        url,
+        resolve,
+        undefined,
+        reject
+      );
+    });
+    
+    // Optimize texture settings
+    texture.anisotropy = 16;
+    texture.generateMipmaps = true;
+    texture.minFilter = THREE.LinearMipmapLinearFilter;
+    texture.magFilter = THREE.LinearFilter;
+    texture.needsUpdate = true;
+    
+    // Store texture
+    this.textures.set(url, texture);
+    
+    return texture;
+  }
+  
+  disposeTexture(url: string): void {
+    if (this.textures.has(url)) {
+      const texture = this.textures.get(url)!;
+      texture.dispose();
+      this.textures.delete(url);
+    }
+  }
+  
+  disposeAll(): void {
+    this.textures.forEach(texture => {
+      texture.dispose();
+    });
+    this.textures.clear();
+  }
+}
+```
+
+### Buffer Reuse
+
+Buffers are reused to reduce memory allocations:
+
+```typescript
+// Reuse array buffers
+class BufferPool {
+  private floatBuffers: Map<number, Float32Array> = new Map();
+  private uint32Buffers: Map<number, Uint32Array> = new Map();
+  
+  getFloat32Buffer(size: number): Float32Array {
+    if (!this.floatBuffers.has(size)) {
+      this.floatBuffers.set(size, new Float32Array(size));
+    }
+    return this.floatBuffers.get(size)!;
+  }
+  
+  getUint32Buffer(size: number): Uint32Array {
+    if (!this.uint32Buffers.has(size)) {
+      this.uint32Buffers.set(size, new Uint32Array(size));
+    }
+    return this.uint32Buffers.get(size)!;
+  }
+}
+```
+
+## WebXR Optimizations
+
+WebXR applications require additional optimizations due to the high performance requirements:
+
+### Mobile VR Optimizations
+
+```typescript
+function optimizeForMobileVR(): void {
+  // Reduce texture quality
+  renderer.setPixelRatio(1.0);
+  
+  // Disable expensive effects
+  renderer.shadowMap.enabled = false;
+  
+  // Use simpler materials
+  this.materials.forEach(material => {
+    material.flatShading = true;
+    material.needsUpdate = true;
+  });
+  
+  // Reduce geometry complexity
+  this.geometries.forEach((geometry, key) => {
+    if (geometry instanceof THREE.SphereGeometry) {
+      const simplified = new THREE.SphereGeometry(
+        geometry.parameters.radius,
+        Math.max(8, Math.floor(geometry.parameters.widthSegments / 2)),
+        Math.max(6, Math.floor(geometry.parameters.heightSegments / 2))
+      );
+      this.geometries.set(key, simplified);
+    }
+  });
+}
+```
+
+### XR-specific Rendering Optimizations
+
+```typescript
+function optimizeForXR(renderer: THREE.WebGLRenderer): void {
+  // Set recommended WebXR settings
+  renderer.xr.enabled = true;
+  renderer.xr.setReferenceSpaceType('local-floor');
+  
+  // Enable foveated rendering if available
+  const gl = renderer.getContext();
+  if (gl.getExtension('OCULUS_multiview')) {
+    renderer.xr.setFoveation(0.5);
+  }
+  
+  // Set frame rate to match display refresh rate
+  const session = renderer.xr.getSession();
+  if (session) {
+    const framerate = session.supportedFrameRates
+      ? Math.max(...session.supportedFrameRates)
+      : 72;
+    session.updateTargetFrameRate(framerate);
+  }
+}
+```
+
+## Performance Profiling
+
+The application includes tools for performance profiling:
+
+```typescript
+class PerformanceProfiler {
+  private static instance: PerformanceProfiler;
+  private active: boolean = false;
+  private markers: Map<string, number> = new Map();
+  private measurements: Map<string, number[]> = new Map();
+  
+  static getInstance(): PerformanceProfiler {
+    if (!PerformanceProfiler.instance) {
+      PerformanceProfiler.instance = new PerformanceProfiler();
+    }
+    return PerformanceProfiler.instance;
+  }
+  
+  startProfiling(): void {
+    this.active = true;
+    this.markers.clear();
+    this.measurements.clear();
+    console.log('Performance profiling started');
+  }
+  
+  stopProfiling(): Record<string, { avg: number, min: number, max: number, count: number }> {
+    this.active = false;
+    
+    const result: Record<string, { avg: number, min: number, max: number, count: number }> = {};
+    
+    this.measurements.forEach((times, name) => {
+      if (times.length === 0) return;
+      
+      const sum = times.reduce((acc, time) => acc + time, 0);
+      const avg = sum / times.length;
+      const min = Math.min(...times);
+      const max = Math.max(...times);
+      
+      result[name] = {
+        avg,
+        min,
+        max,
+        count: times.length
+      };
+    });
+    
+    console.table(result);
+    
+    return result;
+  }
+  
+  mark(name: string): void {
+    if (!this.active) return;
+    
+    this.markers.set(name, performance.now());
+  }
+  
+  measure(name: string, startMark: string, endMark?: string): void {
+    if (!this.active) return;
+    
+    const endTime = endMark ? this.markers.get(endMark) : performance.now();
+    const startTime = this.markers.get(startMark);
+    
+    if (startTime === undefined || endTime === undefined) {
+      console.warn(`Invalid markers for measure "${name}": start=${startMark}, end=${endMark}`);
+      return;
+    }
+    
+    const duration = endTime - startTime;
+    
+    if (!this.measurements.has(name)) {
+      this.measurements.set(name, []);
+    }
+    
+    this.measurements.get(name)!.push(duration);
+  }
+}
+```
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Technical Debt](technical-debt.md) - Technical debt analysis
+- [Business Logic](business-logic.md) - Business logic documentation
+- [Error Handling](error-handling.md) - Error handling patterns
\ No newline at end of file
diff --git a/docs/clientdocs/core/technical-debt.md b/docs/clientdocs/core/technical-debt.md
new file mode 100644
index 00000000..486ed92a
--- /dev/null
+++ b/docs/clientdocs/core/technical-debt.md
@@ -0,0 +1,650 @@
+# Technical Debt
+
+This document provides a comprehensive analysis of technical debt in the client application. Technical debt refers to development decisions that prioritize speed over optimal implementation, leading to future costs in terms of maintenance and extensibility. This analysis categorizes debt by severity, suggests remediation strategies, and provides a roadmap for addressing the most critical issues.
+
+## Overview of Technical Debt
+
+Technical debt in the application is categorized by severity and impact:
+
+```mermaid
+graph TD
+    TechDebt[Technical Debt] --> Critical[Critical Debt]
+    TechDebt --> Significant[Significant Debt]
+    TechDebt --> Moderate[Moderate Debt]
+    TechDebt --> Minor[Minor Debt]
+    
+    Critical --> PerformanceIssues[Performance Issues]
+    Critical --> ArchitecturalFlaws[Architectural Flaws]
+    
+    Significant --> CodeComplexity[Code Complexity]
+    Significant --> InconsistentPatterns[Inconsistent Patterns]
+    
+    Moderate --> TestCoverage[Test Coverage]
+    Moderate --> CodeDuplication[Code Duplication]
+    
+    Minor --> Documentation[Documentation]
+    Minor --> CodeStyle[Code Style]
+```
+
+## Critical Technical Debt
+
+### Performance Issues in Large Graph Rendering
+
+**Description:** The current implementation of the graph rendering system doesn't scale well with very large graphs (10,000+ nodes). Frame rate drops significantly when visualizing large datasets.
+
+**Impact:** Users with large datasets experience poor performance, making the application unusable for complex graphs.
+
+**Root Causes:**
+- Insufficient node culling for off-screen objects
+- Too many draw calls when rendering node labels
+- Inefficient handling of binary position updates for large datasets
+
+**Remediation:**
+1. Implement more aggressive frustum and distance culling for nodes
+2. Use instanced rendering for node labels
+3. Optimize binary position update processing with chunking and web workers
+
+```typescript
+// Current implementation (inefficient)
+function updateNodePositions(positions: Float32Array): void {
+  // Process all nodes in a single frame
+  for (let i = 0; i < positions.length; i += 6) {
+    // Update node position...
+  }
+}
+
+// Recommended implementation
+function updateNodePositions(positions: Float32Array): void {
+  // Process nodes in chunks across multiple frames
+  const CHUNK_SIZE = 1000;
+  let offset = 0;
+  
+  function processChunk() {
+    const endOffset = Math.min(offset + CHUNK_SIZE * 6, positions.length);
+    
+    for (let i = offset; i < endOffset; i += 6) {
+      // Update node position...
+    }
+    
+    offset = endOffset;
+    
+    if (offset < positions.length) {
+      // Schedule next chunk
+      setTimeout(processChunk, 0);
+    }
+  }
+  
+  // Start processing
+  processChunk();
+}
+```
+
+### WebSocket Connection Reliability
+
+**Description:** The WebSocket connection management has reliability issues, particularly with reconnection logic and error recovery.
+
+**Impact:** Users experience disconnections and data synchronization issues, leading to inconsistent state and potential data loss.
+
+**Root Causes:**
+- Inadequate error handling for certain connection failure scenarios
+- Race conditions in the reconnection logic
+- Lack of proper state synchronization after reconnection
+
+**Remediation:**
+1. Refactor WebSocket connection management with a proper state machine
+2. Implement robust error recovery with automatic state resynchronization
+3. Add exponential backoff with jitter for reconnection attempts
+
+```typescript
+// Current implementation
+private handleReconnect(): void {
+  // Simple reconnect logic with fixed timing
+  if (this.reconnectAttempts < this.maxReconnectAttempts) {
+    this.reconnectAttempts++;
+    const delay = this.getReconnectDelay();
+    setTimeout(() => this.connect(), delay);
+  }
+}
+
+// Recommended implementation
+private handleReconnect(): void {
+  if (this.reconnectAttempts < this.maxReconnectAttempts) {
+    this.reconnectAttempts++;
+    
+    // Exponential backoff with jitter
+    const baseDelay = Math.min(
+      this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
+      this.maxReconnectDelay
+    );
+    const jitter = Math.random() * 0.5 * baseDelay;
+    const delay = baseDelay + jitter;
+    
+    // Set reconnection state
+    this.connectionState = ConnectionState.RECONNECTING;
+    this.notifyConnectionStatus();
+    
+    // Schedule reconnection
+    this.reconnectTimeout = setTimeout(() => {
+      this.reconnectTimeout = null;
+      this.connect().catch(error => {
+        logger.error('Reconnection attempt failed:', error);
+        this.handleReconnect();
+      });
+    }, delay);
+  } else {
+    // Max retries reached
+    this.connectionState = ConnectionState.FAILED;
+    this.notifyConnectionStatus();
+  }
+}
+```
+
+## Significant Technical Debt
+
+### Inconsistent State Management
+
+**Description:** The application uses multiple approaches to state management, including direct prop passing, context API, and a custom state store, creating inconsistency and complexity.
+
+**Impact:** Developers struggle to understand data flow, leading to bugs, maintenance challenges, and slower development.
+
+**Root Causes:**
+- Organic growth of the application without architectural planning
+- Different developers applying different patterns over time
+- Lack of clear guidelines for state management
+
+**Remediation:**
+1. Define a consistent state management architecture
+2. Refactor to use a single state management pattern (e.g., centralized store with subscribable slices)
+3. Document the state management approach and enforce it in code reviews
+
+```typescript
+// Current situation: Multiple state management approaches
+
+// Approach 1: Direct prop passing
+function ComponentA({ data, onUpdate }) {
+  // Use data directly, call onUpdate to modify
+}
+
+// Approach 2: Context API
+const DataContext = React.createContext(null);
+
+function ComponentB() {
+  const data = useContext(DataContext);
+  // Use context data
+}
+
+// Approach 3: Custom store with observables
+class DataStore {
+  private data = {};
+  private listeners = new Set();
+  
+  update(newData) {
+    this.data = { ...this.data, ...newData };
+    this.notify();
+  }
+  
+  subscribe(listener) {
+    this.listeners.add(listener);
+    return () => this.listeners.delete(listener);
+  }
+  
+  notify() {
+    this.listeners.forEach(listener => listener(this.data));
+  }
+}
+
+// Recommended approach: Standardize on a single pattern
+class Store<T> {
+  private state: T;
+  private listeners: Set<(state: T) => void> = new Set();
+  
+  constructor(initialState: T) {
+    this.state = initialState;
+  }
+  
+  getState(): T {
+    return this.state;
+  }
+  
+  setState(updater: (state: T) => T): void {
+    this.state = updater(this.state);
+    this.notifyListeners();
+  }
+  
+  subscribe(listener: (state: T) => void): () => void {
+    this.listeners.add(listener);
+    return () => {
+      this.listeners.delete(listener);
+    };
+  }
+  
+  private notifyListeners(): void {
+    for (const listener of this.listeners) {
+      listener(this.state);
+    }
+  }
+}
+```
+
+### Tightly Coupled Components
+
+**Description:** Many components have tight coupling with specific implementations, making them difficult to test, reuse, and maintain.
+
+**Impact:** Changes to one component often require changes to multiple other components, increasing the risk of bugs and making testing difficult.
+
+**Root Causes:**
+- Direct dependencies on concrete implementations rather than abstractions
+- Singleton pattern overuse
+- Lack of dependency injection
+
+**Remediation:**
+1. Refactor components to depend on interfaces rather than concrete implementations
+2. Introduce dependency injection for services and managers
+3. Create a more modular architecture with clear boundaries
+
+```typescript
+// Current implementation (tightly coupled)
+class NodeManager {
+  private static instance: NodeManager;
+  
+  static getInstance(): NodeManager {
+    if (!NodeManager.instance) {
+      NodeManager.instance = new NodeManager();
+    }
+    return NodeManager.instance;
+  }
+  
+  updateNode(nodeId: string, position: Vector3): void {
+    // Direct dependency on WebSocketService singleton
+    WebSocketService.getInstance().sendNodeUpdate(nodeId, position);
+  }
+}
+
+// Recommended implementation
+interface IWebSocketService {
+  sendNodeUpdate(nodeId: string, position: Vector3): void;
+}
+
+class NodeManager {
+  constructor(private webSocketService: IWebSocketService) {}
+  
+  updateNode(nodeId: string, position: Vector3): void {
+    this.webSocketService.sendNodeUpdate(nodeId, position);
+  }
+}
+```
+
+## Moderate Technical Debt
+
+### Inadequate Test Coverage
+
+**Description:** The application has limited automated test coverage, particularly for complex components like the rendering pipeline and WebSocket data handling.
+
+**Impact:** Changes are risky, bugs are discovered late, and refactoring is difficult due to lack of safety net.
+
+**Root Causes:**
+- Initial focus on feature development over testing
+- Complex rendering logic that's difficult to test
+- Lack of clear testing strategy
+
+**Remediation:**
+1. Define a testing strategy for different types of components
+2. Increase unit test coverage for core business logic
+3. Add integration tests for critical paths
+4. Implement visual regression testing for rendering components
+
+```typescript
+// Example of testable code with dependency injection
+class GraphDataManager {
+  constructor(
+    private apiClient: IApiClient,
+    private eventEmitter: IEventEmitter
+  ) {}
+  
+  async loadGraphData(): Promise<GraphData> {
+    try {
+      const data = await this.apiClient.fetchGraphData();
+      this.eventEmitter.emit('graphDataLoaded', data);
+      return data;
+    } catch (error) {
+      this.eventEmitter.emit('graphDataError', error);
+      throw error;
+    }
+  }
+}
+
+// Example test
+describe('GraphDataManager', () => {
+  let manager: GraphDataManager;
+  let mockApiClient: jest.Mocked<IApiClient>;
+  let mockEventEmitter: jest.Mocked<IEventEmitter>;
+  
+  beforeEach(() => {
+    mockApiClient = {
+      fetchGraphData: jest.fn()
+    };
+    
+    mockEventEmitter = {
+      emit: jest.fn()
+    };
+    
+    manager = new GraphDataManager(mockApiClient, mockEventEmitter);
+  });
+  
+  it('should load graph data and emit event', async () => {
+    const mockData = { nodes: [], edges: [] };
+    mockApiClient.fetchGraphData.mockResolvedValue(mockData);
+    
+    const result = await manager.loadGraphData();
+    
+    expect(result).toEqual(mockData);
+    expect(mockEventEmitter.emit).toHaveBeenCalledWith('graphDataLoaded', mockData);
+  });
+});
+```
+
+### Code Duplication
+
+**Description:** Several areas of the codebase contain duplicated logic, particularly in the WebSocket handling, position calculations, and error handling.
+
+**Impact:** Bug fixes and enhancements must be applied in multiple places, increasing the risk of inconsistencies and errors.
+
+**Root Causes:**
+- Copy-paste programming during rapid development
+- Lack of shared utilities and abstractions
+- Insufficient code reviews
+
+**Remediation:**
+1. Extract common logic into shared utility functions
+2. Create reusable abstractions for repeated patterns
+3. Implement stricter code review policies for duplication
+
+```typescript
+// Current situation: Duplicated position validation logic
+
+// In file1.ts
+function validatePosition(position: Vector3): boolean {
+  return !isNaN(position.x) && !isNaN(position.y) && !isNaN(position.z) &&
+         isFinite(position.x) && isFinite(position.y) && isFinite(position.z);
+}
+
+// In file2.ts
+function isValidPosition(pos: Vector3): boolean {
+  return !isNaN(pos.x) && !isNaN(pos.y) && !isNaN(pos.z) &&
+         isFinite(pos.x) && isFinite(pos.y) && isFinite(pos.z);
+}
+
+// Recommended approach: Create a shared utility
+// In vectorUtils.ts
+export function isValidVector3(vector: Vector3): boolean {
+  return !isNaN(vector.x) && !isNaN(vector.y) && !isNaN(vector.z) &&
+         isFinite(vector.x) && isFinite(vector.y) && isFinite(vector.z);
+}
+
+export function sanitizeVector3(vector: Vector3, fallbackValue: number = 0, maxValue?: number): Vector3 {
+  const result = vector.clone();
+  
+  // Replace NaN values
+  if (isNaN(result.x)) result.x = fallbackValue;
+  if (isNaN(result.y)) result.y = fallbackValue;
+  if (isNaN(result.z)) result.z = fallbackValue;
+  
+  // Replace infinite values
+  if (!isFinite(result.x)) result.x = fallbackValue;
+  if (!isFinite(result.y)) result.y = fallbackValue;
+  if (!isFinite(result.z)) result.z = fallbackValue;
+  
+  // Clamp to max value if provided
+  if (maxValue !== undefined) {
+    result.x = Math.max(-maxValue, Math.min(maxValue, result.x));
+    result.y = Math.max(-maxValue, Math.min(maxValue, result.y));
+    result.z = Math.max(-maxValue, Math.min(maxValue, result.z));
+  }
+  
+  return result;
+}
+```
+
+### Inconsistent Error Handling
+
+**Description:** Error handling is inconsistent across the application, with some areas using try/catch, others using Promise chains, and others not handling errors at all.
+
+**Impact:** Errors are not properly caught, reported, or recovered from, leading to poor user experience and difficult debugging.
+
+**Root Causes:**
+- Lack of error handling strategy
+- Mix of asynchronous patterns (callbacks, promises, async/await)
+- Insufficient attention to error scenarios
+
+**Remediation:**
+1. Define a consistent error handling strategy
+2. Implement centralized error logging and reporting
+3. Add proper error recovery mechanisms
+4. Use consistent asynchronous patterns (prefer async/await)
+
+```typescript
+// Current situation: Inconsistent error handling
+
+// Style 1: Promise chains
+fetchData()
+  .then(data => processData(data))
+  .catch(error => console.error('Error:', error));
+
+// Style 2: Async/await with try/catch
+async function loadData() {
+  try {
+    const data = await fetchData();
+    return processData(data);
+  } catch (error) {
+    console.error('Failed to load data:', error);
+    return null;
+  }
+}
+
+// Style 3: No error handling
+function updateNode(id, position) {
+  // No error handling at all
+  const node = getNode(id);
+  node.position = position;
+  saveNode(node);
+}
+
+// Recommended approach: Consistent error handling
+class ErrorHandler {
+  static async handleAsync<T>(
+    operation: () => Promise<T>,
+    errorContext: string
+  ): Promise<T | null> {
+    try {
+      return await operation();
+    } catch (error) {
+      logger.error(`Error in ${errorContext}:`, createErrorMetadata(error));
+      
+      // Optionally report to monitoring service
+      ErrorReportingService.reportError(error, errorContext);
+      
+      // Rethrow or return null depending on strategy
+      return null;
+    }
+  }
+}
+
+// Usage
+async function loadData() {
+  return ErrorHandler.handleAsync(
+    async () => {
+      const data = await fetchData();
+      return processData(data);
+    },
+    'loadData'
+  );
+}
+```
+
+## Minor Technical Debt
+
+### Inconsistent Code Style
+
+**Description:** The codebase exhibits inconsistent code style, naming conventions, and organization patterns across different modules.
+
+**Impact:** Reduced readability, increased cognitive load for developers, and subtle bugs from misunderstanding patterns.
+
+**Root Causes:**
+- Multiple developers with different preferences
+- Lack of enforced code style guidelines
+- Legacy code intermixed with newer patterns
+
+**Remediation:**
+1. Define coding standards and style guidelines
+2. Implement automatic code formatting with ESLint and Prettier
+3. Configure pre-commit hooks to enforce style
+4. Gradually refactor existing code to meet standards
+
+```typescript
+// Add development dependencies
+// package.json
+{
+  "devDependencies": {
+    "eslint": "^8.0.0",
+    "prettier": "^2.5.0",
+    "husky": "^7.0.0",
+    "lint-staged": "^12.0.0"
+  },
+  "scripts": {
+    "lint": "eslint --ext .ts,.tsx src",
+    "format": "prettier --write \"src/**/*.{ts,tsx}\"",
+    "prepare": "husky install"
+  },
+  "husky": {
+    "hooks": {
+      "pre-commit": "lint-staged"
+    }
+  },
+  "lint-staged": {
+    "*.{ts,tsx}": [
+      "prettier --write",
+      "eslint --fix"
+    ]
+  }
+}
+```
+
+### Outdated Dependencies
+
+**Description:** Several dependencies are outdated, including Three.js, TypeScript, and various utility libraries.
+
+**Impact:** Missing out on performance improvements, bug fixes, and new features from updated dependencies.
+
+**Root Causes:**
+- Fear of breaking changes
+- Accumulated technical debt making upgrades risky
+- Lack of regular dependency maintenance
+
+**Remediation:**
+1. Create a dependency update schedule and process
+2. Implement better testing to make upgrades safer
+3. Upgrade dependencies incrementally, starting with minor versions
+4. Modernize build tools and configurations
+
+```typescript
+// Current package.json
+{
+  "dependencies": {
+    "three": "^0.125.0",
+    "typescript": "^4.1.3",
+    // ...other outdated dependencies
+  }
+}
+
+// Recommended process for upgrading
+// 1. Create a dependency update branch
+// 2. Update non-breaking minor versions first
+// 3. Run tests and fix any issues
+// 4. Update major versions with breaking changes one at a time
+// 5. Update build configurations and types as needed
+```
+
+## Technical Debt Remediation Plan
+
+### Short-term (1-3 Months)
+
+1. **Address Critical Performance Issues**
+   - Implement chunked processing for position updates
+   - Optimize WebSocket binary protocol handling
+   - Improve node culling for large graphs
+
+2. **Fix WebSocket Connection Reliability**
+   - Refactor WebSocket connection state management
+   - Implement proper reconnection logic with backoff
+   - Add comprehensive error recovery
+
+3. **Improve Error Handling**
+   - Create central error handling utilities
+   - Standardize error reporting and logging
+   - Add error boundary components
+
+### Medium-term (3-6 Months)
+
+1. **Reduce Code Duplication**
+   - Extract common patterns into shared utilities
+   - Create reusable components for repeated UI patterns
+   - Establish code reuse guidelines
+
+2. **Standardize State Management**
+   - Define state management architecture
+   - Refactor to consistent patterns
+   - Document state flow and management approach
+
+3. **Improve Test Coverage**
+   - Add unit tests for core business logic
+   - Implement integration tests for critical flows
+   - Set up visual regression testing
+
+### Long-term (6-12 Months)
+
+1. **Reduce Component Coupling**
+   - Refactor to use dependency injection
+   - Replace singleton patterns with proper DI
+   - Create clearer module boundaries
+
+2. **Update Dependencies**
+   - Establish regular dependency update process
+   - Upgrade all outdated dependencies
+   - Modernize build tools and configurations
+
+3. **Code Style Standardization**
+   - Define and document coding standards
+   - Configure and enforce automated linting
+   - Gradually refactor legacy code
+
+## Measuring Technical Debt
+
+To track progress in addressing technical debt, we can use the following metrics:
+
+### Code Quality Metrics
+
+- **Cyclomatic Complexity**: Measure the complexity of functions and methods
+- **Duplication**: Track the percentage of duplicated code
+- **Test Coverage**: Measure the percentage of code covered by tests
+- **Warning Count**: Track ESLint warnings and errors
+
+### Performance Metrics
+
+- **Frame Rate**: Monitor average and minimum frame rates
+- **Memory Usage**: Track memory consumption over time
+- **Loading Time**: Measure time to interactive and data loading performance
+- **Network Efficiency**: Monitor WebSocket message size and frequency
+
+### Development Metrics
+
+- **Bug Rate**: Track the number of bugs per feature or release
+- **Change Failure Rate**: Measure the percentage of changes that result in issues
+- **Time to Fix**: Measure how long it takes to fix issues
+- **Developer Satisfaction**: Survey developers about codebase maintainability
+
+## Next Sections
+
+For more detailed information, refer to:
+- [Performance](performance.md) - Performance considerations and optimizations
+- [Error Handling](error-handling.md) - Error handling patterns and implementation
+- [Business Logic](business-logic.md) - Core business rules and implementation
\ No newline at end of file
diff --git a/docs/clientdocs/index.md b/docs/clientdocs/index.md
new file mode 100644
index 00000000..13f35290
--- /dev/null
+++ b/docs/clientdocs/index.md
@@ -0,0 +1,120 @@
+# LogseqSpringThing Client Documentation
+
+This documentation provides a comprehensive technical overview of the LogseqSpringThing client architecture, APIs, components, and implementation details. It's intended to serve as a complete reference that would enable reimplementation while maintaining behavioral equivalence.
+
+## Documentation Structure
+
+### Architecture
+- [System Overview](architecture/overview.md) - High-level architecture and system design
+- [Component Architecture](architecture/component-architecture.md) - Detailed component relationships and dependencies
+- [Data Flow](architecture/data-flow.md) - Data flow patterns throughout the system
+- [State Management](architecture/state-management.md) - State management patterns and state transitions
+
+### APIs
+- [REST Endpoints](apis/rest-endpoints.md) - Complete REST API specification
+- [WebSocket Protocol](apis/websocket-protocol.md) - WebSocket communication protocol and binary format
+- [Payload Formats](apis/payload-formats.md) - Request/response payload formats and schemas
+- [Authentication](apis/authentication.md) - Authentication and authorization mechanisms
+
+### Components
+- [Rendering Pipeline](components/rendering-pipeline.md) - Three.js integration and rendering optimization
+- [Node Management](components/node-management.md) - Node representation and management
+- [Metadata Visualization](components/metadata-visualization.md) - Metadata handling and visualization
+- [XR Integration](components/xr-integration.md) - WebXR integration and interaction models
+- [UI Components](components/ui-components.md) - User interface components and patterns
+
+### Core
+- [Business Logic](core/business-logic.md) - Core business logic and rules
+- [Error Handling](core/error-handling.md) - Error handling patterns and recovery strategies
+- [Performance](core/performance.md) - Performance considerations and optimizations
+- [Technical Debt](core/technical-debt.md) - Technical debt analysis and refactoring opportunities
+
+### Dependencies
+- [Third-Party Libraries](dependencies/third-party-libraries.md) - External dependencies and their usage
+- [Internal Dependencies](dependencies/internal-dependencies.md) - Internal module dependencies and relationships
+
+## Key Visualization Patterns
+
+The documentation uses consistent Mermaid diagrams to visualize:
+- Architecture and component relationships
+- Data flow and sequence diagrams
+- State transitions and application states
+- Error handling and recovery paths
+- Authentication and security flows
+
+## Audience
+
+This documentation is intended for:
+- Developers working on maintaining or extending the codebase
+- Teams planning architectural refactoring or optimization
+- Technical stakeholders evaluating the system architecture
+- New team members onboarding to the codebase
+
+## How to Use This Documentation
+
+Start with the Architecture section to understand the high-level system design, then dive into specific components or APIs as needed. Cross-references are provided throughout the documentation to help navigate related concepts.
+
+## Required Additional Documentation
+
+Based on the client code structure, we need to create the following additional documentation files:
+
+### Audio
+- `/docs/clientdocs/audio/audio-player.md`
+
+### Components
+- `/docs/clientdocs/components/settings-components.md`
+- `/docs/clientdocs/components/validation-components.md`
+
+### Config
+- `/docs/clientdocs/config/feature-flags.md`
+
+### Diagnostics
+- `/docs/clientdocs/diagnostics/node-diagnostics.md`
+- `/docs/clientdocs/diagnostics/system-diagnostics.md`
+
+### Monitoring
+- `/docs/clientdocs/monitoring/metrics-implementation.md`
+- `/docs/clientdocs/monitoring/performance-tracking.md`
+
+### Platform
+- `/docs/clientdocs/platform/platform-abstraction.md`
+
+### Rendering
+- `/docs/clientdocs/rendering/edge-management.md`
+- `/docs/clientdocs/rendering/geometry-factories.md`
+- `/docs/clientdocs/rendering/material-systems.md`
+- `/docs/clientdocs/rendering/shader-implementations.md`
+- `/docs/clientdocs/rendering/text-rendering.md`
+- `/docs/clientdocs/rendering/visualization-controllers.md`
+
+### Services
+- `/docs/clientdocs/services/authentication-services.md`
+- `/docs/clientdocs/services/settings-management.md`
+
+### State
+- `/docs/clientdocs/state/data-stores.md`
+- `/docs/clientdocs/state/settings-management.md`
+- `/docs/clientdocs/state/observers-pattern.md`
+
+### UI
+- `/docs/clientdocs/ui/control-panels.md`
+- `/docs/clientdocs/ui/styling-system.md`
+
+### Utils
+- `/docs/clientdocs/utils/event-emitters.md`
+- `/docs/clientdocs/utils/vector-utilities.md`
+
+### Visualization
+- `/docs/clientdocs/visualization/hologram-system.md`
+- `/docs/clientdocs/visualization/metadata-visualization.md`
+
+### WebSocket
+- `/docs/clientdocs/websocket/communication-protocol.md`
+- `/docs/clientdocs/websocket/service-implementation.md`
+
+### XR
+- `/docs/clientdocs/xr/hand-interactions.md`
+- `/docs/clientdocs/xr/session-management.md`
+- `/docs/clientdocs/xr/xr-implementation.md`
+
+Each documentation file should follow our established format, detailing purpose, interfaces, implementation details, and usage examples.
\ No newline at end of file
diff --git a/docs/contributing/guidelines.md b/docs/contributing/guidelines.md
new file mode 100644
index 00000000..9e0ab3e7
--- /dev/null
+++ b/docs/contributing/guidelines.md
@@ -0,0 +1,264 @@
+# Contributing Guidelines
+
+Thank you for your interest in contributing to LogseqXR! This document provides guidelines and best practices for contributing to the project.
+
+## Code of Conduct
+
+Please read and follow our [Code of Conduct](./CODE_OF_CONDUCT.md) to maintain a positive and inclusive community.
+
+## Getting Started
+
+### 1. Fork and Clone
+```bash
+# Fork the repository on GitHub, then:
+git clone https://github.com/yourusername/logseq-xr.git
+cd logseq-xr
+```
+
+### 2. Set Up Development Environment
+Follow the [Development Setup Guide](../development/setup.md) to configure your environment.
+
+### 3. Create a Branch
+```bash
+# Create a branch for your feature/fix
+git checkout -b feature/your-feature-name
+# or
+git checkout -b fix/your-fix-name
+```
+
+## Development Workflow
+
+### 1. Code Standards
+
+#### Rust Code
+- Follow the [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
+- Use `rustfmt` for formatting
+- Run `clippy` for linting
+```bash
+# Format code
+cargo fmt
+
+# Run clippy
+cargo clippy -- -D warnings
+```
+
+#### TypeScript/JavaScript Code
+- Follow the project's ESLint configuration
+- Use Prettier for formatting
+```bash
+# Lint code
+pnpm lint
+
+# Format code
+pnpm format
+```
+
+### 2. Testing Requirements
+
+#### Write Tests
+- Add unit tests for new functionality
+- Update existing tests when modifying code
+- Ensure all tests pass before submitting PR
+
+```bash
+# Run Rust tests
+cargo test
+
+# Run TypeScript tests
+pnpm test
+
+# Run end-to-end tests
+pnpm test:e2e
+```
+
+#### Test Coverage
+- Aim for 80% or higher coverage
+- Include both success and error cases
+- Test edge cases and boundary conditions
+
+### 3. Documentation
+
+#### Code Documentation
+- Document all public APIs
+- Include examples in doc comments
+- Update relevant documentation files
+
+#### Rust Documentation
+```rust
+/// Calculates the force between two nodes
+///
+/// # Arguments
+///
+/// * `node1` - First node
+/// * `node2` - Second node
+///
+/// # Returns
+///
+/// The force vector between the nodes
+///
+/// # Examples
+///
+/// ```
+/// let force = calculate_force(&node1, &node2);
+/// ```
+pub fn calculate_force(node1: &Node, node2: &Node) -> Vector3<f32> {
+    // Implementation
+}
+```
+
+#### TypeScript Documentation
+```typescript
+/**
+ * Updates node positions based on calculated forces
+ * 
+ * @param nodes - Array of nodes to update
+ * @param forces - Calculated forces for each node
+ * @param deltaTime - Time step for physics simulation
+ * 
+ * @returns Updated node positions
+ * 
+ * @example
+ * ```typescript
+ * const updatedNodes = updateNodePositions(nodes, forces, 0.016);
+ * ```
+ */
+function updateNodePositions(
+    nodes: Node[],
+    forces: Vector3[],
+    deltaTime: number
+): Node[] {
+    // Implementation
+}
+```
+
+### 4. Commit Guidelines
+
+#### Commit Messages
+Follow the [Conventional Commits](https://www.conventionalcommits.org/) specification:
+
+```
+<type>(<scope>): <description>
+
+[optional body]
+
+[optional footer]
+```
+
+Types:
+- `feat`: New feature
+- `fix`: Bug fix
+- `docs`: Documentation changes
+- `style`: Code style changes (formatting, etc.)
+- `refactor`: Code refactoring
+- `perf`: Performance improvements
+- `test`: Adding or updating tests
+- `chore`: Maintenance tasks
+
+Example:
+```
+feat(graph): add force-directed layout algorithm
+
+Implement Barnes-Hut algorithm for efficient force calculation
+in large graphs. This improves performance for graphs with
+over 1000 nodes.
+
+Closes #123
+```
+
+### 5. Pull Request Process
+
+1. **Update Your Branch**
+```bash
+git fetch origin
+git rebase origin/main
+```
+
+2. **Check Your Changes**
+```bash
+# Run all checks
+cargo fmt -- --check
+cargo clippy
+cargo test
+pnpm lint
+pnpm test
+```
+
+3. **Create Pull Request**
+- Use the PR template
+- Link related issues
+- Provide clear description
+- Include screenshots/videos if relevant
+
+4. **PR Template**
+```markdown
+## Description
+Brief description of changes
+
+## Type of Change
+- [ ] Bug fix
+- [ ] New feature
+- [ ] Breaking change
+- [ ] Documentation update
+
+## Testing
+- [ ] Added unit tests
+- [ ] Updated existing tests
+- [ ] Tested manually
+- [ ] Added documentation
+
+## Screenshots
+(if applicable)
+
+## Related Issues
+Fixes #123
+```
+
+5. **Review Process**
+- Address reviewer feedback
+- Keep PR focused and manageable
+- Maintain clear communication
+
+## Best Practices
+
+### 1. Code Organization
+- Keep functions focused and small
+- Use meaningful names
+- Follow project structure
+- Minimize dependencies
+
+### 2. Performance
+- Consider performance implications
+- Profile code changes
+- Document performance impacts
+- Test with large datasets
+
+### 3. Security
+- Follow security best practices
+- Validate inputs
+- Handle errors appropriately
+- Use safe API methods
+
+### 4. Accessibility
+- Follow WCAG guidelines
+- Test with screen readers
+- Provide keyboard navigation
+- Support high contrast modes
+
+## Getting Help
+
+- Join our [Discord server](https://discord.gg/logseq-xr)
+- Check existing issues and discussions
+- Ask questions in PR comments
+- Contact maintainers
+
+## Recognition
+
+Contributors are recognized in:
+- CONTRIBUTORS.md file
+- Release notes
+- Project documentation
+
+## Related Documentation
+- [Development Setup](../development/setup.md)
+- [Architecture Overview](../overview/architecture.md)
+- [API Documentation](../api/rest.md)
\ No newline at end of file
diff --git a/docs/deployment/docker.md b/docs/deployment/docker.md
new file mode 100644
index 00000000..c0574b85
--- /dev/null
+++ b/docs/deployment/docker.md
@@ -0,0 +1,326 @@
+# Docker Deployment Guide
+
+This guide details the deployment process for LogseqXR using Docker and Docker Compose.
+
+## Prerequisites
+
+- Docker Engine 24.0+
+- Docker Compose v2.20+
+- NVIDIA Container Toolkit (for GPU support)
+- Cloudflare account (for tunnel setup)
+
+## Directory Structure
+
+```
+logseq-xr/
+ .env                    # Environment variables
+ docker-compose.yml      # Service definitions
+ Dockerfile             # Multi-stage build definition
+ nginx.conf            # Nginx configuration
+ config.yml            # Cloudflare tunnel config
+ settings.yaml         # Application settings
+ data/                 # Mounted data volumes
+     markdown/         # Markdown files
+     metadata/         # Graph metadata
+     piper/           # TTS models
+     public/          # Built frontend files
+```
+
+## Configuration Files
+
+### 1. Environment Variables (.env)
+```env
+# GitHub Configuration
+GITHUB_TOKEN=your_github_token
+GITHUB_OWNER=your_github_username
+GITHUB_REPO=your_repo_name
+GITHUB_BASE_PATH=path/to/markdown/files
+
+# Cloudflare Configuration
+TUNNEL_TOKEN=your_cloudflare_tunnel_token
+
+# Application Settings
+RUST_LOG=info
+RUST_BACKTRACE=1
+NODE_ENV=production
+DOMAIN=your.domain.com
+
+# GPU Configuration
+NVIDIA_VISIBLE_DEVICES=0
+NVIDIA_DRIVER_CAPABILITIES=compute,utility
+
+# User Configuration
+UID=1000
+GID=1000
+```
+
+### 2. Docker Compose Configuration
+```yaml
+name: logseq-xr
+
+services:
+  webxr:
+    build: .
+    image: logseq-xr-image:latest
+    container_name: logseq-xr-webxr
+    read_only: false
+    networks:
+      ragflow:
+        aliases:
+          - logseq-xr-webxr
+          - webxr-client
+    deploy:
+      resources:
+        limits:
+          cpus: '16.0'
+          memory: 64G
+        reservations:
+          devices:
+            - driver: nvidia
+              device_ids: ['0']
+              capabilities: [gpu]
+    expose:
+      - "4000"
+    ports:
+      - "4000:4000"
+    environment:
+      - RUST_LOG=info
+      - RUST_BACKTRACE=1
+      - BIND_ADDRESS=0.0.0.0
+      - PORT=3001
+      - NGINX_PORT=4000
+      - NODE_ENV=production
+    volumes:
+      - ./data/markdown:/app/data/markdown
+      - ./data/metadata:/app/data/metadata
+      - ./data/piper:/app/data/piper
+      - ./client:/app/client
+      - type: bind
+        source: ${PWD}/settings.yaml
+        target: /app/settings.yaml
+        read_only: false
+      - type: tmpfs
+        target: /tmp
+        tmpfs:
+          size: 4G
+    healthcheck:
+      test: ["CMD-SHELL", "curl -f http://localhost:4000/ || exit 1"]
+      interval: 10s
+      timeout: 5s
+      retries: 5
+      start_period: 10s
+
+  cloudflared:
+    image: cloudflare/cloudflared:latest
+    container_name: cloudflared-tunnel
+    networks:
+      ragflow:
+        aliases:
+          - cloudflared
+    volumes:
+      - ./config.yml:/etc/cloudflared/config.yml:ro
+    command: tunnel --config /etc/cloudflared/config.yml run
+    environment:
+      - TUNNEL_TOKEN=${TUNNEL_TOKEN}
+```
+
+### 3. Nginx Configuration
+```nginx
+pid /var/run/nginx/nginx.pid;
+error_log /var/log/nginx/error.log debug;
+
+events {
+    worker_connections 1024;
+    multi_accept on;
+    use epoll;
+}
+
+http {
+    include /etc/nginx/mime.types;
+    default_type application/octet-stream;
+    charset utf-8;
+
+    # WebSocket configuration
+    map $http_upgrade $connection_upgrade {
+        default upgrade;
+        ''      close;
+    }
+
+    upstream backend {
+        server 127.0.0.1:3001;
+        keepalive 32;
+    }
+
+    server {
+        listen 4000 default_server;
+        root /app/data/public/dist;
+
+        # Security headers
+        add_header X-Content-Type-Options nosniff;
+        add_header X-Frame-Options SAMEORIGIN;
+        add_header X-XSS-Protection "1; mode=block";
+        add_header Content-Security-Policy "default-src 'self'";
+
+        # WebSocket endpoint
+        location /wss {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_read_timeout 3600s;
+        }
+
+        # API endpoints
+        location /api {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_buffering on;
+            proxy_buffer_size 256k;
+        }
+
+        # Static files
+        location / {
+            try_files $uri $uri/ /index.html =404;
+            expires 1h;
+        }
+    }
+}
+```
+
+## Deployment Steps
+
+### 1. Initial Setup
+```bash
+# Clone repository
+git clone https://github.com/yourusername/logseq-xr.git
+cd logseq-xr
+
+# Copy and configure environment
+cp .env_template .env
+nano .env
+
+# Create data directories
+mkdir -p data/{markdown,metadata,piper,public}
+```
+
+### 2. Build and Deploy
+```bash
+# Build and start services
+docker-compose up --build -d
+
+# Check logs
+docker-compose logs -f
+
+# Check service health
+docker ps
+docker-compose ps
+```
+
+### 3. Verify Deployment
+```bash
+# Check HTTP endpoint
+curl http://localhost:4000/health
+
+# Test WebSocket connection
+websocat ws://localhost:4000/wss
+```
+
+## Monitoring & Maintenance
+
+### Health Checks
+The Docker Compose configuration includes health checks that monitor:
+- HTTP endpoint availability
+- WebSocket connectivity
+- Resource usage
+
+### Resource Monitoring
+```bash
+# Monitor container resources
+docker stats logseq-xr-webxr
+
+# Check logs
+docker-compose logs -f
+
+# Check nginx logs
+docker exec logseq-xr-webxr tail -f /var/log/nginx/error.log
+```
+
+### Backup & Recovery
+```bash
+# Backup data volumes
+docker run --rm \
+  -v logseq-xr_data:/data \
+  -v $(pwd)/backup:/backup \
+  alpine tar czf /backup/data-backup.tar.gz /data
+
+# Restore from backup
+docker run --rm \
+  -v logseq-xr_data:/data \
+  -v $(pwd)/backup:/backup \
+  alpine tar xzf /backup/data-backup.tar.gz -C /
+```
+
+## Troubleshooting
+
+### Common Issues
+
+1. **GPU Not Detected**
+   ```bash
+   # Check GPU visibility
+   docker exec logseq-xr-webxr nvidia-smi
+   ```
+
+2. **WebSocket Connection Failed**
+   - Check nginx logs
+   - Verify proxy settings
+   - Ensure Cloudflare tunnel is running
+
+3. **Performance Issues**
+   - Monitor resource usage
+   - Check for memory leaks
+   - Verify GPU utilization
+
+### Recovery Procedures
+
+1. **Service Recovery**
+   ```bash
+   # Restart services
+   docker-compose restart
+
+   # Rebuild and restart
+   docker-compose up --build -d
+   ```
+
+2. **Data Recovery**
+   ```bash
+   # Stop services
+   docker-compose down
+
+   # Restore data
+   cp -r backup/data/* data/
+
+   # Restart services
+   docker-compose up -d
+   ```
+
+## Security Considerations
+
+1. **Container Security**
+   - Run containers as non-root
+   - Use read-only root filesystem
+   - Implement resource limits
+
+2. **Network Security**
+   - Use Cloudflare tunnel for secure access
+   - Implement proper firewall rules
+   - Enable security headers
+
+3. **Data Security**
+   - Regular backups
+   - Encrypted storage
+   - Proper permission management
+
+## Related Documentation
+- [Development Setup](../development/setup.md)
+- [Configuration Guide](../development/configuration.md)
+- [Performance Tuning](../technical/performance.md)
\ No newline at end of file
diff --git a/docs/development/debugging.md b/docs/development/debugging.md
new file mode 100644
index 00000000..4faa7c82
--- /dev/null
+++ b/docs/development/debugging.md
@@ -0,0 +1,167 @@
+# Debugging Guide
+
+This guide provides tools and techniques for debugging LogseqXR during development.
+
+## WebSocket Diagnostics
+
+WebSocket connections are critical for real-time graph updates. These diagnostic tools help identify and resolve connection issues.
+
+### Built-in Diagnostics
+
+LogseqXR includes built-in diagnostic functions for WebSocket troubleshooting:
+
+```typescript
+import { diagnoseWebSocketIssues } from './diagnostics';
+
+// Run comprehensive WebSocket diagnostics
+diagnoseWebSocketIssues();
+```
+
+The diagnostics will check:
+- WebSocket URL validation
+- Connection status
+- Binary protocol validation
+- Message processing
+- GraphDataManager integration
+
+### Common WebSocket Issues
+
+1. **Connection Failures**
+   - Check that the server is running on the expected port (default: 4000)
+   - Verify network connectivity between client and server
+   - Check for firewall or proxy restrictions
+
+2. **Binary Data Issues**
+   - Ensure data format matches the expected binary protocol
+   - Check for compression/decompression errors
+   - Verify that node IDs are correctly parsed
+
+3. **Performance Problems**
+   - Monitor message size and frequency
+   - Check for excessive updates that might overwhelm the client
+   - Verify that position deadbands are properly configured
+
+### WebSocket Monitoring
+
+You can monitor WebSocket traffic using browser developer tools:
+1. Open DevTools (F12 or Ctrl+Shift+I)
+2. Go to the Network tab
+3. Filter by "WS" to show WebSocket connections
+4. Select the connection to view messages
+
+## Rendering Issues
+
+### Three.js Debugging
+
+For Three.js rendering issues:
+
+1. **Enable Stats Panel**
+   ```javascript
+   import Stats from 'three/examples/jsm/libs/stats.module';
+   const stats = new Stats();
+   document.body.appendChild(stats.dom);
+   ```
+
+2. **Scene Inspector**
+   ```javascript
+   import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';
+   const gui = new GUI();
+   gui.add(mesh.position, 'x', -10, 10);
+   ```
+
+3. **Common Rendering Issues**
+   - Check camera position and frustum
+   - Verify that lights are properly configured
+   - Ensure materials and textures are loaded correctly
+
+## Performance Optimization
+
+### Client-Side Performance
+
+1. **Identify Bottlenecks**
+   - Use Chrome DevTools Performance tab to record and analyze performance
+   - Look for long tasks in the Main thread
+   - Check for excessive garbage collection
+
+2. **Rendering Optimization**
+   - Reduce draw calls by combining geometries
+   - Use instanced meshes for similar objects
+   - Implement level-of-detail (LOD) for complex scenes
+
+3. **Memory Management**
+   - Dispose of unused Three.js objects (geometries, materials, textures)
+   - Use object pooling for frequently created/destroyed objects
+   - Monitor memory usage with Chrome DevTools Memory tab
+
+### Server-Side Performance
+
+1. **Profiling Rust Code**
+   ```bash
+   RUSTFLAGS='-C debuginfo=2' cargo build --release
+   perf record -g ./target/release/logseq-xr
+   perf report
+   ```
+
+2. **WebSocket Optimization**
+   - Adjust compression settings for optimal balance
+   - Configure position and velocity deadbands appropriately
+   - Tune update frequency based on available bandwidth
+
+## Logging
+
+### Client-Side Logging
+
+LogseqXR uses a custom logger with different verbosity levels:
+
+```typescript
+import { logger } from './utils/logger';
+
+logger.debug('Detailed information');
+logger.info('General information');
+logger.warn('Warning message');
+logger.error('Error message');
+```
+
+Enable verbose logging in the browser console:
+```javascript
+localStorage.setItem('debug', 'true');
+```
+
+### Server-Side Logging
+
+Control Rust logging level through the `RUST_LOG` environment variable:
+
+```bash
+RUST_LOG=debug cargo run
+```
+
+Available log levels:
+- `error`: Only errors
+- `warn`: Warnings and errors
+- `info`: General information (default)
+- `debug`: Detailed debugging information
+- `trace`: Very verbose tracing information
+
+## Common Issues and Solutions
+
+### Node Position Issues
+
+If nodes are not positioned correctly:
+1. Check the binary protocol implementation
+2. Verify that position data is correctly encoded/decoded
+3. Ensure the client is correctly applying position updates
+
+### WebSocket Connection Problems
+
+If WebSocket connections fail:
+1. Verify the server is running and accessible
+2. Check for network issues or firewall restrictions
+3. Ensure the WebSocket URL is correctly constructed
+
+### Performance Degradation
+
+If performance degrades over time:
+1. Check for memory leaks using browser memory profiling
+2. Monitor CPU usage for excessive calculations
+3. Verify that unused Three.js objects are properly disposed
+4. Check for excessive WebSocket message traffic
diff --git a/docs/development/setup.md b/docs/development/setup.md
new file mode 100644
index 00000000..8a057502
--- /dev/null
+++ b/docs/development/setup.md
@@ -0,0 +1,324 @@
+# Development Setup Guide
+
+This guide will help you set up your development environment for LogseqXR.
+
+## Prerequisites
+
+### Required Software
+- Node.js >=18.0.0
+- Rust (version 1.70.0+)
+- Docker & Docker Compose
+- Git
+- pnpm (recommended) or npm
+- CUDA Toolkit 12.2+ (optional, for GPU acceleration)
+
+### Hardware Requirements
+- NVIDIA GPU with CUDA support (recommended)
+- At least 8GB RAM (16GB recommended)
+- 4GB+ GPU memory for optimal performance
+
+## Initial Setup
+
+### 1. Clone the Repository
+```bash
+git clone https://github.com/yourusername/logseq-xr.git
+cd logseq-xr
+```
+
+### 2. Environment Configuration
+Copy the environment template and configure your settings:
+```bash
+cp .env_template .env
+```
+
+Required environment variables:
+
+#### Server Configuration
+```env
+RUST_LOG=info
+BIND_ADDRESS=0.0.0.0
+DEBUG_MODE=true
+```
+
+#### CUDA Configuration (Optional)
+```env
+CUDA_ARCH=86  # 89 for Ada/A6000
+```
+
+#### Network Configuration
+```env
+DOMAIN=your.domain.com
+TUNNEL_TOKEN=your_cloudflare_tunnel_token
+TUNNEL_ID=your_tunnel_id
+```
+
+#### GitHub Configuration
+```env
+GITHUB_TOKEN=your_github_token
+GITHUB_OWNER=your_github_username
+GITHUB_REPO=your_repo_name
+GITHUB_PATH=/pages
+GITHUB_VERSION=
+GITHUB_RATE_LIMIT=
+```
+
+#### AI Integration Configuration
+```env
+# RAGFlow
+RAGFLOW_API_KEY=your_api_key
+RAGFLOW_API_BASE_URL=http://ragflow-server/v1/
+RAGFLOW_TIMEOUT=30
+RAGFLOW_MAX_RETRIES=3
+
+# Perplexity
+PERPLEXITY_API_KEY=your_api_key
+PERPLEXITY_MODEL=llama-3.1-sonar-small-128k-online
+PERPLEXITY_API_URL=https://api.perplexity.ai/chat/completions
+PERPLEXITY_MAX_TOKENS=4096
+
+# OpenAI
+OPENAI_API_KEY=your_api_key
+OPENAI_BASE_URL=wss://api.openai.com/v1/realtime
+```
+
+#### Authentication Configuration
+```env
+# Base access control
+APPROVED_PUBKEYS=pubkey1,pubkey2
+
+# Role-based access
+POWER_USER_PUBKEYS=pubkey1
+SETTINGS_SYNC_ENABLED_PUBKEYS=pubkey1,pubkey2
+
+# Feature-specific access
+PERPLEXITY_ENABLED_PUBKEYS=pubkey1
+OPENAI_ENABLED_PUBKEYS=pubkey1
+RAGFLOW_ENABLED_PUBKEYS=pubkey1
+```
+
+### 3. Install Dependencies
+
+#### Frontend Dependencies
+```bash
+# Install pnpm if not already installed
+npm install -g pnpm
+
+# Install frontend dependencies
+pnpm install
+```
+
+#### Rust Dependencies
+```bash
+# Install Rust dependencies
+cargo build
+
+# For GPU support
+cargo build --features gpu
+```
+
+## Configuration Files
+
+### settings.yaml
+Create or modify `settings.yaml` in the project root:
+```yaml
+system:
+  network:
+    domain: localhost
+    port: 4000
+    bind_address: 0.0.0.0
+  websocket:
+    heartbeat_interval: 30
+    reconnect_attempts: 5
+    compression_enabled: true
+    compression_threshold: 1024
+  gpu:
+    enable: true
+    workgroup_size: 256
+  debug:
+    enabled: false
+    enable_websocket_debug: false
+
+visualization:
+  nodes:
+    default_size: 1.0
+    min_size: 0.5
+    max_size: 2.0
+  edges:
+    default_width: 0.1
+    min_width: 0.05
+    max_width: 0.3
+  physics:
+    spring_strength: 0.1
+    repulsion: 1.0
+    damping: 0.8
+```
+
+### nginx.conf
+The nginx configuration is provided in the repository. For local development, the default configuration should work without modifications.
+
+## Development Workflow
+
+### 1. Start Development Server
+For local development without Docker:
+
+```bash
+# Terminal 1: Start the Rust backend
+cargo watch -x run
+
+# Terminal 2: Start the frontend development server
+pnpm dev
+```
+
+### 2. Using Docker for Development
+```bash
+# Build and start all services
+docker-compose up --build
+
+# View logs
+docker-compose logs -f
+
+# Restart services
+docker-compose restart
+
+# Stop services
+docker-compose down
+```
+
+## Testing
+
+### Running Tests
+
+#### Frontend Tests
+```bash
+# Run type checking
+pnpm type-check
+
+# Run linting
+pnpm lint
+
+# Format code
+pnpm format
+```
+
+#### Backend Tests
+```bash
+# Run all Rust tests
+cargo test
+
+# Run specific test
+cargo test test_name
+
+# Run with logging
+RUST_LOG=debug cargo test
+```
+
+### Linting and Formatting
+
+#### Frontend
+```bash
+# Run ESLint
+pnpm lint
+
+# Fix ESLint issues
+pnpm lint:fix
+
+# Format with Prettier
+pnpm format
+```
+
+#### Backend
+```bash
+# Format Rust code
+cargo fmt
+
+# Run Clippy linter
+cargo clippy
+```
+
+## Debugging
+
+### Frontend Debugging
+1. Open Chrome DevTools (F12)
+2. Use the "Sources" tab to set breakpoints
+3. Check the "Console" tab for errors and logs
+4. Use the React DevTools extension for component debugging
+
+### Backend Debugging
+1. Set the `RUST_LOG` environment variable:
+```bash
+export RUST_LOG=debug
+```
+
+2. Use logging in your code:
+```rust
+debug!("Debug message");
+info!("Info message");
+error!("Error message");
+```
+
+3. Check logs in `/tmp/webxr.log`
+
+### WebSocket Debugging
+Use the browser's Network tab to inspect WebSocket messages:
+1. Filter by "WS"
+2. Click on the WebSocket connection
+3. View messages in the "Messages" tab
+
+## Common Issues
+
+### GPU Initialization Failed
+If GPU initialization fails, the system will fall back to CPU computation. Check:
+1. GPU drivers are up to date
+2. CUDA is properly installed (if using GPU features)
+3. GPU has sufficient memory
+4. Correct CUDA_ARCH is set in .env
+
+### WebSocket Connection Issues
+If WebSocket connection fails:
+1. Check if the backend is running
+2. Verify nginx configuration
+3. Check browser console for errors
+4. Ensure ports are not blocked by firewall
+5. Verify WebSocket compression settings
+
+### Authentication Issues
+If authentication fails:
+1. Verify Nostr public keys are correctly configured
+2. Check role-based access settings
+3. Verify feature-specific access permissions
+4. Check WebSocket connection for authentication messages
+
+### GitHub API Rate Limiting
+If you encounter GitHub API rate limiting:
+1. Check your token permissions
+2. Use a token with appropriate scopes
+3. Implement request caching
+4. Add rate limit handling
+
+## Development Tools
+
+### Recommended VSCode Extensions
+- rust-analyzer
+- ESLint
+- Prettier
+- Docker
+- WebGL Shader
+- Mermaid Preview
+- Error Lens
+
+### VSCode Settings
+```json
+{
+  "editor.formatOnSave": true,
+  "editor.defaultFormatter": "esbenp.prettier-vscode",
+  "editor.codeActionsOnSave": {
+    "source.fixAll.eslint": true
+  },
+  "rust-analyzer.checkOnSave.command": "clippy"
+}
+```
+
+## Related Documentation
+- [Technical Architecture](../overview/architecture.md)
+- [API Documentation](../api/rest.md)
+- [Contributing Guidelines](../contributing/guidelines.md)
\ No newline at end of file
diff --git a/docs/overview/architecture.md b/docs/overview/architecture.md
new file mode 100644
index 00000000..7fdd91e9
--- /dev/null
+++ b/docs/overview/architecture.md
@@ -0,0 +1,149 @@
+# Technical Architecture
+
+LogseqXR is built on a robust and scalable architecture that combines a Rust-based backend server with a TypeScript-based frontend client.
+
+## Core System Architecture
+
+The following diagram illustrates the core components of the LogseqXR system and their interactions:
+
+```mermaid
+graph TB
+    subgraph Frontend
+        UI[User Interface Layer]
+        VR[WebXR Controller]
+        WS[WebSocket Client]
+        GPU[GPU Compute Layer]
+        ThreeJS[Three.js Renderer]
+        ChatUI[Chat Interface]
+        GraphUI[Graph Interface]
+        ControlPanel[Modular Control Panel]
+        VRControls[VR Control System]
+        WSService[WebSocket Service]
+        DataManager[Graph Data Manager]
+        LayoutEngine[Layout Engine]
+        SpaceMouse[SpaceMouse Controller]
+        NostrAuth[Nostr Authentication]
+        SettingsStore[Settings Store]
+    end
+
+    subgraph Backend
+        Server[Actix Web Server]
+        FileH[File Handler]
+        GraphH[Graph Handler]
+        WSH[WebSocket Handler]
+        PerplexityH[Perplexity Handler]
+        RagFlowH[RagFlow Handler]
+        VisualizationH[Visualization Handler]
+        NostrH[Nostr Handler]
+        FileS[File Service]
+        GraphS[Graph Service]
+        GPUS[GPU Compute Service]
+        PerplexityS[Perplexity Service]
+        RagFlowS[RagFlow Service]
+        SpeechS[Speech Service]
+        NostrS[Nostr Service]
+        WSManager[WebSocket Manager]
+        GPUCompute[GPU Compute]
+        Compression[Compression Utils]
+        AudioProc[Audio Processor]
+        Node[Node Model]
+        Edge[Edge Model]
+        Graph[Graph Model]
+        Metadata[Metadata Model]
+        Position[Position Update Model]
+        SimParams[Simulation Parameters]
+    end
+
+    subgraph External
+        GitHub[GitHub API]
+        Perplexity[Perplexity AI]
+        RagFlow[RagFlow API]
+        OpenAI[OpenAI API]
+        Nostr[Nostr API]
+    end
+
+    UI --> ChatUI
+    UI --> GraphUI
+    UI --> ControlPanel
+    UI --> VRControls
+    UI --> NostrAuth
+
+    VR --> ThreeJS
+    WS --> WSService
+    WSService --> Server
+
+    Server --> FileH
+    Server --> GraphH
+    Server --> WSH
+    Server --> PerplexityH
+    Server --> RagFlowH
+    Server --> VisualizationH
+    Server --> NostrH
+
+    FileH --> FileS
+    GraphH --> GraphS
+    WSH --> WSManager
+    PerplexityH --> PerplexityS
+    RagFlowH --> RagFlowS
+    NostrH --> NostrS
+
+    FileS --> GitHub
+    PerplexityS --> Perplexity
+    RagFlowS --> RagFlow
+    SpeechS --> OpenAI
+    NostrS --> Nostr
+```
+
+## Component Breakdown
+
+### Frontend Components
+
+- **UI (User Interface Layer)**: Handles user interactions, displays information, and manages UI elements.
+- **VR (WebXR Controller)**: Manages WebXR sessions, input, and rendering for VR/AR devices.
+- **WS (WebSocket Client)**: Establishes and maintains a WebSocket connection with the backend server.
+- **GPU (GPU Compute Layer)**: Performs GPU-accelerated computations using CUDA.
+- **ThreeJS (Three.js Renderer)**: Renders the 3D graph visualization using WebGL.
+- **ChatUI**: Handles the chat interface for interacting with the AI.
+- **GraphUI**: Manages the graph visualization, including nodes, edges, and layout.
+- **ControlPanel**: Modular control panel with dockable sections, Nostr authentication, and real-time settings management.
+- **VRControls**: Handles VR-specific controls and interactions.
+- **WSService**: Manages the WebSocket connection and message handling.
+- **DataManager**: Manages the graph data structure and updates.
+- **LayoutEngine**: Computes the force-directed layout of the graph.
+- **SpaceMouse**: Handles input from Spacemouse devices.
+- **NostrAuth**: Manages Nostr-based authentication and user sessions.
+- **SettingsStore**: Centralized settings management with persistence and validation.
+
+### Backend Components
+
+- **Server (Actix Web Server)**: The core backend server built with the Actix web framework.
+- **FileH (File Handler)**: Handles file-related operations, such as fetching and processing Markdown files.
+- **GraphH (Graph Handler)**: Manages graph data and operations, such as building and updating the graph.
+- **WSH (WebSocket Handler)**: Handles WebSocket connections and messages.
+- **PerplexityH (Perplexity Handler)**: Interfaces with the Perplexity AI service.
+- **RagFlowH (RagFlow Handler)**: Interfaces with the RAGFlow service.
+- **VisualizationH (Visualization Handler)**: Handles visualization-related requests.
+- **NostrH (Nostr Handler)**: Manages Nostr authentication and user sessions.
+- **FileS (File Service)**: Provides file-related services.
+- **GraphS (Graph Service)**: Provides graph-related services.
+- **GPUS (GPU Compute Service)**: Manages GPU-accelerated computations.
+- **PerplexityS (Perplexity Service)**: Provides an interface to the Perplexity AI service.
+- **RagFlowS (RagFlow Service)**: Provides an interface to the RAGFlow service.
+- **SpeechS (Speech Service)**: Manages text-to-speech functionality.
+- **NostrS (Nostr Service)**: Provides Nostr-related services and user management.
+- **WSManager (WebSocket Manager)**: Manages WebSocket connections and message routing.
+
+### External Services
+
+- **GitHub API**: Provides access to the GitHub API for fetching and updating files.
+- **Perplexity AI**: Provides AI-powered question answering and content analysis.
+- **RagFlow API**: Provides AI-powered conversational capabilities.
+- **OpenAI API**: Provides text-to-speech functionality.
+- **Nostr API**: Provides decentralized authentication and user management.
+
+For more detailed technical information, please refer to:
+- [Binary Protocol](../technical/binary-protocol.md)
+- [Performance Optimizations](../technical/performance.md)
+- [Class Diagrams](../technical/class-diagrams.md)
+- [WebSockets Implementation](../technical/websockets.md)
+- [Graph Node Stacking Fix](../technical/graph-node-stacking-fix.md)
\ No newline at end of file
diff --git a/docs/overview/introduction.md b/docs/overview/introduction.md
new file mode 100644
index 00000000..9a9cfc5d
--- /dev/null
+++ b/docs/overview/introduction.md
@@ -0,0 +1,129 @@
+# LogseqXR: Immersive WebXR Visualization for Logseq Knowledge Graphs
+
+![image](https://github.com/user-attachments/assets/269a678d-88a5-42de-9d67-d73b64f4e520)
+
+**Inspired by the innovative work of Prof. Rob Aspin:** [https://github.com/trebornipsa](https://github.com/trebornipsa)
+
+![P1080785_1728030359430_0](https://github.com/user-attachments/assets/3ecac4a3-95d7-4c75-a3b2-e93deee565d6)
+
+## Project Overview
+
+LogseqXR revolutionizes the way you interact with your Logseq knowledge base. It's not just a visualization tool; it's a complete platform that transforms your notes into a living, breathing 3D graph, explorable in immersive AR/VR environments. This project leverages the power of **WebXR**, **Perplexity AI**, **RAGFlow**, and **Nostr** to create a dynamic and interactive experience, allowing you to literally step into your knowledge graph and gain new insights through AI-powered interactions.
+
+**What does this mean for you?**
+
+Imagine walking through your Logseq notes as if they were a physical space. Each note becomes a tangible node, connected by edges that represent the relationships between your ideas. With LogseqXR, you can:
+
+- **Visualize Complexity:** See the intricate connections within your knowledge base in a way that's impossible with a flat, 2D representation.
+- **Interact Intuitively:** Move, manipulate, and explore your notes using natural hand gestures or controllers in AR/VR, or through a traditional mouse and keyboard interface.
+- **Gain Deeper Understanding:** Leverage the power of AI to ask questions about your knowledge graph and receive contextually relevant answers, summaries, and insights.
+- **Collaborate in Real-Time:** Future versions will allow multiple users to explore and interact with the same knowledge graph simultaneously, fostering collaborative knowledge building.
+- **Seamlessly Update:** Changes made within the visualization can be automatically submitted back to your source GitHub repository as pull requests, ensuring your Logseq data stays synchronized.
+
+## Key Features
+
+LogseqXR is packed with features designed to enhance your knowledge exploration experience:
+
+### **1. Immersive WebXR 3D Visualization:**
+
+- **AR/VR Environments:** LogseqXR isn't just about viewing your graph on a screen. It's about stepping into it. With support for WebXR, you can experience your knowledge graph in augmented reality (AR) or virtual reality (VR) using compatible devices like the Oculus Quest.
+- **Node Interaction and Manipulation:**
+  - **Click, Drag, and Reposition:** Interact with nodes directly. Click to select, drag to move, and reposition nodes to explore different perspectives on your data.
+  - **Intuitive Navigation:** Use hand tracking or controllers to navigate through the 3D space, zoom in and out, and focus on specific areas of interest.
+- **Dynamic Force-Directed Layout:**
+  - **Real-time Recalculation:** The graph layout is not static. It's powered by a force-directed algorithm that constantly recalculates node positions based on their connections and user interactions. This creates a dynamic and organic visualization that adapts to changes in real-time.
+  - **Customizable Physics:** Fine-tune the physics parameters (like spring strength, repulsion, and damping) to control the layout behavior and tailor it to your preferences.
+- **Custom Shaders for Visual Effects:**
+  - **Holographic Displays:** Nodes and edges can be rendered with a futuristic holographic effect, enhancing the immersive experience.
+  - **Lighting Effects:** Dynamic lighting adds depth and realism to the visualization, making it easier to perceive the 3D structure of the graph.
+- **Fisheye Distortion for Focus + Context Visualization:**
+  - **Focus on Details:** Apply a fisheye distortion effect to magnify specific areas of the graph while still maintaining an overview of the surrounding context. This allows you to focus on details without losing sight of the bigger picture.
+
+### **2. Modular Control Panel with Nostr Authentication**
+
+- **Dockable Interface:**
+  - Flexible, modular control panel with dockable sections
+  - Customizable layout to suit your workflow
+  - Collapsible sections for better space management
+- **Nostr Authentication:**
+  - Secure authentication using Nostr protocol
+  - Role-based access control (Basic/Power User)
+  - Feature access management based on user roles
+- **Settings Management:**
+  - Real-time settings updates with instant visual feedback
+  - Settings persistence across sessions
+  - Advanced settings for power users
+
+### **3. Voice Interaction System**
+
+The system provides flexible voice interaction capabilities with two options:
+
+#### Current Implementation:
+- **OpenAI Voice Integration:**
+  - Real-time voice-to-voice communication via WebSocket API
+  - High-quality text-to-speech synthesis
+  - Natural language understanding
+  - Low-latency streaming responses
+
+#### Planned Local Implementation:
+- **GPU-Accelerated Voice Processing:**
+  - Kororo for local text-to-speech synthesis
+  - Whisper for local speech-to-text processing
+  - Full GPU acceleration for real-time performance
+  - Complete privacy with all processing done locally
+  - Zero dependency on external APIs
+
+Both systems support:
+- Real-time voice interaction
+- Natural conversation flow
+- Multi-language support
+- WebSocket streaming for low-latency responses
+- Seamless integration with the 3D visualization
+
+### **4. AI-Powered Knowledge Enhancement (In Development)**
+
+> **Note:** The Perplexity AI integration is currently under development. The following features describe the planned functionality that will be available in upcoming releases.
+
+- **Automated Knowledge Base Updates:**
+  - Perplexity AI analyzes your Markdown files to identify outdated information and suggest updates
+  - Automatically generates pull requests to keep your knowledge base current
+  - Maintains the integrity of your note structure while enhancing content
+
+- **Intelligent Content Analysis:**
+  - Identifies key topics and concepts across your knowledge base
+  - Suggests new connections between related notes
+  - Highlights potential gaps in your knowledge graph
+
+- **GitHub Integration:**
+  - Seamlessly submits updates through pull requests
+  - Maintains full version control of all AI-suggested changes
+  - Allows for easy review and approval of updates
+
+- **Content Enhancement:**
+  - Expands abbreviated notes with detailed explanations
+  - Adds relevant citations and references
+  - Updates technical information to reflect current state of the art
+
+### **5. Real-time Updates:**
+
+- **WebSocket-Based Communication:** LogseqXR uses WebSockets for real-time, bi-directional communication between the client and server. This ensures that any changes made to the graph, either locally or remotely, are instantly reflected in the visualization.
+- **Optimized Binary Protocol:**
+  - **Efficient Data Transfer:** To minimize bandwidth usage and maximize performance, LogseqXR uses a custom binary protocol for transmitting node position and velocity updates.
+  - **Fixed-Size Format:** Each node update uses a compact 28-byte format (4-byte header + 24 bytes data), making it extremely efficient to transmit over the network.
+  - **Initial Layout Flag:** The 4-byte header includes a flag to indicate whether the message contains the initial layout data or just incremental updates.
+- **Automatic Graph Layout Recalculation:** When the graph structure changes (e.g., new nodes or edges are added), the force-directed layout algorithm automatically recalculates the optimal node positions to maintain a clear and organized visualization.
+- **Live Preview of Changes:** Any changes made to the underlying Logseq knowledge base are immediately reflected in the 3D visualization, providing a live preview of your evolving knowledge graph.
+
+### **6. GPU Acceleration:**
+
+- **CUDA Acceleration for Layout Calculation:** LogseqXR leverages the power of NVIDIA GPUs to perform complex calculations for the force-directed layout algorithm. CUDA kernels enable parallel processing of node positions and velocities, resulting in significantly faster layout calculations compared to CPU-based approaches.
+- **Efficient Force-Directed Algorithms:** The force-directed layout algorithm is optimized for GPU execution, taking advantage of parallel processing to handle large graphs with thousands of nodes and edges.
+- **Fallback to CPU Computation:** If a compatible GPU is not available, LogseqXR gracefully falls back to CPU-based computation, ensuring that the visualization remains functional on a wide range of devices.
+- **GPU-Accelerated Visual Effects:** In addition to layout calculations, CUDA is used to power advanced visual effects like the holographic display and fisheye distortion, enhancing the overall visual appeal and immersiveness of the visualization.
+
+For more detailed information about specific features and components, please refer to the following documentation sections:
+
+- [Technical Architecture](../technical/architecture.md)
+- [Development Setup](../development/setup.md)
+- [API Documentation](../api/rest.md)
+- [Deployment Guide](../deployment/docker.md)
\ No newline at end of file
diff --git a/docs/technical/README.md b/docs/technical/README.md
new file mode 100644
index 00000000..9bfe9195
--- /dev/null
+++ b/docs/technical/README.md
@@ -0,0 +1,39 @@
+# Technical Documentation
+
+This directory contains detailed technical documentation about the system architecture, protocols, and implementation details.
+
+## Available Documentation
+
+### Core Systems
+
+* [Node ID Binding](./node-id-binding.md) - Critical information about node ID binding between binary protocol and metadata visualization
+* [Binary Protocol](./binary-protocol.md) - Details about the binary WebSocket protocol
+* [WebSockets](./websockets.md) - WebSocket implementation and architecture
+
+### Visualization Components
+
+* [Edge Handling Optimization](./edge-handling-optimization.md) - Edge rendering performance improvements
+* [Edge Rendering Fix Plan](./edge-rendering-fix-plan.md) - Plan for fixing edge rendering issues
+* [Hologram Edge Rendering](./hologram-edge-rendering.md) - Specialized edge rendering for holograms
+* [Metadata Text Visibility Fix](./metadata-text-visibility-fix.md) - Fixing metadata text visibility issues
+* [Node Manager Migration](./node-manager-migration.md) - Migration to new node management system
+
+### Performance and Architecture
+
+* [Performance](./performance.md) - Performance considerations and optimizations
+* [Scale Factors Architecture](./scale-factors-architecture.md) - Architecture of scale factors system
+* [Scale Factors Review](./scale-factors-review.md) - Review of scale factors implementation
+* [Dynamic Update Rate Optimization](./dynamic-update-rate-optimization.md) - WebSocket update rate optimization for force-directed graphs
+* [Vec3 Alignment](./vec3-alignment.md) - Alignment requirements for Vec3 structures
+
+### Integration and Settings
+
+* [GitHub Settings Migration](./github-settings-migration.md) - Migration of settings to GitHub
+* [Kokoros TTS Integration](./kokoros-tts-integration.md) - Integration with Kokoros text-to-speech
+* [Settings Initialization](./settings-initialization.md) - Initialization of application settings
+
+### Debugging
+
+* [Debug Enhancement Plan](./debug-enhancement-plan.md) - Plan for enhancing debugging capabilities
+* [Debug System](./debug-system.md) - Overview of the debugging system
+* [Graph Node Stacking Fix](./graph-node-stacking-fix.md) - Fix for stacked nodes in graph visualization
\ No newline at end of file
diff --git a/docs/technical/api/rest_api.md b/docs/technical/api/rest_api.md
new file mode 100644
index 00000000..3712eea8
--- /dev/null
+++ b/docs/technical/api/rest_api.md
@@ -0,0 +1,140 @@
+# REST API Documentation
+
+## Overview
+The REST API provides endpoints for graph data management, content operations, and system status.
+
+## Base URL
+```
+https://api.webxr.dev/v1
+```
+
+## Authentication
+All API requests require a JWT token in the Authorization header:
+```
+Authorization: Bearer <token>
+```
+
+## Endpoints
+
+### Graph Operations
+
+#### GET /graph
+Retrieves current graph state
+```json
+{
+  "nodes": [...],
+  "edges": [...],
+  "metadata": {...}
+}
+```
+
+#### POST /graph/update
+Updates graph data
+```json
+{
+  "nodes": [
+    {
+      "id": "string",
+      "position": {"x": 0, "y": 0, "z": 0},
+      "mass": 1.0
+    }
+  ]
+}
+```
+
+#### GET /graph/nodes/{nodeId}
+Retrieves specific node data
+```json
+{
+  "id": "string",
+  "metadata": {...},
+  "connections": [...]
+}
+```
+
+### Content Operations
+
+#### GET /content/{path}
+Retrieves markdown content
+```json
+{
+  "content": "string",
+  "metadata": {...}
+}
+```
+
+#### POST /content/upload
+Uploads new content
+```json
+{
+  "path": "string",
+  "content": "string",
+  "metadata": {...}
+}
+```
+
+### System Status
+
+#### GET /health
+System health check
+```json
+{
+  "status": "healthy",
+  "services": {
+    "gpu": "active",
+    "github": "connected"
+  }
+}
+```
+
+## WebSocket API
+
+### Connection
+```
+ws://api.webxr.dev/v1/ws
+```
+
+### Message Types
+
+#### Graph Updates
+```json
+{
+  "type": "graph_update",
+  "data": {
+    "nodes": [...],
+    "edges": [...]
+  }
+}
+```
+
+#### Simulation Status
+```json
+{
+  "type": "simulation_status",
+  "data": {
+    "phase": "dynamic",
+    "metrics": {...}
+  }
+}
+```
+
+## Error Responses
+
+### Standard Error Format
+```json
+{
+  "error": {
+    "code": "string",
+    "message": "string",
+    "details": {...}
+  }
+}
+```
+
+### Common Error Codes
+- `400`: Bad Request
+- `401`: Unauthorized
+- `403`: Forbidden
+- `404`: Not Found
+- `429`: Too Many Requests
+- `500`: Internal Server Error
\ No newline at end of file
diff --git a/docs/technical/architecture/CHANGELOG_graph_optimizations.md b/docs/technical/architecture/CHANGELOG_graph_optimizations.md
new file mode 100644
index 00000000..a16109d6
--- /dev/null
+++ b/docs/technical/architecture/CHANGELOG_graph_optimizations.md
@@ -0,0 +1,99 @@
+# Graph System Optimization Changes
+
+## Summary of Changes
+
+We have implemented a "hot start" architecture to improve client load times and optimize the graph data flow. This document summarizes the technical changes made to achieve this optimization.
+
+## Architectural Changes
+
+### 1. GraphData Enhancements
+- Added `last_validated` timestamp field to track when graph was last checked against metadata
+- Added `hot_started` flag to indicate when a graph was loaded from cache
+- Created new `GraphUpdateStatus` struct to track and communicate background update status
+
+### 2. Background Validation Process
+- Modified `graph_handler.rs` to immediately return cached data
+- Added asynchronous background validation using `tokio::spawn`
+- Implemented metadata SHA1 comparison to determine if rebuild is needed
+- Added tracking system to record changes for WebSocket notifications
+
+### 3. WebSocket Notification System
+- Added periodic checking for graph updates in the WebSocket system
+- Implemented JSON update notification message format
+- Added client message handler for `graphUpdateAvailable` notifications
+- Created system to mark and reset update availability flags
+
+### 4. AppState Integration
+- Added `graph_update_status` field to AppState for cross-component communication
+- Ensures WebSocket sessions can check for graph updates
+
+## Files Changed
+
+1. **src/models/graph.rs**
+   - Added `last_validated` timestamp
+   - Added `hot_started` flag
+   - Created `GraphUpdateStatus` struct
+
+2. **src/app_state.rs**
+   - Added `graph_update_status` shared state
+
+3. **src/handlers/graph_handler.rs**
+   - Implemented hot start with background validation
+   - Added update notification logic
+
+4. **src/handlers/socket_flow_handler.rs**
+   - Added graph update check interval
+   - Implemented update notification message sending
+   - Added handler for client acknowledgments
+
+5. **docs/technical/architecture/graph_system_optimizations.md**
+   - Created comprehensive documentation of the hot start system
+
+6. **docs/technical/architecture/graph_data_flow.md**
+   - Added detailed documentation of data flow with diagrams
+
+## Performance Benefits
+
+1. **Faster Initial Load**
+   - Client receives cached graph data immediately
+   - UI becomes responsive much faster
+
+2. **Resource Efficiency**
+   - Validation runs in background without blocking main thread
+   - Avoids redundant graph rebuilds for unchanged metadata
+
+3. **Progressive Updates**
+   - Only sends notifications when meaningful changes are detected
+   - Clients can fetch updated data as needed
+
+4. **Resilient Operations**
+   - System continues functioning with cache even during validation
+   - Clients can work with initial data while validation completes
+
+## Test Scenarios
+
+1. **Fresh Start**
+   - No cache available
+   - Full graph build from metadata
+   - Cache saved for future use
+
+2. **Hot Start - No Changes**
+   - Cache matches metadata (SHA1 hashes)
+   - Background validation confirms no changes
+   - No client notifications needed
+
+3. **Hot Start - With Changes**
+   - Cache partially matches metadata
+   - Background validation detects differences
+   - WebSocket clients receive update notification
+   - Clients fetch updated graph data
+
+## Future Enhancements
+
+1. **Partial Update Transmission**
+   - Send only changed nodes/edges instead of full graph
+   - Implement delta updates via WebSocket
+
+2. **Client-Side Reconciliation**
+   - Allow clients to merge updates without full refresh
+   - Preserve client-side layout optimizations
\ No newline at end of file
diff --git a/docs/technical/architecture/app_state.md b/docs/technical/architecture/app_state.md
new file mode 100644
index 00000000..25cc0c50
--- /dev/null
+++ b/docs/technical/architecture/app_state.md
@@ -0,0 +1,111 @@
+# App State Architecture
+
+## Overview
+The app state module manages the application's shared state and provides thread-safe access to core services.
+
+## Core Structure
+
+### AppState
+```rust
+pub struct AppState {
+    pub settings: Arc<RwLock<Settings>>,
+    pub metadata: Arc<RwLock<MetadataStore>>,
+    pub graph_service: GraphService,
+    pub github_client: Arc<GitHubClient>,
+    pub content_api: Arc<ContentAPI>,
+    pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
+}
+```
+
+## Initialization
+
+### Constructor
+```rust
+impl AppState {
+    pub async fn new(
+        settings: Arc<RwLock<Settings>>,
+        github_client: Arc<GitHubClient>,
+        content_api: Arc<ContentAPI>,
+        gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
+        metadata: Option<MetadataStore>,
+        graph_data: Option<GraphData>,
+        conversation_id: String,
+    ) -> Result<Self, Error>
+}
+```
+
+### Service Setup
+- GitHub client initialization
+- Graph service setup
+- GPU compute configuration
+
+## State Management
+
+### Thread Safety
+```rust
+pub type SafeState = Arc<AppState>;
+pub type SafeMetadata = Arc<RwLock<MetadataStore>>;
+```
+
+### Access Patterns
+```rust
+impl AppState {
+    pub async fn get_metadata(&self) -> RwLockReadGuard<MetadataStore>
+    pub async fn update_metadata(&self, updates: MetadataUpdates)
+}
+```
+
+## Service Integration
+
+### Graph Service
+```rust
+impl AppState {
+    pub async fn update_graph(&self, data: GraphData)
+    pub async fn get_graph_data(&self) -> GraphData
+}
+```
+
+### GitHub Integration
+```rust
+impl AppState {
+    pub async fn fetch_content(&self, path: &str) -> Result<String>
+    pub async fn update_content(&self, path: &str, content: &str)
+}
+```
+
+## Error Handling
+
+### State Errors
+```rust
+pub enum StateError {
+    Initialization(String),
+    ServiceUnavailable(String),
+    InvalidState(String),
+}
+```
+
+### Recovery
+```rust
+impl AppState {
+    pub async fn recover_from_error(&self, error: StateError)
+    pub async fn validate_state(&self) -> Result<(), StateError>
+}
+```
+
+## Implementation Details
+
+### Cleanup
+```rust
+impl Drop for AppState {
+    fn drop(&mut self) {
+        // Cleanup resources
+    }
+}
+```
+
+### State Validation
+```rust
+impl AppState {
+    pub fn validate(&self) -> Result<(), ValidationError>
+}
+```
\ No newline at end of file
diff --git a/docs/technical/architecture/config.md b/docs/technical/architecture/config.md
new file mode 100644
index 00000000..9c793519
--- /dev/null
+++ b/docs/technical/architecture/config.md
@@ -0,0 +1,103 @@
+# Configuration Architecture
+
+## Overview
+The configuration module manages application settings, environment variables, and feature flags.
+
+## Settings Management
+
+### Core Structure
+```rust
+pub struct Settings {
+    pub server: ServerConfig,
+    pub visualization: VisualizationConfig,
+    pub github: GitHubConfig,
+    pub security: SecurityConfig,
+}
+```
+
+### Environment Loading
+```rust
+impl Settings {
+    pub fn from_env() -> Result<Self, ConfigError> {
+        dotenv().ok();
+        // Load configuration from environment
+    }
+}
+```
+
+## Feature Flags
+
+### Configuration
+```rust
+pub struct FeatureFlags {
+    pub gpu_enabled: bool,
+    pub websocket_enabled: bool,
+    pub metrics_enabled: bool,
+}
+```
+
+### Dynamic Updates
+```rust
+impl FeatureFlags {
+    pub fn update_from_env(&mut self)
+    pub fn is_feature_enabled(&self, feature: &str) -> bool
+}
+```
+
+## Environment Configuration
+
+### Server Settings
+```rust
+pub struct ServerConfig {
+    pub host: String,
+    pub port: u16,
+    pub workers: usize,
+}
+```
+
+### API Configuration
+```rust
+pub struct APIConfig {
+    pub base_url: String,
+    pub timeout: Duration,
+    pub retry_count: u32,
+}
+```
+
+## Security Settings
+
+### Authentication
+```rust
+pub struct AuthConfig {
+    pub jwt_secret: String,
+    pub token_expiry: Duration,
+    pub refresh_enabled: bool,
+}
+```
+
+### Rate Limiting
+```rust
+pub struct RateLimitConfig {
+    pub requests_per_second: u32,
+    pub burst_size: u32,
+}
+```
+
+## Implementation Details
+
+### Loading Hierarchy
+1. Environment variables
+2. Configuration files
+3. Default values
+
+### Validation Rules
+```rust
+impl Settings {
+    pub fn validate(&self) -> Result<(), ValidationError>
+}
+```
+
+### Hot Reload
+```rust
+pub async fn reload_config() -> Result<(), ConfigError>
+```
\ No newline at end of file
diff --git a/docs/technical/architecture/gpu-compute.md b/docs/technical/architecture/gpu-compute.md
new file mode 100644
index 00000000..70d56174
--- /dev/null
+++ b/docs/technical/architecture/gpu-compute.md
@@ -0,0 +1,110 @@
+# GPU Compute Architecture
+
+## Overview
+The GPU Compute system provides CUDA-accelerated calculations for force-directed graph layout and other computationally intensive operations. It's designed for high performance while maintaining fallback capabilities for systems without GPU support.
+
+## Core Components
+
+### GPU Compute Service (`src/utils/gpu_compute.rs`)
+```rust
+pub struct GPUCompute {
+    pub device: CudaDevice,
+    pub stream: CudaStream,
+    pub module: CudaModule,
+    // ... other fields
+}
+```
+- Manages CUDA device initialization
+- Handles kernel loading and compilation
+- Provides memory management interface
+- Implements fallback mechanisms
+
+### Force Computation Kernel (`src/utils/compute_forces.cu`)
+```cuda
+__global__ void compute_forces(
+    float3* positions,
+    float3* forces,
+    int* edges,
+    float* params,
+    int num_nodes,
+    int num_edges
+)
+```
+- Parallel force calculation
+- Optimized memory access patterns
+- Configurable simulation parameters
+- Efficient edge force computation
+
+## Memory Management
+
+### Buffer Organization
+- Node position buffers
+- Force accumulation buffers
+- Edge relationship buffers
+- Parameter uniforms
+
+### Memory Transfer
+- Pinned memory for efficient transfers
+- Asynchronous operations
+- Double buffering for continuous updates
+
+## Computation Pipeline
+
+### Initialization
+1. Load CUDA module from PTX
+2. Allocate device memory
+3. Initialize constant parameters
+4. Prepare stream and event synchronization
+
+### Update Cycle
+1. Transfer updated positions
+2. Execute force computation kernel
+3. Apply position updates
+4. Synchronize results
+
+### Cleanup
+- Proper resource deallocation
+- Device memory cleanup
+- Stream synchronization
+
+## Performance Optimization
+
+### Kernel Optimization
+- Coalesced memory access
+- Shared memory usage
+- Warp-level primitives
+- Atomic operations where necessary
+
+### Memory Patterns
+- Structured buffer layouts
+- Aligned data structures
+- Minimized host-device transfers
+
+### Batch Processing
+- Multiple nodes per thread block
+- Edge batch processing
+- Efficient work distribution
+
+## Fallback System
+
+### CPU Fallback
+- Pure Rust implementation
+- Maintains algorithm compatibility
+- Performance-optimized sequential code
+
+### Feature Detection
+- CUDA availability checking
+- Capability-based initialization
+- Graceful degradation
+
+## Integration Points
+
+### Graph Service Integration
+- Direct buffer access
+- Synchronized updates
+- Event-based coordination
+
+### WebSocket Updates
+- Efficient position streaming
+- Batch update coordination
+- Binary protocol optimization
\ No newline at end of file
diff --git a/docs/technical/architecture/gpu_compute.md b/docs/technical/architecture/gpu_compute.md
new file mode 100644
index 00000000..7cc0ae01
--- /dev/null
+++ b/docs/technical/architecture/gpu_compute.md
@@ -0,0 +1,72 @@
+# GPU Compute System
+
+## Overview
+The GPU compute system provides hardware-accelerated physics calculations for graph layout with CPU fallback capabilities.
+
+## Architecture
+
+### Core Components
+```rust
+pub struct GPUCompute {
+    // GPU state management
+    compute_device: Arc<RwLock<Option<ComputeDevice>>>,
+    simulation_params: Arc<RwLock<SimulationParams>>,
+}
+```
+
+### Initialization Flow
+```rust
+match GPUCompute::new(&graph_data).await {
+    Ok(gpu_instance) => {
+        info!("GPU compute initialized successfully");
+        app_state.gpu_compute = Some(gpu_instance);
+    },
+    Err(e) => {
+        warn!("Failed to initialize GPU compute: {}. Using CPU fallback.", e);
+    }
+}
+```
+
+## Features
+
+### Physics Simulation
+- Force-directed layout calculation
+- Particle system simulation
+- Boundary constraints
+- Mass-spring system
+
+### Performance Optimization
+```rust
+pub struct SimulationParams {
+    pub time_step: f32,
+    pub phase: SimulationPhase,
+    pub mode: SimulationMode,
+    pub max_repulsion_distance: f32,
+    pub viewport_bounds: f32,
+    pub mass_scale: f32,
+    pub boundary_damping: f32,
+    pub enable_bounds: bool,
+}
+```
+
+### Fallback Mechanism
+- Automatic CPU fallback
+- Performance monitoring
+- Dynamic switching capability
+
+## Error Handling
+
+### GPU Initialization
+```rust
+pub async fn test_gpu_at_startup(gpu_compute: Option<Arc<RwLock<GPUCompute>>>) {
+    if let Some(gpu) = gpu_compute {
+        info!("[GraphService] Testing GPU compute functionality...");
+        // Implementation
+    }
+}
+```
+
+### Recovery Procedures
+- Device loss handling
+- Resource cleanup
+- State recovery
\ No newline at end of file
diff --git a/docs/technical/architecture/graph_data_flow.md b/docs/technical/architecture/graph_data_flow.md
new file mode 100644
index 00000000..c6195e41
--- /dev/null
+++ b/docs/technical/architecture/graph_data_flow.md
@@ -0,0 +1,146 @@
+# Graph Data Flow and Caching
+
+## Overview
+
+This document describes the data flow architecture of the graph system, focusing on performance optimizations through caching, background validation, and real-time updates.
+
+## Graph Data Loading Process
+
+The graph data flow follows an optimized pattern that prioritizes user experience through fast initial loading:
+
+```mermaid
+flowchart TD
+    Client[Client Application] -->|1. Request graph data| API[REST API]
+    API -->|2a. Check cache| Cache[graph.json Cache]
+    Cache -->|2b. Return cached data| API
+    API -->|3. Immediate response| Client
+    API -->|4. Spawn background task| Validator[Background Validator]
+    Validator -->|5. Compare with metadata| Metadata[metadata.json]
+    Validator -->|6. Update if needed| GraphService[Graph Service]
+    GraphService -->|7. Notify of changes| WebSocket[WebSocket Server]
+    WebSocket -->|8. Push update notification| Client
+    Client -->|9. Request updated data| API
+```
+
+## Caching Strategy
+
+### Cache Files
+- **graph.json**: The complete graph structure with nodes, edges, and metadata
+- **metadata.json**: The source of truth for node and graph metadata
+- **layout.json**: Cache for graph layout positions
+
+### Cache Validation
+Every graph cache validation compares SHA1 hashes between the cached graph and current metadata:
+1. When matching: Use cache as-is
+2. When mismatching: Only rebuild affected nodes/edges
+
+## Background Validation Process
+
+The background validation runs asynchronously after the initial response:
+
+1. The server sends cached graph data immediately to the client
+2. A background task validates the cache against current metadata:
+   - Checks SHA1 hashes of node content
+   - Verifies metadata timestamps
+   - Ensures appropriate node connections
+3. When validation detects needed changes:
+   - Updates the in-memory graph structure 
+   - Updates the cache file
+   - Sets a flag for connected clients
+4. WebSocket clients periodically check for updates
+5. When updates are available, clients receive a notification via WebSocket
+6. Clients request the updated graph data via REST API
+
+## WebSocket Update Notifications
+
+When the background validation detects changes, WebSocket clients are notified:
+
+```json
+{
+  "type": "graphUpdateAvailable",
+  "timestamp": 1647359761234,
+  "nodesChanged": 12
+}
+```
+
+The client can then fetch the updated graph data through the REST API endpoint.
+
+## Performance Benefits
+
+This architecture provides several important benefits:
+
+1. **Perceived Performance**: Users see content immediately from cache
+2. **Resource Efficiency**: Background validation doesn't block the UI thread
+3. **Network Optimization**: 
+   - Initial payload is from cache (fast)
+   - Only changed data transmitted after validation
+4. **Real-time Updates**: Changes detected during background validation are pushed to clients
+5. **Resilience**: System continues functioning with cache data even if validation fails
+
+## Implementation Details
+
+### Graph Service
+```rust
+// GraphService::build_graph_from_metadata
+// Validates cached graph against metadata
+if cached_graph.metadata.len() == metadata.len() {
+    // Check SHA1 hashes for changes
+    let mut needs_rebuild = false;
+    for (file_path, hash) in &metadata {
+        if !cached_graph.metadata.contains_key(file_path) || 
+           cached_graph.metadata.get(file_path) != Some(hash) {
+            needs_rebuild = true;
+            break;
+        }
+    }
+    
+    if !needs_rebuild {
+        return Ok(cached_graph);
+    }
+}
+```
+
+### Graph Handler
+```rust
+// Handle cached graph with background validation
+if graph_size > 0 {
+    info!("Graph already contains {} nodes, using existing data for hot start", graph_size);
+    
+    // Spawn background validation task
+    tokio::spawn(async move {
+        info!("Starting background validation of cached graph");
+        match GraphService::build_graph_from_metadata(&metadata_clone).await {
+            Ok(validated_graph) => {
+                // Update graph data if validation found changes...
+            },
+            Err(e) => error!("Background validation failed: {}", e)
+        }
+    });
+}
+```
+
+### Socket Flow Handler
+```rust
+// Check for graph updates and notify clients
+async fn check_for_graph_updates(&mut self, ctx: &mut ws::WebsocketContext<Self>) {
+    let update_status = app_state.graph_update_status.read().await;
+    
+    if update_status.update_available {
+        // Send update notification to client
+        let message = serde_json::json!({
+            "type": "graphUpdateAvailable",
+            "timestamp": chrono::Utc::now().timestamp_millis(),
+            "nodesChanged": update_status.nodes_changed 
+        });
+        
+        ctx.text(serde_json::to_string(&message).unwrap_or_default());
+    }
+}
+```
+
+## Edge Cases and Error Handling
+
+- If validation fails, the system continues with cache data
+- If cache file is corrupted, system falls back to full rebuilding
+- Cache staleness is detected through SHA1 hash comparisons
+- Clients can manually request a full refresh if needed
\ No newline at end of file
diff --git a/docs/technical/architecture/graph_system.md b/docs/technical/architecture/graph_system.md
new file mode 100644
index 00000000..3e294280
--- /dev/null
+++ b/docs/technical/architecture/graph_system.md
@@ -0,0 +1,110 @@
+# Graph System Architecture
+
+## Overview
+The graph system manages the application's core data structure, providing thread-safe access and real-time updates.
+
+## Components
+
+### Graph Data Structure
+```rust
+pub struct GraphData {
+    pub nodes: Vec<Node>,
+    pub edges: Vec<Edge>,
+    pub metadata: HashMap<String, String>,
+}
+```
+
+### Node Management
+```rust
+pub struct Node {
+    pub id: String,
+    pub data: NodeData,
+    pub metadata: NodeMetadata,
+}
+```
+
+### Edge Management
+```rust
+pub struct Edge {
+    pub source: String,
+    pub target: String,
+    pub weight: f32,
+    pub metadata: EdgeMetadata,
+}
+```
+
+## Services Integration
+
+### Graph Service
+```rust
+pub struct GraphService {
+    settings: Arc<RwLock<Settings>>,
+    graph_data: Arc<RwLock<GraphData>>,
+    node_map: Arc<RwLock<HashMap<String, Node>>>,
+    gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
+}
+```
+
+### Metadata Integration
+```rust
+pub async fn build_graph_from_metadata(
+    metadata_store: &MetadataStore
+) -> Result<GraphData, Error>
+```
+
+## Real-time Updates
+
+### WebSocket Integration
+- Live graph updates
+- State synchronization
+- Client notifications
+
+### Concurrency Management
+```rust
+static GRAPH_REBUILD_IN_PROGRESS: AtomicBool = AtomicBool::new(false);
+static SIMULATION_LOOP_RUNNING: AtomicBool = AtomicBool::new(false);
+```
+
+## Performance Optimization
+
+### Batch Processing
+```rust
+const BATCH_SIZE: usize = 5;
+for chunk in github_files.chunks(BATCH_SIZE) {
+    // Process files in batches
+}
+```
+
+### Memory Management
+- Efficient state updates
+- Resource cleanup
+- Cache optimization
+
+## Error Handling
+
+### Graph Operations
+- Node/edge validation
+- Data consistency checks
+- Error recovery
+
+### State Management
+```rust
+pub async fn calculate_layout_with_retry(
+    gpu_compute: &Arc<RwLock<GPUCompute>>,
+    graph: &mut GraphData,
+    node_map: &mut HashMap<String, Node>, 
+    params: &SimulationParams,
+) -> std::io::Result<()>
+```
+
+## Monitoring
+
+### Performance Metrics
+- Graph size tracking
+- Update frequency
+- Resource utilization
+
+### Health Checks
+- Data consistency
+- Service availability
+- Resource status
\ No newline at end of file
diff --git a/docs/technical/architecture/graph_system_optimizations.md b/docs/technical/architecture/graph_system_optimizations.md
new file mode 100644
index 00000000..55448dbc
--- /dev/null
+++ b/docs/technical/architecture/graph_system_optimizations.md
@@ -0,0 +1,124 @@
+# Graph System Optimizations
+
+## Overview
+This document describes optimization strategies for the graph system, focusing on reducing load times and improving the user experience.
+
+## Hot Start from Cache
+
+### Problem
+Initially, the application would load graph data synchronously, causing delays in the user interface. The client would have to wait for the entire graph to be built from metadata before rendering anything.
+
+### Solution
+The graph system now implements a "hot start" pattern that:
+
+1. Loads the cached graph data (`graph.json`) immediately for fast initial rendering
+2. Validates the cache against metadata in the background
+3. Updates the graph if needed and notifies connected clients
+
+### Implementation Flow
+
+```mermaid
+sequenceDiagram
+    participant Client
+    participant GraphHandler
+    participant GraphService
+    participant MetadataStore
+    participant WebSocket
+
+    Client->>GraphHandler: Request graph data
+    
+    alt Cache Available
+        GraphHandler->>GraphService: Load cached graph
+        GraphService-->>GraphHandler: Return cached graph
+        GraphHandler-->>Client: Immediate response with cached data
+        
+        Note over GraphHandler: Spawn background validation
+        GraphHandler->>+GraphService: Validate against metadata (async)
+        GraphService->>MetadataStore: Check SHA1 hashes
+        
+        alt Cache valid (SHA1 matches)
+            GraphService-->>GraphHandler: No changes needed
+        else Cache invalid or outdated
+            GraphService->>GraphService: Rebuild affected nodes/edges
+            GraphService-->>GraphHandler: Return updated graph
+            GraphHandler->>WebSocket: Broadcast updates
+            WebSocket-->>Client: Push updates via WebSocket
+        end
+    else No Cache
+        GraphHandler->>GraphService: Build graph from metadata
+        GraphService->>MetadataStore: Process all metadata
+        GraphService-->>GraphHandler: Return built graph
+        GraphHandler-->>Client: Response with newly built graph
+    end
+```
+
+## Background Validation Process
+
+The background validation process:
+
+1. Compares the SHA1 hashes in the cached graph with those in the current metadata
+2. Only rebuilds nodes and edges that have changed, preserving positions for unchanged nodes
+3. Sends updates to connected clients via WebSocket when changes are detected
+
+## Performance Benefits
+
+This approach provides several benefits:
+
+- **Perceived Performance**: The UI becomes responsive much faster as it starts with cached data
+- **Progressive Updates**: Changes are streamed to the client as they're detected
+- **Efficient Resource Use**: Validation runs in the background without blocking the main thread
+- **Bandwidth Optimization**: Only changed nodes are transmitted after the initial load
+
+## Implementation Details
+
+The implementation uses Tokio's asynchronous tasks to perform the validation without blocking the HTTP response:
+
+```rust
+// Load cached graph for immediate response
+let graph = state.graph_service.get_graph_data_mut().await;
+
+// Return quickly for hot start
+let response = GraphResponse { ... };
+ctx.text(serde_json::to_string(&response).unwrap());
+
+// Then validate in background
+tokio::spawn(async move {
+    if let Ok(validated_graph) = GraphService::build_graph_from_metadata(&metadata).await {
+        // Check for differences and broadcast updates if needed
+        // ...
+    }
+});
+```
+
+## WebSocket Notification
+
+When the background validation process detects changes, it broadcasts those changes to all connected WebSocket clients:
+
+```rust
+// In socket_flow_handler.rs
+ctx.text(serde_json::to_string(&serde_json::json!({
+    "type": "graph_update",
+    "timestamp": chrono::Utc::now().timestamp_millis(),
+    "changes": changes_count
+})).unwrap());
+```
+
+The client WebSocket handler listens for these updates and refreshes the data as needed:
+
+```typescript
+// In websocketService.ts
+socket.addEventListener('message', (event) => {
+    const data = JSON.parse(event.data);
+    if (data.type === 'graph_update') {
+        // Fetch updated graph data
+        fetchGraphData();
+    }
+});
+```
+
+## Edge Cases and Error Handling
+
+- If the validation process fails, the system continues with the cached data
+- If the cache file is corrupted, the system falls back to full rebuilding
+- Cache staleness is detected through SHA1 hash comparisons
+- The client is able to request a full refresh if needed
\ No newline at end of file
diff --git a/docs/technical/architecture/handlers.md b/docs/technical/architecture/handlers.md
new file mode 100644
index 00000000..abf231e5
--- /dev/null
+++ b/docs/technical/architecture/handlers.md
@@ -0,0 +1,104 @@
+# Request Handlers Architecture
+
+## Overview
+The handler layer manages HTTP and WebSocket endpoints, providing API interfaces for client interactions.
+
+## Core Handlers
+
+### API Handler
+```rust
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(
+        web::scope("/api")
+            // Route configurations
+    );
+}
+```
+- REST API endpoints
+- Request validation
+- Response formatting
+
+### WebSocket Handler
+```rust
+pub async fn socket_flow_handler(
+    req: HttpRequest,
+    stream: web::Payload,
+    app_state: web::Data<AppState>,
+) -> Result<HttpResponse, Error>
+```
+- Real-time communication
+- Graph updates
+- Client state management
+
+### Health Handler
+```rust
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(
+        web::scope("/health")
+            .route("", web::get().to(health_check))
+            .route("/ready", web::get().to(readiness_check))
+    );
+}
+```
+- System health monitoring
+- Readiness checks
+- Dependency status
+
+### Pages Handler
+```rust
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(
+        web::scope("/pages")
+            // Static and dynamic page routes
+    );
+}
+```
+- Static content serving
+- Dynamic page generation
+- Asset management
+
+## Middleware Integration
+
+### CORS Configuration
+```rust
+let cors = Cors::default()
+    .allow_any_origin()
+    .allow_any_method()
+    .allow_any_header()
+    .max_age(3600)
+    .supports_credentials();
+```
+
+### Compression
+```rust
+.wrap(middleware::Compress::default())
+```
+
+### Logging
+```rust
+.wrap(middleware::Logger::default())
+```
+
+## Error Handling
+
+### Request Validation
+- Input sanitization
+- Parameter validation
+- Type checking
+
+### Response Formatting
+- Error standardization
+- Status codes
+- Error messages
+
+## Security
+
+### Authentication
+- Token validation
+- Session management
+- Access control
+
+### Authorization
+- Role-based access
+- Permission checking
+- Resource protection
\ No newline at end of file
diff --git a/docs/technical/architecture/initialization.md b/docs/technical/architecture/initialization.md
new file mode 100644
index 00000000..c17b666a
--- /dev/null
+++ b/docs/technical/architecture/initialization.md
@@ -0,0 +1,71 @@
+# Application Initialization Process
+
+This document describes the initialization process of the application, which has been optimized for speed and efficiency through lazy loading techniques.
+
+## Overview
+
+The application initialization has been restructured to be non-blocking and to defer expensive operations until they're actually needed. This significantly improves startup time and responsiveness.
+
+## Initialization Sequence
+
+1. **Settings Loading**: The first step is loading settings from the configuration file
+2. **Logging Setup**: Configure logging based on settings
+3. **GitHub Client Initialization**: Initialize the GitHub client for content access
+4. **App State Creation**: Create the application state with minimal initial services
+5. **Metadata Loading**: Load existing metadata from cache (without processing files)
+6. **Lazy Graph Initialization**: Defer graph building until it's requested by a client
+7. **HTTP Server Start**: Begin accepting connections
+
+## Lazy Loading Implementation
+
+### Graph Service
+
+The GraphService now implements a lazy initialization pattern:
+
+- No graph is built during server startup
+- The graph is created only when requested by a client
+- When requested, it first attempts to load from cache
+- Only if the cache is invalid or missing, the full graph is rebuilt
+- Position layout caching preserves node positions between sessions
+
+### GraphService Initialization Flow
+
+```mermaid
+graph TD
+    A[Client Requests Graph] --> B{Cache Valid?}
+    B -->|Yes| C[Load from Cache]
+    B -->|No| D[Build Graph from Metadata]
+    D --> E[Initialize Positions]
+    E -->|Cache Available?| F[Load Positions from Cache]
+    E -->|No Cache| G[Generate Random Positions]
+    C --> H[Return Graph to Client]
+    F --> H
+    G --> H
+```
+
+### Metadata Processing
+
+- Metadata is loaded during startup, but file processing is deferred
+- SHA1 hash validation ensures only changed files are reprocessed
+- Individual file metadata is stored separately for incremental updates
+
+## Benefits
+
+1. **Faster Startup**: The server starts much more quickly
+2. **Immediate Responsiveness**: The server can handle requests immediately
+3. **Resource Efficiency**: Resources are only used when needed
+4. **Consistent Experience**: Caching preserves user context between sessions
+
+## Important Notes for Developers
+
+- First client graph request may take longer than subsequent requests
+- When making code changes that affect graph building, ensure the cache invalidation logic is updated
+- The GraphService will handle cache loading failures gracefully, falling back to full rebuilds
+- The position caching system automatically updates when the graph changes
+
+## Configuration
+
+Caching behavior can be adjusted through the following settings:
+
+- Cache paths are defined in `src/services/file_service.rs` as constants
+- The physics simulation parameters are still configurable in settings.yaml
\ No newline at end of file
diff --git a/docs/technical/architecture/models.md b/docs/technical/architecture/models.md
new file mode 100644
index 00000000..ce3ec72b
--- /dev/null
+++ b/docs/technical/architecture/models.md
@@ -0,0 +1,124 @@
+# Models Architecture
+
+## Overview
+The models module defines the core data structures and their relationships within the application.
+
+## Simulation Parameters
+
+### Core Structure
+```rust
+pub struct SimulationParams {
+    pub iterations: u32,
+    pub spring_strength: f32,
+    pub repulsion: f32,
+    pub damping: f32,
+    pub max_repulsion_distance: f32,
+    pub viewport_bounds: f32,
+    pub mass_scale: f32,
+    pub boundary_damping: f32,
+    pub enable_bounds: bool,
+    pub time_step: f32,
+    pub phase: SimulationPhase,
+    pub mode: SimulationMode,
+}
+```
+
+### Usage
+- Physics simulation configuration
+- Real-time parameter adjustment
+- Boundary conditions
+
+## UI Settings
+
+### Configuration
+```rust
+pub struct UISettings {
+    pub visualization: VisualizationConfig,
+    pub layout: LayoutConfig,
+    pub theme: ThemeConfig,
+}
+
+pub struct VisualizationConfig {
+    pub physics: PhysicsConfig,
+    pub rendering: RenderingConfig,
+}
+```
+
+### Features
+- Theme customization
+- Layout preferences
+- Visualization options
+
+## User Settings
+
+### Core Structure
+```rust
+pub struct UserSettings {
+    pub preferences: HashMap<String, Value>,
+    pub display: DisplaySettings,
+    pub interaction: InteractionSettings,
+}
+```
+
+### Persistence
+- Local storage
+- Profile sync
+- Default values
+
+## Protected Settings
+
+### Security Configuration
+```rust
+pub struct ProtectedSettings {
+    pub api_keys: HashMap<String, String>,
+    pub security: SecurityConfig,
+    pub rate_limits: RateLimitConfig,
+}
+```
+
+### Features
+- API key management
+- Security policies
+- Rate limiting
+
+## Metadata Store
+
+### Core Structure
+```rust
+pub struct MetadataStore {
+    pub files: HashMap<String, FileMetadata>,
+    pub relationships: Vec<Relationship>,
+    pub statistics: Statistics,
+}
+```
+
+### Operations
+- CRUD operations
+- Relationship management
+- Statistics tracking
+
+## Implementation Details
+
+### Thread Safety
+```rust
+pub type SafeMetadataStore = Arc<RwLock<MetadataStore>>;
+pub type SafeSettings = Arc<RwLock<Settings>>;
+```
+
+### Serialization
+```rust
+impl Serialize for MetadataStore {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+}
+```
+
+### Validation
+```rust
+impl SimulationParams {
+    pub fn validate(&self) -> Result<(), ValidationError>
+}
+```
+
+
diff --git a/docs/technical/architecture/service-layer.md b/docs/technical/architecture/service-layer.md
new file mode 100644
index 00000000..d3745324
--- /dev/null
+++ b/docs/technical/architecture/service-layer.md
@@ -0,0 +1,76 @@
+# Service Layer Architecture
+
+## Overview
+The service layer provides core business logic and data management capabilities, implementing key features like file handling, graph operations, and external service integration.
+
+## Core Services
+
+### File Service (`src/services/file_service.rs`)
+- Handles file system operations
+- Manages file metadata
+- Implements caching strategies
+- Coordinates with GitHub integration
+
+### Graph Service (`src/services/graph_service.rs`)
+- Core graph data structure management
+- Node and edge operations
+- Layout calculations
+- Graph state persistence
+
+### GitHub Integration (`src/services/github/`)
+```rust
+// Key components:
+mod api;        // API client implementation
+mod config;     // GitHub configuration
+mod content;    // Content management
+mod pr;         // Pull request handling
+mod types;      // Type definitions
+```
+
+### Perplexity Service (`src/services/perplexity_service.rs`)
+- AI integration for graph analysis
+- Query processing
+- Response handling
+
+### RAGFlow Service (`src/services/ragflow_service.rs`)
+- Retrieval-augmented generation
+- Document processing
+- Knowledge graph integration
+
+### Nostr Service (`src/services/nostr_service.rs`)
+- Authentication management
+- User session handling
+- Nostr protocol integration
+
+## Service Interaction Patterns
+
+### 1. Dependency Injection
+Services are initialized through the `AppState` structure:
+```rust
+pub struct AppState {
+    pub graph_service: GraphService,
+    pub github_client: Arc<GitHubClient>,
+    // ... other services
+}
+```
+
+### 2. Concurrency Management
+- Services use `Arc<RwLock<T>>` for shared state
+- Async operations with Tokio
+- Thread-safe data access patterns
+
+### 3. Error Handling
+- Consistent error propagation
+- Service-specific error types
+- Graceful degradation strategies
+
+## Configuration Management
+- Environment-based configuration
+- Feature flags
+- Service-specific settings
+
+## Performance Considerations
+- Connection pooling
+- Caching strategies
+- Rate limiting
+- Resource cleanup
\ No newline at end of file
diff --git a/docs/technical/architecture/services.md b/docs/technical/architecture/services.md
new file mode 100644
index 00000000..a7a2b633
--- /dev/null
+++ b/docs/technical/architecture/services.md
@@ -0,0 +1,135 @@
+# Services Architecture
+
+## Overview
+The services layer provides core business logic, external integrations, and data processing capabilities.
+
+## GitHub Service
+
+### Client Configuration
+```rust
+pub struct GitHubConfig {
+    pub api_token: String,
+    pub repository: String,
+    pub branch: String,
+    pub owner: String,
+}
+```
+
+### Content API
+```rust
+pub struct ContentAPI {
+    client: Arc<GitHubClient>,
+}
+
+impl ContentAPI {
+    pub async fn fetch_file_content(&self, url: &str) -> Result<String, GitHubError>
+    pub async fn list_markdown_files(&self, path: &str) -> Result<Vec<GitHubFileMetadata>, GitHubError>
+    pub async fn check_file_public(&self, url: &str) -> Result<bool, GitHubError>
+}
+```
+- File content retrieval
+- Markdown file listing
+- Access control checks
+
+### File Service
+```rust
+pub struct FileService {
+    node_id_counter: AtomicU32,
+}
+
+impl FileService {
+    pub async fn initialize_local_storage(settings: Arc<RwLock<Settings>>) -> Result<(), Box<dyn StdError>>
+    pub async fn fetch_and_process_files(
+        &self,
+        content_api: Arc<ContentAPI>,
+        settings: Arc<RwLock<Settings>>,
+        metadata_store: &mut MetadataStore,
+    ) -> Result<Vec<ProcessedFile>, Box<dyn StdError>>
+}
+```
+- Local storage management
+- File processing
+- Metadata handling
+
+### Graph Service
+```rust
+pub struct GraphService {
+    settings: Arc<RwLock<Settings>>,
+    graph_data: Arc<RwLock<GraphData>>,
+    node_map: Arc<RwLock<HashMap<String, Node>>>,
+    gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
+}
+
+impl GraphService {
+    pub async fn new(
+        settings: Arc<RwLock<Settings>>,
+        gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
+    ) -> Self
+
+    pub async fn calculate_layout_with_retry(
+        gpu_compute: &Arc<RwLock<GPUCompute>>,
+        graph: &mut GraphData,
+        node_map: &mut HashMap<String, Node>,
+        params: &SimulationParams,
+    ) -> std::io::Result<()>
+}
+```
+- Graph management
+- Physics simulation
+- Layout calculation
+
+## Error Handling
+
+### Service Errors
+```rust
+pub enum ServiceError {
+    GitHub(GitHubError),
+    File(std::io::Error),
+    Graph(String),
+    Configuration(String),
+}
+```
+
+### Retry Mechanisms
+```rust
+const MAX_RETRIES: u32 = 3;
+const RETRY_DELAY: Duration = Duration::from_secs(1);
+```
+- Exponential backoff
+- Error recovery
+- Circuit breaking
+
+## State Management
+
+### Shared State
+```rust
+pub struct AppState {
+    pub settings: Arc<RwLock<Settings>>,
+    pub metadata: Arc<RwLock<MetadataStore>>,
+    pub graph_service: GraphService,
+    pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
+}
+```
+- Thread-safe access
+- Service coordination
+- Resource management
+
+## Performance Optimization
+
+### Caching
+- In-memory caching
+- File system caching
+- Cache invalidation
+
+### Batch Processing
+```rust
+const BATCH_SIZE: usize = 5;
+for chunk in items.chunks(BATCH_SIZE) {
+    // Process in batches
+}
+```
+
+### Resource Management
+- Connection pooling
+- Memory optimization
+- Resource cleanup
diff --git a/docs/technical/architecture/types.md b/docs/technical/architecture/types.md
new file mode 100644
index 00000000..ab50d2a1
--- /dev/null
+++ b/docs/technical/architecture/types.md
@@ -0,0 +1,129 @@
+# Types Architecture
+
+## Overview
+The types module defines core data structures, type aliases, and common enums used throughout the application.
+
+## Core Types
+
+### Graph Types
+```rust
+pub struct GraphData {
+    pub nodes: Vec<Node>,
+    pub edges: Vec<Edge>,
+    pub metadata: HashMap<String, Metadata>,
+}
+
+pub struct Node {
+    pub id: String,
+    pub data: NodeData,
+}
+
+pub struct Edge {
+    pub source: String,
+    pub target: String,
+    pub weight: f32,
+}
+```
+
+### Simulation Types
+```rust
+pub enum SimulationPhase {
+    Dynamic,
+    Static,
+    Paused,
+}
+
+pub enum SimulationMode {
+    Local,
+    Remote,
+    Hybrid,
+}
+```
+
+## Models
+
+### Settings Models
+```rust
+pub struct UISettings {
+    pub theme: String,
+    pub layout: LayoutConfig,
+    pub visualization: VisualizationConfig,
+}
+
+pub struct UserSettings {
+    pub preferences: HashMap<String, Value>,
+    pub customizations: Vec<CustomSetting>,
+}
+
+pub struct ProtectedSettings {
+    pub api_keys: HashMap<String, String>,
+    pub security_config: SecurityConfig,
+}
+```
+
+### Metadata Models
+```rust
+pub struct MetadataStore {
+    pub files: HashMap<String, FileMetadata>,
+    pub relationships: Vec<Relationship>,
+}
+
+pub struct FileMetadata {
+    pub name: String,
+    pub size: usize,
+    pub node_id: String,
+    pub last_modified: DateTime<Utc>,
+}
+```
+
+## Error Types
+
+### Service Errors
+```rust
+pub enum ServiceError {
+    IO(std::io::Error),
+    Graph(String),
+    Config(String),
+}
+
+impl From<std::io::Error> for ServiceError {
+    fn from(err: std::io::Error) -> Self {
+        ServiceError::IO(err)
+    }
+}
+```
+
+### API Errors
+```rust
+pub enum APIError {
+    NotFound(String),
+    Unauthorized,
+    RateLimit,
+    Internal(String),
+}
+```
+
+## Type Aliases
+
+### Common Aliases
+```rust
+pub type Result<T> = std::result::Result<T, Error>;
+pub type NodeMap = HashMap<String, Node>;
+pub type MetadataMap = HashMap<String, Metadata>;
+```
+
+## Constants
+
+### System Constants
+```rust
+pub const MAX_NODES: usize = 10000;
+pub const DEFAULT_BATCH_SIZE: usize = 100;
+pub const CACHE_DURATION: Duration = Duration::from_secs(3600);
+```
+
+### Configuration Constants
+```rust
+pub const DEFAULT_PORT: u16 = 8080;
+pub const DEFAULT_HOST: &str = "127.0.0.1";
+pub const API_VERSION: &str = "v1";
+```
\ No newline at end of file
diff --git a/docs/technical/architecture/utils.md b/docs/technical/architecture/utils.md
new file mode 100644
index 00000000..d5b1e3d8
--- /dev/null
+++ b/docs/technical/architecture/utils.md
@@ -0,0 +1,142 @@
+# Utilities Architecture
+
+## Overview
+The utilities layer provides common functionality, helper methods, and shared tools across the application.
+
+## GPU Compute
+
+### Initialization
+```rust
+pub struct GPUCompute {
+    compute_device: Arc<RwLock<Option<ComputeDevice>>>,
+    simulation_params: Arc<RwLock<SimulationParams>>,
+}
+
+impl GPUCompute {
+    pub async fn new(graph_data: &GraphData) -> Result<Self, Error>
+    pub async fn test_gpu_at_startup(gpu_compute: Option<Arc<RwLock<GPUCompute>>>)
+}
+```
+- Device detection
+- Resource allocation
+- Capability testing
+
+### Simulation Parameters
+```rust
+pub struct SimulationParams {
+    pub iterations: u32,
+    pub spring_strength: f32,
+    pub repulsion: f32,
+    pub damping: f32,
+    pub time_step: f32,
+    pub phase: SimulationPhase,
+    pub mode: SimulationMode,
+}
+```
+
+## Logging
+
+### Configuration
+```rust
+pub struct LogConfig {
+    pub console_level: String,
+    pub file_level: String,
+}
+
+pub fn init_logging_with_config(config: LogConfig) -> Result<(), Error>
+```
+- Log levels
+- Output formatting
+- File rotation
+
+### Usage Patterns
+```rust
+info!("Starting operation: {}", operation_name);
+debug!("Processing data: {:?}", data);
+error!("Operation failed: {}", error);
+```
+
+## WebSocket Messages
+
+### Message Types
+```rust
+pub enum SocketMessage {
+    GraphUpdate(GraphData),
+    StateUpdate(StateData),
+    Error(ErrorData),
+}
+```
+- Binary messages
+- Text messages
+- Control frames
+
+### Flow Control
+```rust
+pub async fn socket_flow_handler(
+    req: HttpRequest,
+    stream: web::Payload,
+    app_state: web::Data<AppState>,
+) -> Result<HttpResponse, Error>
+```
+- Message queuing
+- Rate limiting
+- Connection management
+
+## Security
+
+### Token Management
+```rust
+pub fn generate_token() -> String
+pub fn validate_token(token: &str) -> Result<Claims, TokenError>
+```
+- Token generation
+- Validation
+- Expiration
+
+### Encryption
+```rust
+pub fn encrypt_data(data: &[u8], key: &[u8]) -> Result<Vec<u8>, CryptoError>
+pub fn decrypt_data(encrypted: &[u8], key: &[u8]) -> Result<Vec<u8>, CryptoError>
+```
+- Data encryption
+- Key management
+- Secure storage
+
+## Helper Functions
+
+### String Manipulation
+```rust
+pub fn sanitize_filename(name: &str) -> String
+pub fn generate_slug(title: &str) -> String
+```
+- Text formatting
+- Sanitization
+- Normalization
+
+### File Operations
+```rust
+pub async fn ensure_directory(path: &Path) -> Result<(), Error>
+pub async fn atomic_write(path: &Path, content: &[u8]) -> Result<(), Error>
+```
+- Safe writes
+- Directory management
+- Path handling
+
+## Error Handling
+
+### Custom Errors
+```rust
+pub enum UtilError {
+    IO(std::io::Error),
+    Format(String),
+    Validation(String),
+}
+```
+- Error types
+- Error conversion
+- Error context
+
+### Recovery Strategies
+- Retry logic
+- Fallback mechanisms
+- Error reporting
\ No newline at end of file
diff --git a/docs/technical/class-diagrams.md b/docs/technical/class-diagrams.md
new file mode 100644
index 00000000..ce0053cb
--- /dev/null
+++ b/docs/technical/class-diagrams.md
@@ -0,0 +1,253 @@
+# Class Diagrams
+
+This document provides detailed class diagrams and relationships for the major components of LogseqXR.
+
+## Core Application Structure
+
+```mermaid
+classDiagram
+    class App {
+        +websocketService: WebsocketService
+        +graphDataManager: GraphDataManager
+        +visualization: WebXRVisualization
+        +chatManager: ChatManager
+        +interface: Interface
+        +ragflowService: RAGFlowService
+        +nostrAuthService: NostrAuthService
+        +settingsStore: SettingsStore
+        +start()
+        +initializeEventListeners()
+        +toggleFullscreen()
+    }
+    class WebsocketService {
+        +socket: WebSocket
+        +listeners: Object
+        +reconnectAttempts: number
+        +maxReconnectAttempts: number
+        +reconnectInterval: number
+        +connect()
+        +on(event: string, callback: function)
+        +emit(event: string, data: any)
+        +send(data: object)
+        +reconnect()
+    }
+    class GraphDataManager {
+        +websocketService: WebsocketService
+        +graphData: GraphData
+        +requestInitialData()
+        +updateGraphData(newData: GraphData)
+        +getGraphData(): GraphData
+        +recalculateLayout()
+        +updateForceDirectedParams(name: string, value: any)
+    }
+    class WebXRVisualization {
+        +graphDataManager: GraphDataManager
+        +scene: Scene
+        +camera: Camera
+        +renderer: Renderer
+        +controls: Controls
+        +composer: Composer
+        +gpu: GPUUtilities
+        +nodeManager: EnhancedNodeManager
+        +edgeManager: EdgeManager
+        +hologramManager: HologramManager
+        +textRenderer: TextRenderer
+        +initialize()
+        +updateVisualization()
+        +initThreeJS()
+        +setupGPU()
+        +initPostProcessing()
+        +addLights()
+        +createHologramStructure()
+        +handleSpacemouseInput(x: number, y: number, z: number)
+        +handleBinaryPositionUpdate(buffer: ArrayBuffer)
+        +animate()
+        +updateVisualFeatures(control: string, value: any)
+        +onWindowResize()
+        +handleNodeDrag(nodeId: string, position: Vector3)
+        +getNodePositions(): PositionUpdate[]
+        +showError(message: string)
+    }
+
+    App --> WebsocketService
+    App --> GraphDataManager
+    App --> WebXRVisualization
+    App --> NostrAuthService
+    App --> SettingsStore
+    GraphDataManager --> WebsocketService
+    WebXRVisualization --> GraphDataManager
+```
+
+## Backend Services
+
+```mermaid
+classDiagram
+    class GraphService {
+        +build_graph(app_state: AppState): Result<GraphData, Error>
+        +calculate_layout(gpu_compute: GPUCompute, graph: GraphData, params: SimulationParams): Result<void, Error>
+        +initialize_random_positions(graph: GraphData)
+    }
+    class PerplexityService {
+        +process_file(file: ProcessedFile, settings: Settings, api_client: ApiClient): Result<ProcessedFile, Error>
+    }
+    class FileService {
+        +fetch_and_process_files(github_service: GitHubService, settings: Settings, metadata_map: Map<String, Metadata>): Result<Vec<ProcessedFile>, Error>
+        +load_or_create_metadata(): Result<Map<String, Metadata>, Error>
+        +save_metadata(metadata: Map<String, Metadata>): Result<void, Error>
+        +calculate_node_size(file_size: number): number
+        +extract_references(content: string, valid_nodes: String[]): Map<String, ReferenceInfo>
+        +convert_references_to_topic_counts(references: Map<String, ReferenceInfo>): Map<String, number>
+        +initialize_local_storage(github_service: GitHubService, settings: Settings): Result<void, Error>
+        +count_hyperlinks(content: string): number
+    }
+    class NostrService {
+        +settings: Settings
+        +validate_session(pubkey: str, token: str): bool
+        +get_user(pubkey: str): Option<NostrUser>
+        +update_user_api_keys(pubkey: str, api_keys: ApiKeys): Result<NostrUser>
+    }
+    class GitHubService {
+        +fetch_file_metadata(): Result<Vec<GithubFileMetadata>, Error>
+        +get_download_url(file_name: string): Result<string, Error>
+        +fetch_file_content(download_url: string): Result<string, Error>
+        +get_file_last_modified(file_path: string): Result<Date, Error>
+    }
+    class GitHubPRService {
+        +create_pull_request(file_name: string, content: string, original_sha: string): Result<string, Error>
+    }
+    class ApiClient {
+        +post_json(url: string, body: PerplexityRequest, perplexity_api_key: string): Result<string, Error>
+    }
+    class SpeechService {
+        +websocketManager: WebSocketManager
+        +settings: Settings
+        +start(receiver: Receiver<SpeechCommand>)
+        +initialize(): Result<void, Error>
+        +send_message(message: string): Result<void, Error>
+        +close(): Result<void, Error>
+        +set_tts_provider(use_openai: boolean): Result<void, Error>
+    }
+
+    GraphService --> GPUCompute
+    PerplexityService --> ApiClient
+    FileService --> GitHubService
+    GitHubPRService --> GitHubService
+    SpeechService --> WebSocketManager
+```
+
+## Frontend Components
+
+```mermaid
+classDiagram
+    class ChatManager {
+        +websocketService: WebsocketService
+        +ragflowService: RAGFlowService
+        +sendMessage(message: string)
+        +receiveMessage()
+        +handleIncomingMessage(message: string)
+    }
+    class Interface {
+        +chatManager: ChatManager
+        +visualization: WebXRVisualization
+        +controlPanel: ModularControlPanel
+        +handleUserInput(input: string)
+        +displayChatMessage(message: string)
+        +setupEventListeners()
+        +renderUI()
+        +updateNodeInfoPanel(node: object)
+        +displayErrorMessage(message: string)
+    }
+    class ModularControlPanel {
+        +settingsStore: SettingsStore
+        +validationDisplay: ValidationErrorDisplay
+        +sections: Map<string, SectionConfig>
+        +initializePanel()
+        +initializeNostrAuth()
+        +updateAuthUI(user: NostrUser)
+        +createSection(config: SectionConfig, paths: string[])
+        +toggleDetached(sectionId: string)
+        +toggleCollapsed(sectionId: string)
+        +show()
+        +hide()
+        +dispose()
+    }
+    class NostrAuthService {
+        +currentUser: NostrUser
+        +eventEmitter: SettingsEventEmitter
+        +settingsPersistence: SettingsPersistenceService
+        +initialize()
+        +login(): Promise<AuthResult>
+        +logout()
+        +getCurrentUser(): NostrUser
+        +isAuthenticated(): boolean
+        +isPowerUser(): boolean
+        +hasFeatureAccess(feature: string): boolean
+        +checkAuthStatus(pubkey: string)
+        +onAuthStateChanged(callback: function)
+    }
+    class SettingsStore {
+        +settings: Settings
+        +observers: Set<Observer>
+        +initialize()
+        +get(path: string): any
+        +set(path: string, value: any)
+        +subscribe(observer: Observer)
+        +unsubscribe(observer: Observer)
+        +validate(settings: Settings)
+        +persist()
+    }
+    class RAGFlowService {
+        +settings: Settings
+        +apiClient: ApiClient
+        +createConversation(userId: string): Promise<string>
+        +sendMessage(conversationId: string, message: string): Promise<string>
+        +getConversationHistory(conversationId: string): Promise<object>
+    }
+
+    Interface --> ChatManager
+    Interface --> WebXRVisualization
+    Interface --> ModularControlPanel
+    ChatManager --> RAGFlowService
+    ModularControlPanel --> SettingsStore
+    ModularControlPanel --> NostrAuthService
+```
+
+## WebSocket Components
+
+```mermaid
+classDiagram
+    class SpeechWs {
+        +websocketManager: WebSocketManager
+        +settings: Settings
+        +hb(ctx: Context)
+        +check_heartbeat(ctx: Context)
+        +started(ctx: Context)
+        +handle(msg: Message, ctx: Context)
+    }
+    class WebSocketManager {
+        +connections: Map<String, WebSocket>
+        +add_connection(id: String, ws: WebSocket)
+        +remove_connection(id: String)
+        +broadcast(message: Message)
+        +send_to(id: String, message: Message)
+    }
+
+    SpeechWs --> WebSocketManager
+```
+
+## Key Relationships
+
+- The `App` class serves as the main entry point and coordinates all major components
+- `WebsocketService` handles real-time communication between frontend and backend
+- `GraphDataManager` manages the graph data structure and coordinates with the visualization
+- `WebXRVisualization` handles the 3D rendering and XR interactions
+- `ModularControlPanel` provides a flexible UI with dockable sections and Nostr authentication
+- `NostrAuthService` manages user authentication and feature access
+- `SettingsStore` provides centralized settings management
+- Backend services are organized around specific responsibilities (files, graph, AI, auth, etc.)
+- Frontend components handle user interaction and visualization updates
+
+## Related Documentation
+- [Technical Architecture](../overview/architecture.md)
+- [Development Setup](../development/setup.md)
+- [API Documentation](../api/rest.md)
\ No newline at end of file
diff --git a/docs/technical/components/node-manager.md b/docs/technical/components/node-manager.md
new file mode 100644
index 00000000..92f498b1
--- /dev/null
+++ b/docs/technical/components/node-manager.md
@@ -0,0 +1,61 @@
+# Node Management System
+
+## Architecture
+
+The node management system uses a modular architecture optimized for Meta Quest 3 performance.
+
+### Core Components
+
+1. NodeGeometryManager
+   - Handles LOD and geometry optimization
+   - Manages geometry levels for different distances
+   - Optimizes for Quest hardware
+
+2. NodeInstanceManager
+   - Uses THREE.InstancedMesh for efficient rendering
+   - Manages batched updates
+   - Handles node indices and pending updates
+
+3. NodeMetadataManager
+   - Efficient label rendering
+   - Distance-based visibility
+   - Memory-optimized metadata storage
+
+4. NodeInteractionManager
+   - XR interaction handling
+   - Gesture recognition
+   - Haptic feedback support
+
+## Scale Management
+
+### AR Space Matching
+- Room scale is the source of truth for AR mode
+- Only xrSessionManager.ts handles room-scale adjustments
+- All other scaling is relative to room scale
+
+### Visualization Hierarchy
+- Node scaling based on visual importance
+- Hologram instance scaling for scene composition
+- Spatial relationships preserved in AR mode
+
+## Performance Optimizations
+
+- Instanced rendering for improved GPU performance
+- LOD system for distance-based detail
+- Batched updates for efficient state management
+- Memory-optimized data structures
+
+## Configuration
+
+```yaml
+features:
+  useInstancedNodes: true  # Enable instanced rendering
+  enableLOD: true         # Enable Level of Detail system
+```
+
+## Integration Points
+
+- WebSocket updates via binary protocol
+- XR session management
+- Visualization system
+- Physics system
\ No newline at end of file
diff --git a/docs/technical/components/platform-management.md b/docs/technical/components/platform-management.md
new file mode 100644
index 00000000..ef9eecaa
--- /dev/null
+++ b/docs/technical/components/platform-management.md
@@ -0,0 +1,65 @@
+# Platform Management
+
+## Overview
+The Platform Management system handles device capabilities, feature detection, and runtime environment management. It serves as the central coordination point for platform-specific features and optimizations.
+
+## Core Components
+
+### PlatformManager (`client/platform/platformManager.ts`)
+- Handles device capability detection
+- Manages feature flags and runtime configurations
+- Coordinates platform-specific initializations
+- Provides unified interface for platform-specific operations
+
+## Key Responsibilities
+
+### 1. Capability Detection
+- WebGL support and version
+- WebXR availability
+- GPU compute capabilities
+- Memory constraints
+- Input device support (SpaceMouse, VR controllers, etc.)
+
+### 2. Feature Management
+- Dynamic feature enabling/disabling based on platform capabilities
+- Performance profile management
+- Resource allocation strategies
+
+### 3. Runtime Optimization
+- Adapts rendering quality based on device capabilities
+- Manages memory usage patterns
+- Coordinates with GPU compute availability
+
+## Integration Points
+
+### Settings System
+- Synchronizes with `SettingsStore` for platform-specific configurations
+- Provides capability information for settings validation
+
+### Rendering System
+- Informs renderer of available capabilities
+- Manages quality settings based on platform performance
+
+### WebXR
+- Coordinates XR device detection and initialization
+- Manages XR session lifecycle
+
+## Usage Example
+
+```typescript
+// Initialize platform manager
+const platform = await PlatformManager.initialize();
+
+// Check capabilities
+if (platform.hasCapability('webxr')) {
+    // Initialize XR features
+}
+
+// Get performance profile
+const profile = platform.getPerformanceProfile();
+```
+
+## Error Handling
+- Graceful degradation when features are unavailable
+- Fallback strategies for unsupported capabilities
+- Clear error reporting for diagnostic purposes
\ No newline at end of file
diff --git a/docs/technical/components/visualization.md b/docs/technical/components/visualization.md
new file mode 100644
index 00000000..0792d86c
--- /dev/null
+++ b/docs/technical/components/visualization.md
@@ -0,0 +1,53 @@
+# Visualization System
+
+## Core Components
+
+### Edge Rendering
+- Dynamic width calculation based on settings
+- Node radius-aware endpoint positioning
+- Efficient geometry updates
+
+### Text Rendering
+- Distance-based scaling
+- Font loading with retry mechanism
+- Billboard behavior for readability
+- Outline support for visibility
+
+### Scale Management
+- Base scale from settings
+- AR mode compatibility
+- Performance-optimized scaling
+
+## Implementation Details
+
+### Edge Rendering
+```typescript
+const edgeWidth = Math.max(widthRange[0], Math.min(widthRange[1], baseWidth)) 
+    * settings.visualization.edges.scaleFactor;
+```
+
+### Text Visibility
+- Font loading verification
+- Configurable retry mechanism
+- Cached font instances
+- Distance-based scaling
+
+## Performance Considerations
+
+- GPU-optimized geometry updates
+- Batched rendering operations
+- Memory-efficient data structures
+- AR-specific optimizations
+
+## Configuration
+
+```yaml
+visualization:
+  edges:
+    scaleFactor: 2.0
+    widthRange: [0.1, 5.0]
+  text:
+    fontSize: 16
+    outlineWidth: 2
+    outlineColor: "#000000"
+```
\ No newline at end of file
diff --git a/docs/technical/compute/gpu_compute.md b/docs/technical/compute/gpu_compute.md
new file mode 100644
index 00000000..730d651a
--- /dev/null
+++ b/docs/technical/compute/gpu_compute.md
@@ -0,0 +1,161 @@
+# GPU Compute System
+
+## Overview
+The GPU compute system handles physics simulations and graph layout calculations using WebGPU for hardware acceleration.
+
+## Architecture
+
+### Core Components
+```rust
+pub struct GPUCompute {
+    device: Arc<Device>,
+    queue: Arc<Queue>,
+    compute_pipeline: ComputePipeline,
+    simulation_params: SimulationParams,
+    buffers: ComputeBuffers,
+}
+
+pub struct ComputeBuffers {
+    node_buffer: Buffer,
+    edge_buffer: Buffer,
+    params_buffer: Buffer,
+    output_buffer: Buffer,
+}
+```
+
+## Initialization
+
+### Device Setup
+```rust
+impl GPUCompute {
+    pub async fn new(settings: &Settings) -> Result<Self, GPUError> {
+        // Initialize WebGPU device
+        // Create compute pipeline
+        // Allocate buffers
+    }
+}
+```
+
+### Buffer Management
+```rust
+impl ComputeBuffers {
+    pub fn new(device: &Device, node_count: usize, edge_count: usize) -> Self {
+        // Create node buffer
+        // Create edge buffer
+        // Create parameter buffer
+        // Create output buffer
+    }
+}
+```
+
+## Computation Pipeline
+
+### Physics Simulation
+```rust
+impl GPUCompute {
+    pub async fn compute_forces(&mut self) -> Result<(), GPUError> {
+        // Update simulation parameters
+        // Dispatch compute shader
+        // Read results
+    }
+}
+```
+
+### Shader Code
+```wgsl
+@compute @workgroup_size(256)
+fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
+    // Force calculation
+    // Position updates
+    // Boundary checking
+}
+```
+
+## Fallback System
+
+### CPU Fallback
+```rust
+impl GPUCompute {
+    pub fn fallback_to_cpu(&mut self) -> Result<(), ComputeError> {
+        // Switch to CPU computation
+        // Update computation flags
+        // Log fallback event
+    }
+}
+```
+
+### Performance Monitoring
+```rust
+pub struct ComputeMetrics {
+    pub frame_time: Duration,
+    pub node_count: usize,
+    pub edge_count: usize,
+    pub gpu_utilization: f32,
+}
+```
+
+## Memory Management
+
+### Buffer Updates
+```rust
+impl GPUCompute {
+    pub fn update_buffers(&mut self, nodes: &[Node], edges: &[Edge]) -> Result<(), GPUError> {
+        // Resize buffers if needed
+        // Copy new data
+        // Sync with GPU
+    }
+}
+```
+
+### Resource Cleanup
+```rust
+impl Drop for GPUCompute {
+    fn drop(&mut self) {
+        // Free GPU resources
+        // Clean up buffers
+        // Release device
+    }
+}
+```
+
+## Error Handling
+
+### GPU Errors
+```rust
+pub enum GPUError {
+    DeviceCreation(String),
+    ShaderCompilation(String),
+    BufferAllocation(String),
+    ComputeError(String),
+}
+```
+
+### Recovery Strategies
+```rust
+impl GPUCompute {
+    pub async fn recover_from_error(&mut self, error: GPUError) -> Result<(), GPUError> {
+        // Attempt device reset
+        // Reallocate resources
+        // Fallback if necessary
+    }
+}
+```
+
+## Performance Optimization
+
+### Workgroup Optimization
+```rust
+const OPTIMAL_WORKGROUP_SIZE: u32 = 256;
+const MAX_COMPUTE_INVOCATIONS: u32 = 65535;
+```
+
+### Memory Layout
+```rust
+#[repr(C)]
+pub struct GPUNode {
+    position: [f32; 4],  // Aligned for GPU
+    velocity: [f32; 4],  // Aligned for GPU
+    mass: f32,
+    padding: [f32; 3],   // Maintain 16-byte alignment
+}
+```
\ No newline at end of file
diff --git a/docs/technical/performance.md b/docs/technical/performance.md
new file mode 100644
index 00000000..317f51fe
--- /dev/null
+++ b/docs/technical/performance.md
@@ -0,0 +1,61 @@
+# Performance Optimizations
+
+This document details performance optimizations implemented in the application to improve startup time, reduce memory usage, and enhance UI responsiveness.
+
+## Server-Side Optimizations
+
+### Metadata Caching
+
+#### Individual File Metadata
+- **Description**: Store metadata for each file separately
+- **Implementation**: Files are stored at `/app/data/metadata/files/<filename>.json`
+- **Benefit**: Only files that have changed need to be reprocessed, rather than rebuilding the entire metadata store when any file changes
+- **Validation**: SHA1 hash-based validation ensures we only reprocess files that have actually changed
+
+#### Graph Data Caching
+- **Description**: Cache the entire graph structure (nodes and edges)
+- **Implementation**: Serialized to disk at `/app/data/metadata/graph.json`
+- **Benefit**: Avoid rebuilding the entire graph on startup when metadata hasn't changed
+- **Performance Impact**: Startup is significantly faster for subsequent runs
+
+#### Layout Position Caching
+- **Description**: Preserve the calculated node positions between sessions
+- **Implementation**: Stored at `/app/data/metadata/layout.json`
+- **Benefit**: Preserves user's mental map of the graph between sessions
+- **Details**: Includes x,y,z coordinates for each node indexed by node ID
+
+### Lazy Initialization
+
+- **Description**: Defer expensive operations until they're actually needed
+- **Implementation**: 
+  - Graph is only built when first requested by a client
+  - Layout calculation is no longer performed during server startup
+  - Initial 500ms startup delay was removed
+- **Benefit**: Server starts much faster and is immediately responsive
+- **Details**: Uses caches where available, falls back to full calculation only when necessary
+
+### Temporarily Disabled Services
+
+- **Perplexity Service**: Temporarily commented out as it's not currently in use
+- **Benefits**: Reduces API calls and response times
+
+## Client-Side Considerations
+
+- Clients should be prepared for lazily initialized data
+- First request may take longer as the graph is built
+- Subsequent requests will be faster as they use cached values
+
+## Future Improvements
+
+- **Background Updates**: Implement a background task to periodically check for changes
+- **Incremental Updates**: Support partial graph updates when only a few files change
+- **Differential Response**: Send only changed data to clients
+- **Memory Management**: Add cache size limits and cleanup of old cached data
+
+## Metrics
+
+Initial measurements show these optimizations provide:
+- Reduced server startup time: From ~5s to <1s
+- Reduced memory usage during startup
+- Improved responsiveness for WebSocket communications
+- Consistent graph layouts for better user experience
\ No newline at end of file
diff --git a/docs/technical/protocols/binary-protocol.md b/docs/technical/protocols/binary-protocol.md
new file mode 100644
index 00000000..3dad0b28
--- /dev/null
+++ b/docs/technical/protocols/binary-protocol.md
@@ -0,0 +1,105 @@
+# WebSocket Binary Protocol
+
+This document describes the binary protocol used for efficient real-time updates of node positions and velocities over WebSockets.
+
+## Overview
+
+The binary protocol is designed to minimize bandwidth usage while providing fast updates for node positions and velocities in the 3D visualization. The protocol uses a fixed-size format for each node to simplify parsing and ensure consistency.
+
+## Protocol Format
+
+Each binary message consists of a series of node updates, where each node update is exactly 26 bytes:
+
+| Field    | Type      | Size (bytes) | Description                       |
+|----------|-----------|--------------|-----------------------------------|
+| Node ID  | uint16    | 2            | Unique identifier for the node    |
+| Position | float32[3]| 12           | X, Y, Z coordinates               |
+| Velocity | float32[3]| 12           | X, Y, Z velocity components       |
+
+Total: 26 bytes per node
+
+## Compression
+
+For large updates (more than 1KB), the binary data is compressed using zlib compression. The client automatically detects and decompresses these messages using the pako library.
+
+## Server-Side Only Fields
+
+The server maintains additional data for each node that is not transmitted over the wire:
+
+- `mass` (u8): Node mass used for physics calculations 
+- `flags` (u8): Bit flags for node properties
+- `padding` (u8[2]): Reserved for future use
+
+These fields are used for server-side physics calculations and GPU processing but are not transmitted to clients to optimize bandwidth.
+
+## Flow Sequence
+
+1. Client connects to WebSocket endpoint (`/wss`)
+2. Server sends a text message: `{"type": "connection_established"}`
+3. Client sends a text message: `{"type": "requestInitialData"}`
+4. Server starts sending binary updates at regular intervals (configured by `binary_update_rate` setting)
+5. Server sends a text message: `{"type": "updatesStarted"}`
+6. Client processes binary updates and updates the visualization
+
+## Error Handling
+
+If a binary message has an invalid size (not a multiple of 26 bytes), the client will log an error and discard the message. The server includes additional logging to help diagnose issues with binary message transmission.
+
+## Implementation Notes
+
+- All numeric values use little-endian byte order
+- Position and velocity are represented as:
+  - Server-side: `Vec3Data` objects with x, y, z properties
+  - Client-side: THREE.Vector3 objects
+  - Wire format: float32[3] arrays for efficient binary transmission
+- Binary conversion takes place at the protocol boundary only
+
+## Data Type Handling
+
+### Server-side (Rust)
+
+```rust
+// Vec3Data object representation
+struct Vec3Data {
+    x: f32,
+    y: f32,
+    z: f32,
+}
+```
+
+### Client-side (TypeScript)
+
+```typescript
+// Conversion from binary to Vector3
+function decodeNodeData(view: DataView, offset: number): NodeData {
+    const position = new THREE.Vector3(
+        view.getFloat32(offset, true),
+        view.getFloat32(offset + 4, true),
+        view.getFloat32(offset + 8, true)
+    );
+    // ...
+}
+```
+
+## Debugging
+
+To enable WebSocket debugging:
+
+1. Set `system.debug.enabled = true` in settings.yaml
+2. Set `system.debug.enable_websocket_debug = true` in settings.yaml
+
+This will enable detailed logging of WebSocket messages on both client and server.
+
+## Recent Optimizations
+
+The binary protocol was recently optimized to:
+
+1. **Reduce Message Size**: Changed Node ID from uint32 (4 bytes) to uint16 (2 bytes), reducing each node's size from 28 to 26 bytes (7% reduction)
+
+2. **Simplify Processing**: Removed headers with version numbers, sequence numbers and timestamps to reduce overhead
+
+3. **Improve Type Consistency**: Ensured consistent use of structured vector objects through the entire pipeline:
+   - Server: Vec3Data objects with x, y, z properties
+   - Wire format: Compact binary arrays for transmission
+   - Client: Direct conversion to THREE.Vector3 objects
+   - GPU: Helper functions for array conversion when needed for CUDA
\ No newline at end of file
diff --git a/docs/technical/protocols/websocket-protocol.md b/docs/technical/protocols/websocket-protocol.md
new file mode 100644
index 00000000..bddeeffd
--- /dev/null
+++ b/docs/technical/protocols/websocket-protocol.md
@@ -0,0 +1,61 @@
+# WebSocket Protocol Specification
+
+## Overview
+The WebSocket implementation in LogseqXR provides real-time graph updates using an optimized binary protocol.
+
+## Binary Protocol Format
+
+Each binary message consists of node updates, where each node update is exactly 26 bytes:
+
+| Field    | Type      | Size (bytes) | Description                       |
+|----------|-----------|--------------|-----------------------------------|
+| Node ID  | uint16    | 2            | Unique identifier for the node    |
+| Position | float32[3]| 12           | X, Y, Z coordinates               |
+| Velocity | float32[3]| 12           | X, Y, Z velocity components       |
+
+## Connection Flow
+
+1. Client connects to WebSocket endpoint (`/wss`)
+2. Server sends: `{"type": "connection_established"}`
+3. Client sends: `{"type": "requestInitialData"}`
+4. Server begins binary updates (configured by `binary_update_rate`)
+5. Server sends: `{"type": "updatesStarted"}`
+
+## Optimization Features
+
+- Zlib compression for messages >1KB
+- Fixed-size format for efficient parsing
+- No message headers to minimize overhead
+- Consistent use of THREE.Vector3 throughout
+
+## Diagnostics
+
+### Common Issues
+
+1. Connection Issues
+   - Mixed Content: Ensure WebSocket uses WSS with HTTPS
+   - CORS: Check server configuration for cross-origin
+   - Proxy/Firewall: Verify WebSocket ports are open
+
+2. Binary Protocol Issues
+   - Message Size: Verify 26 bytes per node
+   - Data Integrity: Validate Vector3 data
+
+### Diagnostic Tools
+
+```typescript
+// Run comprehensive diagnostics
+WebSocketDiagnostics.runDiagnostics();
+
+// Test API connectivity
+WebSocketDiagnostics.testApiConnectivity();
+
+// Validate vector data
+WebSocketDiagnostics.validateVectorData();
+```
+
+## Error Handling
+
+- Connection failures trigger automatic reconnection
+- Invalid messages are logged and skipped
+- Server-side validation prevents corrupt data transmission
\ No newline at end of file
diff --git a/docs/technical/protocols/websockets.md b/docs/technical/protocols/websockets.md
new file mode 100644
index 00000000..db69b450
--- /dev/null
+++ b/docs/technical/protocols/websockets.md
@@ -0,0 +1,214 @@
+# WebSocket Connection and Communication in Logseq XR
+## WebSocket Connection Architecture
+
+The application uses a two-component architecture for WebSocket communication:
+
+1. **WebSocketService** (client/websocket/websocketService.ts):
+   - Handles the raw WebSocket connection to the server
+   - Manages binary protocol encoding/decoding
+   - Implements reconnection logic
+   - Uses socket-flow library on the server side
+
+2. **GraphDataManager** (client/state/graphData.ts):
+   - Manages graph data state
+   - Processes node and edge updates
+   - Communicates with WebSocketService for binary updates
+
+### Connection Flow
+
+The proper connection sequence must follow this order:
+
+1. Initialize GraphVisualization in index.ts
+2. Connect WebSocketService to server with websocketService.connect()
+3. Set up binary message handler with websocketService.onBinaryMessage()
+4. **Create an adapter** that connects WebSocketService to GraphDataManager
+5. Register the adapter with GraphDataManager using setWebSocketService()
+6. Enable binary updates in GraphDataManager with graphDataManager.setBinaryUpdatesEnabled(true)
+
+This sequence ensures proper communication between the two components, which use different interfaces.
+
+This sequence ensures that GraphDataManager knows when it can start sending binary updates through WebSocketService.
+
+### Common Issues
+
+#### "WebSocket service not configured" Error
+
+If you see log messages like:
+```
+[GraphDataManager] Binary updates enabled but WebSocket service not yet configured
+[GraphDataManager] WebSocket service still not configured (attempt X/30)
+```
+
+This indicates that GraphDataManager is trying to send binary updates before WebSocketService is properly initialized. The fix is to ensure proper initialization sequence:
+
+1. First connect the WebSocketService
+2. Then enable binary updates in GraphDataManager
+
+Do not try to directly connect these components through their internal interfaces, as they use different communication patterns. Instead, use their public API methods as shown in the connection flow.
+
+### Component Bridging with Adapter Pattern
+
+GraphDataManager and WebSocketService use different interfaces, which can cause errors if not connected properly. The solution is to use an adapter:
+
+```typescript
+// Create an adapter that implements the InternalWebSocketService interface
+const webSocketAdapter = {
+    send: (data: ArrayBuffer) => {
+        websocketService.sendRawBinaryData(data);
+    }
+};
+
+// Register the adapter with GraphDataManager
+graphDataManager.setWebSocketService(webSocketAdapter);
+```
+
+This document describes the WebSocket connection and communication process in the Logseq XR project, covering the client-server interaction, data formats, compression, heartbeats, and configuration.
+
+## 1. Connection Establishment
+
+*   **Client-Side Initiation:** The `WebSocketService` in `client/websocket/websocketService.ts` manages the WebSocket connection. The `connect()` method must be called explicitly to initiate the connection.
+*   **URL Construction:** The `buildWsUrl()` function in `client/core/api.ts` constructs the WebSocket URL:
+    *   **Protocol:** `wss:` for HTTPS, `ws:` for HTTP (determined by `window.location.protocol`).
+    *   **Host:** `window.location.hostname`.
+    *   **Port:** `:4000` in development (non-production), empty (default port) in production.
+    *   **Path:** `/wss`.
+    *   **Final URL:** `${protocol}//${host}${port}/wss`
+*   **Development Proxy:** In development (using `vite`), the `vite.config.ts` file configures a proxy:
+    *   Requests to `/wss` are proxied to `ws://localhost:4000`.
+*   **Docker Environment:**
+    *   The `Dockerfile` exposes port 4000.
+    *   The `docker-compose.yml` file maps container port 4000 to host port 4000.
+    *   `nginx` (configured in `nginx.conf`) listens on port 4000 inside the container.
+    *   The `scripts/launch-docker.sh` script builds and starts the containers, including a readiness check that uses `websocat` to test the WebSocket connection to `ws://localhost:4000/wss`.
+*   **Cloudflared:** When using Cloudflared (`docker-compose.yml`):
+    *   Cloudflared forwards traffic to the `webxr` container's `nginx` instance on port 4000, using the container name (`logseq-xr-webxr`) as the hostname.
+*   **Server-Side Handling:**
+    *   The `socket_flow_handler` function in `src/handlers/socket_flow_handler.rs` handles WebSocket connections (using Actix Web).
+    *   It checks for the `Upgrade` header to verify it's a WebSocket request.
+    *   It creates a `SocketFlowServer` instance for each connection.
+    *   The `ws::start()` function starts the WebSocket actor.
+* **Nginx Proxy:** The `nginx.conf` file configures nginx to proxy websocket connections at `/wss` to the rust backend, which is listening on `127.0.0.1:3001` inside the container.
+
+## 2. Message Handling
+
+*   **Client-Side (`client/websocket/websocketService.ts`):**
+    *   **`onopen`:** Sends a `requestInitialData` message (JSON) to the server.
+    *   **`onmessage`:**
+        *   **Text Messages:** Parses JSON messages. Handles `connection_established`, `loading`, and `updatesStarted`.
+        *   **Binary Messages:**
+            *   Decompresses using `pako.inflate()` (zlib) if necessary.
+            *   Decodes the binary data according to the custom protocol (see "Binary Protocol").
+            *   Calls the `binaryMessageCallback` with the decoded node data.
+    *   **`sendMessage()`:** Sends text messages (JSON).
+    *   **`sendNodeUpdates()`:** Sends binary messages for node updates (limited to 2 nodes per update). Compresses if needed.
+*   **Server-Side (`src/handlers/socket_flow_handler.rs`):**
+    *   **`started`:** Sends a `connection_established` message (JSON) followed by a `loading` message.
+    *   **`handle`:**
+        *   **`Ping`:** Responds with a `Pong` message (JSON).
+        *   **`Text`:**
+            *   Parses JSON.
+            *   Handles `ping` messages (responds with `pong`).
+            *   Handles `requestInitialData`:
+                *   Immediately starts a timer to send binary position updates periodically (interval based on settings, default 30 Hz).
+                *   Sends an `updatesStarted` message (JSON) to signal that updates have begun.
+        *   **`Binary`:**
+            *   Decodes using `binary_protocol::decode_node_data()`.
+            *   Handles `MessageType::PositionVelocityUpdate` (for up to 2 nodes): Updates node positions and velocities in the graph data.
+        *   **`Close`:** Handles client close requests.
+
+## 3. Binary Protocol (`src/utils/binary_protocol.rs`)
+
+*   **`MessageType`:** `PositionVelocityUpdate` (0x01).
+*   **`BinaryNodeData`:**
+    *   `id`: `u16` (2 bytes)
+    *   `position`: `Vec3Data` (12 bytes: x, y, z as `f32` properties)
+    *   `velocity`: `Vec3Data` (12 bytes: x, y, z as `f32` properties)
+    *   Total: 26 bytes per node.
+*   **Encoding:**
+    *   Node Data (stream of nodes without header):
+        *   Node ID (`u16` Little Endian).
+        *   Position (x, y, z as `f32` Little Endian).
+        *   Velocity (x, y, z as `f32` Little Endian).
+*   **Decoding:**
+    *   Validates message size is a multiple of 26 bytes.
+    *   Reads node data for each 26-byte segment.
+* **Byte Order:** Little Endian.
+
+## 4. Data Alignment and Case Handling
+
+*   **Client (TypeScript):** Uses `camelCase` for variables and interfaces.
+*   **Server (Rust):**
+    *   `socket_flow_messages::BinaryNodeData`: Uses Vec3Data struct with x,y,z properties for position and velocity
+    *   `types::vec3::Vec3Data`: Structured vector representation with x,y,z fields
+    *   `models::node::Node`: Uses `camelCase` for fields (due to Serde's `rename_all` attribute)
+    * API calls use `burger-case`.
+*   **Data Transfer:** The binary protocol ensures data alignment between the client and server. The `BinaryNodeData` struct in `socket_flow_messages.rs` mirrors the structure sent over the WebSocket.
+
+## 5. Compression
+
+*   **Client:** Uses `pako` library for zlib compression/decompression.
+    *   Compresses binary messages if they are larger than `COMPRESSION_THRESHOLD` (1024 bytes).
+    *   Attempts to decompress incoming binary messages, falling back to original data if decompression fails.
+*   **Server:** Uses `flate2` crate for zlib compression/decompression.
+    *   `maybe_compress()`: Compresses if enabled in settings and data size exceeds the threshold.
+    *   `maybe_decompress()`: Decompresses if enabled in settings.
+
+## 6. Heartbeat
+
+*   **Server:** Expects `ping` messages from the client. `src/utils/socket_flow_constants.rs` defines:
+    *   `HEARTBEAT_INTERVAL`: 30 seconds.
+    *   `CLIENT_TIMEOUT`: 60 seconds (double the heartbeat interval).
+*   **Client:** The client-side code doesn't have explicit heartbeat sending logic, but the server expects pings, and the `docker-compose.yml` healthcheck sends a ping. The `cloudflared` configuration also sets `TUNNEL_WEBSOCKET_HEARTBEAT_INTERVAL` to 30s.
+* **Nginx:** `nginx.conf` has timeouts configured:
+    * `proxy_read_timeout`: 3600s
+    * `proxy_send_timeout`: 3600s
+    * `proxy_connect_timeout`: 75s
+
+## 7. Throttling/Update Rate
+
+*   **Server:** Sends position updates at a rate determined by the `binary_update_rate` setting (defaulting to 30 Hz), controlled by a timer in `socket_flow_handler.rs`. The constant `POSITION_UPDATE_RATE` in `socket_flow_constants.rs` is 5 Hz, but the actual update rate is controlled by the settings.
+*   **Client:**  The client receives updates as they are sent by the server. There's no explicit throttling on the client side, other than limiting user-initiated updates to 2 nodes per message.
+*   **Initial Delay:** To ensure GPU computations have time to run, the server now has a 500ms delay before starting to accept client connections.
+
+## 8. Order of Operations
+
+1.  Client initiates a WebSocket connection to `/wss`.
+2.  In development, Vite proxies the connection to `ws://localhost:4000`.
+3.  In Docker, the connection goes to port 4000 on the host, which is mapped to port 4000 of the `webxr` container.
+4.  Before accepting connections, the server has a brief delay (500ms) to allow the GPU to compute initial node positions.
+5.  `nginx` (inside the container) receives the connection on port 4000.
+6.  `nginx` proxies the WebSocket connection to the Rust backend on `127.0.0.1:3001`.
+7.  The `socket_flow_handler` in the Rust backend handles the connection.
+8.  The server sends a `connection_established` message (JSON).
+9.  The server sends a `loading` message to signal that the client should display a loading indicator.
+10. The client displays a loading indicator and sends a `requestInitialData` message (JSON).
+11. The server starts sending binary position updates at the configured interval.
+12. The client creates an adapter to connect WebSocketService with GraphDataManager.
+13. The client registers the adapter using GraphDataManager.setWebSocketService().
+14. The server sends an `updatesStarted` message to signal that updates have begun.
+13. The client hides the loading indicator upon receiving the `updatesStarted` message.
+14. The client receives and processes the binary data, updating the visualization.
+15. The server and client exchange `ping` and `pong` messages for connection health (although the client-side pinging is primarily handled by the `docker-compose` healthcheck and potentially Cloudflared).
+16. User interactions on the client can trigger sending binary node updates (limited to 2 nodes) to the server.
+
+## 9. Loading State and User Feedback
+
+*   **Server-Side Loading Message:** After the connection is established, the server sends a `loading` message to indicate data is being prepared.
+*   **Client-Side Loading Indicator:** Upon receiving the `loading` message, the client displays a loading indicator (in `VisualizationController.ts`).
+*   **Updates Started Signal:** Once the server is ready to send position updates, it sends an `updatesStarted` message.
+*   **Loading Complete:** Upon receiving the `updatesStarted` message, the client hides the loading indicator and begins displaying the graph.
+*   This provides visual feedback during the initialization process and ensures users don't see poorly-distributed node layouts.
+
+## 10. Recent Protocol Optimizations
+
+*   **Size Reduction:** 
+    * Node ID changed from u32 (4 bytes) to u16 (2 bytes)
+    * Node data size reduced from 28 to 26 bytes per node (~7% reduction)
+
+*   **Format Simplification:**
+    * Removed message headers (no version number, sequence number, timestamp)
+    * Binary data is now a simple array of node updates
+
+*   **Type Consistency:**
+    * Consistent use of structured Vec3Data/THREE.Vector3 objects throughout the pipeline
+    * Helper functions handle GPU compatibility where array formats are needed
\ No newline at end of file
diff --git a/handlers/perplexity_handler.rs b/handlers/perplexity_handler.rs
deleted file mode 100755
index 0e4ffcf6..00000000
--- a/handlers/perplexity_handler.rs
+++ /dev/null
@@ -1,49 +0,0 @@
-use crate::AppState;
-use actix_web::{post, web, HttpResponse, Responder};
-use serde::{Deserialize, Serialize};
-use serde_json::json;
-use log::{error, info};
-
-#[derive(Debug, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct PerplexityRequest {
-    pub query: String,
-    pub conversation_id: Option<String>,
-}
-
-#[derive(Debug, Serialize)]
-#[serde(rename_all = "camelCase")]
-pub struct PerplexityResponse {
-    pub answer: String,
-    pub conversation_id: String,
-}
-
-#[post("")]
-pub async fn handle_perplexity(
-    state: web::Data<AppState>,
-    request: web::Json<PerplexityRequest>,
-) -> impl Responder {
-    info!("Received perplexity request: {:?}", request);
-
-    let perplexity_service = match &state.perplexity_service {
-        Some(service) => service,
-        None => return HttpResponse::ServiceUnavailable().json(json!({
-            "error": "Perplexity service is not available"
-        }))
-    };
-
-    let conversation_id = state.ragflow_conversation_id.clone();
-    match perplexity_service.query(&request.query, &conversation_id).await {
-        Ok(answer) => {
-            let response = PerplexityResponse {
-                answer,
-                conversation_id,
-            };
-            HttpResponse::Ok().json(response)
-        }
-        Err(e) => {
-            error!("Error processing perplexity request: {}", e);
-            HttpResponse::InternalServerError().json(format!("Error: {}", e))
-        }
-    }
-}
diff --git a/models/graph.rs b/models/graph.rs
deleted file mode 100755
index e393442e..00000000
--- a/models/graph.rs
+++ /dev/null
@@ -1,32 +0,0 @@
-use crate::utils::socket_flow_messages::Node;
-use super::edge::Edge;
-use super::metadata::MetadataStore;
-use serde::{Deserialize, Serialize};
-use std::collections::HashMap;
-
-/// Represents the graph data structure containing nodes, edges, and metadata.
-/// All fields use camelCase serialization for client compatibility.
-#[derive(Default, Serialize, Deserialize, Clone, Debug)]
-#[serde(rename_all = "camelCase")]
-pub struct GraphData {
-    /// List of nodes in the graph.
-    pub nodes: Vec<Node>,
-    /// List of edges connecting the nodes.
-    pub edges: Vec<Edge>,
-    /// Metadata associated with the graph, using camelCase keys.
-    pub metadata: MetadataStore,
-    /// Mapping from numeric ID to metadata ID (filename) for lookup
-    #[serde(skip)]
-    pub id_to_metadata: HashMap<String, String>,
-}
-
-impl GraphData {
-    pub fn new() -> Self {
-        Self {
-            nodes: Vec::new(),
-            edges: Vec::new(),
-            metadata: MetadataStore::new(),
-            id_to_metadata: HashMap::new(),
-        }
-    }
-}
diff --git a/nginx.conf b/nginx.conf
new file mode 100755
index 00000000..9b1b1860
--- /dev/null
+++ b/nginx.conf
@@ -0,0 +1,157 @@
+pid /var/run/nginx/nginx.pid;
+error_log /var/log/nginx/error.log debug;
+
+events {
+    worker_connections 1024;
+    multi_accept on;
+    use epoll;
+}
+
+http {
+    # Basic settings
+    include /etc/nginx/mime.types;
+    default_type application/octet-stream;
+    charset utf-8;
+
+    # Override TypeScript MIME type (overriding video/mp2t from mime.types)
+    types {
+        application/typescript ts;
+    }
+
+    # Logging
+    log_format debug_format '$remote_addr - $remote_user [$time_local] '
+                          '"$request" $status $body_bytes_sent '
+                          '"$http_referer" "$http_user_agent" '
+                          'rt=$request_time uct="$upstream_connect_time" uht="$upstream_header_time" urt="$upstream_response_time"'
+                          ' ws_status="$upstream_http_upgrade"';  # Added WebSocket status logging
+
+    access_log /var/log/nginx/access.log debug_format;
+
+    # Optimization
+    sendfile on;
+    tcp_nopush on;
+    tcp_nodelay on;
+    keepalive_timeout 120;  # Increased to match cloudflared keepAliveTimeout
+    keepalive_requests 100;
+
+    # Gzip settings
+    gzip on;
+    gzip_disable "msie6";
+    gzip_vary on;
+    gzip_proxied any;
+    gzip_comp_level 6;
+    gzip_buffers 16 8k;
+    gzip_http_version 1.1;
+    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
+
+    # WebSocket configuration
+    map $http_upgrade $connection_upgrade {
+        default upgrade;
+        ''      close;
+    }
+
+    # Upstream backend definition for the Rust server
+    upstream backend {
+        server 127.0.0.1:3001;  # Use localhost since both services are in same container
+        keepalive 32;  # Keep connections alive
+    }
+
+    # Main server configuration
+    server {
+        listen 4000 default_server;  # Listen on port 4000 for external connections
+        server_name _;  # Accept any server name
+        root /app/data/public/dist;  # Set root to built files directory
+
+        # Security headers
+        add_header X-Content-Type-Options nosniff;
+        add_header X-Frame-Options SAMEORIGIN;
+        add_header X-XSS-Protection "1; mode=block";
+        add_header Referrer-Policy "same-origin" always;
+        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline' 'unsafe-eval'; connect-src 'self' ws: wss: http: https: *.visionflow.info; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://getalby.com; frame-src 'self' https://getalby.com" always;
+        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
+
+        # WebSocket endpoint
+        location /wss {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+            
+            # Pass through Cloudflare headers
+            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
+            proxy_set_header CF-Ray $http_cf_ray;
+            proxy_set_header CF-Visitor $http_cf_visitor;
+            
+            # Standard proxy headers
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
+            
+            # WebSocket timeouts
+            proxy_read_timeout 600m;  # Increased from 3600s to 600m (10 hours) to match websocketIdleTimeout
+            proxy_send_timeout 3600s;
+            proxy_connect_timeout 75s;
+            proxy_buffering off;
+            proxy_cache off;
+            
+            # Debug logging
+            access_log /var/log/nginx/websocket.log debug_format;
+            error_log /var/log/nginx/websocket-error.log debug;
+        }
+
+        # API endpoints
+        location /api {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $scheme;
+            
+            # API specific settings
+            proxy_read_timeout 120s;  # Increased for larger graph data
+            proxy_send_timeout 120s;  # Increased for larger graph data
+            proxy_connect_timeout 60s;
+            proxy_buffering on;       # Enable buffering for API responses
+            proxy_buffer_size 256k;   # Increased for larger responses
+            proxy_buffers 8 256k;     # Increased number of buffers
+            proxy_busy_buffers_size 512k;  # Increased for larger responses
+            proxy_max_temp_file_size 2048m;  # Allow larger temporary files
+            add_header Cache-Control "no-store" always;  # Prevent caching of dynamic data
+        }
+
+        # Static files
+        location / {
+            try_files $uri $uri/ /index.html =404;
+            expires 1h;
+            add_header Cache-Control "public, no-transform";
+            error_page 404 = @backend;  # Fallback to backend if file not found
+        }
+
+        # Static files with proper MIME types
+        location /assets/ {
+            expires 7d;
+            add_header Cache-Control "public, no-transform" always;
+            try_files $uri =404;
+            access_log off;
+        }
+
+        # Fallback location for static files
+        location @backend {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $scheme;
+        }
+
+        # Error pages
+        error_page 404 /404.html;
+        error_page 500 502 503 504 /50x.html;
+        location = /50x.html {
+            root /usr/share/nginx/html;
+        }
+    }
+}
diff --git a/package.json b/package.json
new file mode 100755
index 00000000..86044c77
--- /dev/null
+++ b/package.json
@@ -0,0 +1,44 @@
+{
+  "name": "logseq-spring-thing",
+  "private": true,
+  "version": "1.0.0",
+  "type": "module",
+  "scripts": {
+    "dev": "vite",
+    "build": "tsc && vite build",
+    "build:skip-ts": "vite build",
+    "build:prod": "tsc && DEPLOY_ENV=prod vite build --mode production",
+    "build:dev": "DEPLOY_ENV=dev vite build",
+    "preview": "vite preview",
+    "type-check": "tsc --noEmit",
+    "lint": "eslint . --ext .js,.ts --fix --ignore-path .gitignore",
+    "format": "prettier --write client/"
+  },
+  "dependencies": {
+    "@mui/material": "^5.16.14",
+    "@types/pako": "^2.0.3",
+    "@types/webxr": "^0.5.21",
+    "alby-js-sdk": "^2.3.0",
+    "pako": "^2.1.0",
+    "three": "0.174.0"
+  },
+  "devDependencies": {
+    "@types/node": "^22.13.9",
+    "@types/three": "0.174.0",
+    "@typescript-eslint/eslint-plugin": "^8.26.0",
+    "@typescript-eslint/parser": "^8.26.0",
+    "eslint": "^8.57.1",
+    "prettier": "^3.5.3",
+    "terser": "^5.39.0",
+    "typescript": "~5.4.5",
+    "vite": "^5.4.14"
+  },
+  "engines": {
+    "node": ">=18.0.0"
+  },
+  "pnpm": {
+    "overrides": {
+      "vite": "^5.4.12"
+    }
+  }
+}
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
new file mode 100644
index 00000000..101f7951
--- /dev/null
+++ b/pnpm-lock.yaml
@@ -0,0 +1,2093 @@
+lockfileVersion: '9.0'
+
+settings:
+  autoInstallPeers: true
+  excludeLinksFromLockfile: false
+
+overrides:
+  vite: ^5.4.12
+
+importers:
+
+  .:
+    dependencies:
+      '@mui/material':
+        specifier: ^5.16.14
+        version: 5.16.14(@types/react@19.0.10)(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
+      '@types/pako':
+        specifier: ^2.0.3
+        version: 2.0.3
+      '@types/webxr':
+        specifier: ^0.5.21
+        version: 0.5.21
+      alby-js-sdk:
+        specifier: ^2.3.0
+        version: 2.3.0
+      pako:
+        specifier: ^2.1.0
+        version: 2.1.0
+      three:
+        specifier: 0.174.0
+        version: 0.174.0
+    devDependencies:
+      '@types/node':
+        specifier: ^22.13.9
+        version: 22.13.9
+      '@types/three':
+        specifier: 0.174.0
+        version: 0.174.0
+      '@typescript-eslint/eslint-plugin':
+        specifier: ^8.26.0
+        version: 8.26.0(@typescript-eslint/parser@8.26.0(eslint@8.57.1)(typescript@5.4.5))(eslint@8.57.1)(typescript@5.4.5)
+      '@typescript-eslint/parser':
+        specifier: ^8.26.0
+        version: 8.26.0(eslint@8.57.1)(typescript@5.4.5)
+      eslint:
+        specifier: ^8.57.1
+        version: 8.57.1
+      prettier:
+        specifier: ^3.5.3
+        version: 3.5.3
+      terser:
+        specifier: ^5.39.0
+        version: 5.39.0
+      typescript:
+        specifier: ~5.4.5
+        version: 5.4.5
+      vite:
+        specifier: ^5.4.12
+        version: 5.4.14(@types/node@22.13.9)(terser@5.39.0)
+
+packages:
+
+  '@babel/runtime@7.26.9':
+    resolution: {integrity: sha512-aA63XwOkcl4xxQa3HjPMqOP6LiK0ZDv3mUPYEFXkpHbaFjtGggE1A61FjFzJnB+p7/oy2gA8E+rcBNl/zC1tMg==}
+    engines: {node: '>=6.9.0'}
+
+  '@emotion/cache@11.14.0':
+    resolution: {integrity: sha512-L/B1lc/TViYk4DcpGxtAVbx0ZyiKM5ktoIyafGkH6zg/tj+mA+NE//aPYKG0k8kCHSHVJrpLpcAlOBEXQ3SavA==}
+
+  '@emotion/memoize@0.9.0':
+    resolution: {integrity: sha512-30FAj7/EoJ5mwVPOWhAyCX+FPfMDrVecJAM+Iw9NRoSl4BBAQeqj4cApHHUXOVvIPgLVDsCFoz/hGD+5QQD1GQ==}
+
+  '@emotion/sheet@1.4.0':
+    resolution: {integrity: sha512-fTBW9/8r2w3dXWYM4HCB1Rdp8NLibOw2+XELH5m5+AkWiL/KqYX6dc0kKYlaYyKjrQ6ds33MCdMPEwgs2z1rqg==}
+
+  '@emotion/utils@1.4.2':
+    resolution: {integrity: sha512-3vLclRofFziIa3J2wDh9jjbkUz9qk5Vi3IZ/FSTKViB0k+ef0fPV7dYrUIugbgupYDx7v9ud/SjrtEP8Y4xLoA==}
+
+  '@emotion/weak-memoize@0.4.0':
+    resolution: {integrity: sha512-snKqtPW01tN0ui7yu9rGv69aJXr/a/Ywvl11sUjNtEcRc+ng/mQriFL0wLXMef74iHa/EkftbDzU9F8iFbH+zg==}
+
+  '@esbuild/aix-ppc64@0.21.5':
+    resolution: {integrity: sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==}
+    engines: {node: '>=12'}
+    cpu: [ppc64]
+    os: [aix]
+
+  '@esbuild/android-arm64@0.21.5':
+    resolution: {integrity: sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==}
+    engines: {node: '>=12'}
+    cpu: [arm64]
+    os: [android]
+
+  '@esbuild/android-arm@0.21.5':
+    resolution: {integrity: sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==}
+    engines: {node: '>=12'}
+    cpu: [arm]
+    os: [android]
+
+  '@esbuild/android-x64@0.21.5':
+    resolution: {integrity: sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [android]
+
+  '@esbuild/darwin-arm64@0.21.5':
+    resolution: {integrity: sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==}
+    engines: {node: '>=12'}
+    cpu: [arm64]
+    os: [darwin]
+
+  '@esbuild/darwin-x64@0.21.5':
+    resolution: {integrity: sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [darwin]
+
+  '@esbuild/freebsd-arm64@0.21.5':
+    resolution: {integrity: sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==}
+    engines: {node: '>=12'}
+    cpu: [arm64]
+    os: [freebsd]
+
+  '@esbuild/freebsd-x64@0.21.5':
+    resolution: {integrity: sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [freebsd]
+
+  '@esbuild/linux-arm64@0.21.5':
+    resolution: {integrity: sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==}
+    engines: {node: '>=12'}
+    cpu: [arm64]
+    os: [linux]
+
+  '@esbuild/linux-arm@0.21.5':
+    resolution: {integrity: sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==}
+    engines: {node: '>=12'}
+    cpu: [arm]
+    os: [linux]
+
+  '@esbuild/linux-ia32@0.21.5':
+    resolution: {integrity: sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==}
+    engines: {node: '>=12'}
+    cpu: [ia32]
+    os: [linux]
+
+  '@esbuild/linux-loong64@0.21.5':
+    resolution: {integrity: sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==}
+    engines: {node: '>=12'}
+    cpu: [loong64]
+    os: [linux]
+
+  '@esbuild/linux-mips64el@0.21.5':
+    resolution: {integrity: sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==}
+    engines: {node: '>=12'}
+    cpu: [mips64el]
+    os: [linux]
+
+  '@esbuild/linux-ppc64@0.21.5':
+    resolution: {integrity: sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==}
+    engines: {node: '>=12'}
+    cpu: [ppc64]
+    os: [linux]
+
+  '@esbuild/linux-riscv64@0.21.5':
+    resolution: {integrity: sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==}
+    engines: {node: '>=12'}
+    cpu: [riscv64]
+    os: [linux]
+
+  '@esbuild/linux-s390x@0.21.5':
+    resolution: {integrity: sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==}
+    engines: {node: '>=12'}
+    cpu: [s390x]
+    os: [linux]
+
+  '@esbuild/linux-x64@0.21.5':
+    resolution: {integrity: sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [linux]
+
+  '@esbuild/netbsd-x64@0.21.5':
+    resolution: {integrity: sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [netbsd]
+
+  '@esbuild/openbsd-x64@0.21.5':
+    resolution: {integrity: sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [openbsd]
+
+  '@esbuild/sunos-x64@0.21.5':
+    resolution: {integrity: sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [sunos]
+
+  '@esbuild/win32-arm64@0.21.5':
+    resolution: {integrity: sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==}
+    engines: {node: '>=12'}
+    cpu: [arm64]
+    os: [win32]
+
+  '@esbuild/win32-ia32@0.21.5':
+    resolution: {integrity: sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==}
+    engines: {node: '>=12'}
+    cpu: [ia32]
+    os: [win32]
+
+  '@esbuild/win32-x64@0.21.5':
+    resolution: {integrity: sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==}
+    engines: {node: '>=12'}
+    cpu: [x64]
+    os: [win32]
+
+  '@eslint-community/eslint-utils@4.4.1':
+    resolution: {integrity: sha512-s3O3waFUrMV8P/XaF/+ZTp1X9XBZW1a4B97ZnjQF2KYWaFD2A8KyFBsrsfSjEmjn3RGWAIuvlneuZm3CUK3jbA==}
+    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
+    peerDependencies:
+      eslint: ^6.0.0 || ^7.0.0 || >=8.0.0
+
+  '@eslint-community/regexpp@4.12.1':
+    resolution: {integrity: sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==}
+    engines: {node: ^12.0.0 || ^14.0.0 || >=16.0.0}
+
+  '@eslint/eslintrc@2.1.4':
+    resolution: {integrity: sha512-269Z39MS6wVJtsoUl10L60WdkhJVdPG24Q4eZTH3nnF6lpvSShEK3wQjDX9JRWAUPvPh7COouPpU9IrqaZFvtQ==}
+    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
+
+  '@eslint/js@8.57.1':
+    resolution: {integrity: sha512-d9zaMRSTIKDLhctzH12MtXvJKSSUhaHcjV+2Z+GK+EEY7XKpP5yR4x+N3TAcHTcu963nIr+TMcCb4DBCYX1z6Q==}
+    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
+
+  '@humanwhocodes/config-array@0.13.0':
+    resolution: {integrity: sha512-DZLEEqFWQFiyK6h5YIeynKx7JlvCYWL0cImfSRXZ9l4Sg2efkFGTuFf6vzXjK1cq6IYkU+Eg/JizXw+TD2vRNw==}
+    engines: {node: '>=10.10.0'}
+    deprecated: Use @eslint/config-array instead
+
+  '@humanwhocodes/module-importer@1.0.1':
+    resolution: {integrity: sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==}
+    engines: {node: '>=12.22'}
+
+  '@humanwhocodes/object-schema@2.0.3':
+    resolution: {integrity: sha512-93zYdMES/c1D69yZiKDBj0V24vqNzB/koF26KPaagAfd3P/4gUlh3Dys5ogAK+Exi9QyzlD8x/08Zt7wIKcDcA==}
+    deprecated: Use @eslint/object-schema instead
+
+  '@jridgewell/gen-mapping@0.3.8':
+    resolution: {integrity: sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==}
+    engines: {node: '>=6.0.0'}
+
+  '@jridgewell/resolve-uri@3.1.2':
+    resolution: {integrity: sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==}
+    engines: {node: '>=6.0.0'}
+
+  '@jridgewell/set-array@1.2.1':
+    resolution: {integrity: sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==}
+    engines: {node: '>=6.0.0'}
+
+  '@jridgewell/source-map@0.3.6':
+    resolution: {integrity: sha512-1ZJTZebgqllO79ue2bm3rIGud/bOe0pP5BjSRCRxxYkEZS8STV7zN84UBbiYu7jy+eCKSnVIUgoWWE/tt+shMQ==}
+
+  '@jridgewell/sourcemap-codec@1.5.0':
+    resolution: {integrity: sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==}
+
+  '@jridgewell/trace-mapping@0.3.25':
+    resolution: {integrity: sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==}
+
+  '@mui/core-downloads-tracker@5.16.14':
+    resolution: {integrity: sha512-sbjXW+BBSvmzn61XyTMun899E7nGPTXwqD9drm1jBUAvWEhJpPFIRxwQQiATWZnd9rvdxtnhhdsDxEGWI0jxqA==}
+
+  '@mui/material@5.16.14':
+    resolution: {integrity: sha512-eSXQVCMKU2xc7EcTxe/X/rC9QsV2jUe8eLM3MUCPYbo6V52eCE436akRIvELq/AqZpxx2bwkq7HC0cRhLB+yaw==}
+    engines: {node: '>=12.0.0'}
+    peerDependencies:
+      '@emotion/react': ^11.5.0
+      '@emotion/styled': ^11.3.0
+      '@types/react': ^17.0.0 || ^18.0.0 || ^19.0.0
+      react: ^17.0.0 || ^18.0.0 || ^19.0.0
+      react-dom: ^17.0.0 || ^18.0.0 || ^19.0.0
+    peerDependenciesMeta:
+      '@emotion/react':
+        optional: true
+      '@emotion/styled':
+        optional: true
+      '@types/react':
+        optional: true
+
+  '@mui/private-theming@5.16.14':
+    resolution: {integrity: sha512-12t7NKzvYi819IO5IapW2BcR33wP/KAVrU8d7gLhGHoAmhDxyXlRoKiRij3TOD8+uzk0B6R9wHUNKi4baJcRNg==}
+    engines: {node: '>=12.0.0'}
+    peerDependencies:
+      '@types/react': ^17.0.0 || ^18.0.0 || ^19.0.0
+      react: ^17.0.0 || ^18.0.0 || ^19.0.0
+    peerDependenciesMeta:
+      '@types/react':
+        optional: true
+
+  '@mui/styled-engine@5.16.14':
+    resolution: {integrity: sha512-UAiMPZABZ7p8mUW4akDV6O7N3+4DatStpXMZwPlt+H/dA0lt67qawN021MNND+4QTpjaiMYxbhKZeQcyWCbuKw==}
+    engines: {node: '>=12.0.0'}
+    peerDependencies:
+      '@emotion/react': ^11.4.1
+      '@emotion/styled': ^11.3.0
+      react: ^17.0.0 || ^18.0.0 || ^19.0.0
+    peerDependenciesMeta:
+      '@emotion/react':
+        optional: true
+      '@emotion/styled':
+        optional: true
+
+  '@mui/system@5.16.14':
+    resolution: {integrity: sha512-KBxMwCb8mSIABnKvoGbvM33XHyT+sN0BzEBG+rsSc0lLQGzs7127KWkCA6/H8h6LZ00XpBEME5MAj8mZLiQ1tw==}
+    engines: {node: '>=12.0.0'}
+    peerDependencies:
+      '@emotion/react': ^11.5.0
+      '@emotion/styled': ^11.3.0
+      '@types/react': ^17.0.0 || ^18.0.0 || ^19.0.0
+      react: ^17.0.0 || ^18.0.0 || ^19.0.0
+    peerDependenciesMeta:
+      '@emotion/react':
+        optional: true
+      '@emotion/styled':
+        optional: true
+      '@types/react':
+        optional: true
+
+  '@mui/types@7.2.21':
+    resolution: {integrity: sha512-6HstngiUxNqLU+/DPqlUJDIPbzUBxIVHb1MmXP0eTWDIROiCR2viugXpEif0PPe2mLqqakPzzRClWAnK+8UJww==}
+    peerDependencies:
+      '@types/react': ^17.0.0 || ^18.0.0 || ^19.0.0
+    peerDependenciesMeta:
+      '@types/react':
+        optional: true
+
+  '@mui/utils@5.16.14':
+    resolution: {integrity: sha512-wn1QZkRzSmeXD1IguBVvJJHV3s6rxJrfb6YuC9Kk6Noh9f8Fb54nUs5JRkKm+BOerRhj5fLg05Dhx/H3Ofb8Mg==}
+    engines: {node: '>=12.0.0'}
+    peerDependencies:
+      '@types/react': ^17.0.0 || ^18.0.0 || ^19.0.0
+      react: ^17.0.0 || ^18.0.0 || ^19.0.0
+    peerDependenciesMeta:
+      '@types/react':
+        optional: true
+
+  '@noble/curves@1.1.0':
+    resolution: {integrity: sha512-091oBExgENk/kGj3AZmtBDMpxQPDtxQABR2B9lb1JbVTs6ytdzZNwvhxQ4MWasRNEzlbEH8jCWFCwhF/Obj5AA==}
+
+  '@noble/hashes@1.3.1':
+    resolution: {integrity: sha512-EbqwksQwz9xDRGfDST86whPBgM65E0OH/pCgqW0GBVzO22bNE+NuIbeTb714+IfSjU3aRk47EUvXIb5bTsenKA==}
+    engines: {node: '>= 16'}
+
+  '@nodelib/fs.scandir@2.1.5':
+    resolution: {integrity: sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==}
+    engines: {node: '>= 8'}
+
+  '@nodelib/fs.stat@2.0.5':
+    resolution: {integrity: sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==}
+    engines: {node: '>= 8'}
+
+  '@nodelib/fs.walk@1.2.8':
+    resolution: {integrity: sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==}
+    engines: {node: '>= 8'}
+
+  '@popperjs/core@2.11.8':
+    resolution: {integrity: sha512-P1st0aksCrn9sGZhp8GMYwBnQsbvAWsZAX44oXNNvLHGqAOcoVxmjZiohstwQ7SqKnbR47akdNi+uleWD8+g6A==}
+
+  '@rollup/rollup-android-arm-eabi@4.34.9':
+    resolution: {integrity: sha512-qZdlImWXur0CFakn2BJ2znJOdqYZKiedEPEVNTBrpfPjc/YuTGcaYZcdmNFTkUj3DU0ZM/AElcM8Ybww3xVLzA==}
+    cpu: [arm]
+    os: [android]
+
+  '@rollup/rollup-android-arm64@4.34.9':
+    resolution: {integrity: sha512-4KW7P53h6HtJf5Y608T1ISKvNIYLWRKMvfnG0c44M6In4DQVU58HZFEVhWINDZKp7FZps98G3gxwC1sb0wXUUg==}
+    cpu: [arm64]
+    os: [android]
+
+  '@rollup/rollup-darwin-arm64@4.34.9':
+    resolution: {integrity: sha512-0CY3/K54slrzLDjOA7TOjN1NuLKERBgk9nY5V34mhmuu673YNb+7ghaDUs6N0ujXR7fz5XaS5Aa6d2TNxZd0OQ==}
+    cpu: [arm64]
+    os: [darwin]
+
+  '@rollup/rollup-darwin-x64@4.34.9':
+    resolution: {integrity: sha512-eOojSEAi/acnsJVYRxnMkPFqcxSMFfrw7r2iD9Q32SGkb/Q9FpUY1UlAu1DH9T7j++gZ0lHjnm4OyH2vCI7l7Q==}
+    cpu: [x64]
+    os: [darwin]
+
+  '@rollup/rollup-freebsd-arm64@4.34.9':
+    resolution: {integrity: sha512-2lzjQPJbN5UnHm7bHIUKFMulGTQwdvOkouJDpPysJS+QFBGDJqcfh+CxxtG23Ik/9tEvnebQiylYoazFMAgrYw==}
+    cpu: [arm64]
+    os: [freebsd]
+
+  '@rollup/rollup-freebsd-x64@4.34.9':
+    resolution: {integrity: sha512-SLl0hi2Ah2H7xQYd6Qaiu01kFPzQ+hqvdYSoOtHYg/zCIFs6t8sV95kaoqjzjFwuYQLtOI0RZre/Ke0nPaQV+g==}
+    cpu: [x64]
+    os: [freebsd]
+
+  '@rollup/rollup-linux-arm-gnueabihf@4.34.9':
+    resolution: {integrity: sha512-88I+D3TeKItrw+Y/2ud4Tw0+3CxQ2kLgu3QvrogZ0OfkmX/DEppehus7L3TS2Q4lpB+hYyxhkQiYPJ6Mf5/dPg==}
+    cpu: [arm]
+    os: [linux]
+
+  '@rollup/rollup-linux-arm-musleabihf@4.34.9':
+    resolution: {integrity: sha512-3qyfWljSFHi9zH0KgtEPG4cBXHDFhwD8kwg6xLfHQ0IWuH9crp005GfoUUh/6w9/FWGBwEHg3lxK1iHRN1MFlA==}
+    cpu: [arm]
+    os: [linux]
+
+  '@rollup/rollup-linux-arm64-gnu@4.34.9':
+    resolution: {integrity: sha512-6TZjPHjKZUQKmVKMUowF3ewHxctrRR09eYyvT5eFv8w/fXarEra83A2mHTVJLA5xU91aCNOUnM+DWFMSbQ0Nxw==}
+    cpu: [arm64]
+    os: [linux]
+
+  '@rollup/rollup-linux-arm64-musl@4.34.9':
+    resolution: {integrity: sha512-LD2fytxZJZ6xzOKnMbIpgzFOuIKlxVOpiMAXawsAZ2mHBPEYOnLRK5TTEsID6z4eM23DuO88X0Tq1mErHMVq0A==}
+    cpu: [arm64]
+    os: [linux]
+
+  '@rollup/rollup-linux-loongarch64-gnu@4.34.9':
+    resolution: {integrity: sha512-dRAgTfDsn0TE0HI6cmo13hemKpVHOEyeciGtvlBTkpx/F65kTvShtY/EVyZEIfxFkV5JJTuQ9tP5HGBS0hfxIg==}
+    cpu: [loong64]
+    os: [linux]
+
+  '@rollup/rollup-linux-powerpc64le-gnu@4.34.9':
+    resolution: {integrity: sha512-PHcNOAEhkoMSQtMf+rJofwisZqaU8iQ8EaSps58f5HYll9EAY5BSErCZ8qBDMVbq88h4UxaNPlbrKqfWP8RfJA==}
+    cpu: [ppc64]
+    os: [linux]
+
+  '@rollup/rollup-linux-riscv64-gnu@4.34.9':
+    resolution: {integrity: sha512-Z2i0Uy5G96KBYKjeQFKbbsB54xFOL5/y1P5wNBsbXB8yE+At3oh0DVMjQVzCJRJSfReiB2tX8T6HUFZ2k8iaKg==}
+    cpu: [riscv64]
+    os: [linux]
+
+  '@rollup/rollup-linux-s390x-gnu@4.34.9':
+    resolution: {integrity: sha512-U+5SwTMoeYXoDzJX5dhDTxRltSrIax8KWwfaaYcynuJw8mT33W7oOgz0a+AaXtGuvhzTr2tVKh5UO8GVANTxyQ==}
+    cpu: [s390x]
+    os: [linux]
+
+  '@rollup/rollup-linux-x64-gnu@4.34.9':
+    resolution: {integrity: sha512-FwBHNSOjUTQLP4MG7y6rR6qbGw4MFeQnIBrMe161QGaQoBQLqSUEKlHIiVgF3g/mb3lxlxzJOpIBhaP+C+KP2A==}
+    cpu: [x64]
+    os: [linux]
+
+  '@rollup/rollup-linux-x64-musl@4.34.9':
+    resolution: {integrity: sha512-cYRpV4650z2I3/s6+5/LONkjIz8MBeqrk+vPXV10ORBnshpn8S32bPqQ2Utv39jCiDcO2eJTuSlPXpnvmaIgRA==}
+    cpu: [x64]
+    os: [linux]
+
+  '@rollup/rollup-win32-arm64-msvc@4.34.9':
+    resolution: {integrity: sha512-z4mQK9dAN6byRA/vsSgQiPeuO63wdiDxZ9yg9iyX2QTzKuQM7T4xlBoeUP/J8uiFkqxkcWndWi+W7bXdPbt27Q==}
+    cpu: [arm64]
+    os: [win32]
+
+  '@rollup/rollup-win32-ia32-msvc@4.34.9':
+    resolution: {integrity: sha512-KB48mPtaoHy1AwDNkAJfHXvHp24H0ryZog28spEs0V48l3H1fr4i37tiyHsgKZJnCmvxsbATdZGBpbmxTE3a9w==}
+    cpu: [ia32]
+    os: [win32]
+
+  '@rollup/rollup-win32-x64-msvc@4.34.9':
+    resolution: {integrity: sha512-AyleYRPU7+rgkMWbEh71fQlrzRfeP6SyMnRf9XX4fCdDPAJumdSBqYEcWPMzVQ4ScAl7E4oFfK0GUVn77xSwbw==}
+    cpu: [x64]
+    os: [win32]
+
+  '@scure/base@1.1.1':
+    resolution: {integrity: sha512-ZxOhsSyxYwLJj3pLZCefNitxsj093tb2vq90mp2txoYeBqbcjDjqFhyM8eUjq/uFm6zJ+mUuqxlS2FkuSY1MTA==}
+
+  '@scure/bip32@1.3.1':
+    resolution: {integrity: sha512-osvveYtyzdEVbt3OfwwXFr4P2iVBL5u1Q3q4ONBfDY/UpOuXmOlbgwc1xECEboY8wIays8Yt6onaWMUdUbfl0A==}
+
+  '@scure/bip39@1.2.1':
+    resolution: {integrity: sha512-Z3/Fsz1yr904dduJD0NpiyRHhRYHdcnyh73FZWiV+/qhWi83wNJ3NWolYqCEN+ZWsUz2TWwajJggcRE9r1zUYg==}
+
+  '@tweenjs/tween.js@23.1.3':
+    resolution: {integrity: sha512-vJmvvwFxYuGnF2axRtPYocag6Clbb5YS7kLL+SO/TeVFzHqDIWrNKYtcsPMibjDx9O+bu+psAy9NKfWklassUA==}
+
+  '@types/estree@1.0.6':
+    resolution: {integrity: sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==}
+
+  '@types/node@22.13.9':
+    resolution: {integrity: sha512-acBjXdRJ3A6Pb3tqnw9HZmyR3Fiol3aGxRCK1x3d+6CDAMjl7I649wpSd+yNURCjbOUGu9tqtLKnTGxmK6CyGw==}
+
+  '@types/pako@2.0.3':
+    resolution: {integrity: sha512-bq0hMV9opAcrmE0Byyo0fY3Ew4tgOevJmQ9grUhpXQhYfyLJ1Kqg3P33JT5fdbT2AjeAjR51zqqVjAL/HMkx7Q==}
+
+  '@types/prop-types@15.7.14':
+    resolution: {integrity: sha512-gNMvNH49DJ7OJYv+KAKn0Xp45p8PLl6zo2YnvDIbTd4J6MER2BmWN49TG7n9LvkyihINxeKW8+3bfS2yDC9dzQ==}
+
+  '@types/react-transition-group@4.4.12':
+    resolution: {integrity: sha512-8TV6R3h2j7a91c+1DXdJi3Syo69zzIZbz7Lg5tORM5LEJG7X/E6a1V3drRyBRZq7/utz7A+c4OgYLiLcYGHG6w==}
+    peerDependencies:
+      '@types/react': '*'
+
+  '@types/react@19.0.10':
+    resolution: {integrity: sha512-JuRQ9KXLEjaUNjTWpzuR231Z2WpIwczOkBEIvbHNCzQefFIT0L8IqE6NV6ULLyC1SI/i234JnDoMkfg+RjQj2g==}
+
+  '@types/stats.js@0.17.3':
+    resolution: {integrity: sha512-pXNfAD3KHOdif9EQXZ9deK82HVNaXP5ZIF5RP2QG6OQFNTaY2YIetfrE9t528vEreGQvEPRDDc8muaoYeK0SxQ==}
+
+  '@types/three@0.174.0':
+    resolution: {integrity: sha512-De/+vZnfg2aVWNiuy1Ldu+n2ydgw1osinmiZTAn0necE++eOfsygL8JpZgFjR2uHmAPo89MkxBj3JJ+2BMe+Uw==}
+
+  '@types/webxr@0.5.21':
+    resolution: {integrity: sha512-geZIAtLzjGmgY2JUi6VxXdCrTb99A7yP49lxLr2Nm/uIK0PkkxcEi4OGhoGDO4pxCf3JwGz2GiJL2Ej4K2bKaA==}
+
+  '@typescript-eslint/eslint-plugin@8.26.0':
+    resolution: {integrity: sha512-cLr1J6pe56zjKYajK6SSSre6nl1Gj6xDp1TY0trpgPzjVbgDwd09v2Ws37LABxzkicmUjhEeg/fAUjPJJB1v5Q==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+    peerDependencies:
+      '@typescript-eslint/parser': ^8.0.0 || ^8.0.0-alpha.0
+      eslint: ^8.57.0 || ^9.0.0
+      typescript: '>=4.8.4 <5.9.0'
+
+  '@typescript-eslint/parser@8.26.0':
+    resolution: {integrity: sha512-mNtXP9LTVBy14ZF3o7JG69gRPBK/2QWtQd0j0oH26HcY/foyJJau6pNUez7QrM5UHnSvwlQcJXKsk0I99B9pOA==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+    peerDependencies:
+      eslint: ^8.57.0 || ^9.0.0
+      typescript: '>=4.8.4 <5.9.0'
+
+  '@typescript-eslint/scope-manager@8.26.0':
+    resolution: {integrity: sha512-E0ntLvsfPqnPwng8b8y4OGuzh/iIOm2z8U3S9zic2TeMLW61u5IH2Q1wu0oSTkfrSzwbDJIB/Lm8O3//8BWMPA==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+
+  '@typescript-eslint/type-utils@8.26.0':
+    resolution: {integrity: sha512-ruk0RNChLKz3zKGn2LwXuVoeBcUMh+jaqzN461uMMdxy5H9epZqIBtYj7UiPXRuOpaALXGbmRuZQhmwHhaS04Q==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+    peerDependencies:
+      eslint: ^8.57.0 || ^9.0.0
+      typescript: '>=4.8.4 <5.9.0'
+
+  '@typescript-eslint/types@8.26.0':
+    resolution: {integrity: sha512-89B1eP3tnpr9A8L6PZlSjBvnJhWXtYfZhECqlBl1D9Lme9mHO6iWlsprBtVenQvY1HMhax1mWOjhtL3fh/u+pA==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+
+  '@typescript-eslint/typescript-estree@8.26.0':
+    resolution: {integrity: sha512-tiJ1Hvy/V/oMVRTbEOIeemA2XoylimlDQ03CgPPNaHYZbpsc78Hmngnt+WXZfJX1pjQ711V7g0H7cSJThGYfPQ==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+    peerDependencies:
+      typescript: '>=4.8.4 <5.9.0'
+
+  '@typescript-eslint/utils@8.26.0':
+    resolution: {integrity: sha512-2L2tU3FVwhvU14LndnQCA2frYC8JnPDVKyQtWFPf8IYFMt/ykEN1bPolNhNbCVgOmdzTlWdusCTKA/9nKrf8Ig==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+    peerDependencies:
+      eslint: ^8.57.0 || ^9.0.0
+      typescript: '>=4.8.4 <5.9.0'
+
+  '@typescript-eslint/visitor-keys@8.26.0':
+    resolution: {integrity: sha512-2z8JQJWAzPdDd51dRQ/oqIJxe99/hoLIqmf8RMCAJQtYDc535W/Jt2+RTP4bP0aKeBG1F65yjIZuczOXCmbWwg==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+
+  '@ungap/structured-clone@1.3.0':
+    resolution: {integrity: sha512-WmoN8qaIAo7WTYWbAZuG8PYEhn5fkz7dZrqTBZ7dtt//lL2Gwms1IcnQ5yHqjDfX8Ft5j4YzDM23f87zBfDe9g==}
+
+  '@webgpu/types@0.1.54':
+    resolution: {integrity: sha512-81oaalC8LFrXjhsczomEQ0u3jG+TqE6V9QHLA8GNZq/Rnot0KDugu3LhSYSlie8tSdooAN1Hov05asrUUp9qgg==}
+
+  acorn-jsx@5.3.2:
+    resolution: {integrity: sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==}
+    peerDependencies:
+      acorn: ^6.0.0 || ^7.0.0 || ^8.0.0
+
+  acorn@8.14.0:
+    resolution: {integrity: sha512-cl669nCJTZBsL97OF4kUQm5g5hC2uihk0NxY3WENAC0TYdILVkAyHymAntgxGkl7K+t0cXIrH5siy5S4XkFycA==}
+    engines: {node: '>=0.4.0'}
+    hasBin: true
+
+  ajv@6.12.6:
+    resolution: {integrity: sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==}
+
+  alby-js-sdk@2.3.0:
+    resolution: {integrity: sha512-EZ7c1tk85IjDC6fzzIcliZNCUnAHhL5EfoqzXCfn7DExvaFHxJLOpacy6X9zdtXWVFX/SPWovQtR/OioG6uDUw==}
+    engines: {node: '>=14'}
+
+  ansi-regex@5.0.1:
+    resolution: {integrity: sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==}
+    engines: {node: '>=8'}
+
+  ansi-styles@4.3.0:
+    resolution: {integrity: sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==}
+    engines: {node: '>=8'}
+
+  argparse@2.0.1:
+    resolution: {integrity: sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==}
+
+  balanced-match@1.0.2:
+    resolution: {integrity: sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==}
+
+  brace-expansion@1.1.11:
+    resolution: {integrity: sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==}
+
+  brace-expansion@2.0.1:
+    resolution: {integrity: sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==}
+
+  braces@3.0.3:
+    resolution: {integrity: sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==}
+    engines: {node: '>=8'}
+
+  buffer-from@1.1.2:
+    resolution: {integrity: sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==}
+
+  callsites@3.1.0:
+    resolution: {integrity: sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==}
+    engines: {node: '>=6'}
+
+  chalk@4.1.2:
+    resolution: {integrity: sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==}
+    engines: {node: '>=10'}
+
+  clsx@2.1.1:
+    resolution: {integrity: sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==}
+    engines: {node: '>=6'}
+
+  color-convert@2.0.1:
+    resolution: {integrity: sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==}
+    engines: {node: '>=7.0.0'}
+
+  color-name@1.1.4:
+    resolution: {integrity: sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==}
+
+  commander@2.20.3:
+    resolution: {integrity: sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==}
+
+  concat-map@0.0.1:
+    resolution: {integrity: sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==}
+
+  cross-spawn@7.0.6:
+    resolution: {integrity: sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==}
+    engines: {node: '>= 8'}
+
+  crypto-js@4.2.0:
+    resolution: {integrity: sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q==}
+
+  csstype@3.1.3:
+    resolution: {integrity: sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==}
+
+  debug@4.4.0:
+    resolution: {integrity: sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==}
+    engines: {node: '>=6.0'}
+    peerDependencies:
+      supports-color: '*'
+    peerDependenciesMeta:
+      supports-color:
+        optional: true
+
+  deep-is@0.1.4:
+    resolution: {integrity: sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==}
+
+  doctrine@3.0.0:
+    resolution: {integrity: sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==}
+    engines: {node: '>=6.0.0'}
+
+  dom-helpers@5.2.1:
+    resolution: {integrity: sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==}
+
+  esbuild@0.21.5:
+    resolution: {integrity: sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==}
+    engines: {node: '>=12'}
+    hasBin: true
+
+  escape-string-regexp@4.0.0:
+    resolution: {integrity: sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==}
+    engines: {node: '>=10'}
+
+  eslint-scope@7.2.2:
+    resolution: {integrity: sha512-dOt21O7lTMhDM+X9mB4GX+DZrZtCUJPL/wlcTqxyrx5IvO0IYtILdtrQGQp+8n5S0gwSVmOf9NQrjMOgfQZlIg==}
+    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
+
+  eslint-visitor-keys@3.4.3:
+    resolution: {integrity: sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==}
+    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
+
+  eslint-visitor-keys@4.2.0:
+    resolution: {integrity: sha512-UyLnSehNt62FFhSwjZlHmeokpRK59rcz29j+F1/aDgbkbRTk7wIc9XzdoasMUbRNKDM0qQt/+BJ4BrpFeABemw==}
+    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
+
+  eslint@8.57.1:
+    resolution: {integrity: sha512-ypowyDxpVSYpkXr9WPv2PAZCtNip1Mv5KTW0SCurXv/9iOpcrH9PaqUElksqEB6pChqHGDRCFTyrZlGhnLNGiA==}
+    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
+    deprecated: This version is no longer supported. Please see https://eslint.org/version-support for other options.
+    hasBin: true
+
+  espree@9.6.1:
+    resolution: {integrity: sha512-oruZaFkjorTpF32kDSI5/75ViwGeZginGGy2NoOSg3Q9bnwlnmDm4HLnkl0RE3n+njDXR037aY1+x58Z/zFdwQ==}
+    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
+
+  esquery@1.6.0:
+    resolution: {integrity: sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==}
+    engines: {node: '>=0.10'}
+
+  esrecurse@4.3.0:
+    resolution: {integrity: sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==}
+    engines: {node: '>=4.0'}
+
+  estraverse@5.3.0:
+    resolution: {integrity: sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==}
+    engines: {node: '>=4.0'}
+
+  esutils@2.0.3:
+    resolution: {integrity: sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==}
+    engines: {node: '>=0.10.0'}
+
+  events@3.3.0:
+    resolution: {integrity: sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==}
+    engines: {node: '>=0.8.x'}
+
+  fast-deep-equal@3.1.3:
+    resolution: {integrity: sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==}
+
+  fast-glob@3.3.3:
+    resolution: {integrity: sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==}
+    engines: {node: '>=8.6.0'}
+
+  fast-json-stable-stringify@2.1.0:
+    resolution: {integrity: sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==}
+
+  fast-levenshtein@2.0.6:
+    resolution: {integrity: sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==}
+
+  fastq@1.19.1:
+    resolution: {integrity: sha512-GwLTyxkCXjXbxqIhTsMI2Nui8huMPtnxg7krajPJAjnEG/iiOS7i+zCtWGZR9G0NBKbXKh6X9m9UIsYX/N6vvQ==}
+
+  fflate@0.8.2:
+    resolution: {integrity: sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==}
+
+  file-entry-cache@6.0.1:
+    resolution: {integrity: sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==}
+    engines: {node: ^10.12.0 || >=12.0.0}
+
+  fill-range@7.1.1:
+    resolution: {integrity: sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==}
+    engines: {node: '>=8'}
+
+  find-up@5.0.0:
+    resolution: {integrity: sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==}
+    engines: {node: '>=10'}
+
+  flat-cache@3.2.0:
+    resolution: {integrity: sha512-CYcENa+FtcUKLmhhqyctpclsq7QF38pKjZHsGNiSQF5r4FtoKDWabFDl3hzaEQMvT1LHEysw5twgLvpYYb4vbw==}
+    engines: {node: ^10.12.0 || >=12.0.0}
+
+  flatted@3.3.3:
+    resolution: {integrity: sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==}
+
+  fs.realpath@1.0.0:
+    resolution: {integrity: sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==}
+
+  fsevents@2.3.3:
+    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
+    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
+    os: [darwin]
+
+  glob-parent@5.1.2:
+    resolution: {integrity: sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==}
+    engines: {node: '>= 6'}
+
+  glob-parent@6.0.2:
+    resolution: {integrity: sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==}
+    engines: {node: '>=10.13.0'}
+
+  glob@7.2.3:
+    resolution: {integrity: sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==}
+    deprecated: Glob versions prior to v9 are no longer supported
+
+  globals@13.24.0:
+    resolution: {integrity: sha512-AhO5QUcj8llrbG09iWhPU2B204J1xnPeL8kQmVorSsy+Sjj1sk8gIyh6cUocGmH4L0UuhAJy+hJMRA4mgA4mFQ==}
+    engines: {node: '>=8'}
+
+  graphemer@1.4.0:
+    resolution: {integrity: sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==}
+
+  has-flag@4.0.0:
+    resolution: {integrity: sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==}
+    engines: {node: '>=8'}
+
+  ignore@5.3.2:
+    resolution: {integrity: sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==}
+    engines: {node: '>= 4'}
+
+  import-fresh@3.3.1:
+    resolution: {integrity: sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==}
+    engines: {node: '>=6'}
+
+  imurmurhash@0.1.4:
+    resolution: {integrity: sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==}
+    engines: {node: '>=0.8.19'}
+
+  inflight@1.0.6:
+    resolution: {integrity: sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==}
+    deprecated: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.
+
+  inherits@2.0.4:
+    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}
+
+  is-extglob@2.1.1:
+    resolution: {integrity: sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==}
+    engines: {node: '>=0.10.0'}
+
+  is-glob@4.0.3:
+    resolution: {integrity: sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==}
+    engines: {node: '>=0.10.0'}
+
+  is-number@7.0.0:
+    resolution: {integrity: sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==}
+    engines: {node: '>=0.12.0'}
+
+  is-path-inside@3.0.3:
+    resolution: {integrity: sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==}
+    engines: {node: '>=8'}
+
+  isexe@2.0.0:
+    resolution: {integrity: sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==}
+
+  js-tokens@4.0.0:
+    resolution: {integrity: sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==}
+
+  js-yaml@4.1.0:
+    resolution: {integrity: sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==}
+    hasBin: true
+
+  json-buffer@3.0.1:
+    resolution: {integrity: sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==}
+
+  json-schema-traverse@0.4.1:
+    resolution: {integrity: sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==}
+
+  json-stable-stringify-without-jsonify@1.0.1:
+    resolution: {integrity: sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==}
+
+  keyv@4.5.4:
+    resolution: {integrity: sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==}
+
+  levn@0.4.1:
+    resolution: {integrity: sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==}
+    engines: {node: '>= 0.8.0'}
+
+  locate-path@6.0.0:
+    resolution: {integrity: sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==}
+    engines: {node: '>=10'}
+
+  lodash.merge@4.6.2:
+    resolution: {integrity: sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==}
+
+  loose-envify@1.4.0:
+    resolution: {integrity: sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==}
+    hasBin: true
+
+  merge2@1.4.1:
+    resolution: {integrity: sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==}
+    engines: {node: '>= 8'}
+
+  meshoptimizer@0.18.1:
+    resolution: {integrity: sha512-ZhoIoL7TNV4s5B6+rx5mC//fw8/POGyNxS/DZyCJeiZ12ScLfVwRE/GfsxwiTkMYYD5DmK2/JXnEVXqL4rF+Sw==}
+
+  micromatch@4.0.8:
+    resolution: {integrity: sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==}
+    engines: {node: '>=8.6'}
+
+  minimatch@3.1.2:
+    resolution: {integrity: sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==}
+
+  minimatch@9.0.5:
+    resolution: {integrity: sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==}
+    engines: {node: '>=16 || 14 >=14.17'}
+
+  ms@2.1.3:
+    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}
+
+  nanoid@3.3.8:
+    resolution: {integrity: sha512-WNLf5Sd8oZxOm+TzppcYk8gVOgP+l58xNy58D0nbUnOxOWRWvlcCV4kUF7ltmI6PsrLl/BgKEyS4mqsGChFN0w==}
+    engines: {node: ^10 || ^12 || ^13.7 || ^14 || >=15.0.1}
+    hasBin: true
+
+  natural-compare@1.4.0:
+    resolution: {integrity: sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==}
+
+  nostr-tools@1.13.1:
+    resolution: {integrity: sha512-DTwpbxTH1/ar+afWd4gmVdpHH8CF290kdaxi00Llra88SHE6e38XuyzlRABVTcrBaceLMnoDdHmV3x16MoEFJg==}
+
+  object-assign@4.1.1:
+    resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
+    engines: {node: '>=0.10.0'}
+
+  once@1.4.0:
+    resolution: {integrity: sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==}
+
+  optionator@0.9.4:
+    resolution: {integrity: sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==}
+    engines: {node: '>= 0.8.0'}
+
+  p-limit@3.1.0:
+    resolution: {integrity: sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==}
+    engines: {node: '>=10'}
+
+  p-locate@5.0.0:
+    resolution: {integrity: sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==}
+    engines: {node: '>=10'}
+
+  pako@2.1.0:
+    resolution: {integrity: sha512-w+eufiZ1WuJYgPXbV/PO3NCMEc3xqylkKHzp8bxp1uW4qaSNQUkwmLLEc3kKsfz8lpV1F8Ht3U1Cm+9Srog2ug==}
+
+  parent-module@1.0.1:
+    resolution: {integrity: sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==}
+    engines: {node: '>=6'}
+
+  path-exists@4.0.0:
+    resolution: {integrity: sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==}
+    engines: {node: '>=8'}
+
+  path-is-absolute@1.0.1:
+    resolution: {integrity: sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==}
+    engines: {node: '>=0.10.0'}
+
+  path-key@3.1.1:
+    resolution: {integrity: sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==}
+    engines: {node: '>=8'}
+
+  picocolors@1.1.1:
+    resolution: {integrity: sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==}
+
+  picomatch@2.3.1:
+    resolution: {integrity: sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==}
+    engines: {node: '>=8.6'}
+
+  postcss@8.5.3:
+    resolution: {integrity: sha512-dle9A3yYxlBSrt8Fu+IpjGT8SY8hN0mlaA6GY8t0P5PjIOZemULz/E2Bnm/2dcUOena75OTNkHI76uZBNUUq3A==}
+    engines: {node: ^10 || ^12 || >=14}
+
+  prelude-ls@1.2.1:
+    resolution: {integrity: sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==}
+    engines: {node: '>= 0.8.0'}
+
+  prettier@3.5.3:
+    resolution: {integrity: sha512-QQtaxnoDJeAkDvDKWCLiwIXkTgRhwYDEQCghU9Z6q03iyek/rxRh/2lC3HB7P8sWT2xC/y5JDctPLBIGzHKbhw==}
+    engines: {node: '>=14'}
+    hasBin: true
+
+  prop-types@15.8.1:
+    resolution: {integrity: sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==}
+
+  punycode@2.3.1:
+    resolution: {integrity: sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==}
+    engines: {node: '>=6'}
+
+  queue-microtask@1.2.3:
+    resolution: {integrity: sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==}
+
+  react-dom@19.0.0:
+    resolution: {integrity: sha512-4GV5sHFG0e/0AD4X+ySy6UJd3jVl1iNsNHdpad0qhABJ11twS3TTBnseqsKurKcsNqCEFeGL3uLpVChpIO3QfQ==}
+    peerDependencies:
+      react: ^19.0.0
+
+  react-is@16.13.1:
+    resolution: {integrity: sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==}
+
+  react-is@19.0.0:
+    resolution: {integrity: sha512-H91OHcwjZsbq3ClIDHMzBShc1rotbfACdWENsmEf0IFvZ3FgGPtdHMcsv45bQ1hAbgdfiA8SnxTKfDS+x/8m2g==}
+
+  react-transition-group@4.4.5:
+    resolution: {integrity: sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==}
+    peerDependencies:
+      react: '>=16.6.0'
+      react-dom: '>=16.6.0'
+
+  react@19.0.0:
+    resolution: {integrity: sha512-V8AVnmPIICiWpGfm6GLzCR/W5FXLchHop40W4nXBmdlEceh16rCN8O8LNWm5bh5XUX91fh7KpA+W0TgMKmgTpQ==}
+    engines: {node: '>=0.10.0'}
+
+  regenerator-runtime@0.14.1:
+    resolution: {integrity: sha512-dYnhHh0nJoMfnkZs6GmmhFknAGRrLznOu5nc9ML+EJxGvrx6H7teuevqVqCuPcPK//3eDrrjQhehXVx9cnkGdw==}
+
+  resolve-from@4.0.0:
+    resolution: {integrity: sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==}
+    engines: {node: '>=4'}
+
+  reusify@1.1.0:
+    resolution: {integrity: sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==}
+    engines: {iojs: '>=1.0.0', node: '>=0.10.0'}
+
+  rimraf@3.0.2:
+    resolution: {integrity: sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==}
+    deprecated: Rimraf versions prior to v4 are no longer supported
+    hasBin: true
+
+  rollup@4.34.9:
+    resolution: {integrity: sha512-nF5XYqWWp9hx/LrpC8sZvvvmq0TeTjQgaZHYmAgwysT9nh8sWnZhBnM8ZyVbbJFIQBLwHDNoMqsBZBbUo4U8sQ==}
+    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
+    hasBin: true
+
+  run-parallel@1.2.0:
+    resolution: {integrity: sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==}
+
+  scheduler@0.25.0:
+    resolution: {integrity: sha512-xFVuu11jh+xcO7JOAGJNOXld8/TcEHK/4CituBUeUb5hqxJLj9YuemAEuvm9gQ/+pgXYfbQuqAkiYu+u7YEsNA==}
+
+  semver@7.7.1:
+    resolution: {integrity: sha512-hlq8tAfn0m/61p4BVRcPzIGr6LKiMwo4VM6dGi6pt4qcRkmNzTcWq6eCEjEh+qXjkMDvPlOFFSGwQjoEa6gyMA==}
+    engines: {node: '>=10'}
+    hasBin: true
+
+  shebang-command@2.0.0:
+    resolution: {integrity: sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==}
+    engines: {node: '>=8'}
+
+  shebang-regex@3.0.0:
+    resolution: {integrity: sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==}
+    engines: {node: '>=8'}
+
+  source-map-js@1.2.1:
+    resolution: {integrity: sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==}
+    engines: {node: '>=0.10.0'}
+
+  source-map-support@0.5.21:
+    resolution: {integrity: sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==}
+
+  source-map@0.6.1:
+    resolution: {integrity: sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==}
+    engines: {node: '>=0.10.0'}
+
+  strip-ansi@6.0.1:
+    resolution: {integrity: sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==}
+    engines: {node: '>=8'}
+
+  strip-json-comments@3.1.1:
+    resolution: {integrity: sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==}
+    engines: {node: '>=8'}
+
+  stylis@4.2.0:
+    resolution: {integrity: sha512-Orov6g6BB1sDfYgzWfTHDOxamtX1bE/zo104Dh9e6fqJ3PooipYyfJ0pUmrZO2wAvO8YbEyeFrkV91XTsGMSrw==}
+
+  supports-color@7.2.0:
+    resolution: {integrity: sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==}
+    engines: {node: '>=8'}
+
+  terser@5.39.0:
+    resolution: {integrity: sha512-LBAhFyLho16harJoWMg/nZsQYgTrg5jXOn2nCYjRUcZZEdE3qa2zb8QEDRUGVZBW4rlazf2fxkg8tztybTaqWw==}
+    engines: {node: '>=10'}
+    hasBin: true
+
+  text-table@0.2.0:
+    resolution: {integrity: sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==}
+
+  three@0.174.0:
+    resolution: {integrity: sha512-p+WG3W6Ov74alh3geCMkGK9NWuT62ee21cV3jEnun201zodVF4tCE5aZa2U122/mkLRmhJJUQmLLW1BH00uQJQ==}
+
+  to-regex-range@5.0.1:
+    resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
+    engines: {node: '>=8.0'}
+
+  ts-api-utils@2.0.1:
+    resolution: {integrity: sha512-dnlgjFSVetynI8nzgJ+qF62efpglpWRk8isUEWZGWlJYySCTD6aKvbUDu+zbPeDakk3bg5H4XpitHukgfL1m9w==}
+    engines: {node: '>=18.12'}
+    peerDependencies:
+      typescript: '>=4.8.4'
+
+  type-check@0.4.0:
+    resolution: {integrity: sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==}
+    engines: {node: '>= 0.8.0'}
+
+  type-fest@0.20.2:
+    resolution: {integrity: sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==}
+    engines: {node: '>=10'}
+
+  typescript@5.4.5:
+    resolution: {integrity: sha512-vcI4UpRgg81oIRUFwR0WSIHKt11nJ7SAVlYNIu+QpqeyXP+gpQJy/Z4+F0aGxSE4MqwjyXvW/TzgkLAx2AGHwQ==}
+    engines: {node: '>=14.17'}
+    hasBin: true
+
+  undici-types@6.20.0:
+    resolution: {integrity: sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg==}
+
+  uri-js@4.4.1:
+    resolution: {integrity: sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==}
+
+  vite@5.4.14:
+    resolution: {integrity: sha512-EK5cY7Q1D8JNhSaPKVK4pwBFvaTmZxEnoKXLG/U9gmdDcihQGNzFlgIvaxezFR4glP1LsuiedwMBqCXH3wZccA==}
+    engines: {node: ^18.0.0 || >=20.0.0}
+    hasBin: true
+    peerDependencies:
+      '@types/node': ^18.0.0 || >=20.0.0
+      less: '*'
+      lightningcss: ^1.21.0
+      sass: '*'
+      sass-embedded: '*'
+      stylus: '*'
+      sugarss: '*'
+      terser: ^5.4.0
+    peerDependenciesMeta:
+      '@types/node':
+        optional: true
+      less:
+        optional: true
+      lightningcss:
+        optional: true
+      sass:
+        optional: true
+      sass-embedded:
+        optional: true
+      stylus:
+        optional: true
+      sugarss:
+        optional: true
+      terser:
+        optional: true
+
+  which@2.0.2:
+    resolution: {integrity: sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==}
+    engines: {node: '>= 8'}
+    hasBin: true
+
+  word-wrap@1.2.5:
+    resolution: {integrity: sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==}
+    engines: {node: '>=0.10.0'}
+
+  wrappy@1.0.2:
+    resolution: {integrity: sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==}
+
+  yocto-queue@0.1.0:
+    resolution: {integrity: sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==}
+    engines: {node: '>=10'}
+
+snapshots:
+
+  '@babel/runtime@7.26.9':
+    dependencies:
+      regenerator-runtime: 0.14.1
+
+  '@emotion/cache@11.14.0':
+    dependencies:
+      '@emotion/memoize': 0.9.0
+      '@emotion/sheet': 1.4.0
+      '@emotion/utils': 1.4.2
+      '@emotion/weak-memoize': 0.4.0
+      stylis: 4.2.0
+
+  '@emotion/memoize@0.9.0': {}
+
+  '@emotion/sheet@1.4.0': {}
+
+  '@emotion/utils@1.4.2': {}
+
+  '@emotion/weak-memoize@0.4.0': {}
+
+  '@esbuild/aix-ppc64@0.21.5':
+    optional: true
+
+  '@esbuild/android-arm64@0.21.5':
+    optional: true
+
+  '@esbuild/android-arm@0.21.5':
+    optional: true
+
+  '@esbuild/android-x64@0.21.5':
+    optional: true
+
+  '@esbuild/darwin-arm64@0.21.5':
+    optional: true
+
+  '@esbuild/darwin-x64@0.21.5':
+    optional: true
+
+  '@esbuild/freebsd-arm64@0.21.5':
+    optional: true
+
+  '@esbuild/freebsd-x64@0.21.5':
+    optional: true
+
+  '@esbuild/linux-arm64@0.21.5':
+    optional: true
+
+  '@esbuild/linux-arm@0.21.5':
+    optional: true
+
+  '@esbuild/linux-ia32@0.21.5':
+    optional: true
+
+  '@esbuild/linux-loong64@0.21.5':
+    optional: true
+
+  '@esbuild/linux-mips64el@0.21.5':
+    optional: true
+
+  '@esbuild/linux-ppc64@0.21.5':
+    optional: true
+
+  '@esbuild/linux-riscv64@0.21.5':
+    optional: true
+
+  '@esbuild/linux-s390x@0.21.5':
+    optional: true
+
+  '@esbuild/linux-x64@0.21.5':
+    optional: true
+
+  '@esbuild/netbsd-x64@0.21.5':
+    optional: true
+
+  '@esbuild/openbsd-x64@0.21.5':
+    optional: true
+
+  '@esbuild/sunos-x64@0.21.5':
+    optional: true
+
+  '@esbuild/win32-arm64@0.21.5':
+    optional: true
+
+  '@esbuild/win32-ia32@0.21.5':
+    optional: true
+
+  '@esbuild/win32-x64@0.21.5':
+    optional: true
+
+  '@eslint-community/eslint-utils@4.4.1(eslint@8.57.1)':
+    dependencies:
+      eslint: 8.57.1
+      eslint-visitor-keys: 3.4.3
+
+  '@eslint-community/regexpp@4.12.1': {}
+
+  '@eslint/eslintrc@2.1.4':
+    dependencies:
+      ajv: 6.12.6
+      debug: 4.4.0
+      espree: 9.6.1
+      globals: 13.24.0
+      ignore: 5.3.2
+      import-fresh: 3.3.1
+      js-yaml: 4.1.0
+      minimatch: 3.1.2
+      strip-json-comments: 3.1.1
+    transitivePeerDependencies:
+      - supports-color
+
+  '@eslint/js@8.57.1': {}
+
+  '@humanwhocodes/config-array@0.13.0':
+    dependencies:
+      '@humanwhocodes/object-schema': 2.0.3
+      debug: 4.4.0
+      minimatch: 3.1.2
+    transitivePeerDependencies:
+      - supports-color
+
+  '@humanwhocodes/module-importer@1.0.1': {}
+
+  '@humanwhocodes/object-schema@2.0.3': {}
+
+  '@jridgewell/gen-mapping@0.3.8':
+    dependencies:
+      '@jridgewell/set-array': 1.2.1
+      '@jridgewell/sourcemap-codec': 1.5.0
+      '@jridgewell/trace-mapping': 0.3.25
+
+  '@jridgewell/resolve-uri@3.1.2': {}
+
+  '@jridgewell/set-array@1.2.1': {}
+
+  '@jridgewell/source-map@0.3.6':
+    dependencies:
+      '@jridgewell/gen-mapping': 0.3.8
+      '@jridgewell/trace-mapping': 0.3.25
+
+  '@jridgewell/sourcemap-codec@1.5.0': {}
+
+  '@jridgewell/trace-mapping@0.3.25':
+    dependencies:
+      '@jridgewell/resolve-uri': 3.1.2
+      '@jridgewell/sourcemap-codec': 1.5.0
+
+  '@mui/core-downloads-tracker@5.16.14': {}
+
+  '@mui/material@5.16.14(@types/react@19.0.10)(react-dom@19.0.0(react@19.0.0))(react@19.0.0)':
+    dependencies:
+      '@babel/runtime': 7.26.9
+      '@mui/core-downloads-tracker': 5.16.14
+      '@mui/system': 5.16.14(@types/react@19.0.10)(react@19.0.0)
+      '@mui/types': 7.2.21(@types/react@19.0.10)
+      '@mui/utils': 5.16.14(@types/react@19.0.10)(react@19.0.0)
+      '@popperjs/core': 2.11.8
+      '@types/react-transition-group': 4.4.12(@types/react@19.0.10)
+      clsx: 2.1.1
+      csstype: 3.1.3
+      prop-types: 15.8.1
+      react: 19.0.0
+      react-dom: 19.0.0(react@19.0.0)
+      react-is: 19.0.0
+      react-transition-group: 4.4.5(react-dom@19.0.0(react@19.0.0))(react@19.0.0)
+    optionalDependencies:
+      '@types/react': 19.0.10
+
+  '@mui/private-theming@5.16.14(@types/react@19.0.10)(react@19.0.0)':
+    dependencies:
+      '@babel/runtime': 7.26.9
+      '@mui/utils': 5.16.14(@types/react@19.0.10)(react@19.0.0)
+      prop-types: 15.8.1
+      react: 19.0.0
+    optionalDependencies:
+      '@types/react': 19.0.10
+
+  '@mui/styled-engine@5.16.14(react@19.0.0)':
+    dependencies:
+      '@babel/runtime': 7.26.9
+      '@emotion/cache': 11.14.0
+      csstype: 3.1.3
+      prop-types: 15.8.1
+      react: 19.0.0
+
+  '@mui/system@5.16.14(@types/react@19.0.10)(react@19.0.0)':
+    dependencies:
+      '@babel/runtime': 7.26.9
+      '@mui/private-theming': 5.16.14(@types/react@19.0.10)(react@19.0.0)
+      '@mui/styled-engine': 5.16.14(react@19.0.0)
+      '@mui/types': 7.2.21(@types/react@19.0.10)
+      '@mui/utils': 5.16.14(@types/react@19.0.10)(react@19.0.0)
+      clsx: 2.1.1
+      csstype: 3.1.3
+      prop-types: 15.8.1
+      react: 19.0.0
+    optionalDependencies:
+      '@types/react': 19.0.10
+
+  '@mui/types@7.2.21(@types/react@19.0.10)':
+    optionalDependencies:
+      '@types/react': 19.0.10
+
+  '@mui/utils@5.16.14(@types/react@19.0.10)(react@19.0.0)':
+    dependencies:
+      '@babel/runtime': 7.26.9
+      '@mui/types': 7.2.21(@types/react@19.0.10)
+      '@types/prop-types': 15.7.14
+      clsx: 2.1.1
+      prop-types: 15.8.1
+      react: 19.0.0
+      react-is: 19.0.0
+    optionalDependencies:
+      '@types/react': 19.0.10
+
+  '@noble/curves@1.1.0':
+    dependencies:
+      '@noble/hashes': 1.3.1
+
+  '@noble/hashes@1.3.1': {}
+
+  '@nodelib/fs.scandir@2.1.5':
+    dependencies:
+      '@nodelib/fs.stat': 2.0.5
+      run-parallel: 1.2.0
+
+  '@nodelib/fs.stat@2.0.5': {}
+
+  '@nodelib/fs.walk@1.2.8':
+    dependencies:
+      '@nodelib/fs.scandir': 2.1.5
+      fastq: 1.19.1
+
+  '@popperjs/core@2.11.8': {}
+
+  '@rollup/rollup-android-arm-eabi@4.34.9':
+    optional: true
+
+  '@rollup/rollup-android-arm64@4.34.9':
+    optional: true
+
+  '@rollup/rollup-darwin-arm64@4.34.9':
+    optional: true
+
+  '@rollup/rollup-darwin-x64@4.34.9':
+    optional: true
+
+  '@rollup/rollup-freebsd-arm64@4.34.9':
+    optional: true
+
+  '@rollup/rollup-freebsd-x64@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-arm-gnueabihf@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-arm-musleabihf@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-arm64-gnu@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-arm64-musl@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-loongarch64-gnu@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-powerpc64le-gnu@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-riscv64-gnu@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-s390x-gnu@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-x64-gnu@4.34.9':
+    optional: true
+
+  '@rollup/rollup-linux-x64-musl@4.34.9':
+    optional: true
+
+  '@rollup/rollup-win32-arm64-msvc@4.34.9':
+    optional: true
+
+  '@rollup/rollup-win32-ia32-msvc@4.34.9':
+    optional: true
+
+  '@rollup/rollup-win32-x64-msvc@4.34.9':
+    optional: true
+
+  '@scure/base@1.1.1': {}
+
+  '@scure/bip32@1.3.1':
+    dependencies:
+      '@noble/curves': 1.1.0
+      '@noble/hashes': 1.3.1
+      '@scure/base': 1.1.1
+
+  '@scure/bip39@1.2.1':
+    dependencies:
+      '@noble/hashes': 1.3.1
+      '@scure/base': 1.1.1
+
+  '@tweenjs/tween.js@23.1.3': {}
+
+  '@types/estree@1.0.6': {}
+
+  '@types/node@22.13.9':
+    dependencies:
+      undici-types: 6.20.0
+
+  '@types/pako@2.0.3': {}
+
+  '@types/prop-types@15.7.14': {}
+
+  '@types/react-transition-group@4.4.12(@types/react@19.0.10)':
+    dependencies:
+      '@types/react': 19.0.10
+
+  '@types/react@19.0.10':
+    dependencies:
+      csstype: 3.1.3
+
+  '@types/stats.js@0.17.3': {}
+
+  '@types/three@0.174.0':
+    dependencies:
+      '@tweenjs/tween.js': 23.1.3
+      '@types/stats.js': 0.17.3
+      '@types/webxr': 0.5.21
+      '@webgpu/types': 0.1.54
+      fflate: 0.8.2
+      meshoptimizer: 0.18.1
+
+  '@types/webxr@0.5.21': {}
+
+  '@typescript-eslint/eslint-plugin@8.26.0(@typescript-eslint/parser@8.26.0(eslint@8.57.1)(typescript@5.4.5))(eslint@8.57.1)(typescript@5.4.5)':
+    dependencies:
+      '@eslint-community/regexpp': 4.12.1
+      '@typescript-eslint/parser': 8.26.0(eslint@8.57.1)(typescript@5.4.5)
+      '@typescript-eslint/scope-manager': 8.26.0
+      '@typescript-eslint/type-utils': 8.26.0(eslint@8.57.1)(typescript@5.4.5)
+      '@typescript-eslint/utils': 8.26.0(eslint@8.57.1)(typescript@5.4.5)
+      '@typescript-eslint/visitor-keys': 8.26.0
+      eslint: 8.57.1
+      graphemer: 1.4.0
+      ignore: 5.3.2
+      natural-compare: 1.4.0
+      ts-api-utils: 2.0.1(typescript@5.4.5)
+      typescript: 5.4.5
+    transitivePeerDependencies:
+      - supports-color
+
+  '@typescript-eslint/parser@8.26.0(eslint@8.57.1)(typescript@5.4.5)':
+    dependencies:
+      '@typescript-eslint/scope-manager': 8.26.0
+      '@typescript-eslint/types': 8.26.0
+      '@typescript-eslint/typescript-estree': 8.26.0(typescript@5.4.5)
+      '@typescript-eslint/visitor-keys': 8.26.0
+      debug: 4.4.0
+      eslint: 8.57.1
+      typescript: 5.4.5
+    transitivePeerDependencies:
+      - supports-color
+
+  '@typescript-eslint/scope-manager@8.26.0':
+    dependencies:
+      '@typescript-eslint/types': 8.26.0
+      '@typescript-eslint/visitor-keys': 8.26.0
+
+  '@typescript-eslint/type-utils@8.26.0(eslint@8.57.1)(typescript@5.4.5)':
+    dependencies:
+      '@typescript-eslint/typescript-estree': 8.26.0(typescript@5.4.5)
+      '@typescript-eslint/utils': 8.26.0(eslint@8.57.1)(typescript@5.4.5)
+      debug: 4.4.0
+      eslint: 8.57.1
+      ts-api-utils: 2.0.1(typescript@5.4.5)
+      typescript: 5.4.5
+    transitivePeerDependencies:
+      - supports-color
+
+  '@typescript-eslint/types@8.26.0': {}
+
+  '@typescript-eslint/typescript-estree@8.26.0(typescript@5.4.5)':
+    dependencies:
+      '@typescript-eslint/types': 8.26.0
+      '@typescript-eslint/visitor-keys': 8.26.0
+      debug: 4.4.0
+      fast-glob: 3.3.3
+      is-glob: 4.0.3
+      minimatch: 9.0.5
+      semver: 7.7.1
+      ts-api-utils: 2.0.1(typescript@5.4.5)
+      typescript: 5.4.5
+    transitivePeerDependencies:
+      - supports-color
+
+  '@typescript-eslint/utils@8.26.0(eslint@8.57.1)(typescript@5.4.5)':
+    dependencies:
+      '@eslint-community/eslint-utils': 4.4.1(eslint@8.57.1)
+      '@typescript-eslint/scope-manager': 8.26.0
+      '@typescript-eslint/types': 8.26.0
+      '@typescript-eslint/typescript-estree': 8.26.0(typescript@5.4.5)
+      eslint: 8.57.1
+      typescript: 5.4.5
+    transitivePeerDependencies:
+      - supports-color
+
+  '@typescript-eslint/visitor-keys@8.26.0':
+    dependencies:
+      '@typescript-eslint/types': 8.26.0
+      eslint-visitor-keys: 4.2.0
+
+  '@ungap/structured-clone@1.3.0': {}
+
+  '@webgpu/types@0.1.54': {}
+
+  acorn-jsx@5.3.2(acorn@8.14.0):
+    dependencies:
+      acorn: 8.14.0
+
+  acorn@8.14.0: {}
+
+  ajv@6.12.6:
+    dependencies:
+      fast-deep-equal: 3.1.3
+      fast-json-stable-stringify: 2.1.0
+      json-schema-traverse: 0.4.1
+      uri-js: 4.4.1
+
+  alby-js-sdk@2.3.0:
+    dependencies:
+      crypto-js: 4.2.0
+      events: 3.3.0
+      nostr-tools: 1.13.1
+
+  ansi-regex@5.0.1: {}
+
+  ansi-styles@4.3.0:
+    dependencies:
+      color-convert: 2.0.1
+
+  argparse@2.0.1: {}
+
+  balanced-match@1.0.2: {}
+
+  brace-expansion@1.1.11:
+    dependencies:
+      balanced-match: 1.0.2
+      concat-map: 0.0.1
+
+  brace-expansion@2.0.1:
+    dependencies:
+      balanced-match: 1.0.2
+
+  braces@3.0.3:
+    dependencies:
+      fill-range: 7.1.1
+
+  buffer-from@1.1.2: {}
+
+  callsites@3.1.0: {}
+
+  chalk@4.1.2:
+    dependencies:
+      ansi-styles: 4.3.0
+      supports-color: 7.2.0
+
+  clsx@2.1.1: {}
+
+  color-convert@2.0.1:
+    dependencies:
+      color-name: 1.1.4
+
+  color-name@1.1.4: {}
+
+  commander@2.20.3: {}
+
+  concat-map@0.0.1: {}
+
+  cross-spawn@7.0.6:
+    dependencies:
+      path-key: 3.1.1
+      shebang-command: 2.0.0
+      which: 2.0.2
+
+  crypto-js@4.2.0: {}
+
+  csstype@3.1.3: {}
+
+  debug@4.4.0:
+    dependencies:
+      ms: 2.1.3
+
+  deep-is@0.1.4: {}
+
+  doctrine@3.0.0:
+    dependencies:
+      esutils: 2.0.3
+
+  dom-helpers@5.2.1:
+    dependencies:
+      '@babel/runtime': 7.26.9
+      csstype: 3.1.3
+
+  esbuild@0.21.5:
+    optionalDependencies:
+      '@esbuild/aix-ppc64': 0.21.5
+      '@esbuild/android-arm': 0.21.5
+      '@esbuild/android-arm64': 0.21.5
+      '@esbuild/android-x64': 0.21.5
+      '@esbuild/darwin-arm64': 0.21.5
+      '@esbuild/darwin-x64': 0.21.5
+      '@esbuild/freebsd-arm64': 0.21.5
+      '@esbuild/freebsd-x64': 0.21.5
+      '@esbuild/linux-arm': 0.21.5
+      '@esbuild/linux-arm64': 0.21.5
+      '@esbuild/linux-ia32': 0.21.5
+      '@esbuild/linux-loong64': 0.21.5
+      '@esbuild/linux-mips64el': 0.21.5
+      '@esbuild/linux-ppc64': 0.21.5
+      '@esbuild/linux-riscv64': 0.21.5
+      '@esbuild/linux-s390x': 0.21.5
+      '@esbuild/linux-x64': 0.21.5
+      '@esbuild/netbsd-x64': 0.21.5
+      '@esbuild/openbsd-x64': 0.21.5
+      '@esbuild/sunos-x64': 0.21.5
+      '@esbuild/win32-arm64': 0.21.5
+      '@esbuild/win32-ia32': 0.21.5
+      '@esbuild/win32-x64': 0.21.5
+
+  escape-string-regexp@4.0.0: {}
+
+  eslint-scope@7.2.2:
+    dependencies:
+      esrecurse: 4.3.0
+      estraverse: 5.3.0
+
+  eslint-visitor-keys@3.4.3: {}
+
+  eslint-visitor-keys@4.2.0: {}
+
+  eslint@8.57.1:
+    dependencies:
+      '@eslint-community/eslint-utils': 4.4.1(eslint@8.57.1)
+      '@eslint-community/regexpp': 4.12.1
+      '@eslint/eslintrc': 2.1.4
+      '@eslint/js': 8.57.1
+      '@humanwhocodes/config-array': 0.13.0
+      '@humanwhocodes/module-importer': 1.0.1
+      '@nodelib/fs.walk': 1.2.8
+      '@ungap/structured-clone': 1.3.0
+      ajv: 6.12.6
+      chalk: 4.1.2
+      cross-spawn: 7.0.6
+      debug: 4.4.0
+      doctrine: 3.0.0
+      escape-string-regexp: 4.0.0
+      eslint-scope: 7.2.2
+      eslint-visitor-keys: 3.4.3
+      espree: 9.6.1
+      esquery: 1.6.0
+      esutils: 2.0.3
+      fast-deep-equal: 3.1.3
+      file-entry-cache: 6.0.1
+      find-up: 5.0.0
+      glob-parent: 6.0.2
+      globals: 13.24.0
+      graphemer: 1.4.0
+      ignore: 5.3.2
+      imurmurhash: 0.1.4
+      is-glob: 4.0.3
+      is-path-inside: 3.0.3
+      js-yaml: 4.1.0
+      json-stable-stringify-without-jsonify: 1.0.1
+      levn: 0.4.1
+      lodash.merge: 4.6.2
+      minimatch: 3.1.2
+      natural-compare: 1.4.0
+      optionator: 0.9.4
+      strip-ansi: 6.0.1
+      text-table: 0.2.0
+    transitivePeerDependencies:
+      - supports-color
+
+  espree@9.6.1:
+    dependencies:
+      acorn: 8.14.0
+      acorn-jsx: 5.3.2(acorn@8.14.0)
+      eslint-visitor-keys: 3.4.3
+
+  esquery@1.6.0:
+    dependencies:
+      estraverse: 5.3.0
+
+  esrecurse@4.3.0:
+    dependencies:
+      estraverse: 5.3.0
+
+  estraverse@5.3.0: {}
+
+  esutils@2.0.3: {}
+
+  events@3.3.0: {}
+
+  fast-deep-equal@3.1.3: {}
+
+  fast-glob@3.3.3:
+    dependencies:
+      '@nodelib/fs.stat': 2.0.5
+      '@nodelib/fs.walk': 1.2.8
+      glob-parent: 5.1.2
+      merge2: 1.4.1
+      micromatch: 4.0.8
+
+  fast-json-stable-stringify@2.1.0: {}
+
+  fast-levenshtein@2.0.6: {}
+
+  fastq@1.19.1:
+    dependencies:
+      reusify: 1.1.0
+
+  fflate@0.8.2: {}
+
+  file-entry-cache@6.0.1:
+    dependencies:
+      flat-cache: 3.2.0
+
+  fill-range@7.1.1:
+    dependencies:
+      to-regex-range: 5.0.1
+
+  find-up@5.0.0:
+    dependencies:
+      locate-path: 6.0.0
+      path-exists: 4.0.0
+
+  flat-cache@3.2.0:
+    dependencies:
+      flatted: 3.3.3
+      keyv: 4.5.4
+      rimraf: 3.0.2
+
+  flatted@3.3.3: {}
+
+  fs.realpath@1.0.0: {}
+
+  fsevents@2.3.3:
+    optional: true
+
+  glob-parent@5.1.2:
+    dependencies:
+      is-glob: 4.0.3
+
+  glob-parent@6.0.2:
+    dependencies:
+      is-glob: 4.0.3
+
+  glob@7.2.3:
+    dependencies:
+      fs.realpath: 1.0.0
+      inflight: 1.0.6
+      inherits: 2.0.4
+      minimatch: 3.1.2
+      once: 1.4.0
+      path-is-absolute: 1.0.1
+
+  globals@13.24.0:
+    dependencies:
+      type-fest: 0.20.2
+
+  graphemer@1.4.0: {}
+
+  has-flag@4.0.0: {}
+
+  ignore@5.3.2: {}
+
+  import-fresh@3.3.1:
+    dependencies:
+      parent-module: 1.0.1
+      resolve-from: 4.0.0
+
+  imurmurhash@0.1.4: {}
+
+  inflight@1.0.6:
+    dependencies:
+      once: 1.4.0
+      wrappy: 1.0.2
+
+  inherits@2.0.4: {}
+
+  is-extglob@2.1.1: {}
+
+  is-glob@4.0.3:
+    dependencies:
+      is-extglob: 2.1.1
+
+  is-number@7.0.0: {}
+
+  is-path-inside@3.0.3: {}
+
+  isexe@2.0.0: {}
+
+  js-tokens@4.0.0: {}
+
+  js-yaml@4.1.0:
+    dependencies:
+      argparse: 2.0.1
+
+  json-buffer@3.0.1: {}
+
+  json-schema-traverse@0.4.1: {}
+
+  json-stable-stringify-without-jsonify@1.0.1: {}
+
+  keyv@4.5.4:
+    dependencies:
+      json-buffer: 3.0.1
+
+  levn@0.4.1:
+    dependencies:
+      prelude-ls: 1.2.1
+      type-check: 0.4.0
+
+  locate-path@6.0.0:
+    dependencies:
+      p-locate: 5.0.0
+
+  lodash.merge@4.6.2: {}
+
+  loose-envify@1.4.0:
+    dependencies:
+      js-tokens: 4.0.0
+
+  merge2@1.4.1: {}
+
+  meshoptimizer@0.18.1: {}
+
+  micromatch@4.0.8:
+    dependencies:
+      braces: 3.0.3
+      picomatch: 2.3.1
+
+  minimatch@3.1.2:
+    dependencies:
+      brace-expansion: 1.1.11
+
+  minimatch@9.0.5:
+    dependencies:
+      brace-expansion: 2.0.1
+
+  ms@2.1.3: {}
+
+  nanoid@3.3.8: {}
+
+  natural-compare@1.4.0: {}
+
+  nostr-tools@1.13.1:
+    dependencies:
+      '@noble/curves': 1.1.0
+      '@noble/hashes': 1.3.1
+      '@scure/base': 1.1.1
+      '@scure/bip32': 1.3.1
+      '@scure/bip39': 1.2.1
+
+  object-assign@4.1.1: {}
+
+  once@1.4.0:
+    dependencies:
+      wrappy: 1.0.2
+
+  optionator@0.9.4:
+    dependencies:
+      deep-is: 0.1.4
+      fast-levenshtein: 2.0.6
+      levn: 0.4.1
+      prelude-ls: 1.2.1
+      type-check: 0.4.0
+      word-wrap: 1.2.5
+
+  p-limit@3.1.0:
+    dependencies:
+      yocto-queue: 0.1.0
+
+  p-locate@5.0.0:
+    dependencies:
+      p-limit: 3.1.0
+
+  pako@2.1.0: {}
+
+  parent-module@1.0.1:
+    dependencies:
+      callsites: 3.1.0
+
+  path-exists@4.0.0: {}
+
+  path-is-absolute@1.0.1: {}
+
+  path-key@3.1.1: {}
+
+  picocolors@1.1.1: {}
+
+  picomatch@2.3.1: {}
+
+  postcss@8.5.3:
+    dependencies:
+      nanoid: 3.3.8
+      picocolors: 1.1.1
+      source-map-js: 1.2.1
+
+  prelude-ls@1.2.1: {}
+
+  prettier@3.5.3: {}
+
+  prop-types@15.8.1:
+    dependencies:
+      loose-envify: 1.4.0
+      object-assign: 4.1.1
+      react-is: 16.13.1
+
+  punycode@2.3.1: {}
+
+  queue-microtask@1.2.3: {}
+
+  react-dom@19.0.0(react@19.0.0):
+    dependencies:
+      react: 19.0.0
+      scheduler: 0.25.0
+
+  react-is@16.13.1: {}
+
+  react-is@19.0.0: {}
+
+  react-transition-group@4.4.5(react-dom@19.0.0(react@19.0.0))(react@19.0.0):
+    dependencies:
+      '@babel/runtime': 7.26.9
+      dom-helpers: 5.2.1
+      loose-envify: 1.4.0
+      prop-types: 15.8.1
+      react: 19.0.0
+      react-dom: 19.0.0(react@19.0.0)
+
+  react@19.0.0: {}
+
+  regenerator-runtime@0.14.1: {}
+
+  resolve-from@4.0.0: {}
+
+  reusify@1.1.0: {}
+
+  rimraf@3.0.2:
+    dependencies:
+      glob: 7.2.3
+
+  rollup@4.34.9:
+    dependencies:
+      '@types/estree': 1.0.6
+    optionalDependencies:
+      '@rollup/rollup-android-arm-eabi': 4.34.9
+      '@rollup/rollup-android-arm64': 4.34.9
+      '@rollup/rollup-darwin-arm64': 4.34.9
+      '@rollup/rollup-darwin-x64': 4.34.9
+      '@rollup/rollup-freebsd-arm64': 4.34.9
+      '@rollup/rollup-freebsd-x64': 4.34.9
+      '@rollup/rollup-linux-arm-gnueabihf': 4.34.9
+      '@rollup/rollup-linux-arm-musleabihf': 4.34.9
+      '@rollup/rollup-linux-arm64-gnu': 4.34.9
+      '@rollup/rollup-linux-arm64-musl': 4.34.9
+      '@rollup/rollup-linux-loongarch64-gnu': 4.34.9
+      '@rollup/rollup-linux-powerpc64le-gnu': 4.34.9
+      '@rollup/rollup-linux-riscv64-gnu': 4.34.9
+      '@rollup/rollup-linux-s390x-gnu': 4.34.9
+      '@rollup/rollup-linux-x64-gnu': 4.34.9
+      '@rollup/rollup-linux-x64-musl': 4.34.9
+      '@rollup/rollup-win32-arm64-msvc': 4.34.9
+      '@rollup/rollup-win32-ia32-msvc': 4.34.9
+      '@rollup/rollup-win32-x64-msvc': 4.34.9
+      fsevents: 2.3.3
+
+  run-parallel@1.2.0:
+    dependencies:
+      queue-microtask: 1.2.3
+
+  scheduler@0.25.0: {}
+
+  semver@7.7.1: {}
+
+  shebang-command@2.0.0:
+    dependencies:
+      shebang-regex: 3.0.0
+
+  shebang-regex@3.0.0: {}
+
+  source-map-js@1.2.1: {}
+
+  source-map-support@0.5.21:
+    dependencies:
+      buffer-from: 1.1.2
+      source-map: 0.6.1
+
+  source-map@0.6.1: {}
+
+  strip-ansi@6.0.1:
+    dependencies:
+      ansi-regex: 5.0.1
+
+  strip-json-comments@3.1.1: {}
+
+  stylis@4.2.0: {}
+
+  supports-color@7.2.0:
+    dependencies:
+      has-flag: 4.0.0
+
+  terser@5.39.0:
+    dependencies:
+      '@jridgewell/source-map': 0.3.6
+      acorn: 8.14.0
+      commander: 2.20.3
+      source-map-support: 0.5.21
+
+  text-table@0.2.0: {}
+
+  three@0.174.0: {}
+
+  to-regex-range@5.0.1:
+    dependencies:
+      is-number: 7.0.0
+
+  ts-api-utils@2.0.1(typescript@5.4.5):
+    dependencies:
+      typescript: 5.4.5
+
+  type-check@0.4.0:
+    dependencies:
+      prelude-ls: 1.2.1
+
+  type-fest@0.20.2: {}
+
+  typescript@5.4.5: {}
+
+  undici-types@6.20.0: {}
+
+  uri-js@4.4.1:
+    dependencies:
+      punycode: 2.3.1
+
+  vite@5.4.14(@types/node@22.13.9)(terser@5.39.0):
+    dependencies:
+      esbuild: 0.21.5
+      postcss: 8.5.3
+      rollup: 4.34.9
+    optionalDependencies:
+      '@types/node': 22.13.9
+      fsevents: 2.3.3
+      terser: 5.39.0
+
+  which@2.0.2:
+    dependencies:
+      isexe: 2.0.0
+
+  word-wrap@1.2.5: {}
+
+  wrappy@1.0.2: {}
+
+  yocto-queue@0.1.0: {}
diff --git a/scripts/debug.sh b/scripts/debug.sh
new file mode 100644
index 00000000..797e58f3
--- /dev/null
+++ b/scripts/debug.sh
@@ -0,0 +1,43 @@
+#!/bin/bash
+
+# Colors for output
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+NC='\033[0m'
+
+# Function to show logs
+show_logs() {
+    echo -e "${YELLOW}=== Container Logs ===${NC}"
+    docker logs logseq-xr-webxr
+
+    echo -e "\n${YELLOW}=== Application Logs ===${NC}"
+    docker exec logseq-xr-webxr cat /app/webxr.log
+
+    echo -e "\n${YELLOW}=== Environment Variables ===${NC}"
+    docker exec logseq-xr-webxr env
+
+    echo -e "\n${YELLOW}=== Directory Structure ===${NC}"
+    docker exec logseq-xr-webxr ls -la /app/data/markdown
+    docker exec logseq-xr-webxr ls -la /app/data/metadata
+
+    echo -e "\n${YELLOW}=== Metadata Content ===${NC}"
+    docker exec logseq-xr-webxr cat /app/data/metadata/metadata.json
+
+    echo -e "\n${YELLOW}=== GitHub API Test ===${NC}"
+    docker exec logseq-xr-webxr curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
+        "https://api.github.com/repos/$GITHUB_OWNER/$GITHUB_REPO/contents/$GITHUB_BASE_PATH"
+}
+
+# Function to check endpoints
+check_endpoints() {
+    echo -e "${YELLOW}=== Testing Endpoints ===${NC}"
+    curl -v http://localhost:4000/api/graph/data
+    echo -e "\n"
+    curl -v http://localhost:4000/api/files/fetch
+}
+
+# Main debug flow
+echo -e "${GREEN}Starting debug process...${NC}"
+show_logs
+check_endpoints 
\ No newline at end of file
diff --git a/scripts/generateCodebase.sh b/scripts/generateCodebase.sh
new file mode 100755
index 00000000..52c7e1f9
--- /dev/null
+++ b/scripts/generateCodebase.sh
@@ -0,0 +1,133 @@
+#!/bin/bash
+
+# Path to the export repository relative to this script
+EXPORT_REPO="/mnt/mldata/githubs/export-repository-to-prompt-for-llm"
+
+# Activate virtual environment and ensure we deactivate it even if script fails
+activate_venv() {
+    source "$EXPORT_REPO/venv/bin/activate"
+}
+
+
+# Export Docker and deployment configuration
+export_docker_config() {
+    # Add project metadata
+    echo -e "# Project Codebase\n" >> codebase.txt
+    echo -e "Generated: $(date)\n" >> codebase.txt
+    echo -e "## Project Structure\n" >> codebase.txt
+    echo -e "- Server: Rust (src directory)\n- Client: TypeScript (client directory)\n" >> codebase.txt
+
+    echo -e "\n## README.md\n" >> codebase.txt
+    cat ../README.md >> codebase.txt
+
+    echo -e "\n\n## Docker Configuration\n" >> codebase.txt
+    
+    # Add each file with proper headers
+    for file in "../docker-compose.yml" "../Dockerfile" "../nginx.conf" "../settings.yaml" "../.dockerignore"; do
+        if [ -f "$file" ]; then
+            echo -e "\n### $(basename $file)\n" >> codebase.txt
+            cat "$file" >> codebase.txt
+        else
+            echo -e "\n### $(basename $file) - MISSING\n" >> codebase.txt
+        fi
+    done
+
+    # Add package management and config files
+    echo -e "\n\n## Configuration Files\n" >> codebase.txt
+    for file in "../Cargo.toml" "../client/package.json" "../vite.config.ts" "../.env.template" \
+                "../tsconfig.json" "../.eslintrc" "../.gitignore" \
+                "../client/tsconfig.json" "../scripts/launch-docker.sh" "../scripts/start.sh"; do
+        if [ -f "$file" ]; then
+            echo -e "\n### $(basename $file)\n" >> codebase.txt
+            cat "$file" >> codebase.txt
+        else
+            echo -e "\n### $(basename $file) - MISSING\n" >> codebase.txt
+        fi
+    done
+
+    # Export docker directory if it exists
+    if [ -d "../docker" ]; then
+        echo -e "\n\n## Docker Directory Contents\n" >> codebase.txt
+        for file in ../docker/*; do
+            if [ -f "$file" ]; then
+                echo -e "\n### docker/$(basename $file)\n" >> codebase.txt
+                cat "$file" >> codebase.txt
+            fi
+        done
+    fi
+}
+
+# Export Docker network information
+export_network_info() {
+    echo -e "\n\n=== Docker Network Configuration ===\n" >> codebase.txt
+    echo -e "\n--- docker network inspect docker_ragflow ---\n" >> codebase.txt
+    docker network inspect docker_ragflow >> codebase.txt 2>/dev/null || echo "Unable to fetch network info - docker daemon not running or network doesn't exist" >> codebase.txt
+}
+
+# Export both directories and combine them
+export_and_combine() {
+    # Export server (src) code
+    python "$EXPORT_REPO/export-repository-to-file.py" "../src"
+    mv output.txt server.txt
+
+    # Export client code
+    python "$EXPORT_REPO/export-repository-to-file.py" "../client"
+    mv output.txt client.txt
+
+    # Export docs code
+    python "$EXPORT_REPO/export-repository-to-file.py" "../docs"
+    mv output.txt docs.txt
+
+    # Combine files with clear separation
+    echo -e "\n\n## Server Code (Rust)\n" >> codebase.txt
+    cat server.txt >> codebase.txt
+    
+    echo -e "\n\n## Client Code (TypeScript)\n" >> codebase.txt
+    cat client.txt >> codebase.txt
+    
+    echo -e "\n\n## Documentation\n" >> codebase.txt
+    cat docs.txt >> codebase.txt
+    
+    rm server.txt
+    rm client.txt
+    rm docs.txt
+}
+
+# Add project structure information
+export_project_structure() {
+    echo -e "\n## Project Structure Tree\n" >> codebase.txt
+    echo -e "\`\`\`" >> codebase.txt
+    # Show root level files
+    echo "Root files:" >> codebase.txt
+    ls -p ../ | grep -v / >> codebase.txt
+    echo -e "\nDirectories:" >> codebase.txt
+    # Show client, src, and docs directories structure
+    tree -I 'node_modules|target|dist|.git|venv' ../client ../src ../docs >> codebase.txt
+    echo -e "\`\`\`\n" >> codebase.txt
+}
+
+# Main execution
+if [ ! -d "$EXPORT_REPO" ]; then
+    echo "Error: Export repository not found at $EXPORT_REPO"
+    exit 1
+fi
+
+if [ ! -d "$EXPORT_REPO/venv" ]; then
+    echo "Error: Virtual environment not found at $EXPORT_REPO/venv"
+    exit 1
+fi
+
+# Execute the export process
+activate_venv
+
+# Add Docker configuration and network info
+export_project_structure
+export_docker_config
+export_network_info
+
+export_and_combine
+deactivate
+
+
+
+echo "Successfully generated codebase.txt with Docker configuration and network info"
diff --git a/scripts/launch-docker.sh b/scripts/launch-docker.sh
new file mode 100755
index 00000000..5219e548
--- /dev/null
+++ b/scripts/launch-docker.sh
@@ -0,0 +1,526 @@
+#!/usr/bin/env bash
+
+###############################################################################
+# SAFETY SETTINGS
+###############################################################################
+# -e  Exit on any command returning a non-zero status
+# -u  Treat unset variables as errors
+# -o pipefail  Return error if any part of a pipeline fails
+set -euo pipefail
+
+###############################################################################
+# DETECT SCRIPT & PROJECT ROOT
+###############################################################################
+SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"
+
+###############################################################################
+# COLOR CONSTANTS
+###############################################################################
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+NC='\033[0m'  # No color
+
+###############################################################################
+# DATA PATHS
+###############################################################################
+MARKDOWN_DIR="$PROJECT_ROOT/data/markdown"
+METADATA_DIR="$PROJECT_ROOT/data/metadata"
+METADATA_FILE="$METADATA_DIR/metadata.json"
+
+###############################################################################
+# LOGGING & EXIT HANDLING
+###############################################################################
+log() {
+    # Logs a message with a timestamp
+    echo -e "[$(date "+%Y-%m-%d %H:%M:%S")] $1"
+}
+
+handle_exit() {
+    # Called when the script receives a signal (Ctrl+C, kill, etc.)
+    log "\n${YELLOW}Exiting to shell. Containers will continue running.${NC}"
+    exit 0
+}
+
+# Trap Ctrl+C, kill, etc. so we can exit gracefully
+trap handle_exit INT TERM
+
+###############################################################################
+# CHECKS & VALIDATIONS
+###############################################################################
+
+check_environment() {
+    # Validate required env vars and GitHub token
+    log "${YELLOW}Checking environment variables...${NC}"
+
+    local required_vars=(
+        "GITHUB_TOKEN"
+        "GITHUB_OWNER"
+        "GITHUB_REPO"
+        "GITHUB_BASE_PATH"
+    )
+
+    for var in "${required_vars[@]}"; do
+        if [ -z "${!var:-}" ]; then
+            log "${RED}Error: $var is not set in .env file${NC}"
+            return 1
+        fi
+    done
+
+    # Check GitHub token access
+    if ! curl -s -H "Authorization: token $GITHUB_TOKEN" \
+        "https://api.github.com/repos/$GITHUB_OWNER/$GITHUB_REPO" >/dev/null; then
+        log "${RED}Error: Invalid GitHub token or repository access${NC}"
+        return 1
+    fi
+
+    log "${GREEN}Environment check passed${NC}"
+    return 0
+}
+
+check_pnpm_security() {
+    log "${YELLOW}Running pnpm security audit...${NC}"
+
+    # Run and capture the audit output
+    local audit_output
+    audit_output=$(pnpm audit 2>&1 || true)
+    local audit_exit=$?
+
+    # Extract critical vulnerabilities count
+    local critical_count
+    critical_count=$(echo "$audit_output" | grep -i "critical" \
+                                    | grep -o '[0-9]\+ vulnerabilities' \
+                                    | awk '{print $1}')
+    critical_count=${critical_count:-0}
+
+    # Display the audit output
+    echo "$audit_output"
+
+    if [ "$critical_count" -gt 0 ]; then
+        log "${RED}Found $critical_count critical vulnerabilities!${NC}"
+        return 1
+    elif [ "$audit_exit" -ne 0 ]; then
+        log "${YELLOW}Found non-critical vulnerabilities${NC}"
+    else
+        log "${GREEN}No critical vulnerabilities found${NC}"
+    fi
+
+    return 0
+}
+
+check_typescript() {
+    log "${YELLOW}Running TypeScript type check...${NC}"
+    if ! pnpm run type-check; then
+        log "${RED}TypeScript check failed${NC}"
+        log "${YELLOW}Containers will be left running for debugging${NC}"
+        return 1
+    fi
+    log "${GREEN}TypeScript check passed${NC}"
+    return 0
+}
+
+check_rust_security() {
+    log "${YELLOW}Running cargo audit...${NC}"
+
+    local audit_output
+    audit_output=$(cargo audit 2>&1 || true)
+    local audit_exit=$?
+
+    local critical_count
+    critical_count=$(echo "$audit_output" | grep -i "critical" | wc -l)
+    critical_count=${critical_count:-0}
+
+    echo "$audit_output"
+
+    if [ "$critical_count" -gt 0 ]; then
+        log "${RED}Found $critical_count critical vulnerabilities!${NC}"
+        return 1
+    elif [ "$audit_exit" -ne 0 ]; then
+        log "${YELLOW}Found non-critical vulnerabilities${NC}"
+    else
+        log "${GREEN}No critical vulnerabilities found${NC}"
+    fi
+
+    return 0
+}
+
+read_settings() {
+    # Read domain & port from settings.yaml using yq
+    local settings_file="$PROJECT_ROOT/settings.yaml"
+
+    if [ ! -f "$settings_file" ]; then
+        log "${RED}Error: settings.yaml not found${NC}"
+        return 1
+    fi
+
+    # Check if yq is installed
+    if ! command -v yq &>/dev/null; then
+        log "${RED}Error: yq is not installed. Please install yq to parse YAML files.${NC}"
+        return 1
+    fi
+
+    # Extract domain and port using yq
+    DOMAIN=$(yq eval '.system.network.domain' "$settings_file")
+    export DOMAIN
+
+    PORT=$(yq eval '.system.network.port' "$settings_file")
+    export PORT
+
+    if [ -z "${DOMAIN:-}" ] || [ -z "${PORT:-}" ] || [ "$DOMAIN" = "null" ] || [ "$PORT" = "null" ]; then
+        log "${RED}Error: DOMAIN or PORT not set in settings.yaml. Check your configuration.${NC}"
+        return 1
+    fi
+}
+
+check_system_resources() {
+    log "${YELLOW}Checking GPU availability...${NC}"
+    if ! command -v nvidia-smi &>/dev/null; then
+        log "${RED}Error: nvidia-smi not found${NC}"
+        return 1
+    fi
+
+    local gpu_info
+    gpu_info=$(nvidia-smi --query-gpu=memory.used,memory.total --format=csv,noheader)
+    echo "$gpu_info"
+
+    local has_enough_memory=false
+    while IFS=, read -r used total; do
+        used=$(echo "$used" | tr -d ' MiB')
+        total=$(echo "$total" | tr -d ' MiB')
+        local free=$((total - used))
+        if [ "$free" -gt 4096 ]; then
+            has_enough_memory=true
+            break
+        fi
+    done <<< "$gpu_info"
+
+    if [ "$has_enough_memory" = false ]; then
+        log "${RED}Error: No GPU with at least 4GB free memory${NC}"
+        return 1
+    fi
+}
+
+check_dependencies() {
+    # Check Docker
+    if ! command -v docker &>/dev/null; then
+        log "${RED}Error: Docker is not installed${NC}"
+        return 1
+    fi
+
+    # Try Docker Compose v2 first, fallback to v1
+    if docker compose version &>/dev/null; then
+        DOCKER_COMPOSE="docker compose"
+    elif docker-compose version &>/dev/null; then
+        DOCKER_COMPOSE="docker-compose"
+    else
+        log "${RED}Error: Docker Compose not found${NC}"
+        return 1
+    fi
+
+    # Check yq
+    if ! command -v yq &>/dev/null; then
+        log "${RED}Error: yq is not installed${NC}"
+        log "${YELLOW}Please install yq to parse YAML files:${NC}"
+        log "${YELLOW}On Ubuntu/Debian: sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq && sudo chmod +x /usr/bin/yq${NC}"
+        log "${YELLOW}On macOS: brew install yq${NC}"
+        log "${YELLOW}On other systems, visit: https://github.com/mikefarah/yq#install${NC}"
+        return 1
+    fi
+}
+
+verify_client_structure() {
+    log "${YELLOW}Verifying client directory structure...${NC}"
+
+    local required_files=(
+        "$PROJECT_ROOT/client/index.html"
+        "$PROJECT_ROOT/client/index.ts"
+        "$PROJECT_ROOT/client/core/types.ts"
+        "$PROJECT_ROOT/client/core/constants.ts"
+        "$PROJECT_ROOT/client/core/utils.ts"
+        "$PROJECT_ROOT/client/core/logger.ts"
+        "$PROJECT_ROOT/client/websocket/websocketService.ts"
+        "$PROJECT_ROOT/client/rendering/scene.ts"
+        "$PROJECT_ROOT/client/rendering/node/geometry/NodeGeometryManager.ts"
+        "$PROJECT_ROOT/client/rendering/textRenderer.ts"
+        "$PROJECT_ROOT/client/state/settings.ts"
+        "$PROJECT_ROOT/client/state/graphData.ts"
+        "$PROJECT_ROOT/client/state/defaultSettings.ts"
+        "$PROJECT_ROOT/client/xr/xrSessionManager.ts"
+        "$PROJECT_ROOT/client/xr/xrInteraction.ts"
+        "$PROJECT_ROOT/client/xr/xrTypes.ts"
+        "$PROJECT_ROOT/client/platform/platformManager.ts"
+        "$PROJECT_ROOT/client/tsconfig.json"
+    )
+
+    for file in "${required_files[@]}"; do
+        if [ ! -f "$file" ]; then
+            log "${RED}Error: Required file $file not found${NC}"
+            return 1
+        fi
+    done
+
+    log "${GREEN}Client directory structure verified${NC}"
+    return 0
+}
+
+check_ragflow_network() {
+    log "${YELLOW}Checking RAGFlow network availability...${NC}"
+    if ! docker network ls | grep -q "docker_ragflow"; then
+        log "${RED}Error: RAGFlow network (docker_ragflow) not found${NC}"
+        log "${YELLOW}Please ensure RAGFlow is running in ../ragflow/docker${NC}"
+        log "${YELLOW}You can check the network with: docker network ls${NC}"
+        return 1
+    fi
+    log "${GREEN}RAGFlow network is available${NC}"
+    return 0
+}
+
+check_kokoros() {
+    log "${YELLOW}Checking Kokoros TTS service...${NC}"
+    if ! docker ps --format '{{.Names}}' | grep -q "^kokoros$"; then
+        log "${YELLOW}Kokoros container not running, starting it...${NC}"
+        if ! docker run -d -p 4001:4001 --network docker_ragflow --name kokoros kokoros openai; then
+            log "${RED}Failed to start Kokoros container${NC}"
+            return 1
+        fi
+        log "${GREEN}Kokoros container started successfully${NC}"
+    else
+        log "${GREEN}Kokoros container is already running${NC}"
+    fi
+    return 0
+}
+
+check_application_readiness() {
+    local max_attempts=60
+    local attempt=1
+    local wait_secs=2
+
+    log "${YELLOW}Checking application readiness...${NC}"
+
+    while [ "$attempt" -le "$max_attempts" ]; do
+        local ready=true
+        local status_msg=""
+
+        # Simple container running check instead of health check
+        if ! docker ps --format '{{.Names}}' | grep -q "^logseq-xr-webxr$"; then
+            ready=false
+            status_msg="Container not running"
+        fi
+
+        # Basic HTTP check
+        if [ "$ready" = true ] && ! timeout 5 curl -s http://localhost:4000/ >/dev/null; then
+            ready=false
+            status_msg="HTTP endpoint not ready"
+        fi
+
+        # Process check inside container (more reliable than health check)
+        if [ "$ready" = true ]; then
+            if ! docker exec logseq-xr-webxr pgrep -f "node" >/dev/null; then
+                ready=false
+                status_msg="Node process not running in container"
+            fi
+        fi
+
+        if [ "$ready" = true ]; then
+            log "${GREEN}All services are ready${NC}"
+            return 0
+        fi
+
+        log "${YELLOW}Attempt $attempt/$max_attempts: $status_msg${NC}"
+
+        if [ "$attempt" -eq $((max_attempts / 2)) ]; then
+            log "${YELLOW}Still waiting for services. Recent logs:${NC}"
+            $DOCKER_COMPOSE logs --tail=20
+        fi
+
+        sleep "$wait_secs"
+        attempt=$((attempt + 1))
+    done
+
+    log "${RED}Application failed to start properly${NC}"
+    $DOCKER_COMPOSE logs
+    return 1
+}
+###############################################################################
+# COMMAND LINE ARGUMENTS
+###############################################################################
+REBUILD_TEST=false
+DEBUG_MODE=false
+
+# Parse command line arguments
+for arg in "$@"; do
+    case $arg in
+        rebuild-test)
+            REBUILD_TEST=true
+            shift # Remove from processing
+            ;;
+        --debug)
+            DEBUG_MODE=true
+            shift # Remove from processing
+            ;;
+    esac
+done
+
+###############################################################################
+# MAIN EXECUTION
+###############################################################################
+cd "$PROJECT_ROOT"
+
+
+# 1. Ensure .env exists
+if [ ! -f .env ]; then
+    log "${RED}Error: .env file not found in $PROJECT_ROOT${NC}"
+    exit 1
+fi
+
+# 2. Source environment variables
+set -a
+source .env
+set +a
+
+# 3. Read settings from TOML (non-fatal if it fails, to allow debugging)
+read_settings || {
+    log "${YELLOW}Settings read failed - continuing for debugging${NC}"
+}
+
+# 4. Check dependencies (Docker and yq)
+check_dependencies || {
+    log "${RED}Dependency check failed${NC}"
+    exit 1
+}
+
+# 5. GPU resources (non-fatal if it fails)
+check_system_resources || {
+    log "${YELLOW}System resources check failed - continuing for debugging${NC}"
+}
+
+# Set NVIDIA GPU UUID explicitly to the known working value
+log "${YELLOW}Setting GPU UUID...${NC}"
+
+# Use the specific GPU UUID we know works
+NVIDIA_GPU_UUID="GPU-553dc306-dab3-32e2-c69b-28175a6f4da6"
+export NVIDIA_GPU_UUID
+export NVIDIA_VISIBLE_DEVICES="$NVIDIA_GPU_UUID"
+log "${GREEN}GPU UUID configured as: ${NVIDIA_GPU_UUID:-not set}${NC}"
+
+# 6. Verify client directory structure (non-fatal if it fails)
+if ! verify_client_structure; then
+    log "${RED}Client structure verification failed${NC}"
+    log "${YELLOW}Continuing for debugging${NC}"
+fi
+
+# 7. Security checks
+log "\n${YELLOW}Running security checks...${NC}"
+check_pnpm_security || true
+check_typescript || {
+    log "${YELLOW}TypeScript check failed - continuing for debugging${NC}"
+}
+check_rust_security || true
+
+# 10. Environment & GitHub token check (non-fatal)
+if ! check_environment; then
+    log "${YELLOW}Environment check failed - continuing for debugging${NC}"
+fi
+
+# 10. Build & start containers
+log "${YELLOW}Building and starting services...${NC}"
+
+# Clean up existing containers
+log "${YELLOW}Cleaning up existing containers...${NC}"
+
+# Get container IDs for our specific containers
+cloudflared_id=$(docker ps -aq --filter "name=cloudflared-tunnel")
+webxr_id=$(docker ps -aq --filter "name=logseq-xr-webxr")
+
+# Stop and remove cloudflared container if it exists
+if [ -n "$cloudflared_id" ]; then
+    log "${YELLOW}Stopping cloudflared container $cloudflared_id...${NC}"
+    docker stop "$cloudflared_id"
+    docker rm "$cloudflared_id"
+fi
+
+# Stop and remove webxr container if it exists
+if [ -n "$webxr_id" ]; then
+    log "${YELLOW}Stopping webxr container $webxr_id...${NC}"
+    docker stop "$webxr_id"
+    docker rm "$webxr_id"
+fi
+
+# If in rebuild-test mode, do additional cleanup
+if [ "$REBUILD_TEST" = true ]; then
+    log "${YELLOW}Rebuild-test mode: Performing additional cleanup...${NC}"
+    docker system prune -f
+fi
+
+# Get current git hash or use "development" if not in a git repo
+GIT_HASH=$(git rev-parse HEAD 2>/dev/null || echo "development")
+export GIT_HASH
+
+# Compile CUDA to PTX
+log "${YELLOW}Compiling CUDA to PTX...${NC}"
+if ! command -v nvcc &>/dev/null; then
+    log "${RED}Error: NVIDIA CUDA Compiler (nvcc) not found${NC}"
+    log "${YELLOW}Please install CUDA toolkit to compile PTX files${NC}"
+    exit 1
+fi
+
+# Use CUDA_ARCH from .env or default to 89 (Ada)
+CUDA_ARCH=${CUDA_ARCH:-89}
+log "${YELLOW}Compiling CUDA to PTX for sm_${CUDA_ARCH}...${NC}"
+
+if ! nvcc \
+    -arch=sm_${CUDA_ARCH} \
+    -O3 \
+    --use_fast_math \
+    -ptx \
+    -rdc=true \
+    --compiler-options -fPIC \
+    src/utils/compute_forces.cu \
+    -o src/utils/compute_forces.ptx \
+    --compiler-bindir=/usr/bin/gcc-11; then
+    log "${RED}Failed to compile CUDA to PTX${NC}"
+    true
+else
+    log "${YELLOW}Setting PTX file permissions...${NC}"
+    chmod 644 src/utils/compute_forces.ptx
+fi
+log "${YELLOW}Building client code...${NC}"
+pnpm build || { log "${RED}Client build failed${NC}"; exit 1; }
+log "${GREEN}Client build successful${NC}"
+
+# Build with GIT_HASH environment variable
+log "${YELLOW}Building Docker containers (passing NVIDIA_GPU_UUID=${NVIDIA_GPU_UUID:-not set})${NC}"
+DEBUG_MODE=$DEBUG_MODE GIT_HASH=$GIT_HASH $DOCKER_COMPOSE build --pull --no-cache
+$DOCKER_COMPOSE up -d
+
+# 11. Check readiness (fatal if fails)
+if ! check_application_readiness; then
+    log "${RED}Application failed to start properly${NC}"
+    log "${YELLOW}Containers left running for debugging. Use these commands:${NC}"
+    log "  $DOCKER_COMPOSE logs -f"
+    log "  docker logs logseq-xr-webxr"
+    log "  docker logs cloudflared-tunnel"
+    exit 1
+fi
+
+# 12. Final status
+log "\n${GREEN} Services are running!${NC}"
+
+log "\nResource Usage:"
+docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
+
+log "\nEndpoints:"
+echo "HTTP:      http://localhost:4000"
+echo "WebSocket: ws://localhost:4000/wss"
+
+log "\nCommands:"
+echo "logs:    $DOCKER_COMPOSE logs -f"
+echo "stop:    $DOCKER_COMPOSE down"
+echo "restart: $DOCKER_COMPOSE restart"
+
+# 13. Show logs in background, wait for them
+log "\n${YELLOW}Showing logs (Ctrl+C to exit)...${NC}"
+$DOCKER_COMPOSE logs -f &
+
+wait
diff --git a/scripts/start.sh b/scripts/start.sh
new file mode 100755
index 00000000..463e1ac9
--- /dev/null
+++ b/scripts/start.sh
@@ -0,0 +1,71 @@
+#!/bin/bash
+set -euo pipefail
+
+# Function to log messages with timestamps
+log() {
+    echo "[$(date "+%Y-%m-%d %H:%M:%S")] $1"
+}
+
+# Check for GPU environment variables
+log "Checking GPU environment variables..."
+
+if [ -z "${NVIDIA_GPU_UUID:-}" ]; then
+    # Use the specific GPU UUID that we know works
+    NVIDIA_GPU_UUID="GPU-553dc306-dab3-32e2-c69b-28175a6f4da6"
+    log "Setting NVIDIA_GPU_UUID to known value: $NVIDIA_GPU_UUID"
+    export NVIDIA_GPU_UUID
+    
+    # Also set NVIDIA_VISIBLE_DEVICES to ensure Docker uses this GPU
+    if [ -z "${NVIDIA_VISIBLE_DEVICES:-}" ]; then
+        export NVIDIA_VISIBLE_DEVICES="$NVIDIA_GPU_UUID"
+        log "Setting NVIDIA_VISIBLE_DEVICES to: $NVIDIA_VISIBLE_DEVICES"
+    fi
+    
+    # For older CUDA versions, also set CUDA_VISIBLE_DEVICES
+    if [ -z "${CUDA_VISIBLE_DEVICES:-}" ]; then
+        # Use device index 0 since NVIDIA_VISIBLE_DEVICES will map to this
+        export CUDA_VISIBLE_DEVICES="0"
+        log "Setting CUDA_VISIBLE_DEVICES to: $CUDA_VISIBLE_DEVICES"
+    fi
+else
+    log "Using GPU UUID: $NVIDIA_GPU_UUID"
+fi
+
+# Parse command line arguments
+START_WEBXR=true
+if [ $# -gt 0 ] && [ "$1" = "--no-webxr" ]; then
+    START_WEBXR=false
+fi
+
+# Verify settings file permissions
+log "Verifying settings.yaml permissions..."
+if [ ! -f "/app/settings.yaml" ]; then
+    log "Error: settings.yaml not found"
+    exit 1
+fi
+chmod 666 /app/settings.yaml
+log "settings.yaml permissions verified"
+
+# Set up runtime environment
+# Start nginx
+log "Starting nginx..."
+nginx -t && nginx
+log "nginx started successfully"
+
+# Execute the webxr binary only if not in debug mode
+if [ "$START_WEBXR" = true ]; then
+    log "Executing webxr..."
+    log "GPU information:"
+    if command -v nvidia-smi &>/dev/null; then
+        nvidia-smi
+    else
+        log "nvidia-smi not available"
+    fi
+    # Always enable GPU debugging to ensure physics simulation runs
+    log "Starting webxr with GPU compute enabled"
+    exec /app/webxr --gpu-debug
+else
+    log "Skipping webxr execution (debug mode)"
+    # Keep the container running
+    tail -f /dev/null
+fi
\ No newline at end of file
diff --git a/scripts/test_endpoints.sh b/scripts/test_endpoints.sh
new file mode 100755
index 00000000..baf014e4
--- /dev/null
+++ b/scripts/test_endpoints.sh
@@ -0,0 +1,381 @@
+#!/usr/bin/env bash
+
+# ------------------------------------------------------------------------------
+# Best Practice Refactored Test Script with Dotenv Loading
+# ------------------------------------------------------------------------------
+# - Each test function returns 0 for success, 1 for failure.
+# - The main function accumulates test results, prints a summary,
+#   and exits with the final code.
+# - Loads GitHub credentials from a .env file located in the parent or current directory.
+# ------------------------------------------------------------------------------
+
+set -Eeuo pipefail  # Safer defaults; won't auto-exit on single command failure
+
+# For debugging/troubleshooting (optional):
+trap 'echo -e "\n[ERROR] Script encountered an error at line $LINENO." >&2' ERR
+
+# ------------------------------------------------------------------------------
+# Constants & Variables
+# ------------------------------------------------------------------------------
+SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+
+# Color definitions
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+MAGENTA='\033[0;35m'
+CYAN='\033[0;36m'
+GRAY='\033[0;90m'
+BOLD='\033[1m'
+NC='\033[0m' # No Color
+
+# Other configuration
+BACKEND_PORT=3001
+NGINX_PORT=4000
+CONTAINER_NAME="logseq-xr-webxr"
+PUBLIC_DOMAIN="www.visionflow.info"
+RAGFLOW_NETWORK="docker_ragflow"
+VERBOSE=true
+LOG_DIR="logs"
+LOG_FILE="${LOG_DIR}/test_$(date +%Y%m%d_%H%M%S).log"
+TIMEOUT=5
+
+# ------------------------------------------------------------------------------
+# Load Dotenv Credentials for GitHub
+# ------------------------------------------------------------------------------
+if [ -f "../.env" ]; then
+    set -a
+    source "../.env"
+    set +a
+elif [ -f ".env" ]; then
+    set -a
+    source ".env"
+    set +a
+else
+    echo -e "${RED}Error: .env file not found in parent or current directory${NC}"
+    exit 1
+fi
+
+# Verify required GitHub variables are loaded
+if [ -z "$GITHUB_TOKEN" ] || [ -z "$GITHUB_OWNER" ] || [ -z "$GITHUB_REPO" ]; then
+    echo -e "${YELLOW}Warning: Some GitHub credentials are missing in .env file${NC}"
+    echo "Required variables:"
+    echo "GITHUB_TOKEN: ${GITHUB_TOKEN:-not set}"
+    echo "GITHUB_OWNER: ${GITHUB_OWNER:-not set}"
+    echo "GITHUB_REPO: ${GITHUB_REPO:-not set}"
+fi
+
+# ------------------------------------------------------------------------------
+# Logging Helpers
+# ------------------------------------------------------------------------------
+mkdir -p "$LOG_DIR"
+
+log() {
+  echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_FILE"
+}
+
+log_verbose() {
+  if [ "$VERBOSE" = true ]; then
+    echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} ${CYAN}${NC} $1" | tee -a "$LOG_FILE"
+  fi
+}
+
+log_error() {
+  echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} ${RED} ERROR:${NC} $1" | tee -a "$LOG_FILE"
+}
+
+log_success() {
+  echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} ${GREEN}${NC} $1" | tee -a "$LOG_FILE"
+}
+
+log_message() {
+  echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_FILE"
+}
+
+log_section() {
+  echo -e "\n${BLUE}${BOLD}=== $1 ===${NC}\n" | tee -a "$LOG_FILE"
+}
+
+# ------------------------------------------------------------------------------
+# Command-Line Args
+# ------------------------------------------------------------------------------
+SKIP_GITHUB=false
+SKIP_WEBSOCKET=false
+TEST_SETTINGS_ONLY=false
+
+while [[ "$#" -gt 0 ]]; do
+  case $1 in
+    -v|--verbose) VERBOSE=true ;;
+    --skip-github) SKIP_GITHUB=true ;;
+    --skip-websocket) SKIP_WEBSOCKET=true ;;
+    --settings-only) TEST_SETTINGS_ONLY=true ;;
+    --help)
+      echo "Usage: $0 [-v|--verbose] [--skip-github] [--skip-websocket] [--settings-only] [--help]"
+      exit 0
+      ;;
+    *)
+      echo "Unknown parameter: $1"
+      exit 1
+      ;;
+  esac
+  shift
+done
+
+# ------------------------------------------------------------------------------
+# GitHub API Helper Function
+# ------------------------------------------------------------------------------
+check_github_file() {
+  local file="$1"
+  local encoded_path
+  encoded_path=$(echo -n "$file" | jq -sRr @uri)
+
+  # Fetch file metadata from GitHub
+  local response
+  response=$(curl -s --max-time "${TIMEOUT}" \
+      -H "Authorization: Bearer ${GITHUB_TOKEN}" \
+      -H "Accept: application/vnd.github+json" \
+      "https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${encoded_path}" || true)
+
+  if [ -z "$response" ]; then
+      log_error "GitHub API: No response for file ${file}"
+      return 1
+  fi
+
+  if echo "$response" | jq -e 'has("message")' >/dev/null 2>&1; then
+      local error_msg
+      error_msg=$(echo "$response" | jq -r '.message')
+      log_error "GitHub API: Error for file ${file}: ${error_msg}"
+      return 1
+  fi
+
+  # Optionally, fetch commit history for the file
+  local commits_response
+  commits_response=$(curl -s --max-time "${TIMEOUT}" \
+      -H "Authorization: Bearer ${GITHUB_TOKEN}" \
+      -H "Accept: application/vnd.github+json" \
+      "https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/commits?path=${encoded_path}" || true)
+
+  if [ -z "$commits_response" ]; then
+      log_error "GitHub API: No commit history for file ${file}"
+      return 1
+  fi
+
+  if echo "$commits_response" | jq -e 'has("message")' >/dev/null 2>&1; then
+      local error_msg
+      error_msg=$(echo "$commits_response" | jq -r '.message')
+      log_error "GitHub API: Error fetching commits for file ${file}: ${error_msg}"
+      return 1
+  fi
+
+  local commit_count
+  commit_count=$(echo "$commits_response" | jq -r 'length')
+
+  log_success "GitHub file check passed for ${file} (Commits: ${commit_count})"
+  return 0
+}
+
+# ------------------------------------------------------------------------------
+# Test Functions
+# ------------------------------------------------------------------------------
+
+check_container_health() {
+  # Returns 0 if container is healthy, 1 otherwise
+
+  local container_running
+  container_running=$(docker ps -q -f name="${CONTAINER_NAME}" || true)
+  if [ -z "$container_running" ]; then
+    log_error "Container ${CONTAINER_NAME} is not running"
+    return 1
+  fi
+
+  if ! docker exec "${CONTAINER_NAME}" curl -s --max-time 5 "http://localhost:4000/" >/dev/null; then
+    log_error "Container HTTP endpoint is not responding"
+    return 1
+  fi
+
+  local process_check
+  process_check=$(docker exec "${CONTAINER_NAME}" ps -e | grep -v grep | grep "webxr" || true)
+  if [ -z "$process_check" ]; then
+    log_error "Main WebXR process is not running in container"
+    return 1
+  fi
+
+  log_success "Container health check passed"
+  return 0
+}
+
+check_settings_endpoint() {
+  log_section "Checking Settings Endpoint"
+  log_message "Testing settings endpoint..."
+
+  local response status
+  response=$(docker exec "${CONTAINER_NAME}" curl -s --max-time "${TIMEOUT}" \
+    "http://localhost:4000/api/user-settings" || true)
+  status=$?
+
+  if [ $status -ne 0 ] || [ -z "$response" ]; then
+    log_error "Failed to fetch or empty response from settings endpoint"
+    return 1
+  fi
+
+  if ! echo "$response" | jq -e . >/dev/null 2>&1; then
+    log_error "Invalid JSON response from settings endpoint"
+    return 1
+  fi
+
+  log_success "Settings endpoint check passed"
+  return 0
+}
+
+check_graph_endpoints() {
+  log_section "Checking Graph Endpoints"
+  log_message "Testing full graph data endpoint..."
+
+  local response
+  response=$(docker exec "${CONTAINER_NAME}" curl -s --max-time "${TIMEOUT}" \
+    -H "Content-Type: application/json" \
+    -H "Accept: application/json" \
+    "http://localhost:4000/api/graph/data" || true)
+
+  if [ -z "$response" ]; then
+    log_error "Empty or no response from graph data endpoint"
+    return 1
+  fi
+
+  log_success "Graph endpoints check passed"
+  return 0
+}
+
+check_github_endpoints() {
+    log_section "Testing GitHub API Access"
+    local failed=0
+
+    # Check if required variables are set (including GITHUB_BASE_PATH)
+    if [ -z "${GITHUB_TOKEN:-}" ] || [ -z "${GITHUB_OWNER:-}" ] || [ -z "${GITHUB_REPO:-}" ] || [ -z "${GITHUB_BASE_PATH:-}" ]; then
+        log_error "Missing required GitHub configuration"
+        return 1
+    fi
+
+    # Test a few markdown files in the specified base path
+    local files=(
+        "${GITHUB_BASE_PATH}/Debug Test Page.md"
+    )
+
+    for file in "${files[@]}"; do
+        check_github_file "$file"
+        if [ $? -ne 0 ]; then
+            failed=$((failed + 1))
+        fi
+    done
+
+    return $failed
+}
+
+check_settings_sync() {
+  log_section "Testing Settings Synchronization"
+  local failed=0
+
+  local test_value="#FF0000"
+  local test_setting="visualization.nodes.base_color"
+
+  log_message "Updating setting to ${test_value}..."
+  local update_response
+  update_response=$(curl -s -X POST \
+    -H "Content-Type: application/json" \
+    -d "{\"$test_setting\":\"$test_value\"}" \
+    "http://localhost:${NGINX_PORT}/api/user-settings" || true)
+
+  if [ -z "$update_response" ]; then
+    log_error "Failed to update setting"
+    return 1
+  fi
+
+  sleep 1
+  local verify_response
+  verify_response=$(curl -s "http://localhost:${NGINX_PORT}/api/user-settings" || true)
+
+  local actual_value
+  actual_value=$(echo "$verify_response" | jq -r ".$test_setting" || echo "")
+  if [ "$actual_value" != "$test_value" ]; then
+    log_error "Setting verification failed. Expected: $test_value, Got: $actual_value"
+    failed=1
+  fi
+
+  return $failed
+}
+
+# ------------------------------------------------------------------------------
+# Main Execution
+# ------------------------------------------------------------------------------
+main() {
+  log "${YELLOW}Starting endpoint diagnostics...${NC}"
+  local failed=0
+  local test_count=0
+  local failed_count=0
+
+  if ! check_container_health; then
+    log_error "Container health check failed. Continuing with tests..."
+  fi
+
+  log_message "Checking network connectivity..."
+  if ! docker exec "${CONTAINER_NAME}" bash -c '
+        echo -e "=== Network Status ==="
+        ip addr show | grep -A2 "eth0" | head -n3
+        ip route | grep default
+        grep "nameserver" /etc/resolv.conf | head -n2
+  ' | tee -a "$LOG_FILE"; then
+    log_error "Network connectivity check failed. Continuing..."
+  fi
+
+  log_message "Testing basic HTTP endpoint..."
+  if docker exec "${CONTAINER_NAME}" curl -s --max-time "${TIMEOUT}" "http://localhost:4000/" > /dev/null; then
+    log_success "Basic HTTP endpoint is responding"
+  else
+    log_error "Basic HTTP endpoint test failed - cannot continue"
+    exit 1
+  fi
+
+  if [ "$TEST_SETTINGS_ONLY" = true ]; then
+    log_section "Settings-Only Mode"
+    check_settings_endpoint
+    exit $?
+  fi
+
+  log_section "Running All Tests"
+
+  test_count=$((test_count+1))
+  if ! check_settings_endpoint; then
+    failed_count=$((failed_count+1))
+    failed=1
+  fi
+
+  test_count=$((test_count+1))
+  if ! check_graph_endpoints; then
+    failed_count=$((failed_count+1))
+    failed=1
+  fi
+
+  if [ "$SKIP_GITHUB" != true ]; then
+    test_count=$((test_count+1))
+    if ! check_github_endpoints; then
+      failed_count=$((failed_count+1))
+      failed=1
+    fi
+  fi
+
+  log_section "Test Summary"
+  log_message "Total tests:  ${test_count}"
+  log_message "Failed tests: ${failed_count}"
+
+  if [ $failed -eq 0 ]; then
+    log_success "All tests passed successfully"
+  else
+    log_error "Some tests failed"
+  fi
+
+  log "${YELLOW}Diagnostics completed${NC}"
+  exit $failed
+}
+
+main
diff --git a/scripts/test_settings.sh b/scripts/test_settings.sh
new file mode 100755
index 00000000..d752baca
--- /dev/null
+++ b/scripts/test_settings.sh
@@ -0,0 +1,354 @@
+#!/bin/bash
+
+# Enable error reporting
+set -e
+
+# Colors and formatting
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+MAGENTA='\033[0;35m'
+CYAN='\033[0;36m'
+GRAY='\033[0;90m'
+BOLD='\033[1m'
+NC='\033[0m' # No Color
+
+# Configuration
+CONTAINER_NAME="logseq-xr-webxr"
+VERBOSE=false
+LOG_DIR="logs"
+LOG_FILE="${LOG_DIR}/settings_test_$(date +%Y%m%d_%H%M%S).log"
+
+# Create logs directory if it doesn't exist
+mkdir -p "$LOG_DIR"
+
+# Parse command line arguments
+while [[ "$#" -gt 0 ]]; do
+    case $1 in
+        -v|--verbose) VERBOSE=true ;;
+        *) echo "Usage: $0 [-v|--verbose]"; exit 1 ;;
+    esac
+    shift
+done
+
+# Logging functions
+log() {
+    echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_FILE"
+}
+
+log_error() {
+    echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} ${RED} ERROR:${NC} $1" | tee -a "$LOG_FILE"
+}
+
+log_success() {
+    echo -e "${GRAY}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} ${GREEN}${NC} $1" | tee -a "$LOG_FILE"
+}
+
+log_section() {
+    echo -e "\n${BLUE}${BOLD}=== $1 ===${NC}\n" | tee -a "$LOG_FILE"
+}
+
+# Function to check if a setting exists and is not null
+check_setting() {
+    local obj=$1
+    local path=$2
+    local name=$3
+    local value=$(echo "$obj" | jq -r "$path")
+    
+    if [ -z "$value" ] || [ "$value" = "null" ]; then
+        log_error "$name is missing or invalid"
+        return 1
+    elif [ "$VERBOSE" = true ]; then
+        log "Found $name: $value"
+    fi
+    return 0
+}
+
+# Function to check visualization settings
+check_visualization_settings() {
+    local settings=$1
+    local failed=0
+    
+    log_section "Checking Visualization Settings"
+    
+    # Check nodes section
+    local nodes=$(echo "$settings" | jq -r '.visualization.nodes')
+    if [ -z "$nodes" ] || [ "$nodes" = "null" ]; then
+        log_error "Node settings missing"
+        failed=1
+    else
+        check_setting "$nodes" '.base_color' "Node base color" || failed=1
+        check_setting "$nodes" '.size_range' "Node size range" || failed=1
+        check_setting "$nodes" '.quality' "Node quality" || failed=1
+        check_setting "$nodes" '.enable_instancing' "Node instancing" || failed=1
+        check_setting "$nodes" '.enable_hologram' "Node hologram" || failed=1
+        check_setting "$nodes" '.enable_metadata_visualization' "Node metadata visualization" || failed=1
+    fi
+    
+    # Check edges section
+    local edges=$(echo "$settings" | jq -r '.visualization.edges')
+    if [ -z "$edges" ] || [ "$edges" = "null" ]; then
+        log_error "Edge settings missing"
+        failed=1
+    else
+        check_setting "$edges" '.color' "Edge color" || failed=1
+        check_setting "$edges" '.width_range' "Edge width range" || failed=1
+        check_setting "$edges" '.quality' "Edge quality" || failed=1
+        check_setting "$edges" '.arrow_size' "Edge arrow size" || failed=1
+    fi
+    
+    # Check physics section
+    local physics=$(echo "$settings" | jq -r '.visualization.physics')
+    if [ -z "$physics" ] || [ "$physics" = "null" ]; then
+        log_error "Physics settings missing"
+        failed=1
+    else
+        check_setting "$physics" '.enabled' "Physics enabled" || failed=1
+        check_setting "$physics" '.iterations' "Physics iterations" || failed=1
+        check_setting "$physics" '.attraction_strength' "Attraction strength" || failed=1
+        check_setting "$physics" '.repulsion_strength' "Repulsion strength" || failed=1
+    fi
+    
+    # Check rendering section
+    local rendering=$(echo "$settings" | jq -r '.visualization.rendering')
+    if [ -z "$rendering" ] || [ "$rendering" = "null" ]; then
+        log_error "Rendering settings missing"
+        failed=1
+    else
+        check_setting "$rendering" '.background_color' "Background color" || failed=1
+        check_setting "$rendering" '.ambient_light_intensity' "Ambient light intensity" || failed=1
+        check_setting "$rendering" '.enable_antialiasing' "Antialiasing" || failed=1
+    fi
+    
+    if [ $failed -eq 0 ]; then
+        log_success "Visualization settings validation passed"
+        return 0
+    fi
+    return 1
+}
+
+# Function to check system settings
+check_system_settings() {
+    local settings=$1
+    local failed=0
+    
+    log_section "Checking System Settings"
+    
+    # Check websocket section
+    local websocket=$(echo "$settings" | jq -r '.system.websocket')
+    if [ -z "$websocket" ] || [ "$websocket" = "null" ]; then
+        log_error "WebSocket settings missing"
+        failed=1
+    else
+        check_setting "$websocket" '.update_rate' "WebSocket update rate" || failed=1
+        check_setting "$websocket" '.reconnect_attempts' "Reconnect attempts" || failed=1
+        check_setting "$websocket" '.binary_chunk_size' "Binary chunk size" || failed=1
+    fi
+    
+    # Check debug section
+    local debug=$(echo "$settings" | jq -r '.system.debug')
+    if [ -z "$debug" ] || [ "$debug" = "null" ]; then
+        log_error "Debug settings missing"
+        failed=1
+    else
+        check_setting "$debug" '.enabled' "Debug enabled" || failed=1
+        check_setting "$debug" '.log_level' "Log level" || failed=1
+    fi
+    
+    if [ $failed -eq 0 ]; then
+        log_success "System settings validation passed"
+        return 0
+    fi
+    return 1
+}
+
+# Function to check XR settings
+check_xr_settings() {
+    local settings=$1
+    local failed=0
+    
+    log_section "Checking XR Settings"
+    
+    local xr=$(echo "$settings" | jq -r '.xr')
+    if [ -z "$xr" ] || [ "$xr" = "null" ]; then
+        log_error "XR settings missing"
+        failed=1
+    else
+        check_setting "$xr" '.mode' "XR mode" || failed=1
+        check_setting "$xr" '.room_scale' "Room scale" || failed=1
+        check_setting "$xr" '.enable_hand_tracking' "Hand tracking" || failed=1
+        check_setting "$xr" '.hand_mesh_enabled' "Hand mesh" || failed=1
+        check_setting "$xr" '.movement_speed' "Movement speed" || failed=1
+        check_setting "$xr" '.interaction_radius' "Interaction radius" || failed=1
+    fi
+    
+    if [ $failed -eq 0 ]; then
+        log_success "XR settings validation passed"
+        return 0
+    fi
+    return 1
+}
+
+# Add new test cases
+check_settings_consistency() {
+    local settings=$1
+    local failed=0
+    
+    log_section "Checking Settings Consistency"
+    
+    # Check case consistency
+    local visualization=$(echo "$settings" | jq -r '.visualization')
+    check_case_consistency "$visualization" "visualization" || failed=1
+    
+    # Check key presence across all layers
+    check_key_hierarchy "$settings" || failed=1
+    
+    # Verify power user settings access
+    check_power_user_access || failed=1
+    
+    return $failed
+}
+
+check_case_consistency() {
+    local obj=$1
+    local prefix=$2
+    local failed=0
+    
+    # Check for case mismatches in keys
+    for key in $(echo "$obj" | jq -r 'keys[]'); do
+        if [[ "$key" =~ [A-Z] ]]; then
+            log_error "Upper case found in key: $prefix.$key"
+            failed=1
+        fi
+    done
+    
+    return $failed
+}
+
+check_key_hierarchy() {
+    local settings=$1
+    local failed=0
+    
+    # Define expected key hierarchies
+    local expected_paths=(
+        ".visualization.nodes.base_color"
+        ".visualization.edges.color"
+        ".system.debug.enabled"
+        ".xr.mode"
+    )
+    
+    for path in "${expected_paths[@]}"; do
+        if ! echo "$settings" | jq -e "$path" >/dev/null 2>&1; then
+            log_error "Missing required setting: $path"
+            failed=1
+        fi
+    done
+    
+    return $failed
+}
+
+check_power_user_access() {
+    local failed=0
+    
+    # Test with power user credentials
+    log "Testing power user access..."
+    local response=$(curl -s -X POST \
+        -H "Content-Type: application/json" \
+        -H "X-Power-User: true" \
+        -d '{"visualization":{"nodes":{"base_color":"#FF0000"}}}' \
+        "http://localhost:4000/api/user-settings")
+    
+    if [ $? -ne 0 ] || [ -z "$response" ]; then
+        log_error "Power user access test failed"
+        failed=1
+    fi
+    
+    return $failed
+}
+
+# Add this function to verify settings persistence
+verify_settings_persistence() {
+    local settings=$1
+    local failed=0
+    
+    log_section "Verifying Settings Persistence"
+    
+    # Test setting update
+    local test_value="#FF0000"
+    local test_path=".visualization.nodes.base_color"
+    
+    # Save original value
+    local original_value=$(echo "$settings" | jq -r "$test_path")
+    
+    # Update setting
+    local update_response=$(curl -s -X POST \
+        -H "Content-Type: application/json" \
+        -d "{\"visualization\":{\"nodes\":{\"base_color\":\"$test_value\"}}}" \
+        "http://localhost:4000/api/user-settings")
+    
+    if [ $? -ne 0 ]; then
+        log_error "Failed to update test setting"
+        return 1
+    fi
+    
+    # Verify update
+    sleep 1
+    local verify_response=$(curl -s "http://localhost:4000/api/user-settings")
+    local updated_value=$(echo "$verify_response" | jq -r "$test_path")
+    
+    if [ "$updated_value" != "$test_value" ]; then
+        log_error "Setting update verification failed"
+        failed=1
+    fi
+    
+    # Restore original value
+    curl -s -X POST \
+        -H "Content-Type: application/json" \
+        -d "{\"visualization\":{\"nodes\":{\"base_color\":\"$original_value\"}}}" \
+        "http://localhost:4000/api/user-settings" > /dev/null
+    
+    return $failed
+}
+
+# Main function to test settings
+main() {
+    log "${YELLOW}Starting settings validation...${NC}"
+    local failed=0
+    
+    # Fetch settings from API
+    log "Fetching settings from API..."
+    local response=$(docker exec ${CONTAINER_NAME} curl -s \
+        "http://localhost:4000/api/user-settings")
+    
+    if [ -z "$response" ] || [ "$response" = "null" ]; then
+        log_error "Failed to fetch settings from API"
+        exit 1
+    fi
+    
+    # First verify we got valid JSON
+    if ! echo "$response" | jq -e . >/dev/null 2>&1; then
+        log_error "Invalid JSON response from API"
+        exit 1
+    fi
+    
+    # Run all checks
+    check_visualization_settings "$response" || failed=1
+    check_system_settings "$response" || failed=1
+    check_xr_settings "$response" || failed=1
+    check_settings_consistency "$response" || failed=1
+    verify_settings_persistence "$response" || failed=1
+    
+    # Final status
+    log_section "Settings Validation Summary"
+    if [ $failed -eq 0 ]; then
+        log_success "All settings validated successfully"
+        exit 0
+    else
+        log_error "Some settings validation failed"
+        exit 1
+    fi
+}
+
+# Run main function
+main
diff --git a/services/empty_graph_check.rs b/services/empty_graph_check.rs
deleted file mode 100644
index a17ddb28..00000000
--- a/services/empty_graph_check.rs
+++ /dev/null
@@ -1,21 +0,0 @@
-use crate::models::graph::GraphData;
-use std::io::{Error, ErrorKind};
-use log::warn;
-
-/// This function checks if a graph is empty or contains too few nodes
-/// It is used before GPU operations to prevent errors
-pub fn check_empty_graph(graph: &GraphData, min_nodes: usize) -> Result<(), Error> {
-    // Check for completely empty graph
-    if graph.nodes.is_empty() {
-        return Err(Error::new(ErrorKind::InvalidData, 
-            "Graph contains no nodes, cannot perform GPU computation on empty graph"));
-    }
-    
-    // Check if graph is below recommended threshold
-    if graph.nodes.len() < min_nodes {
-        warn!("[Empty Graph Check] Graph contains only {} nodes, which is below the recommended minimum of {}. 
-              This may cause instability in GPU computation.", graph.nodes.len(), min_nodes);
-    }
-    
-    Ok(())
-}
\ No newline at end of file
diff --git a/settings.yaml b/settings.yaml
new file mode 100644
index 00000000..0f365938
--- /dev/null
+++ b/settings.yaml
@@ -0,0 +1,208 @@
+visualization:
+  nodes:
+    base_color: '#df90c2'
+    metalness: 0.2
+    opacity: 1.0
+    roughness: 0.7
+    size_range:
+    - 0.5
+    - 10.0
+    quality: medium
+    enable_instancing: false
+    enable_hologram: true
+    enable_metadata_shape: true
+    enable_metadata_visualization: true
+  edges:
+    arrow_size: 0.02
+    base_width: 0.005
+    color: '#0c2140'
+    enable_arrows: true
+    opacity: 1
+    width_range:
+    - 0.1
+    - 0.5
+    quality: low
+  physics:
+    attraction_strength: 0.2      # Increased for stronger cohesion
+    bounds_size: 8.0              # Reduced to keep nodes closer together
+    collision_radius: 0.5         # Increased to prevent nodes from getting too close
+    damping: 0.98                 # Higher damping to reduce oscillation and improve stability
+    enable_bounds: false
+    enabled: true
+    iterations: 100
+    max_velocity: 0.01            # Reduced to prevent nodes from moving too quickly
+    repulsion_strength: 0.03      # Reduced relative to attraction for better cohesion
+    spring_strength: 0.15         # Increased to improve node cohesion
+    repulsion_distance: 1.0       # Reduced to limit repulsion effects
+    mass_scale: 1.0
+    boundary_damping: 0.98        # Increased for better containment and stability
+  rendering:
+    ambient_light_intensity: 0.8
+    background_color: '#1a1a2e'
+    directional_light_intensity: 0.7
+    enable_ambient_occlusion: true
+    enable_antialiasing: true
+    enable_shadows: false
+    environment_intensity: 0.7
+  animations:
+    enable_motion_blur: false
+    enable_node_animations: false
+    motion_blur_strength: 0.2
+    selection_wave_enabled: false
+    pulse_enabled: false
+    pulse_speed: 0.8
+    pulse_strength: 0.6
+    wave_speed: 0.5
+  labels:
+    desktop_font_size: 5
+    enable_labels: true
+    text_color: '#000000'
+    text_outline_color: '#ffffff'
+    text_outline_width: 0.1
+    text_resolution: 16
+    text_padding: 1
+    billboard_mode: camera
+  bloom:
+    edge_bloom_strength: 0.4
+    enabled: false
+    environment_bloom_strength: 2.0
+    node_bloom_strength: 3.0
+    radius: 2.0
+    strength: 3.0
+  hologram:
+    ring_count: 3
+    ring_color: '#c2a200'
+    ring_opacity: 0.001
+    sphere_sizes: # Reduced by factor of 10 to match default scale
+    - 4
+    - 8
+    ring_rotation_speed: 10.0
+    enable_buckminster: true
+    buckminster_size: 10
+    buckminster_opacity: 0.05
+    enable_geodesic: true
+    geodesic_size: 10
+    geodesic_opacity: 0.05
+    enable_triangle_sphere: true
+    triangle_sphere_size: 10 # Reduced by factor of 10 to match default scale
+    triangle_sphere_opacity: 0.05
+    global_rotation_speed: 3
+system:
+  network:
+    bind_address: 0.0.0.0
+    domain: visionflow.info
+    enable_http2: false
+    enable_rate_limiting: false
+    enable_tls: false
+    max_request_size: 10485760
+    min_tls_version: ''
+    port: 3001
+    rate_limit_requests: 10000
+    rate_limit_window: 600
+    tunnel_id: dummy
+    api_client_timeout: 30
+    enable_metrics: false
+    max_concurrent_requests: 1
+    max_retries: 3
+    metrics_port: 9090
+    retry_delay: 5
+  websocket:
+    binary_chunk_size: 2048
+    binary_update_rate: 30
+    # Dynamic update rate parameters
+    min_update_rate: 5      # Minimum updates per second when graph is stable
+    max_update_rate: 60     # Maximum updates per second during high motion
+    motion_threshold: 0.05  # Consider graph in motion if at least 5% of nodes are moving
+    motion_damping: 0.9     # Damping factor for rate changes (higher = smoother transitions)
+    binary_message_version: 1
+    compression_enabled: false
+    compression_threshold: 512
+    heartbeat_interval: 10000
+    heartbeat_timeout: 600000
+    max_connections: 100
+    max_message_size: 10485760
+    reconnect_attempts: 5
+    reconnect_delay: 1000
+    update_rate: 60
+  security:
+    allowed_origins:
+    - https://www.visionflow.info
+    - https://visionflow.info
+    audit_log_path: /app/logs/audit.log
+    cookie_httponly: true
+    cookie_samesite: Strict
+    cookie_secure: true
+    csrf_token_timeout: 3600
+    enable_audit_logging: true
+    enable_request_validation: true
+    session_timeout: 3600
+  debug:
+    enabled: false
+    enable_data_debug: false
+    enable_websocket_debug: false
+    log_binary_headers: false
+    log_full_json: false
+    log_level: debug
+    log_format: json
+xr:
+  mode: inline
+  room_scale: 1.0
+  space_type: local-floor
+  quality: medium
+  enable_hand_tracking: true
+  hand_mesh_enabled: true
+  hand_mesh_color: '#4287f5'
+  hand_mesh_opacity: 0.3
+  hand_point_size: 0.006
+  hand_ray_enabled: true
+  hand_ray_color: '#4287f5'
+  hand_ray_width: 0.003
+  gesture_smoothing: 0.7
+  enable_haptics: true
+  haptic_intensity: 0.3
+  drag_threshold: 0.08
+  pinch_threshold: 0.3
+  rotation_threshold: 0.08
+  interaction_radius: 0.15
+  movement_speed: 0.08
+  dead_zone: 0.12
+  movement_axes:
+    horizontal: 2
+    vertical: 3
+  enable_light_estimation: false
+  enable_plane_detection: false
+  enable_scene_understanding: false
+  plane_color: '#4287f5'
+  plane_opacity: 0.001
+  plane_detection_distance: 3.0
+  show_plane_overlay: false
+  snap_to_floor: false
+  enable_passthrough_portal: false
+  passthrough_opacity: 0.8
+  passthrough_brightness: 1.1
+  passthrough_contrast: 1.2
+  portal_size: 2.5
+  portal_edge_color: '#4287f5'
+  portal_edge_width: 0.02
+ragflow:
+  api_key: ''
+  api_base_url: ''
+  timeout: 30
+  max_retries: 3
+  chat_id: ''
+perplexity:
+  api_key: ''
+  model: llama-3.1-sonar-small-128k-online
+  api_url: ''
+  max_tokens: 4096
+  temperature: 0.5
+  top_p: 0.9
+  presence_penalty: 0.0
+  frequency_penalty: 0.0
+  timeout: 30
+  rate_limit: 100
+openai:
+  api_key: ''
+  base_url: ''
+  timeout: 30
+  rate_limit: 100
diff --git a/app_state.rs b/src/app_state.rs
similarity index 95%
rename from app_state.rs
rename to src/app_state.rs
index 33009f3c..36268b9e 100755
--- a/app_state.rs
+++ b/src/app_state.rs
@@ -8,6 +8,7 @@ use tokio::time::Duration;
 use crate::config::feature_access::FeatureAccess;
 use crate::models::metadata::MetadataStore;
 use crate::models::protected_settings::{ProtectedSettings, ApiKeys, NostrUser};
+use crate::models::graph::GraphUpdateStatus;
 use crate::services::graph_service::GraphService;
 use crate::services::github::{GitHubClient, ContentAPI};
 use crate::services::perplexity_service::PerplexityService;
@@ -30,6 +31,8 @@ pub struct AppState {
     pub feature_access: web::Data<FeatureAccess>,
     pub ragflow_conversation_id: String,
     pub active_connections: Arc<AtomicUsize>,
+    // Track graph updates for websocket clients
+    pub graph_update_status: Arc<RwLock<GraphUpdateStatus>>,
 }
 
 impl AppState {
@@ -65,6 +68,7 @@ impl AppState {
             feature_access: web::Data::new(FeatureAccess::from_env()),
             ragflow_conversation_id,
             active_connections: Arc::new(AtomicUsize::new(0)),
+            graph_update_status: Arc::new(RwLock::new(GraphUpdateStatus::default())),
         })
     }
 
diff --git a/config/feature_access.rs b/src/config/feature_access.rs
similarity index 84%
rename from config/feature_access.rs
rename to src/config/feature_access.rs
index 31e1949e..b661d270 100644
--- a/config/feature_access.rs
+++ b/src/config/feature_access.rs
@@ -1,7 +1,7 @@
 use std::env;
 use std::fs;
 use std::path::PathBuf;
-use log::{info, warn};
+use log::{info, warn, debug};
 
 /// Represents the access control configuration for various features and user roles
 pub struct FeatureAccess {
@@ -41,7 +41,11 @@ impl FeatureAccess {
         env::var(var_name)
             .unwrap_or_default()
             .split(',')
-            .map(|s| s.trim().to_string())
+            .map(|s| {
+                let trimmed = s.trim().to_string();
+                debug!("Loaded pubkey from env {}: '{}'", var_name, trimmed);
+                trimmed
+            })
             .filter(|s| !s.is_empty())
             .collect()
     }
@@ -102,33 +106,48 @@ impl FeatureAccess {
 
     /// Checks if a pubkey has basic access
     pub fn has_access(&self, pubkey: &str) -> bool {
-        self.approved_pubkeys.contains(&pubkey.to_string())
+        let pubkey_str = pubkey.trim();
+        debug!("Checking access for pubkey: '{}'", pubkey_str);
+        debug!("Approved pubkeys: {:?}", self.approved_pubkeys);
+        self.approved_pubkeys.iter().any(|p| p.trim() == pubkey_str)
     }
 
     /// Checks if a pubkey has access to Perplexity features
     pub fn has_perplexity_access(&self, pubkey: &str) -> bool {
-        self.perplexity_enabled.contains(&pubkey.to_string())
+        let pubkey_str = pubkey.trim();
+        debug!("Checking Perplexity access for pubkey: '{}'", pubkey_str);
+        self.perplexity_enabled.iter().any(|p| p.trim() == pubkey_str)
     }
 
     /// Checks if a pubkey has access to OpenAI features
     pub fn has_openai_access(&self, pubkey: &str) -> bool {
-        self.openai_enabled.contains(&pubkey.to_string())
+        let pubkey_str = pubkey.trim();
+        debug!("Checking OpenAI access for pubkey: '{}'", pubkey_str);
+        self.openai_enabled.iter().any(|p| p.trim() == pubkey_str)
     }
 
     /// Checks if a pubkey has access to RagFlow features
     pub fn has_ragflow_access(&self, pubkey: &str) -> bool {
-        self.ragflow_enabled.contains(&pubkey.to_string())
+        let pubkey_str = pubkey.trim();
+        debug!("Checking RagFlow access for pubkey: '{}'", pubkey_str);
+        self.ragflow_enabled.iter().any(|p| p.trim() == pubkey_str)
     }
 
     /// Checks if a pubkey has power user status
-    pub fn is_power_user(&self, pubkey: &str) -> bool {
-        self.power_users.contains(&pubkey.to_string())
+    pub fn is_power_user(&self, pubkey: &str) -> bool {       
+        let pubkey_str = pubkey.trim();
+        debug!("Checking power user status for pubkey: '{}'", pubkey_str);
+        debug!("Power users: {:?}", self.power_users);
+        self.power_users.iter().any(|p| p.trim() == pubkey_str)
     }
 
     /// Checks if a pubkey has settings sync access
     pub fn can_sync_settings(&self, pubkey: &str) -> bool {
         // Power users automatically get settings sync access
-        self.is_power_user(pubkey) || self.settings_sync_enabled.contains(&pubkey.to_string())
+        if self.is_power_user(pubkey) {
+            return true;
+        }
+        self.settings_sync_enabled.iter().any(|p| p.trim() == pubkey.trim())
     }
 
     /// Checks if a pubkey has access to a specific feature
diff --git a/config/feature_access_test.rs b/src/config/feature_access_test.rs
similarity index 100%
rename from config/feature_access_test.rs
rename to src/config/feature_access_test.rs
diff --git a/config/mod.rs b/src/config/mod.rs
similarity index 100%
rename from config/mod.rs
rename to src/config/mod.rs
diff --git a/handlers/api_handler/files/mod.rs b/src/handlers/api_handler/files/mod.rs
similarity index 98%
rename from handlers/api_handler/files/mod.rs
rename to src/handlers/api_handler/files/mod.rs
index ef3cd1ef..44ff8c90 100644
--- a/handlers/api_handler/files/mod.rs
+++ b/src/handlers/api_handler/files/mod.rs
@@ -22,7 +22,7 @@ pub async fn fetch_and_process_files(state: web::Data<AppState>) -> HttpResponse
     
     let file_service = FileService::new(state.settings.clone());
     
-    match file_service.fetch_and_process_files(state.content_api.clone(), state.settings.clone(), &mut metadata_store).await {
+    match file_service.fetch_and_process_files(&state.content_api, state.settings.clone(), &mut metadata_store).await {
         Ok(processed_files) => {
             let file_names: Vec<String> = processed_files.iter()
                 .map(|pf| pf.file_name.clone())
diff --git a/handlers/api_handler/graph/mod.rs b/src/handlers/api_handler/graph/mod.rs
similarity index 98%
rename from handlers/api_handler/graph/mod.rs
rename to src/handlers/api_handler/graph/mod.rs
index 1d9da939..3f63a8c0 100644
--- a/handlers/api_handler/graph/mod.rs
+++ b/src/handlers/api_handler/graph/mod.rs
@@ -198,7 +198,7 @@ pub async fn update_graph(state: web::Data<AppState>) -> impl Responder {
     };
     
     let file_service = FileService::new(Arc::clone(&state.settings));
-    match file_service.fetch_and_process_files(state.content_api.clone(), Arc::clone(&state.settings), &mut metadata).await {
+    match file_service.fetch_and_process_files(&state.content_api, Arc::clone(&state.settings), &mut metadata).await {
         Ok(processed_files) => {
             if processed_files.is_empty() {
                 debug!("No new files to process");
diff --git a/handlers/api_handler/mod.rs b/src/handlers/api_handler/mod.rs
similarity index 100%
rename from handlers/api_handler/mod.rs
rename to src/handlers/api_handler/mod.rs
diff --git a/handlers/api_handler/visualization/mod.rs b/src/handlers/api_handler/visualization/mod.rs
similarity index 100%
rename from handlers/api_handler/visualization/mod.rs
rename to src/handlers/api_handler/visualization/mod.rs
diff --git a/handlers/file_handler.rs b/src/handlers/file_handler.rs
similarity index 99%
rename from handlers/file_handler.rs
rename to src/handlers/file_handler.rs
index 7f5e33d3..24bcbf41 100755
--- a/handlers/file_handler.rs
+++ b/src/handlers/file_handler.rs
@@ -28,7 +28,7 @@ pub async fn fetch_and_process_files(state: web::Data<AppState>) -> HttpResponse
     match file_service.fetch_and_process_files(&state.content_api, state.settings.clone(), &mut metadata_store).await {
         Ok(processed_files) => {
             let file_names: Vec<String> = processed_files.iter()
-                .map(|pf| pf.file_name.clone())
+                .map(|pf| pf.file_name.clone()) 
                 .collect();
 
             info!("Successfully processed {} public markdown files", processed_files.len());
diff --git a/handlers/graph_handler.rs b/src/handlers/graph_handler.rs
similarity index 59%
rename from handlers/graph_handler.rs
rename to src/handlers/graph_handler.rs
index d761ff2e..d939cd2b 100755
--- a/handlers/graph_handler.rs
+++ b/src/handlers/graph_handler.rs
@@ -6,8 +6,12 @@ use std::collections::HashMap;
 use std::sync::Arc;
 use crate::models::metadata::Metadata;
 use crate::utils::socket_flow_messages::Node;
+use tokio::fs::{create_dir_all, File, metadata};
 use crate::services::file_service::FileService;
 use crate::services::graph_service::GraphService;
+use std::io::Error;
+use std::path::Path;
+use crate::services::file_service::{GRAPH_CACHE_PATH, LAYOUT_CACHE_PATH};
 
 #[derive(Serialize)]
 #[serde(rename_all = "camelCase")]
@@ -39,8 +43,158 @@ pub struct GraphQuery {
     pub filter: Option<String>,
 }
 
+/// Explicitly verify and report on cache file status
+pub async fn verify_cache_files() -> (bool, bool) {
+    info!("Verifying cache files existence and permissions");
+    let graph_exists = Path::new(GRAPH_CACHE_PATH).exists();
+    let layout_exists = Path::new(LAYOUT_CACHE_PATH).exists();
+    
+    if graph_exists {
+        match metadata(GRAPH_CACHE_PATH).await {
+            Ok(md) => {
+                info!("Graph cache file exists: {} bytes, is_file={}", 
+                      md.len(), md.is_file());
+                
+                // Try opening the file to verify permissions
+                match File::open(GRAPH_CACHE_PATH).await {
+                    Ok(_) => info!("Graph cache file is readable"),
+                    Err(e) => error!("Graph cache file exists but can't be opened: {}", e)
+                }
+            },
+            Err(e) => error!("Failed to get metadata for graph cache: {}", e)
+        }
+    } else {
+        error!("Graph cache file does not exist at {}", GRAPH_CACHE_PATH);
+    }
+    
+    if layout_exists {
+        match metadata(LAYOUT_CACHE_PATH).await {
+            Ok(md) => {
+                info!("Layout cache file exists: {} bytes, is_file={}", 
+                      md.len(), md.is_file());
+                match File::open(LAYOUT_CACHE_PATH).await {
+                    Ok(_) => info!("Layout cache file is readable"),
+                    Err(e) => error!("Layout cache file exists but can't be opened: {}", e)
+                }
+            },
+            Err(e) => error!("Failed to get metadata for layout cache: {}", e)
+        }
+    } else {
+        error!("Layout cache file does not exist at {}", LAYOUT_CACHE_PATH);
+    }
+    (graph_exists, layout_exists)
+}
+
 pub async fn get_graph_data(state: web::Data<AppState>) -> impl Responder {
     info!("Received request for graph data");
+
+    // Check if metadata directory exists and create if necessary
+    if let Err(e) = create_dir_all("/app/data/metadata").await {
+        error!("Failed to create metadata directory: {}", e);
+    } else {
+        info!("Metadata directory exists or was created successfully");
+    }
+    
+    // Get metadata from the app state
+    let metadata = state.metadata.read().await.clone();
+    if metadata.is_empty() {
+        error!("Metadata store is empty - no files to process");
+        return HttpResponse::ServiceUnavailable().json(serde_json::json!({
+            "error": "No metadata available to build graph"
+        }));
+    }
+    
+    // Check if the graph_service already has graph data
+    let graph_size = {
+        let graph = state.graph_service.get_graph_data_mut().await;
+        graph.nodes.len()
+        // Don't drop graph lock here to avoid race conditions with validation
+    };
+    
+    // If the graph is empty, we need to build it first
+    if graph_size == 0 {
+        info!("Graph data is empty, building graph from {} metadata entries", metadata.len());
+        match GraphService::build_graph_from_metadata(&metadata).await {
+            Ok(built_graph) => {
+                // Update the app state's graph data
+                let mut app_graph = state.graph_service.get_graph_data_mut().await;
+                *app_graph = built_graph.clone();
+                drop(app_graph);
+                
+                // Update node map
+                let mut node_map = state.graph_service.get_node_map_mut().await;
+                node_map.clear();
+                for node in &built_graph.nodes {
+                    node_map.insert(node.id.clone(), node.clone());
+                }
+                drop(node_map);
+                
+                info!("Successfully built and updated graph with {} nodes, {} edges",
+                      built_graph.nodes.len(), built_graph.edges.len());
+            },
+            Err(e) => error!("Failed to build graph: {}", e)
+        }
+    } else {
+        info!("Graph already contains {} nodes, using existing data for hot start", graph_size);
+        
+        // Clone what we need for the background task
+        let app_state = state.clone();
+        let metadata_clone = metadata.clone();
+        
+        // Spawn background validation and update task
+        tokio::spawn(async move {
+            info!("Starting background validation of cached graph data against metadata");
+            
+            // Try to validate and update the graph
+            match GraphService::build_graph_from_metadata(&metadata_clone).await {
+                Ok(validated_graph) => {
+                    // Check if the validated graph is different from what we have
+                    let current_size = {
+                        let graph = app_state.graph_service.get_graph_data_mut().await;
+                        graph.nodes.len()
+                    };
+                    
+                    let validated_size = validated_graph.nodes.len();
+                    
+                    if current_size != validated_size {
+                        info!("Background validation found graph size difference: {} vs {}. Updating...", 
+                              current_size, validated_size);
+                        
+                        // Update app state with the validated graph
+                        let mut app_graph = app_state.graph_service.get_graph_data_mut().await;
+                        *app_graph = validated_graph.clone();
+                        drop(app_graph);
+                        
+                        // Update node map
+                        let mut node_map = app_state.graph_service.get_node_map_mut().await;
+                        node_map.clear();
+                        for node in &validated_graph.nodes {
+                            node_map.insert(node.id.clone(), node.clone());
+                        }
+
+                        // Update the graph update status so WebSocket clients can check for changes
+                        let update_diff = validated_graph.nodes.len() as i32 - current_size as i32;
+                        let mut update_status = app_state.graph_update_status.write().await;
+                        
+                        // Only mark as updated if there were actual changes
+                        if update_diff != 0 {
+                            info!("Background validation completed - found {} node changes", update_diff);
+                            update_status.last_update = chrono::Utc::now();
+                            update_status.update_available = true;
+                            update_status.nodes_changed = update_diff;
+                        } else {
+                            // Still update check time even if no changes
+                            info!("Background validation completed - graph is already up to date");
+                            update_status.last_check = chrono::Utc::now();
+                            update_status.update_available = false;
+                        }
+                        
+                    }
+                },
+                Err(e) => error!("Background graph validation failed: {}", e)
+            }
+        });
+    }
     
     // Make sure the GPU layout is calculated before sending data
     if let Some(gpu_compute) = &state.graph_service.get_gpu_compute().await {
@@ -82,17 +236,39 @@ pub async fn get_graph_data(state: web::Data<AppState>) -> impl Responder {
         info!("GPU compute not available, sending graph without GPU processing");
     }
     
+    // Take a single layout snapshot for client to load at init
+    info!("Taking layout snapshot for client initialization");
+    if let Err(e) = state.graph_service.take_layout_snapshot().await {
+        warn!("Failed to take layout snapshot: {}", e);
+    } else {
+        info!("Layout snapshot saved successfully");
+    }
+
+    // Verify if cache files were created and provide details
+    let (graph_cached, layout_cached) = verify_cache_files().await;
+    info!("Cache file verification complete: graph={}, layout={}", graph_cached, layout_cached);
+    
     let graph = state.graph_service.get_graph_data_mut().await;
     
     // Log position data to debug zero positions
-    if !graph.nodes.is_empty() {
+    if graph.nodes.is_empty() {
+        error!("Graph is still empty after build attempt. This should not happen if there is valid metadata.");
+        
+        // Return an empty response with an error indicator
+        return HttpResponse::Ok().json(serde_json::json!({
+            "nodes": [],
+            "edges": [],
+            "metadata": {},
+            "error": "Failed to build graph data"
+        }));
+    } else {
         // Log a few nodes for debugging
         for (i, node) in graph.nodes.iter().take(5).enumerate() {
             debug!("Node {}: id={}, label={}, pos=[{:.3},{:.3},{:.3}]", 
                 i, node.id, node.label, node.data.position[0], node.data.position[1], node.data.position[2]);
         }
     }
-    
+
     // Log edge data
     if !graph.edges.is_empty() {
         for (i, edge) in graph.edges.iter().take(5).enumerate() {
@@ -118,7 +294,35 @@ pub async fn get_graph_data(state: web::Data<AppState>) -> impl Responder {
 pub async fn get_paginated_graph_data(
     state: web::Data<AppState>,
     query: web::Query<GraphQuery>,
-) -> impl Responder {
+) -> impl Responder {    
+    // Ensure metadata directory exists
+    if let Err(e) = create_dir_all("/app/data/metadata").await {
+        error!("Failed to create metadata directory: {}", e);
+    }
+    
+    // Get metadata and explicitly build graph with caching if this is the first page
+    if query.page.unwrap_or(1) == 1 {
+        info!("First page requested - verifying cache files");
+        // Verify cache files when first page is requested
+        let (graph_cached, layout_cached) = verify_cache_files().await;
+        
+        // Get the current graph size
+        let graph_size = {
+            let graph = state.graph_service.get_graph_data_mut().await;
+            graph.nodes.len()
+        };
+        
+        // If the graph is empty, rebuild it
+        if graph_size == 0 {
+            info!("Graph data is empty when paginated view requested, rebuilding graph");
+            let metadata = state.metadata.read().await.clone();
+            if !metadata.is_empty() {
+                let _ = get_graph_data(state.clone()).await;
+            }
+        }
+        
+        info!("Cache status for first page: graph={}, layout={}", graph_cached, layout_cached);
+    }
     info!("Received request for paginated graph data with params: {:?}", query);
     
     // Ensure GPU layout is calculated before sending first page of data
@@ -236,9 +440,10 @@ pub async fn get_paginated_graph_data(
 
 // Rebuild graph from existing metadata
 pub async fn refresh_graph(state: web::Data<AppState>) -> impl Responder {
-    info!("Received request to refresh graph");
+    info!("Received request to refresh graph and rebuild caches");
     
     let metadata = state.metadata.read().await.clone();
+    info!("Building graph from {} metadata entries", metadata.len());
     debug!("Building graph from {} metadata entries", metadata.len());
     
     match GraphService::build_graph_from_metadata(&metadata).await {
@@ -271,11 +476,23 @@ pub async fn refresh_graph(state: web::Data<AppState>) -> impl Responder {
             for node in &graph.nodes {
                 node_map.insert(node.id.clone(), node.clone());
             }
+
+            // Take a layout snapshot after refreshing the graph
+            info!("Taking layout snapshot after graph refresh");
+            if let Err(e) = state.graph_service.take_layout_snapshot().await {
+                warn!("Failed to take layout snapshot: {}", e);
+            } else {
+                info!("Layout snapshot saved successfully after refresh");
+            }
+
+            // Verify the cache files after rebuilding the graph
+            let (graph_cached, layout_cached) = verify_cache_files().await;
             
             info!("Graph refreshed successfully with {} nodes and {} edges", 
                 graph.nodes.len(), 
                 graph.edges.len()
             );
+            info!("Cache files after refresh: graph={}, layout={}", graph_cached, layout_cached);
             
             HttpResponse::Ok().json(serde_json::json!({
                 "success": true,
@@ -359,6 +576,14 @@ pub async fn update_graph(state: web::Data<AppState>) -> impl Responder {
                     for node in &graph.nodes {
                         node_map.insert(node.id.clone(), node.clone());
                     }
+
+                    // Take a layout snapshot after updating the graph
+                    info!("Taking layout snapshot after graph update");
+                    if let Err(e) = state.graph_service.take_layout_snapshot().await {
+                        warn!("Failed to take layout snapshot: {}", e);
+                    } else {
+                        info!("Layout snapshot saved successfully after update");
+                    }
                     
                     debug!("Graph updated successfully");
                     
diff --git a/handlers/health_handler.rs b/src/handlers/health_handler.rs
similarity index 100%
rename from handlers/health_handler.rs
rename to src/handlers/health_handler.rs
diff --git a/handlers/mod.rs b/src/handlers/mod.rs
similarity index 100%
rename from handlers/mod.rs
rename to src/handlers/mod.rs
diff --git a/handlers/nostr_handler.rs b/src/handlers/nostr_handler.rs
similarity index 81%
rename from handlers/nostr_handler.rs
rename to src/handlers/nostr_handler.rs
index 11bbf037..506c1b15 100644
--- a/handlers/nostr_handler.rs
+++ b/src/handlers/nostr_handler.rs
@@ -4,6 +4,7 @@ use crate::services::nostr_service::{NostrService, AuthEvent, NostrError};
 use crate::config::feature_access::FeatureAccess;
 use actix_web::{web, Error, HttpRequest, HttpResponse};
 use serde::{Deserialize, Serialize};
+use log::{debug, error, info};
 use serde_json::json;
 
 #[derive(Debug, Serialize)]
@@ -66,12 +67,15 @@ async fn check_power_user_status(
     req: HttpRequest,
     feature_access: web::Data<FeatureAccess>,
 ) -> Result<HttpResponse, Error> {
-    let pubkey = req.headers()
+    let pubkey_raw = req.headers()
         .get("X-Nostr-Pubkey")
         .and_then(|h| h.to_str().ok())
         .unwrap_or("");
+        
+    let pubkey = pubkey_raw.trim();
+    debug!("Checking power user status for pubkey: '{}'", pubkey);
 
-    if pubkey.is_empty() {
+    if pubkey.is_empty() { 
         return Ok(HttpResponse::BadRequest().json(json!({
             "error": "Missing Nostr pubkey"
         })));
@@ -86,12 +90,15 @@ async fn get_available_features(
     req: HttpRequest,
     feature_access: web::Data<FeatureAccess>,
 ) -> Result<HttpResponse, Error> {
-    let pubkey = req.headers()
+    let pubkey_raw = req.headers()
         .get("X-Nostr-Pubkey")
         .and_then(|h| h.to_str().ok())
         .unwrap_or("");
+        
+    let pubkey = pubkey_raw.trim();
+    debug!("Getting available features for pubkey: '{}'", pubkey);
 
-    if pubkey.is_empty() {
+    if pubkey.is_empty() { 
         return Ok(HttpResponse::BadRequest().json(json!({
             "error": "Missing Nostr pubkey"
         })));
@@ -108,12 +115,15 @@ async fn check_feature_access(
     feature_access: web::Data<FeatureAccess>,
     feature: web::Path<String>,
 ) -> Result<HttpResponse, Error> {
-    let pubkey = req.headers()
+    let pubkey_raw = req.headers()
         .get("X-Nostr-Pubkey")
         .and_then(|h| h.to_str().ok())
         .unwrap_or("");
+        
+    let pubkey = pubkey_raw.trim();
+    debug!("Checking access to feature '{}' for pubkey: '{}'", feature, pubkey);
 
-    if pubkey.is_empty() {
+    if pubkey.is_empty() { 
         return Ok(HttpResponse::BadRequest().json(json!({
             "error": "Missing Nostr pubkey"
         })));
@@ -129,7 +139,9 @@ async fn login(
     nostr_service: web::Data<NostrService>,
     feature_access: web::Data<FeatureAccess>,
 ) -> Result<HttpResponse, Error> {
+    info!("Handling login request for pubkey: {}", event.pubkey.trim());
     match nostr_service.verify_auth_event(event.into_inner()).await {
+        
         Ok(user) => {
             let token = user.session_token.clone().unwrap_or_default();
             let expires_at = user.last_seen + std::env::var("AUTH_TOKEN_EXPIRY")
@@ -146,6 +158,9 @@ async fn login(
                 npub: Some(user.npub.clone()),
                 is_power_user: user.is_power_user,
             };
+            
+            debug!("Login successful for pubkey: {}, is_power_user: {}, features: {:?}", 
+                user.pubkey.trim(), user.is_power_user, features);
 
             Ok(HttpResponse::Ok().json(AuthResponse {
                 user: user_dto,
@@ -160,7 +175,8 @@ async fn login(
             })))
         }
         Err(e) => {
-            Ok(HttpResponse::InternalServerError().json(json!({
+            error!("Authentication error: {}", e);
+            Ok(HttpResponse::InternalServerError().json(json!({ 
                 "error": format!("Authentication error: {}", e)
             })))
         }
@@ -171,14 +187,17 @@ async fn logout(
     req: web::Json<ValidateRequest>,
     nostr_service: web::Data<NostrService>,
 ) -> Result<HttpResponse, Error> {
+    let pubkey = req.pubkey.trim();
+    debug!("Handling logout request for pubkey: '{}'", pubkey);
+    
     // Validate session before logout
-    if !nostr_service.validate_session(&req.pubkey, &req.token).await {
+    if !nostr_service.validate_session(pubkey, &req.token).await {
         return Ok(HttpResponse::Unauthorized().json(json!({
             "error": "Invalid session"
         })));
     }
 
-    match nostr_service.logout(&req.pubkey).await {
+    match nostr_service.logout(pubkey).await {
         Ok(_) => Ok(HttpResponse::Ok().json(json!({
             "message": "Logged out successfully"
         }))),
@@ -193,13 +212,18 @@ async fn verify(
     nostr_service: web::Data<NostrService>,
     feature_access: web::Data<FeatureAccess>,
 ) -> Result<HttpResponse, Error> {
-    let is_valid = nostr_service.validate_session(&req.pubkey, &req.token).await;
+    let pubkey = req.pubkey.trim();
+    debug!("Verifying session for pubkey: '{}'", pubkey);
+    
+    let is_valid = nostr_service.validate_session(pubkey, &req.token).await;
     let user = if is_valid {
-        nostr_service.get_user(&req.pubkey).await
+        debug!("Session is valid, getting user info");
+        nostr_service.get_user(pubkey).await
                 .map(|u| UserResponseDTO {
                     pubkey: u.pubkey,
                     npub: Some(u.npub),
                     is_power_user: u.is_power_user,
+                    
                 })
     } else {
         None
@@ -207,7 +231,7 @@ async fn verify(
 
     // Get available features if session is valid
     let features = if is_valid {
-        feature_access.get_available_features(&req.pubkey)
+        feature_access.get_available_features(pubkey)
     } else {
         Vec::new()
     };
@@ -224,22 +248,24 @@ async fn refresh(
     nostr_service: web::Data<NostrService>,
     feature_access: web::Data<FeatureAccess>,
 ) -> Result<HttpResponse, Error> {
+    let pubkey = req.pubkey.trim();
+    debug!("Refreshing session for pubkey: '{}'", pubkey);
     // First validate the current session
-    if !nostr_service.validate_session(&req.pubkey, &req.token).await {
+    if !nostr_service.validate_session(pubkey, &req.token).await {
         return Ok(HttpResponse::Unauthorized().json(json!({
             "error": "Invalid session"
         })));
     }
 
-    match nostr_service.refresh_session(&req.pubkey).await {
+    match nostr_service.refresh_session(pubkey).await {
         Ok(new_token) => {
-            if let Some(user) = nostr_service.get_user(&req.pubkey).await {
+            if let Some(user) = nostr_service.get_user(pubkey).await {
                 let expires_at = user.last_seen + std::env::var("AUTH_TOKEN_EXPIRY")
                     .unwrap_or_else(|_| "3600".to_string())
                     .parse::<i64>()
                     .unwrap_or(3600);
 // Get available features for the refreshed session
-let features = feature_access.get_available_features(&req.pubkey);
+let features = feature_access.get_available_features(pubkey);
 
 Ok(HttpResponse::Ok().json(AuthResponse {
     user: UserResponseDTO {
@@ -268,13 +294,16 @@ async fn update_api_keys(
     nostr_service: web::Data<NostrService>,
     pubkey: web::Path<String>,
 ) -> Result<HttpResponse, Error> {
+    let trimmed_pubkey = pubkey.trim().to_string();
     let api_keys = ApiKeys {
         perplexity: req.perplexity.clone(),
         openai: req.openai.clone(),
         ragflow: req.ragflow.clone(),
     };
+    
+    debug!("Updating API keys for pubkey: '{}'", trimmed_pubkey);
 
-    match nostr_service.update_user_api_keys(&pubkey, api_keys).await {
+    match nostr_service.update_user_api_keys(&trimmed_pubkey, api_keys).await {
         Ok(user) => {
             let user_dto = UserResponseDTO {
                 pubkey: user.pubkey.clone(),
@@ -303,9 +332,12 @@ async fn update_api_keys(
 
 async fn get_api_keys(
     state: web::Data<AppState>,
-    pubkey: web::Path<String>,
+    pubkey_param: web::Path<String>,
 ) -> Result<HttpResponse, Error> {
+    let pubkey = pubkey_param.trim();
+    debug!("Getting API keys for pubkey: '{}'", pubkey);
     let protected_settings = state.protected_settings.read().await;
+    
     let api_keys = protected_settings.get_api_keys(&pubkey);
     
     Ok(HttpResponse::Ok().json(api_keys))
diff --git a/handlers/pages_handler.rs b/src/handlers/pages_handler.rs
similarity index 100%
rename from handlers/pages_handler.rs
rename to src/handlers/pages_handler.rs
diff --git a/src/handlers/perplexity_handler.rs b/src/handlers/perplexity_handler.rs
new file mode 100755
index 00000000..7838d616
--- /dev/null
+++ b/src/handlers/perplexity_handler.rs
@@ -0,0 +1,58 @@
+use crate::AppState;
+use actix_web::{post, web, HttpResponse, Responder};
+use serde::{Deserialize, Serialize};
+use serde_json::json; 
+use log::info;
+
+#[derive(Debug, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PerplexityRequest {
+    pub query: String,
+    pub conversation_id: Option<String>,
+}
+
+#[derive(Debug, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PerplexityResponse {
+    pub answer: String,
+    pub conversation_id: String,
+}
+
+#[post("")]
+pub async fn handle_perplexity(
+    state: web::Data<AppState>,
+    request: web::Json<PerplexityRequest>,
+) -> impl Responder {
+    info!("Received perplexity request: {:?}", request);
+
+    let _perplexity_service = match &state.perplexity_service {
+        Some(service) => service,
+        None => return HttpResponse::ServiceUnavailable().json(json!({
+            "error": "Perplexity service is not available"
+        }))
+    };
+
+    let conversation_id = state.ragflow_conversation_id.clone();
+    
+    // TEMPORARILY COMMENTED OUT: Perplexity API call as per optimization requirements
+    // match perplexity_service.query(&request.query, &conversation_id).await {
+    //     Ok(answer) => {
+    //         let response = PerplexityResponse {
+    //             answer,
+    //             conversation_id,
+    //         };
+    //         HttpResponse::Ok().json(response)
+    //     }
+    //     Err(e) => {
+    //         error!("Error processing perplexity request: {}", e);
+    //         HttpResponse::InternalServerError().json(format!("Error: {}", e))
+    //     }
+    // }
+    
+    // Return a default response while the perplexity service is disabled
+    let response = PerplexityResponse {
+        answer: "The Perplexity service is temporarily disabled for performance optimization.".to_string(),
+        conversation_id,
+    };
+    HttpResponse::Ok().json(response)
+}
diff --git a/handlers/ragflow_handler.rs b/src/handlers/ragflow_handler.rs
similarity index 100%
rename from handlers/ragflow_handler.rs
rename to src/handlers/ragflow_handler.rs
diff --git a/handlers/settings_handler.rs b/src/handlers/settings_handler.rs
similarity index 100%
rename from handlers/settings_handler.rs
rename to src/handlers/settings_handler.rs
diff --git a/handlers/socket_flow_handler.rs b/src/handlers/socket_flow_handler.rs
similarity index 91%
rename from handlers/socket_flow_handler.rs
rename to src/handlers/socket_flow_handler.rs
index 2f28b871..cf145919 100644
--- a/handlers/socket_flow_handler.rs
+++ b/src/handlers/socket_flow_handler.rs
@@ -1,6 +1,7 @@
 use actix::prelude::*;
 use actix_web::{web, Error, HttpRequest, HttpResponse};
 use actix_web_actors::ws;
+use futures::future::{self, Future};
 use flate2::{write::ZlibEncoder, Compression};
 use log::{debug, error, info, warn};
 use std::io::Write;
@@ -14,6 +15,9 @@ use crate::utils::binary_protocol;
 use crate::types::vec3::Vec3Data;
 use crate::utils::socket_flow_messages::{BinaryNodeData, PingMessage, PongMessage};
 
+// Initialize node ID counter when module is loaded
+use crate::models::node::Node;
+
 // Constants for throttling debug logs
 const DEBUG_LOG_SAMPLE_RATE: usize = 10; // Only log 1 in 10 updates
 
@@ -27,6 +31,10 @@ const DEFAULT_MIN_UPDATE_RATE: u32 = 5;   // Min 5 updates per second when stabl
 const BATCH_UPDATE_WINDOW_MS: u64 = 200;  // Check motion every 200ms
 const DEFAULT_MAX_UPDATE_RATE: u32 = 60;  // Max 60 updates per second when active
 const DEFAULT_MOTION_THRESHOLD: f32 = 0.05;  // 5% of nodes need to be moving
+
+// Graph update check interval (check every 10 seconds)
+const GRAPH_UPDATE_CHECK_INTERVAL: std::time::Duration = std::time::Duration::from_secs(10);
+
 const DEFAULT_MOTION_DAMPING: f32 = 0.9;  // Smooth transitions in rate
 
 // Maximum value for u16 node IDs
@@ -62,6 +70,9 @@ pub struct SocketFlowServer {
     nodes_in_motion: usize,    // Counter for nodes currently in motion
     total_node_count: usize,   // Total node count for percentage calculation
     last_motion_check: Instant, // Last time we checked motion percentage
+    
+    // Graph update check
+    last_graph_update_check: Instant, // Last time we checked for graph updates
 }
 
 impl SocketFlowServer {
@@ -120,6 +131,7 @@ impl SocketFlowServer {
             nodes_in_motion: 0,
             total_node_count: 0,
             last_motion_check: Instant::now(),
+            last_graph_update_check: Instant::now(),
         }
     }
 
@@ -245,7 +257,7 @@ impl SocketFlowServer {
 
     // New method to mark a batch as sent
     fn mark_batch_sent(&mut self) { self.last_batch_time = Instant::now(); }
-    
+
     // New method to collect nodes that have changed position
     fn collect_changed_nodes(&mut self) -> Vec<(u16, BinaryNodeData)> {
         let mut changed_nodes = Vec::new();
@@ -278,6 +290,48 @@ impl Actor for SocketFlowServer {
                 act.last_activity = std::time::Instant::now();
             });
         }
+        
+        // Set up periodic graph update check
+        ctx.run_interval(GRAPH_UPDATE_CHECK_INTERVAL, |act, ctx| {
+            // Get current time and check if we should perform an update check
+            let now = Instant::now();
+            let elapsed = now.duration_since(act.last_graph_update_check);
+            
+            // Only check periodically to reduce overhead
+            if elapsed < GRAPH_UPDATE_CHECK_INTERVAL {
+                return;
+            }
+            
+            // Update timestamp first to prevent repeated checks
+            act.last_graph_update_check = now;
+            
+            // Clone what we need to avoid borrowing issues
+            let app_state_clone = act.app_state.clone();
+            
+            // Use a separate future for the async work, properly wrapped
+            let fut = async move { 
+                let status = app_state_clone.graph_update_status.read().await;
+                (status.update_available, status.nodes_changed)
+            };
+            
+            // Wrap the future and handle the result with proper actor context
+            let wrapped_fut = actix::fut::wrap_future::<_, Self>(fut);
+            ctx.spawn(wrapped_fut.map(|(update_available, nodes_changed), _act, ctx| {
+                // If an update is available, send notification to client
+                if update_available {
+                    let message = serde_json::json!({
+                        "type": "graphUpdateAvailable",
+                        "timestamp": chrono::Utc::now().timestamp_millis(),
+                        "nodesChanged": nodes_changed
+                    });
+                    
+                    if let Ok(msg_str) = serde_json::to_string(&message) {
+                        ctx.text(msg_str);
+                        info!("Notified client of available graph update with {} node changes", nodes_changed);
+                    }
+                }
+            }));
+        });
 
         // Send simple connection established message
         let response = serde_json::json!({
@@ -512,7 +566,7 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer
                                                 
                                                 // Use a simple recursive approach to restart the cycle
                                                 let _app_state = act.app_state.clone();
-                    let _settings_clone = act.settings.clone();
+                                                let _settings_clone = act.settings.clone();
                                                 ctx.run_later(next_interval, move |act, ctx| {
                                                     // Recursively call the handler to restart the cycle
                                                     act.handle(Ok(ws::Message::Text("{\"type\":\"requestInitialData\"}".to_string().into())), ctx);
@@ -546,6 +600,22 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer
                                     ctx.text(msg_str);
                                 }
                             }
+                            
+                            Some("fetchUpdatedGraph") => {
+                                // Client is requesting to fetch updated graph data
+                                info!("Client requesting to fetch updated graph data");
+                                
+                                // Reset the update flag in AppState
+                                let app_state = self.app_state.clone();
+                                let fut = async move {
+                                    let mut update_status = app_state.graph_update_status.write().await;
+                                    update_status.update_available = false;
+                                };
+                                
+                                // Run as actor future
+                                let fut = fut.into_actor(self);
+                                ctx.spawn(fut.map(|_, _, _| ()));
+                            }
                             Some("enableRandomization") => {
                                 if let Ok(enable_msg) = serde_json::from_value::<serde_json::Value>(msg.clone()) {
                                     let enabled = enable_msg.get("enabled").and_then(|e| e.as_bool()).unwrap_or(false);
@@ -736,6 +806,9 @@ pub async fn socket_flow_handler(
     app_state: web::Data<AppState>,
     settings: web::Data<Arc<RwLock<crate::config::Settings>>>,
 ) -> Result<HttpResponse, Error> {
+    // Initialize node ID counter from persistent storage
+    Node::initialize_id_counter();
+    
     let should_debug = settings.try_read().map(|s| {
         s.system.debug.enabled && s.system.debug.enable_websocket_debug
     }).unwrap_or(false);
diff --git a/handlers/visualization_handler.rs b/src/handlers/visualization_handler.rs
similarity index 100%
rename from handlers/visualization_handler.rs
rename to src/handlers/visualization_handler.rs
diff --git a/lib.rs b/src/lib.rs
similarity index 100%
rename from lib.rs
rename to src/lib.rs
diff --git a/main.rs b/src/main.rs
similarity index 56%
rename from main.rs
rename to src/main.rs
index 6125be43..23616df8 100755
--- a/main.rs
+++ b/src/main.rs
@@ -1,6 +1,7 @@
 use webxr::{
     AppState,
     config::Settings,
+    models::graph::GraphData,
     handlers::{
         api_handler,
         health_handler,
@@ -10,8 +11,9 @@ use webxr::{
     },
     services::{
         file_service::FileService,
-        graph_service::GraphService,
+        file_service::{GRAPH_CACHE_PATH, LAYOUT_CACHE_PATH}, // Added import for cache paths
         github::{GitHubClient, ContentAPI, GitHubConfig},
+        graph_service::GraphService,
     },
     utils::gpu_compute::GPUCompute
 };
@@ -21,7 +23,6 @@ use actix_cors::Cors;
 use actix_files::Files;
 use std::sync::Arc;
 use tokio::sync::RwLock;
-use tokio::time::Duration;
 use dotenvy::dotenv;
 use log::{error, info, debug, warn};
 use webxr::utils::logging::{init_logging_with_config, LogConfig};
@@ -117,6 +118,23 @@ async fn main() -> std::io::Result<()> {
     }
 
     info!("Loaded {} items from metadata store", metadata_store.len());
+    
+    // Ensure metadata directories are properly set up
+    if let Err(e) = tokio::fs::create_dir_all("/app/data/metadata/files").await {
+        warn!("Failed to create metadata directory: {}", e);
+    }
+    
+    // Ensure parent directories for cache files exist
+    if let Err(e) = tokio::fs::create_dir_all(std::path::Path::new(GRAPH_CACHE_PATH).parent().unwrap()).await {
+        warn!("Failed to create directory for graph cache: {}", e);
+    }
+    if let Err(e) = tokio::fs::create_dir_all(std::path::Path::new(LAYOUT_CACHE_PATH).parent().unwrap()).await {
+        warn!("Failed to create directory for layout cache: {}", e);
+    }
+    
+    if tokio::fs::metadata("/app/data/metadata").await.is_ok() {
+        info!("Verified metadata directory exists");
+    }
 
     // Update metadata in app state
     {
@@ -125,123 +143,62 @@ async fn main() -> std::io::Result<()> {
         info!("Loaded metadata into app state");
     }
 
-    // IMPORTANT: Build graph from metadata BEFORE attempting GPU initialization
-    // This prevents the "empty graph" initialization problem
-    info!("STEP 1: Building initial graph from metadata for physics simulation");
-    let graph_data = match GraphService::build_graph_from_metadata(&metadata_store).await {
-        Ok(data) => {
-            info!("Successfully built graph with {} nodes and {} edges", 
-                  data.nodes.len(), data.edges.len());
-            data
-        },
-        Err(e) => {
-            error!("Failed to build initial graph: {}", e);
-            return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to build initial graph: {}", e)));
-        }
-    };
-
-    // Validate graph data before proceeding with GPU initialization
-    if graph_data.nodes.is_empty() {
-        warn!("Graph contains no nodes. Using minimal test data to avoid empty GPU initialization");
-        // Could add dummy nodes here if needed
-    } else {
-        info!("Graph validation passed: contains {} nodes and {} edges", 
-              graph_data.nodes.len(), graph_data.edges.len());
-    }
-            
-    // STEP 2: Initialize GPU with the populated graph data
-    info!("STEP 2: Initializing GPU compute with populated graph data ({} nodes)", graph_data.nodes.len());
-    
-    // Implement maximum retry attempts for GPU initialization
-    const MAX_GPU_INIT_ATTEMPTS: usize = 3;
-    let mut gpu_instance = None;
-    let mut last_error = None;
-    
-    // Try multiple times to initialize GPU with exponential backoff
-    for attempt in 0..MAX_GPU_INIT_ATTEMPTS {
-        info!("GPU initialization attempt {}/{}", attempt + 1, MAX_GPU_INIT_ATTEMPTS);
-        
-        match GPUCompute::new(&graph_data).await {
-            Ok(instance) => {
-                info!(" GPU compute initialized successfully on attempt {}", attempt + 1);
-                gpu_instance = Some(instance);
-                break;
-            },
-            Err(e) => {
-                warn!(" GPU initialization failed (attempt {}/{}): {}", 
-                      attempt + 1, MAX_GPU_INIT_ATTEMPTS, e);
-                last_error = Some(e);
-                
-                if attempt + 1 < MAX_GPU_INIT_ATTEMPTS {
-                    let delay = 500 * (1 << attempt); // Exponential backoff
-                    info!("Retrying in {}ms...", delay);
-                    tokio::time::sleep(Duration::from_millis(delay)).await;
-                }
-            }
-        }
-    }
+    // Build initial graph from metadata and initialize GPU compute
+    // LAZY INITIALIZATION: We don't build the graph on startup anymore
+    // Instead, we'll build it when the first client request comes in
+    info!("LAZY INITIALIZATION ENABLED: Deferring graph building until first client request");
     
-    // Update app_state based on GPU initialization result
-    if let Some(instance) = gpu_instance {
-        info!("STEP 3: Updating app state with GPU compute instance");
-        app_state.gpu_compute = Some(instance);
-        
-        // Shut down the existing GraphService before creating a new one
-        info!("Shutting down existing graph service before reinitializing with GPU");
-        let shutdown_start = std::time::Instant::now();
-        app_state.graph_service.shutdown().await;
-        info!("Graph service shutdown completed in {:?}", shutdown_start.elapsed());
-        
-        // Add a small delay to ensure clean shutdown
-        tokio::time::sleep(Duration::from_millis(100)).await;
-        
-        // Reinitialize graph service with GPU compute
-        info!("Reinitializing graph service with GPU compute");
-        app_state.graph_service = GraphService::new(
-            settings.clone(), 
-            app_state.gpu_compute.clone()
-        ).await;
-        
-        info!("Graph service successfully reinitialized with GPU compute");
-    } else {
-        warn!("All GPU initialization attempts failed: {}. Falling back to CPU.", 
-              last_error.map(|e| e.to_string()).unwrap_or_else(|| "Unknown error".to_string()));
-        
-        // Shut down the existing GraphService before creating a new one with CPU fallback
-        app_state.graph_service.shutdown().await;
-        
-        // Initialize graph service with None as GPU compute (will use CPU fallback)
-        app_state.graph_service = GraphService::new(
-            settings.clone(), 
-            None
-        ).await;
-        
-        info!("Graph service initialized with CPU fallback");
-    }
-
-    // Update graph data in the graph service
-    info!("STEP 4: Updating graph service with built graph data");
-    let mut graph = app_state.graph_service.get_graph_data_mut().await;
-    let mut node_map = app_state.graph_service.get_node_map_mut().await;
-    *graph = graph_data;
+    // Initialize the GraphService with the settings, but don't build the graph yet
+    // GraphService will try to load from cache when first requested
+    info!("Initializing graph service with lazy loading");
     
-    // Update node_map with new graph nodes
-    node_map.clear();
-    for node in &graph.nodes {
-        node_map.insert(node.id.clone(), node.clone());
+    // Initialize GPU compute instance but don't populate it with data yet
+    match GPUCompute::new(&GraphData::default()).await {
+        Ok(gpu_instance) => {
+            info!("GPU compute initialized (empty) successfully for lazy loading");
+            app_state.gpu_compute = Some(gpu_instance);
+        },
+        Err(e) => warn!("Failed to initialize GPU compute: {}. Will use CPU fallback when needed.", e)
     }
     
-    drop(graph);
-    drop(node_map);
-
-    // Add a delay to allow GPU computation to run before accepting client connections
-    info!("Waiting for initial physics layout calculation to complete...");
-    tokio::time::sleep(Duration::from_millis(500)).await;
-    info!("Initial delay complete. Starting HTTP server...");
+    info!("Starting HTTP server with lazy graph initialization...");
 
     // Create web::Data after all initialization is complete
     let app_state_data = web::Data::new(app_state);
 
+    // Pre-build graph to ensure cache files are created on startup
+    if metadata_store.len() > 0 {
+        info!("Pre-building graph to ensure cache files are created on startup");
+        match GraphService::build_graph_from_metadata(&metadata_store).await {
+            Ok(graph) => {
+                info!("Successfully pre-built graph with {} nodes, {} edges", graph.nodes.len(), graph.edges.len());
+                
+                // Update the app state's graph service with the built graph
+                let mut app_graph = app_state_data.graph_service.get_graph_data_mut().await;
+                *app_graph = graph.clone();
+                drop(app_graph);
+                
+                // Update the node map too
+                let mut node_map = app_state_data.graph_service.get_node_map_mut().await;
+                node_map.clear();
+                for node in &graph.nodes {
+                    node_map.insert(node.id.clone(), node.clone());
+                }
+                drop(node_map);
+                
+                // Explicitly verify the cache files were created
+                if let Err(e) = tokio::fs::metadata(GRAPH_CACHE_PATH).await {
+                    warn!("Graph cache file was not created: {}", e);
+                }
+                if let Err(e) = tokio::fs::metadata(LAYOUT_CACHE_PATH).await {
+                    warn!("Layout cache file was not created: {}", e);
+                }
+            },
+            Err(e) => warn!("Failed to pre-build graph: {}. Cache files may not be created until first request", e)
+        }
+        info!("Pre-build process completed");
+    }
+
     // Start the server
     let bind_address = {
         let settings_read = settings.read().await;
diff --git a/models/edge.rs b/src/models/edge.rs
similarity index 100%
rename from models/edge.rs
rename to src/models/edge.rs
diff --git a/src/models/graph.rs b/src/models/graph.rs
new file mode 100755
index 00000000..bb648b17
--- /dev/null
+++ b/src/models/graph.rs
@@ -0,0 +1,67 @@
+use crate::utils::socket_flow_messages::Node;
+use super::edge::Edge;
+use super::metadata::MetadataStore;
+use serde::{Deserialize, Serialize};
+use std::collections::HashMap;
+use chrono::{DateTime, Utc, Duration};
+
+/// Represents the graph data structure containing nodes, edges, and metadata.
+/// All fields use camelCase serialization for client compatibility.
+#[derive(Default, Serialize, Deserialize, Clone, Debug)]
+#[serde(rename_all = "camelCase")]
+pub struct GraphData {
+    /// List of nodes in the graph.
+    pub nodes: Vec<Node>,
+    /// List of edges connecting the nodes.
+    pub edges: Vec<Edge>,
+    /// Metadata associated with the graph, using camelCase keys.
+    pub metadata: MetadataStore,
+    /// Timestamp when the graph was last validated against metadata
+    pub last_validated: DateTime<Utc>,
+    /// Mapping from numeric ID to metadata ID (filename) for lookup
+    #[serde(skip)]
+    pub id_to_metadata: HashMap<String, String>,
+    /// Flag to indicate if the graph has been hot-started from cache
+    #[serde(skip)]
+    pub hot_started: bool,
+}
+
+/// Status of background graph updates for WebSocket clients to check
+#[derive(Clone, Debug)]
+pub struct GraphUpdateStatus {
+    /// Timestamp of the last update check
+    pub last_check: DateTime<Utc>,
+    /// Timestamp of the most recent update
+    pub last_update: DateTime<Utc>,
+    /// Whether an update is available that clients should fetch
+    pub update_available: bool,
+    /// Count of nodes changed in the last update
+    pub nodes_changed: i32,
+}
+
+impl Default for GraphUpdateStatus {
+    fn default() -> Self {
+        let now = Utc::now();
+        Self {
+            last_check: now,
+            last_update: now - Duration::hours(1), // Initial offset to ensure first check is considered new
+            update_available: false,
+            nodes_changed: 0,
+        }
+    }
+}
+
+/// Implementation of GraphData for creating and manipulating graph data
+/// All fields use camelCase serialization for client compatibility
+impl GraphData {
+    pub fn new() -> Self {
+        Self {
+            nodes: Vec::new(),
+            edges: Vec::new(),
+            metadata: MetadataStore::new(),
+            last_validated: Utc::now(),
+            id_to_metadata: HashMap::new(),
+            hot_started: false,
+        }
+    }
+}
diff --git a/models/metadata.rs b/src/models/metadata.rs
similarity index 100%
rename from models/metadata.rs
rename to src/models/metadata.rs
diff --git a/models/mod.rs b/src/models/mod.rs
similarity index 100%
rename from models/mod.rs
rename to src/models/mod.rs
diff --git a/models/node.rs b/src/models/node.rs
similarity index 64%
rename from models/node.rs
rename to src/models/node.rs
index 43c1ab3d..dffbdd5c 100755
--- a/models/node.rs
+++ b/src/models/node.rs
@@ -1,11 +1,19 @@
 use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
-use std::sync::atomic::{AtomicU32, Ordering};
+use std::sync::atomic::{AtomicU32, Ordering, AtomicBool};
 use crate::utils::socket_flow_messages::BinaryNodeData;
 use crate::types::vec3::Vec3Data;
+use std::path::Path;
+use std::fs;
+use log::{info, warn};
 
 // Static counter for generating unique numeric IDs
 static NEXT_NODE_ID: AtomicU32 = AtomicU32::new(1);  // Start from 1 (0 could be reserved)
+static ID_INITIALIZED: AtomicBool = AtomicBool::new(false);
+
+// Constants for ID management
+const MAX_NODE_ID_FILE: &str = "data/metadata/max_node_id.txt";
+const MAX_U16_VALUE: u32 = 65535; // Maximum value for u16 to ensure compatibility with binary protocol
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "camelCase")]
@@ -39,20 +47,122 @@ pub struct Node {
 }
 
 impl Node {
+    /// Initialize the NEXT_NODE_ID counter from stored max ID
+    pub fn initialize_id_counter() {
+        // Only initialize once to prevent race conditions
+        if ID_INITIALIZED.swap(true, Ordering::SeqCst) {
+            return;
+        }
+
+        let max_id = Node::load_max_id_from_storage();
+        
+        // Update the counter if we found a valid ID
+        if max_id > 0 {
+            // Add 1 to ensure next ID is unique
+            let next_id = max_id + 1;
+            
+            // Ensure we don't exceed u16 limit for binary protocol compatibility
+            if next_id > MAX_U16_VALUE {
+                warn!("Loaded max node ID {} exceeds u16 limit. Resetting to 1.", max_id);
+                NEXT_NODE_ID.store(1, Ordering::SeqCst);
+            } else {
+                info!("Initialized node ID counter with value {} (loaded max ID: {})", next_id, max_id);
+                NEXT_NODE_ID.store(next_id, Ordering::SeqCst);
+            }
+        } else {
+            info!("No valid max node ID found, starting from 1");
+            NEXT_NODE_ID.store(1, Ordering::SeqCst);
+        }
+    }
+    
+    /// Load the maximum node ID from storage
+    fn load_max_id_from_storage() -> u32 {
+        // Check if the file exists
+        if !Path::new(MAX_NODE_ID_FILE).exists() {
+            return 0;
+        }
+        
+        // Try to read the file
+        match fs::read_to_string(MAX_NODE_ID_FILE) {
+            Ok(content) => {
+                // Try to parse the content as u32
+                match content.trim().parse::<u32>() {
+                    Ok(id) => {
+                        if id > 0 && id <= MAX_U16_VALUE {
+                            return id;
+                        } else {
+                            warn!("Invalid node ID in storage: {}, must be between 1 and {}", id, MAX_U16_VALUE);
+                        }
+                    },
+                    Err(e) => warn!("Failed to parse node ID from storage: {}", e)
+                }
+            },
+            Err(e) => warn!("Failed to read max node ID file: {}", e)
+        }
+        
+        0 // Return 0 if loading failed
+    }
+    
+    /// Save the current maximum node ID to storage
+    fn save_max_id_to_storage(id: u32) {
+        // Create parent directory if it doesn't exist
+        if let Some(parent) = Path::new(MAX_NODE_ID_FILE).parent() {
+            if !parent.exists() {
+                if let Err(e) = fs::create_dir_all(parent) {
+                    warn!("Failed to create directory for max node ID: {}", e);
+                    return;
+                }
+            }
+        }
+        
+        // Write the ID to the file
+        if let Err(e) = fs::write(MAX_NODE_ID_FILE, id.to_string()) {
+            warn!("Failed to save max node ID to storage: {}", e);
+        }
+    }
+    
     pub fn new(metadata_id: String) -> Self {
+        // Ensure ID counter is initialized
+        if !ID_INITIALIZED.load(Ordering::SeqCst) {
+            Node::initialize_id_counter();
+        }
+        
         Self::new_with_id(metadata_id, None)
     }
 
     pub fn new_with_id(metadata_id: String, provided_id: Option<String>) -> Self {
+        // Ensure ID counter is initialized
+        if !ID_INITIALIZED.load(Ordering::SeqCst) {
+            Node::initialize_id_counter();
+        }
+        
         // Always generate a new ID on the server side
         // Use provided ID only if it's a valid numeric string (from a previous session)
         let id = match provided_id {
             Some(id) if !id.is_empty() && id != "0" && id.parse::<u32>().is_ok() => {
-                // Use the provided ID only if it's a valid numeric ID
-                id
+                let parsed_id = id.parse::<u32>().unwrap();
+                
+                // Ensure we update our counter if this ID is higher
+                if parsed_id > NEXT_NODE_ID.load(Ordering::SeqCst) {
+                    NEXT_NODE_ID.store(parsed_id + 1, Ordering::SeqCst);
+                    // Save the new maximum ID
+                    Node::save_max_id_to_storage(parsed_id);
+                }
+                
+                // Return the provided ID
+                id.clone()
             },
             _ => {
-                NEXT_NODE_ID.fetch_add(1, Ordering::SeqCst).to_string()
+                // Generate a new unique ID and save it
+                let new_id = NEXT_NODE_ID.fetch_add(1, Ordering::SeqCst);
+                
+                // Save the new maximum ID periodically (every 10 IDs)
+                if new_id % 10 == 0 {
+                    Node::save_max_id_to_storage(new_id);
+                }
+                
+                // Return the new ID as string
+                new_id.to_string()
             }
         };
         
diff --git a/models/pagination.rs b/src/models/pagination.rs
similarity index 100%
rename from models/pagination.rs
rename to src/models/pagination.rs
diff --git a/models/protected_settings.rs b/src/models/protected_settings.rs
similarity index 100%
rename from models/protected_settings.rs
rename to src/models/protected_settings.rs
diff --git a/models/simulation_params.rs b/src/models/simulation_params.rs
similarity index 100%
rename from models/simulation_params.rs
rename to src/models/simulation_params.rs
diff --git a/models/ui_settings.rs b/src/models/ui_settings.rs
similarity index 100%
rename from models/ui_settings.rs
rename to src/models/ui_settings.rs
diff --git a/models/user_settings.rs b/src/models/user_settings.rs
similarity index 100%
rename from models/user_settings.rs
rename to src/models/user_settings.rs
diff --git a/services/file_service.rs b/src/services/file_service.rs
similarity index 70%
rename from services/file_service.rs
rename to src/services/file_service.rs
index 519ae9ae..bc0ef94f 100755
--- a/services/file_service.rs
+++ b/src/services/file_service.rs
@@ -2,7 +2,7 @@ use crate::models::metadata::{Metadata, MetadataStore, MetadataOps};
 use crate::models::graph::GraphData;
 use crate::config::Settings;
 use serde::{Deserialize, Serialize};
-use log::{info, debug, error};
+use log::{info, debug, error, warn};
 use std::sync::atomic::{AtomicU32, Ordering};
 use regex::Regex;
 use std::fs;
@@ -20,7 +20,11 @@ use std::io::Error;
 use super::github::{GitHubClient, ContentAPI, GitHubConfig};
 
 // Constants
-const METADATA_PATH: &str = "/app/data/metadata/metadata.json";
+pub const METADATA_PATH: &str = "/app/data/metadata/metadata.json"; // Legacy combined metadata path
+pub const METADATA_DIR: &str = "/app/data/metadata";
+pub const FILE_METADATA_DIR: &str = "/app/data/metadata/files"; // Directory for individual file metadata
+pub const GRAPH_CACHE_PATH: &str = "/app/data/metadata/graph.json"; // Path for cached graph data
+pub const LAYOUT_CACHE_PATH: &str = "/app/data/metadata/layout.json"; // Path for cached layout data
 pub const MARKDOWN_DIR: &str = "/app/data/markdown";
 const GITHUB_API_DELAY: Duration = Duration::from_millis(500);
 
@@ -184,8 +188,31 @@ impl FileService {
     /// Load metadata from file or create new if not exists
     pub fn load_or_create_metadata() -> Result<MetadataStore, String> {
         // Ensure metadata directory exists
-        std::fs::create_dir_all("/app/data/metadata")
+        std::fs::create_dir_all(METADATA_DIR)
             .map_err(|e| format!("Failed to create metadata directory: {}", e))?;
+            
+        // Explicitly set permissions on metadata directory to ensure it's writable
+        #[cfg(unix)]
+        {
+            use std::os::unix::fs::PermissionsExt;
+            if let Err(e) = std::fs::set_permissions(METADATA_DIR, std::fs::Permissions::from_mode(0o777)) {
+                warn!("Could not set permissions on metadata directory: {}", e);
+                // Continue anyway, as this is not critical
+            } else {
+                info!("Successfully set permissions on metadata directory");
+            }
+        }
+            
+        // Ensure file metadata directory exists
+        std::fs::create_dir_all(FILE_METADATA_DIR)
+            .map_err(|e| format!("Failed to create file metadata directory: {}", e))?;
+
+        // Also set permissions on the file metadata directory
+        #[cfg(unix)]
+        {
+            use std::os::unix::fs::PermissionsExt;
+            let _ = std::fs::set_permissions(FILE_METADATA_DIR, std::fs::Permissions::from_mode(0o777));
+        }
         
         let metadata_path = "/app/data/metadata/metadata.json";
         
@@ -264,6 +291,10 @@ impl FileService {
     pub async fn initialize_local_storage(
         settings: Arc<RwLock<Settings>>,
     ) -> Result<(), Box<dyn StdError + Send + Sync>> {
+        // First ensure directories exist with proper permissions
+        info!("Ensuring metadata directories exist with proper permissions");
+        Self::ensure_directories()?;
+        
         // Create GitHub client using environment variables
         let github_config = GitHubConfig::from_env()
             .map_err(|e| Box::new(e) as Box<dyn StdError + Send + Sync>)?;
@@ -279,9 +310,6 @@ impl FileService {
 
         info!("Initializing local storage with files from GitHub");
 
-        // Ensure directories exist and have proper permissions
-        Self::ensure_directories()?;
-
         // Get all markdown files from GitHub
         let github_files = content_api.list_markdown_files("").await?;
         info!("Found {} markdown files in GitHub", github_files.len());
@@ -467,13 +495,97 @@ impl FileService {
             }
         }
     }
+    
+    /// Load metadata for a single file
+    pub fn load_file_metadata(file_name: &str) -> Result<Option<Metadata>, Error> {
+        let file_path = format!("{}/{}.json", FILE_METADATA_DIR, file_name);
+        let metadata_path = Path::new(&file_path);
+        
+        if !metadata_path.exists() {
+            return Ok(None);
+        }
+        
+        match fs::read_to_string(metadata_path) {
+            Ok(content) => {
+                match serde_json::from_str::<Metadata>(&content) {
+                    Ok(metadata) => Ok(Some(metadata)),
+                    Err(e) => Err(Error::new(std::io::ErrorKind::InvalidData, 
+                        format!("Failed to parse metadata for {}: {}", file_name, e)))
+                }
+            },
+            Err(e) => Err(Error::new(std::io::ErrorKind::Other, 
+                format!("Failed to read metadata file for {}: {}", file_name, e)))
+        }
+    }
+    
+    /// Save metadata for a single file
+    pub fn save_file_metadata(file_name: &str, metadata: &Metadata) -> Result<(), Error> {
+        let file_path = format!("{}/{}.json", FILE_METADATA_DIR, file_name);
+        
+        // Serialize the metadata to JSON
+        let json = serde_json::to_string_pretty(metadata)
+            .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+            
+        // Write to file
+        fs::write(&file_path, json)
+            .map_err(|e| Error::new(std::io::ErrorKind::Other, 
+                format!("Failed to write metadata for {}: {}", file_name, e)))
+    }
+    
+    /// Check if a file has changed by comparing SHA1 hashes
+    pub fn has_file_changed(file_name: &str, content: &str) -> Result<bool, Error> {
+        // Calculate the SHA1 hash of the current content
+        let current_hash = Self::calculate_sha1(content);
+        
+        // Try to load the existing metadata
+        match Self::load_file_metadata(file_name)? {
+            Some(metadata) => {
+                // If we have metadata, compare the SHA1 hashes
+                Ok(metadata.sha1 != current_hash)
+            },
+            None => {
+                // If we don't have metadata, the file is considered changed
+                Ok(true)
+            }
+        }
+    }
+    
+    /// Load metadata from individual files
+    pub fn load_all_file_metadata() -> Result<MetadataStore, Error> {
+        let mut metadata_store = MetadataStore::new();
+        
+        // Read all .json files in the file metadata directory
+        if let Ok(entries) = fs::read_dir(FILE_METADATA_DIR) {
+            for entry in entries.filter_map(Result::ok) {
+                if let Some(file_name) = entry.file_name().to_str().map(|s| s.to_owned()) {
+                    if file_name.ends_with(".json") {
+                        let base_name = file_name.trim_end_matches(".json");
+                        if let Ok(Some(metadata)) = Self::load_file_metadata(base_name) {
+                            metadata_store.insert(base_name.to_owned(), metadata);
+                        }
+                    }
+                }
+            }
+        }
+        
+        Ok(metadata_store)
+    }
 
     /// Save metadata to file
     pub fn save_metadata(metadata: &MetadataStore) -> Result<(), Error> {
+        // Save combined metadata for backward compatibility
         let json = serde_json::to_string_pretty(metadata)
             .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
         fs::write(METADATA_PATH, json)
             .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+        
+        // Save individual file metadata
+        for (file_name, metadata) in metadata {
+            if let Err(e) = Self::save_file_metadata(file_name, metadata) {
+                error!("Failed to save individual metadata for {}: {}", file_name, e);
+            }
+        }
+        
         Ok(())
     }
 
@@ -494,12 +606,14 @@ impl FileService {
     /// Fetch and process files from GitHub
     pub async fn fetch_and_process_files(
         &self,
-        content_api: Arc<ContentAPI>,
+        content_api: &Arc<ContentAPI>,
         _settings: Arc<RwLock<Settings>>,
         metadata_store: &mut MetadataStore,
     ) -> Result<Vec<ProcessedFile>, Box<dyn StdError + Send + Sync>> {
         let mut processed_files = Vec::new();
-
+        
+        info!("Starting optimized file processing with hash-based invalidation");
+        
         // Get all markdown files from GitHub
         let github_files = content_api.list_markdown_files("").await?;
         info!("Found {} markdown files in GitHub", github_files.len());
@@ -524,35 +638,67 @@ impl FileService {
 
                             // Only fetch full content for public files
                             match content_api.fetch_file_content(&file_meta.download_url).await {
-                                Ok(content) => {
+                                Ok(content) => {                                
                                     let file_path = format!("{}/{}", MARKDOWN_DIR, file_meta.name);
-                                    if let Err(e) = fs::write(&file_path, &content) {
-                                        error!("Failed to write file {}: {}", file_path, e);
-                                        return Err(e.into());
-                                    }
-
-                                    let file_size = content.len();
-                                    let node_size = Self::calculate_node_size(file_size);
-
-                                    let metadata = Metadata {
-                                        file_name: file_meta.name.clone(),
-                                        file_size,
-                                        node_size,
-                                        node_id: "0".to_string(), // Will be assigned properly later
-                                        hyperlink_count: Self::count_hyperlinks(&content),
-                                        sha1: Self::calculate_sha1(&content),
-                                        last_modified: file_meta.last_modified.unwrap_or_else(|| Utc::now()),
-                                        perplexity_link: String::new(),
-                                        last_perplexity_process: None,
-                                        topic_counts: HashMap::new(), // Will be updated later
+                                    // Calculate the SHA1 hash of the content
+                                    let new_sha1 = Self::calculate_sha1(&content);
+                                    
+                                    // Check if the file has changed by comparing SHA1 hashes
+                                    let file_changed = match Self::load_file_metadata(&file_meta.name) {
+                                        Ok(Some(existing_metadata)) => {
+                                            let changed = existing_metadata.sha1 != new_sha1;
+                                            if !changed {
+                                                debug!("File {} unchanged (SHA1 match), skipping processing", file_meta.name);
+                                            } else {
+                                                debug!("File {} has changed, reprocessing", file_meta.name);
+                                            }
+                                            changed
+                                        },
+                                        _ => {
+                                            debug!("No existing metadata for {}, processing as new file", file_meta.name);
+                                            true
+                                        }
                                     };
-
-                                    Ok(Some(ProcessedFile {
-                                        file_name: file_meta.name.clone(),
-                                        content,
-                                        is_public: true,
-                                        metadata,
-                                    }))
+                                    
+                                    // Only process the file if it has changed or if we don't have metadata for it
+                                    if file_changed {
+                                        // Write the content to the file
+                                        if let Err(e) = fs::write(&file_path, &content) {
+                                            error!("Failed to write file {}: {}", file_path, e);
+                                            return Err(e.into());
+                                        }
+
+                                        let file_size = content.len();
+                                        let node_size = Self::calculate_node_size(file_size);
+
+                                        // Create new metadata or update existing
+                                        let mut metadata = Self::load_file_metadata(&file_meta.name)
+                                            .unwrap_or_default()
+                                            .unwrap_or_default();
+                                            
+                                        // Update metadata fields
+                                        metadata.file_name = file_meta.name.clone();
+                                        metadata.file_size = file_size;
+                                        metadata.node_size = node_size;
+                                        metadata.hyperlink_count = Self::count_hyperlinks(&content);
+                                        metadata.sha1 = new_sha1;
+                                        metadata.last_modified = file_meta.last_modified.unwrap_or_else(|| Utc::now());
+                                        
+                                        // Keep existing values for these fields if present
+                                        if metadata.node_id == "0" || metadata.node_id.is_empty() {
+                                            metadata.node_id = "0".to_string(); // Will be assigned properly later
+                                        }
+
+                                        Ok(Some(ProcessedFile {
+                                            file_name: file_meta.name.clone(),
+                                            content,
+                                            is_public: true,
+                                            metadata,
+                                        }))
+                                    } else {
+                                        // If the file hasn't changed, return None so we don't process it again
+                                        Ok(None)
+                                    }
                                 }
                                 Err(e) => {
                                     error!("Failed to fetch content for {}: {}", file_meta.name, e);
@@ -574,7 +720,17 @@ impl FileService {
             for result in results {
                 match result {
                     Ok(Some(processed_file)) => {
+                        // Save individual file metadata
+                        if let Err(e) = Self::save_file_metadata(
+                            &processed_file.file_name, 
+                            &processed_file.metadata
+                        ) {
+                            error!("Failed to save metadata for {}: {}", 
+                                processed_file.file_name, e);
+                        }
+                        
                         processed_files.push(processed_file);
+                        info!("Processed file: {}", processed_files.last().unwrap().file_name);
                     }
                     Ok(None) => continue, // Skipped non-public file
                     Err(e) => {
diff --git a/services/github/api.rs b/src/services/github/api.rs
similarity index 100%
rename from services/github/api.rs
rename to src/services/github/api.rs
diff --git a/services/github/config.rs b/src/services/github/config.rs
similarity index 100%
rename from services/github/config.rs
rename to src/services/github/config.rs
diff --git a/services/github/content.rs b/src/services/github/content.rs
similarity index 100%
rename from services/github/content.rs
rename to src/services/github/content.rs
diff --git a/services/github/mod.rs b/src/services/github/mod.rs
similarity index 100%
rename from services/github/mod.rs
rename to src/services/github/mod.rs
diff --git a/services/github/pr.rs b/src/services/github/pr.rs
similarity index 100%
rename from services/github/pr.rs
rename to src/services/github/pr.rs
diff --git a/services/github/types.rs b/src/services/github/types.rs
similarity index 100%
rename from services/github/types.rs
rename to src/services/github/types.rs
diff --git a/services/graph_service.rs b/src/services/graph_service.rs
similarity index 79%
rename from services/graph_service.rs
rename to src/services/graph_service.rs
index f1783b1b..dba4971c 100755
--- a/services/graph_service.rs
+++ b/src/services/graph_service.rs
@@ -11,7 +11,7 @@ use std::pin::Pin;
 use std::time::{Duration, Instant};
 use futures::Future;
 use log::{info, warn, error, debug};
-use scopeguard;
+use scopeguard; 
 
 use tokio::fs::File as TokioFile;
 use crate::models::graph::GraphData;
@@ -23,8 +23,11 @@ use crate::config::Settings;
 use crate::utils::gpu_compute::GPUCompute;
 use crate::models::simulation_params::{SimulationParams, SimulationPhase, SimulationMode};
 use crate::models::pagination::PaginatedGraphData;
+use tokio::io::AsyncReadExt;
 use tokio::sync::Mutex;
 use once_cell::sync::Lazy;
+use crate::services::file_service::GRAPH_CACHE_PATH;
+use crate::services::file_service::LAYOUT_CACHE_PATH;
 
 // Static flag to prevent multiple simultaneous graph rebuilds
 static GRAPH_REBUILD_IN_PROGRESS: AtomicBool = AtomicBool::new(false);
@@ -42,10 +45,7 @@ const NODE_POSITION_CACHE_TTL_MS: u64 = 50; // 50ms cache time
 const METADATA_FILE_WAIT_TIMEOUT_MS: u64 = 5000; // 5 second wait timeout
 const METADATA_FILE_CHECK_INTERVAL_MS: u64 = 100; // Check every 100ms
 // Constants for GPU retry mechanism
-const MAX_GPU_CALCULATION_RETRIES: u32 = 5; // Increased from 3 to 5 for more robustness
-const GPU_INIT_WAIT_MS: u64 = 1000; // Added wait time after initialization
-const EMPTY_GRAPH_THRESHOLD: usize = 5; // Minimum nodes to consider a graph "empty"
-const GRAPH_DATA_VALIDATION_ENABLED: bool = true; // Enable validation before GPU operations
+const MAX_GPU_CALCULATION_RETRIES: u32 = 3;
 const GPU_RETRY_DELAY_MS: u64 = 500; // 500ms delay between retries
 
 #[derive(Clone)]
@@ -84,7 +84,7 @@ impl GraphService {
         if gpu_compute.is_some() {
             info!("[GraphService] GPU compute is enabled - physics simulation will run");
             info!("[GraphService] Testing GPU compute functionality at startup");
-            tokio::spawn(Self::test_gpu_at_startup(gpu_compute.clone(), simulation_id.clone()));
+            tokio::spawn(Self::test_gpu_at_startup(gpu_compute.clone()));
         } else {
             error!("[GraphService] GPU compute is NOT enabled - physics simulation will use CPU fallback");
         }
@@ -138,6 +138,9 @@ impl GraphService {
         // Release the mutex before spawning the task
         drop(guard);
         
+        // Try to load cached graph data
+        let _ = Self::try_load_cached_graph_data(Arc::clone(&graph_service.graph_data)).await;
+        
         info!("[GraphService] Starting physics simulation loop (ID: {})", loop_simulation_id);
         tokio::spawn(async move {
             let params = SimulationParams {
@@ -272,63 +275,7 @@ impl GraphService {
     }
     
     /// Test GPU compute at startup to verify it's working
-    async fn test_gpu_at_startup(gpu_compute: Option<Arc<RwLock<GPUCompute>>>, instance_id: String) {
-        // Add a small delay to let other initialization complete
-        tokio::time::sleep(Duration::from_millis(GPU_INIT_WAIT_MS)).await;
-        
-        info!("[GraphService:{}] Running GPU startup test", instance_id);
-        
-        if let Some(gpu) = &gpu_compute {
-            match gpu.read().await.test_compute() {
-                Ok(_) => {
-                    info!("[GraphService:{}]  GPU test computation succeeded - GPU physics is working", instance_id);
-                },
-                Err(e) => {
-                    error!("[GraphService:{}]  GPU test computation failed: {}", instance_id, e);
-                    error!("[GraphService:{}] The system will fall back to CPU physics which may be slower", instance_id);
-                    
-                    // Try initializing a new GPU instance
-                    info!("[GraphService:{}] Attempting to reinitialize GPU...", instance_id);
-                    let _new_gpu = GPUCompute::new(&GraphData::default()).await; // Using _ to avoid unused warning
-                }
-            }
-        } else {
-            error!("[GraphService:{}]  No GPU compute instance available for testing", instance_id);
-        }
-    }
-    
-    /// Validate graph data before GPU operations
-    fn validate_graph_data(graph: &GraphData) -> Result<(), Error> {
-        if !GRAPH_DATA_VALIDATION_ENABLED {
-            return Ok(());
-        }
-        
-        // Check for empty graph
-        if graph.nodes.is_empty() {
-            return Err(Error::new(ErrorKind::InvalidData, 
-                "Graph contains no nodes, cannot perform GPU computation on empty graph"));
-        }
-        
-        // Check for minimum node count threshold
-        if graph.nodes.len() < EMPTY_GRAPH_THRESHOLD {
-            warn!("[GraphService] Graph contains only {} nodes, which is below the recommended minimum of {}. 
-                  This may cause instability in GPU computation.", graph.nodes.len(), EMPTY_GRAPH_THRESHOLD);
-        }
-        
-        // Check for potential numerical issues
-        for node in &graph.nodes {
-            if node.data.position.x.is_nan() || node.data.position.y.is_nan() || node.data.position.z.is_nan() {
-                return Err(Error::new(ErrorKind::InvalidData, 
-                    format!("Node {} contains NaN coordinates which will cause GPU calculation failures", node.id)));
-            }
-        }
-        
-        Ok(())
-    }
-    
-    /// Original test_gpu_at_startup kept for backward compatibility, but using new implementation
-    #[deprecated(since="1.1.0", note="Use test_gpu_at_startup with instance_id parameter")]
-    async fn _legacy_test_gpu_at_startup(gpu_compute: Option<Arc<RwLock<GPUCompute>>>) {
+    async fn test_gpu_at_startup(gpu_compute: Option<Arc<RwLock<GPUCompute>>>) {
         // Add a small delay to let other initialization complete
         tokio::time::sleep(Duration::from_millis(1000)).await;
         
@@ -405,6 +352,35 @@ impl GraphService {
     pub async fn build_graph_from_metadata(metadata: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
         // Check if a rebuild is already in progress
         info!("Building graph from {} metadata entries", metadata.len());
+        
+        // Try to load from cache first if metadata has not changed
+        if let Ok(cached_graph) = Self::load_graph_cache().await {
+            // Check if cached graph matches current metadata
+            info!("Checking if cached graph is valid: {} cache entries vs {} metadata entries", cached_graph.metadata.len(), metadata.len());
+            if cached_graph.metadata.len() == metadata.len() {
+                // Simple check: count metadata items
+                let mut needs_rebuild = false;
+                
+                // More detailed check: compare sha1 hashes
+                for (file_name, meta) in metadata.iter() {
+                    if !cached_graph.metadata.contains_key(file_name) || 
+                       cached_graph.metadata[file_name].sha1 != meta.sha1 {
+                        needs_rebuild = true;
+                        break;
+                    }
+                }
+
+                if !needs_rebuild {
+                    info!("Cached graph is valid (all SHA1 hashes match), using it");
+                    let mut cloned_graph = cached_graph.clone();
+                    
+                    // Ensure timestamp is updated to show it was validated
+                    cloned_graph.last_validated = chrono::Utc::now();
+                    
+                    return Ok(cloned_graph);
+                }
+            }
+        }
         debug!("Building graph from {} metadata entries", metadata.len());
         
         if GRAPH_REBUILD_IN_PROGRESS.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst).is_err() {
@@ -553,10 +529,29 @@ impl GraphService {
             .collect();
 
         // Initialize random positions
-        Self::initialize_random_positions(&mut graph);
+        // Try to use cached layout positions first, fall back to random if not available
+        if let Err(e) = Self::initialize_positions(&mut graph).await {
+            warn!("Failed to initialize positions from cache: {}, using random positions", e);
+            Self::initialize_random_positions(&mut graph);
+        }
 
-        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
+        // Record validation timestamp
+        graph.last_validated = chrono::Utc::now();
+        
+        // Take a layout snapshot to provide for client initialization
+        info!("Taking layout snapshot after graph build");
+        if let Err(e) = Self::save_layout_cache(graph.clone()).await {
+            warn!("Failed to take layout snapshot: {}", e);
+        }
+        
+        info!("Built graph with {} nodes and {} edges (validated at {})",
+              graph.nodes.len(), graph.edges.len(), graph.last_validated);
         debug!("Completed graph build: {} nodes, {} edges", graph.nodes.len(), graph.edges.len());
+        
+        // Cache the graph data to disk
+        if let Err(e) = Self::save_graph_cache(&graph).await {
+            warn!("Failed to cache graph data: {}", e);
+        }
         Ok(graph)
     }
 
@@ -715,10 +710,25 @@ impl GraphService {
             .collect();
 
         // Initialize random positions for all nodes
-        Self::initialize_random_positions(&mut graph);
+        // Try to use cached layout positions first, fall back to random if not available
+        if let Err(e) = Self::initialize_positions(&mut graph).await {
+            warn!("Failed to initialize positions from cache: {}", e);
+            Self::initialize_random_positions(&mut graph);
+        }
 
         info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
         debug!("Completed graph build: {} nodes, {} edges", graph.nodes.len(), graph.edges.len());
+        
+        // Take a layout snapshot to provide for client initialization
+        info!("Taking layout snapshot after graph build");
+        if let Err(e) = Self::save_layout_cache(graph.clone()).await {
+            warn!("Failed to take layout snapshot: {}", e);
+        }
+        
+        // Cache the graph data to disk
+        if let Err(e) = Self::save_graph_cache(&graph).await {
+            warn!("Failed to cache graph data: {}", e);
+        }
         Ok(graph)
     }
 
@@ -765,6 +775,34 @@ impl GraphService {
             }
         }
     }
+    
+    // Initialize positions using cached values or random positions as fallback
+    pub async fn initialize_positions(graph: &mut GraphData) -> Result<(), std::io::Error> {
+        // Try to load positions from cache first
+        match Self::load_layout_cache().await {
+            Ok(position_map) => {
+                debug!("Applying cached positions to {} nodes", position_map.len());
+                let mut applied_count = 0;
+                
+                for node in &mut graph.nodes {
+                    if let Some(&(x, y, z)) = position_map.get(&node.id) {
+                        node.set_x(x);
+                        node.set_y(y);
+                        node.set_z(z);
+                        applied_count += 1;
+                    }
+                }
+                
+                info!("Applied cached positions to {}/{} nodes", applied_count, graph.nodes.len());
+                Ok(())
+            },
+            Err(e) => {
+                info!("No cached positions available, using random initialization: {}", e);
+                Self::initialize_random_positions(graph);
+                Ok(())
+            }
+        }
+    }
 
     /// Helper function to retry GPU layout calculation with exponential backoff
     pub async fn calculate_layout_with_retry(
@@ -772,21 +810,6 @@ impl GraphService {
         graph: &mut GraphData,
         node_map: &mut HashMap<String, Node>, 
         params: &SimulationParams,
-    ) -> std::io::Result<()> {
-        // First validate the graph data to avoid potential GPU issues
-        if let Err(e) = Self::validate_graph_data(graph) {
-            warn!("[calculate_layout_with_retry] Graph data validation failed: {}. Falling back to CPU.", e);
-            return Self::calculate_layout_cpu(graph, node_map, params);
-        }
-        Self::calculate_layout_with_retry_internal(gpu_compute, graph, node_map, params).await
-    }
-    
-    /// Internal implementation of retry mechanism for GPU layout calculation
-    async fn calculate_layout_with_retry_internal(
-        gpu_compute: &Arc<RwLock<GPUCompute>>,
-        graph: &mut GraphData,
-        node_map: &mut HashMap<String, Node>, 
-        params: &SimulationParams,
     ) -> std::io::Result<()> {
         debug!("[calculate_layout_with_retry] Starting GPU calculation with retry mechanism");
         let mut last_error: Option<Error> = None;
@@ -813,11 +836,6 @@ impl GraphService {
             }
         }
         
-        // Log a warning if we've had to retry multiple times
-        if last_error.is_some() && gpu_compute.read().await.iteration_count > 10 {
-            warn!("[calculate_layout_with_retry] GPU calculation required multiple retries after {} iterations. Consider checking GPU health.", gpu_compute.read().await.iteration_count);
-        }
-        
         // If we get here, all attempts failed
         debug!("[calculate_layout_with_retry] All GPU attempts failed, falling back to CPU");
         error!("[calculate_layout] Failed after {} attempts, falling back to CPU", MAX_GPU_CALCULATION_RETRIES);
@@ -845,7 +863,7 @@ impl GraphService {
     ) -> std::io::Result<()> {
         {
             info!("[calculate_layout] Starting GPU physics calculation for {} nodes, {} edges with mode {:?}", 
-                  graph.nodes.len(), graph.edges.len(), params.mode);
+                graph.nodes.len(), graph.edges.len(), params.mode);
             
             // Get current timestamp for performance tracking
             let start_time = std::time::Instant::now();
@@ -853,7 +871,7 @@ impl GraphService {
             let mut gpu_compute = gpu_compute.write().await;
 
             info!("[calculate_layout] params: iterations={}, spring_strength={:.3}, repulsion={:.3}, damping={:.3}",
-                 params.iterations, params.spring_strength, params.repulsion, params.damping);
+                params.iterations, params.spring_strength, params.repulsion, params.damping);
             
             // Update data and parameters
             if let Err(e) = gpu_compute.update_graph_data(graph) {
@@ -922,11 +940,15 @@ impl GraphService {
                     format!("[{:.2},{:.2},{:.2}]", graph.nodes[0].data.position.x, graph.nodes[0].data.position.y, graph.nodes[0].data.position.z)
                 } else { "no nodes".to_string() };
             
-                info!("[calculate_layout] Updated positions for {}/{} nodes in {:?}. Sample positions: {}", nodes_updated, graph.nodes.len(), elapsed, sample_positions);
+            info!("[calculate_layout] Updated positions for {}/{} nodes in {:?}. Sample positions: {}", nodes_updated, graph.nodes.len(), elapsed, sample_positions);
             
-            Ok(())
+            // Return success
+            ()
         }
-    }
+        
+        // Return success
+        Ok(())
+   }
 
     /// CPU fallback implementation of force-directed graph layout
     pub fn calculate_layout_cpu(
@@ -1120,7 +1142,9 @@ impl GraphService {
         let elapsed = start_time.elapsed();
         info!("[calculate_layout_cpu] Updated positions for {} nodes in {:?}", 
              graph.nodes.len(), elapsed);
+             
         
+        // Return success
         Ok(())
     }
 
@@ -1174,6 +1198,13 @@ impl GraphService {
         *cache = None;
     }
 
+    /// Take a layout snapshot and save it to disk (only called explicitly, not after every physics update)
+    pub async fn take_layout_snapshot(&self) -> Result<(), std::io::Error> {
+        let graph = self.graph_data.read().await;
+        info!("Taking layout snapshot to {}", LAYOUT_CACHE_PATH);
+        Self::save_layout_cache((*graph).clone()).await
+    }
+
     pub async fn get_node_positions(&self) -> Vec<Node> {
         let start_time = Instant::now();
 
@@ -1233,6 +1264,241 @@ impl GraphService {
         self.gpu_compute.clone()
     }
 
+    /// Save graph data to cache file
+    pub async fn save_graph_cache(graph: &GraphData) -> Result<(), std::io::Error> {
+        info!("Attempting to cache graph data to {}", GRAPH_CACHE_PATH);
+        let start_time = std::time::Instant::now();
+        info!("Graph contains {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
+        
+        // Ensure the directory exists
+        if let Some(dir) = std::path::Path::new(GRAPH_CACHE_PATH).parent() {
+            if !dir.exists() {
+                info!("Creating directory: {:?}", dir);
+                match std::fs::create_dir_all(dir) {
+                    Ok(_) => {
+                        info!("Successfully created directory: {:?}", dir);
+                        
+                        // Set directory permissions explicitly on Unix systems
+                        #[cfg(unix)]
+                        {
+                            use std::os::unix::fs::PermissionsExt;
+                            if let Err(e) = std::fs::set_permissions(dir, std::fs::Permissions::from_mode(0o777)) {
+                                warn!("Could not set permissions on cache directory: {}", e);
+                            }
+                        }
+                    },
+                    Err(e) => {
+                        error!("Failed to create directory {:?}: {}", dir, e);
+                        // Continue anyway since the directory might already exist with different permissions
+                    }
+                }
+            }
+        }
+        
+        // Serialize graph to JSON with pretty formatting for easier debugging
+        let json = match serde_json::to_string_pretty(graph) {
+            Ok(json) => json,
+            Err(e) => {
+                error!("Failed to serialize graph data: {}", e);
+                return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()));
+            }
+        };
+
+        // First try using standard file system functions, which might be more reliable
+        info!("Writing {} bytes to file {} using std::fs", json.len(), GRAPH_CACHE_PATH);
+        match std::fs::write(GRAPH_CACHE_PATH, json.as_bytes()) {
+            Ok(_) => {
+                let elapsed = start_time.elapsed();
+                info!("Successfully cached graph data ({} bytes) to {} in {:?} using std::fs", 
+                      json.len(), GRAPH_CACHE_PATH, elapsed);
+                return Ok(());
+            }
+            Err(e) => {
+                warn!("Failed to write graph cache using std::fs, falling back to tokio::fs: {}", e);
+                // Fall through to tokio version below
+            }
+        }
+        
+        // Fall back to tokio's async fs
+        info!("Writing {} bytes to file {} using tokio::fs", json.len(), GRAPH_CACHE_PATH);
+        match tokio::fs::write(GRAPH_CACHE_PATH, json.as_bytes()).await {
+            Ok(_) => {
+                info!("Successfully cached graph data ({} bytes) to {}", json.len(), GRAPH_CACHE_PATH);
+                Ok(())
+            },
+            Err(e) => {
+                error!("Failed to write graph cache file {}: {}", GRAPH_CACHE_PATH, e);
+                Err(e)
+            }
+        }
+    }
+    
+    /// Load graph data from cache file
+    pub async fn load_graph_cache() -> Result<GraphData, std::io::Error> {
+        info!("Attempting to load graph data from cache: {}", GRAPH_CACHE_PATH);
+        debug!("GRAPH_CACHE_PATH = {}", GRAPH_CACHE_PATH);
+        
+        // Check if cache file exists
+        if !tokio::fs::metadata(GRAPH_CACHE_PATH).await.is_ok() {
+            return Err(std::io::Error::new(
+                std::io::ErrorKind::NotFound, 
+                "Graph cache file not found"
+            ));
+        }
+        
+        // Read file content
+        let mut file = tokio::fs::File::open(GRAPH_CACHE_PATH).await?;
+        let mut content = String::new();
+        
+        // Read the file content
+        file.read_to_string(&mut content).await?;
+        
+        // Deserialize JSON
+        let graph = serde_json::from_str::<GraphData>(&content)
+            .map_err(|e| std::io::Error::new(
+                std::io::ErrorKind::InvalidData, 
+                format!("Failed to parse graph cache: {}", e)
+            ))?;
+        
+        info!("Successfully loaded graph data from cache ({} nodes, {} edges), last validated: {}", 
+              graph.nodes.len(), graph.edges.len(), graph.last_validated);
+              
+        // Return the loaded graph
+        Ok(graph) 
+    }
+    
+    /// Try to load cached graph data into the provided graph_data RwLock
+    pub async fn try_load_cached_graph_data(graph_data: Arc<RwLock<GraphData>>) -> Result<(), std::io::Error> {
+        match Self::load_graph_cache().await {
+            Ok(cached_graph) => {
+                info!("Initializing graph service with cached graph data");
+                let mut graph = graph_data.write().await;
+                *graph = cached_graph;
+                info!("Graph service initialized with {} nodes and {} edges from cache",
+                     graph.nodes.len(), graph.edges.len());
+                Ok(())
+            },
+            Err(e) => {
+                info!("No valid graph cache found: {}", e);
+                Err(e)
+            }
+        }
+    }
+    
+    /// Save layout positions to cache file
+    pub async fn save_layout_cache(graph: GraphData) -> Result<(), std::io::Error> {
+        info!("Attempting to cache node layout positions to {}", LAYOUT_CACHE_PATH);
+        let start_time = std::time::Instant::now();
+        
+        // Ensure the directory exists
+        if let Some(dir) = std::path::Path::new(LAYOUT_CACHE_PATH).parent() {
+            if !dir.exists() {
+                info!("Creating directory: {:?}", dir);
+                match std::fs::create_dir_all(dir) {
+                    Ok(_) => {
+                        info!("Successfully created directory: {:?}", dir);
+                        
+                        // Set directory permissions explicitly on Unix systems
+                        #[cfg(unix)]
+                        {
+                            use std::os::unix::fs::PermissionsExt;
+                            if let Err(e) = std::fs::set_permissions(dir, std::fs::Permissions::from_mode(0o777)) {
+                                warn!("Could not set permissions on cache directory: {}", e);
+                            }
+                        }
+                    },
+                    Err(e) => {
+                        error!("Failed to create directory {:?}: {}", dir, e);
+                        // Continue anyway since the directory might already exist with different permissions
+                    }
+                }
+            }
+        }
+        
+        // Create a serializable structure with just the necessary position information
+        info!("Building position data array for {} nodes", graph.nodes.len());
+        let positions: Vec<(String, f32, f32, f32)> = graph.nodes.iter()
+            .map(|node| (
+                node.id.clone(),
+                node.data.position.x,
+                node.data.position.y,
+                node.data.position.z
+            ))
+            .collect();
+        
+        // Serialize positions to JSON with pretty formatting for easier debugging
+        let json = match serde_json::to_string_pretty(&positions) {
+            Ok(json) => json,
+            Err(e) => {
+                error!("Failed to serialize layout positions: {}", e);
+                return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()));
+            }
+        };
+
+        // First try using standard file system functions, which might be more reliable
+        info!("Writing {} bytes to file {} using std::fs", json.len(), LAYOUT_CACHE_PATH);
+        match std::fs::write(LAYOUT_CACHE_PATH, json.as_bytes()) {
+            Ok(_) => {
+                let elapsed = start_time.elapsed();
+                info!("Successfully cached layout data for {} nodes to {} in {:?} using std::fs", 
+                      positions.len(), LAYOUT_CACHE_PATH, elapsed);
+                return Ok(());
+            }
+            Err(e) => {
+                warn!("Failed to write layout cache using std::fs, falling back to tokio::fs: {}", e);
+                // Fall through to tokio version below
+            }
+        }
+        
+        // Fall back to tokio's async fs 
+        info!("Writing {} bytes to file {} using tokio::fs", json.len(), LAYOUT_CACHE_PATH);
+        match tokio::fs::write(LAYOUT_CACHE_PATH, json.as_bytes()).await {
+            Ok(_) => {
+                info!("Successfully cached layout data for {} nodes to {}", positions.len(), LAYOUT_CACHE_PATH);
+                Ok(())
+            },
+            Err(e) => {
+                error!("Failed to write layout cache file {}: {}", LAYOUT_CACHE_PATH, e);
+                Err(e)
+            }
+        }
+    }
+    
+    /// Load layout positions from cache file
+    pub async fn load_layout_cache() -> Result<HashMap<String, (f32, f32, f32)>, std::io::Error> {
+        info!("Attempting to load layout from cache: {}", LAYOUT_CACHE_PATH);
+        
+        // Check if cache file exists
+        if !tokio::fs::metadata(LAYOUT_CACHE_PATH).await.is_ok() {
+            return Err(std::io::Error::new(
+                std::io::ErrorKind::NotFound, 
+                "Layout cache file not found"
+            ));
+        }
+        
+        // Read file content
+        let mut file = tokio::fs::File::open(LAYOUT_CACHE_PATH).await?;
+        let mut content = String::new();
+        file.read_to_string(&mut content).await?;
+        
+        // Deserialize JSON
+        let positions = serde_json::from_str::<Vec<(String, f32, f32, f32)>>(&content)
+            .map_err(|e| std::io::Error::new(
+                std::io::ErrorKind::InvalidData, 
+                format!("Failed to parse layout cache: {}", e)
+            ))?;
+        
+        // Convert to HashMap
+        let position_map: HashMap<String, (f32, f32, f32)> = positions.into_iter()
+            .map(|(id, x, y, z)| (id, (x, y, z)))
+            .collect();
+        
+        info!("Successfully loaded layout positions for {} nodes from cache", 
+              position_map.len());
+        Ok(position_map)
+    }
+
+
     pub async fn update_node_positions(&self, updates: Vec<(u16, Node)>) -> Result<(), Error> {
         let mut graph = self.graph_data.write().await;
         let mut node_map = self.node_map.write().await;
diff --git a/services/mod.rs b/src/services/mod.rs
similarity index 85%
rename from services/mod.rs
rename to src/services/mod.rs
index f39623c2..81bebaf9 100755
--- a/services/mod.rs
+++ b/src/services/mod.rs
@@ -5,4 +5,3 @@ pub mod nostr_service;
 pub mod perplexity_service;
 pub mod ragflow_service;
 pub mod speech_service;
-pub mod empty_graph_check;
diff --git a/services/nostr_service.rs b/src/services/nostr_service.rs
similarity index 79%
rename from services/nostr_service.rs
rename to src/services/nostr_service.rs
index a8c46855..faa36be0 100644
--- a/services/nostr_service.rs
+++ b/src/services/nostr_service.rs
@@ -10,7 +10,7 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use chrono::Utc;
 use thiserror::Error;
-use log::{debug, error, info};
+use log::{debug, error, info, warn};
 use uuid::Uuid;
 
 #[derive(Debug, Error)]
@@ -57,7 +57,11 @@ impl NostrService {
         let power_users = std::env::var("POWER_USER_PUBKEYS")
             .unwrap_or_default()
             .split(',')
-            .map(|s| s.trim().to_string())
+            .map(|s| {
+                let trimmed = s.trim().to_string();
+                debug!("Loaded power user pubkey: '{}'", trimmed);
+                trimmed
+            })
             .collect();
 
         let token_expiry = std::env::var("AUTH_TOKEN_EXPIRY")
@@ -110,7 +114,12 @@ impl NostrService {
         }
 
         let now = Utc::now();
-        let is_power_user = self.power_user_pubkeys.contains(&event.pubkey);
+        let trimmed_pubkey = event.pubkey.trim().to_string();
+        let is_power_user = self.power_user_pubkeys.iter().any(|p| p.trim() == trimmed_pubkey);
+        
+        debug!("Checking power user status for pubkey '{}', result: {}", trimmed_pubkey, is_power_user);
+        debug!("Power users list: {:?}", self.power_user_pubkeys);
+        debug!("Is pubkey in list with exact match: {}", self.power_user_pubkeys.contains(&trimmed_pubkey));
 
         // Generate session token
         let session_token = Uuid::new_v4().to_string();
@@ -136,14 +145,16 @@ impl NostrService {
     }
 
     pub async fn get_user(&self, pubkey: &str) -> Option<NostrUser> {
+        let trimmed_pubkey = pubkey.trim();
         let users = self.users.read().await;
-        users.get(pubkey).cloned()
+        users.get(trimmed_pubkey).cloned()
     }
 
     pub async fn update_user_api_keys(&self, pubkey: &str, api_keys: ApiKeys) -> Result<NostrUser, NostrError> {
+        let trimmed_pubkey = pubkey.trim();
         let mut users = self.users.write().await;
-        
-        if let Some(user) = users.get_mut(pubkey) {
+        debug!("Updating API keys for pubkey: '{}'", trimmed_pubkey);
+        if let Some(user) = users.get_mut(trimmed_pubkey) {
             if user.is_power_user {
                 return Err(NostrError::PowerUserOperation);
             }
@@ -156,7 +167,9 @@ impl NostrService {
     }
 
     pub async fn validate_session(&self, pubkey: &str, token: &str) -> bool {
-        if let Some(user) = self.get_user(pubkey).await {
+        let trimmed_pubkey = pubkey.trim();
+        debug!("Validating session for pubkey: '{}'", trimmed_pubkey);
+        if let Some(user) = self.get_user(trimmed_pubkey).await {
             if let Some(session_token) = user.session_token {
                 let now = Utc::now().timestamp();
                 if now - user.last_seen <= self.token_expiry {
@@ -168,9 +181,10 @@ impl NostrService {
     }
 
     pub async fn refresh_session(&self, pubkey: &str) -> Result<String, NostrError> {
+        let trimmed_pubkey = pubkey.trim();
         let mut users = self.users.write().await;
-        
-        if let Some(user) = users.get_mut(pubkey) {
+        debug!("Refreshing session for pubkey: '{}'", trimmed_pubkey);
+        if let Some(user) = users.get_mut(trimmed_pubkey) {
             let now = Utc::now().timestamp();
             let new_token = Uuid::new_v4().to_string();
             user.session_token = Some(new_token.clone());
@@ -182,9 +196,10 @@ impl NostrService {
     }
 
     pub async fn logout(&self, pubkey: &str) -> Result<(), NostrError> {
+        let trimmed_pubkey = pubkey.trim();
         let mut users = self.users.write().await;
-        
-        if let Some(user) = users.get_mut(pubkey) {
+        debug!("Logging out pubkey: '{}'", trimmed_pubkey);
+        if let Some(user) = users.get_mut(trimmed_pubkey) {
             user.session_token = None;
             user.last_seen = Utc::now().timestamp();
             Ok(())
@@ -204,7 +219,9 @@ impl NostrService {
     }
 
     pub async fn is_power_user(&self, pubkey: &str) -> bool {
-        if let Some(user) = self.get_user(pubkey).await {
+        let trimmed_pubkey = pubkey.trim();
+        debug!("Checking service-level power user status for: '{}'", trimmed_pubkey);
+        if let Some(user) = self.get_user(trimmed_pubkey).await {
             user.is_power_user
         } else {
             false
diff --git a/services/perplexity_service.rs b/src/services/perplexity_service.rs
similarity index 100%
rename from services/perplexity_service.rs
rename to src/services/perplexity_service.rs
diff --git a/services/ragflow_service.rs b/src/services/ragflow_service.rs
similarity index 100%
rename from services/ragflow_service.rs
rename to src/services/ragflow_service.rs
diff --git a/services/speech_service.rs b/src/services/speech_service.rs
similarity index 99%
rename from services/speech_service.rs
rename to src/services/speech_service.rs
index c5311bc7..52ca9efc 100755
--- a/services/speech_service.rs
+++ b/src/services/speech_service.rs
@@ -1,6 +1,5 @@
 use tokio::sync::{mpsc, Mutex, RwLock};
-use tokio_tungstenite::{connect_async, WebSocketStream, MaybeTlsStream};
-use tungstenite::protocol::Message;
+use tokio_tungstenite::{connect_async, WebSocketStream, MaybeTlsStream, tungstenite::Message};
 use tungstenite::http::Request;
 use serde_json::json;
 use std::sync::Arc;
@@ -18,6 +17,7 @@ use crate::types::speech::{SpeechError, SpeechCommand, TTSProvider};
 pub struct SpeechService {
     sender: Arc<Mutex<mpsc::Sender<SpeechCommand>>>,
     settings: Arc<RwLock<Settings>>,
+    #[allow(dead_code)]
     tts_provider: Arc<RwLock<TTSProvider>>,
 }
 
diff --git a/state.rs b/src/state.rs
similarity index 100%
rename from state.rs
rename to src/state.rs
diff --git a/types/mod.rs b/src/types/mod.rs
similarity index 100%
rename from types/mod.rs
rename to src/types/mod.rs
diff --git a/types/speech.rs b/src/types/speech.rs
similarity index 100%
rename from types/speech.rs
rename to src/types/speech.rs
diff --git a/types/vec3.rs b/src/types/vec3.rs
similarity index 100%
rename from types/vec3.rs
rename to src/types/vec3.rs
diff --git a/utils/audio_processor.rs b/src/utils/audio_processor.rs
similarity index 100%
rename from utils/audio_processor.rs
rename to src/utils/audio_processor.rs
diff --git a/utils/auth.rs b/src/utils/auth.rs
similarity index 100%
rename from utils/auth.rs
rename to src/utils/auth.rs
diff --git a/utils/binary_protocol.rs b/src/utils/binary_protocol.rs
similarity index 100%
rename from utils/binary_protocol.rs
rename to src/utils/binary_protocol.rs
diff --git a/utils/compute_forces.cu b/src/utils/compute_forces.cu
similarity index 100%
rename from utils/compute_forces.cu
rename to src/utils/compute_forces.cu
diff --git a/utils/compute_forces.ptx b/src/utils/compute_forces.ptx
similarity index 100%
rename from utils/compute_forces.ptx
rename to src/utils/compute_forces.ptx
diff --git a/utils/edge_data.rs b/src/utils/edge_data.rs
similarity index 100%
rename from utils/edge_data.rs
rename to src/utils/edge_data.rs
diff --git a/utils/gpu_compute.rs b/src/utils/gpu_compute.rs
similarity index 72%
rename from utils/gpu_compute.rs
rename to src/utils/gpu_compute.rs
index 6fcafe63..65b5ae13 100755
--- a/utils/gpu_compute.rs
+++ b/src/utils/gpu_compute.rs
@@ -4,7 +4,7 @@ use cudarc::driver::sys::CUdevice_attribute_enum;
 
 use std::io::{Error, ErrorKind};
 use std::sync::Arc;
-use log::{error, warn, info, debug};
+use log::{error, warn, info};
 use crate::models::graph::GraphData;
 use std::collections::HashMap;
 use crate::models::simulation_params::SimulationParams;
@@ -23,9 +23,6 @@ const SHARED_MEM_SIZE: u32 = BLOCK_SIZE * NODE_SIZE;
 // Constants for retry mechanism
 const MAX_GPU_INIT_RETRIES: u32 = 3;
 const RETRY_DELAY_MS: u64 = 500; // 500ms delay between retries
-const MIN_VALID_NODES: u32 = 5; // Minimum number of nodes for valid initialization
-const DIAGNOSTIC_INTERVAL: i32 = 100; // Log diagnostic info every N iterations
-const PTX_PATHS: [&str; 2] = ["/app/src/utils/compute_forces.ptx", "./src/utils/compute_forces.ptx"];
 
 // Note: CPU fallback code has been removed as we're always using GPU now
 
@@ -40,28 +37,6 @@ pub struct GPUCompute {
     pub iteration_count: i32,
 }
 
-// Health status of the GPU compute system
-#[derive(Debug, Clone, Copy, PartialEq)]
-pub enum GpuHealth {
-    Healthy,
-    Warning,
-    Critical,
-    Unknown
-}
-
-// Additional info about GPU state
-#[derive(Debug, Clone)]
-pub struct GpuDiagnostics {
-    pub health: GpuHealth,
-    pub node_count: u32,
-    pub gpu_memory_used: u64,
-    pub iterations_completed: i32,
-    pub device_properties: String,
-    pub last_error: Option<String>,
-    pub last_operation_time_ms: u64,
-    pub timestamp: std::time::SystemTime,
-}
-
 impl GPUCompute {
     pub fn test_gpu() -> Result<(), Error> {
         info!("Running GPU test");
@@ -115,16 +90,6 @@ impl GPUCompute {
     pub async fn new(graph: &GraphData) -> Result<Arc<RwLock<Self>>, Error> {
         let num_nodes = graph.nodes.len() as u32;
         info!("Initializing GPU compute with {} nodes (with retry mechanism)", num_nodes);
-        
-        // Validate graph has enough nodes to avoid empty/near-empty graph issues
-        if num_nodes == 0 {
-            return Err(Error::new(
-                ErrorKind::InvalidInput,
-                "Cannot initialize GPU with empty graph (no nodes)"
-            ));
-        } else if num_nodes < MIN_VALID_NODES {
-            warn!("Initializing GPU with only {} nodes, which is below the recommended minimum of {}. This may cause instability.", num_nodes, MIN_VALID_NODES);
-        }
 
         // Check node count limit
         if num_nodes > MAX_NODES {
@@ -135,14 +100,8 @@ impl GPUCompute {
         }
 
         // Use retry mechanism for GPU initialization
-        info!("Starting GPU initialization with retry mechanism (max {} attempts)", MAX_GPU_INIT_RETRIES);
-        
         Self::with_retry(MAX_GPU_INIT_RETRIES, RETRY_DELAY_MS, |attempt| async move {
-            let result = Self::initialize_gpu(graph, num_nodes, attempt).await;
-            if result.is_ok() {
-                info!(" GPU initialization succeeded on attempt {}/{}", attempt + 1, MAX_GPU_INIT_RETRIES);
-            }
-            result
+            Self::initialize_gpu(graph, num_nodes, attempt).await
         }).await
     }
     
@@ -197,11 +156,6 @@ impl GPUCompute {
     
     async fn initialize_gpu(graph: &GraphData, num_nodes: u32, attempt: u32) -> Result<Arc<RwLock<Self>>, Error> {
         info!("GPU initialization attempt {}/{}", attempt + 1, MAX_GPU_INIT_RETRIES);
-
-        // Extra validation for empty graph case
-        if graph.nodes.is_empty() {
-            return Err(Error::new(ErrorKind::InvalidData, "Cannot initialize GPU with empty graph (detected during initialization)"));
-        }
         
         // Check device capabilities
         match Self::test_gpu_capabilities() {
@@ -277,7 +231,6 @@ impl GPUCompute {
         for attempt in 0..max_attempts {
             match operation(attempt).await {
                 Ok(result) => {
-                    // Success after retry
                     if attempt > 0 {
                         info!("Operation succeeded after {} retries", attempt);
                     }
@@ -298,60 +251,33 @@ impl GPUCompute {
         
         // If we get here, all attempts failed
         error!("Operation failed after {} attempts", max_attempts);
-        Err(last_error.unwrap_or_else(|| Error::new(ErrorKind::Other,
-            format!("All {} retry attempts failed without specific error", max_attempts))))
+        Err(last_error.unwrap_or_else(|| Error::new(ErrorKind::Other, 
+            format!("All {} retry attempts failed", max_attempts))))
     }
     
     async fn load_compute_kernel(
         device: Arc<CudaDevice>, 
-        num_nodes: u32,
+        num_nodes: u32, 
         graph: &GraphData
     ) -> Result<Arc<RwLock<Self>>, Error> {
-        // Try to load PTX file from primary path
-        let primary_ptx_path = "/app/src/utils/compute_forces.ptx";
-        let primary_path_exists = Path::new(primary_ptx_path).exists();
+        let ptx_path = "/app/src/utils/compute_forces.ptx";
         
-        // Variable to hold our PTX data once loaded
-        let ptx_data;
-        
-        if primary_path_exists {
-            // Primary path exists, use it
-            info!("PTX file found at primary path: {}", primary_ptx_path);
-            ptx_data = Ptx::from_file(primary_ptx_path);
-            info!("Successfully loaded PTX file from primary path");
-        } else {
-            // Primary path doesn't exist, try alternatives
-            error!("PTX file does not exist at primary path: {} - trying alternatives", primary_ptx_path);
-            
-            let mut found = false;
-            let mut alternative_ptx = None;
-            
-            // Try each alternative path
-            for alt_path in &PTX_PATHS {
-                if Path::new(alt_path).exists() {
-                    info!("Found PTX file at alternative path: {}", alt_path);
-                    alternative_ptx = Some(Ptx::from_file(alt_path));
-                    found = true;
-                    break;
-                }
-            }
-            
-            if !found {
-                // No valid PTX file found anywhere
-                error!("PTX file not found at any known location. GPU physics will not work.");
-                return Err(Error::new(ErrorKind::NotFound, 
-                    format!("PTX file not found at any known location. Tried: {} and alternatives", primary_ptx_path)));
-            }
-            
-            ptx_data = alternative_ptx.unwrap();
-            info!("Successfully loaded PTX file from alternative path");
+        // Validate PTX file
+        let ptx_path_obj = Path::new(ptx_path);
+
+        if !ptx_path_obj.exists() {
+            error!("PTX file does not exist at {} - this file is required for GPU physics", ptx_path);
+            return Err(Error::new(ErrorKind::NotFound, 
+                format!("PTX file not found at {}", ptx_path)));
         }
 
-        // Load the PTX into the device
-        device.load_ptx(ptx_data, "compute_forces_kernel", &["compute_forces_kernel"])
+        let ptx = Ptx::from_file(ptx_path);
+
+        info!("Successfully loaded PTX file");
+            
+        device.load_ptx(ptx, "compute_forces_kernel", &["compute_forces_kernel"])
             .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
-        
-        // Get the compute function
+            
         let force_kernel = device.get_func("compute_forces_kernel", "compute_forces_kernel")
             .ok_or_else(|| Error::new(std::io::ErrorKind::Other, "Function compute_forces_kernel not found"))?;
 
@@ -376,19 +302,8 @@ impl GPUCompute {
             iteration_count: 0,
         };
 
-        // Validate graph data before copying to GPU
-        if graph.nodes.is_empty() {
-            return Err(Error::new(ErrorKind::InvalidData, 
-                "Cannot copy empty graph data to GPU. The graph contains no nodes."));
-        }
-
-        // Copy graph data to GPU with retry mechanism
-        info!("Copying initial graph data ({} nodes) to device memory", graph.nodes.len());
-        match instance.update_graph_data(graph) {
-            Ok(_) => info!("Successfully copied graph data to GPU"),
-            Err(e) => return Err(Error::new(ErrorKind::Other, 
-                format!("Failed to copy initial graph data to GPU: {}", e)))
-        }
+        info!("Copying initial graph data to device memory");
+        instance.update_graph_data(graph)?;
 
         info!("GPU compute initialization complete");
         Ok(Arc::new(RwLock::new(instance)))
@@ -403,37 +318,15 @@ impl GPUCompute {
             self.node_indices.insert(node.id.clone(), idx);
         }
 
-        // Safety check for empty graph
-        if graph.nodes.is_empty() {
-            return Err(Error::new(ErrorKind::InvalidData, 
-                "Cannot update GPU with empty graph data. The graph contains no nodes."));
-        }
-
         // Reallocate buffer if node count changed
         if graph.nodes.len() as u32 != self.num_nodes {
-            info!("Reallocating GPU buffer for {} nodes (was: {} nodes)", 
-                graph.nodes.len(), self.num_nodes);
-            
-            // Allocate the new buffer
+            info!("Reallocating GPU buffer for {} nodes", graph.nodes.len());
             self.node_data = self.device.alloc_zeros::<BinaryNodeData>(graph.nodes.len())
                 .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
-            
-            // Update node count
             self.num_nodes = graph.nodes.len() as u32;
             
             // Reset iteration counter when the graph data changes
             self.iteration_count = 0;
-            
-            info!("GPU buffer reallocated successfully");
-        }
-        
-        // Validate node positions to avoid NaN issues
-        for (i, node) in graph.nodes.iter().enumerate() {
-            if node.data.position.x.is_nan() || node.data.position.y.is_nan() || node.data.position.z.is_nan() {
-                warn!("Node at index {} (id: {}) has NaN coordinates - fixing with zero values", 
-                    i, node.id);
-                // Could fix by setting to zero here if needed
-            }
         }
 
         // Prepare node data
@@ -474,12 +367,6 @@ impl GPUCompute {
     pub fn compute_forces(&mut self) -> Result<(), Error> {
         info!("Starting force computation on GPU");
         
-        // Safety check: Make sure we have nodes to process
-        if self.num_nodes == 0 {
-            return Err(Error::new(ErrorKind::InvalidData, 
-                "Cannot compute forces with zero nodes"));
-        }
-        
         let blocks = ((self.num_nodes + BLOCK_SIZE - 1) / BLOCK_SIZE).max(1);
         let cfg = LaunchConfig {
             grid_dim: (blocks, 1, 1),
@@ -487,19 +374,8 @@ impl GPUCompute {
             shared_mem_bytes: SHARED_MEM_SIZE,
         };
 
-        // Log detailed information periodically rather than every call
-        if self.iteration_count % DIAGNOSTIC_INTERVAL == 0 {
-            info!("GPU kernel launch config: blocks={}, threads={}, shared_mem={}",
-                blocks, BLOCK_SIZE, SHARED_MEM_SIZE);
-            info!("GPU kernel parameters: spring_strength={}, damping={}, repulsion={}, time_step={}",
-                self.simulation_params.spring_strength,
-                self.simulation_params.damping,
-                self.simulation_params.repulsion,
-                self.simulation_params.time_step);
-        } else {
-            info!("GPU kernel launching: blocks={}, nodes={}, iteration={}",
-                blocks, self.num_nodes, self.iteration_count);
-        }
+        info!("Launch config: blocks={}, threads={}, shared_mem={}",
+            blocks, BLOCK_SIZE, SHARED_MEM_SIZE);
 
         unsafe {
             self.force_kernel.clone().launch(cfg, (
@@ -589,33 +465,13 @@ impl GPUCompute {
             },
             Err(e) => {
                 error!("GPU device access test failed: {}", e);
-                return Err(Error::new(ErrorKind::Other, format!("GPU device access test failed: {}", e)));
-            }
+                return Err(Error::new(ErrorKind::Other, format!("GPU device access test failed: {}", e)));            }
         }
         
         // If we got here, the GPU instance is working
         info!("GPU test computation successful");
         Ok(())
     }
-    
-    pub fn get_diagnostics(&self) -> GpuDiagnostics {
-        // Simplified diagnostics without using unsupported methods
-        let device_props = "CUDA GPU".to_string();
-
-        // Use simpler diagnostics without unsupported memory methods
-        let memory_used = 0; // Cannot get actual memory usage
-
-        GpuDiagnostics {
-            health: if self.iteration_count > 0 { GpuHealth::Healthy } else { GpuHealth::Unknown },
-            node_count: self.num_nodes,
-            gpu_memory_used: memory_used,
-            iterations_completed: self.iteration_count,
-            device_properties: device_props,
-            last_error: None,
-            last_operation_time_ms: 0,
-            timestamp: std::time::SystemTime::now(),
-        }
-    }
 }
 
 #[cfg(test)]
diff --git a/utils/logging.rs b/src/utils/logging.rs
similarity index 100%
rename from utils/logging.rs
rename to src/utils/logging.rs
diff --git a/utils/mod.rs b/src/utils/mod.rs
similarity index 100%
rename from utils/mod.rs
rename to src/utils/mod.rs
diff --git a/utils/socket_flow_constants.rs b/src/utils/socket_flow_constants.rs
similarity index 100%
rename from utils/socket_flow_constants.rs
rename to src/utils/socket_flow_constants.rs
diff --git a/utils/socket_flow_messages.rs b/src/utils/socket_flow_messages.rs
similarity index 100%
rename from utils/socket_flow_messages.rs
rename to src/utils/socket_flow_messages.rs
diff --git a/utils/tests/socket_flow_tests.rs b/src/utils/tests/socket_flow_tests.rs
similarity index 100%
rename from utils/tests/socket_flow_tests.rs
rename to src/utils/tests/socket_flow_tests.rs
diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
index 00000000..710ddf55
--- /dev/null
+++ b/tsconfig.json
@@ -0,0 +1,44 @@
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "useDefineForClassFields": true,
+    "module": "ESNext",
+    "lib": [
+      "ES2020",
+      "DOM",
+      "DOM.Iterable",
+      "WebWorker",
+      "WebWorker.ImportScripts",
+      "Webworker.Iterable"
+    ],
+    "skipLibCheck": true,
+    "moduleResolution": "bundler",
+    "allowImportingTsExtensions": true,
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "noEmit": true,
+    "strict": true,
+    "noUnusedLocals": true,
+    "noUnusedParameters": true,
+    "noFallthroughCasesInSwitch": true,
+    "noImplicitAny": true,
+    "noImplicitThis": true,
+    "noImplicitReturns": true,
+    "strictNullChecks": true,
+    "strictFunctionTypes": true,
+    "strictBindCallApply": true,
+    "strictPropertyInitialization": true,
+    "allowJs": true,
+    "checkJs": true,
+    "esModuleInterop": true,
+    "forceConsistentCasingInFileNames": true,
+    "baseUrl": ".",
+    "paths": {
+      "@/*": ["client/*"],
+      "three/examples/jsm/*": ["node_modules/three/examples/jsm/*"]
+    },
+    "types": ["vite/client", "node", "three"]
+  },
+  "include": ["client/**/*.ts", "client/**/*.d.ts", "node_modules/three/examples/jsm/**/*.d.ts"],
+  "exclude": ["node_modules", "dist"]
+}
diff --git a/tsconfig.node.json b/tsconfig.node.json
new file mode 100644
index 00000000..07b1202a
--- /dev/null
+++ b/tsconfig.node.json
@@ -0,0 +1,12 @@
+{
+  "compilerOptions": {
+    "composite": true,
+    "skipLibCheck": true,
+    "module": "ESNext",
+    "moduleResolution": "node",
+    "allowSyntheticDefaultImports": true,
+    "strict": true,
+    "types": ["node"]
+  },
+  "include": ["vite.config.ts"]
+}
diff --git a/vite.config.ts b/vite.config.ts
new file mode 100644
index 00000000..0d5dab3c
--- /dev/null
+++ b/vite.config.ts
@@ -0,0 +1,104 @@
+import { defineConfig } from 'vite';
+import { resolve } from 'path';
+
+// https://vitejs.dev/config/
+export default defineConfig(({ mode, command }) => {
+  const isProd = mode === 'production';
+  const isQuest = process.env.npm_config_platform === 'quest';
+
+  return {
+    root: 'client',
+    base: './',
+    
+    build: {
+      outDir: resolve(__dirname, 'data/public/dist'),
+      emptyOutDir: true,
+      chunkSizeWarningLimit: 600,
+      sourcemap: !isProd, 
+      minify: isProd, // Enable minification for production builds
+      target: 'esnext',
+      terserOptions: {
+        compress: {
+          passes: 2,
+          pure_funcs: ['console.log', 'console.info', 'console.debug'],
+          drop_console: isProd,
+          drop_debugger: isProd,
+          unsafe_math: true,
+          unsafe_methods: true,
+          unsafe_proto: true,
+          keep_infinity: true,
+          ecma: 2020,
+          module: true
+        },
+        mangle: isProd
+      },
+      rollupOptions: {
+        input: {
+          main: resolve(__dirname, 'client/index.html')
+        },
+        output: {
+          assetFileNames: (assetInfo) => {
+            if (!assetInfo.name) return 'assets/[name][extname]';
+            
+            if (/\.(woff2?|eot|ttf|otf)$/i.test(assetInfo.name)) {
+              return `assets/fonts/[name][extname]`;
+            }
+            if (/\.(css)$/i.test(assetInfo.name)) {
+              return `assets/css/[name][extname]`;
+            }
+            if (/\.(png|jpe?g|gif|svg|ico)$/i.test(assetInfo.name)) {
+              return `assets/images/[name][extname]`;
+            }
+            return `assets/[name][extname]`;
+          },
+          chunkFileNames: 'assets/js/[name]-[hash].js',
+          entryFileNames: 'assets/js/[name]-[hash].js',
+          manualChunks: {
+            three: ['three'],
+            'three-extras': [
+              'three/examples/jsm/controls/OrbitControls',
+              'three/examples/jsm/loaders/GLTFLoader'
+            ],
+            visualization: ['./client/visualization/HologramManager.ts', './client/rendering/node/geometry/NodeGeometryManager.ts'],
+            core: ['./client/core/types.ts', './client/core/constants.ts', './client/core/utils.ts']
+          }
+        }
+      }
+    },
+
+    resolve: {
+      alias: {
+        '@': resolve(__dirname, './client')
+      }
+    },
+
+    server: {
+      port: 3001,
+      host: true,
+      proxy: {
+        '/wss': {  // Updated from /ws to /wss to match nginx
+          target: 'ws://localhost:4000',
+          ws: true
+        },
+        '/api': {
+          target: 'http://localhost:4000',
+          changeOrigin: true
+        }
+      }
+    },
+
+    optimizeDeps: {
+      include: [
+        'three',
+        'three/examples/jsm/controls/OrbitControls',
+        'three/examples/jsm/loaders/GLTFLoader'
+      ],
+      exclude: []
+    },
+
+    define: {
+      __QUEST__: isQuest,
+      __DEV__: !isProd
+    }
+  };
+});
