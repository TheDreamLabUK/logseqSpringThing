diff --git a/data/public/index.html b/data/public/index.html
index 1fb4eaea..9e70e6c9 100755
--- a/data/public/index.html
+++ b/data/public/index.html
@@ -14,25 +14,30 @@
             padding: 0;
             height: 100%;
             overflow: hidden;
+            background: #000; /* Add black background */
         }
         #scene-container {
             width: 100%;
             height: 100%;
-            position: absolute;
+            position: fixed;
+            top: 0;
+            left: 0;
             z-index: 1;
         }
         #app {
-            position: relative;
+            position: fixed;
+            top: 0;
+            left: 0;
             width: 100%;
             height: 100%;
             z-index: 1000;
             pointer-events: none;
         }
-        #app > * {
+        #app * {
             pointer-events: auto;
         }
         #connection-status {
-            position: absolute;
+            position: fixed;
             top: 20px;
             left: 20px;
             padding: 5px 10px;
@@ -48,27 +53,27 @@
             background-color: #dc3545;
             color: white;
         }
-        @media (max-width: 600px) {
-            #connection-status {
-                top: 10px;
-                left: 10px;
-            }
-        }
     </style>
 </head>
 <body>
-    <!-- Container for the 3D scene -->
+    <div id="app"></div>
     <div id="scene-container"></div>
-
-    <!-- Connection status indicator -->
     <div id="connection-status" class="disconnected">Disconnected</div>
 
-    <!-- Vue app container -->
-    <div id="app">
-        <!-- The Vue application will mount here and render the ChatManager and ControlPanel components. -->
-    </div>
+    <!-- Debug elements -->
+    <div id="debug-info" style="position: fixed; bottom: 10px; left: 10px; color: white; z-index: 2000;"></div>
 
-    <!-- Include the main application script -->
-    <script type="module" src="/js/app.js"></script>
+    <script type="module" src="/js/index.js"></script>
+    <script>
+        // Add global error handler
+        window.onerror = function(msg, url, line, col, error) {
+            console.error('Global error:', msg, 'at', url, 'line', line);
+            const debugInfo = document.getElementById('debug-info');
+            if (debugInfo) {
+                debugInfo.innerHTML += `<div>Error: ${msg}</div>`;
+            }
+            return false;
+        };
+    </script>
 </body>
 </html>
diff --git a/data/public/js/app.js b/data/public/js/app.js
index e11f79c4..8e16c619 100755
--- a/data/public/js/app.js
+++ b/data/public/js/app.js
@@ -3,13 +3,13 @@
 import { createApp } from 'vue';
 import ControlPanel from './components/ControlPanel.vue';
 import ChatManager from './components/chatManager.vue';
-import { WebXRVisualization } from './components/visualization/core.js';  // Updated import path
+import { WebXRVisualization } from './components/visualization/core.js';
 import WebsocketService from './services/websocketService.js';
 import { GraphDataManager } from './services/graphDataManager.js';
 import { isGPUAvailable, initGPU } from './gpuUtils.js';
 import { enableSpacemouse } from './services/spacemouse.js';
 
-class App {
+export class App {
     constructor() {
         console.log('App constructor called');
         this.websocketService = null;
@@ -21,30 +21,42 @@ class App {
     }
 
     initializeApp() {
-        console.log('Initializing Application');
+        console.log('Initializing Application - Step 1: Services');
 
         // Initialize Services
         try {
             this.websocketService = new WebsocketService();
-            console.log('WebsocketService initialized');
+            console.log('WebsocketService initialized successfully');
         } catch (error) {
             console.error('Failed to initialize WebsocketService:', error);
         }
 
         if (this.websocketService) {
             this.graphDataManager = new GraphDataManager(this.websocketService);
-            console.log('GraphDataManager initialized');
+            console.log('GraphDataManager initialized successfully');
         } else {
             console.error('Cannot initialize GraphDataManager: WebsocketService is not available');
         }
         
+        console.log('Initializing Application - Step 2: Visualization');
         try {
+            // Add container check
+            const container = document.getElementById('scene-container');
+            if (!container) {
+                console.error('Scene container not found, creating it');
+                const newContainer = document.createElement('div');
+                newContainer.id = 'scene-container';
+                document.body.appendChild(newContainer);
+            }
+
             this.visualization = new WebXRVisualization(this.graphDataManager);
             console.log('WebXRVisualization initialized successfully');
         } catch (error) {
             console.error('Failed to initialize WebXRVisualization:', error);
+            console.error('Error stack:', error.stack);
         }
 
+        console.log('Initializing Application - Step 3: GPU');
         // Initialize GPU if available
         this.gpuAvailable = isGPUAvailable();
         if (this.gpuAvailable) {
@@ -54,12 +66,15 @@ class App {
             console.warn('GPU acceleration not available, using CPU fallback');
         }
 
+        console.log('Initializing Application - Step 4: Vue App');
         // Initialize Vue App with ChatManager and ControlPanel
         this.initVueApp();
 
+        console.log('Initializing Application - Step 5: Event Listeners');
         // Setup Event Listeners
         this.setupEventListeners();
 
+        console.log('Initializing Application - Step 6: Three.js');
         // Initialize the visualization
         if (this.visualization) {
             this.visualization.initThreeJS();
@@ -69,96 +84,100 @@ class App {
     }
 
     initVueApp() {
-        console.log('Initializing Vue App');
+        console.log('Initializing Vue App - Start');
+        const websocketService = this.websocketService;
+        const visualization = this.visualization;
+        const graphDataManager = this.graphDataManager;
+
+        // Check if Vue is available
+        if (typeof createApp !== 'function') {
+            console.error('Vue createApp not found!');
+            return;
+        }
+
         const app = createApp({
             components: {
                 ControlPanel,
                 ChatManager
             },
-            setup: () => {
-                // Provide the services directly in setup
-                return {
-                    websocketService: this.websocketService,
-                    visualization: this.visualization,
-                    graphDataManager: this.graphDataManager
-                };
-            },
-            template: `
-                <div>
-                    <chat-manager :websocketService="websocketService"></chat-manager>
-                    <control-panel 
-                        :websocketService="websocketService"
-                        @control-change="handleControlChange"
-                        @toggle-fullscreen="toggleFullscreen"
-                        @enable-spacemouse="enableSpacemouse"
-                    ></control-panel>
-                </div>
-            `,
-            methods: {
-                handleControlChange(data) {
+            setup() {
+                console.log('Vue app setup function called');
+                const handleControlChange = (data) => {
                     console.log('Control changed:', data.name, data.value);
-                    if (this.visualization) {
+                    if (visualization) {
                         console.log('Updating visualization:', data);
                         
                         // Handle force-directed graph parameters
                         if (data.name === 'forceDirectedIterations' || 
                             data.name === 'forceDirectedRepulsion' || 
                             data.name === 'forceDirectedAttraction') {
-                            this.updateForceDirectedParams(data.name, data.value);
+                            updateForceDirectedParams(data.name, data.value);
                         } else {
                             // Pass name and value separately to updateVisualFeatures
-                            this.visualization.updateVisualFeatures(data.name, data.value);
+                            visualization.updateVisualFeatures(data.name, data.value);
                         }
                     } else {
                         console.error('Cannot update visualization: not initialized');
                     }
-                },
-                updateForceDirectedParams(name, value) {
-                    if (this.graphDataManager) {
+                };
+
+                const updateForceDirectedParams = (name, value) => {
+                    if (graphDataManager) {
                         // Update the force-directed parameters in the graph data manager
-                        this.graphDataManager.updateForceDirectedParams(name, value);
+                        graphDataManager.updateForceDirectedParams(name, value);
                         
                         // Trigger a recalculation of the graph layout
-                        this.graphDataManager.recalculateLayout();
+                        graphDataManager.recalculateLayout();
                         
                         // Update the visualization with the new layout
-                        this.visualization.updateVisualization();
+                        visualization.updateVisualization();
                     } else {
                         console.error('Cannot update force-directed parameters: GraphDataManager not initialized');
                     }
-                },
-                toggleFullscreen() {
+                };
+
+                const toggleFullscreen = () => {
                     if (document.fullscreenElement) {
                         document.exitFullscreen();
                     } else {
                         document.documentElement.requestFullscreen();
                     }
-                },
-                enableSpacemouse() {
-                    enableSpacemouse();
-                }
-            }
-        });
-
-        app.config.errorHandler = (err, vm, info) => {
-            console.error('Vue Error:', err, info);
-        };
+                };
 
-        app.config.warnHandler = (msg, vm, trace) => {
-            console.warn('Vue Warning:', msg, trace);
-        };
+                return {
+                    websocketService,
+                    handleControlChange,
+                    toggleFullscreen,
+                    enableSpacemouse
+                };
+            },
+            template: `
+                <div id="app-container">
+                    <chat-manager :websocketService="websocketService"></chat-manager>
+                    <control-panel 
+                        :websocketService="websocketService"
+                        @control-change="handleControlChange"
+                        @toggle-fullscreen="toggleFullscreen"
+                        @enable-spacemouse="enableSpacemouse"
+                        style="z-index: 1000;"
+                    ></control-panel>
+                </div>
+            `
+        });
 
-        // Make services available globally to the app
-        app.config.globalProperties.$websocketService = this.websocketService;
-        app.config.globalProperties.$visualization = this.visualization;
-        app.config.globalProperties.$graphDataManager = this.graphDataManager;
+        // Mount to a specific element
+        const mountElement = document.getElementById('app');
+        if (!mountElement) {
+            console.error('Could not find #app element for mounting Vue application');
+            return;
+        }
 
-        app.mount('#app');
-        console.log('Vue App mounted with services:', {
-            websocketService: this.websocketService,
-            visualization: this.visualization,
-            graphDataManager: this.graphDataManager
-        });
+        try {
+            app.mount('#app');
+            console.log('Vue App mounted successfully');
+        } catch (error) {
+            console.error('Failed to mount Vue app:', error);
+        }
     }
 
     setupEventListeners() {
@@ -260,8 +279,14 @@ class App {
             case 'ttsMethodSet':
                 console.log('TTS method set:', data.method);
                 break;
+            case 'error':
+                console.error('Server error:', data.message);
+                if (this.visualization) {
+                    this.visualization.showError(data.message);
+                }
+                break;
             default:
-                console.warn(`Unhandled message type: ${data.type}`);
+                console.warn(`Unhandled message type: ${data.type}`, data);
                 break;
         }
     }
@@ -279,16 +304,11 @@ class App {
     start() {
         console.log('Starting the application');
         if (this.visualization) {
+            console.log('Starting visualization animation');
             this.visualization.animate();
         } else {
             console.error('Cannot start animation: Visualization not initialized');
         }
-        if (this.gpuAvailable) {
-            console.log('GPU acceleration is available');
-            // Implement GPU-accelerated features here if needed
-        } else {
-            console.log('GPU acceleration is not available, using CPU fallback');
-        }
     }
 }
 
diff --git a/data/public/js/components/ControlPanel.vue b/data/public/js/components/ControlPanel.vue
index f59906f7..96eb7fe8 100755
--- a/data/public/js/components/ControlPanel.vue
+++ b/data/public/js/components/ControlPanel.vue
@@ -10,6 +10,18 @@ export default defineComponent({
         }
     },
     setup(props, { emit }) {
+        console.log('ControlPanel setup called');
+        
+        onMounted(() => {
+            console.log('ControlPanel mounted');
+            // Force visibility after mount
+            const panel = document.getElementById('control-panel');
+            if (panel) {
+                panel.style.display = 'block';
+                panel.style.visibility = 'visible';
+            }
+        });
+
         // Reactive state variables
         const isHidden = ref(false);
         const simulationMode = ref('remote');
@@ -315,6 +327,11 @@ export default defineComponent({
             scrollToBottom();
         });
 
+        // Add watch to debug state changes
+        watch(isHidden, (newVal) => {
+            console.log('isHidden changed to:', newVal);
+        });
+
         return {
             isHidden,
             simulationMode,
@@ -348,8 +365,8 @@ export default defineComponent({
 </script>
 
 <template>
-    <div id="control-panel" :class="{ hidden: isHidden }">
-        <button @click="togglePanel" class="toggle-button">
+    <div id="control-panel" :class="{ hidden: isHidden }" style="display: block !important;">
+        <button @click="togglePanel" class="toggle-button" style="display: block !important;">
             {{ isHidden ? '>' : '<' }}
         </button>
         <div class="panel-content" v-show="!isHidden">
@@ -621,6 +638,8 @@ export default defineComponent({
     overflow-y: auto;
     z-index: 1000;
     transition: transform 0.3s ease-in-out;
+    display: block !important;
+    visibility: visible !important;
 }
 
 #control-panel.hidden {
@@ -638,13 +657,16 @@ export default defineComponent({
     padding: 10px;
     cursor: pointer;
     border-radius: 5px 0 0 5px;
-    z-index: 2;
+    z-index: 1001;
+    display: block !important;
+    visibility: visible !important;
 }
 
 .panel-content {
     padding: 20px 20px 20px 40px;
     height: 100%;
     overflow-y: auto;
+    border: 1px solid rgba(255, 255, 255, 0.1);
 }
 
 .control-group {
diff --git a/data/public/js/components/visualization/core.js b/data/public/js/components/visualization/core.js
index b9e0c236..0c353618 100755
--- a/data/public/js/components/visualization/core.js
+++ b/data/public/js/components/visualization/core.js
@@ -10,6 +10,8 @@ const TRANSLATION_SPEED = 0.01;
 const ROTATION_SPEED = 0.01;
 
 export class WebXRVisualization {
+    // ... [previous methods unchanged until positionUpdate event listener] ...
+
     constructor(graphDataManager) {
         console.log('WebXRVisualization constructor called');
         this.graphDataManager = graphDataManager;
@@ -65,9 +67,11 @@ export class WebXRVisualization {
         // Handle position updates from layout manager
         window.addEventListener('positionUpdate', (event) => {
             console.log('Sending position update');
-            if (this.graphDataManager.websocketService && this.graphDataManager.websocketService.socket) {
-                // Send binary position data directly through websocket
-                this.graphDataManager.websocketService.socket.send(event.detail);
+            // Only send position updates if we have valid graph data
+            if (this.graphDataManager.isGraphDataValid()) {
+                if (this.graphDataManager.websocketService && this.graphDataManager.websocketService.socket) {
+                    this.graphDataManager.websocketService.socket.send(event.detail);
+                }
             }
         });
 
@@ -213,8 +217,14 @@ export class WebXRVisualization {
             // Apply force-directed layout
             this.layoutManager.applyForceDirectedLayout(graphData.nodes, graphData.edges);
             
-            // Update node positions
-            this.nodeManager.updateNodePositions(graphData.nodes);
+            // Convert nodes to position array format for NodeManager
+            const positions = graphData.nodes.map(node => ({
+                x: node.x,
+                y: node.y,
+                z: node.z
+            }));
+            
+            this.nodeManager.updateNodePositions(positions);
             
         } catch (error) {
             console.error('Error updating visualization:', error);
@@ -238,7 +248,8 @@ export class WebXRVisualization {
             } else if (control.startsWith('forceDirected')) {
                 console.log('Updating layout feature:', control, value);
                 this.layoutManager.updateFeature(control, value);
-                this.graphDataManager.updateForceDirectedParams(control.replace('forceDirected', ''), value);
+                // Pass the full parameter name to graphDataManager
+                this.graphDataManager.updateForceDirectedParams(control, value);
             }
 
             // Handle lighting and other scene-level features
@@ -314,59 +325,71 @@ export class WebXRVisualization {
             // Get all node positions for synchronization
             const positions = this.nodeManager.getNodePositions();
             
-            // Create binary position data (28 bytes per node - position, velocity, mass, padding)
-            const buffer = new ArrayBuffer(positions.length * 28);
+            // Create binary position data (24 bytes per node - position and velocity only)
+            const buffer = new ArrayBuffer(positions.length * 24);
             const view = new Float32Array(buffer);
             
             positions.forEach((pos, index) => {
-                const offset = index * 7; // 7 floats per node (3 pos + 3 vel + 1 mass)
+                const offset = index * 6; // 6 floats per node (3 pos + 3 vel)
                 // Position
-                view[offset] = pos.position.x;
-                view[offset + 1] = pos.position.y;
-                view[offset + 2] = pos.position.z;
-                // Velocity
-                view[offset + 3] = pos.velocity.x;
-                view[offset + 4] = pos.velocity.y;
-                view[offset + 5] = pos.velocity.z;
-                // Mass (based on node size/importance)
-                const mass = pos.scale ? Math.max(1.0, pos.scale) : 1.0;
-                view[offset + 6] = mass;
+                view[offset] = pos[0];     // x
+                view[offset + 1] = pos[1]; // y
+                view[offset + 2] = pos[2]; // z
+                // Velocity (default to 0 as we don't track velocity during drag)
+                view[offset + 3] = 0;
+                view[offset + 4] = 0;
+                view[offset + 5] = 0;
             });
 
-            // Send binary position update
-            if (this.graphDataManager.websocketService && this.graphDataManager.websocketService.socket) {
-                this.graphDataManager.websocketService.socket.send(buffer);
+            // Only send position updates if we have valid graph data
+            if (this.graphDataManager.isGraphDataValid()) {
+                if (this.graphDataManager.websocketService && this.graphDataManager.websocketService.socket) {
+                    this.graphDataManager.websocketService.socket.send(buffer);
+                }
             }
         }
     }
 
+    showError(message) {
+        console.error('Visualization error:', message);
+        // You could add visual feedback here, like a floating error message
+        const errorEvent = new CustomEvent('visualizationError', {
+            detail: { message }
+        });
+        window.dispatchEvent(errorEvent);
+    }
+
     handleBinaryPositionUpdate(buffer) {
         try {
-            const positions = new Float32Array(buffer);
+            console.log(`Processing binary position update of size: ${buffer.length} positions`);
+            
+            // Validate buffer size
+            if (buffer.length === 0) {
+                console.warn('Received empty position update buffer');
+                return;
+            }
+
             const updates = [];
             
-            // Each position update contains 7 float values (x,y,z, vx,vy,vz, mass)
-            for (let i = 0; i < positions.length; i += 7) {
-                updates.push({
-                    position: new THREE.Vector3(
-                        positions[i],
-                        positions[i + 1],
-                        positions[i + 2]
-                    ),
-                    velocity: new THREE.Vector3(
-                        positions[i + 3],
-                        positions[i + 4],
-                        positions[i + 5]
-                    ),
-                    mass: positions[i + 6]
-                });
+            // Each position update should have 6 values (x,y,z, vx,vy,vz)
+            for (let i = 0; i < buffer.length; i++) {
+                if (i + 2 < buffer.length) {  // Ensure we have at least x,y,z
+                    updates.push([
+                        buffer[i][0],     // x
+                        buffer[i][1],     // y
+                        buffer[i][2]      // z
+                    ]);
+                }
             }
 
-            // Fast update through node manager
+            console.log(`Processed ${updates.length} position updates`);
+
+            // Update node positions with array format
             this.nodeManager.updateNodePositions(updates);
         } catch (error) {
             console.error('Error handling binary position update:', error);
             console.error('Error stack:', error.stack);
+            this.showError(`Failed to update positions: ${error.message}`);
         }
     }
 }
diff --git a/data/public/js/components/visualization/effects.js b/data/public/js/components/visualization/effects.js
index c3ef9942..a8bcd67a 100755
--- a/data/public/js/components/visualization/effects.js
+++ b/data/public/js/components/visualization/effects.js
@@ -36,7 +36,7 @@ export class EffectsManager {
                 minFilter: THREE.LinearFilter,
                 magFilter: THREE.LinearFilter,
                 format: THREE.RGBAFormat,
-                encoding: THREE.sRGBEncoding
+                colorSpace: THREE.SRGBColorSpace
             }
         );
 
diff --git a/data/public/js/components/visualization/layout.js b/data/public/js/components/visualization/layout.js
index 6558d8ab..66cb240c 100755
--- a/data/public/js/components/visualization/layout.js
+++ b/data/public/js/components/visualization/layout.js
@@ -1,12 +1,14 @@
 export class LayoutManager {
     constructor(settings = {}) {
         // Configuration
-        this.initialIterations = settings.forceDirectedIterations || 250;
+        this.initialIterations = settings.iterations || 250;
         this.updateIterations = 1;       // Single iteration for smooth continuous updates
         this.targetRadius = 200;
         this.naturalLength = 100;
-        this.attraction = settings.forceDirectedAttraction || 0.01;
-        this.repulsion = settings.forceDirectedRepulsion || 1000;
+        this.attraction = settings.attraction_strength || 0.01;
+        this.repulsion = settings.repulsion_strength || 1000;
+        this.spring = settings.spring_strength || 0.1;
+        this.damping = settings.damping || 0.8;
         
         // State
         this.isInitialized = false;
@@ -18,10 +20,13 @@ export class LayoutManager {
         this.updateInterval = 16.67;     // Exactly 60fps
         this.positionBuffer = null;
         this.edges = [];                 // Store computed edges
+        this.nodeCount = 0;              // Track number of nodes
+        this.waitingForInitialData = true; // Wait for initial data before sending updates
     }
 
     initializePositions(nodes) {
         console.log('Initializing positions for nodes:', nodes);
+        this.nodeCount = nodes.length;
         nodes.forEach(node => {
             // Initialize only if positions are invalid
             if (isNaN(node.x) || isNaN(node.y) || isNaN(node.z)) {
@@ -50,17 +55,22 @@ export class LayoutManager {
         }));
 
         this.isInitialized = true;
+        this.waitingForInitialData = false; // Initial data received
         console.log('Position initialization complete');
     }
 
     applyForceDirectedLayout(nodes, edges) {
-        if (!this.isInitialized) {
-            console.warn('Layout manager not initialized');
+        if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
+            console.warn('Invalid nodes array provided to force-directed layout');
             return;
         }
 
-        console.log('Applying force-directed layout');
-        const damping = 0.9;
+        if (!this.isInitialized || this.waitingForInitialData) {
+            console.warn('Layout manager not initialized or waiting for initial data');
+            return;
+        }
+
+        console.log('Applying force-directed layout to', nodes.length, 'nodes');
         const dt = 0.1;
 
         // Apply forces based on edges (topic counts)
@@ -78,19 +88,19 @@ export class LayoutManager {
                 if (distance === 0) return;
 
                 // Use edge weight (from topic counts) to scale the force
-                const force = (distance - this.naturalLength) * this.attraction * (edge.weight || 1);
+                const force = (distance - this.naturalLength) * this.spring * (edge.weight || 1);
                 
                 const fx = (dx / distance) * force;
                 const fy = (dy / distance) * force;
                 const fz = (dz / distance) * force;
 
                 // Apply forces to both nodes
-                sourceNode.vx += fx;
-                sourceNode.vy += fy;
-                sourceNode.vz += fz;
-                targetNode.vx -= fx;
-                targetNode.vy -= fy;
-                targetNode.vz -= fz;
+                sourceNode.vx += fx * this.attraction;
+                sourceNode.vy += fy * this.attraction;
+                sourceNode.vz += fz * this.attraction;
+                targetNode.vx -= fx * this.attraction;
+                targetNode.vy -= fy * this.attraction;
+                targetNode.vz -= fz * this.attraction;
             }
         });
 
@@ -127,9 +137,9 @@ export class LayoutManager {
             node.z += node.vz * dt;
 
             // Apply damping
-            node.vx *= damping;
-            node.vy *= damping;
-            node.vz *= damping;
+            node.vx *= this.damping;
+            node.vy *= this.damping;
+            node.vz *= this.damping;
 
             // Bound checking
             const bound = 500;
@@ -145,18 +155,24 @@ export class LayoutManager {
             case 'forceDirectedIterations':
                 this.initialIterations = value;
                 break;
-            case 'forceDirectedRepulsion':
+            case 'spring_strength':
+                this.spring = value;
+                break;
+            case 'repulsion_strength':
                 this.repulsion = value;
                 break;
-            case 'forceDirectedAttraction':
+            case 'attraction_strength':
                 this.attraction = value;
                 break;
+            case 'damping':
+                this.damping = value;
+                break;
         }
     }
 
     performLayout(graphData) {
-        if (!this.isInitialized || !graphData) {
-            console.warn('Cannot perform layout: not initialized or no graph data');
+        if (!this.isInitialized || !graphData || this.waitingForInitialData) {
+            console.warn('Cannot perform layout: not initialized, no graph data, or waiting for initial data');
             return;
         }
 
@@ -172,15 +188,18 @@ export class LayoutManager {
     }
 
     sendPositionUpdates(nodes) {
-        if (!this.lastPositions) return;
+        if (!this.lastPositions || !this.isInitialized || nodes.length !== this.nodeCount || this.waitingForInitialData) {
+            console.warn('Cannot send position updates: not initialized, node count mismatch, or waiting for initial data');
+            return;
+        }
 
         // Create binary buffer for all node positions and velocities (24 bytes per node)
         const buffer = new ArrayBuffer(nodes.length * 24);
-        const dataView = new DataView(buffer);
+        const dataView = new Float32Array(buffer);
         let hasChanges = false;
 
         nodes.forEach((node, index) => {
-            const offset = index * 24;
+            const offset = index * 6;
             const lastPos = this.lastPositions[index];
 
             if (!lastPos || 
@@ -204,18 +223,21 @@ export class LayoutManager {
                 }
 
                 // Position (vec3<f32>)
-                dataView.setFloat32(offset, node.x, true);
-                dataView.setFloat32(offset + 4, node.y, true);
-                dataView.setFloat32(offset + 8, node.z, true);
+                dataView[offset] = node.x;
+                dataView[offset + 1] = node.y;
+                dataView[offset + 2] = node.z;
 
                 // Velocity (vec3<f32>)
-                dataView.setFloat32(offset + 12, node.vx || 0, true);
-                dataView.setFloat32(offset + 16, node.vy || 0, true);
-                dataView.setFloat32(offset + 20, node.vz || 0, true);
+                dataView[offset + 3] = node.vx || 0;
+                dataView[offset + 4] = node.vy || 0;
+                dataView[offset + 5] = node.vz || 0;
             }
         });
 
         if (hasChanges) {
+            // Log the buffer size before sending
+            console.log(`Sending position update buffer of size: ${buffer.byteLength} bytes for ${nodes.length} nodes`);
+            
             // Dispatch binary data event
             window.dispatchEvent(new CustomEvent('positionUpdate', {
                 detail: buffer
@@ -223,26 +245,6 @@ export class LayoutManager {
         }
     }
 
-    applyPositionUpdates(positions) {
-        if (!this.lastPositions) return;
-
-        // Handle binary data format (24 bytes per node)
-        if (positions instanceof ArrayBuffer) {
-            const dataView = new DataView(positions);
-            for (let i = 0; i < this.lastPositions.length; i++) {
-                const offset = i * 24;
-                this.lastPositions[i] = {
-                    x: dataView.getFloat32(offset, true),
-                    y: dataView.getFloat32(offset + 4, true),
-                    z: dataView.getFloat32(offset + 8, true),
-                    vx: dataView.getFloat32(offset + 12, true),
-                    vy: dataView.getFloat32(offset + 16, true),
-                    vz: dataView.getFloat32(offset + 20, true)
-                };
-            }
-        }
-    }
-
     startContinuousSimulation(graphData) {
         if (this.isSimulating) return;
         
diff --git a/data/public/js/components/visualization/nodes.js b/data/public/js/components/visualization/nodes.js
index b046f26b..220faea8 100755
--- a/data/public/js/components/visualization/nodes.js
+++ b/data/public/js/components/visualization/nodes.js
@@ -26,9 +26,9 @@ export class NodeManager {
         this.edgeMeshes = new Map();
         
         // Node settings
-        this.minNodeSize = 0.1;  // Minimum node size in visualization
-        this.maxNodeSize = 5;    // Maximum node size in visualization
-        this.nodeSizeScalingFactor = 1;  // Global scaling factor
+        this.minNodeSize = 0.01;  // Reduced from 0.1
+        this.maxNodeSize = 0.5;   // Reduced from 5
+        this.nodeSizeScalingFactor = 1;  // Reduced scaling factor
         this.labelFontSize = 18;
         this.nodeColor = new THREE.Color(0x4444ff);  // Initialize as THREE.Color
 
@@ -37,20 +37,24 @@ export class NodeManager {
         this.edgeOpacity = 0.6;
 
         // Server-side node size range (must match constants in file_service.rs)
-        this.serverMinNodeSize = 5.0;
-        this.serverMaxNodeSize = 50.0;
+        this.serverMinNodeSize = 0.5;  // Reduced from 5.0
+        this.serverMaxNodeSize = 5.0;  // Reduced from 50.0
     }
 
     getNodeSize(metadata) {
         // Use the node_size from metadata if available
         if (metadata.node_size) {
-            // Convert from server's range (5.0-50.0) to visualization range (0.1-5.0)
+            // Convert from server's range to visualization range
             const serverSize = parseFloat(metadata.node_size);
-            const normalizedSize = (serverSize - this.serverMinNodeSize) / (this.serverMaxNodeSize - this.serverMinNodeSize);
-            return this.minNodeSize + (this.maxNodeSize - this.minNodeSize) * normalizedSize * this.nodeSizeScalingFactor;
+            const normalizedSize = (serverSize - this.serverMinNodeSize) / 
+                                 (this.serverMaxNodeSize - this.serverMinNodeSize);
+            return this.minNodeSize + 
+                   (this.maxNodeSize - this.minNodeSize) * 
+                   normalizedSize * 
+                   this.nodeSizeScalingFactor;
         }
         
-        // Fallback to a default size if node_size is not available
+        // Fallback to minimum size if node_size is not available
         return this.minNodeSize;
     }
 
@@ -66,8 +70,9 @@ export class NodeManager {
     }
 
     createNodeGeometry(size, hyperlinkCount) {
+        // Adjust geometry creation for smaller sizes
         if (hyperlinkCount < 6) {
-            return new THREE.SphereGeometry(size, 32, 32);
+            return new THREE.SphereGeometry(size, 16, 16); // Reduced segments for better performance
         } else if (hyperlinkCount < 16) {
             return new THREE.BoxGeometry(size, size, size);
         } else {
@@ -106,7 +111,7 @@ export class NodeManager {
             depthWrite: false
         });
         const sprite = new THREE.Sprite(spriteMaterial);
-        sprite.scale.set(canvas.width / 10, canvas.height / 10, 1);
+        sprite.scale.set(canvas.width / 20, canvas.height / 20, 1); // Reduced scale
         sprite.layers.set(NORMAL_LAYER);
 
         return sprite;
@@ -312,8 +317,20 @@ export class NodeManager {
     }
 
     updateLabelOrientations(camera) {
-        this.nodeLabels.forEach(label => {
-            label.lookAt(camera.position);
+        this.nodeLabels.forEach((label, nodeId) => {
+            const mesh = this.nodeMeshes.get(nodeId);
+            if (mesh) {
+                // Position label closer to node due to smaller size
+                const size = mesh.geometry.parameters.radius || 
+                           mesh.geometry.parameters.width || 
+                           this.minNodeSize;
+                label.position.set(
+                    mesh.position.x,
+                    mesh.position.y + size + 0.2, // Reduced offset
+                    mesh.position.z
+                );
+                label.lookAt(camera.position);
+            }
         });
     }
 
@@ -362,58 +379,68 @@ export class NodeManager {
     }
 
     updateNodePositions(positions) {
-        // Handle array-based format (new binary format)
-        if (Array.isArray(positions)) {
-            positions.forEach((position, index) => {
-                const nodeId = Array.from(this.nodeMeshes.keys())[index];
-                if (!nodeId) return;
+        if (!positions) {
+            console.warn('Received null or undefined positions');
+            return;
+        }
 
-                const mesh = this.nodeMeshes.get(nodeId);
-                const label = this.nodeLabels.get(nodeId);
-                
-                if (mesh) {
-                    const [x, y, z] = position;
-                    mesh.position.set(x, y, z);
-                    
-                    if (label) {
-                        const size = mesh.geometry.parameters.radius || 
-                                   mesh.geometry.parameters.width || 
-                                   1; // fallback size
-                        label.position.set(x, y + size + 2, z);
-                    }
+        // Ensure positions is an array
+        const positionsArray = Array.isArray(positions) ? positions : Array.from(positions);
+        console.log('Updating positions for', positionsArray.length, 'nodes');
 
-                    // Update connected edges
-                    this.updateEdgesForNode(nodeId);
-                }
-            });
-        }
-        // Handle legacy object-based format
-        else if (typeof positions === 'object') {
-            Object.entries(positions).forEach(([index, position]) => {
-                const nodeId = Array.from(this.nodeMeshes.keys())[index];
-                if (!nodeId) return;
+        // Get array of node IDs
+        const nodeIds = Array.from(this.nodeMeshes.keys());
 
-                const mesh = this.nodeMeshes.get(nodeId);
-                const label = this.nodeLabels.get(nodeId);
-                
-                if (mesh) {
-                    mesh.position.set(position.x, position.y, position.z);
-                    
-                    if (label) {
-                        const size = mesh.geometry.parameters.radius || 
-                                   mesh.geometry.parameters.width || 
-                                   1; // fallback size
-                        label.position.set(position.x, position.y + size + 2, position.z);
-                    }
+        // Update each node position
+        positionsArray.forEach((position, index) => {
+            const nodeId = nodeIds[index];
+            if (!nodeId) {
+                console.warn(`No node found for index ${index}`);
+                return;
+            }
 
-                    // Update connected edges
-                    this.updateEdgesForNode(nodeId);
+            const mesh = this.nodeMeshes.get(nodeId);
+            const label = this.nodeLabels.get(nodeId);
+            
+            if (!mesh) {
+                console.warn(`No mesh found for node ${nodeId}`);
+                return;
+            }
+
+            // Extract position values, handling both array and object formats
+            let x, y, z;
+            if (Array.isArray(position)) {
+                [x, y, z] = position;
+            } else if (position && typeof position === 'object') {
+                ({ x, y, z } = position);
+            } else {
+                console.warn(`Invalid position format for node ${nodeId}:`, position);
+                return;
+            }
+
+            // Validate position values
+            if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' &&
+                !isNaN(x) && !isNaN(y) && !isNaN(z)) {
+                
+                // Update mesh position
+                mesh.position.set(x, y, z);
+                
+                // Update label position if it exists
+                if (label) {
+                    const size = mesh.geometry.parameters.radius || 
+                               mesh.geometry.parameters.width || 
+                               1; // fallback size
+                    label.position.set(x, y + size + 2, z);
                 }
-            });
-        }
+
+                // Update connected edges
+                this.updateEdgesForNode(nodeId);
+            } else {
+                console.warn(`Invalid position values for node ${nodeId}: x=${x}, y=${y}, z=${z}`);
+            }
+        });
     }
 
-    // Helper method to update edges for a specific node
     updateEdgesForNode(nodeId) {
         this.edgeMeshes.forEach((line, edgeKey) => {
             const [source, target] = edgeKey.split('-');
diff --git a/data/public/js/index.js b/data/public/js/index.js
index 98fee060..bcc206ed 100755
--- a/data/public/js/index.js
+++ b/data/public/js/index.js
@@ -1,6 +1,29 @@
+import { createApp } from 'vue';
 import { App } from './app.js';
 
+console.log('Script loading...');
+
+// Check if Vue is available
+if (typeof createApp !== 'function') {
+    console.error('Vue is not loaded!');
+}
+
 document.addEventListener('DOMContentLoaded', () => {
-    const app = new App();
-    app.start();
+    console.log('DOM loaded, checking elements:');
+    console.log('app element:', document.getElementById('app'));
+    console.log('scene-container:', document.getElementById('scene-container'));
+    console.log('connection-status:', document.getElementById('connection-status'));
+    
+    try {
+        console.log('Creating App instance');
+        const app = new App();
+        console.log('Starting App');
+        app.start();
+    } catch (error) {
+        console.error('Failed to initialize app:', error);
+        const debugInfo = document.getElementById('debug-info');
+        if (debugInfo) {
+            debugInfo.innerHTML += `<div>Init Error: ${error.message}</div>`;
+        }
+    }
 });
diff --git a/data/public/js/services/graphDataManager.js b/data/public/js/services/graphDataManager.js
index 035b3638..cd12ade4 100755
--- a/data/public/js/services/graphDataManager.js
+++ b/data/public/js/services/graphDataManager.js
@@ -12,30 +12,23 @@ export class GraphDataManager {
         this.websocketService = websocketService;
         this.graphData = null;
         this.forceDirectedParams = {
-            iterations: 100,
-            repulsionStrength: 1.0,
-            attractionStrength: 0.01,
-            damping: 0.9
+            forceDirectedIterations: 250,
+            forceDirectedSpring: 0.1,
+            forceDirectedRepulsion: 1000,
+            forceDirectedAttraction: 0.01,
+            forceDirectedDamping: 0.8
         };
         console.log('GraphDataManager initialized');
         
-        // Set up WebSocket message listeners
         this.websocketService.on('graphUpdate', this.handleGraphUpdate.bind(this));
         this.websocketService.on('gpuPositions', this.handleGPUPositions.bind(this));
     }
 
-    /**
-     * Requests the initial graph data from the server via WebSocket.
-     */
     requestInitialData() {
         console.log('Requesting initial data');
         this.websocketService.send({ type: 'getInitialData' });
     }
 
-    /**
-     * Handles GPU-computed position updates from the server.
-     * @param {object} update - The position update data.
-     */
     handleGPUPositions(update) {
         if (!this.graphData || !this.graphData.nodes) {
             console.error('Cannot apply GPU position update: No graph data exists');
@@ -43,18 +36,28 @@ export class GraphDataManager {
         }
 
         const { positions } = update;
+        console.log('Received GPU position update:', positions);
         
         // Update node positions from GPU computation
         this.graphData.nodes.forEach((node, index) => {
             if (positions[index]) {
-                const [x, y, z] = positions[index];
-                node.x = x;
-                node.y = y;
-                node.z = z;
-                // Clear velocities since GPU is handling movement
-                node.vx = 0;
-                node.vy = 0;
-                node.vz = 0;
+                const pos = positions[index];
+                if (Array.isArray(pos) && pos.length >= 3) {
+                    node.x = pos[0];
+                    node.y = pos[1];
+                    node.z = pos[2];
+                    // Clear velocities since GPU is handling movement
+                    node.vx = 0;
+                    node.vy = 0;
+                    node.vz = 0;
+                } else if (pos && typeof pos === 'object') {
+                    node.x = pos.x;
+                    node.y = pos.y;
+                    node.z = pos.z;
+                    node.vx = 0;
+                    node.vy = 0;
+                    node.vz = 0;
+                }
             }
         });
 
@@ -64,10 +67,6 @@ export class GraphDataManager {
         }));
     }
 
-    /**
-     * Handles graph update messages.
-     * @param {object} data - The received graph data.
-     */
     handleGraphUpdate(data) {
         console.log('Received graph update:', data);
         if (!data || !data.graphData) {
@@ -77,10 +76,6 @@ export class GraphDataManager {
         this.updateGraphData(data.graphData);
     }
 
-    /**
-     * Updates the internal graph data with new data received from the server.
-     * @param {object} newData - The new graph data.
-     */
     updateGraphData(newData) {
         console.log('Updating graph data with:', newData);
         
@@ -132,7 +127,7 @@ export class GraphDataManager {
             const nodeSet = new Set();
             newData.edges.forEach(edge => {
                 nodeSet.add(edge.source);
-                nodeSet.add(edge.target); // Fixed: using target instead of target_node
+                nodeSet.add(edge.target);
             });
 
             const nodes = Array.from(nodeSet).map(id => {
@@ -157,7 +152,7 @@ export class GraphDataManager {
                 nodes,
                 edges: newData.edges.map(e => ({
                     source: e.source,
-                    target: e.target, // Fixed: using target instead of target_node
+                    target: e.target,
                     weight: e.weight,
                     hyperlinks: e.hyperlinks
                 })),
@@ -175,10 +170,6 @@ export class GraphDataManager {
         window.dispatchEvent(new CustomEvent('graphDataUpdated', { detail: this.graphData }));
     }
 
-    /**
-     * Retrieves the current graph data.
-     * @returns {object|null} The current graph data or null if not set.
-     */
     getGraphData() {
         if (this.graphData) {
             console.log(`Returning graph data: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
@@ -189,10 +180,6 @@ export class GraphDataManager {
         return this.graphData;
     }
 
-    /**
-     * Checks if the graph data is valid.
-     * @returns {boolean} True if the graph data is valid, false otherwise.
-     */
     isGraphDataValid() {
         return this.graphData && 
                Array.isArray(this.graphData.nodes) && 
@@ -200,22 +187,12 @@ export class GraphDataManager {
                this.graphData.nodes.length > 0;
     }
 
-    /**
-     * Updates the force-directed graph parameters.
-     * @param {string} name - The name of the parameter to update.
-     * @param {number} value - The new value for the parameter.
-     */
     updateForceDirectedParams(name, value) {
         console.log(`Updating force-directed parameter: ${name} = ${value}`);
-        const paramMap = {
-            'iterations': 'iterations',
-            'repulsionStrength': 'repulsionStrength',
-            'attractionStrength': 'attractionStrength'
-        };
-
-        const serverParamName = paramMap[name];
-        if (serverParamName) {
-            this.forceDirectedParams[serverParamName] = value;
+        
+        // Handle full parameter names
+        if (this.forceDirectedParams.hasOwnProperty(name)) {
+            this.forceDirectedParams[name] = value;
             console.log('Force-directed parameters updated:', this.forceDirectedParams);
             this.recalculateLayout();
         } else {
@@ -223,19 +200,17 @@ export class GraphDataManager {
         }
     }
 
-    /**
-     * Recalculates the graph layout using the current force-directed parameters.
-     */
     recalculateLayout() {
         console.log('Requesting server layout recalculation with parameters:', this.forceDirectedParams);
         if (this.isGraphDataValid()) {
             this.websocketService.send({
                 type: 'recalculateLayout',
                 params: {
-                    iterations: this.forceDirectedParams.iterations,
-                    springStrength: this.forceDirectedParams.attractionStrength,
-                    repulsionStrength: this.forceDirectedParams.repulsionStrength,
-                    damping: this.forceDirectedParams.damping
+                    iterations: this.forceDirectedParams.forceDirectedIterations,
+                    spring_strength: this.forceDirectedParams.forceDirectedSpring,
+                    repulsion_strength: this.forceDirectedParams.forceDirectedRepulsion,
+                    attraction_strength: this.forceDirectedParams.forceDirectedAttraction,
+                    damping: this.forceDirectedParams.forceDirectedDamping
                 }
             });
             
diff --git a/data/public/js/services/visualizationSettings.js b/data/public/js/services/visualizationSettings.js
index 5deb0905..145f91c0 100755
--- a/data/public/js/services/visualizationSettings.js
+++ b/data/public/js/services/visualizationSettings.js
@@ -24,10 +24,10 @@ export class VisualizationSettings {
             
             // Force-directed layout settings
             forceDirectedIterations: parseInt(process.env.FORCE_DIRECTED_ITERATIONS) || 100,
-            forceDirectedSpring: parseFloat(process.env.FORCE_DIRECTED_SPRING) || 0.1,
-            forceDirectedRepulsion: parseFloat(process.env.FORCE_DIRECTED_REPULSION) || 1000.0,
-            forceDirectedAttraction: parseFloat(process.env.FORCE_DIRECTED_ATTRACTION) || 0.01,
-            forceDirectedDamping: parseFloat(process.env.FORCE_DIRECTED_DAMPING) || 0.8,
+            spring_strength: parseFloat(process.env.FORCE_DIRECTED_SPRING) || 0.1,
+            repulsion_strength: parseFloat(process.env.FORCE_DIRECTED_REPULSION) || 1000.0,
+            attraction_strength: parseFloat(process.env.FORCE_DIRECTED_ATTRACTION) || 0.01,
+            damping: parseFloat(process.env.FORCE_DIRECTED_DAMPING) || 0.8,
             
             // Bloom settings
             nodeBloomStrength: parseFloat(process.env.NODE_BLOOM_STRENGTH) || 0.1,
@@ -104,10 +104,10 @@ export class VisualizationSettings {
     getLayoutSettings() {
         return {
             iterations: this.settings.forceDirectedIterations,
-            spring: this.settings.forceDirectedSpring,
-            repulsion: this.settings.forceDirectedRepulsion,
-            attraction: this.settings.forceDirectedAttraction,
-            damping: this.settings.forceDirectedDamping
+            spring_strength: this.settings.spring_strength,
+            repulsion_strength: this.settings.repulsion_strength,
+            attraction_strength: this.settings.attraction_strength,
+            damping: this.settings.damping
         };
     }
 
diff --git a/data/public/js/services/websocketService.js b/data/public/js/services/websocketService.js
index fc88b9c2..c250783b 100755
--- a/data/public/js/services/websocketService.js
+++ b/data/public/js/services/websocketService.js
@@ -111,9 +111,32 @@ export default class WebsocketService {
     handleMessage = async (event) => {
         try {
             if (event.data instanceof ArrayBuffer) {
-                // Handle binary position updates by passing directly to visualization
+                // Log received buffer size
+                console.log(`Received binary data of size: ${event.data.byteLength} bytes`);
+                
+                // Convert ArrayBuffer to Float32Array for position updates
+                const positions = new Float32Array(event.data);
+                const positionUpdates = [];
+                
+                // Each node has 6 values (x,y,z, vx,vy,vz)
+                for (let i = 0; i < positions.length; i += 6) {
+                    if (i + 5 < positions.length) {  // Ensure we have complete node data
+                        positionUpdates.push([
+                            positions[i],     // x
+                            positions[i + 1], // y
+                            positions[i + 2], // z
+                            positions[i + 3], // vx
+                            positions[i + 4], // vy
+                            positions[i + 5]  // vz
+                        ]);
+                    }
+                }
+
+                console.log(`Processed ${positionUpdates.length} node position updates`);
+
+                // Dispatch event with properly formatted positions array
                 window.dispatchEvent(new CustomEvent('binaryPositionUpdate', {
-                    detail: event.data
+                    detail: positionUpdates
                 }));
                 return;
             }
@@ -128,7 +151,9 @@ export default class WebsocketService {
             this.emit('error', { 
                 type: 'parse_error', 
                 message: error.message, 
-                rawData: event.data 
+                rawData: event.data instanceof ArrayBuffer ? 
+                    `Binary data of size ${event.data.byteLength}` : 
+                    event.data 
             });
         }
     }
@@ -147,7 +172,8 @@ export default class WebsocketService {
     send(data) {
         if (this.socket && this.socket.readyState === WebSocket.OPEN) {
             if (data instanceof ArrayBuffer) {
-                // Send binary data directly
+                // Log binary data size before sending
+                console.log(`Sending binary data of size: ${data.byteLength} bytes`);
                 this.socket.send(data);
             } else {
                 // Send JSON data
@@ -155,7 +181,8 @@ export default class WebsocketService {
                 this.socket.send(JSON.stringify(data));
             }
         } else {
-            console.warn('WebSocket is not open. Unable to send message:', data);
+            console.warn('WebSocket is not open. Unable to send message:', 
+                data instanceof ArrayBuffer ? `Binary data of size ${data.byteLength}` : data);
             this.emit('error', { type: 'send_error', message: 'WebSocket is not open' });
         }
     }
diff --git a/src/handlers/file_handler.rs b/src/handlers/file_handler.rs
index dad69b88..63bb4c90 100755
--- a/src/handlers/file_handler.rs
+++ b/src/handlers/file_handler.rs
@@ -1,7 +1,6 @@
 use actix_web::{web, Error as ActixError, HttpResponse};
 use serde_json::json;
 use log::{info, error, debug};
-use std::collections::HashMap;
 use crate::AppState;
 use crate::services::file_service::FileService;
 use crate::services::graph_service::GraphService;
diff --git a/src/handlers/websocket_handlers.rs b/src/handlers/websocket_handlers.rs
index addb072b..f6641ba2 100755
--- a/src/handlers/websocket_handlers.rs
+++ b/src/handlers/websocket_handlers.rs
@@ -2,7 +2,6 @@ use actix::prelude::*;
 use actix::ResponseActFuture;
 use actix_web::web;
 use actix_web_actors::ws::WebsocketContext;
-use bytes::Bytes;
 use bytestring::ByteString;
 use bytemuck;
 use futures::StreamExt;
@@ -133,7 +132,49 @@ impl Handler<SendBinary> for WebSocketSession {
     type Result = ();
 
     fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
-        ctx.binary(Bytes::from(msg.0));
+        if let Some(gpu_compute) = &self.state.gpu_compute {
+            let gpu = gpu_compute.clone();
+            let bin_data = msg.0.clone();
+            let ctx_addr = ctx.address();
+
+            ctx.spawn(
+                async move {
+                    let gpu_read = gpu.read().await;
+                    let expected_size = gpu_read.get_num_nodes() as usize * 24;
+                    drop(gpu_read); // Release the read lock before writing
+
+                    if bin_data.len() != expected_size {
+                        error!("Invalid position data length: expected {}, got {}", 
+                            expected_size, bin_data.len());
+                        let error_message = json!({
+                            "type": "error",
+                            "message": format!("Invalid position data length: expected {}, got {}", 
+                                expected_size, bin_data.len())
+                        });
+                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+                            let msg: SendText = SendText(error_str);
+                            ctx_addr.do_send(msg);
+                            
+                        }
+                        return;
+                    }
+
+                    let mut gpu_write = gpu.write().await;
+                    if let Err(e) = gpu_write.update_positions(&bin_data).await {
+                        error!("Failed to update node positions: {}", e);
+                        let error_message = json!({
+                            "type": "error",
+                            "message": format!("Failed to update node positions: {}", e)
+                        });
+                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+                            let msg: SendText = SendText(error_str);
+                            ctx_addr.do_send(msg);
+                        }
+                    }
+                }
+                .into_actor(self)
+            );
+        }
     }
 }
 
diff --git a/src/main.rs b/src/main.rs
index 5228d2cf..13421520 100755
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,11 +32,13 @@ mod models;
 mod services;
 mod utils;
 
-async fn initialize_graph_data(app_state: &web::Data<AppState>) -> std::io::Result<()> {
-    log::info!("Starting graph data initialization...");
+/// Initialize graph data from cached metadata
+/// This is called at startup to quickly get the graph running before GitHub updates
+async fn initialize_cached_graph_data(app_state: &web::Data<AppState>) -> std::io::Result<()> {
+    log::info!("Loading cached graph data...");
     
-    // First load existing metadata
-    let mut metadata_map = match FileService::load_or_create_metadata() {
+    // Load existing metadata from disk
+    let metadata_map = match FileService::load_or_create_metadata() {
         Ok(map) => {
             log::info!("Loaded existing metadata with {} entries", map.len());
             map
@@ -47,77 +49,37 @@ async fn initialize_graph_data(app_state: &web::Data<AppState>) -> std::io::Resu
         }
     };
 
-    // Update metadata with any new or changed files
-    log::info!("Fetching and processing files from GitHub...");
-    match FileService::fetch_and_process_files(&*app_state.github_service, app_state.settings.clone(), &mut metadata_map).await {
-        Ok(processed_files) => {
-            log::info!("Successfully processed {} files", processed_files.len());
-            log::debug!("Processed files: {:?}", processed_files.iter().map(|f| &f.file_name).collect::<Vec<_>>());
-
-            // Update file cache
-            let mut file_cache = app_state.file_cache.write().await;
-            for processed_file in &processed_files {
-                log::debug!("Caching file: {}", processed_file.file_name);
-                file_cache.insert(processed_file.file_name.clone(), processed_file.content.clone());
-            }
-            drop(file_cache); // Explicitly drop the write lock
-
-            // Update graph metadata
-            {
-                let mut graph = app_state.graph_data.write().await;
-                graph.metadata = metadata_map.clone();
-            }
-
-            // Build graph from metadata
-            log::info!("Building graph from metadata...");
-            match GraphService::build_graph_from_metadata(&metadata_map).await {
-                Ok(graph_data) => {
-                    let mut graph = app_state.graph_data.write().await;
-                    *graph = graph_data;
-                    log::info!("Graph data structure initialized successfully");
-                    log::debug!("Graph stats: {} nodes, {} edges", 
-                        graph.nodes.len(), 
-                        graph.edges.len()
-                    );
-                    Ok(())
-                },
-                Err(e) => {
-                    log::error!("Failed to build graph data: {}", e);
-                    log::error!("Error details: {:?}", e);
-                    Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to build graph data: {}", e)))
-                }
-            }
+    // Build initial graph from cached metadata
+    log::info!("Building graph from cached metadata...");
+    match GraphService::build_graph_from_metadata(&metadata_map).await {
+        Ok(graph_data) => {
+            let mut graph = app_state.graph_data.write().await;
+            *graph = graph_data;
+            log::info!("Graph initialized from cache with {} nodes and {} edges", 
+                graph.nodes.len(), 
+                graph.edges.len()
+            );
+            Ok(())
         },
         Err(e) => {
-            log::error!("Error processing files: {:?}", e);
-            log::error!("Error details: {:?}", e);
-            Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Error processing files: {:?}", e)))
+            log::error!("Failed to build graph from cache: {}", e);
+            Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
         }
     }
 }
 
-async fn test_speech_service(app_state: web::Data<AppState>) -> HttpResponse {
-    match app_state.speech_service.send_message("Hello, OpenAI!".to_string()).await {
-        Ok(_) => HttpResponse::Ok().body("Message sent successfully"),
-        Err(e) => HttpResponse::InternalServerError().body(format!("Error: {}", e)),
-    }
-}
-
-// Simple health check endpoint that returns 200 OK when the service is running
-async fn health_check() -> HttpResponse {
-    HttpResponse::Ok().finish()
-}
-
-async fn randomize_nodes_periodically(app_state: web::Data<AppState>) {
-    let mut interval = interval(Duration::from_secs(30));
+/// Periodic graph update function
+/// Checks for GitHub updates every 5 minutes while preserving node positions
+async fn update_graph_periodically(app_state: web::Data<AppState>) {
+    let mut interval = interval(Duration::from_secs(300)); // 5 minute interval
 
     loop {
         interval.tick().await;
         
-        log::debug!("Starting periodic graph rebuild...");
+        log::debug!("Starting periodic graph update...");
         
         // Load current metadata
-        let metadata_map = match FileService::load_or_create_metadata() {
+        let mut metadata_map = match FileService::load_or_create_metadata() {
             Ok(map) => map,
             Err(e) => {
                 log::error!("Failed to load metadata: {}", e);
@@ -125,42 +87,84 @@ async fn randomize_nodes_periodically(app_state: web::Data<AppState>) {
             }
         };
 
-        // Build graph from metadata
-        match GraphService::build_graph_from_metadata(&metadata_map).await {
-            Ok(graph_data) => {
-                // Update graph data
-                let mut graph = app_state.graph_data.write().await;
-                *graph = graph_data.clone();
-                drop(graph);
+        // Check for GitHub updates
+        match FileService::fetch_and_process_files(&*app_state.github_service, app_state.settings.clone(), &mut metadata_map).await {
+            Ok(processed_files) => {
+                if !processed_files.is_empty() {
+                    log::info!("Found {} updated files, updating graph", processed_files.len());
+
+                    // Update file cache with new/modified files
+                    let mut file_cache = app_state.file_cache.write().await;
+                    for processed_file in &processed_files {
+                        file_cache.insert(processed_file.file_name.clone(), processed_file.content.clone());
+                    }
+                    drop(file_cache);
 
-                // Notify WebSocket clients about the updated graph
-                let graph_data = app_state.graph_data.read().await;
-                if let Err(e) = app_state.websocket_manager.broadcast_graph_update(&graph_data).await {
-                    log::error!("Failed to broadcast graph update: {}", e);
+                    // Update graph while preserving node positions
+                    let mut graph = app_state.graph_data.write().await;
+                    let old_positions: HashMap<String, (f32, f32, f32)> = graph.nodes.iter()
+                        .map(|node| (node.id.clone(), (node.x, node.y, node.z)))
+                        .collect();
+                    
+                    // Update metadata
+                    graph.metadata = metadata_map.clone();
+
+                    // Build new graph preserving positions
+                    if let Ok(mut new_graph) = GraphService::build_graph_from_metadata(&metadata_map).await {
+                        // Preserve positions for existing nodes
+                        for node in &mut new_graph.nodes {
+                            if let Some(&(x, y, z)) = old_positions.get(&node.id) {
+                                node.x = x;
+                                node.y = y;
+                                node.z = z;
+                            }
+                        }
+                        *graph = new_graph;
+                        
+                        // Notify clients of the update
+                        if let Err(e) = app_state.websocket_manager.broadcast_graph_update(&graph).await {
+                            log::error!("Failed to broadcast graph update: {}", e);
+                        }
+                    }
+                } else {
+                    log::debug!("No updates found");
                 }
             },
-            Err(e) => {
-                log::error!("Failed to rebuild graph: {}", e);
-            }
+            Err(e) => log::error!("Failed to check for updates: {}", e)
         }
 
-        log::debug!("Completed periodic graph rebuild");
+        log::debug!("Completed periodic graph update");
+    }
+}
+
+/// Simple health check endpoint
+async fn health_check() -> HttpResponse {
+    HttpResponse::Ok().finish()
+}
+
+/// Test endpoint for speech service
+async fn test_speech_service(app_state: web::Data<AppState>) -> HttpResponse {
+    match app_state.speech_service.send_message("Hello, OpenAI!".to_string()).await {
+        Ok(_) => HttpResponse::Ok().body("Message sent successfully"),
+        Err(e) => HttpResponse::InternalServerError().body(format!("Error: {}", e)),
     }
 }
 
 #[actix_web::main]
 async fn main() -> std::io::Result<()> {
-    // Load environment variables from .env file if it exists
+    // Load environment variables
     if let Ok(vars) = envy::from_env::<HashMap<String, String>>() {
         for (key, value) in vars {
             env::set_var(key, value);
         }
     }
 
+    // Initialize logging
     std::env::set_var("RUST_LOG", "debug");
     env_logger::init();
     log::info!("Starting WebXR Graph Server");
 
+    // Load configuration
     log::info!("Loading settings...");
     let settings = match Settings::new() {
         Ok(s) => {
@@ -173,9 +177,11 @@ async fn main() -> std::io::Result<()> {
         }
     };
 
+    // Initialize core data structures
     let file_cache = Arc::new(RwLock::new(HashMap::new()));
     let graph_data = Arc::new(RwLock::new(GraphData::default()));
     
+    // Initialize GitHub service
     log::info!("Initializing GitHub service...");
     let github_service: Arc<dyn GitHubService + Send + Sync> = {
         let settings_read = settings.read().await;
@@ -194,6 +200,7 @@ async fn main() -> std::io::Result<()> {
         }
     };
 
+    // Initialize GitHub PR service
     log::info!("Initializing GitHub PR service...");
     let github_pr_service: Arc<dyn GitHubPRService + Send + Sync> = {
         let settings_read = settings.read().await;
@@ -211,6 +218,7 @@ async fn main() -> std::io::Result<()> {
         }
     };
     
+    // Initialize services
     let perplexity_service = Arc::new(PerplexityServiceImpl::new()) as Arc<dyn PerplexityService + Send + Sync>;
     
     log::info!("Initializing RAGFlow service...");
@@ -222,7 +230,7 @@ async fn main() -> std::io::Result<()> {
         }
     };
 
-    // Create a single RAGFlow conversation
+    // Create RAGFlow conversation
     log::info!("Creating RAGFlow conversation...");
     let ragflow_conversation_id = match ragflow_service.create_conversation("default_user".to_string()).await {
         Ok(id) => {
@@ -237,12 +245,12 @@ async fn main() -> std::io::Result<()> {
 
     let websocket_manager = Arc::new(WebSocketManager::new());
     
-    // Initialize with default graph data first
+    // Initialize GPU compute with default graph
     log::info!("Initializing GPU compute...");
     let initial_graph_data = graph_data.read().await;
     let gpu_compute = match GPUCompute::new(&initial_graph_data).await {
         Ok(gpu) => {
-            log::info!("GPU initialization successful");
+            log::info!("GPU initialization successful with {} nodes", initial_graph_data.nodes.len());
             Some(Arc::new(RwLock::new(gpu)))
         },
         Err(e) => {
@@ -250,8 +258,9 @@ async fn main() -> std::io::Result<()> {
             None
         }
     };
-    drop(initial_graph_data); // Release the read lock
+    drop(initial_graph_data);
 
+    // Initialize speech service
     log::info!("Initializing speech service...");
     let speech_service = Arc::new(SpeechService::new(websocket_manager.clone(), settings.clone()));
     if let Err(e) = speech_service.initialize().await {
@@ -259,6 +268,7 @@ async fn main() -> std::io::Result<()> {
         return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize SpeechService: {:?}", e)));
     }
 
+    // Create application state
     let app_state = web::Data::new(AppState::new(
         graph_data,
         file_cache,
@@ -273,27 +283,28 @@ async fn main() -> std::io::Result<()> {
         github_pr_service,
     ));
 
-    log::info!("Initializing graph data...");
-    if let Err(e) = initialize_graph_data(&app_state).await {
-        log::error!("Failed to initialize graph data: {:?}", e);
-        return Err(e);
+    // Initialize graph from cache for fast startup
+    log::info!("Initializing graph with cached data...");
+    if let Err(e) = initialize_cached_graph_data(&app_state).await {
+        log::warn!("Failed to initialize from cache: {:?}, proceeding with empty graph", e);
     }
 
+    // Initialize WebSocket manager
     log::info!("Initializing WebSocket manager...");
     if let Err(e) = websocket_manager.initialize(&ragflow_service).await {
-        log::error!("Failed to initialize RAGflow conversation: {:?}", e);
-        return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize RAGflow conversation: {:?}", e)));
+        log::error!("Failed to initialize WebSocket manager: {:?}", e);
+        return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize WebSocket manager: {:?}", e)));
     }
 
-    // Spawn the randomization task
-    let randomization_state = app_state.clone();
+    // Start periodic update task
+    let update_state = app_state.clone();
     tokio::spawn(async move {
-        randomize_nodes_periodically(randomization_state).await;
+        update_graph_periodically(update_state).await;
     });
 
+    // Start HTTP server
     let port = env::var("PORT").unwrap_or_else(|_| "4000".to_string());
     let bind_address = format!("0.0.0.0:{}", port);
-
     log::info!("Starting HTTP server on {}", bind_address);
 
     HttpServer::new(move || {
diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
index 0f353ee7..951cded4 100755
--- a/src/services/graph_service.rs
+++ b/src/services/graph_service.rs
@@ -1,7 +1,4 @@
 use std::collections::{HashMap, HashSet};
-use std::fs;
-use std::path::Path;
-use std::io::Error;
 use std::sync::Arc;
 use tokio::sync::RwLock;
 use actix_web::web;
diff --git a/src/services/mod.rs b/src/services/mod.rs
index 2f22218b..c6f777b3 100755
--- a/src/services/mod.rs
+++ b/src/services/mod.rs
@@ -1,13 +1,9 @@
 pub mod file_service;
+pub mod github_service;
 pub mod graph_service;
 pub mod perplexity_service;
 pub mod ragflow_service;
 pub mod speech_service;
-pub mod github_service;
 
-pub use file_service::FileService;
-pub use graph_service::GraphService;
-pub use perplexity_service::PerplexityService;
-pub use ragflow_service::RAGFlowService;
-pub use speech_service::SpeechService;
-pub use github_service::GitHubPRService;
+// Re-export WebSocketSession and related types from handlers
+pub use crate::handlers::{WebSocketSession, WebSocketSessionHandler};
diff --git a/src/utils/gpu_compute.rs b/src/utils/gpu_compute.rs
index b9945ede..f03b97a5 100755
--- a/src/utils/gpu_compute.rs
+++ b/src/utils/gpu_compute.rs
@@ -80,7 +80,7 @@ impl GPUCompute {
     
     /// Creates a new instance of GPUCompute with initialized GPU resources
     pub async fn new(graph: &GraphData) -> Result<Self, Error> {
-        debug!("Initializing GPU compute capabilities");
+        debug!("Initializing GPU compute capabilities with {} nodes", graph.nodes.len());
         
         // Initialize GPU instance with high performance preference
         let instance = wgpu::Instance::new(InstanceDescriptor::default());
@@ -366,7 +366,16 @@ impl GPUCompute {
             ],
         });
 
-        Ok(Self {
+        let num_nodes = graph.nodes.len() as u32;
+        if num_nodes == 0 {
+            return Err(Error::new(
+                std::io::ErrorKind::InvalidInput,
+                "Cannot initialize GPU compute with 0 nodes"
+            ));
+        }
+
+        // Create a mutable instance
+        let mut instance = Self {
             device,
             queue,
             nodes_buffer,
@@ -380,7 +389,7 @@ impl GPUCompute {
             fisheye_bind_group,
             force_pipeline,
             fisheye_pipeline,
-            num_nodes: graph.nodes.len() as u32,
+            num_nodes,  // Initialize with actual node count
             num_edges: graph.edges.len() as u32,
             simulation_params,
             fisheye_params,
@@ -389,7 +398,12 @@ impl GPUCompute {
             position_staging_buffer,
             position_pipeline,
             position_bind_group,
-        })
+        };
+
+        // Initialize with graph data
+        instance.update_graph_data(graph)?;
+
+        Ok(instance)
     }
 
     /// Updates the graph data in GPU buffers
diff --git a/src/utils/websocket_manager.rs b/src/utils/websocket_manager.rs
index 5ec79b56..37376fc3 100755
--- a/src/utils/websocket_manager.rs
+++ b/src/utils/websocket_manager.rs
@@ -122,9 +122,10 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
 
                     ctx.spawn(
                         async move {
-                            let mut gpu = gpu.write().await;
-                            let expected_size = gpu.num_nodes as usize * 24;
-                            
+                            let gpu_read = gpu.read().await;
+                            let expected_size = gpu_read.get_num_nodes() as usize * 24;
+                            drop(gpu_read); // Release the read lock before writing
+
                             if bin_data.len() != expected_size {
                                 error!("Invalid position data length: expected {}, got {}", 
                                     expected_size, bin_data.len());
@@ -140,7 +141,8 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
                                 return;
                             }
 
-                            if let Err(e) = gpu.update_positions(&bin_data).await {
+                            let mut gpu_write = gpu.write().await;
+                            if let Err(e) = gpu_write.update_positions(&bin_data).await {
                                 error!("Failed to update node positions: {}", e);
                                 let error_message = json!({
                                     "type": "error",
