diff --git a/WEBSOCKET_TEST_PLAN.md b/WEBSOCKET_TEST_PLAN.md
deleted file mode 100644
index 6d606443..00000000
--- a/WEBSOCKET_TEST_PLAN.md
+++ /dev/null
@@ -1,188 +0,0 @@
-# WebSocket Direct Connection Test Plan
-
-## Current Setup
-The current architecture uses nginx to handle WebSocket connections with these features:
-```nginx
-location /wss {
-    proxy_pass http://backend;
-    proxy_http_version 1.1;
-    proxy_set_header Upgrade $http_upgrade;
-    proxy_set_header Connection "upgrade";
-    proxy_set_header Host $host;
-    proxy_set_header X-Real-IP $remote_addr;
-    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-    proxy_set_header X-Forwarded-Proto $scheme;
-    proxy_set_header X-Forwarded-Host $host;
-    
-    proxy_read_timeout 3600s;
-    proxy_send_timeout 3600s;
-    proxy_connect_timeout 30s;
-}
-```
-
-## Hypothesis
-Nginx might be unnecessary because:
-1. Cloudflared already handles:
-   - WebSocket protocol upgrades
-   - Connection timeouts
-   - Keep-alive settings
-2. Docker internal networking provides:
-   - Direct container-to-container communication
-   - Network isolation
-   - Name resolution
-
-## Test Steps
-
-### 1. Configuration Changes
-1. Remove nginx container entirely
-2. Update cloudflared config to point directly to webxr:3000:
-```yaml
-ingress:
-  - hostname: www.visionflow.info
-    service: http://logseq-xr-webxr:3000  # Changed from 4000
-    originRequest:
-      noTLSVerify: true
-      connectTimeout: 30s
-      tcpKeepAlive: 30s
-      keepAliveTimeout: 2m
-      keepAliveConnections: 100
-      httpHostHeader: www.visionflow.info
-      idleTimeout: 3600s
-      streamTimeout: 3600s
-```
-
-3. Update docker-compose.yml:
-   - Remove nginx service
-   - Update webxr port mapping if needed
-   - Keep docker_ragflow network unchanged
-
-### 2. Test Cases
-
-#### A. Basic Connectivity
-1. Access https://www.visionflow.info
-2. Verify initial page load
-3. Check browser console for connection errors
-
-#### B. WebSocket Specific
-1. Monitor WebSocket connection status
-2. Verify WebSocket upgrade headers in browser network tab
-3. Test real-time updates and data streaming
-4. Check if multiple WebSocket connections work correctly
-
-#### C. Connection Management
-1. Test connection stability over time
-2. Verify timeout handling
-3. Check reconnection behavior
-4. Monitor memory usage without nginx buffer
-
-#### D. Multiple Clients
-1. Connect multiple browsers simultaneously
-2. Verify each maintains separate WebSocket connection
-3. Test concurrent data streaming
-4. Check for any connection conflicts
-
-### 3. Monitoring Points
-
-1. Client Side:
-   - Browser WebSocket connection status
-   - Network tab timing and headers
-   - Console errors or warnings
-   - Performance metrics
-
-2. Server Side:
-   - webxr container logs
-   - cloudflared tunnel logs
-   - Connection counts
-   - Memory usage
-
-### 4. Success Criteria
-
-1. Must Have:
-   - Successful WebSocket connections
-   - Stable real-time updates
-   - No connection drops
-   - Proper error handling
-
-2. Should Have:
-   - Similar or better performance than with nginx
-   - Clean connection termination
-   - Proper client IP handling
-   - Multiple client support
-
-### 5. Rollback Plan
-
-If issues occur:
-1. Keep original nginx.conf
-2. Document specific failures
-3. Analyze if issues are related to:
-   - Protocol handling
-   - Header management
-   - Connection multiplexing
-   - Other nginx-specific features
-
-## Potential Concerns
-
-1. WebSocket Protocol:
-   - Does the Rust backend expect specific headers that nginx provides?
-   - Are there any custom headers needed for WebSocket upgrade?
-
-2. Connection Management:
-   - How does the backend handle multiple WebSocket connections?
-   - Is there any connection pooling that nginx provides?
-
-3. Security:
-   - Does nginx provide any critical security headers?
-   - Are there any rate limiting features we need?
-
-4. Routing:
-   - How does the backend distinguish between WebSocket and HTTP traffic?
-   - Are there any path-specific handlers that nginx manages?
-
-## Next Steps
-
-1. Implementation:
-   - Create backup of current configuration
-   - Make changes in staging environment first
-   - Test thoroughly before production
-
-2. Monitoring:
-   - Set up enhanced logging
-   - Monitor connection patterns
-   - Track performance metrics
-
-3. Documentation:
-   - Update network documentation
-   - Document any issues found
-   - Create troubleshooting guide
-
-This test plan will help verify if nginx is truly surplus to requirements while ensuring we understand any potential impacts of its removal.
-2. Connection Management:
-   - How does the backend handle multiple WebSocket connections?
-   - Is there any connection pooling that nginx provides?
-
-3. Security:
-   - Does nginx provide any critical security headers?
-   - Are there any rate limiting features we need?
-
-4. Routing:
-   - How does the backend distinguish between WebSocket and HTTP traffic?
-   - Are there any path-specific handlers that nginx manages?
-
-## Next Steps
-
-1. Implementation:
-   - Create backup of current configuration
-   - Make changes in staging environment first
-   - Test thoroughly before production
-
-2. Monitoring:
-   - Set up enhanced logging
-   - Monitor connection patterns
-   - Track performance metrics
-
-3. Documentation:
-   - Update network documentation
-   - Document any issues found
-   - Create troubleshooting guide
-
-This test plan will help verify if nginx is truly surplus to requirements while ensuring we understand any potential impacts of its removal.
diff --git a/client/core/types.ts b/client/core/types.ts
index 25a86193..0f18cb12 100644
--- a/client/core/types.ts
+++ b/client/core/types.ts
@@ -189,6 +189,7 @@ export type MessageType =
   | 'requestInitialData'
   | 'binaryPositionUpdate'
   | 'settingsUpdated'
+  | 'updateSettings'
   | 'enableBinaryUpdates'
   | 'ping'
   | 'pong';
@@ -249,6 +250,13 @@ export interface SettingsUpdateMessage {
   };
 }
 
+export interface UpdateSettingsMessage {
+  type: 'updateSettings';
+  data: {
+    settings: Partial<VisualizationSettings>;
+  };
+}
+
 export interface PingMessage {
   type: 'ping';
 }
@@ -262,6 +270,7 @@ export type RawWebSocketMessage =
   | RawInitialDataMessage
   | RawBinaryPositionUpdateMessage
   | SettingsUpdateMessage
+  | UpdateSettingsMessage
   | RequestInitialDataMessage
   | EnableBinaryUpdatesMessage
   | PingMessage
@@ -271,6 +280,7 @@ export type WebSocketMessage =
   | InitialDataMessage
   | BinaryPositionUpdateMessage
   | SettingsUpdateMessage
+  | UpdateSettingsMessage
   | RequestInitialDataMessage
   | EnableBinaryUpdatesMessage
   | PingMessage
diff --git a/client/rendering/nodes.ts b/client/rendering/nodes.ts
index 64b43975..13ec778c 100644
--- a/client/rendering/nodes.ts
+++ b/client/rendering/nodes.ts
@@ -12,6 +12,7 @@ const logger = createLogger('NodeManager');
 
 // Constants for geometry
 const NODE_SIZE = 2.5;
+const NODE_VISUAL_OFFSET = 1.0; // Reduced from NODE_SIZE to account for visual appearance
 const NODE_SEGMENTS = 16;
 const EDGE_RADIUS = 0.25;
 const EDGE_SEGMENTS = 8;
@@ -281,7 +282,8 @@ export class NodeManager {
       quaternion.setFromAxisAngle(tempVector, angle);
     }
 
-    scale.set(1, Math.max(0.001, length - (NODE_SIZE * 2)), 1);
+    // Use NODE_VISUAL_OFFSET instead of NODE_SIZE for more accurate edge length
+    scale.set(1, Math.max(0.001, length - (NODE_VISUAL_OFFSET * 2)), 1);
 
     matrix.compose(position, quaternion, scale);
     this.edgeInstances.setMatrixAt(index, matrix);
@@ -318,6 +320,10 @@ export class NodeManager {
   }
 
   private processNodeChunk(floatArray: Float32Array, startIndex: number, endIndex: number): void {
+    // Reset quaternion and scale for each chunk to ensure clean transforms
+    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0); // Identity quaternion using axis-angle
+    scale.set(1, 1, 1);         // Unit scale
+
     for (let i = startIndex; i < endIndex; i++) {
       const baseIndex = VERSION_OFFSET + (i * FLOATS_PER_NODE);
       
@@ -328,9 +334,10 @@ export class NodeManager {
         floatArray[baseIndex + 2]
       );
 
-      // Update instance matrix
-      matrix.compose(position, quaternion, scale);
-      this.nodeInstances.setMatrixAt(i, matrix);
+      // Create a new matrix for this instance to avoid transformation bleeding
+      const instanceMatrix = new THREE.Matrix4();
+      instanceMatrix.compose(position, quaternion, scale);
+      this.nodeInstances.setMatrixAt(i, instanceMatrix);
 
       // Update node data
       const node = this.currentNodes[i];
diff --git a/client/state/settings.ts b/client/state/settings.ts
index 169de700..0f3f4beb 100644
--- a/client/state/settings.ts
+++ b/client/state/settings.ts
@@ -3,73 +3,64 @@
  */
 
 import { VisualizationSettings } from '../core/types';
-import { DEFAULT_VISUALIZATION_SETTINGS, IS_PRODUCTION } from '../core/constants';
+import { DEFAULT_VISUALIZATION_SETTINGS } from '../core/constants';
 import { createLogger } from '../core/utils';
+import { WebSocketService } from '../websocket/websocketService';
 
 const logger = createLogger('SettingsManager');
 
-// Settings endpoint
-const SETTINGS_URL = IS_PRODUCTION
-  ? 'https://www.visionflow.info/settings'
-  : 'http://localhost:4000/settings';
-
 export class SettingsManager {
   private static instance: SettingsManager;
   private settings: VisualizationSettings;
   private settingsListeners: Set<(settings: VisualizationSettings) => void>;
+  private webSocket: WebSocketService;
 
-  private constructor() {
+  private constructor(webSocket: WebSocketService) {
     this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
     this.settingsListeners = new Set();
+    this.webSocket = webSocket;
+
+    // Listen for settings updates from server
+    this.webSocket.on('settingsUpdated', (data) => {
+      if (data && data.settings) {
+        this.settings = data.settings;
+        this.notifyListeners();
+      }
+    });
+
     logger.log('Initialized with default settings');
   }
 
-  static getInstance(): SettingsManager {
+  static getInstance(webSocket: WebSocketService): SettingsManager {
     if (!SettingsManager.instance) {
-      SettingsManager.instance = new SettingsManager();
+      SettingsManager.instance = new SettingsManager(webSocket);
     }
     return SettingsManager.instance;
   }
 
   /**
-   * Load settings from the server
+   * Load settings from the server via WebSocket
    */
   async loadSettings(): Promise<void> {
-    try {
-      const response = await fetch(SETTINGS_URL);
-      if (!response.ok) {
-        throw new Error(`Failed to load settings: ${response.statusText}`);
-      }
-      const settings = await response.json();
-      this.updateSettings(settings);
-      logger.log('Loaded settings from server');
-    } catch (error) {
-      logger.error('Error loading settings:', error);
-      // Fall back to default settings
-      this.updateSettings(DEFAULT_VISUALIZATION_SETTINGS);
-    }
+    // Settings will be received through the settingsUpdated WebSocket message
+    // No need to explicitly request them as they're sent with initial data
+    logger.log('Settings will be received through WebSocket');
   }
 
   /**
-   * Save current settings to the server
+   * Save current settings to the server via WebSocket
    */
   async saveSettings(): Promise<void> {
     try {
-      const response = await fetch(SETTINGS_URL, {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-        },
-        body: JSON.stringify(this.settings),
+      this.webSocket.send({
+        type: 'updateSettings',
+        data: {
+          settings: this.settings
+        }
       });
-
-      if (!response.ok) {
-        throw new Error(`Failed to save settings: ${response.statusText}`);
-      }
-
-      logger.log('Settings saved successfully');
+      logger.log('Settings update sent through WebSocket');
     } catch (error) {
-      logger.error('Error saving settings:', error);
+      logger.error('Error sending settings update:', error);
       throw error;
     }
   }
@@ -83,9 +74,11 @@ export class SettingsManager {
       ...newSettings
     };
 
-    logger.log('Updated settings');
+    logger.log('Updated settings locally');
+    this.notifyListeners();
+  }
 
-    // Notify all listeners of the settings change
+  private notifyListeners(): void {
     this.settingsListeners.forEach(listener => {
       try {
         listener(this.settings);
@@ -194,4 +187,9 @@ export class SettingsManager {
 }
 
 // Export a singleton instance
-export const settingsManager = SettingsManager.getInstance();
+// Note: This will be initialized with the WebSocket instance in index.ts
+export let settingsManager: SettingsManager;
+
+export function initializeSettingsManager(webSocket: WebSocketService): void {
+  settingsManager = SettingsManager.getInstance(webSocket);
+}
diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
index 2225c951..ca0c93b1 100644
--- a/client/websocket/websocketService.ts
+++ b/client/websocket/websocketService.ts
@@ -54,7 +54,7 @@ class NetworkDebugPanel {
       max-height: 300px;
       overflow-y: auto;
       z-index: 1000;
-      display: block !important;
+      display: none;
     `;
 
     const title = document.createElement('div');
@@ -117,12 +117,13 @@ export class WebSocketService {
   private errorHandlers: ErrorHandler[] = [];
   private connectionHandlers: ConnectionHandler[] = [];
   private isConnected: boolean = false;
-  private debugPanel: NetworkDebugPanel;
+  private debugPanel: NetworkDebugPanel | null = null;
   private expectedNodeCount: number = 0;
 
   constructor(url: string) {
     this.url = url;
     this.initializeHandlers();
+    // Debug panel is now created but hidden by default
     this.debugPanel = new NetworkDebugPanel();
   }
 
@@ -184,7 +185,9 @@ export class WebSocketService {
     };
 
     this.ws.onmessage = (event) => {
-      this.debugPanel.addMessage('in', event.data);
+      if (this.debugPanel) {
+        this.debugPanel.addMessage('in', event.data);
+      }
       this.handleMessage(event);
     };
   }
@@ -366,7 +369,9 @@ export class WebSocketService {
 
     try {
       const messageStr = JSON.stringify(message);
-      this.debugPanel.addMessage('out', messageStr);
+      if (this.debugPanel) {
+        this.debugPanel.addMessage('out', messageStr);
+      }
       this.ws?.send(messageStr);
     } catch (error) {
       logger.error('Error sending message:', error);
@@ -381,7 +386,9 @@ export class WebSocketService {
     }
 
     try {
-      this.debugPanel.addMessage('out', data);
+      if (this.debugPanel) {
+        this.debugPanel.addMessage('out', data);
+      }
       this.ws?.send(data instanceof Float32Array ? data.buffer : data);
     } catch (error) {
       logger.error('Error sending binary data:', error);
diff --git a/settings.toml b/settings.toml
index 8ffa0416..2a60bd8b 100644
--- a/settings.toml
+++ b/settings.toml
@@ -1,6 +1,6 @@
 # Debug settings
 [server_debug]
-enabled = false                     # Master switch for server debug logging, forces just two nodes
+enabled = true                     # Master switch for server debug logging, forces just two nodes
 enable_websocket_debug = false     # Enable detailed websocket debugging
 enable_data_debug = false          # Enable data exchange debugging
 log_binary_headers = false         # Log binary message headers
diff --git a/todo.md b/todo.md
deleted file mode 100644
index 59f7feaa..00000000
--- a/todo.md
+++ /dev/null
@@ -1,105 +0,0 @@
-todo.text
-Here's a prioritized TODO list for an LLM to address the performance issues, focusing on using the Three.js force-directed graph and optimizing the data flow:
-
-Priority 1: Eliminate Client-Side Force Calculation and Leverage Server Updates
-
-Remove Client-Side Force Simulation:
-
-File: useVisualization.ts, useForceGraph.ts
-
-Task: Delete or comment out all code related to the d3-force-3d library and the simulation object. The client should not be calculating forces.
-
-Reason: The server is already handling force calculations. Duplicating this on the client is redundant and the primary source of performance issues.
-
-Rely on Server-Provided Positions:
-
-File: useVisualization.ts, useForceGraph.ts, stores/binaryUpdate.ts
-
-Task: Refactor useVisualization.ts and useForceGraph.ts to exclusively use the positions received from the server via the binaryUpdateStore. Ensure that updateNodes and updateLinks in useForceGraph.ts are called only when new data arrives from the binaryUpdateStore.
-
-Reason: This offloads the heavy computation to the server and ensures consistent graph layout.
-
-Priority 2: Optimize Rendering and Update Logic
-
-Efficient InstancedMesh Updates:
-
-File: useForceGraph.ts
-
-Task: Rewrite updateNodes and updateLinks to only update the changed instances. Use the changedNodes set from the binaryUpdateStore to determine which instances need their matrix, color, and scale updated. Avoid unnecessary object creation and property updates.
-
-Reason: This drastically reduces the amount of work done in the render loop.
-
-Object Pooling:
-
-File: useForceGraph.ts
-
-Task: Implement object pooling for Vector3, Matrix4, Color, and Quaternion objects. Pre-allocate a small pool of these objects and reuse them within the update loops to avoid continuous allocation and garbage collection.
-
-Reason: Reduces garbage collection overhead and improves performance.
-
-Spatial Grid Optimization:
-
-File: useForceGraph.ts
-
-Task: Refactor the spatial grid to be used solely for frustum culling. Only update the grid when nodes move significantly. Remove the logic that only renders the closest node in a cell. Combine frustum culling with spatial grid culling for maximum efficiency.
-
-Reason: Improves culling efficiency and prevents nodes from disappearing unnecessarily.
-
-Priority 3: Improve Data Handling and Synchronization
-
-Binary Update Validation and Error Handling:
-
-File: stores/binaryUpdate.ts, services/websocketService.ts
-
-Task: Add robust validation to the binary update handling in both the store and the websocket service. Check for buffer size mismatches, invalid position/velocity values, and other potential errors. Implement appropriate error handling and logging.
-
-Reason: Prevents crashes and ensures data integrity.
-
-Client-Server Synchronization for Interactions:
-
-File: components/visualization/GraphSystem.vue, services/websocketService.ts
-
-Task: If you implement client-side interactions (e.g., dragging nodes), ensure that these interactions are correctly synchronized with the server. The client should send position updates for interacted nodes to the server, and the server should acknowledge these updates. Consider a locking mechanism or other synchronization strategy to prevent conflicts between client and server updates.
-
-Reason: Prevents erratic graph behavior and ensures consistency.
-
-Priority 4: Enhance Debug Logging
-
-More Explicit Debug Logging:
-
-Files: Throughout the client-side codebase, especially in performance-critical sections.
-
-Task: Add more specific and targeted console.debug statements to track the execution flow and data transformations. Include timestamps and relevant context information (e.g., node IDs, positions, velocities). Focus on logging key events, data sizes, processing times, and potential errors.
-
-Reason: Makes debugging easier and helps identify the root cause of performance issues. The existing logs are not granular enough to pinpoint the problem areas.
-
-Example of Optimized updateNodes in useForceGraph.ts:
-
-const updateNodes = (camera: Camera) => {
-  const res = resources.value;
-  if (!res) return;
-
-  const changedNodes = binaryUpdateStore.getChangedNodes;
-
-  // Only update changed nodes
-  changedNodes.forEach(index => {
-    const node = nodes.value[index];
-    if (!node || !node.visible) return;
-
-    // ... (get pooled objects: matrix, position, scale)
-
-    // Update instance matrix based on server-provided positions
-    position.set(
-      binaryUpdateStore.positions[index * 3],
-      binaryUpdateStore.positions[index * 3 + 1],
-      binaryUpdateStore.positions[index * 3 + 2]
-    );
-
-    // ... (set matrix, color, scale on InstancedMesh)
-  });
-
-  // ... (update instance counts and needsUpdate flags)
-};
-Use code with caution.
-TypeScript
-This revised approach focuses on efficiency and leverages the server-side force calculations. The client primarily receives and renders data, significantly reducing the computational load and improving performance. The enhanced logging will provide more detailed information for debugging. Remember to test thoroughly after each change to ensure correctness and performance improvements.
\ No newline at end of file
