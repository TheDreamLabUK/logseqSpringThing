diff --git a/.env_template b/.env_template
index 1f9e79aa..077b6c6f 100755
--- a/.env_template
+++ b/.env_template
@@ -3,7 +3,7 @@
 # Server Configuration
 RUST_LOG=info                        # Log level (debug, info, warn, error)
 BIND_ADDRESS=0.0.0.0                 # Server bind address
-DEBUG_MODE=false                     # When true, only processes Debug Test Page.md
+DEBUG_MODE=true                     # When true, only processes Debug Test Page.md
 
 # Cloudflare Tunnel Configuration
 TUNNEL_TOKEN=
@@ -11,53 +11,23 @@ TUNNEL_ID=
 
 # Network Configuration
 DOMAIN=www.visionflow.info          # Production domain
-PORT=3000
-ENABLE_TLS=true
-MIN_TLS_VERSION=TLS1.3
-ENABLE_HTTP2=true
-MAX_REQUEST_SIZE=10485760
-ENABLE_RATE_LIMITING=true
-RATE_LIMIT_REQUESTS=100
-RATE_LIMIT_WINDOW=60
-
-# WebSocket Configuration
-WS_RETRY_ATTEMPTS=3                 # Maximum number of reconnection attempts
-WS_RETRY_DELAY=5000                # Initial retry delay in milliseconds (doubles with each attempt)
-WS_CONNECTION_TIMEOUT=10000        # Connection timeout in milliseconds
-WS_MESSAGE_RATE_LIMIT=60           # Maximum messages per second
-WS_MESSAGE_TIME_WINDOW=1000        # Time window for rate limiting in milliseconds
-WS_MAX_MESSAGE_SIZE=5242880        # Maximum message size in bytes (5MB)
-WS_MAX_QUEUE_SIZE=1000             # Maximum number of queued messages
-
-# Security Configuration
-ENABLE_CORS=false
-ENABLE_CSRF=true
-CSRF_TOKEN_TIMEOUT=3600
-SESSION_TIMEOUT=3600
-COOKIE_SECURE=true
-COOKIE_HTTPONLY=true
-COOKIE_SAMESITE=Strict
-ENABLE_SECURITY_HEADERS=true
-ENABLE_REQUEST_VALIDATION=true
-ENABLE_AUDIT_LOGGING=true
-AUDIT_LOG_PATH=/app/logs/audit.log
 
 # GitHub Configuration
 GITHUB_TOKEN=
-GITHUB_OWNER=jjohare
-GITHUB_REPO=logseq
-GITHUB_PATH=mainKnowledgeGraph/pages
-GITHUB_VERSION=2022-11-28
-GITHUB_RATE_LIMIT=true
+GITHUB_OWNER=
+GITHUB_REPO=
+GITHUB_PATH=/pages
+GITHUB_VERSION=
+GITHUB_RATE_LIMIT=
 
 # RAGFlow Configuration
-RAGFLOW_API_KEY=ragflow-
-RAGFLOW_API_BASE_URL=http://192.168.0.51/v1/
+RAGFLOW_API_KEY=
+RAGFLOW_API_BASE_URL=http://ragflowe-server/v1/
 RAGFLOW_TIMEOUT=30
 RAGFLOW_MAX_RETRIES=3
 
 # Perplexity API Configuration
-PERPLEXITY_API_KEY=pplx-
+PERPLEXITY_API_KEY=
 PERPLEXITY_MODEL=llama-3.1-sonar-small-128k-online
 PERPLEXITY_API_URL=https://api.perplexity.ai/chat/completions
 PERPLEXITY_MAX_TOKENS=4096
@@ -69,94 +39,8 @@ PERPLEXITY_TIMEOUT=30
 PERPLEXITY_RATE_LIMIT=100
 
 # OpenAI Configuration
-OPENAI_API_KEY=sk-proj-
+OPENAI_API_KEY=
 OPENAI_BASE_URL=wss://api.openai.com/v1/realtime
 OPENAI_TIMEOUT=30
 OPENAI_RATE_LIMIT=100
 
-# Default Configuration
-MAX_CONCURRENT_REQUESTS=5
-MAX_RETRIES=3
-RETRY_DELAY=5
-API_CLIENT_TIMEOUT=30
-MAX_PAYLOAD_SIZE=5242880
-ENABLE_REQUEST_LOGGING=false
-LOG_LEVEL=info
-LOG_FORMAT=json
-
-# Visualization Settings - Colors
-NODE_COLOR="0x1A0B31"
-EDGE_COLOR="0xff0000"
-HOLOGRAM_COLOR="0xFFD700"
-NODE_COLOR_NEW="0x00ff88"          # Bright green for very recent files (< 3 days)
-NODE_COLOR_RECENT="0x4444ff"       # Blue for recent files (< 7 days)
-NODE_COLOR_MEDIUM="0xffaa00"       # Orange for medium-age files (< 30 days)
-NODE_COLOR_OLD="0xff4444"          # Red for old files (>= 30 days)
-NODE_COLOR_CORE="0xffa500"         # Orange for core nodes
-NODE_COLOR_SECONDARY="0x00ffff"    # Cyan for secondary nodes
-NODE_COLOR_DEFAULT="0x00ff00"      # Green for default nodes
-
-# Visualization Settings - Physical Dimensions (in meters)
-MIN_NODE_SIZE=0.1                  # 10cm minimum node size
-MAX_NODE_SIZE=0.3                  # 30cm maximum node size
-HOLOGRAM_SCALE=5.0
-HOLOGRAM_OPACITY=0.1
-EDGE_OPACITY=0.3
-
-# Visualization Settings - Labels
-LABEL_FONT_SIZE=36
-LABEL_FONT_FAMILY="Arial"
-LABEL_PADDING=20
-LABEL_VERTICAL_OFFSET=2.0
-LABEL_CLOSE_OFFSET=0.2
-LABEL_BACKGROUND_COLOR="rgba(0, 0, 0, 0.8)"
-LABEL_TEXT_COLOR="white"
-LABEL_INFO_TEXT_COLOR="lightgray"
-LABEL_XR_FONT_SIZE=24
-
-# Visualization Settings - Geometry
-GEOMETRY_MIN_SEGMENTS=16
-GEOMETRY_MAX_SEGMENTS=32
-GEOMETRY_SEGMENT_PER_HYPERLINK=0.5
-
-# Visualization Settings - Material
-NODE_MATERIAL_METALNESS=0.2
-NODE_MATERIAL_ROUGHNESS=0.2
-NODE_MATERIAL_CLEARCOAT=0.3
-NODE_MATERIAL_CLEARCOAT_ROUGHNESS=0.2
-NODE_MATERIAL_OPACITY=0.9
-NODE_EMISSIVE_MIN_INTENSITY=0.3
-NODE_EMISSIVE_MAX_INTENSITY=1.0
-
-# Visualization Settings - Interaction
-CLICK_EMISSIVE_BOOST=2.0
-CLICK_FEEDBACK_DURATION=200        # milliseconds
-
-# Visualization Settings - Environment
-FOG_DENSITY=0.002
-
-# Physics Simulation Parameters
-FORCE_DIRECTED_ITERATIONS=250
-FORCE_DIRECTED_SPRING=0.01         # Spring force (0.001-1.0)
-FORCE_DIRECTED_REPULSION=1000.0    # Required for backend compatibility
-FORCE_DIRECTED_ATTRACTION=0.01
-FORCE_DIRECTED_DAMPING=0.8         # Damping (0.5-0.95)
-
-# Bloom Settings
-NODE_BLOOM_STRENGTH=0.1
-NODE_BLOOM_RADIUS=0.1
-NODE_BLOOM_THRESHOLD=0.0
-EDGE_BLOOM_STRENGTH=0.2
-EDGE_BLOOM_RADIUS=0.3
-EDGE_BLOOM_THRESHOLD=0.0
-ENVIRONMENT_BLOOM_STRENGTH=0.5
-ENVIRONMENT_BLOOM_RADIUS=0.1
-ENVIRONMENT_BLOOM_THRESHOLD=0.0
-
-# Fisheye Settings
-FISHEYE_ENABLED=false
-FISHEYE_STRENGTH=0.5
-FISHEYE_RADIUS=100.0
-FISHEYE_FOCUS_X=0.0
-FISHEYE_FOCUS_Y=0.0
-FISHEYE_FOCUS_Z=0.0
diff --git a/client/core/types.ts b/client/core/types.ts
index 86ecd1e6..896e4ecf 100644
--- a/client/core/types.ts
+++ b/client/core/types.ts
@@ -1,99 +1,86 @@
-/**
- * Core types for graph visualization
- */
+// Core types for the application
 
-// Base types
 export interface Vector3 {
   x: number;
   y: number;
   z: number;
 }
 
-// Binary protocol types
-export interface BinaryHeader {
-  version: number;
-  nodeCount: number;
-}
-
-export interface BinaryNodeData {
-  position: Float32Array; // x, y, z
-  velocity: Float32Array; // vx, vy, vz
-}
-
-// Raw types (matching server format)
-export interface RawNodeData {
-  position: [number, number, number];
-  velocity: [number, number, number];
-  mass: number;
-  flags: number;
-}
-
-export interface RawNode {
-  id: string;
-  label: string;
-  data: RawNodeData;
-  metadata?: Record<string, string>;
-  nodeType?: string;
-  size?: number;
-  color?: string;
-  weight?: number;
-  group?: string;
-  userData?: Record<string, string>;
-}
-
-export interface RawGraphData {
-  nodes: RawNode[];
-  edges: Edge[];
-  metadata?: Record<string, any>;
-}
-
-// Transformed types (used in client)
 export interface NodeData {
   position: Vector3;
   velocity: Vector3;
-  mass: number;
-  flags: number;
 }
 
 export interface Node {
   id: string;
-  label: string;
   data: NodeData;
-  metadata?: Record<string, string>;
-  nodeType?: string;
-  size?: number;
   color?: string;
+  metadata?: any;
+}
+
+export interface Edge {
+  source: string;
+  target: string;
   weight?: number;
-  group?: string;
-  userData?: Record<string, string>;
 }
 
 export interface GraphData {
   nodes: Node[];
   edges: Edge[];
-  metadata?: Record<string, any>;
+  metadata?: any;
 }
 
-// Performance types
-export interface UpdateBatch {
-  timestamp: number;
-  updates: Float32Array;
-}
-
-export interface EdgeUpdateBatch {
-  edgeIndices: Set<number>;
-  timestamp: number;
-}
-
-// Shared types
-export interface Edge {
-  source: string;
-  target: string;
-  weight: number;
-  edgeType?: string;
-  metadata?: Record<string, string>;
-}
+// Platform types
+export type Platform = 'desktop' | 'quest' | 'browser';
 
+export interface PlatformCapabilities {
+  xrSupported: boolean;
+  webglSupported: boolean;
+  websocketSupported: boolean;
+  webxr: boolean;
+  handTracking: boolean;
+  planeDetection: boolean;
+}
+
+// Integration Settings Types
+export interface GithubSettings {
+  basePath: string;
+  owner: string;
+  rateLimitEnabled: boolean;
+  repo: string;
+  token: string;
+}
+
+export interface OpenAISettings {
+  apiKey: string;
+  baseUrl: string;
+  model: string;
+  rateLimit: number;
+  timeout: number;
+}
+
+export interface PerplexitySettings {
+  apiKey: string;
+  apiUrl: string;
+  frequencyPenalty: number;
+  maxTokens: number;
+  model: string;
+  presencePenalty: number;
+  prompt: string;
+  rateLimit: number;
+  temperature: number;
+  timeout: number;
+  topP: number;
+}
+
+export interface RagFlowSettings {
+  apiKey: string;
+  baseUrl: string;
+  maxRetries: number;
+  timeout: number;
+}
+
+// Client-side visualization settings
 export interface VisualizationSettings {
   // Node appearance
   nodeSize: number;
@@ -102,18 +89,51 @@ export interface VisualizationSettings {
   metalness: number;
   roughness: number;
   clearcoat: number;
+  enableInstancing: boolean;
+  materialType: string;
+  sizeRange: [number, number];
+  sizeByConnections: boolean;
+  highlightColor: string;
+  highlightDuration: number;
+  enableHoverEffect: boolean;
+  hoverScale: number;
 
   // Edge appearance
   edgeWidth: number;
   edgeColor: string;
   edgeOpacity: number;
+  edgeWidthRange: [number, number];
   enableArrows: boolean;
   arrowSize: number;
 
+  // Physics settings
+  physicsEnabled: boolean;
+  attractionStrength: number;
+  repulsionStrength: number;
+  springStrength: number;
+  damping: number;
+  maxVelocity: number;
+  collisionRadius: number;
+  boundsSize: number;
+  enableBounds: boolean;
+  iterations: number;
+
+  // Lighting and environment
+  ambientLightIntensity: number;
+  directionalLightIntensity: number;
+  environmentIntensity: number;
+  enableAmbientOcclusion: boolean;
+  enableAntialiasing: boolean;
+  enableShadows: boolean;
+  backgroundColor: string;
+
   // Visual effects
   enableBloom: boolean;
   bloomIntensity: number;
   bloomRadius: number;
+  nodeBloomStrength: number;
+  edgeBloomStrength: number;
+  environmentBloomStrength: number;
   enableNodeAnimations: boolean;
   enableMotionBlur: boolean;
   motionBlurStrength: number;
@@ -126,16 +146,13 @@ export interface VisualizationSettings {
   // Performance
   maxFps: number;
 
-  // AR Settings (Meta Quest 3)
-  // Scene Understanding
+  // AR Settings
   enablePlaneDetection: boolean;
   enableSceneUnderstanding: boolean;
   showPlaneOverlay: boolean;
   planeOpacity: number;
   planeColor: string;
   enableLightEstimation: boolean;
-  
-  // Hand Tracking
   enableHandTracking: boolean;
   handMeshEnabled: boolean;
   handMeshColor: string;
@@ -144,22 +161,14 @@ export interface VisualizationSettings {
   handRayColor: string;
   handRayWidth: number;
   handPointSize: number;
-  
-  // Gesture Controls
   gestureSmoothing: number;
   pinchThreshold: number;
   dragThreshold: number;
   rotationThreshold: number;
-  
-  // Haptics
   enableHaptics: boolean;
   hapticIntensity: number;
-  
-  // Room Scale
   roomScale: boolean;
   snapToFloor: boolean;
-  
-  // Passthrough
   passthroughOpacity: number;
   passthroughBrightness: number;
   passthroughContrast: number;
@@ -169,185 +178,326 @@ export interface VisualizationSettings {
   portalEdgeWidth: number;
 }
 
-export interface BinaryNodeUpdate {
-  nodeId: string;
-  data: NodeData;
-}
-
-export interface BinaryPositionUpdateMessage {
-  type: 'binaryPositionUpdate';
-  data: {
-    nodes: BinaryNodeUpdate[];
+// Server-side settings format
+export interface ServerSettings {
+  animations: {
+    enable_motion_blur: boolean;
+    enable_node_animations: boolean;
+    motion_blur_strength: number;
   };
-}
-
-// Other message types
-export interface RequestInitialDataMessage {
-  type: 'requestInitialData';
-}
-
-export interface EnableBinaryUpdatesMessage {
-  type: 'enableBinaryUpdates';
-}
-
-export interface SettingsUpdateMessage {
-  type: 'settingsUpdated';
-  data: {
-    settings: VisualizationSettings;
+  ar: {
+    drag_threshold: number;
+    enable_hand_tracking: boolean;
+    enable_haptics: boolean;
+    enable_light_estimation: boolean;
+    enable_passthrough_portal: boolean;
+    enable_plane_detection: boolean;
+    enable_scene_understanding: boolean;
+    gesture_smoothing: number;
+    hand_mesh_color: string;
+    hand_mesh_enabled: boolean;
+    hand_mesh_opacity: number;
+    hand_point_size: number;
+    hand_ray_color: string;
+    hand_ray_enabled: boolean;
+    hand_ray_width: number;
+    haptic_intensity: number;
+    passthrough_brightness: number;
+    passthrough_contrast: number;
+    passthrough_opacity: number;
+    pinch_threshold: number;
+    plane_color: string;
+    plane_opacity: number;
+    portal_edge_color: string;
+    portal_edge_width: number;
+    portal_size: number;
+    room_scale: boolean;
+    rotation_threshold: number;
+    show_plane_overlay: boolean;
+    snap_to_floor: boolean;
   };
-}
-
-export interface UpdateSettingsMessage {
-  type: 'updateSettings';
-  data: {
-    settings: Partial<VisualizationSettings>;
+  audio: {
+    enable_ambient_sounds: boolean;
+    enable_interaction_sounds: boolean;
+    enable_spatial_audio: boolean;
+  };
+  bloom: {
+    edge_bloom_strength: number;
+    enabled: boolean;
+    environment_bloom_strength: number;
+    node_bloom_strength: number;
+    radius: number;
+    strength: number;
+  };
+  edges: {
+    arrow_size: number;
+    base_width: number;
+    color: string;
+    enable_arrows: boolean;
+    opacity: number;
+    width_range: [number, number];
+  };
+  labels: {
+    desktop_font_size: number;
+    enable_labels: boolean;
+    text_color: string;
+  };
+  nodes: {
+    base_color: string;
+    base_size: number;
+    clearcoat: number;
+    enable_hover_effect: boolean;
+    enable_instancing: boolean;
+    highlight_color: string;
+    highlight_duration: number;
+    hover_scale: number;
+    material_type: string;
+    metalness: number;
+    opacity: number;
+    roughness: number;
+    size_by_connections: boolean;
+    size_range: [number, number];
+  };
+  physics: {
+    attraction_strength: number;
+    bounds_size: number;
+    collision_radius: number;
+    damping: number;
+    enable_bounds: boolean;
+    enabled: boolean;
+    iterations: number;
+    max_velocity: number;
+    repulsion_strength: number;
+    spring_strength: number;
+  };
+  rendering: {
+    ambient_light_intensity: number;
+    background_color: string;
+    directional_light_intensity: number;
+    enable_ambient_occlusion: boolean;
+    enable_antialiasing: boolean;
+    enable_shadows: boolean;
+    environment_intensity: number;
   };
 }
 
-export interface PingMessage {
-  type: 'ping';
-}
+// Client-side visualization settings (mapped from server settings)
+export interface VisualizationSettings {
+  // Node Appearance
+  nodeSize: number;  // maps from nodes.base_size
+  nodeColor: string;  // maps from nodes.base_color
+  nodeOpacity: number;  // maps from nodes.opacity
+  metalness: number;
+  roughness: number;
+  clearcoat: number;
+  enableInstancing: boolean;  // maps from nodes.enable_instancing
+  materialType: string;  // maps from nodes.material_type
+  sizeRange: [number, number];  // maps from nodes.size_range
+  sizeByConnections: boolean;  // maps from nodes.size_by_connections
+  highlightColor: string;  // maps from nodes.highlight_color
+  highlightDuration: number;  // maps from nodes.highlight_duration
+  enableHoverEffect: boolean;  // maps from nodes.enable_hover_effect
+  hoverScale: number;  // maps from nodes.hover_scale
+
+  // Edge Appearance
+  edgeWidth: number;  // maps from edges.base_width
+  edgeColor: string;  // maps from edges.color
+  edgeOpacity: number;  // maps from edges.opacity
+  edgeWidthRange: [number, number];  // maps from edges.width_range
+  enableArrows: boolean;  // maps from edges.enable_arrows
+  arrowSize: number;  // maps from edges.arrow_size
+
+  // Physics Settings
+  physicsEnabled: boolean;  // maps from physics.enabled
+  attractionStrength: number;  // maps from physics.attraction_strength
+  repulsionStrength: number;  // maps from physics.repulsion_strength
+  springStrength: number;  // maps from physics.spring_strength
+  damping: number;  // maps from physics.damping
+  maxVelocity: number;  // maps from physics.max_velocity
+  collisionRadius: number;  // maps from physics.collision_radius
+  boundsSize: number;  // maps from physics.bounds_size
+  enableBounds: boolean;  // maps from physics.enable_bounds
+  iterations: number;  // maps from physics.iterations
+
+  // Rendering Settings
+  ambientLightIntensity: number;  // maps from rendering.ambient_light_intensity
+  directionalLightIntensity: number;  // maps from rendering.directional_light_intensity
+  environmentIntensity: number;  // maps from rendering.environment_intensity
+  enableAmbientOcclusion: boolean;  // maps from rendering.enable_ambient_occlusion
+  enableAntialiasing: boolean;  // maps from rendering.enable_antialiasing
+  enableShadows: boolean;  // maps from rendering.enable_shadows
+  backgroundColor: string;  // maps from rendering.background_color
+
+  // Visual Effects
+  enableBloom: boolean;  // maps from bloom.enabled
+  bloomIntensity: number;  // maps from bloom.strength
+  bloomRadius: number;  // maps from bloom.radius
+  nodeBloomStrength: number;  // maps from bloom.node_bloom_strength
+  edgeBloomStrength: number;  // maps from bloom.edge_bloom_strength
+  environmentBloomStrength: number;  // maps from bloom.environment_bloom_strength
+  enableNodeAnimations: boolean;  // maps from animations.enable_node_animations
+  enableMotionBlur: boolean;  // maps from animations.enable_motion_blur
+  motionBlurStrength: number;  // maps from animations.motion_blur_strength
 
-export interface PongMessage {
-  type: 'pong';
+  // Labels
+  showLabels: boolean;  // maps from labels.enable_labels
+  labelSize: number;  // maps from labels.desktop_font_size / 48
+  labelColor: string;  // maps from labels.text_color
+
+  // AR Settings
+  enablePlaneDetection: boolean;  // maps from ar.enable_plane_detection
+  enableSceneUnderstanding: boolean;  // maps from ar.enable_scene_understanding
+  showPlaneOverlay: boolean;  // maps from ar.show_plane_overlay
+  planeOpacity: number;  // maps from ar.plane_opacity
+  planeColor: string;  // maps from ar.plane_color
+  enableLightEstimation: boolean;  // maps from ar.enable_light_estimation
+  enableHandTracking: boolean;  // maps from ar.enable_hand_tracking
+  handMeshEnabled: boolean;  // maps from ar.hand_mesh_enabled
+  handMeshColor: string;  // maps from ar.hand_mesh_color
+  handMeshOpacity: number;  // maps from ar.hand_mesh_opacity
+  handRayEnabled: boolean;  // maps from ar.hand_ray_enabled
+  handRayColor: string;  // maps from ar.hand_ray_color
+  handRayWidth: number;  // maps from ar.hand_ray_width
+  handPointSize: number;  // maps from ar.hand_point_size
+  gestureSmoothing: number;  // maps from ar.gesture_smoothing
+  pinchThreshold: number;  // maps from ar.pinch_threshold
+  dragThreshold: number;  // maps from ar.drag_threshold
+  rotationThreshold: number;  // maps from ar.rotation_threshold
+  enableHaptics: boolean;  // maps from ar.enable_haptics
+  hapticIntensity: number;  // maps from ar.haptic_intensity
+  roomScale: boolean;  // maps from ar.room_scale
+  snapToFloor: boolean;  // maps from ar.snap_to_floor
+  passthroughOpacity: number;  // maps from ar.passthrough_opacity
+  passthroughBrightness: number;  // maps from ar.passthrough_brightness
+  passthroughContrast: number;  // maps from ar.passthrough_contrast
+  enablePassthroughPortal: boolean;  // maps from ar.enable_passthrough_portal
+  portalSize: number;  // maps from ar.portal_size
+  portalEdgeColor: string;  // maps from ar.portal_edge_color
+  portalEdgeWidth: number;  // maps from ar.portal_edge_width
 }
 
-// Union types for messages
-export type RawWebSocketMessage =
-  | RawInitialDataMessage
-  | RawBinaryPositionUpdateMessage
-  | SettingsUpdateMessage
-  | UpdateSettingsMessage
-  | RequestInitialDataMessage
-  | EnableBinaryUpdatesMessage
-  | PingMessage
-  | PongMessage;
-
-export type WebSocketMessage =
-  | InitialDataMessage
-  | BinaryPositionUpdateMessage
-  | SettingsUpdateMessage
-  | UpdateSettingsMessage
-  | RequestInitialDataMessage
-  | EnableBinaryUpdatesMessage
-  | PingMessage
-  | PongMessage;
-
-// Platform detection types
-export type Platform = 'browser' | 'quest';
+// WebSocket message types
+export type MessageType = 
+  | 'initialData'
+  | 'graphUpdate'
+  | 'positionUpdate'
+  | 'binaryPositionUpdate'
+  | 'updateSettings'
+  | 'settingsUpdated'
+  | 'requestInitialData'
+  | 'enableBinaryUpdates'
+  | 'connect'
+  | 'disconnect'
+  | 'ping'
+  | 'pong';
 
-export interface PlatformCapabilities {
-  xrSupported: boolean;
-  webglSupported: boolean;
-  websocketSupported: boolean;
+export type BinaryNodeUpdate = {
+  nodeId: string;
+  data: NodeData;
+};
+
+// Base message types
+export interface WebSocketMessage {
+  type: MessageType;
+  data?: any;
 }
 
-// Message queue types
-export interface QueuedMessage {
-  data: ArrayBuffer;
-  timestamp: number;
+export interface RawWebSocketMessage {
+  type: MessageType;
+  data?: any;
 }
 
-// Debug types
-export interface NetworkDebugMessage {
-  direction: 'in' | 'out';
-  type: 'binary' | 'json';
-  timestamp: number;
-  data: any;
+// Initial data messages
+export interface InitialDataMessage extends WebSocketMessage {
+  type: 'initialData';
+  data: {
+    graph: GraphData;
+  };
 }
 
-// Transform functions
-export function arrayToVector3(arr: [number, number, number]): Vector3 {
-  return { x: arr[0], y: arr[1], z: arr[2] };
+export interface RawInitialDataMessage extends RawWebSocketMessage {
+  type: 'initialData';
+  data: {
+    graph: any;
+  };
 }
 
-export function vector3ToArray(vec: Vector3): [number, number, number] {
-  return [vec.x, vec.y, vec.z];
+// Binary position update messages
+export interface BinaryPositionUpdateMessage extends WebSocketMessage {
+  type: 'binaryPositionUpdate';
+  data: {
+    nodes: BinaryNodeUpdate[];
+  };
 }
 
-export function float32ArrayToVector3(arr: Float32Array, offset: number = 0): Vector3 {
-  return {
-    x: arr[offset],
-    y: arr[offset + 1],
-    z: arr[offset + 2]
+export interface RawBinaryPositionUpdateMessage extends RawWebSocketMessage {
+  type: 'binaryPositionUpdate';
+  data: {
+    nodes: {
+      nodeId: string;
+      data: any;
+    }[];
   };
 }
 
-export function vector3ToFloat32Array(vec: Vector3, arr: Float32Array, offset: number = 0): void {
-  arr[offset] = vec.x;
-  arr[offset + 1] = vec.y;
-  arr[offset + 2] = vec.z;
+// Other message types
+export interface RequestInitialDataMessage extends WebSocketMessage {
+  type: 'requestInitialData';
 }
 
-export function transformNodeData(raw: RawNodeData): NodeData {
-  return {
-    position: arrayToVector3(raw.position),
-    velocity: arrayToVector3(raw.velocity),
-    mass: raw.mass,
-    flags: raw.flags
-  };
+export interface EnableBinaryUpdatesMessage extends WebSocketMessage {
+  type: 'enableBinaryUpdates';
 }
 
-export function transformNode(raw: RawNode): Node {
-  return {
-    ...raw,
-    data: transformNodeData(raw.data)
-  };
+export interface PingMessage extends WebSocketMessage {
+  type: 'ping';
 }
 
-export function transformGraphData(raw: RawGraphData): GraphData {
-  return {
-    nodes: raw.nodes.map(transformNode),
-    edges: raw.edges,
-    metadata: raw.metadata
-  };
+export interface PongMessage extends WebSocketMessage {
+  type: 'pong';
 }
 
-// Binary data validation
-export function validateBinaryHeader(data: ArrayBuffer): BinaryHeader | null {
-  if (data.byteLength < 8) return null; // Minimum size for version and count
-  const view = new Float32Array(data);
-  return {
-    version: view[0],
-    nodeCount: Math.floor((view.length - 1) / 6) // (length - version) / floats per node
+// Settings messages
+export interface UpdateSettingsMessage extends WebSocketMessage {
+  type: 'updateSettings';
+  data: {
+    settings: ServerSettings;
   };
 }
 
-// WebSocket message types
-export type MessageType = 
-  | 'initialData'
-  | 'requestInitialData'
-  | 'binaryPositionUpdate'
-  | 'settingsUpdated'
-  | 'updateSettings'
-  | 'enableBinaryUpdates'
-  | 'ping'
-  | 'pong';
-
-// Raw message types (from server)
-export interface RawInitialDataMessage {
-  type: 'initialData';
+export interface SettingsUpdatedMessage extends WebSocketMessage {
+  type: 'settingsUpdated';
   data: {
-    graph: RawGraphData;
+    settings: ServerSettings;
   };
 }
 
-export interface RawBinaryNodeUpdate {
-  nodeId: string;
-  data: RawNodeData;
+// Logger interface
+export interface Logger {
+  log: (message: string, ...args: any[]) => void;
+  error: (message: string, ...args: any[]) => void;
+  warn: (message: string, ...args: any[]) => void;
+  debug: (message: string, ...args: any[]) => void;
+  info: (message: string, ...args: any[]) => void;
 }
 
-export interface RawBinaryPositionUpdateMessage {
-  type: 'binaryPositionUpdate';
-  data: {
-    nodes: RawBinaryNodeUpdate[];
+// Helper functions
+export function transformGraphData(data: any): GraphData {
+  return {
+    nodes: data.nodes.map((node: any) => transformNodeData(node)),
+    edges: data.edges,
+    metadata: data.metadata
   };
 }
 
-// Transformed message types (for client use)
-export interface InitialDataMessage {
-  type: 'initialData';
-  data: {
-    graph: GraphData;
+export function transformNodeData(node: any): Node {
+  return {
+    id: node.id,
+    data: {
+      position: node.data.position,
+      velocity: node.data.velocity || { x: 0, y: 0, z: 0 }
+    },
+    color: node.color,
+    metadata: node.metadata
   };
 }
diff --git a/client/core/utils.ts b/client/core/utils.ts
index 619084ca..021b4fa3 100644
--- a/client/core/utils.ts
+++ b/client/core/utils.ts
@@ -6,22 +6,23 @@ import { Vector3 } from './types';
 import { THROTTLE_INTERVAL } from './constants';
 
 // Debug logging utility
-export const createLogger = (namespace: string) => {
+export interface Logger {
+  log: (message: string, ...args: any[]) => void;
+  error: (message: string, ...args: any[]) => void;
+  warn: (message: string, ...args: any[]) => void;
+  debug: (message: string, ...args: any[]) => void;
+  info: (message: string, ...args: any[]) => void;
+}
+
+export function createLogger(namespace: string): Logger {
   return {
-    log: (message: string, ...args: any[]) => {
-      console.log(`[${namespace}] ${message}`, ...args);
-    },
-    error: (message: string, ...args: any[]) => {
-      console.error(`[${namespace}] ${message}`, ...args);
-    },
-    warn: (message: string, ...args: any[]) => {
-      console.warn(`[${namespace}] ${message}`, ...args);
-    },
-    debug: (message: string, ...args: any[]) => {
-      console.debug(`[${namespace}] ${message}`, ...args);
-    }
+    log: (message: string, ...args: any[]) => console.log(`[${namespace}] ${message}`, ...args),
+    error: (message: string, ...args: any[]) => console.error(`[${namespace}] ${message}`, ...args),
+    warn: (message: string, ...args: any[]) => console.warn(`[${namespace}] ${message}`, ...args),
+    debug: (message: string, ...args: any[]) => console.debug(`[${namespace}] ${message}`, ...args),
+    info: (message: string, ...args: any[]) => console.info(`[${namespace}] ${message}`, ...args)
   };
-};
+}
 
 // Update throttler for performance optimization
 export class UpdateThrottler {
diff --git a/client/implementationPlan.md b/client/implementationPlan.md
index d17a0d3f..1f9b5b22 100644
--- a/client/implementationPlan.md
+++ b/client/implementationPlan.md
@@ -1,310 +1,122 @@
 # Implementation Plan
 
-You can find our old implmentation in /featureclient but it was over complex and didn't work. We are working through creating files in /client in order to completely replace the project client. You can take a look at /featureclient/structure.md if you get stuck, letting it guide you into the old codebase for clues on our original intent. 
-
-This new implmentation should be best in class "mixed reality first" app structure, leaning heavily into the meta quest 3. I think vue has been causing us problems so we should try to get back to simple ts. The desktop interface is still important. We need a way to change all those visualisation settings which were in the vue panel and still exist in settings.toml, using a save settings button to write back to settings.toml on the server. This will allow us also to clean up the meta quest AR interface, removing any control panel from that side. 
-
-When you are confident that you have written a file into this new empty /client directory structure you can mark it with a tick here in the implmentationplan.md file, and move onto the next one.
-
-High-Level Goals
-Mixed Reality First, Desktop Second:
-Develop a "mixed reality first" architecture that provides an optimal experience on the Meta Quest 3. Desktop remains fully functional and provides additional UI for managing settings. Both share a unified codebase as much as possible.
-
-Clean, Modern Architecture:
-Use TypeScript, Three.js, and other best-practice libraries as needed (e.g., state management, lightweight UI libraries). No Vue.js. A simple TypeScript-based approach to UI and state management will replace the old Vue-based panel.
-
-Unified Settings Management:
-Settings are stored on the server in settings.toml. The desktop interface allows users to adjust these settings and save them back to the server. The Quest version reads and applies these same settings. Avoid duplication by using a unified data model and minimal branching logic.
-
-Vector3 Standardization:
-Migrate all position/velocity data to a Vector3 (or equivalent [f32; 3] arrays in Rust) representation. Streamline GPU and WebSocket protocols to match this format once and eliminate conversion overhead. All binary data is now handled through Float32Arrays with proper type safety and validation.
-
-Sensible Data Flows and Networking:
-Rely on a stable WebSocket channel for real-time updates. Desktop and Quest clients share the same binary and JSON protocols. Nginx, Cloudflare tunnels, and Docker networks remain as currently configured, but we keep the plan free of redundant details.
-
-Architecture Overview
+This new implementation should be best in class "mixed reality first" app structure, leaning heavily into the meta quest 3. The desktop interface remains important for managing settings through a clean TypeScript-based UI, while keeping the Meta Quest AR interface focused and uncluttered.
+
+High-Level Goals:
+
+Mixed Reality First, Desktop Second: ✓
+- Optimal Meta Quest 3 experience
+- Clean AR interface without control panels
+- Desktop UI for settings management
+- Unified codebase
+
+Clean, Modern Architecture: ✓
+- Pure TypeScript implementation
+- Three.js for rendering
+- No Vue.js dependencies
+- Simple, efficient state management
+
+Unified Settings Management: ✓
+Settings are stored on the server in settings.toml. The desktop interface allows users to adjust these settings and save them back to the server. The Quest version reads and applies these same settings.
+- ✓ Core settings types and interfaces
+- ✓ Settings state management
+- ✓ REST endpoints for settings (GET/PUT)
+- ✓ Settings integration with rendering
+- ✓ Desktop settings panel UI
+- ✓ Settings persistence and save functionality
+
+Architecture Overview:
 ```
 client/
   ├─ core/              # Core types, constants, utilities ✓
+  │  ├─ types.ts        # Core interfaces and types ✓
+  │  ├─ constants.ts    # Shared constants ✓
+  │  └─ utils.ts        # Helper functions ✓
+  │
   ├─ state/             # Centralized state (settings, graph data) ✓
+  │  ├─ settings.ts     # Settings management ✓
+  │  └─ graphData.ts    # Graph data management ✓
+  │
   ├─ rendering/         # Three.js scene, nodes/edges, text rendering ✓
+  │  ├─ scene.ts        # Scene management ✓
+  │  ├─ nodes.ts        # Node and edge rendering ✓
+  │  └─ textRenderer.ts # Text label rendering ✓
+  │
   ├─ xr/                # XR integration (Quest 3 focus, extends scene) ✓
+  │  ├─ xrSessionManager.ts  # XR session handling ✓
+  │  └─ xrInteraction.ts     # XR input and interaction ✓
+  │
   ├─ platform/          # Platform abstraction (detect Quest vs Desktop) ✓
+  │  └─ platformManager.ts    # Platform detection and capabilities ✓
+  │
   ├─ websocket/         # WebSocket service and message handling ✓
+  │  └─ websocketService.ts   # Real-time communication ✓
+  │
   ├─ types/             # TypeScript declarations for Three.js and WebXR ✓
-  ├─ ui/                # Minimal UI components (desktop settings panel)
+  │  ├─ three.d.ts      # Three.js type definitions ✓
+  │  └─ webxr.d.ts      # WebXR type definitions ✓
+  │
+  ├─ ui/                # Minimal UI components (desktop settings panel) ✓
+  │  ├─ ControlPanel.ts     # Settings panel UI ✓
+  │  └─ ControlPanel.css    # Settings panel styles ✓
+  │
   └─ main.ts            # Application entry point (initializes everything) ✓
 ```
 
-Key Principles:
-
-Unified Code Paths:
-Keep the code paths for desktop and XR similar, differing mainly in input and UI layers. For example, both platforms use the same SceneManager and GraphDataManager, but desktop also spins up a settings panel, while XR relies on in-world interactions or no panel at all.
-
-Minimal Frameworks:
-Vanilla TS, Three.js, and potentially a small state or UI library (e.g., Zustand or a lightweight reactive store) to handle global state and reduce complexity.
-
-No Vue.js:
-The old Vue-based panel is replaced with a simple HTML/TS UI component for the desktop. This UI retrieves and updates settings.toml via API calls.
-
-Core Components
-1. Core (types, constants, utils) ✓
-types.ts: ✓
-Define Node, Edge, GraphData, VisualizationSettings, and other core interfaces. Make sure these interfaces align with the server's Vector3-based data model.
-For positions/velocities, use a simple [number, number, number] tuple or a small Vector3 class to unify all calculations.
-
-constants.ts: ✓
-Store shared numeric constants (e.g., scales for position/velocity, default node sizes).
-
-utils.ts: ✓
-General-purpose helpers: math functions (e.g., for Vector3 operations), throttlers for update frequency, and simple logging helpers.
-
-2. State Management ✓
-state/settings.ts: ✓
-A state module that manages VisualizationSettings.
-
-On startup, load settings from the server (JSON endpoint converting settings.toml to JSON).
-Provide methods to update local settings and trigger a save operation back to settings.toml.
-Make settings accessible to both rendering and XR modules.
-
-state/graphData.ts: ✓
-A centralized store for the graph's node/edge data.
-
-Handles incoming WebSocket data (initial graph, incremental updates).
-Normalizes data into a Vector3-aligned format.
-Exposes a method for the rendering system to apply node positions efficiently.
-
-3. WebSocket Communication ✓
-websocketService.ts: ✓
-A single WebSocket service that:
-Connects upon startup.
-Receives initial GraphData and subsequent incremental updates (binary for positions, JSON for metadata).
-Dispatches events or uses a callback to graphData.ts to update state directly.
-Is protocol-aligned with the Vector3 standardization (24-byte structures for position updates, etc.).
-
-4. Rendering ✓
-scene.ts: ✓
-Sets up a Three.js scene, camera, lights, and renderer.
-Adapts camera setup if XR is active. Maintains a unified scene whether viewed on desktop or Quest 3.
-Desktop: OrbitControls enabled.
-XR: Controlled via headset/hand-tracking.
-
-nodes.ts: ✓
-Manages instanced meshes for nodes and possibly lines for edges.
-Apply incoming position data directly to instance matrices.
-Update on each tick if data changes.
-Keep logic minimal and rely on graphData.ts for raw data access.
-Implements efficient batched edge updates.
-
-textRenderer.ts: ✓
-Handles text labels using SDF-based text rendering.
-Shared between desktop and XR, but the display may differ (e.g., fewer labels in XR mode to reduce clutter).
-
-5. XR Integration ✓
-xrSessionManager.ts: ✓
-Initializes an XR session on supported devices (Quest 3).
-Adapts the camera and rendering loop to XR.
-Maintains platform-agnostic logic, just triggers XR mode if available.
-Implements spatial awareness features:
-- 10x10 grid helper for orientation
-- Semi-transparent ground plane for depth perception
-- Hit test visualization with ring marker
-- Environment-aware lighting with intensity matching
-- Type-safe feature detection and handling
-
-xrInteraction.ts: ✓
-Handles XR-specific input (hand controllers, gestures).
-Shared logic with desktop interaction where possible—both use raycasting to select nodes, but input events differ.
-Quest 3 might trigger node highlighting or selection differently, but the underlying data handling remains the same.
-Implements efficient hit testing with proper type safety.
-
-6. Platform Abstraction ✓
-platformManager.ts: ✓
-Detects if running on Quest (WebXR capable) or Desktop.
-Hooks into main.ts to decide whether to start an XR session or show a desktop UI panel.
-Keeps platform-conditional logic localized here.
-
-7. UI (Desktop Settings Interface)
-ui/settingsPanel.ts:
-A simple HTML+TS panel for desktop:
-Fetches current settings on load.
-Allows editing (sliders, text inputs) of VisualizationSettings.
-On "Save" click, sends updated settings back to the server, updating settings.toml.
-The Quest interface reads the updated settings but does not offer in-headset controls for them.
-
-8. Application Entry ✓
-main.ts: ✓
-The central entry point that:
-Initializes platformManager to detect platform.
-Initializes websocketService and waits for initial graph data.
-Loads settings from the server and updates SettingsManager.
-Creates the SceneManager and NodeManager, applying settings and initial graph data.
-If desktop, renders the settingsPanel UI.
-If Quest, starts the XR session.
-Enters the render loop.
-
-9. Type System ✓
-types/three.d.ts: ✓
-Comprehensive TypeScript declarations for Three.js.
-Proper type definitions for geometries, materials, and transforms.
-Support for matrix operations and Vector3 calculations.
-
-types/webxr.d.ts: ✓
-Complete WebXR API type declarations.
-Type guards for optional WebXR features.
-Proper handling of hit testing and light estimation.
-
-Vector3 & Protocol Consolidation
-Single Source of Truth:
-All position and velocity data are represented as Vector3-like arrays ([number, number, number]) on the client, and [f32; 3] on the server side. The WebSocket binary protocol uses a 24-byte (6 floats) structure for each position/velocity update. On the GPU side, CUDA kernels and WGSL shaders also align with vec3 data formats, reducing conversions and overhead.
-
-Data Flow: ✓
-
-Server → Client: ✓
-Binary WebSocket frames contain a packed array of float32 triples for position and velocity.
-Client parses these directly into Float32Arrays and updates node instances.
-Implements proper validation and type checking.
-
-GPU Integration: ✓
-The client's GPU compute (if used) and Three.js transforms rely on the same Vector3 format.
-Shaders, if needed, use vec3<f32> with no conversions required.
-
-Result: ✓
-A consistent Vector3-oriented pipeline from server logic to client rendering reduces complexity and improves performance.
-
-Settings Management Flow (Partial)
-Startup: ✓
-Client fetches settings.toml via a server endpoint that returns JSON ✓.
-SettingsManager merges these settings with defaults and applies them to the rendering system ✓.
-
-Desktop Editing:
-The settingsPanel UI lets the user modify visualization settings (e.g., node size, color schemes).
-Clicking "Save" sends a POST request with the updated settings to the server, rewriting settings.toml.
-
-Quest Reading: ✓
-On Quest, no separate panel is displayed. The XR experience uses the settings loaded at startup or after a refresh. Changes made on the desktop propagate automatically at next startup or when re-fetching settings.
-
-Unified Handling: ✓
-The SettingsManager notifies rendering components about any setting changes, ensuring both desktop and XR views stay consistent.
-
-Implementation & Integration Steps
-Phase 1: Skeleton & Basic Connectivity ✓
-Set up main.ts ✓, platformManager.ts ✓, websocketService.ts ✓, SettingsManager ✓, and SceneManager stubs ✓.
-Connect to WebSocket, fetch initial data and settings, log them ✓.
-
-Phase 2: Rendering & Data Flow ✓
-Implement NodeManager and basic Three.js scene ✓.
-Apply binary data updates to node positions, confirm rendering works on desktop ✓.
-Add efficient batched edge updates ✓.
-Add proper type safety for all operations ✓.
-
-Phase 3: Settings Integration (In Progress)
-Implement settingsPanel.ts for desktop.
-Wire up SettingsManager to scene and nodes ✓, confirm changes apply when user saves.
-
-Phase 4: XR Integration ✓
-Implement xrSessionManager.ts ✓ and xrInteraction.ts ✓.
-Add spatial awareness features (grid, ground plane, hit testing) ✓.
-Add environment-aware lighting ✓.
-Add proper type guards and safety ✓.
-Test on Quest 3 to ensure scene and controls work similarly to desktop ✓.
-
-Phase 5: Polish & Optimization ✓
-Optimize performance (instancing, memory usage) ✓.
-Add batched updates and efficient matrix operations ✓.
-Add proper type safety throughout the codebase ✓.
-Ensure stable Vector3-based pipeline and minimal code duplication ✓.
-
-[Rest of Docker & Network Architecture section remains unchanged]
-
-Docker & Network Architecture
-===========================
-
-Container Structure
------------------
-1. Multi-Stage Build:
-- Stage 1: Frontend Build (node:20-slim)
-  * Builds TypeScript/client code using pnpm
-  * Outputs static files to /app/data/public/dist
-
-- Stage 2: Rust Dependencies (nvidia/cuda:12.2.0-devel-ubuntu22.04)
-  * Caches Rust dependencies
-  * Compiles CUDA kernels to PTX
-
-- Stage 3: Rust Application
-  * Builds the main Rust application
-  * Handles WebSocket and HTTP endpoints
-
-- Stage 4: Python Dependencies
-  * Sets up Python environment for TTS
-  * Installs GPU-enabled packages
-
-- Stage 5: Final Runtime (nvidia/cuda:12.2.0-devel-ubuntu22.04)
-  * Combines all built artifacts
-  * Runs nginx and application server
-
-Network Architecture
-------------------
-1. External Access Chain:
-   Client → Cloudflare → cloudflared tunnel → nginx → Rust backend
-
-2. Docker Network (docker_ragflow):
-   * Subnet: 172.19.0.0/16
-   * Container Aliases:
-     - logseq-xr-webxr
-     - webxr-client
-     - cloudflared
-
-3. Port Mapping:
-   * External: 4000
-   * Internal: 3000
-   * WebSocket endpoint: /wss
-
-Security & Performance
---------------------
-1. Container Security:
-   * Read-only filesystem where possible
-   * Explicit capability limitations
-   * No privilege escalation
-   * Regular security audits via launch script
-
-2. Resource Management:
-   * CPU: Limited to 16 cores
-   * Memory: 64GB limit
-   * GPU: Explicit NVIDIA GPU 0 allocation
-   * tmpfs for high-speed temporary storage
-
-3. Health Monitoring:
-   * 30s health check intervals
-   * Automatic container restart
-   * JSON log format with rotation
-   * Resource usage tracking
-
-Deployment Flow
--------------
-1. Launch Process:
-   * Environment validation
-   * Security checks (pnpm, TypeScript, Rust)
-   * Container cleanup
-   * Service startup
-   * Health verification
-   * Cloudflare tunnel establishment
-
-2. Volume Management:
-   * /app/data/markdown: Persistent markdown storage
-   * /app/data/piper: TTS model storage
-   * /app/client: Development mount
-   * /tmp: High-speed tmpfs
-
-3. Configuration:
-   * settings.toml: Main configuration
-   * nginx.conf: Web server setup
-   * config.yml: Cloudflare tunnel config
-   * .env: Environment variables
-
-This architecture ensures:
-- Secure external access via Cloudflare
-- Efficient container-to-container communication
-- GPU acceleration for compute tasks
-- Persistent data storage
-- Development flexibility
+Protocol Separation: ✓
+- Settings Management (REST):
+  * GET /api/visualization/settings for loading
+  * PUT /api/visualization/settings for saving
+  * Clean error handling
+  * Settings persistence to settings.toml
+
+- Graph Data:
+  * Initial load via REST
+  * Real-time updates via WebSocket
+  * Binary format for efficiency
+  * Type-safe data handling
+
+Implementation Status:
+
+1. Core Components: ✓
+- Types and interfaces
+- Constants and utilities
+- Vector3 standardization
+- Error handling
+
+2. State Management: ✓
+- Settings via REST
+- Graph data hybrid approach
+- Clean protocol separation
+- Type-safe operations
+
+3. UI Components: ✓
+- TypeScript-based control panel
+- Modern, responsive design
+- Desktop-only display
+- Clean Meta Quest interface
+
+4. XR Integration: ✓
+- Meta Quest 3 optimized
+- Spatial awareness features
+- Hand tracking and gestures
+- Environment-aware lighting
+
+5. Architecture: ✓
+- Pure TypeScript
+- No Vue.js dependencies
+- Clean protocol separation
+- Efficient data handling
+
+Next Steps:
+1. Testing and validation
+2. Performance optimization
+3. Documentation updates
+4. User feedback integration
+
+The implementation provides:
+- Best-in-class mixed reality experience
+- Clean desktop management interface
+- Efficient data handling
+- Type safety throughout
+- Clear separation of concerns
diff --git a/client/index.html b/client/index.html
index d972fa1d..df06c32e 100644
--- a/client/index.html
+++ b/client/index.html
@@ -4,6 +4,7 @@
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>LogseqXR Graph Visualization</title>
+  <link rel="stylesheet" href="/ui/ControlPanel.css">
   <style>
     * {
       margin: 0;
@@ -25,9 +26,56 @@
       width: 100%;
       height: 100%;
     }
+
+    .loading-overlay {
+      position: fixed;
+      top: 0;
+      left: 0;
+      width: 100%;
+      height: 100%;
+      background: rgba(0, 0, 0, 0.9);
+      display: flex;
+      justify-content: center;
+      align-items: center;
+      z-index: 2000;
+    }
+
+    .loading-overlay .spinner {
+      width: 50px;
+      height: 50px;
+      border: 3px solid rgba(255, 255, 255, 0.1);
+      border-radius: 50%;
+      border-top-color: #4a90e2;
+      animation: spin 1s ease-in-out infinite;
+    }
+
+    @keyframes spin {
+      to { transform: rotate(360deg); }
+    }
+
+    .error-message {
+      position: fixed;
+      top: 20px;
+      right: 20px;
+      background: rgba(255, 59, 48, 0.9);
+      color: white;
+      padding: 12px 20px;
+      border-radius: 6px;
+      font-size: 14px;
+      z-index: 2001;
+      animation: fadeIn 0.3s ease;
+    }
+
+    @keyframes fadeIn {
+      from { opacity: 0; transform: translateY(-10px); }
+      to { opacity: 1; transform: translateY(0); }
+    }
   </style>
 </head>
 <body>
+  <div class="loading-overlay">
+    <div class="spinner"></div>
+  </div>
   <div id="canvas-container">
     <canvas id="main-canvas"></canvas>
   </div>
diff --git a/client/index.ts b/client/index.ts
index c2a81e7f..84de58fe 100644
--- a/client/index.ts
+++ b/client/index.ts
@@ -13,290 +13,246 @@ import { XRSessionManager } from './xr/xrSessionManager';
 import { XRInteraction } from './xr/xrInteraction';
 import { createLogger } from './core/utils';
 import { WS_URL } from './core/constants';
-import { BinaryNodeUpdate } from './core/types';
+import { BinaryPositionUpdateMessage } from './core/types';
 import { ControlPanel } from './ui';
 
 const logger = createLogger('Application');
 
 class Application {
-  private webSocket!: WebSocketService;
-  private sceneManager!: SceneManager;
-  private nodeManager!: NodeManager;
-  private textRenderer!: TextRenderer;
-  private xrManager: XRSessionManager | null = null;
-  private xrInteraction: XRInteraction | null = null;
-
-  constructor() {
-    this.initializeApplication();
-  }
+    private webSocket!: WebSocketService;
+    private sceneManager!: SceneManager;
+    private nodeManager!: NodeManager;
+    private textRenderer!: TextRenderer;
+    private xrManager: XRSessionManager | null = null;
+    private xrInteraction: XRInteraction | null = null;
+
+    constructor() {
+        this.initializeApplication();
+    }
 
-  private async initializeApplication(): Promise<void> {
-    try {
-      // Initialize platform manager
-      await platformManager.initialize();
+    private async initializeApplication(): Promise<void> {
+        try {
+            // Initialize platform manager
+            await platformManager.initialize();
 
-      // Initialize scene first so we can render nodes when data arrives
-      this.initializeScene();
+            // Initialize scene first so we can render nodes when data arrives
+            this.initializeScene();
 
-      // Initialize WebSocket connection and settings
-      this.initializeWebSocket();
+            // Load initial graph data from REST endpoint
+            await graphDataManager.loadGraphData();
+            
+            // Load settings from REST endpoint
+            await settingsManager.loadSettings();
 
-      // Initialize settings after WebSocket is ready
-      await this.initializeSettings();
+            // Initialize WebSocket for real-time updates
+            this.initializeWebSocket();
 
-      // Initialize XR if supported
-      await this.initializeXR();
+            // Initialize XR if supported
+            await this.initializeXR();
 
-      // Initialize UI components
-      new ControlPanel(); // Create the control panel instance
+            // Initialize UI components after settings are loaded
+            new ControlPanel();
 
-      // Setup UI event listeners
-      this.setupUIEventListeners();
+            // Setup UI event listeners
+            this.setupUIEventListeners();
 
-      // Hide loading overlay
-      this.hideLoadingOverlay();
+            // Hide loading overlay
+            this.hideLoadingOverlay();
 
-      logger.log('Application initialized successfully');
-    } catch (error) {
-      logger.error('Failed to initialize application:', error);
-      this.showError('Failed to initialize application');
+            logger.log('Application initialized successfully');
+        } catch (error) {
+            logger.error('Failed to initialize application:', error);
+            this.showError('Failed to initialize application');
+        }
     }
-  }
-
-  private initializeWebSocket(): void {
-    // Create WebSocket service with environment-aware URL
-    this.webSocket = new WebSocketService(WS_URL);
-
-    // Setup WebSocket event handlers
-    this.webSocket.on('initialData', (data) => {
-      logger.log('Received initial graph data:', data);
-      if (data && data.graph) {
-        // Update graph data
-        graphDataManager.updateGraphData(data.graph);
-        this.nodeManager.updateGraph(data.graph.nodes, data.graph.edges);
-      }
-    });
-
-    this.webSocket.on('binaryPositionUpdate', (data) => {
-      if (data && data.nodes) {
-        // Convert nodes data to ArrayBuffer for position updates
-        const buffer = new ArrayBuffer(data.nodes.length * 24); // 6 floats per node
-        const floatArray = new Float32Array(buffer);
-        
-        data.nodes.forEach((node: BinaryNodeUpdate, index: number) => {
-          const baseIndex = index * 6;
-          const pos = node.data.position;
-          const vel = node.data.velocity;
-          
-          // Position
-          floatArray[baseIndex] = pos.x;
-          floatArray[baseIndex + 1] = pos.y;
-          floatArray[baseIndex + 2] = pos.z;
-          // Velocity
-          floatArray[baseIndex + 3] = vel.x;
-          floatArray[baseIndex + 4] = vel.y;
-          floatArray[baseIndex + 5] = vel.z;
+
+    private initializeWebSocket(): void {
+        // Create WebSocket service with environment-aware URL
+        this.webSocket = new WebSocketService(WS_URL);
+
+        // Setup WebSocket event handler for binary position updates
+        this.webSocket.on('binaryPositionUpdate', (data: BinaryPositionUpdateMessage['data']) => {
+            if (data && data.nodes) {
+                // Convert nodes data to ArrayBuffer for position updates
+                const buffer = new ArrayBuffer(data.nodes.length * 24); // 6 floats per node
+                const floatArray = new Float32Array(buffer);
+                
+                data.nodes.forEach((node, index) => {
+                    const baseIndex = index * 6;
+                    const pos = node.data.position;
+                    const vel = node.data.velocity;
+                    
+                    // Position
+                    floatArray[baseIndex] = pos.x;
+                    floatArray[baseIndex + 1] = pos.y;
+                    floatArray[baseIndex + 2] = pos.z;
+                    // Velocity
+                    floatArray[baseIndex + 3] = vel.x;
+                    floatArray[baseIndex + 4] = vel.y;
+                    floatArray[baseIndex + 5] = vel.z;
+                });
+
+                // Update graph data and visual representation
+                graphDataManager.updatePositions(buffer);
+                this.nodeManager.updatePositions(floatArray);
+            }
         });
 
-        // Update graph data and visual representation
-        graphDataManager.updatePositions(buffer);
-        this.nodeManager.updatePositions(floatArray);
-      }
-    });
+        // Connect to server
+        this.webSocket.connect();
+    }
+
+    private initializeScene(): void {
+        // Get canvas element
+        const container = document.getElementById('canvas-container');
+        if (!container) {
+            throw new Error('Canvas container not found');
+        }
+
+        // Create canvas
+        const canvas = document.createElement('canvas');
+        container.appendChild(canvas);
+
+        // Initialize scene manager
+        this.sceneManager = SceneManager.getInstance(canvas);
+
+        // Initialize node manager
+        this.nodeManager = NodeManager.getInstance(this.sceneManager);
+
+        // Initialize text renderer
+        this.textRenderer = TextRenderer.getInstance(
+            this.sceneManager.getScene(),
+            this.sceneManager.getCamera()
+        );
+
+        // Start rendering
+        this.sceneManager.start();
+    }
 
-    // Initialize settings manager with WebSocket
-    settingsManager.initializeWebSocket(this.webSocket);
+    private async initializeXR(): Promise<void> {
+        if (platformManager.getCapabilities().xrSupported) {
+            // Initialize XR manager
+            this.xrManager = XRSessionManager.getInstance(this.sceneManager);
+
+            // Initialize XR interaction
+            if (this.xrManager && this.nodeManager) {
+                this.xrInteraction = XRInteraction.getInstance(this.xrManager, this.nodeManager);
+            }
+
+            // Setup XR button
+            const xrButton = document.getElementById('xr-button');
+            if (xrButton) {
+                xrButton.style.display = 'block';
+                xrButton.addEventListener('click', () => this.toggleXRSession());
+            }
+        }
+    }
 
-    // Connect to server
-    this.webSocket.connect();
-  }
+    private setupUIEventListeners(): void {
+        // Settings panel save button
+        const saveButton = document.getElementById('save-settings');
+        if (saveButton) {
+            saveButton.addEventListener('click', () => this.saveSettings());
+        }
 
-  private initializeScene(): void {
-    // Get canvas element
-    const container = document.getElementById('canvas-container');
-    if (!container) {
-      throw new Error('Canvas container not found');
+        // Settings inputs
+        this.setupSettingsInputListeners();
     }
 
-    // Create canvas
-    const canvas = document.createElement('canvas');
-    container.appendChild(canvas);
-
-    // Initialize scene manager
-    this.sceneManager = SceneManager.getInstance(canvas);
-
-    // Initialize node manager
-    this.nodeManager = NodeManager.getInstance(this.sceneManager);
-
-    // Initialize text renderer
-    this.textRenderer = TextRenderer.getInstance(
-      this.sceneManager.getScene(),
-      this.sceneManager.getCamera()
-    );
-
-    // Start rendering
-    this.sceneManager.start();
-  }
-
-  private async initializeSettings(): Promise<void> {
-    try {
-      // Settings will be received through WebSocket
-      await settingsManager.loadSettings();
-
-      // Update UI with current settings
-      this.updateSettingsUI();
-
-      // Subscribe to settings changes to update UI
-      settingsManager.subscribe(() => {
-        this.updateSettingsUI();
-      });
-    } catch (error) {
-      logger.error('Failed to load settings:', error);
-      // Continue with default settings
+    private setupSettingsInputListeners(): void {
+        // Node appearance settings
+        this.setupSettingInput('nodeSize', 'number');
+        this.setupSettingInput('nodeColor', 'color');
+        this.setupSettingInput('nodeOpacity', 'number');
+
+        // Edge appearance settings
+        this.setupSettingInput('edgeWidth', 'number');
+        this.setupSettingInput('edgeColor', 'color');
+        this.setupSettingInput('edgeOpacity', 'number');
+
+        // Visual effects settings
+        this.setupSettingInput('enableBloom', 'checkbox');
+        this.setupSettingInput('bloomIntensity', 'number');
     }
-  }
-
-  private async initializeXR(): Promise<void> {
-    if (platformManager.getCapabilities().xrSupported) {
-      // Initialize XR manager
-      this.xrManager = XRSessionManager.getInstance(this.sceneManager);
-
-      // Initialize XR interaction
-      if (this.xrManager && this.nodeManager) {
-        this.xrInteraction = XRInteraction.getInstance(this.xrManager, this.nodeManager);
-      }
-
-      // Setup XR button
-      const xrButton = document.getElementById('xr-button');
-      if (xrButton) {
-        xrButton.style.display = 'block';
-        xrButton.addEventListener('click', () => this.toggleXRSession());
-      }
+
+    private setupSettingInput(id: string, type: 'number' | 'color' | 'checkbox'): void {
+        const input = document.getElementById(id) as HTMLInputElement;
+        if (input) {
+            input.addEventListener('change', () => {
+                const value = type === 'checkbox' ? input.checked :
+                            type === 'number' ? parseFloat(input.value) :
+                            input.value;
+                // Update settings and save to server via REST endpoint
+                settingsManager.updateSettings({ [id]: value });
+            });
+        }
     }
-  }
 
-  private setupUIEventListeners(): void {
-    // Settings panel save button
-    const saveButton = document.getElementById('save-settings');
-    if (saveButton) {
-      saveButton.addEventListener('click', () => this.saveSettings());
+    private async saveSettings(): Promise<void> {
+        try {
+            await settingsManager.saveSettings();
+            logger.log('Settings saved successfully');
+        } catch (error) {
+            logger.error('Failed to save settings:', error);
+            this.showError('Failed to save settings');
+        }
     }
 
-    // Settings inputs
-    this.setupSettingsInputListeners();
-  }
-
-  private setupSettingsInputListeners(): void {
-    // Node appearance settings
-    this.setupSettingInput('nodeSize', 'number');
-    this.setupSettingInput('nodeColor', 'color');
-    this.setupSettingInput('nodeOpacity', 'number');
-
-    // Edge appearance settings
-    this.setupSettingInput('edgeWidth', 'number');
-    this.setupSettingInput('edgeColor', 'color');
-    this.setupSettingInput('edgeOpacity', 'number');
-
-    // Visual effects settings
-    this.setupSettingInput('enableBloom', 'checkbox');
-    this.setupSettingInput('bloomIntensity', 'number');
-  }
-
-  private setupSettingInput(id: string, type: 'number' | 'color' | 'checkbox'): void {
-    const input = document.getElementById(id) as HTMLInputElement;
-    if (input) {
-      input.addEventListener('change', () => {
-        const value = type === 'checkbox' ? input.checked :
-                     type === 'number' ? parseFloat(input.value) :
-                     input.value;
-        // Update settings - this will automatically send to server via WebSocket
-        settingsManager.updateSettings({ [id]: value });
-      });
+    private async toggleXRSession(): Promise<void> {
+        if (!this.xrManager) return;
+
+        try {
+            if (this.xrManager.isXRPresenting()) {
+                await this.xrManager.endXRSession();
+            } else {
+                await this.xrManager.initXRSession();
+            }
+        } catch (error) {
+            logger.error('Failed to toggle XR session:', error);
+            this.showError('Failed to start XR session');
+        }
     }
-  }
-
-  private updateSettingsUI(): void {
-    const settings = settingsManager.getSettings();
-    Object.entries(settings).forEach(([key, value]) => {
-      const input = document.getElementById(key) as HTMLInputElement;
-      if (input) {
-        if (input.type === 'checkbox') {
-          input.checked = value as boolean;
-        } else {
-          input.value = value.toString();
+
+    private hideLoadingOverlay(): void {
+        const overlay = document.querySelector('.loading-overlay');
+        if (overlay) {
+            overlay.remove();
         }
-      }
-    });
-  }
-
-  private async saveSettings(): Promise<void> {
-    try {
-      await settingsManager.saveSettings();
-      logger.log('Settings saved successfully');
-    } catch (error) {
-      logger.error('Failed to save settings:', error);
-      this.showError('Failed to save settings');
     }
-  }
-
-  private async toggleXRSession(): Promise<void> {
-    if (!this.xrManager) return;
-
-    try {
-      if (this.xrManager.isXRPresenting()) {
-        await this.xrManager.endXRSession();
-      } else {
-        await this.xrManager.initXRSession();
-      }
-    } catch (error) {
-      logger.error('Failed to toggle XR session:', error);
-      this.showError('Failed to start XR session');
+
+    private showError(message: string): void {
+        logger.error(message);
+        const errorDiv = document.createElement('div');
+        errorDiv.style.cssText = `
+            position: fixed;
+            top: 20px;
+            right: 20px;
+            background: rgba(255, 0, 0, 0.8);
+            color: white;
+            padding: 15px;
+            border-radius: 5px;
+            z-index: 1000;
+        `;
+        errorDiv.textContent = message;
+        document.body.appendChild(errorDiv);
+        setTimeout(() => errorDiv.remove(), 5000);
     }
-  }
 
-  private hideLoadingOverlay(): void {
-    const overlay = document.querySelector('.loading-overlay');
-    if (overlay) {
-      overlay.remove();
+    dispose(): void {
+        // Dispose of managers in reverse order of initialization
+        settingsManager.dispose();
+        this.xrInteraction?.dispose();
+        this.xrManager?.dispose();
+        this.textRenderer.dispose();
+        this.nodeManager.dispose();
+        this.sceneManager.dispose();
+
+        // Stop rendering
+        this.sceneManager.stop();
+
+        // Close WebSocket connection
+        this.webSocket.disconnect();
     }
-  }
-
-  private showError(message: string): void {
-    logger.error(message);
-    const errorDiv = document.createElement('div');
-    errorDiv.style.cssText = `
-      position: fixed;
-      top: 20px;
-      right: 20px;
-      background: rgba(255, 0, 0, 0.8);
-      color: white;
-      padding: 15px;
-      border-radius: 5px;
-      z-index: 1000;
-    `;
-    errorDiv.textContent = message;
-    document.body.appendChild(errorDiv);
-    setTimeout(() => errorDiv.remove(), 5000);
-  }
-
-  /**
-   * Clean up resources
-   */
-  dispose(): void {
-    // Dispose of managers in reverse order of initialization
-    settingsManager.dispose();
-    this.xrInteraction?.dispose();
-    this.xrManager?.dispose();
-    this.textRenderer.dispose();
-    this.nodeManager.dispose();
-    this.sceneManager.dispose();
-
-    // Stop rendering
-    this.sceneManager.stop();
-
-    // Close WebSocket connection
-    this.webSocket.disconnect();
-  }
 }
 
 // Create application instance
@@ -304,7 +260,7 @@ const app = new Application();
 
 // Handle window unload
 window.addEventListener('unload', () => {
-  app.dispose();
+    app.dispose();
 });
 
 // Log application start
diff --git a/client/platform/platformManager.ts b/client/platform/platformManager.ts
index 33558893..1599a97f 100644
--- a/client/platform/platformManager.ts
+++ b/client/platform/platformManager.ts
@@ -1,29 +1,53 @@
-/**
- * Platform detection and capability management
- */
+class BrowserEventEmitter {
+  private listeners: { [event: string]: Function[] } = {};
+
+  on(event: string, listener: Function): void {
+    if (!this.listeners[event]) {
+      this.listeners[event] = [];
+    }
+    this.listeners[event].push(listener);
+  }
+
+  emit(event: string, ...args: any[]): void {
+    const eventListeners = this.listeners[event];
+    if (eventListeners) {
+      eventListeners.forEach(listener => listener(...args));
+    }
+  }
+
+  removeAllListeners(): void {
+    this.listeners = {};
+  }
+}
 
 import { Platform, PlatformCapabilities } from '../core/types';
 import { createLogger } from '../core/utils';
 
 const logger = createLogger('PlatformManager');
 
-export class PlatformManager {
-  private static instance: PlatformManager;
+declare global {
+  interface Navigator {
+    xr?: XRSystem;
+  }
+}
+
+export class PlatformManager extends BrowserEventEmitter {
+  private static instance: PlatformManager | null = null;
   private platform: Platform;
   private capabilities: PlatformCapabilities;
+  private initialized: boolean = false;
 
   private constructor() {
-    this.platform = this.detectPlatform();
-    // Initialize with default values
+    super();
+    this.platform = 'desktop';
     this.capabilities = {
       xrSupported: false,
       webglSupported: false,
-      websocketSupported: false
+      websocketSupported: false,
+      webxr: false,
+      handTracking: false,
+      planeDetection: false
     };
-    // Then update capabilities asynchronously
-    this.updateCapabilities();
-    
-    logger.log(`Platform: ${this.platform}`);
   }
 
   static getInstance(): PlatformManager {
@@ -33,40 +57,61 @@ export class PlatformManager {
     return PlatformManager.instance;
   }
 
-  private detectPlatform(): Platform {
-    // Check for Oculus Browser
+  async initialize(): Promise<void> {
+    if (this.initialized) {
+      return;
+    }
+
+    this.detectPlatform();
+    await this.detectCapabilities();
+    this.initialized = true;
+    logger.log('Platform manager initialized');
+  }
+
+  private detectPlatform(): void {
     const userAgent = navigator.userAgent.toLowerCase();
-    if (userAgent.includes('oculus') || userAgent.includes('quest')) {
-      return 'quest';
+    const isQuest = userAgent.includes('quest');
+    
+    if (isQuest) {
+      this.platform = 'quest';
+    } else if (userAgent.includes('chrome') || userAgent.includes('firefox') || userAgent.includes('safari')) {
+      this.platform = 'browser';
+    } else {
+      this.platform = 'desktop';
     }
-    return 'browser';
   }
 
-  private async updateCapabilities(): Promise<void> {
-    // Check WebXR support
-    if (navigator.xr) {
+  private async detectCapabilities(): Promise<void> {
+    // WebXR support
+    if ('xr' in navigator && navigator.xr) {
       try {
         this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
+        this.capabilities.webxr = this.capabilities.xrSupported;
+        this.capabilities.handTracking = this.capabilities.xrSupported;
+        this.capabilities.planeDetection = this.capabilities.xrSupported;
       } catch (error) {
-        logger.warn('Error checking XR support:', error);
+        logger.warn('WebXR not supported:', error);
         this.capabilities.xrSupported = false;
+        this.capabilities.webxr = false;
+        this.capabilities.handTracking = false;
+        this.capabilities.planeDetection = false;
       }
     }
 
-    // Check WebGL support
+    // WebGL support
     try {
       const canvas = document.createElement('canvas');
       const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
       this.capabilities.webglSupported = !!gl;
     } catch (error) {
-      logger.warn('Error checking WebGL support:', error);
+      logger.warn('WebGL not supported:', error);
       this.capabilities.webglSupported = false;
     }
 
-    // Check WebSocket support
+    // WebSocket support
     this.capabilities.websocketSupported = 'WebSocket' in window;
 
-    logger.log('Capabilities:', this.capabilities);
+    logger.log('Platform capabilities detected:', this.capabilities);
   }
 
   getPlatform(): Platform {
@@ -74,7 +119,11 @@ export class PlatformManager {
   }
 
   getCapabilities(): PlatformCapabilities {
-    return this.capabilities;
+    return { ...this.capabilities };
+  }
+
+  isDesktop(): boolean {
+    return this.platform === 'desktop';
   }
 
   isQuest(): boolean {
@@ -85,7 +134,7 @@ export class PlatformManager {
     return this.platform === 'browser';
   }
 
-  async isXRSupported(): Promise<boolean> {
+  isXRSupported(): boolean {
     return this.capabilities.xrSupported;
   }
 
@@ -97,90 +146,61 @@ export class PlatformManager {
     return this.capabilities.websocketSupported;
   }
 
-  async requestXRSession(mode: XRSessionMode = 'immersive-ar'): Promise<XRSession | null> {
-    if (!this.capabilities.xrSupported || !navigator.xr) {
-      logger.warn('XR not supported on this platform');
+  async requestXRSession(): Promise<XRSession | null> {
+    if (!this.capabilities.xrSupported || !('xr' in navigator) || !navigator.xr) {
+      logger.warn('WebXR not supported');
       return null;
     }
 
     try {
-      const session = await navigator.xr.requestSession(mode, {
+      const session = await navigator.xr.requestSession('immersive-ar', {
         requiredFeatures: ['local-floor', 'hit-test'],
-        optionalFeatures: ['hand-tracking', 'layers']
+        optionalFeatures: ['hand-tracking', 'plane-detection']
       });
+
+      // Update capabilities based on session features
+      session.addEventListener('end', () => {
+        logger.log('XR session ended');
+        this.emit('xrsessionend');
+      });
+
+      logger.log('XR session started');
       return session;
     } catch (error) {
-      logger.error('Error requesting XR session:', error);
+      logger.error('Failed to start XR session:', error);
       return null;
     }
   }
 
-  // Event handling for platform-specific features
-  private eventListeners: Map<string, Set<Function>> = new Map();
-
-  on(event: string, callback: Function): void {
-    if (!this.eventListeners.has(event)) {
-      this.eventListeners.set(event, new Set());
-    }
-    this.eventListeners.get(event)?.add(callback);
-  }
-
-  off(event: string, callback: Function): void {
-    this.eventListeners.get(event)?.delete(callback);
-  }
-
-  private emit(event: string, ...args: any[]): void {
-    this.eventListeners.get(event)?.forEach(callback => {
+  async checkXRSupport(): Promise<void> {
+    if ('xr' in navigator && navigator.xr) {
       try {
-        callback(...args);
+        // Check for AR support
+        const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
+        if (arSupported) {
+          this.capabilities.xrSupported = true;
+          this.capabilities.webxr = true;
+          this.capabilities.handTracking = true;
+          this.capabilities.planeDetection = true;
+          this.emit('xrdevicechange', true);
+          logger.log('WebXR AR supported');
+        }
       } catch (error) {
-        logger.error(`Error in platform event listener for ${event}:`, error);
+        logger.warn('WebXR check failed:', error);
+        this.capabilities.xrSupported = false;
+        this.capabilities.webxr = false;
+        this.capabilities.handTracking = false;
+        this.capabilities.planeDetection = false;
+        this.emit('xrdevicechange', false);
       }
-    });
-  }
-
-  // Device orientation handling for mobile/Quest
-  private setupDeviceOrientation(): void {
-    if (typeof DeviceOrientationEvent !== 'undefined') {
-      window.addEventListener('deviceorientation', (event: DeviceOrientationEvent) => {
-        this.emit('orientation', {
-          alpha: event.alpha, // z-axis rotation
-          beta: event.beta,   // x-axis rotation
-          gamma: event.gamma  // y-axis rotation
-        });
-      }, true);
     }
   }
 
-  // Screen orientation handling
-  private setupScreenOrientation(): void {
-    if ('screen' in window && 'orientation' in screen) {
-      screen.orientation.addEventListener('change', () => {
-        this.emit('orientationchange', screen.orientation.type);
-      });
-    }
-  }
-
-  // Initialize platform-specific features
-  async initialize(): Promise<void> {
-    // Set up event listeners
-    this.setupDeviceOrientation();
-    this.setupScreenOrientation();
-
-    // Check for WebXR changes
-    if (navigator.xr) {
-      navigator.xr.addEventListener('devicechange', async () => {
-        if (navigator.xr) {
-          this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
-          this.emit('xrdevicechange', this.capabilities.xrSupported);
-        }
-      });
-    }
-
-    // Additional platform-specific initialization can be added here
-    logger.log('Platform manager initialized');
+  dispose(): void {
+    this.removeAllListeners();
+    this.initialized = false;
+    PlatformManager.instance = null;
   }
 }
 
-// Export a singleton instance
 export const platformManager = PlatformManager.getInstance();
diff --git a/client/rendering/nodes.ts b/client/rendering/nodes.ts
index 13ec778c..939e5f01 100644
--- a/client/rendering/nodes.ts
+++ b/client/rendering/nodes.ts
@@ -2,46 +2,54 @@
  * Node and edge rendering using InstancedMesh for both
  */
 
-import * as THREE from 'three';
+import {
+  Vector3,
+  Matrix4,
+  Quaternion,
+  Color,
+  SphereGeometry,
+  CylinderGeometry,
+  MeshPhongMaterial,
+  MeshBasicMaterial,
+  Material,
+  InstancedMesh,
+  Object3D,
+  MathUtils
+} from 'three';
 import { Node, Edge } from '../core/types';
 import { SceneManager } from './scene';
 import { createLogger } from '../core/utils';
-import { NODE_HIGHLIGHT_COLOR } from '../core/constants';
+import { settingsManager } from '../state/settings';
+import { graphDataManager } from '../state/graphData';
 
 const logger = createLogger('NodeManager');
 
 // Constants for geometry
-const NODE_SIZE = 2.5;
-const NODE_VISUAL_OFFSET = 1.0; // Reduced from NODE_SIZE to account for visual appearance
 const NODE_SEGMENTS = 16;
-const EDGE_RADIUS = 0.25;
 const EDGE_SEGMENTS = 8;
+const NODE_SIZE_MULTIPLIER = 1;
 
 // Binary format constants
 const BINARY_VERSION = 1.0;
 const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
 const VERSION_OFFSET = 1;    // Skip version float
 
-// Colors
-const NODE_COLOR = 0x4CAF50;  // Material Design Green
-const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300
-
 // Reusable objects for matrix calculations
-const matrix = new THREE.Matrix4();
-const quaternion = new THREE.Quaternion();
-const position = new THREE.Vector3();
-const scale = new THREE.Vector3(1, 1, 1);
+const matrix = new Matrix4();
+const quaternion = new Quaternion();
+const position = new Vector3();
+const scale = new Vector3(1, 1, 1);
 
 // Edge calculation vectors (reused for efficiency)
-const start = new THREE.Vector3();
-const end = new THREE.Vector3();
-const direction = new THREE.Vector3();
-const center = new THREE.Vector3();
-const UP = new THREE.Vector3(0, 1, 0);
-const tempVector = new THREE.Vector3();
-const rotationAxis = new THREE.Vector3(1, 0, 0);
-
-export interface NodeMesh extends THREE.Object3D {
+const start = new Vector3();
+const end = new Vector3();
+const direction = new Vector3();
+const center = new Vector3();
+const UP = new Vector3(0, 1, 0);
+const tempVector = new Vector3();
+const rotationAxis = new Vector3(1, 0, 0);
+
+export interface NodeMesh extends Object3D {
   userData: {
     nodeId: string;
   };
@@ -52,8 +60,8 @@ export class NodeManager {
   private sceneManager: SceneManager;
 
   // Instanced meshes - initialized with dummy values, properly set in constructor
-  private nodeInstances: THREE.InstancedMesh;
-  private edgeInstances: THREE.InstancedMesh;
+  private nodeInstances: InstancedMesh;
+  private edgeInstances: InstancedMesh;
 
   // State tracking
   private currentNodes: Node[] = [];
@@ -65,34 +73,99 @@ export class NodeManager {
   private dirtyEdges: Set<number> = new Set();
   private batchUpdateTimeout: number | null = null;
 
+  // Unsubscribe function for position updates
+  private unsubscribeFromPositionUpdates: (() => void) | null = null;
+
   private constructor(sceneManager: SceneManager) {
     this.sceneManager = sceneManager;
     
+    // Get initial settings
+    const threeSettings = settingsManager.getThreeJSSettings();
+    
     // Initialize with proper geometries
-    const nodeGeometry = new THREE.SphereGeometry(NODE_SIZE, NODE_SEGMENTS, NODE_SEGMENTS);
-    const nodeMaterial = new THREE.MeshPhongMaterial({
-      color: NODE_COLOR,
-      shininess: 90,
-      specular: 0x444444,
+    const nodeGeometry = new SphereGeometry(threeSettings.nodes.size * NODE_SIZE_MULTIPLIER, NODE_SEGMENTS, NODE_SEGMENTS);
+    const nodeMaterial = new MeshPhongMaterial({
+      color: new Color(threeSettings.nodes.color),
+      shininess: 100,
+      specular: new Color('#FFFFFF'),
       transparent: true,
-      opacity: 0.7
+      opacity: threeSettings.nodes.opacity
     });
 
-    const edgeGeometry = new THREE.CylinderGeometry(EDGE_RADIUS, EDGE_RADIUS, 1, EDGE_SEGMENTS);
+    const edgeGeometry = new CylinderGeometry(
+      threeSettings.edges.width / 4,
+      threeSettings.edges.width / 4,
+      1,
+      EDGE_SEGMENTS
+    );
     edgeGeometry.rotateX(Math.PI / 2);
     
-    const edgeMaterial = new THREE.MeshBasicMaterial({
-      color: EDGE_COLOR,
+    const edgeMaterial = new MeshBasicMaterial({
+      color: new Color(threeSettings.edges.color),
       transparent: true,
-      opacity: 0.7,
+      opacity: threeSettings.edges.opacity,
       depthWrite: false
     });
 
-    this.nodeInstances = new THREE.InstancedMesh(nodeGeometry, nodeMaterial, 10000);
-    this.edgeInstances = new THREE.InstancedMesh(edgeGeometry, edgeMaterial, 30000);
+    this.nodeInstances = new InstancedMesh(nodeGeometry, nodeMaterial, 10000);
+    this.edgeInstances = new InstancedMesh(edgeGeometry, edgeMaterial, 30000);
     
     this.initializeInstances();
-    logger.log('NodeManager initialized');
+
+    // Subscribe to settings changes
+    settingsManager.subscribe(() => this.onSettingsChanged());
+
+    // Subscribe to position updates from graphDataManager
+    this.unsubscribeFromPositionUpdates = graphDataManager.subscribeToPositionUpdates(
+      (positions: Float32Array) => this.updatePositions(positions)
+    );
+    
+    logger.log('NodeManager initialized with settings:', threeSettings);
+  }
+
+  private onSettingsChanged(): void {
+    const threeSettings = settingsManager.getThreeJSSettings();
+
+    // Update node geometry with new size
+    const nodeGeometry = new SphereGeometry(threeSettings.nodes.size * NODE_SIZE_MULTIPLIER, NODE_SEGMENTS, NODE_SEGMENTS);
+    this.nodeInstances.geometry.dispose();
+    this.nodeInstances.geometry = nodeGeometry;
+
+    // Update node material
+    const nodeMaterial = this.nodeInstances.material as MeshPhongMaterial;
+    nodeMaterial.color.set(threeSettings.nodes.color);
+    nodeMaterial.opacity = threeSettings.nodes.opacity;
+    nodeMaterial.shininess = 100;
+    nodeMaterial.specular.set('#FFFFFF');
+
+    // Update edge material
+    const edgeMaterial = this.edgeInstances.material as MeshBasicMaterial;
+    edgeMaterial.color.set(threeSettings.edges.color);
+    edgeMaterial.opacity = threeSettings.edges.opacity;
+
+    // Update all node positions to account for new size
+    this.currentNodes.forEach((node, index) => {
+      position.set(
+        node.data.position.x,
+        node.data.position.y,
+        node.data.position.z
+      );
+      matrix.compose(position, quaternion, scale);
+      this.nodeInstances.setMatrixAt(index, matrix);
+    });
+    this.nodeInstances.instanceMatrix.needsUpdate = true;
+
+    // Update all edges to account for new node size
+    this.currentEdges.forEach((edge, index) => {
+      const sourceNode = this.currentNodes.find(n => n.id === edge.source);
+      const targetNode = this.currentNodes.find(n => n.id === edge.target);
+      if (sourceNode && targetNode) {
+        this.updateEdgeInstance(index, sourceNode, targetNode);
+      }
+    });
+    this.edgeInstances.instanceMatrix.needsUpdate = true;
+
+    logger.log('Visual settings updated:', threeSettings);
   }
 
   static getInstance(sceneManager: SceneManager): NodeManager {
@@ -123,19 +196,19 @@ export class NodeManager {
     return [this.nodeInstances as unknown as NodeMesh];
   }
 
-  getNodePosition(nodeId: string): THREE.Vector3 {
+  getNodePosition(nodeId: string): Vector3 {
     const node = this.currentNodes.find(n => n.id === nodeId);
     if (!node) {
       throw new Error(`Node ${nodeId} not found`);
     }
-    return new THREE.Vector3(
+    return new Vector3(
       node.data.position.x,
       node.data.position.y,
       node.data.position.z
     );
   }
 
-  updateNodePosition(nodeId: string, newPosition: THREE.Vector3): void {
+  updateNodePosition(nodeId: string, newPosition: Vector3): void {
     const index = this.nodeIndices.get(nodeId);
     if (index === undefined) {
       throw new Error(`Node ${nodeId} not found`);
@@ -193,13 +266,14 @@ export class NodeManager {
   highlightNode(nodeId: string | null): void {
     if (this.highlightedNode === nodeId) return;
 
-    const color = new THREE.Color();
+    const color = new Color();
+    const threeSettings = settingsManager.getThreeJSSettings();
 
     if (this.highlightedNode) {
       const prevIndex = this.nodeIndices.get(this.highlightedNode);
       if (prevIndex !== undefined) {
         const node = this.currentNodes[prevIndex];
-        color.set(node?.color || NODE_COLOR);
+        color.set(node?.color || threeSettings.nodes.color);
         this.nodeInstances.setColorAt(prevIndex, color);
       }
     }
@@ -207,7 +281,7 @@ export class NodeManager {
     if (nodeId) {
       const index = this.nodeIndices.get(nodeId);
       if (index !== undefined) {
-        color.set(NODE_HIGHLIGHT_COLOR);
+        color.set(threeSettings.nodes.highlightColor);
         this.nodeInstances.setColorAt(index, color);
       }
     }
@@ -224,6 +298,9 @@ export class NodeManager {
     this.nodeIndices.clear();
     this.dirtyEdges.clear();
 
+    // Get current settings
+    const threeSettings = settingsManager.getThreeJSSettings();
+
     // Update node instances count and matrices
     this.nodeInstances.count = nodes.length;
     nodes.forEach((node, index) => {
@@ -237,9 +314,16 @@ export class NodeManager {
 
       matrix.compose(position, quaternion, scale);
       this.nodeInstances.setMatrixAt(index, matrix);
+
+      // Set node color based on settings
+      const color = new Color(node.color || threeSettings.nodes.color);
+      this.nodeInstances.setColorAt(index, color);
     });
 
     this.nodeInstances.instanceMatrix.needsUpdate = true;
+    if (this.nodeInstances.instanceColor) {
+      this.nodeInstances.instanceColor.needsUpdate = true;
+    }
 
     // Update edge instances
     this.edgeInstances.count = edges.length;
@@ -273,7 +357,7 @@ export class NodeManager {
     position.copy(center);
 
     direction.normalize();
-    const angle = Math.acos(THREE.MathUtils.clamp(direction.dot(UP), -1, 1));
+    const angle = Math.acos(MathUtils.clamp(direction.dot(UP), -1, 1));
     tempVector.crossVectors(UP, direction).normalize();
     
     if (tempVector.lengthSq() < 0.001) {
@@ -282,8 +366,11 @@ export class NodeManager {
       quaternion.setFromAxisAngle(tempVector, angle);
     }
 
-    // Use NODE_VISUAL_OFFSET instead of NODE_SIZE for more accurate edge length
-    scale.set(1, Math.max(0.001, length - (NODE_VISUAL_OFFSET * 2)), 1);
+    // Get current settings
+    const threeSettings = settingsManager.getThreeJSSettings();
+    const nodeVisualOffset = threeSettings.nodes.size * NODE_SIZE_MULTIPLIER;
+
+    scale.set(nodeVisualOffset, nodeVisualOffset, nodeVisualOffset);
 
     matrix.compose(position, quaternion, scale);
     this.edgeInstances.setMatrixAt(index, matrix);
@@ -317,37 +404,38 @@ export class NodeManager {
     
     // Process batched edge updates
     this.processBatchEdgeUpdate();
+
+    logger.debug(`Updated positions for ${nodeCount} nodes`);
   }
 
   private processNodeChunk(floatArray: Float32Array, startIndex: number, endIndex: number): void {
-    // Reset quaternion and scale for each chunk to ensure clean transforms
-    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0); // Identity quaternion using axis-angle
-    scale.set(1, 1, 1);         // Unit scale
-
+    // Reset quaternion to identity
+    quaternion.identity();
+    
     for (let i = startIndex; i < endIndex; i++) {
       const baseIndex = VERSION_OFFSET + (i * FLOATS_PER_NODE);
       
-      // Extract position directly into position vector
+      // Extract position
       position.set(
         floatArray[baseIndex],
         floatArray[baseIndex + 1],
         floatArray[baseIndex + 2]
       );
 
-      // Create a new matrix for this instance to avoid transformation bleeding
-      const instanceMatrix = new THREE.Matrix4();
-      instanceMatrix.compose(position, quaternion, scale);
-      this.nodeInstances.setMatrixAt(i, instanceMatrix);
+      // Keep uniform scale of 1 for position updates
+      scale.set(1, 1, 1);
+      
+      // Create matrix with uniform scaling
+      matrix.compose(position, quaternion, scale);
+      this.nodeInstances.setMatrixAt(i, matrix);
 
       // Update node data
       const node = this.currentNodes[i];
       if (node) {
-        // Update position
         node.data.position.x = floatArray[baseIndex];
         node.data.position.y = floatArray[baseIndex + 1];
         node.data.position.z = floatArray[baseIndex + 2];
         
-        // Update velocity
         node.data.velocity.x = floatArray[baseIndex + 3];
         node.data.velocity.y = floatArray[baseIndex + 4];
         node.data.velocity.z = floatArray[baseIndex + 5];
@@ -367,12 +455,18 @@ export class NodeManager {
       clearTimeout(this.batchUpdateTimeout);
     }
 
+    // Unsubscribe from position updates
+    if (this.unsubscribeFromPositionUpdates) {
+      this.unsubscribeFromPositionUpdates();
+      this.unsubscribeFromPositionUpdates = null;
+    }
+
     this.nodeInstances.geometry.dispose();
-    (this.nodeInstances.material as THREE.Material).dispose();
+    (this.nodeInstances.material as Material).dispose();
     this.sceneManager.remove(this.nodeInstances);
 
     this.edgeInstances.geometry.dispose();
-    (this.edgeInstances.material as THREE.Material).dispose();
+    (this.edgeInstances.material as Material).dispose();
     this.sceneManager.remove(this.edgeInstances);
 
     this.dirtyEdges.clear();
diff --git a/client/rendering/scene.ts b/client/rendering/scene.ts
index 9f9fe517..a9db7807 100644
--- a/client/rendering/scene.ts
+++ b/client/rendering/scene.ts
@@ -37,7 +37,7 @@ export class SceneManager {
     // Create scene
     this.scene = new THREE.Scene();
     this.scene.background = new THREE.Color(BACKGROUND_COLOR);
-    this.scene.fog = new THREE.FogExp2(BACKGROUND_COLOR, 0.002);
+    // Removed fog to ensure graph visibility
 
     // Create camera
     this.camera = new THREE.PerspectiveCamera(
@@ -46,7 +46,7 @@ export class SceneManager {
       0.1,
       1000
     );
-    this.camera.position.set(0, 75, 200);
+    this.camera.position.set(0, 5, 20); // Moved camera closer
     this.camera.lookAt(0, 0, 0);
 
     // Create renderer
@@ -64,8 +64,8 @@ export class SceneManager {
     this.controls.enableDamping = true;
     this.controls.dampingFactor = 0.05;
     this.controls.screenSpacePanning = false;
-    this.controls.minDistance = 50;
-    this.controls.maxDistance = 500;
+    this.controls.minDistance = 5;  // Reduced min distance
+    this.controls.maxDistance = 100; // Reduced max distance
 
     // Setup post-processing
     this.composer = new EffectComposer(this.renderer);
@@ -104,8 +104,8 @@ export class SceneManager {
     directionalLight.position.set(1, 1, 1).normalize();
     this.scene.add(directionalLight);
 
-    // Add grid helper
-    const gridHelper = new THREE.GridHelper(1000, 100);
+    // Add smaller grid helper
+    const gridHelper = new THREE.GridHelper(50, 50); // Reduced grid size
     if (gridHelper.material instanceof THREE.Material) {
       gridHelper.material.transparent = true;
       gridHelper.material.opacity = 0.1;
diff --git a/client/rendering/textRenderer.ts b/client/rendering/textRenderer.ts
index f26119ff..07652fbe 100644
--- a/client/rendering/textRenderer.ts
+++ b/client/rendering/textRenderer.ts
@@ -89,7 +89,7 @@ export class TextRenderer {
   }
 
   private setupEventListeners(): void {
-    settingsManager.subscribe(settings => {
+    settingsManager.subscribe((settings: VisualizationSettings) => {
       this.settings = settings;
       this.updateAllLabels();
     });
diff --git a/client/state/graphData.ts b/client/state/graphData.ts
index a47abaed..28e30ddf 100644
--- a/client/state/graphData.ts
+++ b/client/state/graphData.ts
@@ -40,7 +40,25 @@ export class GraphDataManager {
   }
 
   /**
-   * Initialize or update the entire graph data
+   * Load initial graph data from REST endpoint
+   */
+  async loadGraphData(): Promise<void> {
+    try {
+      const response = await fetch('/api/graph/data');
+      if (!response.ok) {
+        throw new Error(`Failed to fetch graph data: ${response.status} ${response.statusText}`);
+      }
+      const data = await response.json();
+      this.updateGraphData(data);
+      logger.log('Initial graph data loaded from REST endpoint');
+    } catch (error) {
+      logger.error('Failed to load initial graph data:', error);
+      throw error;
+    }
+  }
+
+  /**
+   * Initialize or update the graph data
    */
   updateGraphData(data: any): void {
     logger.log('Received graph data update');
@@ -50,8 +68,8 @@ export class GraphDataManager {
     this.edges.clear();
 
     // Store nodes in Map for O(1) access
-    if (data.graphData && Array.isArray(data.graphData.nodes)) {
-      data.graphData.nodes.forEach((node: any) => {
+    if (data.nodes && Array.isArray(data.nodes)) {
+      data.nodes.forEach((node: any) => {
         // Convert position array to object if needed
         let position;
         if (Array.isArray(node.position)) {
@@ -74,15 +92,15 @@ export class GraphDataManager {
       });
 
       // Store edges in Map
-      if (Array.isArray(data.graphData.edges)) {
-        data.graphData.edges.forEach((edge: Edge) => {
+      if (Array.isArray(data.edges)) {
+        data.edges.forEach((edge: Edge) => {
           const edgeId = this.createEdgeId(edge.source, edge.target);
           this.edges.set(edgeId, edge);
         });
       }
 
       // Update metadata
-      this.metadata = data.graphData.metadata || {};
+      this.metadata = data.metadata || {};
 
       // Notify listeners
       this.notifyUpdateListeners();
diff --git a/client/state/settings.ts b/client/state/settings.ts
index ed6474c5..2e218142 100644
--- a/client/state/settings.ts
+++ b/client/state/settings.ts
@@ -2,34 +2,67 @@
  * Settings management with simplified visualization configuration
  */
 
-import { VisualizationSettings } from '../core/types';
+import { VisualizationSettings, ServerSettings } from '../core/types';
 import { createLogger } from '../core/utils';
-import { WebSocketService } from '../websocket/websocketService';
 
 const logger = createLogger('SettingsManager');
 
+// Default settings matching settings.toml exactly
 export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
     // Node Appearance
-    nodeSize: 0.2,
-    nodeColor: '#FFB700',
-    nodeOpacity: 0.92,
-    metalness: 0.85,
-    roughness: 0.15,
+    nodeSize: 1.0,
+    nodeColor: '#c3ab6f',
+    nodeOpacity: 0.4,
+    metalness: 0.3,
+    roughness: 0.35,
     clearcoat: 1.0,
+    enableInstancing: false,
+    materialType: 'basic',
+    sizeRange: [1, 5],
+    sizeByConnections: true,
+    highlightColor: '#822626',
+    highlightDuration: 300,
+    enableHoverEffect: true,
+    hoverScale: 1.2,
 
     // Edge Appearance
     edgeWidth: 2.0,
-    edgeColor: '#FFD700',
+    edgeColor: '#917f18',
     edgeOpacity: 0.6,
-    enableArrows: true,
+    edgeWidthRange: [1, 3],
+    enableArrows: false,
     arrowSize: 0.15,
 
+    // Physics Settings
+    physicsEnabled: false,
+    attractionStrength: 0.015,
+    repulsionStrength: 1500.0,
+    springStrength: 0.018,
+    damping: 0.88,
+    maxVelocity: 2.5,
+    collisionRadius: 0.25,
+    boundsSize: 12.0,
+    enableBounds: true,
+    iterations: 500,
+
+    // Rendering Settings
+    ambientLightIntensity: 0.7,
+    directionalLightIntensity: 1.0,
+    environmentIntensity: 1.2,
+    enableAmbientOcclusion: false,
+    enableAntialiasing: true,
+    enableShadows: false,
+    backgroundColor: '#000000',
+
     // Visual Effects
-    enableBloom: true,
+    enableBloom: false,
     bloomIntensity: 1.8,
     bloomRadius: 0.5,
-    enableNodeAnimations: true,
-    enableMotionBlur: true,
+    nodeBloomStrength: 0.2,
+    edgeBloomStrength: 0.3,
+    environmentBloomStrength: 0.5,
+    enableNodeAnimations: false,
+    enableMotionBlur: false,
     motionBlurStrength: 0.4,
 
     // Labels
@@ -40,16 +73,13 @@ export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
     // Performance
     maxFps: 60,
 
-    // AR Settings (Meta Quest 3)
-    // Scene Understanding
+    // AR Settings
     enablePlaneDetection: true,
     enableSceneUnderstanding: true,
     showPlaneOverlay: true,
     planeOpacity: 0.3,
     planeColor: '#4A90E2',
     enableLightEstimation: true,
-    
-    // Hand Tracking
     enableHandTracking: true,
     handMeshEnabled: true,
     handMeshColor: '#FFD700',
@@ -58,22 +88,14 @@ export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
     handRayColor: '#FFD700',
     handRayWidth: 0.002,
     handPointSize: 0.01,
-    
-    // Gesture Controls
     gestureSmoothing: 0.9,
     pinchThreshold: 0.015,
     dragThreshold: 0.04,
     rotationThreshold: 0.08,
-    
-    // Haptics
     enableHaptics: true,
     hapticIntensity: 0.7,
-    
-    // Room Scale
     roomScale: true,
     snapToFloor: true,
-    
-    // Passthrough
     passthroughOpacity: 1.0,
     passthroughBrightness: 1.0,
     passthroughContrast: 1.0,
@@ -83,275 +105,393 @@ export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
     portalEdgeWidth: 0.02
 };
 
+export interface ThreeJSSettings {
+    nodes: {
+        size: number;
+        color: string;
+        opacity: number;
+        metalness: number;
+        roughness: number;
+        clearcoat: number;
+        materialType: string;
+        highlightColor: string;
+    };
+    edges: {
+        width: number;
+        color: string;
+        opacity: number;
+    };
+}
+
 export class SettingsManager {
-  private static instance: SettingsManager | null = null;
-  private settings: VisualizationSettings;
-  private settingsListeners: Set<(settings: VisualizationSettings) => void>;
-  private webSocket: WebSocketService | null = null;
-
-  private constructor() {
-    this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
-    this.settingsListeners = new Set();
-    logger.log('Initialized with default settings');
-  }
-
-  static getInstance(): SettingsManager {
-    if (!SettingsManager.instance) {
-      SettingsManager.instance = new SettingsManager();
+    private static instance: SettingsManager | null = null;
+    private settings: VisualizationSettings;
+    private settingsListeners: Set<(settings: VisualizationSettings) => void>;
+    private connectionListeners: Set<(connected: boolean) => void>;
+    private connected: boolean = false;
+    private readonly API_BASE = '/api/visualization';
+
+    private constructor() {
+        this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
+        this.settingsListeners = new Set();
+        this.connectionListeners = new Set();
+        logger.log('Initialized with default settings');
     }
-    return SettingsManager.instance;
-  }
-
-  /**
-   * Initialize WebSocket connection
-   */
-  initializeWebSocket(webSocket: WebSocketService): void {
-    this.webSocket = webSocket;
-
-    // Listen for settings updates from server
-    this.webSocket.on('settingsUpdated', (data) => {
-      if (data && data.settings) {
-        this.settings = data.settings;
-        this.notifyListeners();
-      }
-    });
-
-    logger.log('WebSocket initialized for settings');
-  }
-
-  /**
-   * Load settings from the server via WebSocket
-   */
-  async loadSettings(): Promise<void> {
-    // Settings will be received through the settingsUpdated WebSocket message
-    // No need to explicitly request them as they're sent with initial data
-    logger.log('Settings will be received through WebSocket');
-  }
-
-  /**
-   * Save current settings to the server via WebSocket
-   */
-  async saveSettings(): Promise<void> {
-    if (!this.webSocket) {
-      throw new Error('WebSocket not initialized');
+
+    static getInstance(): SettingsManager {
+        if (!SettingsManager.instance) {
+            SettingsManager.instance = new SettingsManager();
+        }
+        return SettingsManager.instance;
+    }
+
+    dispose(): void {
+        this.settingsListeners.clear();
+        this.connectionListeners.clear();
+        SettingsManager.instance = null;
+    }
+
+    isConnected(): boolean {
+        return this.connected;
     }
 
-    try {
-      this.webSocket.send({
-        type: 'updateSettings',
-        data: {
-          settings: this.settings
+    onConnectionChange(listener: (connected: boolean) => void): void {
+        this.connectionListeners.add(listener);
+        listener(this.connected);
+    }
+
+    private setConnected(value: boolean): void {
+        if (this.connected !== value) {
+            this.connected = value;
+            this.notifyConnectionListeners();
         }
-      });
-      logger.log('Settings update sent through WebSocket');
-    } catch (error) {
-      logger.error('Error sending settings update:', error);
-      throw error;
     }
-  }
-
-  /**
-   * Update settings and notify listeners
-   */
-  updateSettings(newSettings: Partial<VisualizationSettings>): void {
-    this.settings = {
-      ...this.settings,
-      ...newSettings
-    };
 
-    logger.log('Updated settings locally');
-    this.notifyListeners();
-    
-    // Send update to server if WebSocket is available
-    if (this.webSocket) {
-      this.saveSettings().catch(error => {
-        logger.error('Failed to save settings to server:', error);
-      });
+    private notifyConnectionListeners(): void {
+        this.connectionListeners.forEach(listener => {
+            try {
+                listener(this.connected);
+            } catch (error) {
+                logger.error('Error in connection listener:', error);
+            }
+        });
+    }
+
+    private notifyListeners(): void {
+        this.settingsListeners.forEach(listener => {
+            try {
+                listener(this.settings);
+            } catch (error) {
+                logger.error('Error in settings listener:', error);
+            }
+        });
+    }
+
+    getSettings(): VisualizationSettings {
+        return { ...this.settings };
+    }
+
+    getThreeJSSettings(): ThreeJSSettings {
+        return {
+            nodes: {
+                size: this.settings.nodeSize,
+                color: this.settings.nodeColor,
+                opacity: this.settings.nodeOpacity,
+                metalness: this.settings.metalness,
+                roughness: this.settings.roughness,
+                clearcoat: this.settings.clearcoat,
+                materialType: this.settings.materialType,
+                highlightColor: this.settings.highlightColor
+            },
+            edges: {
+                width: this.settings.edgeWidth,
+                color: this.settings.edgeColor,
+                opacity: this.settings.edgeOpacity
+            }
+        };
     }
-  }
 
-  private notifyListeners(): void {
-    this.settingsListeners.forEach(listener => {
-      try {
+    subscribe(listener: (settings: VisualizationSettings) => void): () => void {
+        this.settingsListeners.add(listener);
         listener(this.settings);
-      } catch (error) {
-        logger.error('Error in settings listener:', error);
-      }
-    });
-  }
-
-  /**
-   * Add a settings update listener
-   */
-  addSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-    this.settingsListeners.add(listener);
-  }
-
-  /**
-   * Remove a settings update listener
-   */
-  removeSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-    this.settingsListeners.delete(listener);
-  }
-
-  /**
-   * Get current settings
-   */
-  getSettings(): VisualizationSettings {
-    return { ...this.settings };
-  }
-
-  /**
-   * Subscribe to settings changes
-   */
-  subscribe(listener: (settings: VisualizationSettings) => void): () => void {
-    this.settingsListeners.add(listener);
-    return () => {
-      this.settingsListeners.delete(listener);
-    };
-  }
-
-  /**
-   * Reset settings to defaults
-   */
-  resetToDefaults(): void {
-    this.updateSettings(DEFAULT_VISUALIZATION_SETTINGS);
-  }
-
-  /**
-   * Clean up resources
-   */
-  dispose(): void {
-    if (this.webSocket) {
-      // Remove WebSocket listeners
-      this.webSocket.off('settingsUpdated', this.notifyListeners);
-      this.webSocket = null;
+        return () => this.settingsListeners.delete(listener);
     }
-    // Clear all listeners
-    this.settingsListeners.clear();
-    SettingsManager.instance = null;
-  }
-
-  public getThreeJSSettings() {
-    return {
-      nodes: {
-        size: this.settings.nodeSize,
-        color: this.settings.nodeColor,
-        opacity: this.settings.nodeOpacity,
-        metalness: this.settings.metalness,
-        roughness: this.settings.roughness,
-        clearcoat: this.settings.clearcoat,
-        highlightColor: '#FFFFFF' // Default highlight color
-      },
-      edges: {
-        width: this.settings.edgeWidth,
-        color: this.settings.edgeColor,
-        opacity: this.settings.edgeOpacity,
-        arrows: {
-          enabled: this.settings.enableArrows,
-          size: this.settings.arrowSize
+
+    addSettingsListener(listener: (settings: VisualizationSettings) => void): void {
+        this.settingsListeners.add(listener);
+        listener(this.settings);
+    }
+
+    removeSettingsListener(listener: (settings: VisualizationSettings) => void): void {
+        this.settingsListeners.delete(listener);
+    }
+
+    resetToDefaults(): void {
+        this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
+        this.notifyListeners();
+        this.saveSettings().catch(error => {
+            logger.error('Failed to save default settings:', error);
+        });
+    }
+
+    async loadSettings(): Promise<void> {
+        try {
+            const response = await fetch(`${this.API_BASE}/settings`);
+            if (!response.ok) {
+                this.setConnected(false);
+                throw new Error(`Failed to fetch settings: ${response.status} ${response.statusText}`);
+            }
+            const serverSettings = await response.json();
+            this.settings = this.flattenSettings(serverSettings);
+            this.notifyListeners();
+            this.setConnected(true);
+            logger.log('Settings loaded from server:', this.settings);
+        } catch (error) {
+            logger.error('Failed to load settings:', error);
+            this.setConnected(false);
+            this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
+            this.notifyListeners();
         }
-      },
-      bloom: {
-        enabled: this.settings.enableBloom,
-        intensity: this.settings.bloomIntensity,
-        radius: this.settings.bloomRadius
-      },
-      animations: {
-        enabled: this.settings.enableNodeAnimations,
-        motionBlur: {
-          enabled: this.settings.enableMotionBlur,
-          strength: this.settings.motionBlurStrength
+    }
+
+    async saveSettings(): Promise<void> {
+        try {
+            const serverSettings: ServerSettings = {
+                nodes: {
+                    base_size: this.settings.nodeSize,
+                    base_color: this.settings.nodeColor,
+                    opacity: this.settings.nodeOpacity,
+                    metalness: this.settings.metalness,
+                    roughness: this.settings.roughness,
+                    clearcoat: this.settings.clearcoat,
+                    enable_instancing: this.settings.enableInstancing,
+                    material_type: this.settings.materialType,
+                    size_range: this.settings.sizeRange,
+                    size_by_connections: this.settings.sizeByConnections,
+                    highlight_color: this.settings.highlightColor,
+                    highlight_duration: this.settings.highlightDuration,
+                    enable_hover_effect: this.settings.enableHoverEffect,
+                    hover_scale: this.settings.hoverScale
+                },
+                edges: {
+                    base_width: this.settings.edgeWidth,
+                    color: this.settings.edgeColor,
+                    opacity: this.settings.edgeOpacity,
+                    width_range: this.settings.edgeWidthRange,
+                    enable_arrows: this.settings.enableArrows,
+                    arrow_size: this.settings.arrowSize
+                },
+                physics: {
+                    enabled: this.settings.physicsEnabled,
+                    attraction_strength: this.settings.attractionStrength,
+                    repulsion_strength: this.settings.repulsionStrength,
+                    spring_strength: this.settings.springStrength,
+                    damping: this.settings.damping,
+                    max_velocity: this.settings.maxVelocity,
+                    collision_radius: this.settings.collisionRadius,
+                    bounds_size: this.settings.boundsSize,
+                    enable_bounds: this.settings.enableBounds,
+                    iterations: this.settings.iterations
+                },
+                rendering: {
+                    ambient_light_intensity: this.settings.ambientLightIntensity,
+                    directional_light_intensity: this.settings.directionalLightIntensity,
+                    environment_intensity: this.settings.environmentIntensity,
+                    enable_ambient_occlusion: this.settings.enableAmbientOcclusion,
+                    enable_antialiasing: this.settings.enableAntialiasing,
+                    enable_shadows: this.settings.enableShadows,
+                    background_color: this.settings.backgroundColor
+                },
+                bloom: {
+                    enabled: this.settings.enableBloom,
+                    strength: this.settings.bloomIntensity,
+                    radius: this.settings.bloomRadius,
+                    node_bloom_strength: this.settings.nodeBloomStrength,
+                    edge_bloom_strength: this.settings.edgeBloomStrength,
+                    environment_bloom_strength: this.settings.environmentBloomStrength
+                },
+                animations: {
+                    enable_node_animations: this.settings.enableNodeAnimations,
+                    enable_motion_blur: this.settings.enableMotionBlur,
+                    motion_blur_strength: this.settings.motionBlurStrength
+                },
+                labels: {
+                    enable_labels: this.settings.showLabels,
+                    desktop_font_size: this.settings.labelSize * 48,
+                    text_color: this.settings.labelColor
+                },
+                ar: {
+                    enable_plane_detection: this.settings.enablePlaneDetection,
+                    enable_scene_understanding: this.settings.enableSceneUnderstanding,
+                    show_plane_overlay: this.settings.showPlaneOverlay,
+                    plane_opacity: this.settings.planeOpacity,
+                    plane_color: this.settings.planeColor,
+                    enable_light_estimation: this.settings.enableLightEstimation,
+                    enable_hand_tracking: this.settings.enableHandTracking,
+                    hand_mesh_enabled: this.settings.handMeshEnabled,
+                    hand_mesh_color: this.settings.handMeshColor,
+                    hand_mesh_opacity: this.settings.handMeshOpacity,
+                    hand_ray_enabled: this.settings.handRayEnabled,
+                    hand_ray_color: this.settings.handRayColor,
+                    hand_ray_width: this.settings.handRayWidth,
+                    hand_point_size: this.settings.handPointSize,
+                    gesture_smoothing: this.settings.gestureSmoothing,
+                    pinch_threshold: this.settings.pinchThreshold,
+                    drag_threshold: this.settings.dragThreshold,
+                    rotation_threshold: this.settings.rotationThreshold,
+                    enable_haptics: this.settings.enableHaptics,
+                    haptic_intensity: this.settings.hapticIntensity,
+                    room_scale: this.settings.roomScale,
+                    snap_to_floor: this.settings.snapToFloor,
+                    passthrough_opacity: this.settings.passthroughOpacity,
+                    passthrough_brightness: this.settings.passthroughBrightness,
+                    passthrough_contrast: this.settings.passthroughContrast,
+                    enable_passthrough_portal: this.settings.enablePassthroughPortal,
+                    portal_size: this.settings.portalSize,
+                    portal_edge_color: this.settings.portalEdgeColor,
+                    portal_edge_width: this.settings.portalEdgeWidth
+                },
+                audio: {
+                    enable_ambient_sounds: false,
+                    enable_interaction_sounds: false,
+                    enable_spatial_audio: false
+                }
+            };
+
+            const response = await fetch(`${this.API_BASE}/settings`, {
+                method: 'PUT',
+                headers: {
+                    'Content-Type': 'application/json',
+                },
+                body: JSON.stringify(serverSettings)
+            });
+
+            if (!response.ok) {
+                this.setConnected(false);
+                throw new Error(`Failed to save settings: ${response.status} ${response.statusText}`);
+            }
+
+            const updatedSettings = await response.json();
+            this.settings = this.flattenSettings(updatedSettings);
+            this.notifyListeners();
+            this.setConnected(true);
+            logger.log('Settings saved successfully');
+        } catch (error) {
+            this.setConnected(false);
+            logger.error('Failed to save settings:', error);
+            throw error;
         }
-      },
-      labels: {
-        enabled: this.settings.showLabels,
-        size: this.settings.labelSize,
-        color: this.settings.labelColor
-      },
-      performance: {
-        maxFps: this.settings.maxFps
-      }
-    };
-  }
-
-  // Essential setting getters
-  getNodeSettings(): {
-    size: number;
-    color: string;
-    opacity: number;
-    highlightColor: string;
-  } {
-    return {
-      size: this.settings.nodeSize,
-      color: this.settings.nodeColor,
-      opacity: this.settings.nodeOpacity,
-      highlightColor: '#FFFFFF' // Default highlight color
-    };
-  }
-
-  getEdgeSettings(): {
-    width: number;
-    color: string;
-    opacity: number;
-  } {
-    return {
-      width: this.settings.edgeWidth,
-      color: this.settings.edgeColor,
-      opacity: this.settings.edgeOpacity
-    };
-  }
-
-  getBloomSettings(): {
-    enabled: boolean;
-    intensity: number;
-    threshold: number;
-    radius: number;
-  } {
-    return {
-      enabled: this.settings.enableBloom,
-      intensity: this.settings.bloomIntensity,
-      threshold: 0.5, // Default threshold
-      radius: this.settings.bloomRadius
-    };
-  }
-
-  getLabelSettings(): {
-    show: boolean;
-    size: number;
-    color: string;
-  } {
-    return {
-      show: this.settings.showLabels,
-      size: this.settings.labelSize,
-      color: this.settings.labelColor
-    };
-  }
-
-  getXRSettings(): {
-    controllerVibration: boolean;
-    hapticIntensity: number;
-  } {
-    return {
-      controllerVibration: false, // Default controller vibration
-      hapticIntensity: 0.5 // Default haptic intensity
-    };
-  }
-
-  getPerformanceSettings(): {
-    maxFps: number;
-    updateThrottle: number;
-  } {
-    return {
-      maxFps: this.settings.maxFps,
-      updateThrottle: 0 // Default update throttle
-    };
-  }
+    }
+
+    updateSettings(newSettings: Partial<VisualizationSettings>): void {
+        this.settings = { ...this.settings, ...newSettings };
+        logger.log('Updated settings locally');
+        this.notifyListeners();
+        this.saveSettings().catch(error => {
+            logger.error('Failed to save settings to server:', error);
+        });
+    }
+
+    private flattenSettings(serverSettings: ServerSettings): VisualizationSettings {
+        return {
+            // Node settings
+            nodeSize: serverSettings.nodes.base_size,
+            nodeColor: serverSettings.nodes.base_color,
+            nodeOpacity: serverSettings.nodes.opacity,
+            metalness: serverSettings.nodes.metalness,
+            roughness: serverSettings.nodes.roughness,
+            clearcoat: serverSettings.nodes.clearcoat,
+            enableInstancing: serverSettings.nodes.enable_instancing,
+            materialType: serverSettings.nodes.material_type,
+            sizeRange: serverSettings.nodes.size_range,
+            sizeByConnections: serverSettings.nodes.size_by_connections,
+            highlightColor: serverSettings.nodes.highlight_color,
+            highlightDuration: serverSettings.nodes.highlight_duration,
+            enableHoverEffect: serverSettings.nodes.enable_hover_effect,
+            hoverScale: serverSettings.nodes.hover_scale,
+
+            // Edge settings
+            edgeWidth: serverSettings.edges.base_width,
+            edgeColor: serverSettings.edges.color,
+            edgeOpacity: serverSettings.edges.opacity,
+            edgeWidthRange: serverSettings.edges.width_range,
+            enableArrows: serverSettings.edges.enable_arrows,
+            arrowSize: serverSettings.edges.arrow_size,
+
+            // Physics settings
+            physicsEnabled: serverSettings.physics.enabled,
+            attractionStrength: serverSettings.physics.attraction_strength,
+            repulsionStrength: serverSettings.physics.repulsion_strength,
+            springStrength: serverSettings.physics.spring_strength,
+            damping: serverSettings.physics.damping,
+            maxVelocity: serverSettings.physics.max_velocity,
+            collisionRadius: serverSettings.physics.collision_radius,
+            boundsSize: serverSettings.physics.bounds_size,
+            enableBounds: serverSettings.physics.enable_bounds,
+            iterations: serverSettings.physics.iterations,
+
+            // Rendering settings
+            ambientLightIntensity: serverSettings.rendering.ambient_light_intensity,
+            directionalLightIntensity: serverSettings.rendering.directional_light_intensity,
+            environmentIntensity: serverSettings.rendering.environment_intensity,
+            enableAmbientOcclusion: serverSettings.rendering.enable_ambient_occlusion,
+            enableAntialiasing: serverSettings.rendering.enable_antialiasing,
+            enableShadows: serverSettings.rendering.enable_shadows,
+            backgroundColor: serverSettings.rendering.background_color,
+
+            // Bloom settings
+            enableBloom: serverSettings.bloom.enabled,
+            bloomIntensity: serverSettings.bloom.strength,
+            bloomRadius: serverSettings.bloom.radius,
+            nodeBloomStrength: serverSettings.bloom.node_bloom_strength,
+            edgeBloomStrength: serverSettings.bloom.edge_bloom_strength,
+            environmentBloomStrength: serverSettings.bloom.environment_bloom_strength,
+
+            // Animation settings
+            enableNodeAnimations: serverSettings.animations.enable_node_animations,
+            enableMotionBlur: serverSettings.animations.enable_motion_blur,
+            motionBlurStrength: serverSettings.animations.motion_blur_strength,
+
+            // Label settings
+            showLabels: serverSettings.labels.enable_labels,
+            labelSize: serverSettings.labels.desktop_font_size / 48,
+            labelColor: serverSettings.labels.text_color,
+
+            // Performance settings
+            maxFps: 60,
+
+            // AR settings
+            enablePlaneDetection: serverSettings.ar.enable_plane_detection,
+            enableSceneUnderstanding: serverSettings.ar.enable_scene_understanding,
+            showPlaneOverlay: serverSettings.ar.show_plane_overlay,
+            planeOpacity: serverSettings.ar.plane_opacity,
+            planeColor: serverSettings.ar.plane_color,
+            enableLightEstimation: serverSettings.ar.enable_light_estimation,
+            enableHandTracking: serverSettings.ar.enable_hand_tracking,
+            handMeshEnabled: serverSettings.ar.hand_mesh_enabled,
+            handMeshColor: serverSettings.ar.hand_mesh_color,
+            handMeshOpacity: serverSettings.ar.hand_mesh_opacity,
+            handRayEnabled: serverSettings.ar.hand_ray_enabled,
+            handRayColor: serverSettings.ar.hand_ray_color,
+            handRayWidth: serverSettings.ar.hand_ray_width,
+            handPointSize: serverSettings.ar.hand_point_size,
+            gestureSmoothing: serverSettings.ar.gesture_smoothing,
+            pinchThreshold: serverSettings.ar.pinch_threshold,
+            dragThreshold: serverSettings.ar.drag_threshold,
+            rotationThreshold: serverSettings.ar.rotation_threshold,
+            enableHaptics: serverSettings.ar.enable_haptics,
+            hapticIntensity: serverSettings.ar.haptic_intensity,
+            roomScale: serverSettings.ar.room_scale,
+            snapToFloor: serverSettings.ar.snap_to_floor,
+            passthroughOpacity: serverSettings.ar.passthrough_opacity,
+            passthroughBrightness: serverSettings.ar.passthrough_brightness,
+            passthroughContrast: serverSettings.ar.passthrough_contrast,
+            enablePassthroughPortal: serverSettings.ar.enable_passthrough_portal,
+            portalSize: serverSettings.ar.portal_size,
+            portalEdgeColor: serverSettings.ar.portal_edge_color,
+            portalEdgeWidth: serverSettings.ar.portal_edge_width
+        };
+    }
 }
 
-// Export singleton instance and initialization function
 export const settingsManager = SettingsManager.getInstance();
-
-export function initializeSettingsManager(webSocket: WebSocketService): void {
-  settingsManager.initializeWebSocket(webSocket);
-}
\ No newline at end of file
diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
index 389de53a..6544ba65 100644
--- a/client/ui/ControlPanel.css
+++ b/client/ui/ControlPanel.css
@@ -1,17 +1,33 @@
+/* Control Panel Styles */
+
 .control-panel {
     position: fixed;
     top: 20px;
     right: 20px;
-    background: rgba(0, 0, 0, 0.85);
-    border-radius: 8px;
-    color: #fff;
-    font-family: Arial, sans-serif;
     width: 320px;
-    max-height: 90vh;
-    overflow-y: auto;
-    transition: transform 0.3s ease;
+    max-width: calc(100vw - 40px);
+    background: rgba(28, 28, 28, 0.95);
+    border-radius: 8px;
+    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
+    color: #ffffff;
+    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
     z-index: 1000;
-    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
+    transition: transform 0.3s ease;
+    transform: translateX(100%);
+    overflow: visible;
+}
+
+/* Ensure panel stays within viewport */
+@media (max-width: 360px) {
+    .control-panel {
+        right: 10px;
+        width: calc(100% - 20px);
+        max-width: 320px;
+    }
+}
+
+.control-panel.expanded {
+    transform: translateX(0);
 }
 
 .control-panel-header {
@@ -19,7 +35,6 @@
     justify-content: space-between;
     align-items: center;
     padding: 12px 16px;
-    background: rgba(0, 0, 0, 0.2);
     border-bottom: 1px solid rgba(255, 255, 255, 0.1);
 }
 
@@ -32,119 +47,212 @@
 .toggle-button {
     background: none;
     border: none;
-    color: #fff;
+    color: #ffffff;
     font-size: 20px;
     cursor: pointer;
     padding: 4px 8px;
-    transition: transform 0.3s ease;
-}
-
-.control-panel-content {
-    padding: 16px;
-    max-height: calc(90vh - 50px);
-    overflow-y: auto;
+    border-radius: 4px;
+    transition: background-color 0.2s;
 }
 
-.settings-group {
-    margin-bottom: 24px;
+.toggle-button:hover {
+    background: rgba(255, 255, 255, 0.1);
 }
 
-.settings-group h4 {
-    margin: 0 0 12px 0;
-    font-size: 14px;
-    color: #4a90e2;
-    font-weight: 500;
+/* Ensure content stays within panel bounds */
+.control-panel-content {
+    max-height: calc(100vh - 200px);
+    overflow-y: auto;
+    overflow-x: hidden; /* Prevent horizontal scroll */
+    padding: 16px;
 }
 
+/* Ensure inputs don't overflow */
 .setting-item {
     margin-bottom: 12px;
+    display: flex;
+    align-items: center;
+    gap: 12px;
+    flex-wrap: wrap; /* Allow wrapping on small screens */
 }
 
 .setting-item label {
-    display: block;
-    margin-bottom: 4px;
-    font-size: 12px;
-    color: #ccc;
+    flex: 1;
+    min-width: 100px; /* Ensure labels have minimum width */
+    font-size: 13px;
+    color: #e0e0e0;
 }
 
 .setting-item input[type="range"] {
-    width: 100%;
+    flex: 2;
+    min-width: 100px;
+    max-width: 150px;
     height: 4px;
-    background: #333;
-    border-radius: 2px;
     -webkit-appearance: none;
+    background: rgba(255, 255, 255, 0.2);
+    border-radius: 2px;
 }
 
 .setting-item input[type="range"]::-webkit-slider-thumb {
     -webkit-appearance: none;
     width: 12px;
     height: 12px;
-    background: #4a90e2;
+    background: #ffffff;
     border-radius: 50%;
     cursor: pointer;
-    transition: background 0.2s;
-}
-
-.setting-item input[type="range"]::-webkit-slider-thumb:hover {
-    background: #357abd;
 }
 
 .setting-item input[type="color"] {
-    width: 100%;
-    height: 30px;
-    padding: 2px;
-    border: 1px solid #444;
-    background: #222;
+    width: 32px;
+    height: 32px;
+    padding: 0;
+    border: none;
     border-radius: 4px;
     cursor: pointer;
 }
 
+.setting-item input[type="checkbox"] {
+    width: 16px;
+    height: 16px;
+    cursor: pointer;
+}
+
 .setting-item input[type="number"] {
-    width: 100%;
-    padding: 6px;
-    border: 1px solid #444;
-    background: #222;
-    color: #fff;
+    width: 60px;
+    padding: 4px 8px;
+    background: rgba(255, 255, 255, 0.1);
+    border: 1px solid rgba(255, 255, 255, 0.2);
     border-radius: 4px;
+    color: #ffffff;
 }
 
-.setting-item input[type="checkbox"] {
-    margin-right: 8px;
+.setting-item select {
+    padding: 4px 8px;
+    background: rgba(255, 255, 255, 0.1);
+    border: 1px solid rgba(255, 255, 255, 0.2);
+    border-radius: 4px;
+    color: #ffffff;
+    cursor: pointer;
+    max-width: 150px; /* Prevent select from being too wide */
 }
 
-.setting-item.disabled {
-    opacity: 0.5;
-    pointer-events: none;
+.setting-value {
+    min-width: 40px;
+    font-size: 12px;
+    color: #a0a0a0;
+    text-align: right;
+}
+
+.settings-group {
+    margin-bottom: 24px;
+}
+
+.settings-group h4 {
+    margin: 0 0 12px 0;
+    font-size: 14px;
+    font-weight: 500;
+    color: #a0a0a0;
 }
 
-.save-button {
-    width: 100%;
+.settings-actions {
+    display: flex;
+    gap: 12px;
+    margin-top: 24px;
+    padding-top: 16px;
+    border-top: 1px solid rgba(255, 255, 255, 0.1);
+}
+
+.primary-button,
+.secondary-button {
+    flex: 1;
     padding: 8px 16px;
-    background: #4a90e2;
-    color: #fff;
     border: none;
     border-radius: 4px;
-    cursor: pointer;
     font-size: 14px;
-    transition: background 0.2s;
+    font-weight: 500;
+    cursor: pointer;
+    transition: background-color 0.2s;
+    white-space: nowrap; /* Prevent button text from wrapping */
 }
 
-.save-button:hover {
+.primary-button {
+    background: #4a90e2;
+    color: #ffffff;
+}
+
+.primary-button:hover {
     background: #357abd;
 }
 
-/* Custom scrollbar */
+.primary-button:disabled {
+    background: #2c5c8f;
+    cursor: not-allowed;
+}
+
+.secondary-button {
+    background: rgba(255, 255, 255, 0.1);
+    color: #ffffff;
+}
+
+.secondary-button:hover {
+    background: rgba(255, 255, 255, 0.15);
+}
+
+.secondary-button:disabled {
+    background: rgba(255, 255, 255, 0.05);
+    cursor: not-allowed;
+}
+
+.settings-feedback {
+    margin: 8px 0;
+    padding: 8px 12px;
+    border-radius: 4px;
+    font-size: 13px;
+    animation: fadeIn 0.3s ease;
+}
+
+.settings-feedback.success {
+    background: rgba(39, 174, 96, 0.2);
+    color: #2ecc71;
+}
+
+.settings-feedback.error {
+    background: rgba(231, 76, 60, 0.2);
+    color: #e74c3c;
+}
+
+.settings-feedback.fade-out {
+    animation: fadeOut 0.3s ease;
+}
+
+.connection-status {
+    width: 8px;
+    height: 8px;
+    border-radius: 50%;
+    margin-right: 8px;
+}
+
+.connection-status.connected {
+    background: #2ecc71;
+}
+
+.connection-status.disconnected {
+    background: #e74c3c;
+}
+
+/* Scrollbar Styles */
 .control-panel-content::-webkit-scrollbar {
-    width: 6px;
+    width: 8px;
 }
 
 .control-panel-content::-webkit-scrollbar-track {
-    background: rgba(0, 0, 0, 0.1);
+    background: rgba(255, 255, 255, 0.1);
+    border-radius: 4px;
 }
 
 .control-panel-content::-webkit-scrollbar-thumb {
     background: rgba(255, 255, 255, 0.2);
-    border-radius: 3px;
+    border-radius: 4px;
 }
 
 .control-panel-content::-webkit-scrollbar-thumb:hover {
@@ -157,13 +265,68 @@
     to { opacity: 1; }
 }
 
-.control-panel {
-    animation: fadeIn 0.3s ease;
+@keyframes fadeOut {
+    from { opacity: 1; transform: translateY(0); }
+    to { opacity: 0; transform: translateY(10px); }
 }
 
-/* Responsive design */
-@media (max-width: 768px) {
-    .control-panel {
-        width: 280px;
-    }
+/* Tooltips */
+.setting-item label[data-tooltip] {
+    position: relative;
+    display: inline-flex;
+    align-items: center;
+}
+
+.setting-item label[data-tooltip]:hover::after {
+    content: attr(data-tooltip);
+    position: absolute;
+    left: 0;
+    top: 100%;
+    background: rgba(0, 0, 0, 0.9);
+    color: #fff;
+    padding: 6px 10px;
+    border-radius: 4px;
+    font-size: 11px;
+    white-space: nowrap;
+    z-index: 10;
+    pointer-events: none;
+    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+}
+
+/* Group headers */
+.settings-group h4::after {
+    content: '';
+    flex: 1;
+    height: 1px;
+    background: rgba(255, 255, 255, 0.1);
+    margin-left: 8px;
+}
+
+/* Disabled states */
+.setting-item.disabled {
+    opacity: 0.5;
+    pointer-events: none;
+}
+
+/* Sub-settings indentation */
+.sub-settings {
+    margin-left: 16px;
+    padding-left: 12px;
+    border-left: 2px solid rgba(74, 144, 226, 0.2);
+}
+
+/* Input focus states */
+.setting-item input:focus,
+.setting-item select:focus {
+    outline: none;
+    border-color: #4a90e2;
+}
+
+/* Hover effects */
+.setting-item:hover label {
+    color: #fff;
+}
+
+.setting-item:hover .setting-value {
+    color: #fff;
 }
diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
index e59b53de..1cc6d5f2 100644
--- a/client/ui/ControlPanel.ts
+++ b/client/ui/ControlPanel.ts
@@ -1,3 +1,7 @@
+/**
+ * Control panel for visualization settings
+ */
+
 import { VisualizationSettings } from '../core/types';
 import { settingsManager } from '../state/settings';
 import { createLogger } from '../core/utils';
@@ -8,16 +12,80 @@ export class ControlPanel {
     private container: HTMLDivElement;
     private settings: VisualizationSettings;
     private isExpanded = false;
+    private feedbackTimeout: number | null = null;
+    private statusIndicator: HTMLDivElement;
     
     constructor() {
         this.container = document.createElement('div');
         this.container.className = 'control-panel';
         this.settings = { ...settingsManager.getSettings() };
+        
+        // Create status indicator
+        this.statusIndicator = document.createElement('div');
+        this.statusIndicator.className = 'connection-status';
+        this.container.appendChild(this.statusIndicator);
+        
         this.initializeUI();
         this.setupEventListeners();
         
         // Subscribe to settings updates
         settingsManager.addSettingsListener(this.onSettingsUpdate.bind(this));
+        
+        // Monitor WebSocket connection
+        this.monitorConnection();
+    }
+
+    private showFeedback(message: string, type: 'success' | 'error' = 'success'): void {
+        // Clear any existing feedback
+        if (this.feedbackTimeout) {
+            clearTimeout(this.feedbackTimeout);
+            const existingFeedback = this.container.querySelector('.settings-feedback');
+            if (existingFeedback) {
+                existingFeedback.remove();
+            }
+        }
+
+        // Create feedback element
+        const feedback = document.createElement('div');
+        feedback.className = `settings-feedback ${type}`;
+        feedback.textContent = message;
+
+        // Add to container before actions
+        const actionsGroup = this.container.querySelector('.settings-actions');
+        if (actionsGroup) {
+            actionsGroup.insertAdjacentElement('beforebegin', feedback);
+        }
+
+        // Auto-remove after delay
+        this.feedbackTimeout = window.setTimeout(() => {
+            feedback.classList.add('fade-out');
+            setTimeout(() => feedback.remove(), 300);
+            this.feedbackTimeout = null;
+        }, 3000);
+    }
+
+    private monitorConnection(): void {
+        const updateStatus = (connected: boolean) => {
+            this.statusIndicator.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
+            this.statusIndicator.title = connected ? 'Connected to server' : 'Disconnected from server';
+        };
+
+        // Initial status
+        updateStatus(settingsManager.isConnected());
+
+        // Listen for connection changes
+        settingsManager.onConnectionChange((connected) => {
+            updateStatus(connected);
+            if (!connected) {
+                this.showFeedback('Lost connection to server', 'error');
+            }
+        });
+    }
+
+    private onSettingsUpdate(newSettings: VisualizationSettings): void {
+        this.settings = { ...newSettings };
+        this.updateUIValues();
+        logger.log('Settings updated from external source');
     }
 
     private initializeUI(): void {
@@ -30,8 +98,9 @@ export class ControlPanel {
                 <div class="settings-group">
                     <h4>Node Appearance</h4>
                     <div class="setting-item">
-                        <label for="nodeSize">Base Size</label>
-                        <input type="range" id="nodeSize" min="0.1" max="2" step="0.1" value="${this.settings.nodeSize}">
+                        <label for="nodeSize">Node Size</label>
+                        <input type="range" id="nodeSize" min="0.05" max="2" step="0.05" value="${this.settings.nodeSize}">
+                        <span class="setting-value">${this.settings.nodeSize.toFixed(2)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="nodeColor">Color</label>
@@ -40,26 +109,64 @@ export class ControlPanel {
                     <div class="setting-item">
                         <label for="nodeOpacity">Opacity</label>
                         <input type="range" id="nodeOpacity" min="0" max="1" step="0.1" value="${this.settings.nodeOpacity}">
+                        <span class="setting-value">${this.settings.nodeOpacity.toFixed(1)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="metalness">Metalness</label>
                         <input type="range" id="metalness" min="0" max="1" step="0.05" value="${this.settings.metalness}">
+                        <span class="setting-value">${this.settings.metalness.toFixed(2)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="roughness">Roughness</label>
                         <input type="range" id="roughness" min="0" max="1" step="0.05" value="${this.settings.roughness}">
+                        <span class="setting-value">${this.settings.roughness.toFixed(2)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="clearcoat">Clearcoat</label>
                         <input type="range" id="clearcoat" min="0" max="1" step="0.1" value="${this.settings.clearcoat}">
+                        <span class="setting-value">${this.settings.clearcoat.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableInstancing">Enable Instancing</label>
+                        <input type="checkbox" id="enableInstancing" ${this.settings.enableInstancing ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="materialType">Material Type</label>
+                        <select id="materialType" value="${this.settings.materialType}">
+                            <option value="physical">Physical</option>
+                            <option value="basic">Basic</option>
+                            <option value="phong">Phong</option>
+                        </select>
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Node Highlight</h4>
+                    <div class="setting-item">
+                        <label for="highlightColor">Highlight Color</label>
+                        <input type="color" id="highlightColor" value="${this.settings.highlightColor}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="highlightDuration">Duration (ms)</label>
+                        <input type="number" id="highlightDuration" min="0" max="2000" step="100" value="${this.settings.highlightDuration}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableHoverEffect">Enable Hover</label>
+                        <input type="checkbox" id="enableHoverEffect" ${this.settings.enableHoverEffect ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="hoverScale">Hover Scale</label>
+                        <input type="range" id="hoverScale" min="1" max="2" step="0.1" value="${this.settings.hoverScale}">
+                        <span class="setting-value">${this.settings.hoverScale.toFixed(1)}</span>
                     </div>
                 </div>
 
                 <div class="settings-group">
                     <h4>Edge Appearance</h4>
                     <div class="setting-item">
-                        <label for="edgeWidth">Width</label>
-                        <input type="range" id="edgeWidth" min="0.1" max="5" step="0.1" value="${this.settings.edgeWidth}">
+                        <label for="edgeWidth">Edge Width</label>
+                        <input type="range" id="edgeWidth" min="0.5" max="5" step="0.5" value="${this.settings.edgeWidth}">
+                        <span class="setting-value">${this.settings.edgeWidth.toFixed(1)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="edgeColor">Color</label>
@@ -68,70 +175,145 @@ export class ControlPanel {
                     <div class="setting-item">
                         <label for="edgeOpacity">Opacity</label>
                         <input type="range" id="edgeOpacity" min="0" max="1" step="0.1" value="${this.settings.edgeOpacity}">
+                        <span class="setting-value">${this.settings.edgeOpacity.toFixed(1)}</span>
                     </div>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableArrows" ${this.settings.enableArrows ? 'checked' : ''}>
-                            Show Arrows
-                        </label>
+                        <label for="enableArrows">Enable Arrows</label>
+                        <input type="checkbox" id="enableArrows" ${this.settings.enableArrows ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item arrow-setting ${this.settings.enableArrows ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="arrowSize">Arrow Size</label>
-                        <input type="range" id="arrowSize" min="0.1" max="1" step="0.05" value="${this.settings.arrowSize}">
+                        <input type="range" id="arrowSize" min="0.05" max="0.5" step="0.05" value="${this.settings.arrowSize}">
+                        <span class="setting-value">${this.settings.arrowSize.toFixed(2)}</span>
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Physics Settings</h4>
+                    <div class="setting-item">
+                        <label for="physicsEnabled">Enable Physics</label>
+                        <input type="checkbox" id="physicsEnabled" ${this.settings.physicsEnabled ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="attractionStrength">Attraction</label>
+                        <input type="range" id="attractionStrength" min="0" max="0.05" step="0.001" value="${this.settings.attractionStrength}">
+                        <span class="setting-value">${this.settings.attractionStrength.toFixed(3)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="repulsionStrength">Repulsion</label>
+                        <input type="range" id="repulsionStrength" min="0" max="3000" step="100" value="${this.settings.repulsionStrength}">
+                        <span class="setting-value">${this.settings.repulsionStrength.toFixed(0)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="springStrength">Spring</label>
+                        <input type="range" id="springStrength" min="0" max="0.05" step="0.001" value="${this.settings.springStrength}">
+                        <span class="setting-value">${this.settings.springStrength.toFixed(3)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="damping">Damping</label>
+                        <input type="range" id="damping" min="0" max="1" step="0.01" value="${this.settings.damping}">
+                        <span class="setting-value">${this.settings.damping.toFixed(2)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="maxVelocity">Max Velocity</label>
+                        <input type="range" id="maxVelocity" min="0.5" max="5" step="0.5" value="${this.settings.maxVelocity}">
+                        <span class="setting-value">${this.settings.maxVelocity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="collisionRadius">Collision Radius</label>
+                        <input type="range" id="collisionRadius" min="0.1" max="1" step="0.05" value="${this.settings.collisionRadius}">
+                        <span class="setting-value">${this.settings.collisionRadius.toFixed(2)}</span>
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Lighting</h4>
+                    <div class="setting-item">
+                        <label for="ambientLightIntensity">Ambient Light</label>
+                        <input type="range" id="ambientLightIntensity" min="0" max="2" step="0.1" value="${this.settings.ambientLightIntensity}">
+                        <span class="setting-value">${this.settings.ambientLightIntensity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="directionalLightIntensity">Directional Light</label>
+                        <input type="range" id="directionalLightIntensity" min="0" max="2" step="0.1" value="${this.settings.directionalLightIntensity}">
+                        <span class="setting-value">${this.settings.directionalLightIntensity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="environmentIntensity">Environment</label>
+                        <input type="range" id="environmentIntensity" min="0" max="2" step="0.1" value="${this.settings.environmentIntensity}">
+                        <span class="setting-value">${this.settings.environmentIntensity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="backgroundColor">Background Color</label>
+                        <input type="color" id="backgroundColor" value="${this.settings.backgroundColor}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableAmbientOcclusion">Ambient Occlusion</label>
+                        <input type="checkbox" id="enableAmbientOcclusion" ${this.settings.enableAmbientOcclusion ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableShadows">Enable Shadows</label>
+                        <input type="checkbox" id="enableShadows" ${this.settings.enableShadows ? 'checked' : ''}>
                     </div>
                 </div>
 
                 <div class="settings-group">
                     <h4>Visual Effects</h4>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableBloom" ${this.settings.enableBloom ? 'checked' : ''}>
-                            Enable Bloom
-                        </label>
+                        <label for="enableBloom">Enable Bloom</label>
+                        <input type="checkbox" id="enableBloom" ${this.settings.enableBloom ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="bloomIntensity">Bloom Intensity</label>
-                        <input type="range" id="bloomIntensity" min="0" max="2" step="0.1" value="${this.settings.bloomIntensity}">
+                        <input type="range" id="bloomIntensity" min="0" max="3" step="0.1" value="${this.settings.bloomIntensity}">
+                        <span class="setting-value">${this.settings.bloomIntensity.toFixed(1)}</span>
                     </div>
-                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="bloomRadius">Bloom Radius</label>
-                        <input type="range" id="bloomRadius" min="0" max="2" step="0.1" value="${this.settings.bloomRadius}">
+                        <input type="range" id="bloomRadius" min="0" max="1" step="0.1" value="${this.settings.bloomRadius}">
+                        <span class="setting-value">${this.settings.bloomRadius.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="nodeBloomStrength">Node Bloom</label>
+                        <input type="range" id="nodeBloomStrength" min="0" max="1" step="0.1" value="${this.settings.nodeBloomStrength}">
+                        <span class="setting-value">${this.settings.nodeBloomStrength.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="edgeBloomStrength">Edge Bloom</label>
+                        <input type="range" id="edgeBloomStrength" min="0" max="1" step="0.1" value="${this.settings.edgeBloomStrength}">
+                        <span class="setting-value">${this.settings.edgeBloomStrength.toFixed(1)}</span>
                     </div>
                 </div>
 
                 <div class="settings-group">
-                    <h4>Animations</h4>
+                    <h4>Motion & Animation</h4>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableNodeAnimations" ${this.settings.enableNodeAnimations ? 'checked' : ''}>
-                            Node Animations
-                        </label>
+                        <label for="enableNodeAnimations">Node Animations</label>
+                        <input type="checkbox" id="enableNodeAnimations" ${this.settings.enableNodeAnimations ? 'checked' : ''}>
                     </div>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableMotionBlur" ${this.settings.enableMotionBlur ? 'checked' : ''}>
-                            Motion Blur
-                        </label>
+                        <label for="enableMotionBlur">Motion Blur</label>
+                        <input type="checkbox" id="enableMotionBlur" ${this.settings.enableMotionBlur ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item motion-setting ${this.settings.enableMotionBlur ? '' : 'disabled'}">
-                        <label for="motionBlurStrength">Motion Blur Strength</label>
+                    <div class="setting-item">
+                        <label for="motionBlurStrength">Blur Strength</label>
                         <input type="range" id="motionBlurStrength" min="0" max="1" step="0.1" value="${this.settings.motionBlurStrength}">
+                        <span class="setting-value">${this.settings.motionBlurStrength.toFixed(1)}</span>
                     </div>
                 </div>
 
                 <div class="settings-group">
                     <h4>Labels</h4>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="showLabels" ${this.settings.showLabels ? 'checked' : ''}>
-                            Show Labels
-                        </label>
+                        <label for="showLabels">Show Labels</label>
+                        <input type="checkbox" id="showLabels" ${this.settings.showLabels ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="labelSize">Label Size</label>
                         <input type="range" id="labelSize" min="0.5" max="2" step="0.1" value="${this.settings.labelSize}">
+                        <span class="setting-value">${this.settings.labelSize.toFixed(1)}</span>
                     </div>
-                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="labelColor">Label Color</label>
                         <input type="color" id="labelColor" value="${this.settings.labelColor}">
                     </div>
@@ -141,176 +323,18 @@ export class ControlPanel {
                     <h4>Performance</h4>
                     <div class="setting-item">
                         <label for="maxFps">Max FPS</label>
-                        <input type="number" id="maxFps" min="30" max="144" value="${this.settings.maxFps}">
+                        <input type="number" id="maxFps" min="30" max="144" step="1" value="${this.settings.maxFps}">
                     </div>
-                </div>
-
-                <div class="settings-group">
-                    <h4>AR Settings</h4>
-                    <div class="setting-item">
-                        <label>Scene Understanding</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enablePlaneDetection" ${this.settings.enablePlaneDetection ? 'checked' : ''}>
-                                    Plane Detection
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableSceneUnderstanding" ${this.settings.enableSceneUnderstanding ? 'checked' : ''}>
-                                    Scene Understanding
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="showPlaneOverlay" ${this.settings.showPlaneOverlay ? 'checked' : ''}>
-                                    Show Plane Overlay
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="planeOpacity">Plane Opacity</label>
-                                <input type="range" id="planeOpacity" min="0" max="1" step="0.1" value="${this.settings.planeOpacity}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="planeColor">Plane Color</label>
-                                <input type="color" id="planeColor" value="${this.settings.planeColor}">
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableLightEstimation" ${this.settings.enableLightEstimation ? 'checked' : ''}>
-                                    Light Estimation
-                                </label>
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Hand Tracking</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableHandTracking" ${this.settings.enableHandTracking ? 'checked' : ''}>
-                                    Enable Hand Tracking
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="handMeshEnabled" ${this.settings.handMeshEnabled ? 'checked' : ''}>
-                                    Show Hand Mesh
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="handMeshColor">Hand Mesh Color</label>
-                                <input type="color" id="handMeshColor" value="${this.settings.handMeshColor}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="handMeshOpacity">Hand Mesh Opacity</label>
-                                <input type="range" id="handMeshOpacity" min="0" max="1" step="0.1" value="${this.settings.handMeshOpacity}">
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="handRayEnabled" ${this.settings.handRayEnabled ? 'checked' : ''}>
-                                    Show Hand Ray
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="handRayColor">Hand Ray Color</label>
-                                <input type="color" id="handRayColor" value="${this.settings.handRayColor}">
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Gesture Controls</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label for="gestureSmoothing">Gesture Smoothing</label>
-                                <input type="range" id="gestureSmoothing" min="0" max="1" step="0.1" value="${this.settings.gestureSmoothing}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="pinchThreshold">Pinch Threshold</label>
-                                <input type="range" id="pinchThreshold" min="0" max="0.05" step="0.001" value="${this.settings.pinchThreshold}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="dragThreshold">Drag Threshold</label>
-                                <input type="range" id="dragThreshold" min="0" max="0.1" step="0.01" value="${this.settings.dragThreshold}">
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Haptics</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableHaptics" ${this.settings.enableHaptics ? 'checked' : ''}>
-                                    Enable Haptics
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="hapticIntensity">Haptic Intensity</label>
-                                <input type="range" id="hapticIntensity" min="0" max="1" step="0.1" value="${this.settings.hapticIntensity}">
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Room Scale</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="roomScale" ${this.settings.roomScale ? 'checked' : ''}>
-                                    Room Scale Mode
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="snapToFloor" ${this.settings.snapToFloor ? 'checked' : ''}>
-                                    Snap to Floor
-                                </label>
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Passthrough</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label for="passthroughOpacity">Opacity</label>
-                                <input type="range" id="passthroughOpacity" min="0" max="1" step="0.1" value="${this.settings.passthroughOpacity}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="passthroughBrightness">Brightness</label>
-                                <input type="range" id="passthroughBrightness" min="0" max="2" step="0.1" value="${this.settings.passthroughBrightness}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="passthroughContrast">Contrast</label>
-                                <input type="range" id="passthroughContrast" min="0" max="2" step="0.1" value="${this.settings.passthroughContrast}">
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enablePassthroughPortal" ${this.settings.enablePassthroughPortal ? 'checked' : ''}>
-                                    Enable Portal
-                                </label>
-                            </div>
-                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-                                <label for="portalSize">Portal Size</label>
-                                <input type="range" id="portalSize" min="0.1" max="2" step="0.1" value="${this.settings.portalSize}">
-                            </div>
-                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-                                <label for="portalEdgeColor">Portal Edge Color</label>
-                                <input type="color" id="portalEdgeColor" value="${this.settings.portalEdgeColor}">
-                            </div>
-                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-                                <label for="portalEdgeWidth">Portal Edge Width</label>
-                                <input type="range" id="portalEdgeWidth" min="0.001" max="0.05" step="0.001" value="${this.settings.portalEdgeWidth}">
-                            </div>
-                        </div>
+                    <div class="setting-item">
+                        <label for="enableAntialiasing">Antialiasing</label>
+                        <input type="checkbox" id="enableAntialiasing" ${this.settings.enableAntialiasing ? 'checked' : ''}>
                     </div>
                 </div>
 
-                <button class="save-button">Save Changes</button>
+                <div class="settings-actions">
+                    <button id="saveSettings" class="primary-button">Save Settings</button>
+                    <button id="resetSettings" class="secondary-button">Reset to Defaults</button>
+                </div>
             </div>
         `;
 
@@ -326,190 +350,200 @@ export class ControlPanel {
         });
 
         // Save button
-        const saveButton = this.container.querySelector('.save-button');
-        saveButton?.addEventListener('click', this.saveSettings.bind(this));
-
-        // Node settings
-        this.setupInputListener('nodeSize', 'number');
-        this.setupInputListener('nodeColor', 'string');
-        this.setupInputListener('nodeOpacity', 'number');
-        this.setupInputListener('metalness', 'number');
-        this.setupInputListener('roughness', 'number');
-        this.setupInputListener('clearcoat', 'number');
+        const saveButton = this.container.querySelector('#saveSettings');
+        saveButton?.addEventListener('click', () => this.saveSettings());
+
+        // Reset button
+        const resetButton = this.container.querySelector('#resetSettings');
+        resetButton?.addEventListener('click', () => this.resetSettings());
+
+        // Node appearance settings
+        this.setupRangeListener('nodeSize', 'nodeSize');
+        this.setupColorListener('nodeColor', 'nodeColor');
+        this.setupRangeListener('nodeOpacity', 'nodeOpacity');
+        this.setupRangeListener('metalness', 'metalness');
+        this.setupRangeListener('roughness', 'roughness');
+        this.setupRangeListener('clearcoat', 'clearcoat');
+        this.setupCheckboxListener('enableInstancing', 'enableInstancing');
+        this.setupSelectListener('materialType', 'materialType');
+
+        // Node highlight settings
+        this.setupColorListener('highlightColor', 'highlightColor');
+        this.setupNumberListener('highlightDuration', 'highlightDuration');
+        this.setupCheckboxListener('enableHoverEffect', 'enableHoverEffect');
+        this.setupRangeListener('hoverScale', 'hoverScale');
 
         // Edge settings
-        this.setupInputListener('edgeWidth', 'number');
-        this.setupInputListener('edgeColor', 'string');
-        this.setupInputListener('edgeOpacity', 'number');
-        
-        const arrowsCheckbox = this.container.querySelector('#enableArrows') as HTMLInputElement;
-        arrowsCheckbox?.addEventListener('change', () => {
-            const arrowSettings = this.container.querySelectorAll('.arrow-setting');
-            arrowSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !arrowsCheckbox.checked);
-            });
-            this.settings.enableArrows = arrowsCheckbox.checked;
-        });
-        this.setupInputListener('arrowSize', 'number');
-
-        // Bloom settings
-        const bloomCheckbox = this.container.querySelector('#enableBloom') as HTMLInputElement;
-        bloomCheckbox?.addEventListener('change', () => {
-            const bloomSettings = this.container.querySelectorAll('.bloom-setting');
-            bloomSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !bloomCheckbox.checked);
-            });
-            this.settings.enableBloom = bloomCheckbox.checked;
-        });
-        this.setupInputListener('bloomIntensity', 'number');
-        this.setupInputListener('bloomRadius', 'number');
-
-        // Animation settings
-        const nodeAnimCheckbox = this.container.querySelector('#enableNodeAnimations') as HTMLInputElement;
-        nodeAnimCheckbox?.addEventListener('change', () => {
-            this.settings.enableNodeAnimations = nodeAnimCheckbox.checked;
-        });
-
-        const motionBlurCheckbox = this.container.querySelector('#enableMotionBlur') as HTMLInputElement;
-        motionBlurCheckbox?.addEventListener('change', () => {
-            const motionSettings = this.container.querySelectorAll('.motion-setting');
-            motionSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !motionBlurCheckbox.checked);
-            });
-            this.settings.enableMotionBlur = motionBlurCheckbox.checked;
-        });
-        this.setupInputListener('motionBlurStrength', 'number');
+        this.setupRangeListener('edgeWidth', 'edgeWidth');
+        this.setupColorListener('edgeColor', 'edgeColor');
+        this.setupRangeListener('edgeOpacity', 'edgeOpacity');
+        this.setupCheckboxListener('enableArrows', 'enableArrows');
+        this.setupRangeListener('arrowSize', 'arrowSize');
+
+        // Physics settings
+        this.setupCheckboxListener('physicsEnabled', 'physicsEnabled');
+        this.setupRangeListener('attractionStrength', 'attractionStrength');
+        this.setupRangeListener('repulsionStrength', 'repulsionStrength');
+        this.setupRangeListener('springStrength', 'springStrength');
+        this.setupRangeListener('damping', 'damping');
+        this.setupRangeListener('maxVelocity', 'maxVelocity');
+        this.setupRangeListener('collisionRadius', 'collisionRadius');
+
+        // Lighting settings
+        this.setupRangeListener('ambientLightIntensity', 'ambientLightIntensity');
+        this.setupRangeListener('directionalLightIntensity', 'directionalLightIntensity');
+        this.setupRangeListener('environmentIntensity', 'environmentIntensity');
+        this.setupColorListener('backgroundColor', 'backgroundColor');
+        this.setupCheckboxListener('enableAmbientOcclusion', 'enableAmbientOcclusion');
+        this.setupCheckboxListener('enableShadows', 'enableShadows');
+
+        // Visual effects settings
+        this.setupCheckboxListener('enableBloom', 'enableBloom');
+        this.setupRangeListener('bloomIntensity', 'bloomIntensity');
+        this.setupRangeListener('bloomRadius', 'bloomRadius');
+        this.setupRangeListener('nodeBloomStrength', 'nodeBloomStrength');
+        this.setupRangeListener('edgeBloomStrength', 'edgeBloomStrength');
+
+        // Motion & animation settings
+        this.setupCheckboxListener('enableNodeAnimations', 'enableNodeAnimations');
+        this.setupCheckboxListener('enableMotionBlur', 'enableMotionBlur');
+        this.setupRangeListener('motionBlurStrength', 'motionBlurStrength');
 
         // Label settings
-        const labelCheckbox = this.container.querySelector('#showLabels') as HTMLInputElement;
-        labelCheckbox?.addEventListener('change', () => {
-            const labelSettings = this.container.querySelectorAll('.label-setting');
-            labelSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !labelCheckbox.checked);
-            });
-            this.settings.showLabels = labelCheckbox.checked;
-        });
-        this.setupInputListener('labelSize', 'number');
-        this.setupInputListener('labelColor', 'string');
+        this.setupCheckboxListener('showLabels', 'showLabels');
+        this.setupRangeListener('labelSize', 'labelSize');
+        this.setupColorListener('labelColor', 'labelColor');
 
         // Performance settings
-        this.setupInputListener('maxFps', 'number');
-
-        // AR settings
-        const planeDetectionCheckbox = this.container.querySelector('#enablePlaneDetection') as HTMLInputElement;
-        planeDetectionCheckbox?.addEventListener('change', () => {
-            this.settings.enablePlaneDetection = planeDetectionCheckbox.checked;
-        });
-
-        const sceneUnderstandingCheckbox = this.container.querySelector('#enableSceneUnderstanding') as HTMLInputElement;
-        sceneUnderstandingCheckbox?.addEventListener('change', () => {
-            this.settings.enableSceneUnderstanding = sceneUnderstandingCheckbox.checked;
-        });
-
-        const showPlaneOverlayCheckbox = this.container.querySelector('#showPlaneOverlay') as HTMLInputElement;
-        showPlaneOverlayCheckbox?.addEventListener('change', () => {
-            this.settings.showPlaneOverlay = showPlaneOverlayCheckbox.checked;
-        });
-
-        this.setupInputListener('planeOpacity', 'number');
-        this.setupInputListener('planeColor', 'string');
-
-        const lightEstimationCheckbox = this.container.querySelector('#enableLightEstimation') as HTMLInputElement;
-        lightEstimationCheckbox?.addEventListener('change', () => {
-            this.settings.enableLightEstimation = lightEstimationCheckbox.checked;
-        });
-
-        const handTrackingCheckbox = this.container.querySelector('#enableHandTracking') as HTMLInputElement;
-        handTrackingCheckbox?.addEventListener('change', () => {
-            this.settings.enableHandTracking = handTrackingCheckbox.checked;
-        });
-
-        const handMeshEnabledCheckbox = this.container.querySelector('#handMeshEnabled') as HTMLInputElement;
-        handMeshEnabledCheckbox?.addEventListener('change', () => {
-            this.settings.handMeshEnabled = handMeshEnabledCheckbox.checked;
-        });
-
-        this.setupInputListener('handMeshColor', 'string');
-        this.setupInputListener('handMeshOpacity', 'number');
-
-        const handRayEnabledCheckbox = this.container.querySelector('#handRayEnabled') as HTMLInputElement;
-        handRayEnabledCheckbox?.addEventListener('change', () => {
-            this.settings.handRayEnabled = handRayEnabledCheckbox.checked;
-        });
-
-        this.setupInputListener('handRayColor', 'string');
-
-        this.setupInputListener('gestureSmoothing', 'number');
-        this.setupInputListener('pinchThreshold', 'number');
-        this.setupInputListener('dragThreshold', 'number');
-
-        const hapticsCheckbox = this.container.querySelector('#enableHaptics') as HTMLInputElement;
-        hapticsCheckbox?.addEventListener('change', () => {
-            this.settings.enableHaptics = hapticsCheckbox.checked;
-        });
-
-        this.setupInputListener('hapticIntensity', 'number');
+        this.setupNumberListener('maxFps', 'maxFps');
+        this.setupCheckboxListener('enableAntialiasing', 'enableAntialiasing');
+    }
 
-        const roomScaleCheckbox = this.container.querySelector('#roomScale') as HTMLInputElement;
-        roomScaleCheckbox?.addEventListener('change', () => {
-            this.settings.roomScale = roomScaleCheckbox.checked;
-        });
+    private setupRangeListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('input', () => {
+                (this.settings[settingKey] as number) = parseFloat(element.value);
+                const valueDisplay = element.parentElement?.querySelector('.setting-value');
+                if (valueDisplay) {
+                    valueDisplay.textContent = parseFloat(element.value).toFixed(
+                        element.step.includes('.') ? element.step.split('.')[1].length : 0
+                    );
+                }
+                settingsManager.updateSettings(this.settings);
+            });
+        }
+    }
 
-        const snapToFloorCheckbox = this.container.querySelector('#snapToFloor') as HTMLInputElement;
-        snapToFloorCheckbox?.addEventListener('change', () => {
-            this.settings.snapToFloor = snapToFloorCheckbox.checked;
-        });
+    private setupColorListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('input', () => {
+                (this.settings[settingKey] as string) = element.value;
+                settingsManager.updateSettings(this.settings);
+            });
+        }
+    }
 
-        this.setupInputListener('passthroughOpacity', 'number');
-        this.setupInputListener('passthroughBrightness', 'number');
-        this.setupInputListener('passthroughContrast', 'number');
+    private setupCheckboxListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('change', () => {
+                (this.settings[settingKey] as boolean) = element.checked;
+                settingsManager.updateSettings(this.settings);
+            });
+        }
+    }
 
-        const passthroughPortalCheckbox = this.container.querySelector('#enablePassthroughPortal') as HTMLInputElement;
-        passthroughPortalCheckbox?.addEventListener('change', () => {
-            const portalSettings = this.container.querySelectorAll('.portal-setting');
-            portalSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !passthroughPortalCheckbox.checked);
+    private setupNumberListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('input', () => {
+                (this.settings[settingKey] as number) = parseInt(element.value);
+                settingsManager.updateSettings(this.settings);
             });
-            this.settings.enablePassthroughPortal = passthroughPortalCheckbox.checked;
-        });
+        }
+    }
 
-        this.setupInputListener('portalSize', 'number');
-        this.setupInputListener('portalEdgeColor', 'string');
-        this.setupInputListener('portalEdgeWidth', 'number');
+    private setupSelectListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLSelectElement;
+        if (element) {
+            element.addEventListener('change', () => {
+                (this.settings[settingKey] as string) = element.value;
+                settingsManager.updateSettings(this.settings);
+            });
+        }
     }
 
-    private setupInputListener(id: string, type: 'number' | 'string'): void {
-        const input = this.container.querySelector(`#${id}`) as HTMLInputElement;
-        input?.addEventListener('input', () => {
-            const value = type === 'number' ? parseFloat(input.value) : input.value;
-            (this.settings as any)[id] = value;
+    private updateUIValues(): void {
+        // Update all input values to match current settings
+        Object.entries(this.settings).forEach(([key, value]) => {
+            const element = this.container.querySelector(`#${key}`) as HTMLInputElement | HTMLSelectElement;
+            if (element) {
+                if (element instanceof HTMLInputElement) {
+                    if (element.type === 'checkbox') {
+                        element.checked = value as boolean;
+                    } else if (element.type === 'range' || element.type === 'number') {
+                        element.value = value.toString();
+                        const valueDisplay = element.parentElement?.querySelector('.setting-value');
+                        if (valueDisplay) {
+                            valueDisplay.textContent = typeof value === 'number' 
+                                ? value.toFixed(element.step.includes('.') ? element.step.split('.')[1].length : 0)
+                                : value.toString();
+                        }
+                    } else {
+                        element.value = value as string;
+                    }
+                } else {
+                    element.value = value as string;
+                }
+            }
         });
     }
 
     private async saveSettings(): Promise<void> {
+        const saveButton = this.container.querySelector('#saveSettings') as HTMLButtonElement;
+        if (saveButton) {
+            saveButton.disabled = true;
+            saveButton.textContent = 'Saving...';
+        }
+
         try {
-            await settingsManager.updateSettings(this.settings);
+            await settingsManager.saveSettings();
+            this.showFeedback('Settings saved successfully');
             logger.log('Settings saved successfully');
         } catch (error) {
+            this.showFeedback('Failed to save settings', 'error');
             logger.error('Failed to save settings:', error);
+        } finally {
+            if (saveButton) {
+                saveButton.disabled = false;
+                saveButton.textContent = 'Save Settings';
+            }
         }
     }
 
-    private onSettingsUpdate(newSettings: VisualizationSettings): void {
-        this.settings = { ...newSettings };
-        this.updateUIValues();
-    }
+    private resetSettings(): void {
+        const resetButton = this.container.querySelector('#resetSettings') as HTMLButtonElement;
+        if (resetButton) {
+            resetButton.disabled = true;
+            resetButton.textContent = 'Resetting...';
+        }
 
-    private updateUIValues(): void {
-        Object.entries(this.settings).forEach(([key, value]) => {
-            const input = this.container.querySelector(`#${key}`) as HTMLInputElement;
-            if (input) {
-                if (input.type === 'checkbox') {
-                    input.checked = value as boolean;
-                } else {
-                    input.value = value.toString();
-                }
+        try {
+            settingsManager.resetToDefaults();
+            this.showFeedback('Settings reset to defaults');
+            logger.log('Settings reset to defaults');
+        } catch (error) {
+            this.showFeedback('Failed to reset settings', 'error');
+            logger.error('Failed to reset settings:', error);
+        } finally {
+            if (resetButton) {
+                resetButton.disabled = false;
+                resetButton.textContent = 'Reset to Defaults';
             }
-        });
+        }
     }
+
+    // ... [Rest of the code remains the same] ...
 }
diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
index ca0c93b1..e287c17e 100644
--- a/client/websocket/websocketService.ts
+++ b/client/websocket/websocketService.ts
@@ -14,7 +14,6 @@ import {
   EnableBinaryUpdatesMessage,
   PingMessage,
   transformGraphData,
-  transformNodeData,
 } from '../core/types';
 import { WS_RECONNECT_INTERVAL, WS_MESSAGE_QUEUE_SIZE } from '../core/constants';
 import { createLogger } from '../core/utils';
@@ -222,8 +221,8 @@ export class WebSocketService {
       return;
     }
 
-    // Notify handlers with validated Float32Array
-    this.notifyHandlers('binaryPositionUpdate', { nodes: floatArray });
+    // Pass the Float32Array directly to handlers
+    this.notifyHandlers('binaryPositionUpdate', floatArray);
   }
 
   private handleJsonMessage(data: string): void {
@@ -244,15 +243,7 @@ export class WebSocketService {
       }
       case 'binaryPositionUpdate': {
         const binaryUpdate = rawMessage as RawBinaryPositionUpdateMessage;
-        const transformedData = {
-          type: 'binaryPositionUpdate' as const,
-          data: {
-            nodes: binaryUpdate.data.nodes.map(node => ({
-              nodeId: node.nodeId,
-              data: transformNodeData(node.data)
-            }))
-          }
-        };
+        const transformedData = this.transformBinaryData(binaryUpdate);
         this.handleBinaryUpdate(transformedData);
         break;
       }
@@ -268,6 +259,21 @@ export class WebSocketService {
     }
   }
 
+  private transformBinaryData(data: any): BinaryPositionUpdateMessage {
+    return {
+      type: 'binaryPositionUpdate',
+      data: {
+        nodes: data.nodes.map((node: any) => ({
+          nodeId: node.nodeId,
+          data: {
+            position: node.data.position,
+            velocity: node.data.velocity
+          }
+        }))
+      }
+    };
+  }
+
   private handleInitialData(message: InitialDataMessage): void {
     this.notifyHandlers('initialData', message.data);
     
diff --git a/diff.patch b/diff.patch
deleted file mode 100644
index 38d0c0b9..00000000
--- a/diff.patch
+++ /dev/null
@@ -1,2721 +0,0 @@
-diff --git a/client/core/NodeManager.ts b/client/core/NodeManager.ts
-new file mode 100644
-index 00000000..3086c172
---- /dev/null
-+++ b/client/core/NodeManager.ts
-@@ -0,0 +1,70 @@
-+import { Node, Vector3 } from './types';
-+import * as THREE from 'three';
-+import { SceneManager } from '../rendering/scene';
-+
-+export class NodeManager {
-+  private static instance: NodeManager | null = null;
-+  private nodeMatrices: Map<string, THREE.Matrix4> = new Map();
-+  private nodes: Map<string, Node> = new Map();
-+  private tempVector = new THREE.Vector3();
-+  private sceneManager: SceneManager;
-+
-+  private constructor(sceneManager: SceneManager) {
-+    this.sceneManager = sceneManager;
-+  }
-+
-+  public static getInstance(sceneManager: SceneManager): NodeManager {
-+    if (!NodeManager.instance) {
-+      NodeManager.instance = new NodeManager(sceneManager);
-+    }
-+    return NodeManager.instance;
-+  }
-+
-+  public addNode(node: Node): void {
-+    this.nodes.set(node.id, node);
-+    this.nodeMatrices.set(node.id, new THREE.Matrix4());
-+    this.updateNodePositionInternal(node.id, node.data.position);
-+  }
-+
-+  public removeNode(nodeId: string): void {
-+    this.nodes.delete(nodeId);
-+    this.nodeMatrices.delete(nodeId);
-+  }
-+
-+  public updateNodePositions(delta: Vector3): void {
-+    for (const node of this.nodes.values()) {
-+      const newPosition = {
-+        x: node.data.position.x + delta.x,
-+        y: node.data.position.y + delta.y,
-+        z: node.data.position.z + delta.z
-+      };
-+      this.updateNodePositionInternal(node.id, newPosition);
-+      node.data.position = newPosition;
-+    }
-+  }
-+
-+  private updateNodePositionInternal(nodeId: string, position: Vector3): void {
-+    const matrix = this.nodeMatrices.get(nodeId);
-+    if (matrix) {
-+      this.tempVector.set(position.x, position.y, position.z);
-+      matrix.identity();
-+      matrix.elements[12] = this.tempVector.x;
-+      matrix.elements[13] = this.tempVector.y;
-+      matrix.elements[14] = this.tempVector.z;
-+    }
-+  }
-+
-+  public getNodeMatrix(nodeId: string): THREE.Matrix4 | undefined {
-+    return this.nodeMatrices.get(nodeId);
-+  }
-+
-+  public getNodes(): Node[] {
-+    return Array.from(this.nodes.values());
-+  }
-+
-+  public dispose(): void {
-+    this.nodes.clear();
-+    this.nodeMatrices.clear();
-+    NodeManager.instance = null;
-+  }
-+}
-diff --git a/client/core/types.ts b/client/core/types.ts
-index b1512a69..86ecd1e6 100644
---- a/client/core/types.ts
-+++ b/client/core/types.ts
-@@ -99,31 +99,161 @@ export interface VisualizationSettings {
-   nodeSize: number;
-   nodeColor: string;
-   nodeOpacity: number;
--  nodeHighlightColor: string;
--  
-+  metalness: number;
-+  roughness: number;
-+  clearcoat: number;
-+
-   // Edge appearance
-   edgeWidth: number;
-   edgeColor: string;
-   edgeOpacity: number;
--  
-+  enableArrows: boolean;
-+  arrowSize: number;
-+
-   // Visual effects
-   enableBloom: boolean;
-   bloomIntensity: number;
--  bloomThreshold: number;
-   bloomRadius: number;
--  
--  // Performance
--  maxFps: number;
--  updateThrottle: number;
-+  enableNodeAnimations: boolean;
-+  enableMotionBlur: boolean;
-+  motionBlurStrength: number;
- 
-   // Labels
-   showLabels: boolean;
-   labelSize: number;
-   labelColor: string;
- 
--  // XR specific
--  xrControllerVibration: boolean;
--  xrControllerHapticIntensity: number;
-+  // Performance
-+  maxFps: number;
-+
-+  // AR Settings (Meta Quest 3)
-+  // Scene Understanding
-+  enablePlaneDetection: boolean;
-+  enableSceneUnderstanding: boolean;
-+  showPlaneOverlay: boolean;
-+  planeOpacity: number;
-+  planeColor: string;
-+  enableLightEstimation: boolean;
-+  
-+  // Hand Tracking
-+  enableHandTracking: boolean;
-+  handMeshEnabled: boolean;
-+  handMeshColor: string;
-+  handMeshOpacity: number;
-+  handRayEnabled: boolean;
-+  handRayColor: string;
-+  handRayWidth: number;
-+  handPointSize: number;
-+  
-+  // Gesture Controls
-+  gestureSmoothing: number;
-+  pinchThreshold: number;
-+  dragThreshold: number;
-+  rotationThreshold: number;
-+  
-+  // Haptics
-+  enableHaptics: boolean;
-+  hapticIntensity: number;
-+  
-+  // Room Scale
-+  roomScale: boolean;
-+  snapToFloor: boolean;
-+  
-+  // Passthrough
-+  passthroughOpacity: number;
-+  passthroughBrightness: number;
-+  passthroughContrast: number;
-+  enablePassthroughPortal: boolean;
-+  portalSize: number;
-+  portalEdgeColor: string;
-+  portalEdgeWidth: number;
-+}
-+
-+export interface BinaryNodeUpdate {
-+  nodeId: string;
-+  data: NodeData;
-+}
-+
-+export interface BinaryPositionUpdateMessage {
-+  type: 'binaryPositionUpdate';
-+  data: {
-+    nodes: BinaryNodeUpdate[];
-+  };
-+}
-+
-+// Other message types
-+export interface RequestInitialDataMessage {
-+  type: 'requestInitialData';
-+}
-+
-+export interface EnableBinaryUpdatesMessage {
-+  type: 'enableBinaryUpdates';
-+}
-+
-+export interface SettingsUpdateMessage {
-+  type: 'settingsUpdated';
-+  data: {
-+    settings: VisualizationSettings;
-+  };
-+}
-+
-+export interface UpdateSettingsMessage {
-+  type: 'updateSettings';
-+  data: {
-+    settings: Partial<VisualizationSettings>;
-+  };
-+}
-+
-+export interface PingMessage {
-+  type: 'ping';
-+}
-+
-+export interface PongMessage {
-+  type: 'pong';
-+}
-+
-+// Union types for messages
-+export type RawWebSocketMessage =
-+  | RawInitialDataMessage
-+  | RawBinaryPositionUpdateMessage
-+  | SettingsUpdateMessage
-+  | UpdateSettingsMessage
-+  | RequestInitialDataMessage
-+  | EnableBinaryUpdatesMessage
-+  | PingMessage
-+  | PongMessage;
-+
-+export type WebSocketMessage =
-+  | InitialDataMessage
-+  | BinaryPositionUpdateMessage
-+  | SettingsUpdateMessage
-+  | UpdateSettingsMessage
-+  | RequestInitialDataMessage
-+  | EnableBinaryUpdatesMessage
-+  | PingMessage
-+  | PongMessage;
-+
-+// Platform detection types
-+export type Platform = 'browser' | 'quest';
-+
-+export interface PlatformCapabilities {
-+  xrSupported: boolean;
-+  webglSupported: boolean;
-+  websocketSupported: boolean;
-+}
-+
-+// Message queue types
-+export interface QueuedMessage {
-+  data: ArrayBuffer;
-+  timestamp: number;
-+}
-+
-+// Debug types
-+export interface NetworkDebugMessage {
-+  direction: 'in' | 'out';
-+  type: 'binary' | 'json';
-+  timestamp: number;
-+  data: any;
- }
- 
- // Transform functions
-@@ -221,90 +351,3 @@ export interface InitialDataMessage {
-     graph: GraphData;
-   };
- }
--
--export interface BinaryNodeUpdate {
--  nodeId: string;
--  data: NodeData;
--}
--
--export interface BinaryPositionUpdateMessage {
--  type: 'binaryPositionUpdate';
--  data: {
--    nodes: BinaryNodeUpdate[];
--  };
--}
--
--// Other message types
--export interface RequestInitialDataMessage {
--  type: 'requestInitialData';
--}
--
--export interface EnableBinaryUpdatesMessage {
--  type: 'enableBinaryUpdates';
--}
--
--export interface SettingsUpdateMessage {
--  type: 'settingsUpdated';
--data: {
--    settings: VisualizationSettings;
--  };
--}
--
--export interface UpdateSettingsMessage {
--  type: 'updateSettings';
--data: {
--    settings: Partial<VisualizationSettings>;
--  };
--}
--
--export interface PingMessage {
--  type: 'ping';
--}
--
--export interface PongMessage {
--  type: 'pong';
--}
--
--// Union types for messages
--export type RawWebSocketMessage =
--  | RawInitialDataMessage
--  | RawBinaryPositionUpdateMessage
--  | SettingsUpdateMessage
--  | UpdateSettingsMessage
--  | RequestInitialDataMessage
--  | EnableBinaryUpdatesMessage
--  | PingMessage
--  | PongMessage;
--
--export type WebSocketMessage =
--  | InitialDataMessage
--  | BinaryPositionUpdateMessage
--  | SettingsUpdateMessage
--  | UpdateSettingsMessage
--  | RequestInitialDataMessage
--  | EnableBinaryUpdatesMessage
--  | PingMessage
--  | PongMessage;
--
--// Platform detection types
--export type Platform = 'browser' | 'quest';
--
--export interface PlatformCapabilities {
--  xrSupported: boolean;
--  webglSupported: boolean;
--  websocketSupported: boolean;
--}
--
--// Message queue types
--export interface QueuedMessage {
--  data: ArrayBuffer;
--  timestamp: number;
--}
--
--// Debug types
--export interface NetworkDebugMessage {
--  direction: 'in' | 'out';
--  type: 'binary' | 'json';
--  timestamp: number;
--  data: any;
--}
-diff --git a/client/index.html b/client/index.html
-index 7caf56b9..d972fa1d 100644
---- a/client/index.html
-+++ b/client/index.html
-@@ -25,154 +25,12 @@
-       width: 100%;
-       height: 100%;
-     }
--
--    #settings-panel {
--      position: fixed;
--      top: 20px;
--      right: 20px;
--      background: rgba(0, 0, 0, 0.8);
--      padding: 20px;
--      border-radius: 8px;
--      z-index: 1000;
--      min-width: 300px;
--    }
--
--    .settings-group {
--      margin-bottom: 15px;
--    }
--
--    .settings-group h3 {
--      margin-bottom: 8px;
--      color: #4a90e2;
--    }
--
--    .setting-item {
--      margin-bottom: 8px;
--    }
--
--    label {
--      display: block;
--      margin-bottom: 4px;
--    }
--
--    input[type="number"],
--    input[type="color"] {
--      width: 100%;
--      padding: 4px;
--      border: 1px solid #666;
--      background: #333;
--      color: #fff;
--      border-radius: 4px;
--    }
--
--    button {
--      padding: 8px 16px;
--      background: #4a90e2;
--      color: #fff;
--      border: none;
--      border-radius: 4px;
--      cursor: pointer;
--      transition: background 0.2s;
--    }
--
--    button:hover {
--      background: #357abd;
--    }
--
--    #xr-button {
--      position: fixed;
--      bottom: 20px;
--      right: 20px;
--      z-index: 1000;
--    }
--
--    .loading-overlay {
--      position: fixed;
--      top: 0;
--      left: 0;
--      width: 100%;
--      height: 100%;
--      background: rgba(0, 0, 0, 0.8);
--      display: flex;
--      justify-content: center;
--      align-items: center;
--      z-index: 2000;
--    }
--
--    .loading-spinner {
--      width: 50px;
--      height: 50px;
--      border: 5px solid #f3f3f3;
--      border-top: 5px solid #4a90e2;
--      border-radius: 50%;
--      animation: spin 1s linear infinite;
--    }
--
--    @keyframes spin {
--      0% { transform: rotate(0deg); }
--      100% { transform: rotate(360deg); }
--    }
-   </style>
- </head>
- <body>
--  <div id="canvas-container"></div>
--
--  <div id="settings-panel">
--    <div class="settings-group">
--      <h3>Node Appearance</h3>
--      <div class="setting-item">
--        <label for="nodeSize">Node Size</label>
--        <input type="number" id="nodeSize" min="0.1" max="5" step="0.1" value="2.5">
--      </div>
--      <div class="setting-item">
--        <label for="nodeColor">Node Color</label>
--        <input type="color" id="nodeColor" value="#4CAF50">
--      </div>
--      <div class="setting-item">
--        <label for="nodeOpacity">Node Opacity</label>
--        <input type="number" id="nodeOpacity" min="0" max="1" step="0.1" value="0.7">
--      </div>
--    </div>
--
--    <div class="settings-group">
--      <h3>Edge Appearance</h3>
--      <div class="setting-item">
--        <label for="edgeWidth">Edge Width</label>
--        <input type="number" id="edgeWidth" min="0.1" max="5" step="0.1" value="0.25">
--      </div>
--      <div class="setting-item">
--        <label for="edgeColor">Edge Color</label>
--        <input type="color" id="edgeColor" value="#E0E0E0">
--      </div>
--      <div class="setting-item">
--        <label for="edgeOpacity">Edge Opacity</label>
--        <input type="number" id="edgeOpacity" min="0" max="1" step="0.1" value="0.7">
--      </div>
--    </div>
--
--    <div class="settings-group">
--      <h3>Visual Effects</h3>
--      <div class="setting-item">
--        <label>
--          <input type="checkbox" id="enableBloom" checked>
--          Enable Bloom
--        </label>
--      </div>
--      <div class="setting-item">
--        <label for="bloomIntensity">Bloom Intensity</label>
--        <input type="number" id="bloomIntensity" min="0" max="3" step="0.1" value="1.5">
--      </div>
--    </div>
--
--    <button id="save-settings">Save Settings</button>
-+  <div id="canvas-container">
-+    <canvas id="main-canvas"></canvas>
-   </div>
--
--  <button id="xr-button" style="display: none;">Enter AR</button>
--
--  <div class="loading-overlay">
--    <div class="loading-spinner"></div>
--  </div>
--
--  <script type="module" src="./index.ts"></script>
-+  <script type="module" src="/index.ts"></script>
- </body>
- </html>
-diff --git a/client/index.ts b/client/index.ts
-index 5dd884ce..c2a81e7f 100644
---- a/client/index.ts
-+++ b/client/index.ts
-@@ -14,6 +14,7 @@ import { XRInteraction } from './xr/xrInteraction';
- import { createLogger } from './core/utils';
- import { WS_URL } from './core/constants';
- import { BinaryNodeUpdate } from './core/types';
-+import { ControlPanel } from './ui';
- 
- const logger = createLogger('Application');
- 
-@@ -46,6 +47,9 @@ class Application {
-       // Initialize XR if supported
-       await this.initializeXR();
- 
-+      // Initialize UI components
-+      new ControlPanel(); // Create the control panel instance
-+
-       // Setup UI event listeners
-       this.setupUIEventListeners();
- 
-diff --git a/client/state/settings.ts b/client/state/settings.ts
-index 0e7c6f1b..ed6474c5 100644
---- a/client/state/settings.ts
-+++ b/client/state/settings.ts
-@@ -3,12 +3,86 @@
-  */
- 
- import { VisualizationSettings } from '../core/types';
--import { DEFAULT_VISUALIZATION_SETTINGS } from '../core/constants';
- import { createLogger } from '../core/utils';
- import { WebSocketService } from '../websocket/websocketService';
- 
- const logger = createLogger('SettingsManager');
- 
-+export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
-+    // Node Appearance
-+    nodeSize: 0.2,
-+    nodeColor: '#FFB700',
-+    nodeOpacity: 0.92,
-+    metalness: 0.85,
-+    roughness: 0.15,
-+    clearcoat: 1.0,
-+
-+    // Edge Appearance
-+    edgeWidth: 2.0,
-+    edgeColor: '#FFD700',
-+    edgeOpacity: 0.6,
-+    enableArrows: true,
-+    arrowSize: 0.15,
-+
-+    // Visual Effects
-+    enableBloom: true,
-+    bloomIntensity: 1.8,
-+    bloomRadius: 0.5,
-+    enableNodeAnimations: true,
-+    enableMotionBlur: true,
-+    motionBlurStrength: 0.4,
-+
-+    // Labels
-+    showLabels: true,
-+    labelSize: 1.0,
-+    labelColor: '#FFFFFF',
-+
-+    // Performance
-+    maxFps: 60,
-+
-+    // AR Settings (Meta Quest 3)
-+    // Scene Understanding
-+    enablePlaneDetection: true,
-+    enableSceneUnderstanding: true,
-+    showPlaneOverlay: true,
-+    planeOpacity: 0.3,
-+    planeColor: '#4A90E2',
-+    enableLightEstimation: true,
-+    
-+    // Hand Tracking
-+    enableHandTracking: true,
-+    handMeshEnabled: true,
-+    handMeshColor: '#FFD700',
-+    handMeshOpacity: 0.3,
-+    handRayEnabled: true,
-+    handRayColor: '#FFD700',
-+    handRayWidth: 0.002,
-+    handPointSize: 0.01,
-+    
-+    // Gesture Controls
-+    gestureSmoothing: 0.9,
-+    pinchThreshold: 0.015,
-+    dragThreshold: 0.04,
-+    rotationThreshold: 0.08,
-+    
-+    // Haptics
-+    enableHaptics: true,
-+    hapticIntensity: 0.7,
-+    
-+    // Room Scale
-+    roomScale: true,
-+    snapToFloor: true,
-+    
-+    // Passthrough
-+    passthroughOpacity: 1.0,
-+    passthroughBrightness: 1.0,
-+    passthroughContrast: 1.0,
-+    enablePassthroughPortal: false,
-+    portalSize: 1.0,
-+    portalEdgeColor: '#FFD700',
-+    portalEdgeWidth: 0.02
-+};
-+
- export class SettingsManager {
-   private static instance: SettingsManager | null = null;
-   private settings: VisualizationSettings;
-@@ -106,6 +180,20 @@ export class SettingsManager {
-     });
-   }
- 
-+  /**
-+   * Add a settings update listener
-+   */
-+  addSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-+    this.settingsListeners.add(listener);
-+  }
-+
-+  /**
-+   * Remove a settings update listener
-+   */
-+  removeSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-+    this.settingsListeners.delete(listener);
-+  }
-+
-   /**
-    * Get current settings
-    */
-@@ -144,6 +232,49 @@ export class SettingsManager {
-     SettingsManager.instance = null;
-   }
- 
-+  public getThreeJSSettings() {
-+    return {
-+      nodes: {
-+        size: this.settings.nodeSize,
-+        color: this.settings.nodeColor,
-+        opacity: this.settings.nodeOpacity,
-+        metalness: this.settings.metalness,
-+        roughness: this.settings.roughness,
-+        clearcoat: this.settings.clearcoat,
-+        highlightColor: '#FFFFFF' // Default highlight color
-+      },
-+      edges: {
-+        width: this.settings.edgeWidth,
-+        color: this.settings.edgeColor,
-+        opacity: this.settings.edgeOpacity,
-+        arrows: {
-+          enabled: this.settings.enableArrows,
-+          size: this.settings.arrowSize
-+        }
-+      },
-+      bloom: {
-+        enabled: this.settings.enableBloom,
-+        intensity: this.settings.bloomIntensity,
-+        radius: this.settings.bloomRadius
-+      },
-+      animations: {
-+        enabled: this.settings.enableNodeAnimations,
-+        motionBlur: {
-+          enabled: this.settings.enableMotionBlur,
-+          strength: this.settings.motionBlurStrength
-+        }
-+      },
-+      labels: {
-+        enabled: this.settings.showLabels,
-+        size: this.settings.labelSize,
-+        color: this.settings.labelColor
-+      },
-+      performance: {
-+        maxFps: this.settings.maxFps
-+      }
-+    };
-+  }
-+
-   // Essential setting getters
-   getNodeSettings(): {
-     size: number;
-@@ -155,7 +286,7 @@ export class SettingsManager {
-       size: this.settings.nodeSize,
-       color: this.settings.nodeColor,
-       opacity: this.settings.nodeOpacity,
--      highlightColor: this.settings.nodeHighlightColor
-+      highlightColor: '#FFFFFF' // Default highlight color
-     };
-   }
- 
-@@ -180,7 +311,7 @@ export class SettingsManager {
-     return {
-       enabled: this.settings.enableBloom,
-       intensity: this.settings.bloomIntensity,
--      threshold: this.settings.bloomThreshold,
-+      threshold: 0.5, // Default threshold
-       radius: this.settings.bloomRadius
-     };
-   }
-@@ -202,8 +333,8 @@ export class SettingsManager {
-     hapticIntensity: number;
-   } {
-     return {
--      controllerVibration: this.settings.xrControllerVibration,
--      hapticIntensity: this.settings.xrControllerHapticIntensity
-+      controllerVibration: false, // Default controller vibration
-+      hapticIntensity: 0.5 // Default haptic intensity
-     };
-   }
- 
-@@ -213,7 +344,7 @@ export class SettingsManager {
-   } {
-     return {
-       maxFps: this.settings.maxFps,
--      updateThrottle: this.settings.updateThrottle
-+      updateThrottle: 0 // Default update throttle
-     };
-   }
- }
-diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
-new file mode 100644
-index 00000000..389de53a
---- /dev/null
-+++ b/client/ui/ControlPanel.css
-@@ -0,0 +1,169 @@
-+.control-panel {
-+    position: fixed;
-+    top: 20px;
-+    right: 20px;
-+    background: rgba(0, 0, 0, 0.85);
-+    border-radius: 8px;
-+    color: #fff;
-+    font-family: Arial, sans-serif;
-+    width: 320px;
-+    max-height: 90vh;
-+    overflow-y: auto;
-+    transition: transform 0.3s ease;
-+    z-index: 1000;
-+    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
-+}
-+
-+.control-panel-header {
-+    display: flex;
-+    justify-content: space-between;
-+    align-items: center;
-+    padding: 12px 16px;
-+    background: rgba(0, 0, 0, 0.2);
-+    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
-+}
-+
-+.control-panel-header h3 {
-+    margin: 0;
-+    font-size: 16px;
-+    font-weight: 500;
-+}
-+
-+.toggle-button {
-+    background: none;
-+    border: none;
-+    color: #fff;
-+    font-size: 20px;
-+    cursor: pointer;
-+    padding: 4px 8px;
-+    transition: transform 0.3s ease;
-+}
-+
-+.control-panel-content {
-+    padding: 16px;
-+    max-height: calc(90vh - 50px);
-+    overflow-y: auto;
-+}
-+
-+.settings-group {
-+    margin-bottom: 24px;
-+}
-+
-+.settings-group h4 {
-+    margin: 0 0 12px 0;
-+    font-size: 14px;
-+    color: #4a90e2;
-+    font-weight: 500;
-+}
-+
-+.setting-item {
-+    margin-bottom: 12px;
-+}
-+
-+.setting-item label {
-+    display: block;
-+    margin-bottom: 4px;
-+    font-size: 12px;
-+    color: #ccc;
-+}
-+
-+.setting-item input[type="range"] {
-+    width: 100%;
-+    height: 4px;
-+    background: #333;
-+    border-radius: 2px;
-+    -webkit-appearance: none;
-+}
-+
-+.setting-item input[type="range"]::-webkit-slider-thumb {
-+    -webkit-appearance: none;
-+    width: 12px;
-+    height: 12px;
-+    background: #4a90e2;
-+    border-radius: 50%;
-+    cursor: pointer;
-+    transition: background 0.2s;
-+}
-+
-+.setting-item input[type="range"]::-webkit-slider-thumb:hover {
-+    background: #357abd;
-+}
-+
-+.setting-item input[type="color"] {
-+    width: 100%;
-+    height: 30px;
-+    padding: 2px;
-+    border: 1px solid #444;
-+    background: #222;
-+    border-radius: 4px;
-+    cursor: pointer;
-+}
-+
-+.setting-item input[type="number"] {
-+    width: 100%;
-+    padding: 6px;
-+    border: 1px solid #444;
-+    background: #222;
-+    color: #fff;
-+    border-radius: 4px;
-+}
-+
-+.setting-item input[type="checkbox"] {
-+    margin-right: 8px;
-+}
-+
-+.setting-item.disabled {
-+    opacity: 0.5;
-+    pointer-events: none;
-+}
-+
-+.save-button {
-+    width: 100%;
-+    padding: 8px 16px;
-+    background: #4a90e2;
-+    color: #fff;
-+    border: none;
-+    border-radius: 4px;
-+    cursor: pointer;
-+    font-size: 14px;
-+    transition: background 0.2s;
-+}
-+
-+.save-button:hover {
-+    background: #357abd;
-+}
-+
-+/* Custom scrollbar */
-+.control-panel-content::-webkit-scrollbar {
-+    width: 6px;
-+}
-+
-+.control-panel-content::-webkit-scrollbar-track {
-+    background: rgba(0, 0, 0, 0.1);
-+}
-+
-+.control-panel-content::-webkit-scrollbar-thumb {
-+    background: rgba(255, 255, 255, 0.2);
-+    border-radius: 3px;
-+}
-+
-+.control-panel-content::-webkit-scrollbar-thumb:hover {
-+    background: rgba(255, 255, 255, 0.3);
-+}
-+
-+/* Animations */
-+@keyframes fadeIn {
-+    from { opacity: 0; }
-+    to { opacity: 1; }
-+}
-+
-+.control-panel {
-+    animation: fadeIn 0.3s ease;
-+}
-+
-+/* Responsive design */
-+@media (max-width: 768px) {
-+    .control-panel {
-+        width: 280px;
-+    }
-+}
-diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
-new file mode 100644
-index 00000000..e59b53de
---- /dev/null
-+++ b/client/ui/ControlPanel.ts
-@@ -0,0 +1,515 @@
-+import { VisualizationSettings } from '../core/types';
-+import { settingsManager } from '../state/settings';
-+import { createLogger } from '../core/utils';
-+
-+const logger = createLogger('ControlPanel');
-+
-+export class ControlPanel {
-+    private container: HTMLDivElement;
-+    private settings: VisualizationSettings;
-+    private isExpanded = false;
-+    
-+    constructor() {
-+        this.container = document.createElement('div');
-+        this.container.className = 'control-panel';
-+        this.settings = { ...settingsManager.getSettings() };
-+        this.initializeUI();
-+        this.setupEventListeners();
-+        
-+        // Subscribe to settings updates
-+        settingsManager.addSettingsListener(this.onSettingsUpdate.bind(this));
-+    }
-+
-+    private initializeUI(): void {
-+        this.container.innerHTML = `
-+            <div class="control-panel-header">
-+                <h3>Graph Controls</h3>
-+                <button class="toggle-button">≡</button>
-+            </div>
-+            <div class="control-panel-content">
-+                <div class="settings-group">
-+                    <h4>Node Appearance</h4>
-+                    <div class="setting-item">
-+                        <label for="nodeSize">Base Size</label>
-+                        <input type="range" id="nodeSize" min="0.1" max="2" step="0.1" value="${this.settings.nodeSize}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="nodeColor">Color</label>
-+                        <input type="color" id="nodeColor" value="${this.settings.nodeColor}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="nodeOpacity">Opacity</label>
-+                        <input type="range" id="nodeOpacity" min="0" max="1" step="0.1" value="${this.settings.nodeOpacity}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="metalness">Metalness</label>
-+                        <input type="range" id="metalness" min="0" max="1" step="0.05" value="${this.settings.metalness}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="roughness">Roughness</label>
-+                        <input type="range" id="roughness" min="0" max="1" step="0.05" value="${this.settings.roughness}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="clearcoat">Clearcoat</label>
-+                        <input type="range" id="clearcoat" min="0" max="1" step="0.1" value="${this.settings.clearcoat}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Edge Appearance</h4>
-+                    <div class="setting-item">
-+                        <label for="edgeWidth">Width</label>
-+                        <input type="range" id="edgeWidth" min="0.1" max="5" step="0.1" value="${this.settings.edgeWidth}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="edgeColor">Color</label>
-+                        <input type="color" id="edgeColor" value="${this.settings.edgeColor}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="edgeOpacity">Opacity</label>
-+                        <input type="range" id="edgeOpacity" min="0" max="1" step="0.1" value="${this.settings.edgeOpacity}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableArrows" ${this.settings.enableArrows ? 'checked' : ''}>
-+                            Show Arrows
-+                        </label>
-+                    </div>
-+                    <div class="setting-item arrow-setting ${this.settings.enableArrows ? '' : 'disabled'}">
-+                        <label for="arrowSize">Arrow Size</label>
-+                        <input type="range" id="arrowSize" min="0.1" max="1" step="0.05" value="${this.settings.arrowSize}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Visual Effects</h4>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableBloom" ${this.settings.enableBloom ? 'checked' : ''}>
-+                            Enable Bloom
-+                        </label>
-+                    </div>
-+                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
-+                        <label for="bloomIntensity">Bloom Intensity</label>
-+                        <input type="range" id="bloomIntensity" min="0" max="2" step="0.1" value="${this.settings.bloomIntensity}">
-+                    </div>
-+                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
-+                        <label for="bloomRadius">Bloom Radius</label>
-+                        <input type="range" id="bloomRadius" min="0" max="2" step="0.1" value="${this.settings.bloomRadius}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Animations</h4>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableNodeAnimations" ${this.settings.enableNodeAnimations ? 'checked' : ''}>
-+                            Node Animations
-+                        </label>
-+                    </div>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableMotionBlur" ${this.settings.enableMotionBlur ? 'checked' : ''}>
-+                            Motion Blur
-+                        </label>
-+                    </div>
-+                    <div class="setting-item motion-setting ${this.settings.enableMotionBlur ? '' : 'disabled'}">
-+                        <label for="motionBlurStrength">Motion Blur Strength</label>
-+                        <input type="range" id="motionBlurStrength" min="0" max="1" step="0.1" value="${this.settings.motionBlurStrength}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Labels</h4>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="showLabels" ${this.settings.showLabels ? 'checked' : ''}>
-+                            Show Labels
-+                        </label>
-+                    </div>
-+                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
-+                        <label for="labelSize">Label Size</label>
-+                        <input type="range" id="labelSize" min="0.5" max="2" step="0.1" value="${this.settings.labelSize}">
-+                    </div>
-+                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
-+                        <label for="labelColor">Label Color</label>
-+                        <input type="color" id="labelColor" value="${this.settings.labelColor}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Performance</h4>
-+                    <div class="setting-item">
-+                        <label for="maxFps">Max FPS</label>
-+                        <input type="number" id="maxFps" min="30" max="144" value="${this.settings.maxFps}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>AR Settings</h4>
-+                    <div class="setting-item">
-+                        <label>Scene Understanding</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enablePlaneDetection" ${this.settings.enablePlaneDetection ? 'checked' : ''}>
-+                                    Plane Detection
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableSceneUnderstanding" ${this.settings.enableSceneUnderstanding ? 'checked' : ''}>
-+                                    Scene Understanding
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="showPlaneOverlay" ${this.settings.showPlaneOverlay ? 'checked' : ''}>
-+                                    Show Plane Overlay
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="planeOpacity">Plane Opacity</label>
-+                                <input type="range" id="planeOpacity" min="0" max="1" step="0.1" value="${this.settings.planeOpacity}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="planeColor">Plane Color</label>
-+                                <input type="color" id="planeColor" value="${this.settings.planeColor}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableLightEstimation" ${this.settings.enableLightEstimation ? 'checked' : ''}>
-+                                    Light Estimation
-+                                </label>
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Hand Tracking</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableHandTracking" ${this.settings.enableHandTracking ? 'checked' : ''}>
-+                                    Enable Hand Tracking
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="handMeshEnabled" ${this.settings.handMeshEnabled ? 'checked' : ''}>
-+                                    Show Hand Mesh
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="handMeshColor">Hand Mesh Color</label>
-+                                <input type="color" id="handMeshColor" value="${this.settings.handMeshColor}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="handMeshOpacity">Hand Mesh Opacity</label>
-+                                <input type="range" id="handMeshOpacity" min="0" max="1" step="0.1" value="${this.settings.handMeshOpacity}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="handRayEnabled" ${this.settings.handRayEnabled ? 'checked' : ''}>
-+                                    Show Hand Ray
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="handRayColor">Hand Ray Color</label>
-+                                <input type="color" id="handRayColor" value="${this.settings.handRayColor}">
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Gesture Controls</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label for="gestureSmoothing">Gesture Smoothing</label>
-+                                <input type="range" id="gestureSmoothing" min="0" max="1" step="0.1" value="${this.settings.gestureSmoothing}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="pinchThreshold">Pinch Threshold</label>
-+                                <input type="range" id="pinchThreshold" min="0" max="0.05" step="0.001" value="${this.settings.pinchThreshold}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="dragThreshold">Drag Threshold</label>
-+                                <input type="range" id="dragThreshold" min="0" max="0.1" step="0.01" value="${this.settings.dragThreshold}">
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Haptics</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableHaptics" ${this.settings.enableHaptics ? 'checked' : ''}>
-+                                    Enable Haptics
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="hapticIntensity">Haptic Intensity</label>
-+                                <input type="range" id="hapticIntensity" min="0" max="1" step="0.1" value="${this.settings.hapticIntensity}">
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Room Scale</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="roomScale" ${this.settings.roomScale ? 'checked' : ''}>
-+                                    Room Scale Mode
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="snapToFloor" ${this.settings.snapToFloor ? 'checked' : ''}>
-+                                    Snap to Floor
-+                                </label>
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Passthrough</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label for="passthroughOpacity">Opacity</label>
-+                                <input type="range" id="passthroughOpacity" min="0" max="1" step="0.1" value="${this.settings.passthroughOpacity}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="passthroughBrightness">Brightness</label>
-+                                <input type="range" id="passthroughBrightness" min="0" max="2" step="0.1" value="${this.settings.passthroughBrightness}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="passthroughContrast">Contrast</label>
-+                                <input type="range" id="passthroughContrast" min="0" max="2" step="0.1" value="${this.settings.passthroughContrast}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enablePassthroughPortal" ${this.settings.enablePassthroughPortal ? 'checked' : ''}>
-+                                    Enable Portal
-+                                </label>
-+                            </div>
-+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-+                                <label for="portalSize">Portal Size</label>
-+                                <input type="range" id="portalSize" min="0.1" max="2" step="0.1" value="${this.settings.portalSize}">
-+                            </div>
-+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-+                                <label for="portalEdgeColor">Portal Edge Color</label>
-+                                <input type="color" id="portalEdgeColor" value="${this.settings.portalEdgeColor}">
-+                            </div>
-+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-+                                <label for="portalEdgeWidth">Portal Edge Width</label>
-+                                <input type="range" id="portalEdgeWidth" min="0.001" max="0.05" step="0.001" value="${this.settings.portalEdgeWidth}">
-+                            </div>
-+                        </div>
-+                    </div>
-+                </div>
-+
-+                <button class="save-button">Save Changes</button>
-+            </div>
-+        `;
-+
-+        document.body.appendChild(this.container);
-+    }
-+
-+    private setupEventListeners(): void {
-+        // Toggle panel
-+        const toggleButton = this.container.querySelector('.toggle-button');
-+        toggleButton?.addEventListener('click', () => {
-+            this.isExpanded = !this.isExpanded;
-+            this.container.classList.toggle('expanded', this.isExpanded);
-+        });
-+
-+        // Save button
-+        const saveButton = this.container.querySelector('.save-button');
-+        saveButton?.addEventListener('click', this.saveSettings.bind(this));
-+
-+        // Node settings
-+        this.setupInputListener('nodeSize', 'number');
-+        this.setupInputListener('nodeColor', 'string');
-+        this.setupInputListener('nodeOpacity', 'number');
-+        this.setupInputListener('metalness', 'number');
-+        this.setupInputListener('roughness', 'number');
-+        this.setupInputListener('clearcoat', 'number');
-+
-+        // Edge settings
-+        this.setupInputListener('edgeWidth', 'number');
-+        this.setupInputListener('edgeColor', 'string');
-+        this.setupInputListener('edgeOpacity', 'number');
-+        
-+        const arrowsCheckbox = this.container.querySelector('#enableArrows') as HTMLInputElement;
-+        arrowsCheckbox?.addEventListener('change', () => {
-+            const arrowSettings = this.container.querySelectorAll('.arrow-setting');
-+            arrowSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !arrowsCheckbox.checked);
-+            });
-+            this.settings.enableArrows = arrowsCheckbox.checked;
-+        });
-+        this.setupInputListener('arrowSize', 'number');
-+
-+        // Bloom settings
-+        const bloomCheckbox = this.container.querySelector('#enableBloom') as HTMLInputElement;
-+        bloomCheckbox?.addEventListener('change', () => {
-+            const bloomSettings = this.container.querySelectorAll('.bloom-setting');
-+            bloomSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !bloomCheckbox.checked);
-+            });
-+            this.settings.enableBloom = bloomCheckbox.checked;
-+        });
-+        this.setupInputListener('bloomIntensity', 'number');
-+        this.setupInputListener('bloomRadius', 'number');
-+
-+        // Animation settings
-+        const nodeAnimCheckbox = this.container.querySelector('#enableNodeAnimations') as HTMLInputElement;
-+        nodeAnimCheckbox?.addEventListener('change', () => {
-+            this.settings.enableNodeAnimations = nodeAnimCheckbox.checked;
-+        });
-+
-+        const motionBlurCheckbox = this.container.querySelector('#enableMotionBlur') as HTMLInputElement;
-+        motionBlurCheckbox?.addEventListener('change', () => {
-+            const motionSettings = this.container.querySelectorAll('.motion-setting');
-+            motionSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !motionBlurCheckbox.checked);
-+            });
-+            this.settings.enableMotionBlur = motionBlurCheckbox.checked;
-+        });
-+        this.setupInputListener('motionBlurStrength', 'number');
-+
-+        // Label settings
-+        const labelCheckbox = this.container.querySelector('#showLabels') as HTMLInputElement;
-+        labelCheckbox?.addEventListener('change', () => {
-+            const labelSettings = this.container.querySelectorAll('.label-setting');
-+            labelSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !labelCheckbox.checked);
-+            });
-+            this.settings.showLabels = labelCheckbox.checked;
-+        });
-+        this.setupInputListener('labelSize', 'number');
-+        this.setupInputListener('labelColor', 'string');
-+
-+        // Performance settings
-+        this.setupInputListener('maxFps', 'number');
-+
-+        // AR settings
-+        const planeDetectionCheckbox = this.container.querySelector('#enablePlaneDetection') as HTMLInputElement;
-+        planeDetectionCheckbox?.addEventListener('change', () => {
-+            this.settings.enablePlaneDetection = planeDetectionCheckbox.checked;
-+        });
-+
-+        const sceneUnderstandingCheckbox = this.container.querySelector('#enableSceneUnderstanding') as HTMLInputElement;
-+        sceneUnderstandingCheckbox?.addEventListener('change', () => {
-+            this.settings.enableSceneUnderstanding = sceneUnderstandingCheckbox.checked;
-+        });
-+
-+        const showPlaneOverlayCheckbox = this.container.querySelector('#showPlaneOverlay') as HTMLInputElement;
-+        showPlaneOverlayCheckbox?.addEventListener('change', () => {
-+            this.settings.showPlaneOverlay = showPlaneOverlayCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('planeOpacity', 'number');
-+        this.setupInputListener('planeColor', 'string');
-+
-+        const lightEstimationCheckbox = this.container.querySelector('#enableLightEstimation') as HTMLInputElement;
-+        lightEstimationCheckbox?.addEventListener('change', () => {
-+            this.settings.enableLightEstimation = lightEstimationCheckbox.checked;
-+        });
-+
-+        const handTrackingCheckbox = this.container.querySelector('#enableHandTracking') as HTMLInputElement;
-+        handTrackingCheckbox?.addEventListener('change', () => {
-+            this.settings.enableHandTracking = handTrackingCheckbox.checked;
-+        });
-+
-+        const handMeshEnabledCheckbox = this.container.querySelector('#handMeshEnabled') as HTMLInputElement;
-+        handMeshEnabledCheckbox?.addEventListener('change', () => {
-+            this.settings.handMeshEnabled = handMeshEnabledCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('handMeshColor', 'string');
-+        this.setupInputListener('handMeshOpacity', 'number');
-+
-+        const handRayEnabledCheckbox = this.container.querySelector('#handRayEnabled') as HTMLInputElement;
-+        handRayEnabledCheckbox?.addEventListener('change', () => {
-+            this.settings.handRayEnabled = handRayEnabledCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('handRayColor', 'string');
-+
-+        this.setupInputListener('gestureSmoothing', 'number');
-+        this.setupInputListener('pinchThreshold', 'number');
-+        this.setupInputListener('dragThreshold', 'number');
-+
-+        const hapticsCheckbox = this.container.querySelector('#enableHaptics') as HTMLInputElement;
-+        hapticsCheckbox?.addEventListener('change', () => {
-+            this.settings.enableHaptics = hapticsCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('hapticIntensity', 'number');
-+
-+        const roomScaleCheckbox = this.container.querySelector('#roomScale') as HTMLInputElement;
-+        roomScaleCheckbox?.addEventListener('change', () => {
-+            this.settings.roomScale = roomScaleCheckbox.checked;
-+        });
-+
-+        const snapToFloorCheckbox = this.container.querySelector('#snapToFloor') as HTMLInputElement;
-+        snapToFloorCheckbox?.addEventListener('change', () => {
-+            this.settings.snapToFloor = snapToFloorCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('passthroughOpacity', 'number');
-+        this.setupInputListener('passthroughBrightness', 'number');
-+        this.setupInputListener('passthroughContrast', 'number');
-+
-+        const passthroughPortalCheckbox = this.container.querySelector('#enablePassthroughPortal') as HTMLInputElement;
-+        passthroughPortalCheckbox?.addEventListener('change', () => {
-+            const portalSettings = this.container.querySelectorAll('.portal-setting');
-+            portalSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !passthroughPortalCheckbox.checked);
-+            });
-+            this.settings.enablePassthroughPortal = passthroughPortalCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('portalSize', 'number');
-+        this.setupInputListener('portalEdgeColor', 'string');
-+        this.setupInputListener('portalEdgeWidth', 'number');
-+    }
-+
-+    private setupInputListener(id: string, type: 'number' | 'string'): void {
-+        const input = this.container.querySelector(`#${id}`) as HTMLInputElement;
-+        input?.addEventListener('input', () => {
-+            const value = type === 'number' ? parseFloat(input.value) : input.value;
-+            (this.settings as any)[id] = value;
-+        });
-+    }
-+
-+    private async saveSettings(): Promise<void> {
-+        try {
-+            await settingsManager.updateSettings(this.settings);
-+            logger.log('Settings saved successfully');
-+        } catch (error) {
-+            logger.error('Failed to save settings:', error);
-+        }
-+    }
-+
-+    private onSettingsUpdate(newSettings: VisualizationSettings): void {
-+        this.settings = { ...newSettings };
-+        this.updateUIValues();
-+    }
-+
-+    private updateUIValues(): void {
-+        Object.entries(this.settings).forEach(([key, value]) => {
-+            const input = this.container.querySelector(`#${key}`) as HTMLInputElement;
-+            if (input) {
-+                if (input.type === 'checkbox') {
-+                    input.checked = value as boolean;
-+                } else {
-+                    input.value = value.toString();
-+                }
-+            }
-+        });
-+    }
-+}
-diff --git a/client/ui/index.ts b/client/ui/index.ts
-new file mode 100644
-index 00000000..04ebc6e6
---- /dev/null
-+++ b/client/ui/index.ts
-@@ -0,0 +1,4 @@
-+import { ControlPanel } from './ControlPanel';
-+import './ControlPanel.css';
-+
-+export { ControlPanel };
-diff --git a/client/xr/xrInteraction.ts b/client/xr/xrInteraction.ts
-index 921924d5..c9b42a1b 100644
---- a/client/xr/xrInteraction.ts
-+++ b/client/xr/xrInteraction.ts
-@@ -1,384 +1,141 @@
--/**
-- * XR interaction handling for controllers and hands
-- */
--
- import * as THREE from 'three';
--import { XRSessionManager } from './xrSessionManager';
-+import { XRHandWithHaptics } from './xrTypes';
- import { NodeManager } from '../rendering/nodes';
--import { settingsManager } from '../state/settings';
--import { createLogger } from '../core/utils';
--
--// Logger will be used for debugging XR interactions and haptic feedback
--const _logger = createLogger('XRInteraction');
--
--// XR Interaction Action Types
--type XRInteractionActionType = 'select' | 'squeeze';
--
--// Extended XR types
--interface XRHandWithHaptics extends XRHand {
--    vibrate?(intensity: number, duration: number): void;
--}
--
--interface XRSessionWithPose extends XRSession {
--    getPose?(source: XRSpace, referenceSpace: XRReferenceSpace): XRPose | undefined;
--}
--
--interface XRInteractionActionEvent extends THREE.Event {
--    type: `${XRInteractionActionType}start` | `${XRInteractionActionType}end`;
--    data: XRInputSource;
--    hand?: XRHandWithHaptics;
--}
--
--interface XRController extends THREE.Group {
--    userData: {
--        inputSource: XRInputSource;
--    };
--}
--
--interface XRNodeMeshUserData {
--    nodeId: string;
--}
--
--interface XRNodeMesh extends THREE.Object3D {
--    userData: XRNodeMeshUserData;
--}
--
--declare module 'three' {
--    interface Object3DEventMap {
--        selectstart: XRInteractionActionEvent;
--        selectend: XRInteractionActionEvent;
--        squeezestart: XRInteractionActionEvent;
--        squeezeend: XRInteractionActionEvent;
--    }
--}
--
--type XRInteractor = XRController | XRHandWithHaptics;
--
--// Type guard function to check if an object is an XRNodeMesh
--function isXRNodeMesh(obj: THREE.Object3D): obj is XRNodeMesh {
--    return (
--        obj !== null &&
--        typeof obj === 'object' &&
--        'userData' in obj &&
--        obj.userData !== null &&
--        typeof obj.userData === 'object' &&
--        'nodeId' in obj.userData &&
--        typeof obj.userData.nodeId === 'string'
--    );
--}
-+import { XRSessionManager } from './xrSessionManager';
-+import { VisualizationSettings } from '../core/types';
- 
- export class XRInteraction {
--    private static instance: XRInteraction;
-+    private static instance: XRInteraction | null = null;
-     private xrManager: XRSessionManager;
-     private nodeManager: NodeManager;
--
--    // Interaction state
--    private selectedNode: string | null = null;
--    private hoveredNode: string | null = null;
--    private isGrabbing: boolean = false;
--    private lastInteractorPosition: THREE.Vector3;
--    private grabOffset: THREE.Vector3;
--
--    // Raycasting
--    private raycaster: THREE.Raycaster;
--    private tempMatrix: THREE.Matrix4;
--
--    // Hand Tracking
-+    private controllers: THREE.Group[] = [];
-+    private lastInteractorPosition = new THREE.Vector3();
-     private hands: XRHandWithHaptics[] = [];
--    private pinchThreshold: number = 0.025;
-+    private settings: VisualizationSettings;
- 
-     private constructor(xrManager: XRSessionManager, nodeManager: NodeManager) {
-         this.xrManager = xrManager;
-         this.nodeManager = nodeManager;
--
--        this.lastInteractorPosition = new THREE.Vector3();
--        this.grabOffset = new THREE.Vector3();
--        this.raycaster = new THREE.Raycaster();
--        this.tempMatrix = new THREE.Matrix4();
--        this.setupEventListeners();
--    }
--
--    static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
-+        this.settings = {
-+            enableHandTracking: true,
-+            pinchThreshold: 0.015,
-+            dragThreshold: 0.04,
-+            enableHaptics: true,
-+            hapticIntensity: 0.7
-+        } as VisualizationSettings;
-+        
-+        this.setupXRControllers();
-+        this.setupHandTracking();
-+    }
-+
-+    public static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
-         if (!XRInteraction.instance) {
-             XRInteraction.instance = new XRInteraction(xrManager, nodeManager);
-         }
-         return XRInteraction.instance;
-     }
- 
--    private setupEventListeners(): void {
--        const session = this.xrManager.getSession();
--        if (!session) return;
--
--        // Handle controller / hand updates
--        session.addEventListener('inputsourceschange', (event: XRInputSourcesChangeEvent) => {
--            // Clear old event listeners
--            this.xrManager.getControllers().forEach(controller => {
--                controller.removeEventListener('selectstart', this.handleSelectStart);
--                controller.removeEventListener('selectend', this.handleSelectEnd);
--                controller.removeEventListener('squeezestart', this.handleSqueezeStart);
--                controller.removeEventListener('squeezeend', this.handleSqueezeEnd);
--            });
--
--            this.hands = [];
--            event.added.forEach((source: XRInputSource) => {
--                if (source.hand) {
--                    this.hands.push(source.hand as XRHandWithHaptics);
--                }
--            });
--
--            // Setup new input sources
--            this.xrManager.getControllers().forEach((controller) => {
--                controller.addEventListener('selectstart', this.handleSelectStart);
--                controller.addEventListener('selectend', this.handleSelectEnd);
--                controller.addEventListener('squeezestart', this.handleSqueezeStart);
--                controller.addEventListener('squeezeend', this.handleSqueezeEnd);
--            });
-+    private setupXRControllers(): void {
-+        this.xrManager.onControllerAdded((controller: THREE.Group) => {
-+            this.controllers.push(controller);
-+            if (controller.userData.hapticActuator) {
-+                this.triggerHapticFeedback(controller, 0.5, 50);
-+            }
-         });
- 
--        // Initial Setup
--        this.xrManager.getControllers().forEach((controller) => {
--            controller.addEventListener('selectstart', this.handleSelectStart);
--            controller.addEventListener('selectend', this.handleSelectEnd);
--            controller.addEventListener('squeezestart', this.handleSqueezeStart);
--            controller.addEventListener('squeezeend', this.handleSqueezeEnd);
-+        this.xrManager.onControllerRemoved((controller: THREE.Group) => {
-+            const index = this.controllers.indexOf(controller);
-+            if (index !== -1) {
-+                this.controllers.splice(index, 1);
-+            }
-         });
-     }
- 
--    private handleSelectStart = (event: THREE.Event) => {
--        if (this.hoveredNode) {
--            const interactionEvent = event as XRInteractionActionEvent;
--            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
--        }
--    }
--
--    private handleSelectEnd = () => {
--        this.endGrab();
--    }
-+    private setupHandTracking(): void {
-+        if (!this.settings.enableHandTracking) return;
- 
--    private handleSqueezeStart = (event: THREE.Event) => {
--        if (this.hoveredNode) {
--            const interactionEvent = event as XRInteractionActionEvent;
--            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
--        }
-+        // Hand tracking is handled by the XRSessionManager directly
-+        this.hands = [];
-     }
- 
--    private handleSqueezeEnd = () => {
--        this.endGrab();
--    }
-+    public update(): void {
-+        if (!this.settings.enableHandTracking) return;
- 
--    /**
--     * Update interaction state
--     */
--    update(frame: XRFrame): void {
--        const session = this.xrManager.getSession() as XRSessionWithPose;
--        const referenceSpace = this.xrManager.getReferenceSpace();
--
--        if (!session || !referenceSpace) return;
--
--        // Update controller interaction
--        this.xrManager.getControllers().forEach((baseController) => {
--            const controller = baseController as XRController;
--            const inputSource = controller.userData.inputSource;
--            if (!inputSource) return;
--
--            // Get controller pose
--            const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
--            if (!pose) return;
--
--            // Update raycaster
--            controller.updateMatrixWorld();
--            this.tempMatrix.identity().extractRotation(controller.matrixWorld);
--            this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
--            this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
--
--            // Check for intersections with nodes
--            this.checkNodeIntersections(controller);
--
--            // Update grabbed node position
--            if (this.isGrabbing && this.selectedNode) {
--                this.updateGrabbedNodePosition(controller);
--            }
--
--            // Provide haptic feedback if enabled
--            if (inputSource.gamepad && settingsManager.getSettings().xrControllerVibration) {
--                this.handleHapticFeedback(inputSource.gamepad);
-+        // Update hand interactions
-+        this.hands.forEach(hand => {
-+            if (hand.pinchStrength > this.settings.pinchThreshold) {
-+                this.handlePinchGesture(hand);
-             }
-         });
- 
--        // Handle Hand Interactions
--        this.hands.forEach((hand) => {
--            this.checkHandIntersections(hand, frame, referenceSpace);
--
--            if (this.isGrabbing && this.selectedNode) {
--                this.updateGrabbedNodePosition(hand);
--            }
-+        // Update controller interactions
-+        this.controllers.forEach(controller => {
-+            this.handleControllerInteraction(controller);
-         });
-     }
- 
--    private checkHandIntersections(hand: XRHandWithHaptics, frame: XRFrame, referenceSpace: XRReferenceSpace): void {
--        if (!hand || !frame || !referenceSpace) return;
--
--        // Get index and thumb tip
--        const indexTipPose = frame.getPose(hand.get("index-finger-tip") as XRSpace, referenceSpace);
--        const thumbTipPose = frame.getPose(hand.get("thumb-tip") as XRSpace, referenceSpace);
--        if (!indexTipPose || !thumbTipPose) return;
--
--        const indexTipPosition = new THREE.Vector3().fromArray(indexTipPose.transform.matrix.slice(12, 15));
--        const thumbTipPosition = new THREE.Vector3().fromArray(thumbTipPose.transform.matrix.slice(12, 15));
--        const distance = indexTipPosition.distanceTo(thumbTipPosition);
--
--        let closestNode: XRNodeMesh | null = null;
--        let minDistance = Infinity;
--
--        // Get meshes and check each one
--        const meshes = this.nodeManager.getAllNodeMeshes();
--        for (const mesh of meshes) {
--            if (isXRNodeMesh(mesh)) {
--                const nodePosition = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);
--                const nodeDistance = nodePosition.distanceTo(indexTipPosition);
--
--                if (nodeDistance < minDistance) {
--                    minDistance = nodeDistance;
--                    closestNode = mesh;
--                }
--            }
--        }
--
--        if (minDistance < 0.1 && closestNode) {
--            const nodeId = closestNode.userData.nodeId;
--            if (nodeId !== this.hoveredNode) {
--                // Update hover state
--                this.hoveredNode = nodeId;
--                this.nodeManager.highlightNode(nodeId);
--                // Trigger haptic pulse for hover
--                this.pulseHand(hand, 0.2, 50);
--            }
--            if (distance < this.pinchThreshold && !this.isGrabbing) {
--                this.startGrab(nodeId, hand, hand);
--            }
--        } else if (this.hoveredNode) {
--            // Clear hover state
--            this.nodeManager.highlightNode(null);
--            this.hoveredNode = null;
--        }
--    }
--
--    private checkNodeIntersections(controller: XRController): void {
--        // Get closest intersection
--        const meshes = this.nodeManager.getAllNodeMeshes();
--        const intersects = this.raycaster.intersectObjects(meshes);
--
--        if (intersects.length > 0) {
--            const intersectedObject = intersects[0].object;
--            if (isXRNodeMesh(intersectedObject)) {
--                const nodeId = intersectedObject.userData.nodeId;
--                if (nodeId !== this.hoveredNode) {
--                    // Update hover state
--                    this.hoveredNode = nodeId;
--                    this.nodeManager.highlightNode(nodeId);
-+    private handlePinchGesture(hand: XRHandWithHaptics): void {
-+        const indexTip = hand.hand.joints['index-finger-tip'];
-+        if (!indexTip) return;
- 
--                    // Trigger haptic pulse for hover
--                    this.pulseController(controller, 0.2, 50);
--                }
--            }
--        } else if (this.hoveredNode) {
--            // Clear hover state
--            this.nodeManager.highlightNode(null);
--            this.hoveredNode = null;
--        }
--    }
-+        const position = new THREE.Vector3();
-+        position.setFromMatrixPosition(indexTip.matrixWorld);
- 
--    private startGrab(nodeId: string, interactor: XRInputSource | XRHandWithHaptics, hand?: XRHandWithHaptics): void {
--        this.selectedNode = nodeId;
--        this.isGrabbing = true;
--
--        // Store initial grab position
--        if (interactor instanceof THREE.Group) {
--            const controller = interactor as unknown as XRController;
--            this.lastInteractorPosition.setFromMatrixPosition(controller.matrixWorld);
--            this.pulseController(controller, 0.7, 100);
--        } else if (hand) {
--            const wrist = hand.get("wrist") as XRSpace;
--            const session = this.xrManager.getSession() as XRSessionWithPose;
--            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
--            if (pose) {
--                this.lastInteractorPosition.fromArray(pose.transform.matrix.slice(12, 15));
-+        // Calculate movement delta
-+        const delta = position.clone().sub(this.lastInteractorPosition);
-+        
-+        // Update node positions based on hand movement
-+        if (delta.length() > this.settings.dragThreshold) {
-+            this.nodeManager.updateNodePositions({
-+                x: delta.x,
-+                y: delta.y,
-+                z: delta.z
-+            });
-+            if (this.settings.enableHaptics) {
-+                this.triggerHapticFeedback(hand, this.settings.hapticIntensity, 50);
-             }
--            this.pulseHand(hand, 0.7, 100);
-         }
- 
--        // Calculate grab offset
--        const nodePosition = this.nodeManager.getNodePosition(nodeId);
--        this.grabOffset.subVectors(nodePosition, this.lastInteractorPosition);
--    }
--
--    private endGrab(): void {
--        if (this.isGrabbing) {
--            this.isGrabbing = false;
--            this.selectedNode = null;
--        }
-+        this.lastInteractorPosition.copy(position);
-     }
- 
--    private updateGrabbedNodePosition(interactor: XRInteractor): void {
--        if (!this.selectedNode) return;
-+    private handleControllerInteraction(controller: THREE.Group): void {
-+        const position = new THREE.Vector3();
-+        position.setFromMatrixPosition(controller.matrixWorld);
- 
--        // Get current interactor position
--        const currentPosition = new THREE.Vector3();
--        if (interactor instanceof THREE.Group) {
--            currentPosition.setFromMatrixPosition(interactor.matrixWorld);
--        } else {
--            const wrist = interactor.get("wrist") as XRSpace;
--            const session = this.xrManager.getSession() as XRSessionWithPose;
--            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
--            if (pose) {
--                currentPosition.fromArray(pose.transform.matrix.slice(12, 15));
-+        // Calculate movement delta
-+        const delta = position.clone().sub(this.lastInteractorPosition);
-+        
-+        // Update node positions based on controller movement
-+        if (delta.length() > this.settings.dragThreshold) {
-+            this.nodeManager.updateNodePositions({
-+                x: delta.x,
-+                y: delta.y,
-+                z: delta.z
-+            });
-+            if (this.settings.enableHaptics && controller.userData.hapticActuator) {
-+                this.triggerHapticFeedback(controller, this.settings.hapticIntensity, 50);
-             }
-         }
- 
--        // Calculate new node position
--        const newPosition = currentPosition.clone().add(this.grabOffset);
--        this.nodeManager.updateNodePosition(this.selectedNode, newPosition);
--
--        // Update last position
--        this.lastInteractorPosition.copy(currentPosition);
--    }
--
--    private handleHapticFeedback(__gamepad: Gamepad): void {
--        if (!settingsManager.getSettings().xrControllerVibration) return;
--
--        // Add haptic feedback logic based on interactions
--        // For example, vibrate when near nodes or when grabbing
-+        this.lastInteractorPosition.copy(position);
-     }
- 
--    private pulseController(controller: XRController, intensity: number, duration: number): void {
--        const inputSource = controller.userData.inputSource;
--        if (!inputSource?.gamepad || !settingsManager.getSettings().xrControllerVibration) return;
-+    private triggerHapticFeedback(device: THREE.Group | XRHandWithHaptics, intensity: number, duration: number): void {
-+        if (!this.settings.enableHaptics) return;
- 
--        const actuator = inputSource.gamepad.hapticActuators?.[0] as any;
--        if (actuator) {
--            try {
-+        if ('hapticActuators' in device) {
-+            device.hapticActuators.forEach(actuator => {
-                 actuator.pulse(intensity, duration);
--            } catch (error) {
--                _logger.warn('Haptic feedback not supported:', error);
--            }
--        }
--    }
--
--    private pulseHand(hand: XRHandWithHaptics, intensity: number, duration: number): void {
--        if (!settingsManager.getSettings().xrControllerVibration) return;
--        try {
--            hand.vibrate?.(intensity, duration);
--        } catch (error) {
--            _logger.warn('Haptic feedback not supported for hands:', error);
-+            });
-+        } else if (device.userData.hapticActuator) {
-+            device.userData.hapticActuator.pulse(intensity, duration);
-         }
-     }
- 
--    /**
--     * Clean up resources
--     */
--    dispose(): void {
--        this.endGrab();
--        this.hoveredNode = null;
--        this.selectedNode = null;
-+    public dispose(): void {
-+        this.controllers = [];
-+        this.hands = [];
-+        XRInteraction.instance = null;
-     }
- }
-diff --git a/client/xr/xrSessionManager.ts b/client/xr/xrSessionManager.ts
-index 8c17d302..e234201e 100644
---- a/client/xr/xrSessionManager.ts
-+++ b/client/xr/xrSessionManager.ts
-@@ -46,6 +46,8 @@ export class XRSessionManager {
-   private xrSessionStartCallback: (() => void) | null = null;
-   private xrSessionEndCallback: (() => void) | null = null;
-   private xrAnimationFrameCallback: ((frame: XRFrame) => void) | null = null;
-+  private controllerAddedCallback: ((controller: THREE.Group) => void) | null = null;
-+  private controllerRemovedCallback: ((controller: THREE.Group) => void) | null = null;
- 
-   private constructor(sceneManager: SceneManager) {
-     this.sceneManager = sceneManager;
-@@ -137,42 +139,33 @@ export class XRSessionManager {
-     this.arGroup.add(this.arLight);
- 
-     // Setup controllers
--    this.controllers.forEach((controller, _index) => {
--      this.cameraRig.add(controller);
--      controller.layers.set(1); // Set to AR layer
--      this.setupController(controller);
-+    this.controllers.forEach((_controller, index) => {
-+      this.setupController(index);
-     });
- 
-     // Setup controller grips
--    this.controllerGrips.forEach((grip, _index) => {
--      this.cameraRig.add(grip);
--      grip.layers.set(1); // Set to AR layer
-+    this.controllerGrips.forEach(grip => {
-       this.setupControllerGrip(grip);
-     });
-   }
- 
--  private setupController(controller: THREE.Group): void {
--    controller.addEventListener('connected', this.onControllerConnected);
--    controller.addEventListener('disconnected', this.onControllerDisconnected);
--  }
-+  private setupController(index: number): void {
-+    const controller = this.controllers[index];
-+    const controllerGrip = this.controllerGrips[index];
- 
--private onControllerConnected = (event: THREE.Event): void => {
--  // Cast the event to XRControllerEvent
--  const xrEvent = event as THREE.XRControllerEvent;
--  // Cast the event target to Object3D first, then to Group
--  const controller = (xrEvent.target as unknown as THREE.Object3D) as THREE.Group;
--  controller.userData.inputSource = xrEvent.data;
-+    controller.addEventListener('connected', (event: any) => {
-+      const controllerModel = this.buildController(event.data);
-+      controller.add(controllerModel);
-+      this.notifyControllerAdded(controller);
-+    });
- 
--  if (xrEvent.data.targetRayMode === 'tracked-pointer') {
--    const pointer = this.createControllerPointer();
--    controller.add(pointer);
--  }
--}
-+    controller.addEventListener('disconnected', () => {
-+      controller.remove(...controller.children);
-+      this.notifyControllerRemoved(controller);
-+    });
- 
--private onControllerDisconnected = (event: THREE.Event): void => {
--  // Cast the event target to Object3D first, then to Group
--  const controller = (event.target as unknown as THREE.Object3D) as THREE.Group;
--  controller.remove(...controller.children);
-+    this.cameraRig.add(controller);
-+    this.cameraRig.add(controllerGrip);
-   }
- 
-   private setupControllerGrip(grip: THREE.Group): void {
-@@ -180,17 +173,13 @@ private onControllerDisconnected = (event: THREE.Event): void => {
-     grip.add(controllerModel);
-   }
- 
--  private createControllerPointer(): THREE.Mesh {
--    const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08);
--    geometry.rotateX(-Math.PI / 2);
--    const material = new THREE.MeshPhongMaterial({
--      color: 0xffffff,
--      transparent: true,
--      opacity: 0.8
--    });
--    const pointer = new THREE.Mesh(geometry, material);
--    pointer.layers.set(1); // Set to AR layer
--    return pointer;
-+  private buildController(_inputSource: XRInputSource): THREE.Group {
-+    const controller = new THREE.Group();
-+    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
-+    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
-+    const sphere = new THREE.Mesh(geometry, material);
-+    controller.add(sphere);
-+    return controller;
-   }
- 
-   /**
-@@ -421,6 +410,22 @@ private onControllerDisconnected = (event: THREE.Event): void => {
-     this.xrAnimationFrameCallback = onFrame;
-   }
- 
-+  public onControllerAdded(callback: (controller: THREE.Group) => void): void {
-+    this.controllerAddedCallback = callback;
-+  }
-+
-+  public onControllerRemoved(callback: (controller: THREE.Group) => void): void {
-+    this.controllerRemovedCallback = callback;
-+  }
-+
-+  private notifyControllerAdded(controller: THREE.Group): void {
-+    this.controllerAddedCallback?.(controller);
-+  }
-+
-+  private notifyControllerRemoved(controller: THREE.Group): void {
-+    this.controllerRemovedCallback?.(controller);
-+  }
-+
-   /**
-    * Get XR objects
-    */
-@@ -461,41 +466,33 @@ private onControllerDisconnected = (event: THREE.Event): void => {
-    * Clean up resources
-    */
-   dispose(): void {
--    if (this.hitTestSource) {
--      this.hitTestSource.cancel();
--    }
--
-     if (this.session) {
--      this.session.end();
-+      this.session.end().catch(console.error);
-     }
- 
--    // Remove event listeners
-     this.controllers.forEach(controller => {
--      controller.removeEventListener('connected', this.onControllerConnected);
--      controller.removeEventListener('disconnected', this.onControllerDisconnected);
--      controller.remove(...controller.children);
-+      controller.removeEventListener('connected', (event: any) => {
-+        const controllerModel = this.buildController(event.data);
-+        controller.add(controllerModel);
-+        this.notifyControllerAdded(controller);
-+      });
-+
-+      controller.removeEventListener('disconnected', () => {
-+        controller.remove(...controller.children);
-+        this.notifyControllerRemoved(controller);
-+      });
-     });
- 
-     this.controllerGrips.forEach(grip => {
-       grip.remove(...grip.children);
-     });
- 
--    // Clean up AR group
--    this.arGroup.remove(...this.arGroup.children);
--    this.cameraRig.remove(this.arGroup);
-+    this.hitTestSource?.cancel();
-+    this.hitTestSource = null;
-+    this.hitTestSourceRequested = false;
- 
--    // Clean up camera rig
--    this.cameraRig.remove(...this.cameraRig.children);
--    
--    const scene = this.sceneManager.getScene();
--    scene.remove(this.cameraRig);
--
--    // Dispose geometries and materials
--    this.gridHelper.geometry.dispose();
--    (this.gridHelper.material as THREE.Material).dispose();
--    this.groundPlane.geometry.dispose();
--    (this.groundPlane.material as THREE.Material).dispose();
--    this.hitTestMarker.geometry.dispose();
--    (this.hitTestMarker.material as THREE.Material).dispose();
-+    this.session = null;
-+    this.referenceSpace = null;
-+    this.isPresenting = false;
-   }
- }
-diff --git a/client/xr/xrTypes.ts b/client/xr/xrTypes.ts
-new file mode 100644
-index 00000000..556eb0af
---- /dev/null
-+++ b/client/xr/xrTypes.ts
-@@ -0,0 +1,25 @@
-+import * as THREE from 'three';
-+
-+export interface XRHandWithHaptics {
-+    hand: {
-+        joints: {
-+            [key: string]: THREE.Object3D;
-+        };
-+    };
-+    hapticActuators: any[];
-+    pinchStrength: number;
-+    gripStrength: number;
-+}
-+
-+export interface XRControllerState {
-+    position: THREE.Vector3;
-+    rotation: THREE.Quaternion;
-+    hapticActuator?: any;
-+}
-+
-+export interface XRHandState {
-+    position: THREE.Vector3;
-+    joints: Map<string, THREE.Object3D>;
-+    pinchStrength: number;
-+    gripStrength: number;
-+}
-diff --git a/settings.md b/settings.md
-new file mode 100644
-index 00000000..61225f8f
---- /dev/null
-+++ b/settings.md
-@@ -0,0 +1,590 @@
-+take a look at @/client/implementationPlan.md and @/NETWORK_SETUP.md and @/settings.toml and map out in very high detail how the settings are connected to the visual aspects of the client force directed graph.
-+
-+
-+I'll analyze how the settings in settings.toml connect to the visual aspects of the client force directed graph. I'll focus on the key sections that directly impact visualization and map out their relationships.
-+
-+Let me break this down into the main visual categories and their connections:
-+
-+Node Appearance & Behavior
-+Edge Visualization
-+Physics & Layout
-+Visual Effects (Bloom, etc.)
-+Labels & Text
-+Environment & Scene
-+
-+Task Completed
-+Detailed Mapping of Settings to Visual Aspects:
-+
-+Node Visualization [nodes]
-+
-+Core Appearance:
-+base_size (0.2): Default node sphere size
-+base_color ("#FFB700"): Default node color
-+geometry_segments (32): Sphere quality/smoothness
-+material_type ("physical"): Three.js material type for realistic rendering
-+Material Properties:
-+metalness (0.85): Reflective quality of nodes
-+roughness (0.15): Surface smoothness
-+clearcoat (1.0): Additional glossy layer
-+opacity (0.92): Node transparency
-+Dynamic Sizing:
-+size_by_connections (true): Nodes grow based on connection count
-+size_range ([0.2, 0.5]): Min/max node sizes
-+Color Scheme:
-+color_scheme ("age"): Nodes colored by creation date
-+new_node_color ("#FFD700"): Recently created nodes
-+old_node_color ("#E6A640"): Older nodes
-+core_node_color ("#FFC125"): Central/important nodes
-+secondary_node_color ("#FFD147"): Supporting nodes
-+Interaction Effects:
-+enable_hover_effect (true): Visual feedback on mouse hover
-+hover_scale (1.15): Size increase on hover
-+highlight_color ("#FFFFFF"): Color when selected
-+highlight_duration (350): Animation time in ms
-+highlight_intensity (3.0): Brightness of highlight
-+Edge Visualization [edges]
-+
-+Basic Properties:
-+base_width (2.0): Default edge line thickness
-+color ("#FFD700"): Default edge color
-+opacity (0.6): Edge transparency
-+curve_segments (24): Smoothness of curved edges
-+Dynamic Width:
-+width_by_strength (true): Edges thicken based on connection strength
-+width_range ([2.0, 8.0]): Min/max edge widths
-+Directional Indicators:
-+enable_arrows (true): Show direction arrows
-+arrow_size (0.15): Size of direction indicators
-+Glow Effects:
-+enable_glow (true): Edge light emission
-+glow_color ("#FFD700"): Color of glow effect
-+glow_intensity (0.7): Strength of glow
-+Physics & Layout [physics]
-+
-+Force Simulation:
-+attraction_strength (0.015): Pull between connected nodes
-+repulsion_strength (1500.0): Push between all nodes
-+spring_strength (0.018): Edge tension force
-+damping (0.88): Movement slowdown factor
-+Boundaries:
-+bounds_size (12.0): Size of containment area
-+enable_bounds (true): Keep nodes within bounds
-+collision_radius (0.25): Node collision detection
-+max_velocity (2.5): Speed limit for node movement
-+Visual Effects
-+[bloom]
-+
-+Glow Effects:
-+enabled (true): Overall bloom effect
-+strength (1.8): Intensity of glow
-+radius (0.5): Spread of glow
-+threshold (0.15): Minimum brightness for bloom
-+node_bloom_strength (1.8): Node-specific glow
-+edge_bloom_strength (1.4): Edge-specific glow
-+[animations]
-+
-+Node Animations:
-+enable_node_animations (true): Allow movement animations
-+animation_smoothing (0.92): Movement interpolation
-+motion_blur_strength (0.4): Movement trail effect
-+Edge Effects:
-+edge_pulse_enabled (true): Pulsing edge effect
-+edge_pulse_color ("#FFD700"): Pulse highlight color
-+edge_pulse_frequency (0.5): Pulse speed
-+edge_pulse_width (0.2): Thickness of pulse
-+Labels & Text [labels]
-+
-+Text Display:
-+enable_labels (true): Show node labels
-+desktop_font_size (48): Label text size
-+font_family ("Arial"): Text font
-+text_color ("#FFFFFF"): Label color
-+Label Positioning:
-+vertical_offset (2.8): Text height above node
-+padding (28): Space around text
-+max_visible_labels (75): Performance limit
-+Visibility:
-+depth_fade_start (7.0): Distance to start fading
-+depth_fade_end (25.0): Distance of full fade
-+view_angle_fade (0.7): Fade based on viewing angle
-+Environment & Scene [rendering]
-+
-+Lighting:
-+ambient_light_intensity (0.7): Overall scene brightness
-+directional_light_intensity (1.0): Main light strength
-+environment_intensity (1.2): HDR environment lighting
-+Scene Quality:
-+enable_antialiasing (true): Edge smoothing
-+enable_shadows (true): Shadow casting
-+shadow_map_size (4096): Shadow quality
-+pixel_ratio (1.5): Rendering resolution multiplier
-+Atmosphere:
-+background_color ("#000000"): Scene background
-+fog_enabled (true): Distance fade effect
-+fog_color ("#000000"): Fog color
-+fog_density (0.0008): Fog thickness
-+Reference Grid:
-+enable_grid (true): Show ground grid
-+grid_color ("#1A1A1A"): Grid line color
-+grid_size (10): Grid extent
-+grid_divisions (20): Grid line density
-+This mapping shows how settings.toml provides fine-grained control over every visual aspect of the force-directed graph, from core rendering properties to subtle animation effects. The settings are structured to allow both high-level control (enabling/disabling features) and detailed customization (specific colors, sizes, and behaviors).
-+
-+
-+trace the flow of the data through the server into json and over the websockets into the client code. Ensure that all critical visualisation aspects are handled
-+
-+
-+I'll trace the data flow from server to client, focusing on visualization aspects. I'll analyze:
-+
-+Server-side data preparation
-+WebSocket protocol and data formats
-+Client-side data handling and visualization pipeline
-+How settings and real-time updates are managed
-+From the implementation plan and network setup docs, I can see this involves multiple layers of data transformation and handling.
-+
-+
-+Task Completed
-+Data Flow Trace for Visualization Pipeline:
-+
-+Server-Side Data Preparation (Rust Backend)
-+
-+A. Initial Graph Data (/src/handlers/graph_handler.rs)
-+
-+// Graph data is prepared as two main components:
-+struct GraphData {
-+    nodes: Vec<Node>,      // Node positions and metadata
-+    edges: Vec<Edge>,      // Edge connections and weights
-+}
-+
-+// Each node contains:
-+struct Node {
-+    position: [f32; 3],    // Vector3 position
-+    velocity: [f32; 3],    // Vector3 velocity
-+    metadata: NodeMetadata // Labels, colors, etc.
-+}
-+B. Binary Position Updates
-+
-+Positions/velocities packed as 24-byte chunks (6 x f32)
-+Format: [px, py, pz, vx, vy, vz] per node
-+Optimized for GPU consumption via CUDA/WGSL
-+WebSocket Protocol (/src/handlers/visualization_handler.rs)
-+
-+A. Initial Connection
-+
-+// 1. Settings sent as JSON
-+send_json({
-+    type: "settings",
-+    data: settings_toml_as_json
-+});
-+
-+// 2. Full graph sent as JSON
-+send_json({
-+    type: "graph",
-+    data: {
-+        nodes: [...],
-+        edges: [...]
-+    }
-+});
-+B. Real-time Updates
-+
-+// Binary position updates (90Hz from settings.toml)
-+send_binary(packed_f32_array);
-+
-+// Metadata updates as JSON
-+send_json({
-+    type: "update",
-+    data: {
-+        nodes: [changed_nodes],
-+        edges: [changed_edges]
-+    }
-+});
-+Client-Side Data Pipeline (/client/)
-+
-+A. WebSocket Service (websocket/websocketService.ts)
-+
-+class WebSocketService {
-+    // Handles binary position data
-+    onBinaryMessage(data: ArrayBuffer) {
-+        const positions = new Float32Array(data);
-+        graphData.updatePositions(positions);
-+    }
-+    
-+    // Handles JSON metadata
-+    onJsonMessage(data: any) {
-+        switch(data.type) {
-+            case "settings":
-+                settingsManager.update(data.data);
-+                break;
-+            case "graph":
-+                graphData.setInitialState(data.data);
-+                break;
-+            case "update":
-+                graphData.applyUpdates(data.data);
-+                break;
-+        }
-+    }
-+}
-+B. Graph Data Management (state/graphData.ts)
-+
-+class GraphDataManager {
-+    private nodes: Map<string, NodeData>;
-+    private edges: Map<string, EdgeData>;
-+    
-+    // Updates node positions from binary data
-+    updatePositions(positions: Float32Array) {
-+        // Direct GPU buffer update if possible
-+        this.nodeBuffer.updateData(positions);
-+        // Or update Three.js instances
-+        this.updateInstanceMatrices(positions);
-+    }
-+    
-+    // Applies metadata updates
-+    applyUpdates(updates: UpdateData) {
-+        this.updateNodeVisuals(updates.nodes);
-+        this.updateEdgeVisuals(updates.edges);
-+    }
-+}
-+C. Rendering Pipeline (rendering/)
-+
-+scene.ts:
-+
-+class SceneManager {
-+    private renderer: THREE.WebGLRenderer;
-+    private nodeSystem: NodeSystem;
-+    private edgeSystem: EdgeSystem;
-+    
-+    // Main render loop (synced to settings.websocket.update_rate)
-+    render() {
-+        // Update physics if enabled
-+        if (settings.physics.enabled) {
-+            this.updatePhysics();
-+        }
-+        
-+        // Update visual elements
-+        this.nodeSystem.update();
-+        this.edgeSystem.update();
-+        
-+        // Apply post-processing
-+        if (settings.bloom.enabled) {
-+            this.applyBloomEffect();
-+        }
-+        
-+        // Handle labels
-+        this.updateLabels();
-+        
-+        // Render frame
-+        this.renderer.render(scene, camera);
-+    }
-+}
-+nodes.ts:
-+
-+class NodeSystem {
-+    private geometry: THREE.InstancedBufferGeometry;
-+    private material: THREE.MeshPhysicalMaterial;
-+    
-+    updateNodes() {
-+        // Update visual properties from settings
-+        this.material.metalness = settings.nodes.metalness;
-+        this.material.roughness = settings.nodes.roughness;
-+        
-+        // Update colors based on scheme
-+        this.updateColorScheme(settings.nodes.color_scheme);
-+        
-+        // Update sizes
-+        if (settings.nodes.size_by_connections) {
-+            this.updateSizesByConnections();
-+        }
-+        
-+        // Apply animations
-+        if (settings.animations.enable_node_animations) {
-+            this.animateNodes();
-+        }
-+    }
-+}
-+edges.ts:
-+
-+class EdgeSystem {
-+    private geometry: THREE.BufferGeometry;
-+    private material: THREE.LineBasicMaterial;
-+    
-+    updateEdges() {
-+        // Update edge visuals from settings
-+        this.material.opacity = settings.edges.opacity;
-+        
-+        // Update widths
-+        if (settings.edges.width_by_strength) {
-+            this.updateLineWidths();
-+        }
-+        
-+        // Update arrows if enabled
-+        if (settings.edges.enable_arrows) {
-+            this.updateArrows();
-+        }
-+        
-+        // Apply edge effects
-+        if (settings.edges.enable_glow) {
-+            this.updateEdgeGlow();
-+        }
-+    }
-+}
-+Critical Visualization Aspects Handled:
-+
-+A. Performance Optimizations
-+
-+Binary position updates at 90Hz (settings.websocket.update_rate)
-+Instanced rendering for nodes
-+GPU-accelerated physics when available
-+Label count limiting (settings.labels.max_visible_labels)
-+B. Visual Quality
-+
-+Bloom post-processing
-+Anti-aliasing
-+Shadow mapping
-+Proper depth sorting for transparency
-+C. Real-time Updates
-+
-+Smooth position interpolation
-+Efficient metadata updates
-+Batched visual updates
-+Animation system for transitions
-+D. Memory Management
-+
-+Geometry instancing
-+Texture atlasing for labels
-+Efficient buffer updates
-+Proper disposal of Three.js resources
-+This trace shows how visualization data flows from the server through WebSocket channels and is processed by various client systems while maintaining high performance and visual quality according to the settings configuration.
-+
-+
-+ok, now examine how the control panel allows writing to the settings toml over the json websocket interface to adapt the look of the system
-+
-+
-+I'll analyze how the control panel interacts with settings.toml through the WebSocket interface. From the implementation plan, I can see this is part of the desktop UI that's being rebuilt. I'll trace:
-+
-+Control panel structure and settings interface
-+WebSocket message protocol for settings updates
-+Server-side settings handling
-+Real-time visual updates
-+
-+Task Completed
-+Settings Control Flow Analysis:
-+
-+Desktop Control Panel Implementation (client/ui/settingsPanel.ts)
-+class SettingsPanel {
-+    private settings: VisualizationSettings;
-+    private websocket: WebSocketService;
-+    
-+    // Groups settings into logical control sections
-+    private controlGroups = {
-+        nodes: {
-+            label: "Node Appearance",
-+            controls: [
-+                {
-+                    id: "nodes.base_size",
-+                    type: "slider",
-+                    label: "Base Size",
-+                    min: 0.1,
-+                    max: 1.0,
-+                    step: 0.1
-+                },
-+                {
-+                    id: "nodes.base_color",
-+                    type: "color",
-+                    label: "Base Color"
-+                },
-+                // ... other node controls
-+            ]
-+        },
-+        edges: {
-+            label: "Edge Appearance",
-+            controls: [/* edge controls */]
-+        },
-+        physics: {
-+            label: "Physics Settings",
-+            controls: [/* physics controls */]
-+        },
-+        // ... other control groups
-+    };
-+
-+    // Handles control value changes
-+    private async handleSettingChange(path: string, value: any) {
-+        // Update local settings
-+        this.updateSettingByPath(path, value);
-+        
-+        // Send update to server
-+        await this.websocket.send({
-+            type: "settings_update",
-+            data: {
-+                path,
-+                value
-+            }
-+        });
-+    }
-+
-+    // Batch multiple settings changes
-+    private async saveAllSettings() {
-+        await this.websocket.send({
-+            type: "settings_bulk_update",
-+            data: this.settings
-+        });
-+    }
-+}
-+WebSocket Protocol for Settings Updates
-+A. Client to Server Messages:
-+
-+// Single setting update
-+interface SettingsUpdateMessage {
-+    type: "settings_update";
-+    data: {
-+        path: string;    // e.g. "nodes.base_size"
-+        value: any;      // New value
-+    }
-+}
-+
-+// Bulk settings update
-+interface SettingsBulkUpdateMessage {
-+    type: "settings_bulk_update";
-+    data: VisualizationSettings;
-+}
-+B. Server to Client Messages:
-+
-+// Settings confirmation
-+interface SettingsConfirmation {
-+    type: "settings_updated";
-+    data: {
-+        success: boolean;
-+        error?: string;
-+    }
-+}
-+
-+// Broadcast updated settings
-+interface SettingsBroadcast {
-+    type: "settings_changed";
-+    data: VisualizationSettings;
-+}
-+Server-Side Settings Handler (src/handlers/visualization_handler.rs)
-+pub struct VisualizationHandler {
-+    settings: Arc<RwLock<Settings>>,
-+    clients: Arc<RwLock<HashMap<ClientId, WebSocket>>>,
-+}
-+
-+impl VisualizationHandler {
-+    // Handle incoming settings updates
-+    async fn handle_settings_update(&self, msg: SettingsUpdate) -> Result<()> {
-+        // Update settings.toml
-+        {
-+            let mut settings = self.settings.write().await;
-+            settings.update_path(&msg.path, msg.value)?;
-+            settings.save_to_file("settings.toml")?;
-+        }
-+
-+        // Broadcast to all clients
-+        self.broadcast_settings().await?;
-+        
-+        Ok(())
-+    }
-+
-+    // Handle bulk settings updates
-+    async fn handle_bulk_settings_update(&self, settings: Settings) -> Result<()> {
-+        // Validate settings
-+        settings.validate()?;
-+
-+        // Update settings.toml
-+        {
-+            let mut current = self.settings.write().await;
-+            *current = settings;
-+            current.save_to_file("settings.toml")?;
-+        }
-+
-+        // Broadcast to all clients
-+        self.broadcast_settings().await?;
-+        
-+        Ok(())
-+    }
-+
-+    // Broadcast settings to all clients
-+    async fn broadcast_settings(&self) -> Result<()> {
-+        let settings = self.settings.read().await;
-+        let msg = json!({
-+            "type": "settings_changed",
-+            "data": settings.to_json()
-+        });
-+
-+        for client in self.clients.read().await.values() {
-+            client.send(msg.clone()).await?;
-+        }
-+        
-+        Ok(())
-+    }
-+}
-+Real-Time Visual Updates (client/state/settings.ts)
-+class SettingsManager {
-+    private settings: VisualizationSettings;
-+    private subscribers: Map<string, (value: any) => void>;
-+
-+    // Handle incoming settings updates
-+    handleSettingsChanged(newSettings: VisualizationSettings) {
-+        this.settings = newSettings;
-+        this.notifySubscribers();
-+    }
-+
-+    // Subscribe to settings changes
-+    subscribe(path: string, callback: (value: any) => void) {
-+        this.subscribers.set(path, callback);
-+    }
-+
-+    // Notify all subscribers of changes
-+    private notifySubscribers() {
-+        for (const [path, callback] of this.subscribers) {
-+            const value = this.getSettingByPath(path);
-+            callback(value);
-+        }
-+    }
-+}
-+
-+// Example subscribers in visualization systems
-+class NodeSystem {
-+    constructor(settingsManager: SettingsManager) {
-+        // Subscribe to relevant settings
-+        settingsManager.subscribe("nodes.base_size", this.updateNodeSize);
-+        settingsManager.subscribe("nodes.base_color", this.updateNodeColor);
-+        settingsManager.subscribe("nodes.material_type", this.updateMaterial);
-+    }
-+
-+    private updateNodeSize = (size: number) => {
-+        this.geometry.scale.setScalar(size);
-+        this.geometry.instanceMatrix.needsUpdate = true;
-+    };
-+
-+    private updateNodeColor = (color: string) => {
-+        this.material.color.set(color);
-+        this.material.needsUpdate = true;
-+    };
-+
-+    private updateMaterial = (type: string) => {
-+        this.recreateMaterial(type);
-+    };
-+}
-+Settings Update Flow:
-+sequenceDiagram
-+    participant CP as Control Panel
-+    participant WS as WebSocket Service
-+    participant SRV as Server
-+    participant TOML as settings.toml
-+    participant VIS as Visualization
-+
-+    CP->>WS: settings_update
-+    WS->>SRV: Send update message
-+    SRV->>TOML: Write new settings
-+    SRV->>WS: Broadcast settings_changed
-+    WS->>VIS: Update visualization
-+    VIS->>CP: Reflect changes in UI
-+This system ensures:
-+
-+Real-time visual updates when settings change
-+Persistence of settings in settings.toml
-+Synchronization across all connected clients
-+Type-safe settings updates with validation
-+Efficient batching of multiple settings changes
-+Immediate visual feedback in the control panel
-+The control panel provides a user-friendly interface to modify settings while maintaining the integrity of the settings.toml file and ensuring all clients stay synchronized with the latest visualization parameters.
-\ No newline at end of file
diff --git a/settings.toml b/settings.toml
index 27a1ed81..c7bc8506 100644
--- a/settings.toml
+++ b/settings.toml
@@ -1,44 +1,14 @@
 [animations]
-animation_quality = "high"
-animation_smoothing = 0.92
-edge_animation_enabled = true
-edge_pulse_amplitude = 0.3
-edge_pulse_color = "#FFD700"
-edge_pulse_enabled = true
-edge_pulse_frequency = 0.5
-edge_pulse_width = 0.2
-enable_motion_blur = true
-enable_node_animations = true
-flow_particle_color = "#FFD700"
-flow_particle_count = 5
-flow_particle_size = 0.02
-flow_particle_speed = 0.8
-flow_particle_trail = true
-flow_particle_trail_length = 0.2
-flow_particles_enabled = true
-max_concurrent_animations = 10
+enable_motion_blur = false
+enable_node_animations = false
 motion_blur_strength = 0.4
-pulse_amplitude = 0.15
-pulse_color = "#FFD700"
-pulse_enabled = true
-pulse_frequency = 0.8
-ripple_color = "#FFD700"
-ripple_decay = 0.85
-ripple_enabled = true
-ripple_segments = 32
-ripple_size = 0.4
-ripple_speed = 1.0
-selection_wave_color = "#FFD700"
-selection_wave_enabled = true
-selection_wave_opacity = 0.4
-selection_wave_size = 0.5
-selection_wave_speed = 1.2
 
 [ar]
 drag_threshold = 0.04
 enable_hand_tracking = true
 enable_haptics = true
 enable_light_estimation = true
+enable_passthrough_portal = false
 enable_plane_detection = true
 enable_scene_understanding = true
 gesture_smoothing = 0.9
@@ -49,56 +19,33 @@ hand_point_size = 0.01
 hand_ray_color = "#FFD700"
 hand_ray_enabled = true
 hand_ray_width = 0.002
-hand_trail_enabled = true
-hand_trail_length = 0.5
-hand_trail_opacity = 0.3
 haptic_intensity = 0.7
+passthrough_brightness = 1
+passthrough_contrast = 1
+passthrough_opacity = 1
 pinch_threshold = 0.015
+plane_color = "#4A90E2"
+plane_opacity = 0.3
+portal_edge_color = "#FFD700"
+portal_edge_width = 0.02
+portal_size = 1
 room_scale = true
 rotation_threshold = 0.08
+show_plane_overlay = true
 snap_to_floor = true
 
 [audio]
-ambient_variation = 0.1
-ambient_volume = 0.2
-audio_rolloff = "logarithmic"
-collision_frequency = 220
-creation_frequency = 550
-deletion_frequency = 275
-doppler_factor = 0.5
-edge_creation_sound = true
-edge_creation_volume = 0.5
-edge_deletion_sound = true
-edge_deletion_volume = 0.4
-edge_flow_sound = true
-edge_flow_volume = 0.3
-enable_ambient_sounds = true
-enable_interaction_sounds = true
-enable_spatial_audio = true
-flow_frequency = 385
-hover_frequency = 330
-hover_sound_enabled = true
-hover_sound_volume = 0.4
-master_volume = 0.8
-max_audio_distance = 20.0
-node_collision_sound = true
-node_collision_volume = 0.5
-node_creation_sound = true
-node_creation_volume = 0.6
-node_deletion_sound = true
-node_deletion_volume = 0.5
-selection_frequency = 440
-selection_sound_enabled = true
-selection_sound_volume = 0.7
+enable_ambient_sounds = false
+enable_interaction_sounds = false
+enable_spatial_audio = false
 
 [bloom]
-edge_bloom_strength = 1.4
-enabled = true
-environment_bloom_strength = 1.2
-node_bloom_strength = 1.8
+edge_bloom_strength = 0.3
+enabled = false
+environment_bloom_strength = 0.5
+node_bloom_strength = 0.2
 radius = 0.5
 strength = 1.8
-threshold = 0.15
 
 [client_debug]
 enable_data_debug = false
@@ -121,19 +68,13 @@ retry_delay = 5
 
 [edges]
 arrow_size = 0.15
-base_width = 2.0
-color = "#FFD700"
-curve_segments = 24
-enable_arrows = true
-enable_glow = true
-glow_color = "#FFD700"
-glow_intensity = 0.7
-highlight_color = "#FFFFFF"
+base_width = 2
+color = "#917f18"
+enable_arrows = false
 opacity = 0.6
-width_by_strength = true
 width_range = [
-    2.0,
-    8.0,
+    1,
+    3,
 ]
 
 [github]
@@ -144,21 +85,9 @@ repo = "default_repo"
 token = "default_token"
 
 [labels]
-ar_font_size = 32
-background_color = "#000000"
-background_opacity = 0.92
-close_offset = 0.3
-depth_fade_end = 25.0
-depth_fade_start = 7.0
 desktop_font_size = 48
 enable_labels = true
-font_family = "Arial"
-info_color = "#E6E6E6"
-max_visible_labels = 75
-padding = 28
 text_color = "#FFFFFF"
-vertical_offset = 2.8
-view_angle_fade = 0.7
 
 [network]
 bind_address = "0.0.0.0"
@@ -174,32 +103,22 @@ rate_limit_window = 60
 tunnel_id = "dummy"
 
 [nodes]
-age_max_days = 30
-base_color = "#FFB700"
-base_size = 0.2
-clearcoat = 1.0
-clearcoat_roughness = 0.05
-color_scheme = "age"
-core_node_color = "#FFC125"
-enable_hover_effect = true
-enable_instancing = true
-enable_transparency = true
-geometry_segments = 32
-highlight_color = "#FFFFFF"
-highlight_duration = 350
-highlight_intensity = 3.0
-hover_scale = 1.15
-material_type = "physical"
-metalness = 0.85
-new_node_color = "#FFD700"
-old_node_color = "#E6A640"
-opacity = 0.92
-roughness = 0.15
-secondary_node_color = "#FFD147"
+base_color = "#c3ab6f"
+base_size = 1
+clearcoat = 1
+enable_hover_effect = false
+enable_instancing = false
+highlight_color = "#822626"
+highlight_duration = 300
+hover_scale = 1.2
+material_type = "basic"
+metalness = 0.3
+opacity = 0.4
+roughness = 0.35
 size_by_connections = true
 size_range = [
-    0.2,
-    0.5,
+    1,
+    5,
 ]
 
 [openai]
@@ -215,26 +134,23 @@ api_url = "https://api.perplexity.ai/chat/completions"
 frequency_penalty = 1.0
 max_tokens = 4096
 model = "llama-3.1-sonar-small-128k-online"
-presence_penalty = 0.0
-prompt = """
-You are an AI assistant for LogSeq knowledge summaries via perplexity API. Style: Informative, analytical, optimistic, critical, conversational, authoritative. Markdown: hierarchical headings (- #), minimal bold, italics for book titles, descriptive links [URL](text), images ![alt](path){:width height}, embeds {{type id}}, lists with '-', block refs [[title]], properties property:: value, code blocks ```lang``` and `inline code`, \r
- newlines, public:: true at start/end. UK spelling, introduce acronyms once, numeric citations, [[reference]] for sources, minimal emojis, parentheses for asides, collapsed:: true. Focus on emerging tech (decentralization, AI, XR), detail, credible sources, implications, examples, future-oriented. Adhere strictly, ensure accuracy, consistency, large context, refine with feedback."""
+prompt = "You are an AI assistant for LogSeq knowledge summaries via perplexity API. Style: Informative, analytical, optimistic, critical, conversational, authoritative. Markdown: hierarchical headings (- #), minimal bold, italics for book titles, descriptive links [URL](text), images ![alt](path){:width height}, embeds {{type id}}, lists with '-', block refs [[title]], properties property:: value, code blocks ```lang``` and `inline code`, \r newlines, public:: true at start. UK spelling, introduce acronyms once, numeric citations, [[reference]] for sources, minimal emojis, parentheses for asides, collapsed:: true. Focus on emerging tech (decentralization, AI, XR), detail, credible sources, implications, examples, future-oriented. Adhere strictly, ensure accuracy, consistency, large context, refine with feedback."
 rate_limit = 100
+resence_penalty = 0.0
 temperature = 0.5
 timeout = 30
 top_p = 0.9
 
 [physics]
 attraction_strength = 0.015
-bounds_size = 12.0
+bounds_size = 12
 collision_radius = 0.25
 damping = 0.88
 enable_bounds = true
-enable_collision = true
-enabled = true
+enabled = false
 iterations = 500
 max_velocity = 2.5
-repulsion_strength = 1500.0
+repulsion_strength = 1500
 spring_strength = 0.018
 
 [ragflow]
@@ -246,22 +162,11 @@ timeout = 30
 [rendering]
 ambient_light_intensity = 0.7
 background_color = "#000000"
-directional_light_intensity = 1.0
-enable_ambient_occlusion = true
+directional_light_intensity = 1
+enable_ambient_occlusion = false
 enable_antialiasing = true
-enable_gpu_acceleration = true
-enable_grid = true
-enable_hemisphere_light = true
-enable_shadows = true
+enable_shadows = false
 environment_intensity = 1.2
-fog_color = "#000000"
-fog_density = 0.0008
-fog_enabled = true
-grid_color = "#1A1A1A"
-grid_divisions = 20
-grid_size = 10
-pixel_ratio = 1.5
-shadow_map_size = 4096
 
 [security]
 allowed_origins = []
@@ -271,10 +176,7 @@ cookie_samesite = "Strict"
 cookie_secure = true
 csrf_token_timeout = 3600
 enable_audit_logging = true
-enable_cors = false
-enable_csrf = false
 enable_request_validation = true
-enable_security_headers = false
 session_timeout = 3600
 
 [server_debug]
diff --git a/src/config.rs b/src/config.rs
index 33fddd67..f2246524 100755
--- a/src/config.rs
+++ b/src/config.rs
@@ -3,118 +3,51 @@ use config::{ConfigBuilder, ConfigError, Environment, File};
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct Settings {
-    pub server_debug: DebugSettings,
-    pub client_debug: DebugSettings,
+    pub default: DefaultSettings,
     pub network: NetworkSettings,
     pub security: SecuritySettings,
-    pub github: GitHubSettings,
-    pub ragflow: RagFlowSettings,
-    pub perplexity: PerplexitySettings,
-    pub openai: OpenAISettings,
-    pub default: DefaultSettings,
     pub rendering: RenderingSettings,
+    pub ar: ARSettings,
     pub nodes: NodeSettings,
     pub edges: EdgeSettings,
-    pub labels: LabelSettings,
-    pub bloom: BloomSettings,
-    pub ar: ARSettings,
     pub physics: PhysicsSettings,
+    pub bloom: BloomSettings,
+    pub labels: LabelSettings,
+    pub websocket: WebSocketSettings,
+    pub server_debug: DebugSettings,
+    pub client_debug: DebugSettings,
+    pub github: GitHubSettings,
+    pub openai: OpenAISettings,
+    pub perplexity: PerplexitySettings,
+    pub ragflow: RagFlowSettings,
     pub animations: AnimationSettings,
     pub audio: AudioSettings,
-    pub websocket: WebSocketSettings,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct WebSocketSettings {
-    #[serde(default = "default_compression_enabled")]
-    pub compression_enabled: bool,
-    #[serde(default = "default_compression_threshold")]
-    pub compression_threshold: usize,
-    #[serde(default = "default_max_message_size")]
-    pub max_message_size: usize,
-    #[serde(default = "default_update_rate")]
-    pub update_rate: u32,
-    #[serde(default = "default_heartbeat_interval")]
-    pub heartbeat_interval: u64,
-    #[serde(default = "default_heartbeat_timeout")]
-    pub heartbeat_timeout: u64,
-    #[serde(default = "default_max_connections")]
-    pub max_connections: usize,
-    #[serde(default = "default_reconnect_attempts")]
-    pub reconnect_attempts: u32,
-    #[serde(default = "default_reconnect_delay")]
-    pub reconnect_delay: u64,
-    #[serde(default = "default_binary_chunk_size")]
-    pub binary_chunk_size: usize,
 }
 
-// Default functions for WebSocket settings
-fn default_compression_enabled() -> bool { true }
-fn default_compression_threshold() -> usize { 1024 }  // 1KB
-fn default_max_message_size() -> usize { 100 * 1024 * 1024 }  // 100MB
-fn default_update_rate() -> u32 { 5 }  // 5fps
-fn default_heartbeat_interval() -> u64 { 15000 }  // 15 seconds
-fn default_heartbeat_timeout() -> u64 { 60000 }  // 60 seconds
-fn default_max_connections() -> usize { 1000 }
-fn default_reconnect_attempts() -> u32 { 3 }
-fn default_reconnect_delay() -> u64 { 5000 }  // 5 seconds
-fn default_binary_chunk_size() -> usize { 64 * 1024 }  // 64KB
-
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct DebugSettings {
-    pub enabled: bool,
-    pub enable_websocket_debug: bool,
-    pub enable_data_debug: bool,
-    pub log_binary_headers: bool,
-    pub log_full_json: bool,
-}
-
-impl Default for DebugSettings {
-    fn default() -> Self {
-        Self {
-            enabled: false,
-            enable_websocket_debug: false,
-            enable_data_debug: false,
-            log_binary_headers: false,
-            log_full_json: false,
-        }
-    }
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct GitHubSettings {
-    #[serde(default = "default_token")]
-    pub token: String,
-    
-    #[serde(default = "default_owner")]
-    pub owner: String,
-    
-    #[serde(default = "default_repo")]
-    pub repo: String,
-    
-    #[serde(default = "default_path")]
-    pub base_path: String,
-    
-    #[serde(default = "default_rate_limit")]
-    pub rate_limit: bool,
+pub struct DefaultSettings {
+    pub api_client_timeout: u64,
+    pub enable_metrics: bool,
+    pub enable_request_logging: bool,
+    pub log_format: String,
+    pub log_level: String,
+    pub max_concurrent_requests: usize,
+    pub max_payload_size: usize,
+    pub max_retries: u32,
+    pub metrics_port: u16,
+    pub retry_delay: u64,
 }
 
-fn default_token() -> String { "".to_string() }
-fn default_owner() -> String { "".to_string() }
-fn default_repo() -> String { "".to_string() }
-fn default_path() -> String { "".to_string() }
-fn default_rate_limit() -> bool { true }
-
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct NetworkSettings {
-    pub domain: String,
-    pub port: u16,
     pub bind_address: String,
-    pub enable_tls: bool,
-    pub min_tls_version: String,
+    pub domain: String,
     pub enable_http2: bool,
-    pub max_request_size: usize,
     pub enable_rate_limiting: bool,
+    pub enable_tls: bool,
+    pub max_request_size: usize,
+    pub min_tls_version: String,
+    pub port: u16,
     pub rate_limit_requests: u32,
     pub rate_limit_window: u32,
     pub tunnel_id: String,
@@ -122,110 +55,48 @@ pub struct NetworkSettings {
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct SecuritySettings {
-    pub enable_cors: bool,
     pub allowed_origins: Vec<String>,
-    pub enable_csrf: bool,
-    pub csrf_token_timeout: u32,
-    pub session_timeout: u32,
-    pub cookie_secure: bool,
+    pub audit_log_path: String,
     pub cookie_httponly: bool,
     pub cookie_samesite: String,
-    pub enable_security_headers: bool,
-    pub enable_request_validation: bool,
+    pub cookie_secure: bool,
+    pub csrf_token_timeout: u32,
     pub enable_audit_logging: bool,
-    pub audit_log_path: String,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct RagFlowSettings {
-    pub api_key: String,
-    pub base_url: String,
-    pub timeout: u64,
-    pub max_retries: u32,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct PerplexitySettings {
-    pub api_key: String,
-    pub prompt: String,
-    pub model: String,
-    pub api_url: String,
-    pub max_tokens: u32,
-    pub temperature: f32,
-    pub top_p: f32,
-    pub presence_penalty: f32,
-    pub frequency_penalty: f32,
-    pub timeout: u64,
-    pub rate_limit: u32,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct OpenAISettings {
-    pub api_key: String,
-    pub base_url: String,
-    pub timeout: u64,
-    pub rate_limit: u32,
-    pub model: String,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct DefaultSettings {
-    pub max_concurrent_requests: usize,
-    pub max_retries: u32,
-    pub retry_delay: u64,
-    pub api_client_timeout: u64,
-    pub max_payload_size: usize,
-    pub enable_request_logging: bool,
-    pub enable_metrics: bool,
-    pub metrics_port: u16,
-    pub log_format: String,
+    pub enable_request_validation: bool,
+    pub session_timeout: u32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct RenderingSettings {
+    pub ambient_light_intensity: f32,
+    pub background_color: String,
+    pub directional_light_intensity: f32,
+    pub enable_ambient_occlusion: bool,
     pub enable_antialiasing: bool,
     pub enable_shadows: bool,
-    pub enable_ambient_occlusion: bool,
-    pub shadow_map_size: u32,
-    pub pixel_ratio: f32,
-    pub enable_gpu_acceleration: bool,
-    pub background_color: String,
     pub environment_intensity: f32,
-    pub ambient_light_intensity: f32,
-    pub directional_light_intensity: f32,
-    pub enable_hemisphere_light: bool,
-    pub fog_enabled: bool,
-    pub fog_color: String,
-    pub fog_density: f32,
-    pub enable_grid: bool,
-    pub grid_size: u32,
-    pub grid_divisions: u32,
-    pub grid_color: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct ARSettings {
+    pub enable_hand_tracking: bool,
+    pub enable_haptics: bool,
+    pub enable_plane_detection: bool,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct NodeSettings {
+    pub base_color: String,
     pub base_size: f32,
     pub size_range: Vec<f32>,
     pub size_by_connections: bool,
-    pub geometry_segments: u32,
     pub enable_instancing: bool,
     pub material_type: String,
-    pub metalness: f32,
+    pub opacity: f32,
     pub roughness: f32,
+    pub metalness: f32,
     pub clearcoat: f32,
-    pub clearcoat_roughness: f32,
-    pub opacity: f32,
-    pub enable_transparency: bool,
-    pub base_color: String,
-    pub color_scheme: String,
-    pub new_node_color: String,
-    pub old_node_color: String,
-    pub core_node_color: String,
-    pub secondary_node_color: String,
-    pub age_max_days: u32,
     pub highlight_color: String,
-    pub highlight_intensity: f32,
     pub highlight_duration: u32,
     pub enable_hover_effect: bool,
     pub hover_scale: f32,
@@ -235,160 +106,125 @@ pub struct NodeSettings {
 pub struct EdgeSettings {
     pub base_width: f32,
     pub width_range: Vec<f32>,
-    pub width_by_strength: bool,
-    pub curve_segments: u32,
-    pub enable_arrows: bool,
-    pub arrow_size: f32,
-    pub opacity: f32,
     pub color: String,
-    pub highlight_color: String,
-    pub enable_glow: bool,
-    pub glow_intensity: f32,
-    pub glow_color: String,
+    pub opacity: f32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct LabelSettings {
-    pub enable_labels: bool,
-    pub font_family: String,
-    pub desktop_font_size: u32,
-    pub ar_font_size: u32,
-    pub padding: u32,
-    pub background_opacity: f32,
-    pub max_visible_labels: u32,
-    pub vertical_offset: f32,
-    pub close_offset: f32,
-    pub view_angle_fade: f32,
-    pub depth_fade_start: f32,
-    pub depth_fade_end: f32,
-    pub text_color: String,
-    pub info_color: String,
-    pub background_color: String,
+pub struct PhysicsSettings {
+    pub attraction_strength: f32,
+    pub bounds_size: f32,
+    pub collision_radius: f32,
+    pub damping: f32,
+    pub enable_bounds: bool,
+    pub enabled: bool,
+    pub iterations: u32,
+    pub max_velocity: f32,
+    pub repulsion_strength: f32,
+    pub spring_strength: f32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct BloomSettings {
     pub enabled: bool,
-    pub strength: f32,
-    pub radius: f32,
-    pub threshold: f32,
     pub node_bloom_strength: f32,
     pub edge_bloom_strength: f32,
     pub environment_bloom_strength: f32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct ARSettings {
-    pub enable_plane_detection: bool,
-    pub enable_light_estimation: bool,
-    pub enable_hand_tracking: bool,
-    pub enable_scene_understanding: bool,
-    pub snap_to_floor: bool,
-    pub room_scale: bool,
-    pub hand_mesh_enabled: bool,
-    pub hand_mesh_opacity: f32,
-    pub hand_mesh_color: String,
-    pub hand_ray_enabled: bool,
-    pub hand_ray_color: String,
-    pub hand_ray_width: f32,
-    pub hand_point_size: f32,
-    pub hand_trail_enabled: bool,
-    pub hand_trail_length: f32,
-    pub hand_trail_opacity: f32,
-    pub pinch_threshold: f32,
-    pub drag_threshold: f32,
-    pub rotation_threshold: f32,
-    pub enable_haptics: bool,
-    pub haptic_intensity: f32,
-    pub gesture_smoothing: f32,
+pub struct LabelSettings {
+    pub enable_labels: bool,
+    pub text_color: String,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct PhysicsSettings {
+pub struct WebSocketSettings {
+    pub binary_chunk_size: usize,
+    pub compression_enabled: bool,
+    pub compression_threshold: usize,
+    pub heartbeat_interval: u64,
+    pub heartbeat_timeout: u64,
+    pub max_connections: usize,
+    pub max_message_size: usize,
+    pub reconnect_attempts: u32,
+    pub reconnect_delay: u64,
+    pub update_rate: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct DebugSettings {
+    pub enable_data_debug: bool,
+    pub enable_websocket_debug: bool,
     pub enabled: bool,
-    pub iterations: u32,
-    pub spring_strength: f32,
-    pub repulsion_strength: f32,
-    pub attraction_strength: f32,
-    pub damping: f32,
-    pub enable_bounds: bool,
-    pub bounds_size: f32,
-    pub enable_collision: bool,
-    pub collision_radius: f32,
-    pub max_velocity: f32,
+    pub log_binary_headers: bool,
+    pub log_full_json: bool,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct GitHubSettings {
+    pub base_path: String,
+    pub owner: String,
+    pub rate_limit: bool,
+    pub repo: String,
+    pub token: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct OpenAISettings {
+    pub api_key: String,
+    pub base_url: String,
+    pub model: String,
+    pub rate_limit: u32,
+    pub timeout: u64,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct PerplexitySettings {
+    pub api_key: String,
+    pub api_url: String,
+    pub frequency_penalty: f32,
+    pub max_tokens: u32,
+    pub model: String,
+    pub prompt: String,
+    pub rate_limit: u32,
+    pub temperature: f32,
+    pub timeout: u64,
+    pub top_p: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct RagFlowSettings {
+    pub api_key: String,
+    pub base_url: String,
+    pub max_retries: u32,
+    pub timeout: u64,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct AnimationSettings {
+    #[serde(default)]
     pub enable_node_animations: bool,
+    #[serde(default)]
     pub selection_wave_enabled: bool,
-    pub selection_wave_color: String,
-    pub selection_wave_speed: f32,
-    pub selection_wave_size: f32,
-    pub selection_wave_opacity: f32,
+    #[serde(default)]
     pub pulse_enabled: bool,
-    pub pulse_frequency: f32,
-    pub pulse_amplitude: f32,
-    pub pulse_color: String,
+    #[serde(default)]
     pub ripple_enabled: bool,
-    pub ripple_speed: f32,
-    pub ripple_size: f32,
-    pub ripple_segments: u32,
-    pub ripple_color: String,
-    pub ripple_decay: f32,
+    #[serde(default)]
     pub edge_animation_enabled: bool,
+    #[serde(default)]
     pub flow_particles_enabled: bool,
-    pub flow_particle_count: u32,
-    pub flow_particle_size: f32,
-    pub flow_particle_speed: f32,
-    pub flow_particle_color: String,
-    pub flow_particle_trail: bool,
-    pub flow_particle_trail_length: f32,
-    pub edge_pulse_enabled: bool,
-    pub edge_pulse_frequency: f32,
-    pub edge_pulse_amplitude: f32,
-    pub edge_pulse_color: String,
-    pub edge_pulse_width: f32,
-    pub animation_quality: String,
-    pub enable_motion_blur: bool,
-    pub motion_blur_strength: f32,
-    pub animation_smoothing: f32,
-    pub max_concurrent_animations: u32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct AudioSettings {
+    #[serde(default)]
     pub enable_spatial_audio: bool,
-    pub master_volume: f32,
-    pub audio_rolloff: String,
-    pub max_audio_distance: f32,
-    pub doppler_factor: f32,
+    #[serde(default)]
     pub enable_interaction_sounds: bool,
-    pub selection_sound_enabled: bool,
-    pub selection_sound_volume: f32,
-    pub hover_sound_enabled: bool,
-    pub hover_sound_volume: f32,
-    pub node_collision_sound: bool,
-    pub node_collision_volume: f32,
-    pub node_creation_sound: bool,
-    pub node_creation_volume: f32,
-    pub node_deletion_sound: bool,
-    pub node_deletion_volume: f32,
-    pub edge_creation_sound: bool,
-    pub edge_creation_volume: f32,
-    pub edge_deletion_sound: bool,
-    pub edge_deletion_volume: f32,
-    pub edge_flow_sound: bool,
-    pub edge_flow_volume: f32,
+    #[serde(default)]
     pub enable_ambient_sounds: bool,
-    pub ambient_volume: f32,
-    pub ambient_variation: f32,
-    pub selection_frequency: u32,
-    pub hover_frequency: u32,
-    pub collision_frequency: u32,
-    pub creation_frequency: u32,
-    pub deletion_frequency: u32,
-    pub flow_frequency: u32,
 }
 
 impl Settings {
diff --git a/src/handlers/visualization_handler.rs b/src/handlers/visualization_handler.rs
index 9206f560..e09680c7 100755
--- a/src/handlers/visualization_handler.rs
+++ b/src/handlers/visualization_handler.rs
@@ -1,62 +1,318 @@
 use crate::config::Settings;
-use crate::utils::socket_flow_messages::{Message, SettingsUpdate, UpdateSettings};
 use actix_web::{web, HttpResponse};
 use std::sync::Arc;
 use tokio::sync::RwLock;
 use serde_json::Value;
 use std::fs;
+use std::path::PathBuf;
 use toml;
 
+// GET /api/visualization/settings
 pub async fn get_visualization_settings(
     settings: web::Data<Arc<RwLock<Settings>>>,
 ) -> HttpResponse {
-    let settings = settings.read().await;
-    let settings_json = serde_json::json!({
-        "rendering": settings.rendering,
-        "nodes": settings.nodes,
-        "edges": settings.edges,
-        "labels": settings.labels,
-        "bloom": settings.bloom,
-        "ar": settings.ar,
-        "physics": settings.physics,
-        "animations": settings.animations,
-        "audio": settings.audio
+    let settings_guard = settings.read().await;
+    
+    // Break down JSON construction into parts
+    let node_settings = serde_json::json!({
+        "nodeSize": settings_guard.nodes.base_size,
+        "nodeColor": settings_guard.nodes.base_color,
+        "nodeOpacity": settings_guard.nodes.opacity,
+        "metalness": settings_guard.nodes.metalness,
+        "roughness": settings_guard.nodes.roughness,
+        "clearcoat": settings_guard.nodes.clearcoat,
+        "enableInstancing": settings_guard.nodes.enable_instancing,
+        "materialType": settings_guard.nodes.material_type,
+        "sizeRange": settings_guard.nodes.size_range,
+        "sizeByConnections": settings_guard.nodes.size_by_connections,
+        "highlightColor": settings_guard.nodes.highlight_color,
+        "highlightDuration": settings_guard.nodes.highlight_duration,
+        "enableHoverEffect": settings_guard.nodes.enable_hover_effect
+    });
+
+    let edge_settings = serde_json::json!({
+        "edgeWidth": settings_guard.edges.base_width,
+        "edgeColor": settings_guard.edges.color,
+        "edgeOpacity": settings_guard.edges.opacity,
+        "edgeWidthRange": settings_guard.edges.width_range
+    });
+
+    let physics_settings = serde_json::json!({
+        "physicsEnabled": settings_guard.physics.enabled,
+        "attractionStrength": settings_guard.physics.attraction_strength,
+        "repulsionStrength": settings_guard.physics.repulsion_strength,
+        "springStrength": settings_guard.physics.spring_strength,
+        "damping": settings_guard.physics.damping,
+        "maxVelocity": settings_guard.physics.max_velocity,
+        "collisionRadius": settings_guard.physics.collision_radius,
+        "boundsSize": settings_guard.physics.bounds_size,
+        "enableBounds": settings_guard.physics.enable_bounds,
+        "iterations": settings_guard.physics.iterations
+    });
+
+    let rendering_settings = serde_json::json!({
+        "ambientLightIntensity": settings_guard.rendering.ambient_light_intensity,
+        "directionalLightIntensity": settings_guard.rendering.directional_light_intensity,
+        "environmentIntensity": settings_guard.rendering.environment_intensity,
+        "enableAmbientOcclusion": settings_guard.rendering.enable_ambient_occlusion,
+        "enableAntialiasing": settings_guard.rendering.enable_antialiasing,
+        "enableShadows": settings_guard.rendering.enable_shadows,
+        "backgroundColor": settings_guard.rendering.background_color
+    });
+
+    let bloom_settings = serde_json::json!({
+        "bloomEnabled": settings_guard.bloom.enabled,
+        "nodeBloomStrength": settings_guard.bloom.node_bloom_strength,
+        "edgeBloomStrength": settings_guard.bloom.edge_bloom_strength,
+        "environmentBloomStrength": settings_guard.bloom.environment_bloom_strength
     });
 
-    HttpResponse::Ok().json(settings_json)
+    let animation_settings = serde_json::json!({
+        "enableNodeAnimations": settings_guard.animations.enable_node_animations,
+        "selectionWaveEnabled": settings_guard.animations.selection_wave_enabled,
+        "pulseEnabled": settings_guard.animations.pulse_enabled,
+        "rippleEnabled": settings_guard.animations.ripple_enabled,
+        "edgeAnimationEnabled": settings_guard.animations.edge_animation_enabled,
+        "flowParticlesEnabled": settings_guard.animations.flow_particles_enabled
+    });
+
+    let label_settings = serde_json::json!({
+        "enableLabels": settings_guard.labels.enable_labels,
+        "textColor": settings_guard.labels.text_color
+    });
+
+    let ar_settings = serde_json::json!({
+        "enablePlaneDetection": settings_guard.ar.enable_plane_detection,
+        "enableHandTracking": settings_guard.ar.enable_hand_tracking,
+        "enableHaptics": settings_guard.ar.enable_haptics
+    });
+
+    // Combine all settings
+    let mut settings_map = serde_json::Map::new();
+    if let Some(obj) = node_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+    if let Some(obj) = edge_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+    if let Some(obj) = physics_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+    if let Some(obj) = rendering_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+    if let Some(obj) = bloom_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+    if let Some(obj) = animation_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+    if let Some(obj) = label_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+    if let Some(obj) = ar_settings.as_object() {
+        settings_map.extend(obj.clone());
+    }
+
+    HttpResponse::Ok().json(serde_json::Value::Object(settings_map))
 }
 
-pub async fn handle_settings_message(
-    message: Message,
-    settings: Arc<RwLock<Settings>>,
-) -> Option<Message> {
-    match message {
-        Message::UpdateSettings(UpdateSettings { settings: new_settings }) => {
-            // Update settings in memory
-            let mut settings_lock = settings.write().await;
-            update_settings(&mut *settings_lock, new_settings);
-            
-            // Save settings to file
-            if let Err(e) = save_settings_to_file(&*settings_lock) {
-                log::error!("Failed to save settings to file: {}", e);
-            }
-            
-            // Send updated settings back to all clients
-            Some(Message::SettingsUpdated(SettingsUpdate {
-                settings: serde_json::json!({
-                    "rendering": settings_lock.rendering,
-                    "nodes": settings_lock.nodes,
-                    "edges": settings_lock.edges,
-                    "labels": settings_lock.labels,
-                    "bloom": settings_lock.bloom,
-                    "ar": settings_lock.ar,
-                    "physics": settings_lock.physics,
-                    "animations": settings_lock.animations,
-                    "audio": settings_lock.audio
-                })
-            }))
-        },
-        _ => None
+// PUT /api/visualization/settings
+pub async fn update_visualization_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    new_settings: web::Json<serde_json::Value>,
+) -> HttpResponse {
+    // Clone the settings Data before borrowing
+    let settings_clone = settings.clone();
+    let mut settings_guard = settings.write().await;
+    
+    if let Some(obj) = new_settings.as_object() {
+        // Update node settings
+        if let Some(size) = obj.get("nodeSize").and_then(|v| v.as_f64()) {
+            settings_guard.nodes.base_size = size as f32;
+        }
+        if let Some(color) = obj.get("nodeColor").and_then(|v| v.as_str()) {
+            settings_guard.nodes.base_color = color.to_string();
+        }
+        if let Some(opacity) = obj.get("nodeOpacity").and_then(|v| v.as_f64()) {
+            settings_guard.nodes.opacity = opacity as f32;
+        }
+        if let Some(metalness) = obj.get("metalness").and_then(|v| v.as_f64()) {
+            settings_guard.nodes.metalness = metalness as f32;
+        }
+        if let Some(roughness) = obj.get("roughness").and_then(|v| v.as_f64()) {
+            settings_guard.nodes.roughness = roughness as f32;
+        }
+        if let Some(clearcoat) = obj.get("clearcoat").and_then(|v| v.as_f64()) {
+            settings_guard.nodes.clearcoat = clearcoat as f32;
+        }
+        if let Some(enable_instancing) = obj.get("enableInstancing").and_then(|v| v.as_bool()) {
+            settings_guard.nodes.enable_instancing = enable_instancing;
+        }
+        if let Some(material_type) = obj.get("materialType").and_then(|v| v.as_str()) {
+            settings_guard.nodes.material_type = material_type.to_string();
+        }
+        if let Some(size_range) = obj.get("sizeRange").and_then(|v| v.as_array()) {
+            settings_guard.nodes.size_range = size_range.iter()
+                .filter_map(|x| x.as_f64())
+                .map(|x| x as f32)
+                .collect();
+        }
+        if let Some(size_by_connections) = obj.get("sizeByConnections").and_then(|v| v.as_bool()) {
+            settings_guard.nodes.size_by_connections = size_by_connections;
+        }
+        if let Some(highlight_color) = obj.get("highlightColor").and_then(|v| v.as_str()) {
+            settings_guard.nodes.highlight_color = highlight_color.to_string();
+        }
+        if let Some(highlight_duration) = obj.get("highlightDuration").and_then(|v| v.as_f64()) {
+            settings_guard.nodes.highlight_duration = highlight_duration as u32;
+        }
+        if let Some(enable_hover_effect) = obj.get("enableHoverEffect").and_then(|v| v.as_bool()) {
+            settings_guard.nodes.enable_hover_effect = enable_hover_effect;
+        }
+
+        // Update edge settings
+        if let Some(base_width) = obj.get("edgeWidth").and_then(|v| v.as_f64()) {
+            settings_guard.edges.base_width = base_width as f32;
+        }
+        if let Some(color) = obj.get("edgeColor").and_then(|v| v.as_str()) {
+            settings_guard.edges.color = color.to_string();
+        }
+        if let Some(opacity) = obj.get("edgeOpacity").and_then(|v| v.as_f64()) {
+            settings_guard.edges.opacity = opacity as f32;
+        }
+        if let Some(width_range) = obj.get("edgeWidthRange").and_then(|v| v.as_array()) {
+            settings_guard.edges.width_range = width_range.iter()
+                .filter_map(|x| x.as_f64())
+                .map(|x| x as f32)
+                .collect();
+        }
+
+        // Update physics settings
+        if let Some(enabled) = obj.get("physicsEnabled").and_then(|v| v.as_bool()) {
+            settings_guard.physics.enabled = enabled;
+        }
+        if let Some(attraction_strength) = obj.get("attractionStrength").and_then(|v| v.as_f64()) {
+            settings_guard.physics.attraction_strength = attraction_strength as f32;
+        }
+        if let Some(repulsion_strength) = obj.get("repulsionStrength").and_then(|v| v.as_f64()) {
+            settings_guard.physics.repulsion_strength = repulsion_strength as f32;
+        }
+        if let Some(spring_strength) = obj.get("springStrength").and_then(|v| v.as_f64()) {
+            settings_guard.physics.spring_strength = spring_strength as f32;
+        }
+        if let Some(damping) = obj.get("damping").and_then(|v| v.as_f64()) {
+            settings_guard.physics.damping = damping as f32;
+        }
+        if let Some(max_velocity) = obj.get("maxVelocity").and_then(|v| v.as_f64()) {
+            settings_guard.physics.max_velocity = max_velocity as f32;
+        }
+        if let Some(collision_radius) = obj.get("collisionRadius").and_then(|v| v.as_f64()) {
+            settings_guard.physics.collision_radius = collision_radius as f32;
+        }
+        if let Some(bounds_size) = obj.get("boundsSize").and_then(|v| v.as_f64()) {
+            settings_guard.physics.bounds_size = bounds_size as f32;
+        }
+        if let Some(enable_bounds) = obj.get("enableBounds").and_then(|v| v.as_bool()) {
+            settings_guard.physics.enable_bounds = enable_bounds;
+        }
+        if let Some(iterations) = obj.get("iterations").and_then(|v| v.as_f64()) {
+            settings_guard.physics.iterations = iterations as u32;
+        }
+
+        // Update rendering settings
+        if let Some(ambient_light_intensity) = obj.get("ambientLightIntensity").and_then(|v| v.as_f64()) {
+            settings_guard.rendering.ambient_light_intensity = ambient_light_intensity as f32;
+        }
+        if let Some(directional_light_intensity) = obj.get("directionalLightIntensity").and_then(|v| v.as_f64()) {
+            settings_guard.rendering.directional_light_intensity = directional_light_intensity as f32;
+        }
+        if let Some(environment_intensity) = obj.get("environmentIntensity").and_then(|v| v.as_f64()) {
+            settings_guard.rendering.environment_intensity = environment_intensity as f32;
+        }
+        if let Some(enable_ambient_occlusion) = obj.get("enableAmbientOcclusion").and_then(|v| v.as_bool()) {
+            settings_guard.rendering.enable_ambient_occlusion = enable_ambient_occlusion;
+        }
+        if let Some(enable_antialiasing) = obj.get("enableAntialiasing").and_then(|v| v.as_bool()) {
+            settings_guard.rendering.enable_antialiasing = enable_antialiasing;
+        }
+        if let Some(enable_shadows) = obj.get("enableShadows").and_then(|v| v.as_bool()) {
+            settings_guard.rendering.enable_shadows = enable_shadows;
+        }
+        if let Some(background_color) = obj.get("backgroundColor").and_then(|v| v.as_str()) {
+            settings_guard.rendering.background_color = background_color.to_string();
+        }
+
+        // Update bloom settings
+        if let Some(enabled) = obj.get("bloomEnabled").and_then(|v| v.as_bool()) {
+            settings_guard.bloom.enabled = enabled;
+        }
+        if let Some(node_bloom_strength) = obj.get("nodeBloomStrength").and_then(|v| v.as_f64()) {
+            settings_guard.bloom.node_bloom_strength = node_bloom_strength as f32;
+        }
+        if let Some(edge_bloom_strength) = obj.get("edgeBloomStrength").and_then(|v| v.as_f64()) {
+            settings_guard.bloom.edge_bloom_strength = edge_bloom_strength as f32;
+        }
+        if let Some(environment_bloom_strength) = obj.get("environmentBloomStrength").and_then(|v| v.as_f64()) {
+            settings_guard.bloom.environment_bloom_strength = environment_bloom_strength as f32;
+        }
+
+        // Update animation settings
+        if let Some(enable_node_animations) = obj.get("enableNodeAnimations").and_then(|v| v.as_bool()) {
+            settings_guard.animations.enable_node_animations = enable_node_animations;
+        }
+        if let Some(selection_wave_enabled) = obj.get("selectionWaveEnabled").and_then(|v| v.as_bool()) {
+            settings_guard.animations.selection_wave_enabled = selection_wave_enabled;
+        }
+        if let Some(pulse_enabled) = obj.get("pulseEnabled").and_then(|v| v.as_bool()) {
+            settings_guard.animations.pulse_enabled = pulse_enabled;
+        }
+        if let Some(ripple_enabled) = obj.get("rippleEnabled").and_then(|v| v.as_bool()) {
+            settings_guard.animations.ripple_enabled = ripple_enabled;
+        }
+        if let Some(edge_animation_enabled) = obj.get("edgeAnimationEnabled").and_then(|v| v.as_bool()) {
+            settings_guard.animations.edge_animation_enabled = edge_animation_enabled;
+        }
+        if let Some(flow_particles_enabled) = obj.get("flowParticlesEnabled").and_then(|v| v.as_bool()) {
+            settings_guard.animations.flow_particles_enabled = flow_particles_enabled;
+        }
+
+        // Update label settings
+        if let Some(enable_labels) = obj.get("enableLabels").and_then(|v| v.as_bool()) {
+            settings_guard.labels.enable_labels = enable_labels;
+        }
+        if let Some(text_color) = obj.get("textColor").and_then(|v| v.as_str()) {
+            settings_guard.labels.text_color = text_color.to_string();
+        }
+
+        // Update AR settings
+        if let Some(enable_plane_detection) = obj.get("enablePlaneDetection").and_then(|v| v.as_bool()) {
+            settings_guard.ar.enable_plane_detection = enable_plane_detection;
+        }
+        if let Some(enable_hand_tracking) = obj.get("enableHandTracking").and_then(|v| v.as_bool()) {
+            settings_guard.ar.enable_hand_tracking = enable_hand_tracking;
+        }
+        if let Some(enable_haptics) = obj.get("enableHaptics").and_then(|v| v.as_bool()) {
+            settings_guard.ar.enable_haptics = enable_haptics;
+        }
+
+        // Save settings to file
+        if let Err(e) = save_settings_to_file(&settings_guard) {
+            eprintln!("Failed to save settings to file: {}", e);
+            return HttpResponse::InternalServerError().json(serde_json::json!({
+                "error": "Failed to save settings to file"
+            }));
+        }
+
+        // Drop the write guard before returning the current settings
+        drop(settings_guard);
+        
+        // Return the current settings using the cloned Data
+        get_visualization_settings(settings_clone).await
+    } else {
+        HttpResponse::BadRequest().json(serde_json::json!({
+            "error": "Invalid settings format"
+        }))
     }
 }
 
@@ -120,16 +376,20 @@ fn save_settings_to_file(settings: &Settings) -> std::io::Result<()> {
     let toml_string = toml::to_string_pretty(&settings)
         .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
     
-    // Write to settings.toml
-    fs::write("settings.toml", toml_string)?;
+    // Get the absolute path to settings.toml
+    let settings_path = PathBuf::from(std::env::current_dir()?)
+        .join("settings.toml");
+    
+    // Write to settings.toml with absolute path
+    fs::write(&settings_path, toml_string)?;
+    
+    log::info!("Settings saved to: {:?}", settings_path);
     
     Ok(())
 }
 
 // Register the handlers with the Actix web app
 pub fn config(cfg: &mut web::ServiceConfig) {
-    cfg.service(
-        web::scope("/visualization")
-            .route("/settings", web::get().to(get_visualization_settings))
-    );
+    cfg.route("/visualization/settings", web::get().to(get_visualization_settings))
+       .route("/visualization/settings", web::put().to(update_visualization_settings));
 }
diff --git a/src/lib.rs b/src/lib.rs
index eb0f80ee..a709cfe8 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,3 +1,5 @@
+#![recursion_limit = "256"]
+
 #[macro_use]
 extern crate log;
 
diff --git a/src/main.rs b/src/main.rs
index 63bc5302..07859768 100755
--- a/src/main.rs
+++ b/src/main.rs
@@ -265,7 +265,7 @@ async fn main() -> std::io::Result<()> {
             )
             .service(
                 web::scope("/api/visualization")
-                    .route("/settings", web::get().to(visualization_handler::get_visualization_settings))
+                    .configure(visualization_handler::config)  // Use the config function to register both GET and PUT
             )
             .service(
                 web::scope("/api/perplexity")
