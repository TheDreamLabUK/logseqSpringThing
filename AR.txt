Thought for 14 seconds
It sounds like you're encountering issues with rendering your force-directed graph in AR mode on the Quest 3 headset. Specifically:

AR Mode Displays Only Passthrough: No grid or nodes are visible.
Distorted View Upon Returning: The Quest browser view becomes distorted with improperly mapped rotational tracking.
These issues can stem from several factors related to XR session management, scene setup, camera handling, and rendering configurations. Below, I'll outline potential causes and provide detailed solutions to help you resolve these problems.

1. Ensure Proper Visibility of AR Elements
Issue: When entering AR, the grid and nodes aren't visible, only passthrough.

Potential Causes:

Visibility Flags: The grid and ground plane might not be set to visible correctly.
Scene Hierarchy: AR elements might not be correctly added to the scene or attached to the camera rig.
Rendering Layers: Objects might be on layers that are not rendered in AR.
Solutions:

Check Visibility Flags: Ensure that the gridHelper and groundPlane are set to visible when the AR session starts.

typescript
Copy code
// In XRSessionManager's initXRSession method
setTimeout(() => {
  this.gridHelper.visible = true;
  this.groundPlane.visible = true;
  this.hitTestMarker.visible = true; // Ensure hit test marker is also visible
  // Optionally, make nodes visible if they're hidden by default
  // this.nodeManager.setNodesVisibility(true);
}, 1000);
Scene Hierarchy: Verify that all AR-specific objects (grid, ground plane, hit test marker) are correctly added to the scene and are part of the camera rig's hierarchy.

typescript
Copy code
private setupXRObjects(): void {
  const scene = this.sceneManager.getScene();
  
  // Add camera rig to scene
  scene.add(this.cameraRig);

  // Add AR objects to camera rig to ensure they move with the user
  this.cameraRig.add(this.gridHelper);
  this.cameraRig.add(this.groundPlane);
  this.cameraRig.add(this.hitTestMarker);
  this.cameraRig.add(this.arLight);

  // Setup controllers and grips
  // ...
}
Rendering Layers: Ensure that the grid, nodes, and other AR elements are on layers that the renderer is set to display.

typescript
Copy code
// Example: Set all AR objects to layer 1
this.gridHelper.layers.set(1);
this.groundPlane.layers.set(1);
this.hitTestMarker.layers.set(1);
this.arLight.layers.set(1);

// Configure camera to render layer 1
const camera = this.sceneManager.getCamera();
camera.layers.enable(1);
2. Review Camera and Reference Space Handling
Issue: After returning to desktop viewport, the Quest browser view is distorted with misaligned rotational tracking.

Potential Causes:

Manual Camera Updates: Manually updating the camera's position and quaternion might conflict with Three.js's built-in XR management.
Reference Space Misconfiguration: Incorrect handling of reference spaces can lead to tracking issues.
Quaternion Decomposition: Setting quaternion components individually can cause inaccuracies.
Solutions:

Leverage Three.js's XR Integration: Avoid manually updating the camera's position and quaternion. Instead, let Three.js handle camera updates via its WebXRManager.

Remove Manual Updates:

typescript
Copy code
// Remove or comment out manual camera updates in onXRFrame
/*
this.cameraRig.position.copy(position);
this.cameraRig.quaternion.x = quaternion.x;
this.cameraRig.quaternion.y = quaternion.y;
this.cameraRig.quaternion.z = quaternion.z;
this.cameraRig.quaternion.w = quaternion.w;

camera.position.set(0, 0, 0);
camera.quaternion.identity();

if (pose.views[0]) {
  const view = pose.views[0];
  camera.projectionMatrix.fromArray(view.projectionMatrix);
  camera.updateMatrixWorld(true);
}
*/
Ensure Correct Reference Space: Confirm that the reference space is correctly set to 'local-floor' and that the camera rig is appropriately positioned within this space.

typescript
Copy code
// In initXRSession method
this.referenceSpace = await this.session.requestReferenceSpace('local-floor');

// Ensure cameraRig is at the correct position
this.cameraRig.position.set(0, 0, 0); // Origin of the reference space
Use Group Hierarchies: Attach AR elements to a group that's parented to the camera rig. This ensures that all AR elements move cohesively with the user's movement.

typescript
Copy code
// Create a group for AR elements
const arGroup = new THREE.Group();
this.cameraRig.add(arGroup);

// Add AR objects to this group
arGroup.add(this.gridHelper);
arGroup.add(this.groundPlane);
arGroup.add(this.hitTestMarker);
arGroup.add(this.arLight);
Quaternion Handling: If you need to manipulate quaternions, set them entirely rather than component-wise to prevent inaccuracies.

typescript
Copy code
// Instead of setting individual quaternion components
// this.cameraRig.quaternion.x = quaternion.x;
// this.cameraRig.quaternion.y = quaternion.y;
// this.cameraRig.quaternion.z = quaternion.z;
// this.cameraRig.quaternion.w = quaternion.w;

// Set the quaternion directly
this.cameraRig.quaternion.copy(quaternion);
3. Verify XR Session Initialization and Cleanup
Issue: The AR session might not be initializing or terminating correctly, leading to rendering issues.

Potential Causes:

Session End Handling: Improper cleanup when ending the XR session can leave the scene in an inconsistent state.
Multiple Sessions: Starting multiple XR sessions without proper termination can cause conflicts.
Event Listeners: Event listeners might not be correctly added or removed, leading to unexpected behavior.
Solutions:

Ensure Single XR Session: Prevent multiple XR sessions from running simultaneously.

typescript
Copy code
async initXRSession(): Promise<void> {
  if (this.isPresenting) {
    _logger.warn('XR session already active');
    return;
  }

  // Existing session initialization logic...
}
Proper Cleanup on Session End: Ensure that all XR-related objects are hidden or reset when the session ends.

typescript
Copy code
private onXRSessionEnd(): void {
  // Existing cleanup logic...

  // Ensure AR objects are hidden
  this.gridHelper.visible = false;
  this.groundPlane.visible = false;
  this.hitTestMarker.visible = false;
  this.arLight.visible = false;
  
  // Optionally reset camera rig
  this.cameraRig.position.set(0, 0, 0);
  this.cameraRig.quaternion.identity();
  
  // Reset scene background
  this.sceneManager.getScene().background = new THREE.Color(BACKGROUND_COLOR);
  
  // Notify listeners or perform additional cleanup if necessary
}
Handle Event Listeners Correctly: Make sure that event listeners are not duplicated or left dangling, which can cause unexpected behavior.

typescript
Copy code
private setupXRObjects(): void {
  // Existing setup logic...

  // Use arrow functions or bind to ensure correct 'this' context
  controller.addEventListener('connected', this.onControllerConnected);
  controller.addEventListener('disconnected', this.onControllerDisconnected);
}

private onControllerConnected = (event: XRControllerEvent) => {
  // Handle controller connection
};

private onControllerDisconnected = () => {
  // Handle controller disconnection
};
4. Optimize Rendering and Performance for AR
Issue: The distorted view might be due to performance bottlenecks or rendering mismatches.

Potential Causes:

High Polygon Counts: Excessive number of nodes or edges can strain the GPU.
Inefficient Rendering Pipeline: Using multiple passes or unnecessary computations can degrade performance.
Incorrect Renderer Settings: Settings like pixelRatio or antialias might need adjustment for AR.
Solutions:

Optimize InstancedMesh Usage: Ensure that you're using InstancedMesh efficiently, minimizing the number of draw calls.

typescript
Copy code
// In NodeManager, ensure instanced meshes are correctly sized
this.nodeInstances = new THREE.InstancedMesh(nodeGeometry, nodeMaterial, nodes.length);
this.edgeInstances = new THREE.InstancedMesh(edgeGeometry, edgeMaterial, edges.length);
Adjust Renderer Settings for AR: Optimize renderer settings for performance in AR mode.

typescript
Copy code
async initXRSession(): Promise<void> {
  // Existing session initialization logic...

  // Optimize renderer settings for AR
  this.sceneManager.getRenderer().setPixelRatio(window.devicePixelRatio);
  this.sceneManager.getRenderer().setSize(window.innerWidth, window.innerHeight);
  this.sceneManager.getRenderer().setClearColor(0x000000, 0); // Transparent background
  
  // Optionally disable antialiasing for better performance
  this.sceneManager.getRenderer().antialias = false;
  this.sceneManager.getRenderer().render(this.sceneManager.getScene(), this.sceneManager.getCamera());
  
  // Existing visibility settings...
}
Monitor and Profile Performance: Use performance monitoring tools to identify bottlenecks.

typescript
Copy code
// In the main entry point, utilize PerformanceMonitor
const performanceMonitor = new PerformanceMonitor();

function animate() {
  requestAnimationFrame(animate);
  performanceMonitor.update();
  
  // Update scene and render
  this.sceneManager.getRenderer().render(this.sceneManager.getScene(), this.sceneManager.getCamera());
  
  // Display FPS or other stats if needed
  const fpsElement = document.getElementById('fps');
  if (fpsElement) {
    fpsElement.textContent = performanceMonitor.getFPS().toString();
  }
}

animate();
5. Debugging and Logging Enhancements
Issue: Difficulty in pinpointing the exact cause of rendering issues.

Solutions:

Enhanced Logging: Add more granular logs to trace the flow of XR session initialization, frame updates, and visibility toggles.

typescript
Copy code
// Example: Add logs when AR objects are toggled
setTimeout(() => {
  this.gridHelper.visible = true;
  this.groundPlane.visible = true;
  this.hitTestMarker.visible = true;
  this.arLight.visible = true;
  _logger.log('AR objects set to visible');
}, 1000);
Visual Debugging Aids: Temporarily add wireframes or bounding boxes to AR elements to verify their positions and orientations.

typescript
Copy code
const wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });

const gridWireframe = new THREE.GridHelper(10, 10, 0x0000ff, 0x0000ff);
gridWireframe.visible = false;
this.sceneManager.getScene().add(gridWireframe);

// Toggle visibility alongside gridHelper
setTimeout(() => {
  gridWireframe.visible = true;
  _logger.log('Grid wireframe set to visible');
}, 1000);
Check Console for Errors: Inspect the browser's developer console for any errors or warnings related to WebXR, Three.js, or other parts of your application.

6. Review Three.js and WebXR Integration
Issue: Potential conflicts between manual camera updates and Three.js's WebXRManager.

Solutions:

Avoid Manual Camera Manipulation: Let Three.js manage the camera's position and orientation when using WebXR.

typescript
Copy code
// Remove manual camera updates and rely on Three.js's WebXRManager
// Ensure that renderer.xr.enabled = true is set correctly
Use XRCompatible Cameras: Ensure that the camera used is compatible with XR sessions.

typescript
Copy code
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 75, 200);
camera.lookAt(0, 0, 0);
Update EffectComposer for XR: If using post-processing, ensure that EffectComposer is compatible with XR.

typescript
Copy code
// In SceneManager, configure EffectComposer for XR
this.composer = new EffectComposer(this.renderer);
this.composer.setPixelRatio(window.devicePixelRatio);
this.composer.setSize(window.innerWidth, window.innerHeight);

const renderPass = new RenderPass(this.scene, this.camera);
this.composer.addPass(renderPass);

this.bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.5,  // Strength
  0.75, // Radius
  0.3   // Threshold
);
this.composer.addPass(this.bloomPass);

// When in XR mode, ensure EffectComposer renders correctly
this.renderer.xr.enabled = true;
7. Additional Recommendations
Test with Simplified Scene: Temporarily simplify your AR scene to include only essential elements (e.g., grid and a few nodes) to isolate the issue.

Check Asset Loading: Ensure that all assets (textures, models) are correctly loaded and not causing rendering issues.

Update Three.js: Ensure you're using the latest stable version of Three.js, as updates may fix existing bugs related to WebXR.

Validate WebXR Features: Confirm that the required XR features (local-floor, hit-test, etc.) are supported and correctly requested.

typescript
Copy code
const session = await navigator.xr.requestSession('immersive-ar', {
  requiredFeatures: ['local-floor', 'hit-test'],
  optionalFeatures: ['hand-tracking', 'layers', 'light-estimation']
});
Handle Light Estimation: Ensure that lighting in AR mode is correctly handled to make AR elements visible and properly lit.

typescript
Copy code
private updateARLighting(lightEstimate: XRLightEstimate): void {
  const intensity = lightEstimate.primaryLightIntensity?.value || 1;
  const direction = lightEstimate.primaryLightDirection;
  
  if (direction) {
    this.arLight.position.set(direction.x, direction.y, direction.z);
    this.arLight.target.position.set(0, 0, 0); // Adjust as needed
    this.arLight.target.updateMatrixWorld();
  }
  this.arLight.intensity = intensity;
}
Conclusion

=== XR Session Manager ===
/**
 * XR session management and rendering
 */

import * as THREE from 'three';
import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory';
import { createLogger } from '../core/utils';
import { platformManager } from '../platform/platformManager';
import { SceneManager } from '../rendering/scene';

const _logger = createLogger('XRSessionManager');

// Type guards for WebXR features
function hasLightEstimate(frame: XRFrame): frame is XRFrame & { getLightEstimate(): XRLightEstimate | null } {
  return 'getLightEstimate' in frame;
}

function hasHitTest(session: XRSession): session is XRSession & { requestHitTestSource(options: XRHitTestOptionsInit): Promise<XRHitTestSource> } {
  return 'requestHitTestSource' in session;
}

export class XRSessionManager {
  private static instance: XRSessionManager;
  private sceneManager: SceneManager;
  private session: XRSession | null = null;
  private referenceSpace: XRReferenceSpace | null = null;
  private isPresenting: boolean = false;

  // XR specific objects
  private cameraRig: THREE.Group;
  private controllers: THREE.Group[];
  private controllerGrips: THREE.Group[];
  private controllerModelFactory: XRControllerModelFactory;

  // AR specific objects
  private gridHelper: THREE.GridHelper;
  private groundPlane: THREE.Mesh;
  private hitTestMarker: THREE.Mesh;
  private arLight: THREE.DirectionalLight;
  private hitTestSource: XRHitTestSource | null = null;
  private hitTestSourceRequested = false;

  // Event handlers
  private xrSessionStartCallback: (() => void) | null = null;
  private xrSessionEndCallback: (() => void) | null = null;
  private xrAnimationFrameCallback: ((frame: XRFrame) => void) | null = null;

  private constructor(sceneManager: SceneManager) {
    this.sceneManager = sceneManager;
    
    // Initialize XR objects
    this.cameraRig = new THREE.Group();
    this.controllers = [new THREE.Group(), new THREE.Group()];
    this.controllerGrips = [new THREE.Group(), new THREE.Group()];
    this.controllerModelFactory = new XRControllerModelFactory();

    // Initialize AR objects
    this.gridHelper = this.createGridHelper();
    this.groundPlane = this.createGroundPlane();
    this.hitTestMarker = this.createHitTestMarker();
    this.arLight = this.createARLight();

    this.setupXRObjects();
  }

  static getInstance(sceneManager: SceneManager): XRSessionManager {
    if (!XRSessionManager.instance) {
      XRSessionManager.instance = new XRSessionManager(sceneManager);
    }
    return XRSessionManager.instance;
  }

  private createGridHelper(): THREE.GridHelper {
    const grid = new THREE.GridHelper(10, 10, 0x808080, 0x808080);
    grid.material.transparent = true;
    grid.material.opacity = 0.5;
    grid.position.y = -0.01; // Slightly below ground to avoid z-fighting
    grid.visible = false; // Start hidden until AR session begins
    return grid;
  }

  private createGroundPlane(): THREE.Mesh {
    const geometry = new THREE.PlaneGeometry(10, 10);
    const material = new THREE.MeshPhongMaterial({
      color: 0x999999,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    const plane = new THREE.Mesh(geometry, material);
    plane.rotateX(-Math.PI / 2);
    plane.position.y = -0.02; // Below grid
    plane.visible = false; // Start hidden until AR session begins
    return plane;
  }

  private createHitTestMarker(): THREE.Mesh {
    const geometry = new THREE.RingGeometry(0.15, 0.2, 32);
    const material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    const marker = new THREE.Mesh(geometry, material);
    marker.rotateX(-Math.PI / 2);
    marker.visible = false;
    return marker;
  }

  private createARLight(): THREE.DirectionalLight {
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 1);
    return light;
  }

  private setupXRObjects(): void {
    const scene = this.sceneManager.getScene();
    
    // Add camera rig to scene
    scene.add(this.cameraRig);

    // Add AR objects to scene
    scene.add(this.gridHelper);
    scene.add(this.groundPlane);
    scene.add(this.hitTestMarker);
    scene.add(this.arLight);

    // Setup controllers
    this.controllers.forEach((controller, _index) => {
      this.cameraRig.add(controller);
      this.setupController(controller);
    });

    // Setup controller grips
    this.controllerGrips.forEach((grip, _index) => {
      this.cameraRig.add(grip);
      this.setupControllerGrip(grip);
    });
  }

  private setupController(controller: THREE.Group): void {
    controller.addEventListener('connected', (event: XRControllerEvent) => {
      controller.userData.inputSource = event.data;

      // Add visual representation of controller
      if (event.data.targetRayMode === 'tracked-pointer') {
        controller.add(this.createControllerPointer());
      }
    });

    controller.addEventListener('disconnected', () => {
      controller.remove(...controller.children);
    });
  }

  private setupControllerGrip(grip: THREE.Group): void {
    const controllerModel = this.controllerModelFactory.createControllerModel(grip);
    grip.add(controllerModel);
  }

  private createControllerPointer(): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08);
    geometry.rotateX(-Math.PI / 2);
    const material = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    return new THREE.Mesh(geometry, material);
  }

  /**
   * Initialize XR session
   */
  async initXRSession(): Promise<void> {
    if (!platformManager.getCapabilities().xrSupported || !navigator.xr) {
      throw new Error('XR not supported on this platform');
    }

    try {
      const session = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['local-floor', 'hit-test'],
        optionalFeatures: ['hand-tracking', 'layers', 'light-estimation']
      });

      if (!session) {
        throw new Error('Failed to create XR session');
      }

      this.session = session;

      // Setup XR rendering
      const renderer = this.sceneManager.getRenderer();
      await renderer.xr.setSession(this.session);
      
      // Configure renderer for AR
      renderer.xr.enabled = true;
      
      // Clear background for AR passthrough
      const scene = this.sceneManager.getScene();
      scene.background = null;
      
      // Get reference space
      this.referenceSpace = await this.session.requestReferenceSpace('local-floor');
      
      // Setup session event handlers
      this.session.addEventListener('end', () => this.onXRSessionEnd());

      // Show AR visualization elements after a short delay to ensure proper placement
      setTimeout(() => {
        this.gridHelper.visible = true;
        this.groundPlane.visible = true;
      }, 1000);
      
      this.isPresenting = true;
      _logger.log('XR session initialized');

      // Notify session start
      if (this.xrSessionStartCallback) {
        this.xrSessionStartCallback();
      }
    } catch (error) {
      _logger.error('Failed to initialize XR session:', error);
      throw error;
    }
  }

  /**
   * End XR session
   */
  async endXRSession(): Promise<void> {
    if (this.session) {
      await this.session.end();
    }
  }

  private onXRSessionEnd(): void {
    if (this.hitTestSource) {
      this.hitTestSource.cancel();
      this.hitTestSource = null;
    }
    
    this.session = null;
    this.referenceSpace = null;
    this.hitTestSourceRequested = false;
    this.isPresenting = false;

    // Hide AR visualization elements
    this.gridHelper.visible = false;
    this.groundPlane.visible = false;
    this.hitTestMarker.visible = false;

    // Reset renderer settings
    const renderer = this.sceneManager.getRenderer();
    renderer.xr.enabled = false;

    _logger.log('XR session ended');

    // Notify session end
    if (this.xrSessionEndCallback) {
      this.xrSessionEndCallback();
    }
  }

  /**
   * XR animation frame
   */
  onXRFrame(frame: XRFrame): void {
    if (!this.session || !this.referenceSpace) return;

    // Get pose
    const pose = frame.getViewerPose(this.referenceSpace);
    if (!pose) return;

    // Update camera rig position from viewer pose
    const camera = this.sceneManager.getCamera();
    if (pose.transform) {
      // Extract position and orientation from pose transform
      const position = new THREE.Vector3();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      
      const matrix = new THREE.Matrix4();
      matrix.fromArray(pose.transform.matrix);
      matrix.decompose(position, quaternion, scale);

      // Update camera rig
      this.cameraRig.position.copy(position);
      // Update quaternion components individually
      this.cameraRig.quaternion.x = quaternion.x;
      this.cameraRig.quaternion.y = quaternion.y;
      this.cameraRig.quaternion.z = quaternion.z;
      this.cameraRig.quaternion.w = quaternion.w;
      
      // Reset camera position and orientation relative to rig
      camera.position.set(0, 0, 0);
      camera.quaternion.identity();
      
      // Update projection matrix
      if (pose.views[0]) {
        const view = pose.views[0];
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.updateMatrixWorld(true);
      }
    }

    // Handle hit testing
    this.handleHitTest(frame);

    // Update controller poses
    this.controllers.forEach((controller) => {
      const inputSource = controller.userData.inputSource as XRInputSource;
      if (inputSource) {
        const targetRayPose = frame.getPose(inputSource.targetRaySpace, this.referenceSpace!);
        if (targetRayPose) {
          controller.matrix.fromArray(targetRayPose.transform.matrix);
          controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
        }
      }
    });

    // Update lighting if available
    if (hasLightEstimate(frame)) {
      const lightEstimate = frame.getLightEstimate();
      if (lightEstimate) {
        this.updateARLighting(lightEstimate);
      }
    }

    // Call animation frame callback
    if (this.xrAnimationFrameCallback) {
      this.xrAnimationFrameCallback(frame);
    }
  }

  private async handleHitTest(frame: XRFrame): Promise<void> {
    if (!this.hitTestSourceRequested && this.session && hasHitTest(this.session)) {
      try {
        const viewerSpace = await this.session.requestReferenceSpace('viewer');
        if (!viewerSpace) {
          throw new Error('Failed to get viewer reference space');
        }

        const hitTestSource = await this.session.requestHitTestSource({
          space: viewerSpace
        });

        if (hitTestSource) {
          this.hitTestSource = hitTestSource;
          this.hitTestSourceRequested = true;
        }
      } catch (error) {
        _logger.error('Failed to initialize hit test source:', error);
        this.hitTestSourceRequested = true; // Prevent further attempts
      }
    }

    if (this.hitTestSource && this.referenceSpace) {
      const hitTestResults = frame.getHitTestResults(this.hitTestSource);
      if (hitTestResults.length > 0) {
        const hit = hitTestResults[0];
        const pose = hit.getPose(this.referenceSpace);
        if (pose) {
          this.hitTestMarker.visible = true;
          this.hitTestMarker.position.set(
            pose.transform.position.x,
            pose.transform.position.y,
            pose.transform.position.z
          );

          // Update grid and ground plane position to match hit test
          this.gridHelper.position.y = pose.transform.position.y;
          this.groundPlane.position.y = pose.transform.position.y - 0.01;
        }
      } else {
        this.hitTestMarker.visible = false;
      }
    }
  }

  private updateARLighting(lightEstimate: XRLightEstimate): void {
    const intensity = lightEstimate.primaryLightIntensity?.value || 1;
    const direction = lightEstimate.primaryLightDirection;
    
    if (direction) {
      this.arLight.position.set(direction.x, direction.y, direction.z);
    }
    this.arLight.intensity = intensity;
  }

  /**
   * Set session event callbacks
   */
  setSessionCallbacks(
    onStart: () => void,
    onEnd: () => void,
    onFrame: (frame: XRFrame) => void
  ): void {
    this.xrSessionStartCallback = onStart;
    this.xrSessionEndCallback = onEnd;
    this.xrAnimationFrameCallback = onFrame;
  }

  /**
   * Get XR objects
   */
  getCameraRig(): THREE.Group {
    return this.cameraRig;
  }

  getControllers(): THREE.Group[] {
    return this.controllers;
  }

  getControllerGrips(): THREE.Group[] {
    return this.controllerGrips;
  }

  /**
   * Check if currently in XR session
   */
  isXRPresenting(): boolean {
    return this.isPresenting;
  }

  /**
   * Get current XR session
   */
  getSession(): XRSession | null {
    return this.session;
  }

  /**
   * Get reference space
   */
  getReferenceSpace(): XRReferenceSpace | null {
    return this.referenceSpace;
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.hitTestSource) {
      this.hitTestSource.cancel();
    }

    if (this.session) {
      this.session.end();
    }

    this.controllers.forEach(controller => {
      controller.remove(...controller.children);
    });

    this.controllerGrips.forEach(grip => {
      grip.remove(...grip.children);
    });

    this.cameraRig.remove(...this.cameraRig.children);
    
    const scene = this.sceneManager.getScene();
    scene.remove(this.cameraRig);
    scene.remove(this.gridHelper);
    scene.remove(this.groundPlane);
    scene.remove(this.hitTestMarker);
    scene.remove(this.arLight);

    // Dispose geometries and materials
    this.gridHelper.geometry.dispose();
    (this.gridHelper.material as THREE.Material).dispose();
    this.groundPlane.geometry.dispose();
    (this.groundPlane.material as THREE.Material).dispose();
    this.hitTestMarker.geometry.dispose();
    (this.hitTestMarker.material as THREE.Material).dispose();
  }
}


=== XR Interaction ===
/**
 * XR interaction handling for controllers and hands
 */

import * as THREE from 'three';
import { XRSessionManager } from './xrSessionManager';
import { NodeManager } from '../rendering/nodes';
import { settingsManager } from '../state/settings';
import { createLogger } from '../core/utils';

// Logger will be used for debugging XR interactions and haptic feedback
const _logger = createLogger('XRInteraction');

// XR Interaction Action Types
type XRInteractionActionType = 'select' | 'squeeze';

// Extended XR types
interface XRHandWithHaptics extends XRHand {
    vibrate?(intensity: number, duration: number): void;
}

interface XRSessionWithPose extends XRSession {
    getPose?(source: XRSpace, referenceSpace: XRReferenceSpace): XRPose | undefined;
}

interface XRInteractionActionEvent extends THREE.Event {
    type: `${XRInteractionActionType}start` | `${XRInteractionActionType}end`;
    data: XRInputSource;
    hand?: XRHandWithHaptics;
}

interface XRController extends THREE.Group {
    userData: {
        inputSource: XRInputSource;
    };
}

interface XRNodeMeshUserData {
    nodeId: string;
}

interface XRNodeMesh extends THREE.Object3D {
    userData: XRNodeMeshUserData;
}

declare module 'three' {
    interface Object3DEventMap {
        selectstart: XRInteractionActionEvent;
        selectend: XRInteractionActionEvent;
        squeezestart: XRInteractionActionEvent;
        squeezeend: XRInteractionActionEvent;
    }
}

type XRInteractor = XRController | XRHandWithHaptics;

// Type guard function to check if an object is an XRNodeMesh
function isXRNodeMesh(obj: THREE.Object3D): obj is XRNodeMesh {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        'userData' in obj &&
        obj.userData !== null &&
        typeof obj.userData === 'object' &&
        'nodeId' in obj.userData &&
        typeof obj.userData.nodeId === 'string'
    );
}

export class XRInteraction {
    private static instance: XRInteraction;
    private xrManager: XRSessionManager;
    private nodeManager: NodeManager;

    // Interaction state
    private selectedNode: string | null = null;
    private hoveredNode: string | null = null;
    private isGrabbing: boolean = false;
    private lastInteractorPosition: THREE.Vector3;
    private grabOffset: THREE.Vector3;

    // Raycasting
    private raycaster: THREE.Raycaster;
    private tempMatrix: THREE.Matrix4;

    // Hand Tracking
    private hands: XRHandWithHaptics[] = [];
    private pinchThreshold: number = 0.025;

    private constructor(xrManager: XRSessionManager, nodeManager: NodeManager) {
        this.xrManager = xrManager;
        this.nodeManager = nodeManager;

        this.lastInteractorPosition = new THREE.Vector3();
        this.grabOffset = new THREE.Vector3();
        this.raycaster = new THREE.Raycaster();
        this.tempMatrix = new THREE.Matrix4();
        this.setupEventListeners();
    }

    static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
        if (!XRInteraction.instance) {
            XRInteraction.instance = new XRInteraction(xrManager, nodeManager);
        }
        return XRInteraction.instance;
    }

    private setupEventListeners(): void {
        const session = this.xrManager.getSession();
        if (!session) return;

        // Handle controller / hand updates
        session.addEventListener('inputsourceschange', (event: XRInputSourcesChangeEvent) => {
            // Clear old event listeners
            this.xrManager.getControllers().forEach(controller => {
                controller.removeEventListener('selectstart', this.handleSelectStart);
                controller.removeEventListener('selectend', this.handleSelectEnd);
                controller.removeEventListener('squeezestart', this.handleSqueezeStart);
                controller.removeEventListener('squeezeend', this.handleSqueezeEnd);
            });

            this.hands = [];
            event.added.forEach((source: XRInputSource) => {
                if (source.hand) {
                    this.hands.push(source.hand as XRHandWithHaptics);
                }
            });

            // Setup new input sources
            this.xrManager.getControllers().forEach((controller) => {
                controller.addEventListener('selectstart', this.handleSelectStart);
                controller.addEventListener('selectend', this.handleSelectEnd);
                controller.addEventListener('squeezestart', this.handleSqueezeStart);
                controller.addEventListener('squeezeend', this.handleSqueezeEnd);
            });
        });

        // Initial Setup
        this.xrManager.getControllers().forEach((controller) => {
            controller.addEventListener('selectstart', this.handleSelectStart);
            controller.addEventListener('selectend', this.handleSelectEnd);
            controller.addEventListener('squeezestart', this.handleSqueezeStart);
            controller.addEventListener('squeezeend', this.handleSqueezeEnd);
        });
    }

    private handleSelectStart = (event: THREE.Event) => {
        if (this.hoveredNode) {
            const interactionEvent = event as XRInteractionActionEvent;
            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
        }
    }

    private handleSelectEnd = () => {
        this.endGrab();
    }

    private handleSqueezeStart = (event: THREE.Event) => {
        if (this.hoveredNode) {
            const interactionEvent = event as XRInteractionActionEvent;
            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
        }
    }

    private handleSqueezeEnd = () => {
        this.endGrab();
    }

    /**
     * Update interaction state
     */
    update(frame: XRFrame): void {
        const session = this.xrManager.getSession() as XRSessionWithPose;
        const referenceSpace = this.xrManager.getReferenceSpace();

        if (!session || !referenceSpace) return;

        // Update controller interaction
        this.xrManager.getControllers().forEach((baseController) => {
            const controller = baseController as XRController;
            const inputSource = controller.userData.inputSource;
            if (!inputSource) return;

            // Get controller pose
            const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
            if (!pose) return;

            // Update raycaster
            controller.updateMatrixWorld();
            this.tempMatrix.identity().extractRotation(controller.matrixWorld);
            this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);

            // Check for intersections with nodes
            this.checkNodeIntersections(controller);

            // Update grabbed node position
            if (this.isGrabbing && this.selectedNode) {
                this.updateGrabbedNodePosition(controller);
            }

            // Provide haptic feedback if enabled
            if (inputSource.gamepad && settingsManager.getSettings().xrControllerVibration) {
                this.handleHapticFeedback(inputSource.gamepad);
            }
        });

        // Handle Hand Interactions
        this.hands.forEach((hand) => {
            this.checkHandIntersections(hand, frame, referenceSpace);

            if (this.isGrabbing && this.selectedNode) {
                this.updateGrabbedNodePosition(hand);
            }
        });
    }

    private checkHandIntersections(hand: XRHandWithHaptics, frame: XRFrame, referenceSpace: XRReferenceSpace): void {
        if (!hand || !frame || !referenceSpace) return;

        // Get index and thumb tip
        const indexTipPose = frame.getPose(hand.get("index-finger-tip") as XRSpace, referenceSpace);
        const thumbTipPose = frame.getPose(hand.get("thumb-tip") as XRSpace, referenceSpace);
        if (!indexTipPose || !thumbTipPose) return;

        const indexTipPosition = new THREE.Vector3().fromArray(indexTipPose.transform.matrix.slice(12, 15));
        const thumbTipPosition = new THREE.Vector3().fromArray(thumbTipPose.transform.matrix.slice(12, 15));
        const distance = indexTipPosition.distanceTo(thumbTipPosition);

        let closestNode: XRNodeMesh | null = null;
        let minDistance = Infinity;

        // Get meshes and check each one
        const meshes = this.nodeManager.getAllNodeMeshes();
        for (const mesh of meshes) {
            if (isXRNodeMesh(mesh)) {
                const nodePosition = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);
                const nodeDistance = nodePosition.distanceTo(indexTipPosition);

                if (nodeDistance < minDistance) {
                    minDistance = nodeDistance;
                    closestNode = mesh;
                }
            }
        }

        if (minDistance < 0.1 && closestNode) {
            const nodeId = closestNode.userData.nodeId;
            if (nodeId !== this.hoveredNode) {
                // Update hover state
                this.hoveredNode = nodeId;
                this.nodeManager.highlightNode(nodeId);
                // Trigger haptic pulse for hover
                this.pulseHand(hand, 0.2, 50);
            }
            if (distance < this.pinchThreshold && !this.isGrabbing) {
                this.startGrab(nodeId, hand, hand);
            }
        } else if (this.hoveredNode) {
            // Clear hover state
            this.nodeManager.highlightNode(null);
            this.hoveredNode = null;
        }
    }

    private checkNodeIntersections(controller: XRController): void {
        // Get closest intersection
        const meshes = this.nodeManager.getAllNodeMeshes();
        const intersects = this.raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (isXRNodeMesh(intersectedObject)) {
                const nodeId = intersectedObject.userData.nodeId;
                if (nodeId !== this.hoveredNode) {
                    // Update hover state
                    this.hoveredNode = nodeId;
                    this.nodeManager.highlightNode(nodeId);

                    // Trigger haptic pulse for hover
                    this.pulseController(controller, 0.2, 50);
                }
            }
        } else if (this.hoveredNode) {
            // Clear hover state
            this.nodeManager.highlightNode(null);
            this.hoveredNode = null;
        }
    }

    private startGrab(nodeId: string, interactor: XRInputSource | XRHandWithHaptics, hand?: XRHandWithHaptics): void {
        this.selectedNode = nodeId;
        this.isGrabbing = true;

        // Store initial grab position
        if (interactor instanceof THREE.Group) {
            const controller = interactor as unknown as XRController;
            this.lastInteractorPosition.setFromMatrixPosition(controller.matrixWorld);
            this.pulseController(controller, 0.7, 100);
        } else if (hand) {
            const wrist = hand.get("wrist") as XRSpace;
            const session = this.xrManager.getSession() as XRSessionWithPose;
            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
            if (pose) {
                this.lastInteractorPosition.fromArray(pose.transform.matrix.slice(12, 15));
            }
            this.pulseHand(hand, 0.7, 100);
        }

        // Calculate grab offset
        const nodePosition = this.nodeManager.getNodePosition(nodeId);
        this.grabOffset.subVectors(nodePosition, this.lastInteractorPosition);
    }

    private endGrab(): void {
        if (this.isGrabbing) {
            this.isGrabbing = false;
            this.selectedNode = null;
        }
    }

    private updateGrabbedNodePosition(interactor: XRInteractor): void {
        if (!this.selectedNode) return;

        // Get current interactor position
        const currentPosition = new THREE.Vector3();
        if (interactor instanceof THREE.Group) {
            currentPosition.setFromMatrixPosition(interactor.matrixWorld);
        } else {
            const wrist = interactor.get("wrist") as XRSpace;
            const session = this.xrManager.getSession() as XRSessionWithPose;
            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
            if (pose) {
                currentPosition.fromArray(pose.transform.matrix.slice(12, 15));
            }
        }

        // Calculate new node position
        const newPosition = currentPosition.clone().add(this.grabOffset);
        this.nodeManager.updateNodePosition(this.selectedNode, newPosition);

        // Update last position
        this.lastInteractorPosition.copy(currentPosition);
    }

    private handleHapticFeedback(__gamepad: Gamepad): void {
        if (!settingsManager.getSettings().xrControllerVibration) return;

        // Add haptic feedback logic based on interactions
        // For example, vibrate when near nodes or when grabbing
    }

    private pulseController(controller: XRController, intensity: number, duration: number): void {
        const inputSource = controller.userData.inputSource;
        if (!inputSource?.gamepad || !settingsManager.getSettings().xrControllerVibration) return;

        const actuator = inputSource.gamepad.hapticActuators?.[0] as any;
        if (actuator) {
            try {
                actuator.pulse(intensity, duration);
            } catch (error) {
                _logger.warn('Haptic feedback not supported:', error);
            }
        }
    }

    private pulseHand(hand: XRHandWithHaptics, intensity: number, duration: number): void {
        if (!settingsManager.getSettings().xrControllerVibration) return;
        try {
            hand.vibrate?.(intensity, duration);
        } catch (error) {
            _logger.warn('Haptic feedback not supported for hands:', error);
        }
    }

    /**
     * Clean up resources
     */
    dispose(): void {
        this.endGrab();
        this.hoveredNode = null;
        this.selectedNode = null;
    }
}


=== WebXR Types ===
/**
 * WebXR API type extensions
 */

declare module 'three' {
  interface Object3DEventMap {
    connected: XRControllerEvent;
    disconnected: XRControllerEvent;
  }
}

interface XRControllerEvent extends THREE.Event {
  type: 'connected' | 'disconnected';
  data: XRInputSource;
}

interface XRLightEstimate {
  primaryLightIntensity?: { value: number };
  primaryLightDirection?: { x: number; y: number; z: number };
}

// Extend existing WebXR types
declare global {
  interface XRFrame {
    // Make getLightEstimate optional
    getLightEstimate?(): XRLightEstimate | null;
    getHitTestResults(hitTestSource: XRHitTestSource): XRHitTestResult[];
    getViewerPose(referenceSpace: XRReferenceSpace): XRViewerPose | null;
    getPose(space: XRSpace, baseSpace: XRReferenceSpace): XRPose | null;
  }

  interface XRSession {
    requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace>;
    // Make requestHitTestSource non-optional
    requestHitTestSource(options: XRHitTestOptionsInit): Promise<XRHitTestSource>;
    end(): Promise<void>;
    addEventListener(type: string, listener: EventListener): void;
    removeEventListener(type: string, listener: EventListener): void;
  }

  interface XRHitTestOptionsInit {
    space: XRSpace;
    offsetRay?: XRRay;
  }

  interface XRHitTestSource {
    cancel(): void;
  }

  interface XRHitTestResult {
    getPose(baseSpace: XRSpace): XRPose | null;
  }

  interface XRPose {
    transform: XRRigidTransform;
  }

  interface XRViewerPose extends XRPose {
    views: XRView[];
  }

  interface XRView {
    projectionMatrix: Float32Array;
    transform: XRRigidTransform;
  }

  interface XRRigidTransform {
    matrix: Float32Array;
    position: { x: number; y: number; z: number };
    orientation: { x: number; y: number; z: number; w: number };
  }

  interface XRReferenceSpace extends XRSpace {
    getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
  }

  interface XRSpace {}

  interface XRRay {
    origin: DOMPointReadOnly;
    direction: DOMPointReadOnly;
    matrix: Float32Array;
  }

  type XRReferenceSpaceType = 
    | 'viewer'
    | 'local'
    | 'local-floor'
    | 'bounded-floor'
    | 'unbounded';

  interface XRInputSource {
    handedness: 'none' | 'left' | 'right';
    targetRayMode: 'gaze' | 'tracked-pointer' | 'screen';
    targetRaySpace: XRSpace;
    gripSpace?: XRSpace;
    profiles: string[];
    gamepad?: Gamepad;
    hand?: XRHand;
  }

  interface XRHand extends Map<XRHandJoint, XRJointSpace> {
    get(joint: XRHandJoint): XRJointSpace | undefined;
  }

  type XRHandJoint =
    | 'wrist'
    | 'thumb-metacarpal'
    | 'thumb-phalanx-proximal'
    | 'thumb-phalanx-distal'
    | 'thumb-tip'
    | 'index-finger-metacarpal'
    | 'index-finger-phalanx-proximal'
    | 'index-finger-phalanx-intermediate'
    | 'index-finger-phalanx-distal'
    | 'index-finger-tip';

  interface XRJointSpace extends XRSpace {
    jointRadius: number | undefined;
  }

  interface Navigator {
    xr?: {
      isSessionSupported(mode: string): Promise<boolean>;
      requestSession(mode: string, options?: XRSessionInit): Promise<XRSession>;
    };
  }

  interface XRSessionInit {
    requiredFeatures?: string[];
    optionalFeatures?: string[];
  }
}

// Prevent conflicts with @types/webxr
declare module '@types/webxr' {
  export {};
}


=== Three.js Types ===
/**
 * THREE.js type declarations
 */

declare module 'three' {
  export interface Event {
    type: string;
    target: any;
  }

  // XR Controller Event Types
  export interface XRControllerEvent extends Event {
    type: 'connected' | 'disconnected';
    data: XRInputSource;
  }

  export interface Object3DEventMap {
    connected: XRControllerEvent;
    disconnected: XRControllerEvent;
  }

  export interface EventDispatcher<E extends Event = Event> {
    addEventListener<T extends E['type']>(type: T, listener: (event: E & { type: T }) => void): void;
    removeEventListener<T extends E['type']>(type: T, listener: (event: E & { type: T }) => void): void;
    dispatchEvent(event: E): void;
  }

  export class Object3D implements EventDispatcher<Event & XRControllerEvent> {
    position: Vector3;
    quaternion: Quaternion;
    scale: Vector3;
    matrix: Matrix4;
    matrixWorld: Matrix4;
    children: Object3D[];
    parent: Object3D | null;
    userData: any;
    visible: boolean;
    renderOrder: number;
    frustumCulled: boolean;
    matrixAutoUpdate: boolean;
    add(...objects: Object3D[]): this;
    remove(...objects: Object3D[]): this;
    rotateX(angle: number): this;
    rotateY(angle: number): this;
    rotateZ(angle: number): this;
    updateMatrix(): void;
    updateMatrixWorld(force?: boolean): void;
    traverse(callback: (object: Object3D) => void): void;
    lookAt(x: number | Vector3, y?: number, z?: number): void;
    addEventListener<K extends keyof Object3DEventMap>(
      type: K,
      listener: (event: Object3DEventMap[K]) => void
    ): void;
    addEventListener(
      type: string,
      listener: (event: Event) => void
    ): void;
    removeEventListener<K extends keyof Object3DEventMap>(
      type: K,
      listener: (event: Object3DEventMap[K]) => void
    ): void;
    removeEventListener(
      type: string,
      listener: (event: Event) => void
    ): void;
    dispatchEvent(event: Event): void;
  }

  export class Scene extends Object3D {
    constructor();
    fog: FogExp2 | null;
    background: Color | Texture | null;
  }

  export class Group extends Object3D {
    constructor();
  }

  export class Mesh extends Object3D {
    constructor(geometry: BufferGeometry, material: Material);
    geometry: BufferGeometry;
    material: Material;
  }

  export class InstancedMesh extends Mesh {
    constructor(geometry: BufferGeometry, material: Material, count: number);
    count: number;
    instanceMatrix: BufferAttribute;
    instanceColor: BufferAttribute | null;
    setMatrixAt(index: number, matrix: Matrix4): void;
    setColorAt(index: number, color: Color): void;
  }

  export class Sprite extends Object3D {
    constructor(material: SpriteMaterial);
    material: SpriteMaterial;
  }

  export class BufferGeometry {
    dispose(): void;
    rotateX(angle: number): this;
    rotateY(angle: number): this;
    rotateZ(angle: number): this;
  }

  export class Material {
    transparent: boolean;
    opacity: number;
    depthWrite: boolean;
    depthTest: boolean;
    side: Side;
    color: Color;
    dispose(): void;
  }

  export interface MaterialParameters {
    color?: ColorRepresentation;
    transparent?: boolean;
    opacity?: number;
    side?: Side;
    depthWrite?: boolean;
    depthTest?: boolean;
    map?: Texture;
  }

  export interface MeshBasicMaterialParameters extends MaterialParameters {}
  export interface MeshPhongMaterialParameters extends MaterialParameters {
    shininess?: number;
    specular?: ColorRepresentation;
  }
  export interface SpriteMaterialParameters extends MaterialParameters {
    depthTest?: boolean;
  }

  export class MeshBasicMaterial extends Material {
    constructor(parameters?: MeshBasicMaterialParameters);
  }

  export class MeshPhongMaterial extends Material {
    constructor(parameters?: MeshPhongMaterialParameters);
    shininess: number;
    specular: Color;
  }

  export class SpriteMaterial extends Material {
    constructor(parameters?: SpriteMaterialParameters);
    map: Texture | null;
  }

  export class BufferAttribute {
    array: ArrayLike<number>;
    needsUpdate: boolean;
  }

  export class GridHelper extends Object3D {
    constructor(size: number, divisions: number, color1?: ColorRepresentation, color2?: ColorRepresentation);
    material: Material;
    geometry: BufferGeometry;
  }

  export class DirectionalLight extends Object3D {
    constructor(color?: ColorRepresentation, intensity?: number);
    intensity: number;
  }

  export class AmbientLight extends Light {
    constructor(color?: ColorRepresentation, intensity?: number);
  }

  export class Light extends Object3D {
    constructor(color?: ColorRepresentation, intensity?: number);
    intensity: number;
  }

  export class Vector2 {
    x: number;
    y: number;
    constructor(x?: number, y?: number);
    set(x: number, y: number): this;
  }

  export class Vector3 {
    x: number;
    y: number;
    z: number;
    constructor(x?: number, y?: number, z?: number);
    set(x: number, y: number, z: number): this;
    copy(v: Vector3): this;
    add(v: Vector3): this;
    sub(v: Vector3): this;
    multiply(v: Vector3): this;
    multiplyScalar(s: number): this;
    normalize(): this;
    dot(v: Vector3): number;
    cross(v: Vector3): this;
    length(): number;
    lengthSq(): number;
    clone(): Vector3;
    fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
    subVectors(a: Vector3, b: Vector3): this;
    addVectors(a: Vector3, b: Vector3): this;
    crossVectors(a: Vector3, b: Vector3): this;
    setFromMatrixPosition(m: Matrix4): this;
    distanceTo(v: Vector3): number;
    applyMatrix4(m: Matrix4): this;
    lookAt(v: Vector3): this;
  }

  export class Matrix4 {
    elements: number[];
    constructor();
    set(...elements: number[]): this;
    identity(): this;
    copy(m: Matrix4): this;
    compose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
    decompose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
    fromArray(array: ArrayLike<number>, offset?: number): this;
    extractRotation(m: Matrix4): this;
    makeRotationFromQuaternion(q: Quaternion): this;
  }

  export class Quaternion {
    x: number;
    y: number;
    z: number;
    w: number;
    constructor(x?: number, y?: number, z?: number, w?: number);
    setFromAxisAngle(axis: Vector3, angle: number): this;
    identity(): this;
  }

  export class Color {
    constructor(color?: ColorRepresentation);
    set(color: ColorRepresentation): this;
  }

  export class SphereGeometry extends BufferGeometry {
    constructor(radius?: number, widthSegments?: number, heightSegments?: number);
  }

  export class PlaneGeometry extends BufferGeometry {
    constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number);
  }

  export class CylinderGeometry extends BufferGeometry {
    constructor(
      radiusTop?: number,
      radiusBottom?: number,
      height?: number,
      radialSegments?: number
    );
  }

  export class RingGeometry extends BufferGeometry {
    constructor(
      innerRadius?: number,
      outerRadius?: number,
      thetaSegments?: number
    );
  }

  export class Texture {
    constructor(image?: HTMLImageElement | HTMLCanvasElement);
    needsUpdate: boolean;
    dispose(): void;
  }

  export class WebGLRenderer {
    constructor(parameters?: WebGLRendererParameters);
    domElement: HTMLCanvasElement;
    setSize(width: number, height: number, updateStyle?: boolean): void;
    setPixelRatio(value: number): void;
    render(scene: Scene, camera: Camera): void;
    dispose(): void;
    xr: WebXRManager;
  }

  export interface WebGLRendererParameters {
    canvas?: HTMLCanvasElement;
    antialias?: boolean;
    alpha?: boolean;
    powerPreference?: 'default' | 'high-performance' | 'low-power';
  }

  export class WebXRManager {
    enabled: boolean;
    setSession(session: XRSession): Promise<void>;
  }

  export class Camera extends Object3D {
    matrixWorldInverse: Matrix4;
    projectionMatrix: Matrix4;
    projectionMatrixInverse: Matrix4;
    lookAt(target: Vector3 | number, y?: number, z?: number): void;
  }

  export class PerspectiveCamera extends Camera {
    constructor(fov?: number, aspect?: number, near?: number, far?: number);
    fov: number;
    aspect: number;
    near: number;
    far: number;
    updateProjectionMatrix(): void;
    lookAt(target: Vector3 | number, y?: number, z?: number): void;
  }

  export class Raycaster {
    constructor();
    ray: Ray;
    near: number;
    far: number;
    setFromCamera(coords: Vector2, camera: Camera): void;
    intersectObject(object: Object3D, recursive?: boolean): Intersection[];
    intersectObjects(objects: Object3D[], recursive?: boolean): Intersection[];
  }

  export class Ray {
    origin: Vector3;
    direction: Vector3;
  }

  export interface Intersection {
    distance: number;
    point: Vector3;
    object: Object3D;
  }

  export class FogExp2 {
    constructor(color: ColorRepresentation, density?: number);
    color: Color;
    density: number;
  }

  export const DoubleSide: Side;
  export type Side = 0 | 1 | 2;
  export type ColorRepresentation = Color | string | number;

  export class MathUtils {
    static clamp(value: number, min: number, max: number): number;
  }
}


=== Three.js Extension Types ===
declare module 'three/examples/jsm/controls/OrbitControls' {
  import { Camera, EventDispatcher, MOUSE, TOUCH, Vector3 } from 'three';

  export class OrbitControls extends EventDispatcher {
    constructor(object: Camera, domElement?: HTMLElement);

    object: Camera;
    domElement: HTMLElement | HTMLDocument;

    enabled: boolean;
    target: Vector3;

    minDistance: number;
    maxDistance: number;

    minZoom: number;
    maxZoom: number;

    minPolarAngle: number;
    maxPolarAngle: number;

    minAzimuthAngle: number;
    maxAzimuthAngle: number;

    enableDamping: boolean;
    dampingFactor: number;

    enableZoom: boolean;
    zoomSpeed: number;

    enableRotate: boolean;
    rotateSpeed: number;

    enablePan: boolean;
    panSpeed: number;
    screenSpacePanning: boolean;
    keyPanSpeed: number;

    autoRotate: boolean;
    autoRotateSpeed: number;

    enableKeys: boolean;

    keys: { LEFT: number; UP: number; RIGHT: number; BOTTOM: number };
    mouseButtons: { LEFT: MOUSE; MIDDLE: MOUSE; RIGHT: MOUSE };
    touches: { ONE: TOUCH; TWO: TOUCH };

    update(): boolean;
    dispose(): void;
  }
}

declare module 'three/examples/jsm/webxr/XRControllerModelFactory' {
  import { Group, Texture } from 'three';

  export class XRControllerModelFactory {
    constructor();
    createControllerModel(controller: Group): Group;
  }
}

declare module 'three/examples/jsm/postprocessing/EffectComposer' {
  import { WebGLRenderer, WebGLRenderTarget } from 'three';

  export class Pass {
    enabled: boolean;
    needsSwap: boolean;
    clear: boolean;
    renderToScreen: boolean;

    setSize(width: number, height: number): void;
    render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime?: number, maskActive?: boolean): void;
  }

  export class EffectComposer {
    constructor(renderer: WebGLRenderer, renderTarget?: WebGLRenderTarget);
    
    renderTarget1: WebGLRenderTarget;
    renderTarget2: WebGLRenderTarget;
    writeBuffer: WebGLRenderTarget;
    readBuffer: WebGLRenderTarget;
    passes: Pass[];
    
    swapBuffers(): void;
    addPass(pass: Pass): void;
    insertPass(pass: Pass, __index: number): void;
    removePass(pass: Pass): void;
    render(deltaTime?: number): void;
    reset(renderTarget?: WebGLRenderTarget): void;
    setSize(width: number, height: number): void;
    dispose(): void;
  }
}

declare module 'three/examples/jsm/postprocessing/RenderPass' {
  import { Scene, Camera } from 'three';
  import { Pass } from 'three/examples/jsm/postprocessing/EffectComposer';

  export class RenderPass extends Pass {
    constructor(scene: Scene, camera: Camera);
    scene: Scene;
    camera: Camera;
  }
}

declare module 'three/examples/jsm/postprocessing/UnrealBloomPass' {
  import { Vector2 } from 'three';
  import { Pass } from 'three/examples/jsm/postprocessing/EffectComposer';

  export class UnrealBloomPass extends Pass {
    constructor(resolution: Vector2, strength?: number, radius?: number, threshold?: number);
    resolution: Vector2;
    strength: number;
    radius: number;
    threshold: number;
  }
}


=== Core Types ===
/**
 * Core types for graph visualization
 */

// Base types
export interface Vector3 {
  x: number;
  y: number;
  z: number;
}

// Binary protocol types
export interface BinaryHeader {
  version: number;
  nodeCount: number;
}

export interface BinaryNodeData {
  position: Float32Array; // x, y, z
  velocity: Float32Array; // vx, vy, vz
}

// Raw types (matching server format)
export interface RawNodeData {
  position: [number, number, number];
  velocity: [number, number, number];
  mass: number;
  flags: number;
}

export interface RawNode {
  id: string;
  label: string;
  data: RawNodeData;
  metadata?: Record<string, string>;
  nodeType?: string;
  size?: number;
  color?: string;
  weight?: number;
  group?: string;
  userData?: Record<string, string>;
}

export interface RawGraphData {
  nodes: RawNode[];
  edges: Edge[];
  metadata?: Record<string, any>;
}

// Transformed types (used in client)
export interface NodeData {
  position: Vector3;
  velocity: Vector3;
  mass: number;
  flags: number;
}

export interface Node {
  id: string;
  label: string;
  data: NodeData;
  metadata?: Record<string, string>;
  nodeType?: string;
  size?: number;
  color?: string;
  weight?: number;
  group?: string;
  userData?: Record<string, string>;
}

export interface GraphData {
  nodes: Node[];
  edges: Edge[];
  metadata?: Record<string, any>;
}

// Performance types
export interface UpdateBatch {
  timestamp: number;
  updates: Float32Array;
}

export interface EdgeUpdateBatch {
  edgeIndices: Set<number>;
  timestamp: number;
}

// Shared types
export interface Edge {
  source: string;
  target: string;
  weight: number;
  edgeType?: string;
  metadata?: Record<string, string>;
}

export interface VisualizationSettings {
  // Node appearance
  nodeSize: number;
  nodeColor: string;
  nodeOpacity: number;
  nodeHighlightColor: string;
  
  // Edge appearance
  edgeWidth: number;
  edgeColor: string;
  edgeOpacity: number;
  
  // Visual effects
  enableBloom: boolean;
  bloomIntensity: number;
  bloomThreshold: number;
  bloomRadius: number;
  
  // Performance
  maxFps: number;
  updateThrottle: number;

  // Labels
  showLabels: boolean;
  labelSize: number;
  labelColor: string;

  // XR specific
  xrControllerVibration: boolean;
  xrControllerHapticIntensity: number;
}

// Transform functions
export function arrayToVector3(arr: [number, number, number]): Vector3 {
  return { x: arr[0], y: arr[1], z: arr[2] };
}

export function vector3ToArray(vec: Vector3): [number, number, number] {
  return [vec.x, vec.y, vec.z];
}

export function float32ArrayToVector3(arr: Float32Array, offset: number = 0): Vector3 {
  return {
    x: arr[offset],
    y: arr[offset + 1],
    z: arr[offset + 2]
  };
}

export function vector3ToFloat32Array(vec: Vector3, arr: Float32Array, offset: number = 0): void {
  arr[offset] = vec.x;
  arr[offset + 1] = vec.y;
  arr[offset + 2] = vec.z;
}

export function transformNodeData(raw: RawNodeData): NodeData {
  return {
    position: arrayToVector3(raw.position),
    velocity: arrayToVector3(raw.velocity),
    mass: raw.mass,
    flags: raw.flags
  };
}

export function transformNode(raw: RawNode): Node {
  return {
    ...raw,
    data: transformNodeData(raw.data)
  };
}

export function transformGraphData(raw: RawGraphData): GraphData {
  return {
    nodes: raw.nodes.map(transformNode),
    edges: raw.edges,
    metadata: raw.metadata
  };
}

// Binary data validation
export function validateBinaryHeader(data: ArrayBuffer): BinaryHeader | null {
  if (data.byteLength < 8) return null; // Minimum size for version and count
  const view = new Float32Array(data);
  return {
    version: view[0],
    nodeCount: Math.floor((view.length - 1) / 6) // (length - version) / floats per node
  };
}

// WebSocket message types
export type MessageType = 
  | 'initialData'
  | 'requestInitialData'
  | 'binaryPositionUpdate'
  | 'settingsUpdated'
  | 'enableBinaryUpdates'
  | 'ping'
  | 'pong';

// Raw message types (from server)
export interface RawInitialDataMessage {
  type: 'initialData';
  data: {
    graph: RawGraphData;
  };
}

export interface RawBinaryNodeUpdate {
  nodeId: string;
  data: RawNodeData;
}

export interface RawBinaryPositionUpdateMessage {
  type: 'binaryPositionUpdate';
  data: {
    nodes: RawBinaryNodeUpdate[];
  };
}

// Transformed message types (for client use)
export interface InitialDataMessage {
  type: 'initialData';
  data: {
    graph: GraphData;
  };
}

export interface BinaryNodeUpdate {
  nodeId: string;
  data: NodeData;
}

export interface BinaryPositionUpdateMessage {
  type: 'binaryPositionUpdate';
  data: {
    nodes: BinaryNodeUpdate[];
  };
}

// Other message types
export interface RequestInitialDataMessage {
  type: 'requestInitialData';
}

export interface EnableBinaryUpdatesMessage {
  type: 'enableBinaryUpdates';
}

export interface SettingsUpdateMessage {
  type: 'settingsUpdated';
  data: {
    settings: VisualizationSettings;
  };
}

export interface PingMessage {
  type: 'ping';
}

export interface PongMessage {
  type: 'pong';
}

// Union types for messages
export type RawWebSocketMessage =
  | RawInitialDataMessage
  | RawBinaryPositionUpdateMessage
  | SettingsUpdateMessage
  | RequestInitialDataMessage
  | EnableBinaryUpdatesMessage
  | PingMessage
  | PongMessage;

export type WebSocketMessage =
  | InitialDataMessage
  | BinaryPositionUpdateMessage
  | SettingsUpdateMessage
  | RequestInitialDataMessage
  | EnableBinaryUpdatesMessage
  | PingMessage
  | PongMessage;

// Platform detection types
export type Platform = 'browser' | 'quest';

export interface PlatformCapabilities {
  xrSupported: boolean;
  webglSupported: boolean;
  websocketSupported: boolean;
}

// Message queue types
export interface QueuedMessage {
  data: ArrayBuffer;
  timestamp: number;
}

// Debug types
export interface NetworkDebugMessage {
  direction: 'in' | 'out';
  type: 'binary' | 'json';
  timestamp: number;
  data: any;
}


=== Core Constants ===
/**
 * Application constants
 */

// Environment detection
export const IS_PRODUCTION = window.location.hostname === 'www.visionflow.info';
export const IS_DEVELOPMENT = !IS_PRODUCTION;

// WebSocket URLs
export const WS_URL = IS_PRODUCTION
  ? 'wss://www.visionflow.info/wss'
  : 'ws://localhost:3000/wss';  // Updated to match server port and path

// WebSocket configuration
export const WS_RECONNECT_INTERVAL = 5000;
export const WS_MESSAGE_QUEUE_SIZE = 100;

// Binary protocol configuration
export const BINARY_VERSION = 1.0;
export const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
export const VERSION_OFFSET = 1;    // Skip version float
export const BINARY_CHUNK_SIZE = 1000; // Number of nodes to process in one chunk

// Performance configuration
export const THROTTLE_INTERVAL = 16; // ~60fps
export const EDGE_UPDATE_BATCH_INTERVAL = 16; // Batch edge updates at ~60fps

// Visualization constants
export const NODE_SIZE = 2.5;
export const NODE_SEGMENTS = 16;
export const EDGE_RADIUS = 0.25;
export const EDGE_SEGMENTS = 8;

// Font configuration
export const FONT_URL = '/fonts/Roboto-Regular.woff2';

// Colors
export const NODE_COLOR = 0x4CAF50;  // Material Design Green
export const NODE_HIGHLIGHT_COLOR = 0xff4444;  // Material Design Red
export const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300
export const BACKGROUND_COLOR = 0x212121;  // Material Design Grey 900
export const LABEL_COLOR = 0xFFFFFF;  // White

// Default settings
export const DEFAULT_VISUALIZATION_SETTINGS = {
  // Node appearance
  nodeSize: NODE_SIZE,
  nodeColor: '#4CAF50',
  nodeOpacity: 0.7,
  nodeHighlightColor: '#ff4444',
  
  // Edge appearance
  edgeWidth: EDGE_RADIUS * 2,
  edgeColor: '#E0E0E0',
  edgeOpacity: 0.7,
  
  // Visual effects
  enableBloom: true,
  bloomIntensity: 1.5,
  bloomThreshold: 0.3,
  bloomRadius: 0.75,
  
  // Performance
  maxFps: 60,
  updateThrottle: THROTTLE_INTERVAL,

  // Labels
  showLabels: true,
  labelSize: 1.0,
  labelColor: '#FFFFFF',

  // XR specific
  xrControllerVibration: true,
  xrControllerHapticIntensity: 1.0
};

// Default bloom settings
export const DEFAULT_BLOOM_SETTINGS = {
  threshold: DEFAULT_VISUALIZATION_SETTINGS.bloomThreshold,
  strength: DEFAULT_VISUALIZATION_SETTINGS.bloomIntensity,
  radius: DEFAULT_VISUALIZATION_SETTINGS.bloomRadius,
};

// Debug configuration
export const DEBUG = {
  NETWORK_PANEL: {
    MAX_MESSAGES: 50,
    ENABLED: IS_DEVELOPMENT
  }
};


=== Core Utils ===
/**
 * Core utilities for the LogseqXR visualization system
 */

import { Vector3 } from './types';
import { THROTTLE_INTERVAL } from './constants';

// Debug logging utility
export const createLogger = (namespace: string) => {
  return {
    log: (message: string, ...args: any[]) => {
      console.log(`[${namespace}] ${message}`, ...args);
    },
    error: (message: string, ...args: any[]) => {
      console.error(`[${namespace}] ${message}`, ...args);
    },
    warn: (message: string, ...args: any[]) => {
      console.warn(`[${namespace}] ${message}`, ...args);
    },
    debug: (message: string, ...args: any[]) => {
      console.debug(`[${namespace}] ${message}`, ...args);
    }
  };
};

// Update throttler for performance optimization
export class UpdateThrottler {
  private lastUpdate: number = 0;
  private throttleInterval: number;

  constructor(throttleInterval: number = THROTTLE_INTERVAL) {
    this.throttleInterval = throttleInterval;
  }

  shouldUpdate(): boolean {
    const now = performance.now();
    if (now - this.lastUpdate >= this.throttleInterval) {
      this.lastUpdate = now;
      return true;
    }
    return false;
  }

  reset(): void {
    this.lastUpdate = 0;
  }
}

// Vector operations
export const vectorOps = {
  add: (a: Vector3, b: Vector3): Vector3 => ({
    x: a.x + b.x,
    y: a.y + b.y,
    z: a.z + b.z
  }),

  subtract: (a: Vector3, b: Vector3): Vector3 => ({
    x: a.x - b.x,
    y: a.y - b.y,
    z: a.z - b.z
  }),

  multiply: (v: Vector3, scalar: number): Vector3 => ({
    x: v.x * scalar,
    y: v.y * scalar,
    z: v.z * scalar
  }),

  divide: (v: Vector3, scalar: number): Vector3 => ({
    x: v.x / scalar,
    y: v.y / scalar,
    z: v.z / scalar
  }),

  length: (v: Vector3): number => 
    Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z),

  normalize: (v: Vector3): Vector3 => {
    const len = vectorOps.length(v);
    return len > 0 ? vectorOps.divide(v, len) : { x: 0, y: 0, z: 0 };
  },

  distance: (a: Vector3, b: Vector3): number => 
    vectorOps.length(vectorOps.subtract(a, b)),

  // Convert position array to Vector3
  fromArray: (arr: number[]): Vector3 => ({
    x: arr[0] || 0,
    y: arr[1] || 0,
    z: arr[2] || 0
  })
};

// Scale utilities
export const scaleOps = {
  // Normalize a value between min and max
  normalize: (value: number, min: number, max: number): number => {
    return Math.min(max, Math.max(min, value));
  },

  // Map a value from one range to another
  mapRange: (value: number, inMin: number, inMax: number, outMin: number, outMax: number): number => {
    // First normalize to 0-1
    const normalized = (value - inMin) / (inMax - inMin);
    // Then map to output range
    return outMin + normalized * (outMax - outMin);
  },

  // Scale node size from server range to visualization range
  normalizeNodeSize: (size: number, serverMin: number = 20, serverMax: number = 30, visMin: number = 0.15, visMax: number = 0.4): number => {
    return scaleOps.mapRange(size, serverMin, serverMax, visMin, visMax);
  }
};

// Data validation utilities
export const validateGraphData = (data: any): boolean => {
  if (!data || typeof data !== 'object') return false;
  if (!Array.isArray(data.nodes) || !Array.isArray(data.edges)) return false;
  
  // Validate nodes
  for (const node of data.nodes) {
    if (!node.id) return false;
    // Allow position to be either array or Vector3
    if (node.position) {
      if (Array.isArray(node.position)) {
        if (node.position.length !== 3 || 
            typeof node.position[0] !== 'number' ||
            typeof node.position[1] !== 'number' ||
            typeof node.position[2] !== 'number') {
          return false;
        }
      } else if (typeof node.position === 'object') {
        if (typeof node.position.x !== 'number' ||
            typeof node.position.y !== 'number' ||
            typeof node.position.z !== 'number') {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  
  // Validate edges
  for (const edge of data.edges) {
    if (!edge.source || !edge.target) return false;
  }
  
  return true;
};

// Binary data helpers
export const binaryToFloat32Array = (buffer: ArrayBuffer): Float32Array => {
  return new Float32Array(buffer);
};

export const float32ArrayToPositions = (array: Float32Array): Vector3[] => {
  const positions: Vector3[] = [];
  for (let i = 0; i < array.length; i += 3) {
    positions.push({
      x: array[i],
      y: array[i + 1],
      z: array[i + 2]
    });
  }
  return positions;
};

// Error handling utility
export class VisualizationError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'VisualizationError';
  }
}

// Performance monitoring
export class PerformanceMonitor {
  private frames: number = 0;
  private lastTime: number = performance.now();
  private fps: number = 0;

  update(): void {
    this.frames++;
    const now = performance.now();
    const delta = now - this.lastTime;

    if (delta >= 1000) {
      this.fps = (this.frames * 1000) / delta;
      this.frames = 0;
      this.lastTime = now;
    }
  }

  getFPS(): number {
    return Math.round(this.fps);
  }
}


=== Scene Manager ===
/**
 * Three.js scene management with simplified setup
 */

import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
import { createLogger } from '../core/utils';

const logger = createLogger('SceneManager');

// Constants
const BACKGROUND_COLOR = 0x212121;  // Material Design Grey 900

export class SceneManager {
  private static instance: SceneManager;
  
  // Three.js core components
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private controls: OrbitControls;
  
  // Post-processing
  private composer: EffectComposer;
  private bloomPass: UnrealBloomPass;
  
  // Animation
  private animationFrameId: number | null = null;
  private isRunning: boolean = false;

  private constructor(canvas: HTMLCanvasElement) {
    logger.log('Initializing SceneManager');
    
    // Create scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(BACKGROUND_COLOR);
    this.scene.fog = new THREE.FogExp2(BACKGROUND_COLOR, 0.002);

    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(0, 75, 200);
    this.camera.lookAt(0, 0, 0);

    // Create renderer
    this.renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Create controls
    this.controls = new OrbitControls(this.camera, canvas);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.screenSpacePanning = false;
    this.controls.minDistance = 50;
    this.controls.maxDistance = 500;

    // Setup post-processing
    this.composer = new EffectComposer(this.renderer);
    const renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(renderPass);

    this.bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5,  // Strength
      0.75, // Radius
      0.3   // Threshold
    );
    this.composer.addPass(this.bloomPass);

    // Setup basic lighting
    this.setupLighting();

    // Setup event listeners
    window.addEventListener('resize', this.handleResize.bind(this));

    logger.log('SceneManager initialization complete');
  }

  static getInstance(canvas: HTMLCanvasElement): SceneManager {
    if (!SceneManager.instance) {
      SceneManager.instance = new SceneManager(canvas);
    }
    return SceneManager.instance;
  }

  private setupLighting(): void {
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1).normalize();
    this.scene.add(directionalLight);

    // Add grid helper
    const gridHelper = new THREE.GridHelper(1000, 100);
    if (gridHelper.material instanceof THREE.Material) {
      gridHelper.material.transparent = true;
      gridHelper.material.opacity = 0.1;
    }
    this.scene.add(gridHelper);
  }

  private handleResize(): void {
    const width = window.innerWidth;
    const height = window.innerHeight;

    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();

    this.renderer.setSize(width, height);
    this.composer.setSize(width, height);
  }

  start(): void {
    if (this.isRunning) return;
    this.isRunning = true;
    this.animate();
    logger.log('Scene rendering started');
  }

  stop(): void {
    this.isRunning = false;
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
    logger.log('Scene rendering stopped');
  }

  private animate(): void {
    if (!this.isRunning) return;

    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
    this.controls.update();
    this.composer.render();
  }

  // Public getters
  getScene(): THREE.Scene {
    return this.scene;
  }

  getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  getRenderer(): THREE.WebGLRenderer {
    return this.renderer;
  }

  getControls(): OrbitControls {
    return this.controls;
  }

  // Scene management methods
  add(object: THREE.Object3D): void {
    this.scene.add(object);
  }

  remove(object: THREE.Object3D): void {
    this.scene.remove(object);
  }

  dispose(): void {
    this.stop();
    
    window.removeEventListener('resize', this.handleResize.bind(this));

    this.renderer.dispose();
    this.scene.traverse((object) => {
      if (object instanceof THREE.Mesh) {
        object.geometry.dispose();
        if (object.material instanceof THREE.Material) {
          object.material.dispose();
        }
      }
    });

    logger.log('Scene manager disposed');
  }
}


=== Node Manager ===
/**
 * Node and edge rendering using InstancedMesh for both
 */

import * as THREE from 'three';
import { Node, Edge } from '../core/types';
import { SceneManager } from './scene';
import { createLogger } from '../core/utils';
import { NODE_HIGHLIGHT_COLOR } from '../core/constants';

const logger = createLogger('NodeManager');

// Constants for geometry
const NODE_SIZE = 2.5;
const NODE_SEGMENTS = 16;
const EDGE_RADIUS = 0.25;
const EDGE_SEGMENTS = 8;

// Binary format constants
const BINARY_VERSION = 1.0;
const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
const VERSION_OFFSET = 1;    // Skip version float

// Colors
const NODE_COLOR = 0x4CAF50;  // Material Design Green
const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300

// Reusable objects for matrix calculations
const matrix = new THREE.Matrix4();
const quaternion = new THREE.Quaternion();
const position = new THREE.Vector3();
const scale = new THREE.Vector3(1, 1, 1);

// Edge calculation vectors (reused for efficiency)
const start = new THREE.Vector3();
const end = new THREE.Vector3();
const direction = new THREE.Vector3();
const center = new THREE.Vector3();
const UP = new THREE.Vector3(0, 1, 0);
const tempVector = new THREE.Vector3();
const rotationAxis = new THREE.Vector3(1, 0, 0);

export interface NodeMesh extends THREE.Object3D {
  userData: {
    nodeId: string;
  };
}

export class NodeManager {
  private static instance: NodeManager;
  private sceneManager: SceneManager;

  // Instanced meshes - initialized with dummy values, properly set in constructor
  private nodeInstances: THREE.InstancedMesh;
  private edgeInstances: THREE.InstancedMesh;

  // State tracking
  private currentNodes: Node[] = [];
  private currentEdges: Edge[] = [];
  private nodeIndices: Map<string, number> = new Map();
  private highlightedNode: string | null = null;
  
  // Edge update batching
  private dirtyEdges: Set<number> = new Set();
  private batchUpdateTimeout: number | null = null;

  private constructor(sceneManager: SceneManager) {
    this.sceneManager = sceneManager;
    
    // Initialize with proper geometries
    const nodeGeometry = new THREE.SphereGeometry(NODE_SIZE, NODE_SEGMENTS, NODE_SEGMENTS);
    const nodeMaterial = new THREE.MeshPhongMaterial({
      color: NODE_COLOR,
      shininess: 90,
      specular: 0x444444,
      transparent: true,
      opacity: 0.7
    });

    const edgeGeometry = new THREE.CylinderGeometry(EDGE_RADIUS, EDGE_RADIUS, 1, EDGE_SEGMENTS);
    edgeGeometry.rotateX(Math.PI / 2);
    
    const edgeMaterial = new THREE.MeshBasicMaterial({
      color: EDGE_COLOR,
      transparent: true,
      opacity: 0.7,
      depthWrite: false
    });

    this.nodeInstances = new THREE.InstancedMesh(nodeGeometry, nodeMaterial, 10000);
    this.edgeInstances = new THREE.InstancedMesh(edgeGeometry, edgeMaterial, 30000);
    
    this.initializeInstances();
    logger.log('NodeManager initialized');
  }

  static getInstance(sceneManager: SceneManager): NodeManager {
    if (!NodeManager.instance) {
      NodeManager.instance = new NodeManager(sceneManager);
    }
    return NodeManager.instance;
  }

  private initializeInstances(): void {
    // Initialize node instances
    this.nodeInstances.count = 0;
    this.nodeInstances.frustumCulled = false;

    // Initialize edge instances
    this.edgeInstances.count = 0;
    this.edgeInstances.frustumCulled = false;
    this.edgeInstances.renderOrder = 1;

    // Add to scene
    this.sceneManager.add(this.nodeInstances);
    this.sceneManager.add(this.edgeInstances);

    logger.log('Instances initialized');
  }

  getAllNodeMeshes(): NodeMesh[] {
    return [this.nodeInstances as unknown as NodeMesh];
  }

  getNodePosition(nodeId: string): THREE.Vector3 {
    const node = this.currentNodes.find(n => n.id === nodeId);
    if (!node) {
      throw new Error(`Node ${nodeId} not found`);
    }
    return new THREE.Vector3(
      node.data.position.x,
      node.data.position.y,
      node.data.position.z
    );
  }

  updateNodePosition(nodeId: string, newPosition: THREE.Vector3): void {
    const index = this.nodeIndices.get(nodeId);
    if (index === undefined) {
      throw new Error(`Node ${nodeId} not found`);
    }

    // Update node position in current nodes array
    const node = this.currentNodes[index];
    if (node) {
      node.data.position = { x: newPosition.x, y: newPosition.y, z: newPosition.z };
    }

    // Update instance matrix
    position.copy(newPosition);
    matrix.compose(position, quaternion, scale);
    this.nodeInstances.setMatrixAt(index, matrix);
    this.nodeInstances.instanceMatrix.needsUpdate = true;

    // Mark connected edges for update
    this.currentEdges.forEach((edge, edgeIndex) => {
      if (edge.source === nodeId || edge.target === nodeId) {
        this.dirtyEdges.add(edgeIndex);
      }
    });

    // Schedule batch edge update
    this.scheduleBatchEdgeUpdate();
  }

  private scheduleBatchEdgeUpdate(): void {
    if (this.batchUpdateTimeout !== null) return;

    this.batchUpdateTimeout = window.setTimeout(() => {
      this.processBatchEdgeUpdate();
      this.batchUpdateTimeout = null;
    }, 16); // Batch updates at ~60fps
  }

  private processBatchEdgeUpdate(): void {
    if (this.dirtyEdges.size === 0) return;

    for (const edgeIndex of this.dirtyEdges) {
      const edge = this.currentEdges[edgeIndex];
      const sourceNode = this.currentNodes.find(n => n.id === edge.source);
      const targetNode = this.currentNodes.find(n => n.id === edge.target);

      if (sourceNode && targetNode) {
        this.updateEdgeInstance(edgeIndex, sourceNode, targetNode);
      }
    }

    this.dirtyEdges.clear();
    this.edgeInstances.instanceMatrix.needsUpdate = true;
  }

  highlightNode(nodeId: string | null): void {
    if (this.highlightedNode === nodeId) return;

    const color = new THREE.Color();

    if (this.highlightedNode) {
      const prevIndex = this.nodeIndices.get(this.highlightedNode);
      if (prevIndex !== undefined) {
        const node = this.currentNodes[prevIndex];
        color.set(node?.color || NODE_COLOR);
        this.nodeInstances.setColorAt(prevIndex, color);
      }
    }

    if (nodeId) {
      const index = this.nodeIndices.get(nodeId);
      if (index !== undefined) {
        color.set(NODE_HIGHLIGHT_COLOR);
        this.nodeInstances.setColorAt(index, color);
      }
    }

    this.highlightedNode = nodeId;
    if (this.nodeInstances.instanceColor) {
      this.nodeInstances.instanceColor.needsUpdate = true;
    }
  }

  updateGraph(nodes: Node[], edges: Edge[]): void {
    this.currentNodes = nodes;
    this.currentEdges = edges;
    this.nodeIndices.clear();
    this.dirtyEdges.clear();

    // Update node instances count and matrices
    this.nodeInstances.count = nodes.length;
    nodes.forEach((node, index) => {
      this.nodeIndices.set(node.id, index);
      
      position.set(
        node.data.position.x,
        node.data.position.y,
        node.data.position.z
      );

      matrix.compose(position, quaternion, scale);
      this.nodeInstances.setMatrixAt(index, matrix);
    });

    this.nodeInstances.instanceMatrix.needsUpdate = true;

    // Update edge instances
    this.edgeInstances.count = edges.length;
    edges.forEach((edge, index) => {
      const sourceNode = nodes.find(n => n.id === edge.source);
      const targetNode = nodes.find(n => n.id === edge.target);

      if (sourceNode && targetNode) {
        this.updateEdgeInstance(index, sourceNode, targetNode);
      }
    });

    this.edgeInstances.instanceMatrix.needsUpdate = true;

    logger.log(`Updated graph: ${nodes.length} nodes, ${edges.length} edges`);
  }

  private updateEdgeInstance(index: number, sourceNode: Node, targetNode: Node): void {
    const sourcePos = sourceNode.data.position;
    const targetPos = targetNode.data.position;

    start.set(sourcePos.x, sourcePos.y, sourcePos.z);
    end.set(targetPos.x, targetPos.y, targetPos.z);

    direction.subVectors(end, start);
    const length = direction.length();
    
    if (length < 0.001) return;

    center.addVectors(start, end).multiplyScalar(0.5);
    position.copy(center);

    direction.normalize();
    const angle = Math.acos(THREE.MathUtils.clamp(direction.dot(UP), -1, 1));
    tempVector.crossVectors(UP, direction).normalize();
    
    if (tempVector.lengthSq() < 0.001) {
      quaternion.setFromAxisAngle(rotationAxis, direction.dot(UP) > 0 ? 0 : Math.PI);
    } else {
      quaternion.setFromAxisAngle(tempVector, angle);
    }

    scale.set(1, Math.max(0.001, length - (NODE_SIZE * 2)), 1);

    matrix.compose(position, quaternion, scale);
    this.edgeInstances.setMatrixAt(index, matrix);
  }

  updatePositions(floatArray: Float32Array): void {
    // Check binary version
    const version = floatArray[0];
    if (version !== BINARY_VERSION) {
      logger.warn(`Received binary data version ${version}, expected ${BINARY_VERSION}`);
      return;
    }

    // Calculate number of nodes from array length
    const nodeCount = Math.floor((floatArray.length - VERSION_OFFSET) / FLOATS_PER_NODE);
    
    if (nodeCount > this.currentNodes.length) {
      logger.warn(`Received more nodes than currently tracked: ${nodeCount} > ${this.currentNodes.length}`);
      return;
    }

    // Process node updates in chunks for better performance
    const CHUNK_SIZE = 1000;
    for (let i = 0; i < nodeCount; i += CHUNK_SIZE) {
      const endIndex = Math.min(i + CHUNK_SIZE, nodeCount);
      this.processNodeChunk(floatArray, i, endIndex);
    }

    // Trigger matrix updates
    this.nodeInstances.instanceMatrix.needsUpdate = true;
    
    // Process batched edge updates
    this.processBatchEdgeUpdate();
  }

  private processNodeChunk(floatArray: Float32Array, startIndex: number, endIndex: number): void {
    for (let i = startIndex; i < endIndex; i++) {
      const baseIndex = VERSION_OFFSET + (i * FLOATS_PER_NODE);
      
      // Extract position directly into position vector
      position.set(
        floatArray[baseIndex],
        floatArray[baseIndex + 1],
        floatArray[baseIndex + 2]
      );

      // Update instance matrix
      matrix.compose(position, quaternion, scale);
      this.nodeInstances.setMatrixAt(i, matrix);

      // Update node data
      const node = this.currentNodes[i];
      if (node) {
        // Update position
        node.data.position.x = floatArray[baseIndex];
        node.data.position.y = floatArray[baseIndex + 1];
        node.data.position.z = floatArray[baseIndex + 2];
        
        // Update velocity
        node.data.velocity.x = floatArray[baseIndex + 3];
        node.data.velocity.y = floatArray[baseIndex + 4];
        node.data.velocity.z = floatArray[baseIndex + 5];

        // Mark connected edges for update
        this.currentEdges.forEach((edge, edgeIndex) => {
          if (edge.source === node.id || edge.target === node.id) {
            this.dirtyEdges.add(edgeIndex);
          }
        });
      }
    }
  }

  dispose(): void {
    if (this.batchUpdateTimeout !== null) {
      clearTimeout(this.batchUpdateTimeout);
    }

    this.nodeInstances.geometry.dispose();
    (this.nodeInstances.material as THREE.Material).dispose();
    this.sceneManager.remove(this.nodeInstances);

    this.edgeInstances.geometry.dispose();
    (this.edgeInstances.material as THREE.Material).dispose();
    this.sceneManager.remove(this.edgeInstances);

    this.dirtyEdges.clear();
    logger.log('NodeManager disposed');
  }
}


=== Text Renderer ===
/**
 * Text rendering for node labels using sprites
 */

import * as THREE from 'three';
import { Vector3, VisualizationSettings } from '../core/types';
import { createLogger } from '../core/utils';
import { settingsManager } from '../state/settings';
import { FONT_URL } from '../core/constants';

// Logger will be used for debugging font loading and text rendering
const _logger = createLogger('TextRenderer');

// Add FontFace API type declarations
declare global {
  interface Document {
    fonts: FontFaceSet;
  }

  interface FontFaceSet extends Set<FontFace> {
    readonly ready: Promise<FontFaceSet>;
    readonly status: 'loading' | 'loaded';
    check(font: string, text?: string): boolean;
    load(font: string, text?: string): Promise<FontFace[]>;
  }
}

export class TextRenderer {
  private static instance: TextRenderer;
  private scene: THREE.Scene;
  private camera: THREE.Camera;
  
  // Font texture and canvas
  private canvas: HTMLCanvasElement;
  private context: CanvasRenderingContext2D;
  private fontLoaded: boolean = false;
  
  // Label management
  private labels: Map<string, THREE.Sprite>;
  private labelPool: THREE.Sprite[];
  private settings: VisualizationSettings;

  private constructor(scene: THREE.Scene, camera: THREE.Camera) {
    this.scene = scene;
    this.camera = camera;
    this.labels = new Map();
    this.labelPool = [];
    this.settings = settingsManager.getSettings();

    // Create canvas for text rendering
    this.canvas = document.createElement('canvas');
    const context = this.canvas.getContext('2d');
    if (!context) {
      throw new Error('Failed to get 2D context for text rendering');
    }
    this.context = context;

    this.initialize();
  }

  static getInstance(scene: THREE.Scene, camera: THREE.Camera): TextRenderer {
    if (!TextRenderer.instance) {
      TextRenderer.instance = new TextRenderer(scene, camera);
    }
    return TextRenderer.instance;
  }

  private async initialize(): Promise<void> {
    await this.loadFont();
    this.setupEventListeners();
  }

  private async loadFont(): Promise<void> {
    try {
      // Load font using FontFace API
      const font = new FontFace(
        'LabelFont',
        `url(${FONT_URL})`
      );

      const loadedFont = await font.load();
      document.fonts.add(loadedFont);
      this.fontLoaded = true;
      _logger.log('Font loaded successfully');
    } catch (error) {
      _logger.error('Failed to load font:', error);
      throw error;
    }
  }

  private setupEventListeners(): void {
    settingsManager.subscribe(settings => {
      this.settings = settings;
      this.updateAllLabels();
    });
  }

  private createTextTexture(text: string): THREE.Texture {
    // Set canvas size
    const fontSize = 48;
    this.context.font = `${fontSize}px LabelFont`;
    const metrics = this.context.measureText(text);
    const width = Math.ceil(metrics.width);
    const height = Math.ceil(fontSize * 1.4); // Add some padding

    this.canvas.width = width;
    this.canvas.height = height;

    // Clear canvas
    this.context.fillStyle = 'transparent';
    this.context.fillRect(0, 0, width, height);

    // Draw text
    this.context.font = `${fontSize}px LabelFont`;
    this.context.textAlign = 'center';
    this.context.textBaseline = 'middle';
    this.context.fillStyle = this.settings.labelColor;
    this.context.fillText(text, width / 2, height / 2);

    // Create texture
    const texture = new THREE.Texture(this.canvas);
    texture.needsUpdate = true;
    return texture;
  }

  private createLabelSprite(text: string): THREE.Sprite {
    // Reuse sprite from pool if available
    let sprite = this.labelPool.pop();
    
    if (!sprite) {
      const spriteMaterial = new THREE.SpriteMaterial({
        transparent: true,
        depthTest: false
      });
      sprite = new THREE.Sprite(spriteMaterial);
    }

    // Update sprite texture
    const texture = this.createTextTexture(text);
    (sprite.material as THREE.SpriteMaterial).map = texture;

    // Set sprite scale based on text dimensions
    const scale = this.settings.labelSize * 0.01;
    sprite.scale.set(
      this.canvas.width * scale,
      this.canvas.height * scale,
      1
    );

    return sprite;
  }

  /**
   * Create or update a label for a node
   */
  updateLabel(id: string, text: string, position: Vector3): void {
    if (!this.fontLoaded || !this.settings.showLabels) {
      return;
    }

    let label = this.labels.get(id);
    if (!label) {
      label = this.createLabelSprite(text);
      this.labels.set(id, label);
      this.scene.add(label);
    } else {
      // Update existing label
      const texture = this.createTextTexture(text);
      (label.material as THREE.SpriteMaterial).map?.dispose();
      (label.material as THREE.SpriteMaterial).map = texture;
    }

    // Update position
    label.position.set(position.x, position.y + 1.5, position.z); // Offset above node
    label.material.opacity = this.calculateOpacity(position);
  }

  /**
   * Remove a label
   */
  removeLabel(id: string): void {
    const label = this.labels.get(id);
    if (label) {
      this.scene.remove(label);
      (label.material as THREE.SpriteMaterial).map?.dispose();
      this.labelPool.push(label); // Return to pool for reuse
      this.labels.delete(id);
    }
  }

  /**
   * Update all labels (e.g., after settings change)
   */
  private updateAllLabels(): void {
    if (!this.fontLoaded || !this.settings.showLabels) {
      return;
    }

    this.labels.forEach((__label, id) => {
      const label = this.labels.get(id);
      if (label) {
        const opacity = this.calculateOpacity(label.position);
        label.material.opacity = opacity;
      }
    });
  }

  /**
   * Update label positions and visibility
   */
  update(): void {
    if (!this.fontLoaded || !this.settings.showLabels) {
      return;
    }

    // Update label opacity based on distance to camera
    this.labels.forEach((__label, id) => {
      const label = this.labels.get(id);
      if (label) {
        const opacity = this.calculateOpacity(label.position);
        label.material.opacity = opacity;
      }
    });
  }

  /**
   * Calculate label opacity based on distance to camera
   */
  private calculateOpacity(position: Vector3): number {
    const distance = this.camera.position.distanceTo(new THREE.Vector3(position.x, position.y, position.z));
    const maxDistance = 100;
    const minDistance = 10;
    
    if (distance > maxDistance) return 0;
    if (distance < minDistance) return 1;
    
    return 1 - ((distance - minDistance) / (maxDistance - minDistance));
  }

  /**
   * Clear all labels
   */
  clear(): void {
    this.labels.forEach((__label, id) => {
      this.removeLabel(id);
    });
  }

  /**
   * Dispose of resources
   */
  dispose(): void {
    this.clear();
    this.labels.forEach(label => {
      label.material.dispose();
      (label.material as THREE.SpriteMaterial).map?.dispose();
    });
    this.labelPool.forEach(label => {
      label.material.dispose();
      (label.material as THREE.SpriteMaterial).map?.dispose();
    });
    this.canvas.remove();
  }
}


=== Settings Manager ===
/**
 * Settings management with simplified visualization configuration
 */

import { VisualizationSettings } from '../core/types';
import { DEFAULT_VISUALIZATION_SETTINGS, IS_PRODUCTION } from '../core/constants';
import { createLogger } from '../core/utils';

const logger = createLogger('SettingsManager');

// Settings endpoint
const SETTINGS_URL = IS_PRODUCTION
  ? 'https://www.visionflow.info/settings'
  : 'http://localhost:4000/settings';

export class SettingsManager {
  private static instance: SettingsManager;
  private settings: VisualizationSettings;
  private settingsListeners: Set<(settings: VisualizationSettings) => void>;

  private constructor() {
    this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
    this.settingsListeners = new Set();
    logger.log('Initialized with default settings');
  }

  static getInstance(): SettingsManager {
    if (!SettingsManager.instance) {
      SettingsManager.instance = new SettingsManager();
    }
    return SettingsManager.instance;
  }

  /**
   * Load settings from the server
   */
  async loadSettings(): Promise<void> {
    try {
      const response = await fetch(SETTINGS_URL);
      if (!response.ok) {
        throw new Error(`Failed to load settings: ${response.statusText}`);
      }
      const settings = await response.json();
      this.updateSettings(settings);
      logger.log('Loaded settings from server');
    } catch (error) {
      logger.error('Error loading settings:', error);
      // Fall back to default settings
      this.updateSettings(DEFAULT_VISUALIZATION_SETTINGS);
    }
  }

  /**
   * Save current settings to the server
   */
  async saveSettings(): Promise<void> {
    try {
      const response = await fetch(SETTINGS_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(this.settings),
      });

      if (!response.ok) {
        throw new Error(`Failed to save settings: ${response.statusText}`);
      }

      logger.log('Settings saved successfully');
    } catch (error) {
      logger.error('Error saving settings:', error);
      throw error;
    }
  }

  /**
   * Update settings and notify listeners
   */
  updateSettings(newSettings: Partial<VisualizationSettings>): void {
    this.settings = {
      ...this.settings,
      ...newSettings
    };

    logger.log('Updated settings');

    // Notify all listeners of the settings change
    this.settingsListeners.forEach(listener => {
      try {
        listener(this.settings);
      } catch (error) {
        logger.error('Error in settings listener:', error);
      }
    });
  }

  /**
   * Get current settings
   */
  getSettings(): VisualizationSettings {
    return { ...this.settings };
  }

  /**
   * Subscribe to settings changes
   */
  subscribe(listener: (settings: VisualizationSettings) => void): () => void {
    this.settingsListeners.add(listener);
    return () => {
      this.settingsListeners.delete(listener);
    };
  }

  /**
   * Reset settings to defaults
   */
  resetToDefaults(): void {
    this.updateSettings(DEFAULT_VISUALIZATION_SETTINGS);
  }

  // Essential setting getters
  getNodeSettings(): {
    size: number;
    color: string;
    opacity: number;
    highlightColor: string;
  } {
    return {
      size: this.settings.nodeSize,
      color: this.settings.nodeColor,
      opacity: this.settings.nodeOpacity,
      highlightColor: this.settings.nodeHighlightColor
    };
  }

  getEdgeSettings(): {
    width: number;
    color: string;
    opacity: number;
  } {
    return {
      width: this.settings.edgeWidth,
      color: this.settings.edgeColor,
      opacity: this.settings.edgeOpacity
    };
  }

  getBloomSettings(): {
    enabled: boolean;
    intensity: number;
    threshold: number;
    radius: number;
  } {
    return {
      enabled: this.settings.enableBloom,
      intensity: this.settings.bloomIntensity,
      threshold: this.settings.bloomThreshold,
      radius: this.settings.bloomRadius
    };
  }

  getLabelSettings(): {
    show: boolean;
    size: number;
    color: string;
  } {
    return {
      show: this.settings.showLabels,
      size: this.settings.labelSize,
      color: this.settings.labelColor
    };
  }

  getXRSettings(): {
    controllerVibration: boolean;
    hapticIntensity: number;
  } {
    return {
      controllerVibration: this.settings.xrControllerVibration,
      hapticIntensity: this.settings.xrControllerHapticIntensity
    };
  }

  getPerformanceSettings(): {
    maxFps: number;
    updateThrottle: number;
  } {
    return {
      maxFps: this.settings.maxFps,
      updateThrottle: this.settings.updateThrottle
    };
  }
}

// Export a singleton instance
export const settingsManager = SettingsManager.getInstance();


=== Graph Data Manager ===
/**
 * Graph data management with simplified binary updates
 */

import { GraphData, Node, Edge } from '../core/types';
import { createLogger } from '../core/utils';

const logger = createLogger('GraphDataManager');

// Constants
const THROTTLE_INTERVAL = 16;  // ~60fps max
const BINARY_VERSION = 1.0;
const NODE_POSITION_SIZE = 24;  // 6 floats * 4 bytes
const BINARY_HEADER_SIZE = 4;   // 1 float * 4 bytes

export class GraphDataManager {
  private static instance: GraphDataManager;
  private nodes: Map<string, Node>;
  private edges: Map<string, Edge>;
  private metadata: Record<string, any>;
  private updateListeners: Set<(data: GraphData) => void>;
  private positionUpdateListeners: Set<(positions: Float32Array) => void>;
  private lastUpdateTime: number;
  private binaryUpdatesEnabled: boolean = false;

  private constructor() {
    this.nodes = new Map();
    this.edges = new Map();
    this.metadata = {};
    this.updateListeners = new Set();
    this.positionUpdateListeners = new Set();
    this.lastUpdateTime = performance.now();
  }

  static getInstance(): GraphDataManager {
    if (!GraphDataManager.instance) {
      GraphDataManager.instance = new GraphDataManager();
    }
    return GraphDataManager.instance;
  }

  /**
   * Initialize or update the entire graph data
   */
  updateGraphData(data: any): void {
    logger.log('Received graph data update');

    // Clear existing data
    this.nodes.clear();
    this.edges.clear();

    // Store nodes in Map for O(1) access
    if (data.graphData && Array.isArray(data.graphData.nodes)) {
      data.graphData.nodes.forEach((node: any) => {
        // Convert position array to object if needed
        let position;
        if (Array.isArray(node.position)) {
          position = {
            x: node.position[0] || 0,
            y: node.position[1] || 0,
            z: node.position[2] || 0
          };
        } else {
          position = node.position || { x: 0, y: 0, z: 0 };
        }

        logger.log(`Processing node ${node.id} with position:`, position);

        this.nodes.set(node.id, {
          ...node,
          position,
          label: node.label || node.id
        });
      });

      // Store edges in Map
      if (Array.isArray(data.graphData.edges)) {
        data.graphData.edges.forEach((edge: Edge) => {
          const edgeId = this.createEdgeId(edge.source, edge.target);
          this.edges.set(edgeId, edge);
        });
      }

      // Update metadata
      this.metadata = data.graphData.metadata || {};

      // Notify listeners
      this.notifyUpdateListeners();
      logger.log(`Updated graph data: ${this.nodes.size} nodes, ${this.edges.size} edges`);

      // Enable binary updates after initial data is received
      if (!this.binaryUpdatesEnabled) {
        this.enableBinaryUpdates();
      }
    } else {
      logger.warn('Invalid graph data format received');
    }
  }

  /**
   * Enable binary position updates
   */
  private enableBinaryUpdates(): void {
    // Send message to server to enable binary updates
    if (window.ws && window.ws.readyState === WebSocket.OPEN) {
      window.ws.send(JSON.stringify({ type: 'enableBinaryUpdates' }));
      this.binaryUpdatesEnabled = true;
      logger.log('Enabled binary updates');
    } else {
      logger.warn('WebSocket not ready, cannot enable binary updates');
    }
  }

  /**
   * Handle binary position updates with throttling
   */
  updatePositions(buffer: ArrayBuffer): void {
    const now = performance.now();
    const timeSinceLastUpdate = now - this.lastUpdateTime;

    if (timeSinceLastUpdate < THROTTLE_INTERVAL) {
      return;  // Skip update if too soon
    }

    try {
      const floatArray = new Float32Array(buffer);
      
      // Check binary version
      const version = floatArray[0];
      if (version !== BINARY_VERSION) {
        logger.warn(`Received binary data version ${version}, expected ${BINARY_VERSION}`);
      }

      // Verify data size
      const expectedSize = BINARY_HEADER_SIZE + Math.floor((buffer.byteLength - BINARY_HEADER_SIZE) / NODE_POSITION_SIZE) * NODE_POSITION_SIZE;
      if (buffer.byteLength !== expectedSize) {
        logger.error(`Invalid binary data length: ${buffer.byteLength} bytes (expected ${expectedSize})`);
        return;
      }

      this.notifyPositionUpdateListeners(floatArray);
      this.lastUpdateTime = now;
    } catch (error) {
      logger.error('Error processing binary position update:', error);
    }
  }

  /**
   * Get the current graph data
   */
  getGraphData(): GraphData {
    return {
      nodes: Array.from(this.nodes.values()),
      edges: Array.from(this.edges.values()),
      metadata: this.metadata
    };
  }

  /**
   * Get a specific node by ID
   */
  getNode(id: string): Node | undefined {
    return this.nodes.get(id);
  }

  /**
   * Subscribe to graph data updates
   */
  subscribe(listener: (data: GraphData) => void): () => void {
    this.updateListeners.add(listener);
    return () => {
      this.updateListeners.delete(listener);
    };
  }

  /**
   * Subscribe to position updates only
   */
  subscribeToPositionUpdates(
    listener: (positions: Float32Array) => void
  ): () => void {
    this.positionUpdateListeners.add(listener);
    return () => {
      this.positionUpdateListeners.delete(listener);
    };
  }

  /**
   * Clear all graph data
   */
  clear(): void {
    this.nodes.clear();
    this.edges.clear();
    this.metadata = {};
    this.notifyUpdateListeners();
  }

  private createEdgeId(source: string, target: string): string {
    return [source, target].sort().join('_');
  }

  private notifyUpdateListeners(): void {
    const data = this.getGraphData();
    this.updateListeners.forEach(listener => {
      try {
        listener(data);
      } catch (error) {
        logger.error('Error in graph update listener:', error);
      }
    });
  }

  private notifyPositionUpdateListeners(positions: Float32Array): void {
    this.positionUpdateListeners.forEach(listener => {
      try {
        listener(positions);
      } catch (error) {
        logger.error('Error in position update listener:', error);
      }
    });
  }
}

// Export a singleton instance
export const graphDataManager = GraphDataManager.getInstance();

// Declare WebSocket on window for TypeScript
declare global {
  interface Window {
    ws: WebSocket;
  }
}


=== Platform Manager ===
/**
 * Platform detection and capability management
 */

import { Platform, PlatformCapabilities } from '../core/types';
import { createLogger } from '../core/utils';

const logger = createLogger('PlatformManager');

export class PlatformManager {
  private static instance: PlatformManager;
  private platform: Platform;
  private capabilities: PlatformCapabilities;

  private constructor() {
    this.platform = this.detectPlatform();
    // Initialize with default values
    this.capabilities = {
      xrSupported: false,
      webglSupported: false,
      websocketSupported: false
    };
    // Then update capabilities asynchronously
    this.updateCapabilities();
    
    logger.log(`Platform: ${this.platform}`);
  }

  static getInstance(): PlatformManager {
    if (!PlatformManager.instance) {
      PlatformManager.instance = new PlatformManager();
    }
    return PlatformManager.instance;
  }

  private detectPlatform(): Platform {
    // Check for Oculus Browser
    const userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.includes('oculus') || userAgent.includes('quest')) {
      return 'quest';
    }
    return 'browser';
  }

  private async updateCapabilities(): Promise<void> {
    // Check WebXR support
    if (navigator.xr) {
      try {
        this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
      } catch (error) {
        logger.warn('Error checking XR support:', error);
        this.capabilities.xrSupported = false;
      }
    }

    // Check WebGL support
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
      this.capabilities.webglSupported = !!gl;
    } catch (error) {
      logger.warn('Error checking WebGL support:', error);
      this.capabilities.webglSupported = false;
    }

    // Check WebSocket support
    this.capabilities.websocketSupported = 'WebSocket' in window;

    logger.log('Capabilities:', this.capabilities);
  }

  getPlatform(): Platform {
    return this.platform;
  }

  getCapabilities(): PlatformCapabilities {
    return this.capabilities;
  }

  isQuest(): boolean {
    return this.platform === 'quest';
  }

  isBrowser(): boolean {
    return this.platform === 'browser';
  }

  async isXRSupported(): Promise<boolean> {
    return this.capabilities.xrSupported;
  }

  isWebGLSupported(): boolean {
    return this.capabilities.webglSupported;
  }

  isWebSocketSupported(): boolean {
    return this.capabilities.websocketSupported;
  }

  async requestXRSession(mode: XRSessionMode = 'immersive-ar'): Promise<XRSession | null> {
    if (!this.capabilities.xrSupported || !navigator.xr) {
      logger.warn('XR not supported on this platform');
      return null;
    }

    try {
      const session = await navigator.xr.requestSession(mode, {
        requiredFeatures: ['local-floor', 'hit-test'],
        optionalFeatures: ['hand-tracking', 'layers']
      });
      return session;
    } catch (error) {
      logger.error('Error requesting XR session:', error);
      return null;
    }
  }

  // Event handling for platform-specific features
  private eventListeners: Map<string, Set<Function>> = new Map();

  on(event: string, callback: Function): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, new Set());
    }
    this.eventListeners.get(event)?.add(callback);
  }

  off(event: string, callback: Function): void {
    this.eventListeners.get(event)?.delete(callback);
  }

  private emit(event: string, ...args: any[]): void {
    this.eventListeners.get(event)?.forEach(callback => {
      try {
        callback(...args);
      } catch (error) {
        logger.error(`Error in platform event listener for ${event}:`, error);
      }
    });
  }

  // Device orientation handling for mobile/Quest
  private setupDeviceOrientation(): void {
    if (typeof DeviceOrientationEvent !== 'undefined') {
      window.addEventListener('deviceorientation', (event: DeviceOrientationEvent) => {
        this.emit('orientation', {
          alpha: event.alpha, // z-axis rotation
          beta: event.beta,   // x-axis rotation
          gamma: event.gamma  // y-axis rotation
        });
      }, true);
    }
  }

  // Screen orientation handling
  private setupScreenOrientation(): void {
    if ('screen' in window && 'orientation' in screen) {
      screen.orientation.addEventListener('change', () => {
        this.emit('orientationchange', screen.orientation.type);
      });
    }
  }

  // Initialize platform-specific features
  async initialize(): Promise<void> {
    // Set up event listeners
    this.setupDeviceOrientation();
    this.setupScreenOrientation();

    // Check for WebXR changes
    if (navigator.xr) {
      navigator.xr.addEventListener('devicechange', async () => {
        if (navigator.xr) {
          this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
          this.emit('xrdevicechange', this.capabilities.xrSupported);
        }
      });
    }

    // Additional platform-specific initialization can be added here
    logger.log('Platform manager initialized');
  }
}

// Export a singleton instance
export const platformManager = PlatformManager.getInstance();


=== Main Entry Point ===
/**
 * LogseqXR Application Entry Point
 */

import { platformManager } from './platform/platformManager';
import { settingsManager } from './state/settings';
import { graphDataManager } from './state/graphData';
import { WebSocketService } from './websocket/websocketService';
import { SceneManager } from './rendering/scene';
import { NodeManager } from './rendering/nodes';
import { TextRenderer } from './rendering/textRenderer';
import { XRSessionManager } from './xr/xrSessionManager';
import { XRInteraction } from './xr/xrInteraction';
import { createLogger } from './core/utils';
import { WS_URL } from './core/constants';
import { BinaryNodeUpdate } from './core/types';

const logger = createLogger('Application');

class Application {
  private webSocket!: WebSocketService;
  private sceneManager!: SceneManager;
  private nodeManager!: NodeManager;
  private textRenderer!: TextRenderer;
  private xrManager: XRSessionManager | null = null;
  private xrInteraction: XRInteraction | null = null;
  private lastFrameTime = performance.now();
  private frameCount = 0;
  private updateCount = 0;

  constructor() {
    this.initializeApplication();
  }

  private async initializeApplication(): Promise<void> {
    try {
      // Initialize platform manager
      await platformManager.initialize();

      // Initialize scene first so we can render nodes when data arrives
      this.initializeScene();

      // Initialize WebSocket connection
      this.initializeWebSocket();

      // Initialize settings
      await this.initializeSettings();

      // Initialize XR if supported
      await this.initializeXR();

      // Setup UI event listeners
      this.setupUIEventListeners();

      // Start stats update loop
      this.updateStats();

      // Hide loading overlay
      this.hideLoadingOverlay();

      logger.log('Application initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize application:', error);
      this.showError('Failed to initialize application');
    }
  }

  private initializeWebSocket(): void {
    // Create WebSocket service with environment-aware URL
    this.webSocket = new WebSocketService(WS_URL);

    // Setup WebSocket event handlers
    this.webSocket.on('initialData', (data) => {
      logger.log('Received initial graph data:', data);
      if (data && data.graph) {
        // Update graph data
        graphDataManager.updateGraphData(data.graph);
        this.nodeManager.updateGraph(data.graph.nodes, data.graph.edges);

        // Update UI
        this.updateGraphStatus(true);
        this.updateNodeEdgeCounts(data.graph.nodes.length, data.graph.edges.length);
      }
    });

    this.webSocket.on('binaryPositionUpdate', (data) => {
      if (data && data.nodes) {
        // Convert nodes data to ArrayBuffer for position updates
        const buffer = new ArrayBuffer(data.nodes.length * 24); // 6 floats per node
        const floatArray = new Float32Array(buffer);
        
        data.nodes.forEach((node: BinaryNodeUpdate, index: number) => {
          const baseIndex = index * 6;
          const pos = node.data.position;
          const vel = node.data.velocity;
          
          // Position
          floatArray[baseIndex] = pos.x;
          floatArray[baseIndex + 1] = pos.y;
          floatArray[baseIndex + 2] = pos.z;
          // Velocity
          floatArray[baseIndex + 3] = vel.x;
          floatArray[baseIndex + 4] = vel.y;
          floatArray[baseIndex + 5] = vel.z;
        });

        // Update graph data and visual representation
        graphDataManager.updatePositions(buffer);
        this.nodeManager.updatePositions(floatArray);

        // Update stats
        this.updateCount++;
        this.updateLastUpdate();
      }
    });

    this.webSocket.on('settingsUpdated', (data) => {
      if (data && data.settings) {
        settingsManager.updateSettings(data.settings);
        this.updateSettingsUI();
      }
    });

    // Update connection status
    const connectionStatus = document.getElementById('connection-status');
    if (connectionStatus) {
      this.webSocket.onConnectionChange((connected: boolean) => {
        connectionStatus.classList.toggle('connected', connected);
      });
    }

    // Connect to server
    this.webSocket.connect();
  }

  private updateGraphStatus(hasData: boolean): void {
    const graphStatus = document.getElementById('graph-status');
    if (graphStatus) {
      graphStatus.classList.toggle('connected', hasData);
    }
  }

  private updateNodeEdgeCounts(nodes: number, edges: number): void {
    const nodeCount = document.getElementById('nodeCount');
    const edgeCount = document.getElementById('edgeCount');
    if (nodeCount) nodeCount.textContent = nodes.toString();
    if (edgeCount) edgeCount.textContent = edges.toString();
  }

  private updateLastUpdate(): void {
    const lastUpdate = document.getElementById('lastUpdate');
    if (lastUpdate) {
      lastUpdate.textContent = new Date().toISOString().split('T')[1].slice(0, -1);
    }
    const updates = document.getElementById('updates');
    if (updates) {
      updates.textContent = this.updateCount.toString();
    }
  }

  private updateStats(): void {
    const now = performance.now();
    this.frameCount++;

    // Update FPS every second
    if (now - this.lastFrameTime >= 1000) {
      const fps = Math.round((this.frameCount * 1000) / (now - this.lastFrameTime));
      const fpsElement = document.getElementById('fps');
      if (fpsElement) {
        fpsElement.textContent = fps.toString();
      }

      this.frameCount = 0;
      this.lastFrameTime = now;
    }

    requestAnimationFrame(() => this.updateStats());
  }

  private initializeScene(): void {
    // Get canvas element
    const container = document.getElementById('canvas-container');
    if (!container) {
      throw new Error('Canvas container not found');
    }

    // Create canvas
    const canvas = document.createElement('canvas');
    container.appendChild(canvas);

    // Initialize scene manager
    this.sceneManager = SceneManager.getInstance(canvas);

    // Initialize node manager
    this.nodeManager = NodeManager.getInstance(this.sceneManager);

    // Initialize text renderer
    this.textRenderer = TextRenderer.getInstance(
      this.sceneManager.getScene(),
      this.sceneManager.getCamera()
    );

    // Start rendering
    this.sceneManager.start();
  }

  private async initializeSettings(): Promise<void> {
    try {
      // Load settings from server
      await settingsManager.loadSettings();

      // Update UI with current settings
      this.updateSettingsUI();
    } catch (error) {
      logger.error('Failed to load settings:', error);
      // Continue with default settings
    }
  }

  private async initializeXR(): Promise<void> {
    if (platformManager.getCapabilities().xrSupported) {
      // Initialize XR manager
      this.xrManager = XRSessionManager.getInstance(this.sceneManager);

      // Initialize XR interaction
      if (this.xrManager && this.nodeManager) {
        this.xrInteraction = XRInteraction.getInstance(this.xrManager, this.nodeManager);
      }

      // Setup XR button
      const xrButton = document.getElementById('xr-button');
      if (xrButton) {
        xrButton.style.display = 'block';
        xrButton.addEventListener('click', () => this.toggleXRSession());
      }
    }
  }

  private setupUIEventListeners(): void {
    // Settings panel save button
    const saveButton = document.getElementById('save-settings');
    if (saveButton) {
      saveButton.addEventListener('click', () => this.saveSettings());
    }

    // Settings inputs
    this.setupSettingsInputListeners();
  }

  private setupSettingsInputListeners(): void {
    // Node appearance settings
    this.setupSettingInput('nodeSize', 'number');
    this.setupSettingInput('nodeColor', 'color');
    this.setupSettingInput('nodeOpacity', 'number');

    // Edge appearance settings
    this.setupSettingInput('edgeWidth', 'number');
    this.setupSettingInput('edgeColor', 'color');
    this.setupSettingInput('edgeOpacity', 'number');

    // Visual effects settings
    this.setupSettingInput('enableBloom', 'checkbox');
    this.setupSettingInput('bloomIntensity', 'number');
  }

  private setupSettingInput(id: string, type: 'number' | 'color' | 'checkbox'): void {
    const input = document.getElementById(id) as HTMLInputElement;
    if (input) {
      input.addEventListener('change', () => {
        const value = type === 'checkbox' ? input.checked :
                     type === 'number' ? parseFloat(input.value) :
                     input.value;
        settingsManager.updateSettings({ [id]: value });
      });
    }
  }

  private updateSettingsUI(): void {
    const settings = settingsManager.getSettings();
    Object.entries(settings).forEach(([key, value]) => {
      const input = document.getElementById(key) as HTMLInputElement;
      if (input) {
        if (input.type === 'checkbox') {
          input.checked = value as boolean;
        } else {
          input.value = value.toString();
        }
      }
    });
  }

  private async saveSettings(): Promise<void> {
    try {
      await settingsManager.saveSettings();
      logger.log('Settings saved successfully');
    } catch (error) {
      logger.error('Failed to save settings:', error);
      this.showError('Failed to save settings');
    }
  }

  private async toggleXRSession(): Promise<void> {
    if (!this.xrManager) return;

    try {
      if (this.xrManager.isXRPresenting()) {
        await this.xrManager.endXRSession();
      } else {
        await this.xrManager.initXRSession();
      }
    } catch (error) {
      logger.error('Failed to toggle XR session:', error);
      this.showError('Failed to start XR session');
    }
  }

  private hideLoadingOverlay(): void {
    const overlay = document.querySelector('.loading-overlay');
    if (overlay) {
      overlay.remove();
    }
  }

  private showError(message: string): void {
    logger.error(message);
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 5px;
      z-index: 1000;
    `;
    errorDiv.textContent = message;
    document.body.appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 5000);
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    // Stop rendering
    this.sceneManager.stop();

    // Dispose of managers
    this.nodeManager.dispose();
    this.textRenderer.dispose();
    this.xrManager?.dispose();
    this.xrInteraction?.dispose();
    this.sceneManager.dispose();

    // Close WebSocket connection
    this.webSocket.disconnect();
  }
}

// Create application instance
const app = new Application();

// Handle window unload
window.addEventListener('unload', () => {
  app.dispose();
});

// Log application start
console.info('LogseqXR application starting...');
