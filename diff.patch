diff --git a/.env_template b/.env_template
index 1f9e79aa..077b6c6f 100755
--- a/.env_template
+++ b/.env_template
@@ -3,7 +3,7 @@
 # Server Configuration
 RUST_LOG=info                        # Log level (debug, info, warn, error)
 BIND_ADDRESS=0.0.0.0                 # Server bind address
-DEBUG_MODE=false                     # When true, only processes Debug Test Page.md
+DEBUG_MODE=true                     # When true, only processes Debug Test Page.md
 
 # Cloudflare Tunnel Configuration
 TUNNEL_TOKEN=
@@ -11,53 +11,23 @@ TUNNEL_ID=
 
 # Network Configuration
 DOMAIN=www.visionflow.info          # Production domain
-PORT=3000
-ENABLE_TLS=true
-MIN_TLS_VERSION=TLS1.3
-ENABLE_HTTP2=true
-MAX_REQUEST_SIZE=10485760
-ENABLE_RATE_LIMITING=true
-RATE_LIMIT_REQUESTS=100
-RATE_LIMIT_WINDOW=60
-
-# WebSocket Configuration
-WS_RETRY_ATTEMPTS=3                 # Maximum number of reconnection attempts
-WS_RETRY_DELAY=5000                # Initial retry delay in milliseconds (doubles with each attempt)
-WS_CONNECTION_TIMEOUT=10000        # Connection timeout in milliseconds
-WS_MESSAGE_RATE_LIMIT=60           # Maximum messages per second
-WS_MESSAGE_TIME_WINDOW=1000        # Time window for rate limiting in milliseconds
-WS_MAX_MESSAGE_SIZE=5242880        # Maximum message size in bytes (5MB)
-WS_MAX_QUEUE_SIZE=1000             # Maximum number of queued messages
-
-# Security Configuration
-ENABLE_CORS=false
-ENABLE_CSRF=true
-CSRF_TOKEN_TIMEOUT=3600
-SESSION_TIMEOUT=3600
-COOKIE_SECURE=true
-COOKIE_HTTPONLY=true
-COOKIE_SAMESITE=Strict
-ENABLE_SECURITY_HEADERS=true
-ENABLE_REQUEST_VALIDATION=true
-ENABLE_AUDIT_LOGGING=true
-AUDIT_LOG_PATH=/app/logs/audit.log
 
 # GitHub Configuration
 GITHUB_TOKEN=
-GITHUB_OWNER=jjohare
-GITHUB_REPO=logseq
-GITHUB_PATH=mainKnowledgeGraph/pages
-GITHUB_VERSION=2022-11-28
-GITHUB_RATE_LIMIT=true
+GITHUB_OWNER=
+GITHUB_REPO=
+GITHUB_PATH=/pages
+GITHUB_VERSION=
+GITHUB_RATE_LIMIT=
 
 # RAGFlow Configuration
-RAGFLOW_API_KEY=ragflow-
-RAGFLOW_API_BASE_URL=http://192.168.0.51/v1/
+RAGFLOW_API_KEY=
+RAGFLOW_API_BASE_URL=http://ragflowe-server/v1/
 RAGFLOW_TIMEOUT=30
 RAGFLOW_MAX_RETRIES=3
 
 # Perplexity API Configuration
-PERPLEXITY_API_KEY=pplx-
+PERPLEXITY_API_KEY=
 PERPLEXITY_MODEL=llama-3.1-sonar-small-128k-online
 PERPLEXITY_API_URL=https://api.perplexity.ai/chat/completions
 PERPLEXITY_MAX_TOKENS=4096
@@ -69,94 +39,8 @@ PERPLEXITY_TIMEOUT=30
 PERPLEXITY_RATE_LIMIT=100
 
 # OpenAI Configuration
-OPENAI_API_KEY=sk-proj-
+OPENAI_API_KEY=
 OPENAI_BASE_URL=wss://api.openai.com/v1/realtime
 OPENAI_TIMEOUT=30
 OPENAI_RATE_LIMIT=100
 
-# Default Configuration
-MAX_CONCURRENT_REQUESTS=5
-MAX_RETRIES=3
-RETRY_DELAY=5
-API_CLIENT_TIMEOUT=30
-MAX_PAYLOAD_SIZE=5242880
-ENABLE_REQUEST_LOGGING=false
-LOG_LEVEL=info
-LOG_FORMAT=json
-
-# Visualization Settings - Colors
-NODE_COLOR="0x1A0B31"
-EDGE_COLOR="0xff0000"
-HOLOGRAM_COLOR="0xFFD700"
-NODE_COLOR_NEW="0x00ff88"          # Bright green for very recent files (< 3 days)
-NODE_COLOR_RECENT="0x4444ff"       # Blue for recent files (< 7 days)
-NODE_COLOR_MEDIUM="0xffaa00"       # Orange for medium-age files (< 30 days)
-NODE_COLOR_OLD="0xff4444"          # Red for old files (>= 30 days)
-NODE_COLOR_CORE="0xffa500"         # Orange for core nodes
-NODE_COLOR_SECONDARY="0x00ffff"    # Cyan for secondary nodes
-NODE_COLOR_DEFAULT="0x00ff00"      # Green for default nodes
-
-# Visualization Settings - Physical Dimensions (in meters)
-MIN_NODE_SIZE=0.1                  # 10cm minimum node size
-MAX_NODE_SIZE=0.3                  # 30cm maximum node size
-HOLOGRAM_SCALE=5.0
-HOLOGRAM_OPACITY=0.1
-EDGE_OPACITY=0.3
-
-# Visualization Settings - Labels
-LABEL_FONT_SIZE=36
-LABEL_FONT_FAMILY="Arial"
-LABEL_PADDING=20
-LABEL_VERTICAL_OFFSET=2.0
-LABEL_CLOSE_OFFSET=0.2
-LABEL_BACKGROUND_COLOR="rgba(0, 0, 0, 0.8)"
-LABEL_TEXT_COLOR="white"
-LABEL_INFO_TEXT_COLOR="lightgray"
-LABEL_XR_FONT_SIZE=24
-
-# Visualization Settings - Geometry
-GEOMETRY_MIN_SEGMENTS=16
-GEOMETRY_MAX_SEGMENTS=32
-GEOMETRY_SEGMENT_PER_HYPERLINK=0.5
-
-# Visualization Settings - Material
-NODE_MATERIAL_METALNESS=0.2
-NODE_MATERIAL_ROUGHNESS=0.2
-NODE_MATERIAL_CLEARCOAT=0.3
-NODE_MATERIAL_CLEARCOAT_ROUGHNESS=0.2
-NODE_MATERIAL_OPACITY=0.9
-NODE_EMISSIVE_MIN_INTENSITY=0.3
-NODE_EMISSIVE_MAX_INTENSITY=1.0
-
-# Visualization Settings - Interaction
-CLICK_EMISSIVE_BOOST=2.0
-CLICK_FEEDBACK_DURATION=200        # milliseconds
-
-# Visualization Settings - Environment
-FOG_DENSITY=0.002
-
-# Physics Simulation Parameters
-FORCE_DIRECTED_ITERATIONS=250
-FORCE_DIRECTED_SPRING=0.01         # Spring force (0.001-1.0)
-FORCE_DIRECTED_REPULSION=1000.0    # Required for backend compatibility
-FORCE_DIRECTED_ATTRACTION=0.01
-FORCE_DIRECTED_DAMPING=0.8         # Damping (0.5-0.95)
-
-# Bloom Settings
-NODE_BLOOM_STRENGTH=0.1
-NODE_BLOOM_RADIUS=0.1
-NODE_BLOOM_THRESHOLD=0.0
-EDGE_BLOOM_STRENGTH=0.2
-EDGE_BLOOM_RADIUS=0.3
-EDGE_BLOOM_THRESHOLD=0.0
-ENVIRONMENT_BLOOM_STRENGTH=0.5
-ENVIRONMENT_BLOOM_RADIUS=0.1
-ENVIRONMENT_BLOOM_THRESHOLD=0.0
-
-# Fisheye Settings
-FISHEYE_ENABLED=false
-FISHEYE_STRENGTH=0.5
-FISHEYE_RADIUS=100.0
-FISHEYE_FOCUS_X=0.0
-FISHEYE_FOCUS_Y=0.0
-FISHEYE_FOCUS_Z=0.0
diff --git a/client/core/types.ts b/client/core/types.ts
index 86ecd1e6..5c4c1703 100644
--- a/client/core/types.ts
+++ b/client/core/types.ts
@@ -1,99 +1,86 @@
-/**
- * Core types for graph visualization
- */
+// Core types for the application
 
-// Base types
 export interface Vector3 {
   x: number;
   y: number;
   z: number;
 }
 
-// Binary protocol types
-export interface BinaryHeader {
-  version: number;
-  nodeCount: number;
-}
-
-export interface BinaryNodeData {
-  position: Float32Array; // x, y, z
-  velocity: Float32Array; // vx, vy, vz
-}
-
-// Raw types (matching server format)
-export interface RawNodeData {
-  position: [number, number, number];
-  velocity: [number, number, number];
-  mass: number;
-  flags: number;
-}
-
-export interface RawNode {
-  id: string;
-  label: string;
-  data: RawNodeData;
-  metadata?: Record<string, string>;
-  nodeType?: string;
-  size?: number;
-  color?: string;
-  weight?: number;
-  group?: string;
-  userData?: Record<string, string>;
-}
-
-export interface RawGraphData {
-  nodes: RawNode[];
-  edges: Edge[];
-  metadata?: Record<string, any>;
-}
-
-// Transformed types (used in client)
 export interface NodeData {
   position: Vector3;
   velocity: Vector3;
-  mass: number;
-  flags: number;
 }
 
 export interface Node {
   id: string;
-  label: string;
   data: NodeData;
-  metadata?: Record<string, string>;
-  nodeType?: string;
-  size?: number;
   color?: string;
+  metadata?: any;
+}
+
+export interface Edge {
+  source: string;
+  target: string;
   weight?: number;
-  group?: string;
-  userData?: Record<string, string>;
 }
 
 export interface GraphData {
   nodes: Node[];
   edges: Edge[];
-  metadata?: Record<string, any>;
-}
-
-// Performance types
-export interface UpdateBatch {
-  timestamp: number;
-  updates: Float32Array;
+  metadata?: any;
 }
 
-export interface EdgeUpdateBatch {
-  edgeIndices: Set<number>;
-  timestamp: number;
-}
-
-// Shared types
-export interface Edge {
-  source: string;
-  target: string;
-  weight: number;
-  edgeType?: string;
-  metadata?: Record<string, string>;
-}
+// Platform types
+export type Platform = 'desktop' | 'quest' | 'browser';
 
+export interface PlatformCapabilities {
+  xrSupported: boolean;
+  webglSupported: boolean;
+  websocketSupported: boolean;
+  webxr: boolean;
+  handTracking: boolean;
+  planeDetection: boolean;
+}
+
+// Integration Settings Types
+export interface GithubSettings {
+  basePath: string;
+  owner: string;
+  rateLimitEnabled: boolean;
+  repo: string;
+  token: string;
+}
+
+export interface OpenAISettings {
+  apiKey: string;
+  baseUrl: string;
+  model: string;
+  rateLimit: number;
+  timeout: number;
+}
+
+export interface PerplexitySettings {
+  apiKey: string;
+  apiUrl: string;
+  frequencyPenalty: number;
+  maxTokens: number;
+  model: string;
+  presencePenalty: number;
+  prompt: string;
+  rateLimit: number;
+  temperature: number;
+  timeout: number;
+  topP: number;
+}
+
+export interface RagFlowSettings {
+  apiKey: string;
+  baseUrl: string;
+  maxRetries: number;
+  timeout: number;
+}
+
+// Client-side visualization settings
 export interface VisualizationSettings {
   // Node appearance
   nodeSize: number;
@@ -102,18 +89,51 @@ export interface VisualizationSettings {
   metalness: number;
   roughness: number;
   clearcoat: number;
+  enableInstancing: boolean;
+  materialType: string;
+  sizeRange: [number, number];
+  sizeByConnections: boolean;
+  highlightColor: string;
+  highlightDuration: number;
+  enableHoverEffect: boolean;
+  hoverScale: number;
 
   // Edge appearance
   edgeWidth: number;
   edgeColor: string;
   edgeOpacity: number;
+  edgeWidthRange: [number, number];
   enableArrows: boolean;
   arrowSize: number;
 
+  // Physics settings
+  physicsEnabled: boolean;
+  attractionStrength: number;
+  repulsionStrength: number;
+  springStrength: number;
+  damping: number;
+  maxVelocity: number;
+  collisionRadius: number;
+  boundsSize: number;
+  enableBounds: boolean;
+  iterations: number;
+
+  // Lighting and environment
+  ambientLightIntensity: number;
+  directionalLightIntensity: number;
+  environmentIntensity: number;
+  enableAmbientOcclusion: boolean;
+  enableAntialiasing: boolean;
+  enableShadows: boolean;
+  backgroundColor: string;
+
   // Visual effects
   enableBloom: boolean;
   bloomIntensity: number;
   bloomRadius: number;
+  nodeBloomStrength: number;
+  edgeBloomStrength: number;
+  environmentBloomStrength: number;
   enableNodeAnimations: boolean;
   enableMotionBlur: boolean;
   motionBlurStrength: number;
@@ -126,16 +146,13 @@ export interface VisualizationSettings {
   // Performance
   maxFps: number;
 
-  // AR Settings (Meta Quest 3)
-  // Scene Understanding
+  // AR Settings
   enablePlaneDetection: boolean;
   enableSceneUnderstanding: boolean;
   showPlaneOverlay: boolean;
   planeOpacity: number;
   planeColor: string;
   enableLightEstimation: boolean;
-  
-  // Hand Tracking
   enableHandTracking: boolean;
   handMeshEnabled: boolean;
   handMeshColor: string;
@@ -144,22 +161,14 @@ export interface VisualizationSettings {
   handRayColor: string;
   handRayWidth: number;
   handPointSize: number;
-  
-  // Gesture Controls
   gestureSmoothing: number;
   pinchThreshold: number;
   dragThreshold: number;
   rotationThreshold: number;
-  
-  // Haptics
   enableHaptics: boolean;
   hapticIntensity: number;
-  
-  // Room Scale
   roomScale: boolean;
   snapToFloor: boolean;
-  
-  // Passthrough
   passthroughOpacity: number;
   passthroughBrightness: number;
   passthroughContrast: number;
@@ -169,185 +178,224 @@ export interface VisualizationSettings {
   portalEdgeWidth: number;
 }
 
-export interface BinaryNodeUpdate {
-  nodeId: string;
-  data: NodeData;
-}
-
-export interface BinaryPositionUpdateMessage {
-  type: 'binaryPositionUpdate';
-  data: {
-    nodes: BinaryNodeUpdate[];
+// Server-side settings format
+export interface ServerSettings {
+  nodes: {
+    base_size: number;
+    base_color: string;
+    opacity: number;
+    metalness: number;
+    roughness: number;
+    clearcoat: number;
+    enable_instancing: boolean;
+    material_type: string;
+    size_range: [number, number];
+    size_by_connections: boolean;
+    highlight_color: string;
+    highlight_duration: number;
+    enable_hover_effect: boolean;
+    hover_scale: number;
+  };
+  edges: {
+    base_width: number;
+    color: string;
+    opacity: number;
+    width_range: [number, number];
+    enable_arrows: boolean;
+    arrow_size: number;
+  };
+  physics: {
+    enabled: boolean;
+    attraction_strength: number;
+    repulsion_strength: number;
+    spring_strength: number;
+    damping: number;
+    max_velocity: number;
+    collision_radius: number;
+    bounds_size: number;
+    enable_bounds: boolean;
+    iterations: number;
+  };
+  rendering: {
+    ambient_light_intensity: number;
+    directional_light_intensity: number;
+    environment_intensity: number;
+    enable_ambient_occlusion: boolean;
+    enable_antialiasing: boolean;
+    enable_shadows: boolean;
+    background_color: string;
+  };
+  bloom: {
+    enabled: boolean;
+    strength: number;
+    radius: number;
+    node_bloom_strength: number;
+    edge_bloom_strength: number;
+    environment_bloom_strength: number;
+  };
+  animations: {
+    enable_node_animations: boolean;
+    enable_motion_blur: boolean;
+    motion_blur_strength: number;
+  };
+  labels: {
+    enable_labels: boolean;
+    desktop_font_size: number;
+    text_color: string;
+  };
+  ar: {
+    enable_plane_detection: boolean;
+    enable_scene_understanding: boolean;
+    show_plane_overlay: boolean;
+    plane_opacity: number;
+    plane_color: string;
+    enable_light_estimation: boolean;
+    enable_hand_tracking: boolean;
+    hand_mesh_enabled: boolean;
+    hand_mesh_color: string;
+    hand_mesh_opacity: number;
+    hand_ray_enabled: boolean;
+    hand_ray_color: string;
+    hand_ray_width: number;
+    hand_point_size: number;
+    gesture_smoothing: number;
+    pinch_threshold: number;
+    drag_threshold: number;
+    rotation_threshold: number;
+    enable_haptics: boolean;
+    haptic_intensity: number;
+    room_scale: boolean;
+    snap_to_floor: boolean;
+    passthrough_opacity: number;
+    passthrough_brightness: number;
+    passthrough_contrast: number;
+    enable_passthrough_portal: boolean;
+    portal_size: number;
+    portal_edge_color: string;
+    portal_edge_width: number;
   };
 }
 
-// Other message types
-export interface RequestInitialDataMessage {
-  type: 'requestInitialData';
+// WebSocket message types
+export type MessageType = 
+  | 'initialData'
+  | 'graphUpdate'
+  | 'positionUpdate'
+  | 'binaryPositionUpdate'
+  | 'updateSettings'
+  | 'settingsUpdated'
+  | 'requestInitialData'
+  | 'enableBinaryUpdates'
+  | 'connect'
+  | 'disconnect'
+  | 'ping'
+  | 'pong';
+
+// Base message types
+export interface WebSocketMessage {
+  type: MessageType;
+  data?: any;
 }
 
-export interface EnableBinaryUpdatesMessage {
-  type: 'enableBinaryUpdates';
+export interface RawWebSocketMessage {
+  type: MessageType;
+  data?: any;
 }
 
-export interface SettingsUpdateMessage {
-  type: 'settingsUpdated';
+// Initial data messages
+export interface InitialDataMessage extends WebSocketMessage {
+  type: 'initialData';
   data: {
-    settings: VisualizationSettings;
+    graph: GraphData;
   };
 }
 
-export interface UpdateSettingsMessage {
-  type: 'updateSettings';
+export interface RawInitialDataMessage extends RawWebSocketMessage {
+  type: 'initialData';
   data: {
-    settings: Partial<VisualizationSettings>;
+    graph: any;
   };
 }
 
-export interface PingMessage {
-  type: 'ping';
-}
-
-export interface PongMessage {
-  type: 'pong';
-}
-
-// Union types for messages
-export type RawWebSocketMessage =
-  | RawInitialDataMessage
-  | RawBinaryPositionUpdateMessage
-  | SettingsUpdateMessage
-  | UpdateSettingsMessage
-  | RequestInitialDataMessage
-  | EnableBinaryUpdatesMessage
-  | PingMessage
-  | PongMessage;
-
-export type WebSocketMessage =
-  | InitialDataMessage
-  | BinaryPositionUpdateMessage
-  | SettingsUpdateMessage
-  | UpdateSettingsMessage
-  | RequestInitialDataMessage
-  | EnableBinaryUpdatesMessage
-  | PingMessage
-  | PongMessage;
-
-// Platform detection types
-export type Platform = 'browser' | 'quest';
-
-export interface PlatformCapabilities {
-  xrSupported: boolean;
-  webglSupported: boolean;
-  websocketSupported: boolean;
-}
-
-// Message queue types
-export interface QueuedMessage {
-  data: ArrayBuffer;
-  timestamp: number;
-}
-
-// Debug types
-export interface NetworkDebugMessage {
-  direction: 'in' | 'out';
-  type: 'binary' | 'json';
-  timestamp: number;
-  data: any;
-}
-
-// Transform functions
-export function arrayToVector3(arr: [number, number, number]): Vector3 {
-  return { x: arr[0], y: arr[1], z: arr[2] };
-}
-
-export function vector3ToArray(vec: Vector3): [number, number, number] {
-  return [vec.x, vec.y, vec.z];
+// Binary position update messages
+export interface BinaryPositionUpdateMessage extends WebSocketMessage {
+  type: 'binaryPositionUpdate';
+  data: {
+    nodes: {
+      nodeId: string;
+      data: NodeData;
+    }[];
+  };
 }
 
-export function float32ArrayToVector3(arr: Float32Array, offset: number = 0): Vector3 {
-  return {
-    x: arr[offset],
-    y: arr[offset + 1],
-    z: arr[offset + 2]
+export interface RawBinaryPositionUpdateMessage extends RawWebSocketMessage {
+  type: 'binaryPositionUpdate';
+  data: {
+    nodes: {
+      nodeId: string;
+      data: any;
+    }[];
   };
 }
 
-export function vector3ToFloat32Array(vec: Vector3, arr: Float32Array, offset: number = 0): void {
-  arr[offset] = vec.x;
-  arr[offset + 1] = vec.y;
-  arr[offset + 2] = vec.z;
+// Other message types
+export interface RequestInitialDataMessage extends WebSocketMessage {
+  type: 'requestInitialData';
 }
 
-export function transformNodeData(raw: RawNodeData): NodeData {
-  return {
-    position: arrayToVector3(raw.position),
-    velocity: arrayToVector3(raw.velocity),
-    mass: raw.mass,
-    flags: raw.flags
-  };
+export interface EnableBinaryUpdatesMessage extends WebSocketMessage {
+  type: 'enableBinaryUpdates';
 }
 
-export function transformNode(raw: RawNode): Node {
-  return {
-    ...raw,
-    data: transformNodeData(raw.data)
-  };
+export interface PingMessage extends WebSocketMessage {
+  type: 'ping';
 }
 
-export function transformGraphData(raw: RawGraphData): GraphData {
-  return {
-    nodes: raw.nodes.map(transformNode),
-    edges: raw.edges,
-    metadata: raw.metadata
-  };
+export interface PongMessage extends WebSocketMessage {
+  type: 'pong';
 }
 
-// Binary data validation
-export function validateBinaryHeader(data: ArrayBuffer): BinaryHeader | null {
-  if (data.byteLength < 8) return null; // Minimum size for version and count
-  const view = new Float32Array(data);
-  return {
-    version: view[0],
-    nodeCount: Math.floor((view.length - 1) / 6) // (length - version) / floats per node
+// Settings messages
+export interface UpdateSettingsMessage extends WebSocketMessage {
+  type: 'updateSettings';
+  data: {
+    settings: ServerSettings;
   };
 }
 
-// WebSocket message types
-export type MessageType = 
-  | 'initialData'
-  | 'requestInitialData'
-  | 'binaryPositionUpdate'
-  | 'settingsUpdated'
-  | 'updateSettings'
-  | 'enableBinaryUpdates'
-  | 'ping'
-  | 'pong';
-
-// Raw message types (from server)
-export interface RawInitialDataMessage {
-  type: 'initialData';
+export interface SettingsUpdatedMessage extends WebSocketMessage {
+  type: 'settingsUpdated';
   data: {
-    graph: RawGraphData;
+    settings: ServerSettings;
   };
 }
 
-export interface RawBinaryNodeUpdate {
-  nodeId: string;
-  data: RawNodeData;
+// Logger interface
+export interface Logger {
+  log: (message: string, ...args: any[]) => void;
+  error: (message: string, ...args: any[]) => void;
+  warn: (message: string, ...args: any[]) => void;
+  debug: (message: string, ...args: any[]) => void;
+  info: (message: string, ...args: any[]) => void;
 }
 
-export interface RawBinaryPositionUpdateMessage {
-  type: 'binaryPositionUpdate';
-  data: {
-    nodes: RawBinaryNodeUpdate[];
+// Helper functions
+export function transformGraphData(data: any): GraphData {
+  return {
+    nodes: data.nodes.map((node: any) => transformNodeData(node)),
+    edges: data.edges,
+    metadata: data.metadata
   };
 }
 
-// Transformed message types (for client use)
-export interface InitialDataMessage {
-  type: 'initialData';
-  data: {
-    graph: GraphData;
+export function transformNodeData(node: any): Node {
+  return {
+    id: node.id,
+    data: {
+      position: node.data.position,
+      velocity: node.data.velocity || { x: 0, y: 0, z: 0 }
+    },
+    color: node.color,
+    metadata: node.metadata
   };
 }
diff --git a/client/implementationPlan.md b/client/implementationPlan.md
index d17a0d3f..900ce7c4 100644
--- a/client/implementationPlan.md
+++ b/client/implementationPlan.md
@@ -13,39 +13,73 @@ Develop a "mixed reality first" architecture that provides an optimal experience
 Clean, Modern Architecture:
 Use TypeScript, Three.js, and other best-practice libraries as needed (e.g., state management, lightweight UI libraries). No Vue.js. A simple TypeScript-based approach to UI and state management will replace the old Vue-based panel.
 
-Unified Settings Management:
+Unified Settings Management: (In Progress)
 Settings are stored on the server in settings.toml. The desktop interface allows users to adjust these settings and save them back to the server. The Quest version reads and applies these same settings. Avoid duplication by using a unified data model and minimal branching logic.
-
-Vector3 Standardization:
+- ✓ Core settings types and interfaces
+- ✓ Settings state management
+- ✓ WebSocket communication for settings
+- ✓ Settings integration with rendering
+- Desktop settings panel UI (In Progress)
+- Settings persistence and save functionality (In Progress)
+
+Vector3 Standardization: ✓
 Migrate all position/velocity data to a Vector3 (or equivalent [f32; 3] arrays in Rust) representation. Streamline GPU and WebSocket protocols to match this format once and eliminate conversion overhead. All binary data is now handled through Float32Arrays with proper type safety and validation.
 
-Sensible Data Flows and Networking:
+Sensible Data Flows and Networking: ✓
 Rely on a stable WebSocket channel for real-time updates. Desktop and Quest clients share the same binary and JSON protocols. Nginx, Cloudflare tunnels, and Docker networks remain as currently configured, but we keep the plan free of redundant details.
 
 Architecture Overview
 ```
 client/
   ├─ core/              # Core types, constants, utilities ✓
+  │  ├─ types.ts        # Core interfaces and types ✓
+  │  ├─ constants.ts    # Shared constants ✓
+  │  └─ utils.ts        # Helper functions ✓
+  │
   ├─ state/             # Centralized state (settings, graph data) ✓
+  │  ├─ settings.ts     # Settings management ✓
+  │  └─ graphData.ts    # Graph data management ✓
+  │
   ├─ rendering/         # Three.js scene, nodes/edges, text rendering ✓
+  │  ├─ scene.ts        # Scene management ✓
+  │  ├─ nodes.ts        # Node and edge rendering ✓
+  │  └─ textRenderer.ts # Text label rendering ✓
+  │
   ├─ xr/                # XR integration (Quest 3 focus, extends scene) ✓
+  │  ├─ xrSessionManager.ts  # XR session handling ✓
+  │  └─ xrInteraction.ts     # XR input and interaction ✓
+  │
   ├─ platform/          # Platform abstraction (detect Quest vs Desktop) ✓
+  │  └─ platformManager.ts    # Platform detection and capabilities ✓
+  │
   ├─ websocket/         # WebSocket service and message handling ✓
+  │  └─ websocketService.ts   # Real-time communication ✓
+  │
   ├─ types/             # TypeScript declarations for Three.js and WebXR ✓
+  │  ├─ three.d.ts      # Three.js type definitions ✓
+  │  └─ webxr.d.ts      # WebXR type definitions ✓
+  │
   ├─ ui/                # Minimal UI components (desktop settings panel)
+  │  ├─ ControlPanel.ts     # Settings panel UI (In Progress)
+  │  └─ ControlPanel.css    # Settings panel styles (In Progress)
+  │
   └─ main.ts            # Application entry point (initializes everything) ✓
 ```
 
 Key Principles:
 
-Unified Code Paths:
+Unified Code Paths: ✓
 Keep the code paths for desktop and XR similar, differing mainly in input and UI layers. For example, both platforms use the same SceneManager and GraphDataManager, but desktop also spins up a settings panel, while XR relies on in-world interactions or no panel at all.
 
-Minimal Frameworks:
+Minimal Frameworks: ✓
 Vanilla TS, Three.js, and potentially a small state or UI library (e.g., Zustand or a lightweight reactive store) to handle global state and reduce complexity.
 
-No Vue.js:
-The old Vue-based panel is replaced with a simple HTML/TS UI component for the desktop. This UI retrieves and updates settings.toml via API calls.
+No Vue.js: (In Progress)
+The old Vue-based panel is being replaced with a simple HTML/TS UI component for the desktop. This UI retrieves and updates settings.toml via WebSocket.
+- ✓ Remove Vue dependencies
+- ✓ Create TypeScript-based UI structure
+- Settings panel implementation (In Progress)
+- Settings persistence (In Progress)
 
 Core Components
 1. Core (types, constants, utils) ✓
@@ -124,13 +158,14 @@ Detects if running on Quest (WebXR capable) or Desktop.
 Hooks into main.ts to decide whether to start an XR session or show a desktop UI panel.
 Keeps platform-conditional logic localized here.
 
-7. UI (Desktop Settings Interface)
+7. UI (Desktop Settings Interface) (In Progress)
 ui/settingsPanel.ts:
 A simple HTML+TS panel for desktop:
-Fetches current settings on load.
-Allows editing (sliders, text inputs) of VisualizationSettings.
-On "Save" click, sends updated settings back to the server, updating settings.toml.
-The Quest interface reads the updated settings but does not offer in-headset controls for them.
+- ✓ Basic panel structure
+- ✓ Settings controls (sliders, inputs)
+- ✓ Settings update handling
+- Save functionality (In Progress)
+- Settings persistence (In Progress)
 
 8. Application Entry ✓
 main.ts: ✓
@@ -154,7 +189,7 @@ Complete WebXR API type declarations.
 Type guards for optional WebXR features.
 Proper handling of hit testing and light estimation.
 
-Vector3 & Protocol Consolidation
+Vector3 & Protocol Consolidation ✓
 Single Source of Truth:
 All position and velocity data are represented as Vector3-like arrays ([number, number, number]) on the client, and [f32; 3] on the server side. The WebSocket binary protocol uses a 24-byte (6 floats) structure for each position/velocity update. On the GPU side, CUDA kernels and WGSL shaders also align with vec3 data formats, reducing conversions and overhead.
 
@@ -172,14 +207,17 @@ Shaders, if needed, use vec3<f32> with no conversions required.
 Result: ✓
 A consistent Vector3-oriented pipeline from server logic to client rendering reduces complexity and improves performance.
 
-Settings Management Flow (Partial)
+Settings Management Flow (In Progress)
 Startup: ✓
 Client fetches settings.toml via a server endpoint that returns JSON ✓.
 SettingsManager merges these settings with defaults and applies them to the rendering system ✓.
 
-Desktop Editing:
+Desktop Editing: (In Progress)
 The settingsPanel UI lets the user modify visualization settings (e.g., node size, color schemes).
-Clicking "Save" sends a POST request with the updated settings to the server, rewriting settings.toml.
+- ✓ Settings controls implementation
+- ✓ Real-time preview
+- Save functionality (In Progress)
+- Settings persistence (In Progress)
 
 Quest Reading: ✓
 On Quest, no separate panel is displayed. The XR experience uses the settings loaded at startup or after a refresh. Changes made on the desktop propagate automatically at next startup or when re-fetching settings.
@@ -200,7 +238,11 @@ Add proper type safety for all operations ✓.
 
 Phase 3: Settings Integration (In Progress)
 Implement settingsPanel.ts for desktop.
-Wire up SettingsManager to scene and nodes ✓, confirm changes apply when user saves.
+- ✓ Basic panel structure
+- ✓ Settings controls
+- ✓ Settings update handling
+- Save functionality (In Progress)
+- Settings persistence (In Progress)
 
 Phase 4: XR Integration ✓
 Implement xrSessionManager.ts ✓ and xrInteraction.ts ✓.
@@ -215,8 +257,6 @@ Add batched updates and efficient matrix operations ✓.
 Add proper type safety throughout the codebase ✓.
 Ensure stable Vector3-based pipeline and minimal code duplication ✓.
 
-[Rest of Docker & Network Architecture section remains unchanged]
-
 Docker & Network Architecture
 ===========================
 
diff --git a/client/index.html b/client/index.html
index d972fa1d..df06c32e 100644
--- a/client/index.html
+++ b/client/index.html
@@ -4,6 +4,7 @@
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>LogseqXR Graph Visualization</title>
+  <link rel="stylesheet" href="/ui/ControlPanel.css">
   <style>
     * {
       margin: 0;
@@ -25,9 +26,56 @@
       width: 100%;
       height: 100%;
     }
+
+    .loading-overlay {
+      position: fixed;
+      top: 0;
+      left: 0;
+      width: 100%;
+      height: 100%;
+      background: rgba(0, 0, 0, 0.9);
+      display: flex;
+      justify-content: center;
+      align-items: center;
+      z-index: 2000;
+    }
+
+    .loading-overlay .spinner {
+      width: 50px;
+      height: 50px;
+      border: 3px solid rgba(255, 255, 255, 0.1);
+      border-radius: 50%;
+      border-top-color: #4a90e2;
+      animation: spin 1s ease-in-out infinite;
+    }
+
+    @keyframes spin {
+      to { transform: rotate(360deg); }
+    }
+
+    .error-message {
+      position: fixed;
+      top: 20px;
+      right: 20px;
+      background: rgba(255, 59, 48, 0.9);
+      color: white;
+      padding: 12px 20px;
+      border-radius: 6px;
+      font-size: 14px;
+      z-index: 2001;
+      animation: fadeIn 0.3s ease;
+    }
+
+    @keyframes fadeIn {
+      from { opacity: 0; transform: translateY(-10px); }
+      to { opacity: 1; transform: translateY(0); }
+    }
   </style>
 </head>
 <body>
+  <div class="loading-overlay">
+    <div class="spinner"></div>
+  </div>
   <div id="canvas-container">
     <canvas id="main-canvas"></canvas>
   </div>
diff --git a/client/index.ts b/client/index.ts
index c2a81e7f..25723eff 100644
--- a/client/index.ts
+++ b/client/index.ts
@@ -13,7 +13,7 @@ import { XRSessionManager } from './xr/xrSessionManager';
 import { XRInteraction } from './xr/xrInteraction';
 import { createLogger } from './core/utils';
 import { WS_URL } from './core/constants';
-import { BinaryNodeUpdate } from './core/types';
+import { BinaryPositionUpdateMessage } from './core/types';
 import { ControlPanel } from './ui';
 
 const logger = createLogger('Application');
@@ -77,13 +77,13 @@ class Application {
       }
     });
 
-    this.webSocket.on('binaryPositionUpdate', (data) => {
+    this.webSocket.on('binaryPositionUpdate', (data: BinaryPositionUpdateMessage['data']) => {
       if (data && data.nodes) {
         // Convert nodes data to ArrayBuffer for position updates
         const buffer = new ArrayBuffer(data.nodes.length * 24); // 6 floats per node
         const floatArray = new Float32Array(buffer);
         
-        data.nodes.forEach((node: BinaryNodeUpdate, index: number) => {
+        data.nodes.forEach((node, index) => {
           const baseIndex = index * 6;
           const pos = node.data.position;
           const vel = node.data.velocity;
diff --git a/client/platform/platformManager.ts b/client/platform/platformManager.ts
index 33558893..1599a97f 100644
--- a/client/platform/platformManager.ts
+++ b/client/platform/platformManager.ts
@@ -1,29 +1,53 @@
-/**
- * Platform detection and capability management
- */
+class BrowserEventEmitter {
+  private listeners: { [event: string]: Function[] } = {};
+
+  on(event: string, listener: Function): void {
+    if (!this.listeners[event]) {
+      this.listeners[event] = [];
+    }
+    this.listeners[event].push(listener);
+  }
+
+  emit(event: string, ...args: any[]): void {
+    const eventListeners = this.listeners[event];
+    if (eventListeners) {
+      eventListeners.forEach(listener => listener(...args));
+    }
+  }
+
+  removeAllListeners(): void {
+    this.listeners = {};
+  }
+}
 
 import { Platform, PlatformCapabilities } from '../core/types';
 import { createLogger } from '../core/utils';
 
 const logger = createLogger('PlatformManager');
 
-export class PlatformManager {
-  private static instance: PlatformManager;
+declare global {
+  interface Navigator {
+    xr?: XRSystem;
+  }
+}
+
+export class PlatformManager extends BrowserEventEmitter {
+  private static instance: PlatformManager | null = null;
   private platform: Platform;
   private capabilities: PlatformCapabilities;
+  private initialized: boolean = false;
 
   private constructor() {
-    this.platform = this.detectPlatform();
-    // Initialize with default values
+    super();
+    this.platform = 'desktop';
     this.capabilities = {
       xrSupported: false,
       webglSupported: false,
-      websocketSupported: false
+      websocketSupported: false,
+      webxr: false,
+      handTracking: false,
+      planeDetection: false
     };
-    // Then update capabilities asynchronously
-    this.updateCapabilities();
-    
-    logger.log(`Platform: ${this.platform}`);
   }
 
   static getInstance(): PlatformManager {
@@ -33,40 +57,61 @@ export class PlatformManager {
     return PlatformManager.instance;
   }
 
-  private detectPlatform(): Platform {
-    // Check for Oculus Browser
+  async initialize(): Promise<void> {
+    if (this.initialized) {
+      return;
+    }
+
+    this.detectPlatform();
+    await this.detectCapabilities();
+    this.initialized = true;
+    logger.log('Platform manager initialized');
+  }
+
+  private detectPlatform(): void {
     const userAgent = navigator.userAgent.toLowerCase();
-    if (userAgent.includes('oculus') || userAgent.includes('quest')) {
-      return 'quest';
+    const isQuest = userAgent.includes('quest');
+    
+    if (isQuest) {
+      this.platform = 'quest';
+    } else if (userAgent.includes('chrome') || userAgent.includes('firefox') || userAgent.includes('safari')) {
+      this.platform = 'browser';
+    } else {
+      this.platform = 'desktop';
     }
-    return 'browser';
   }
 
-  private async updateCapabilities(): Promise<void> {
-    // Check WebXR support
-    if (navigator.xr) {
+  private async detectCapabilities(): Promise<void> {
+    // WebXR support
+    if ('xr' in navigator && navigator.xr) {
       try {
         this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
+        this.capabilities.webxr = this.capabilities.xrSupported;
+        this.capabilities.handTracking = this.capabilities.xrSupported;
+        this.capabilities.planeDetection = this.capabilities.xrSupported;
       } catch (error) {
-        logger.warn('Error checking XR support:', error);
+        logger.warn('WebXR not supported:', error);
         this.capabilities.xrSupported = false;
+        this.capabilities.webxr = false;
+        this.capabilities.handTracking = false;
+        this.capabilities.planeDetection = false;
       }
     }
 
-    // Check WebGL support
+    // WebGL support
     try {
       const canvas = document.createElement('canvas');
       const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
       this.capabilities.webglSupported = !!gl;
     } catch (error) {
-      logger.warn('Error checking WebGL support:', error);
+      logger.warn('WebGL not supported:', error);
       this.capabilities.webglSupported = false;
     }
 
-    // Check WebSocket support
+    // WebSocket support
     this.capabilities.websocketSupported = 'WebSocket' in window;
 
-    logger.log('Capabilities:', this.capabilities);
+    logger.log('Platform capabilities detected:', this.capabilities);
   }
 
   getPlatform(): Platform {
@@ -74,7 +119,11 @@ export class PlatformManager {
   }
 
   getCapabilities(): PlatformCapabilities {
-    return this.capabilities;
+    return { ...this.capabilities };
+  }
+
+  isDesktop(): boolean {
+    return this.platform === 'desktop';
   }
 
   isQuest(): boolean {
@@ -85,7 +134,7 @@ export class PlatformManager {
     return this.platform === 'browser';
   }
 
-  async isXRSupported(): Promise<boolean> {
+  isXRSupported(): boolean {
     return this.capabilities.xrSupported;
   }
 
@@ -97,90 +146,61 @@ export class PlatformManager {
     return this.capabilities.websocketSupported;
   }
 
-  async requestXRSession(mode: XRSessionMode = 'immersive-ar'): Promise<XRSession | null> {
-    if (!this.capabilities.xrSupported || !navigator.xr) {
-      logger.warn('XR not supported on this platform');
+  async requestXRSession(): Promise<XRSession | null> {
+    if (!this.capabilities.xrSupported || !('xr' in navigator) || !navigator.xr) {
+      logger.warn('WebXR not supported');
       return null;
     }
 
     try {
-      const session = await navigator.xr.requestSession(mode, {
+      const session = await navigator.xr.requestSession('immersive-ar', {
         requiredFeatures: ['local-floor', 'hit-test'],
-        optionalFeatures: ['hand-tracking', 'layers']
+        optionalFeatures: ['hand-tracking', 'plane-detection']
       });
+
+      // Update capabilities based on session features
+      session.addEventListener('end', () => {
+        logger.log('XR session ended');
+        this.emit('xrsessionend');
+      });
+
+      logger.log('XR session started');
       return session;
     } catch (error) {
-      logger.error('Error requesting XR session:', error);
+      logger.error('Failed to start XR session:', error);
       return null;
     }
   }
 
-  // Event handling for platform-specific features
-  private eventListeners: Map<string, Set<Function>> = new Map();
-
-  on(event: string, callback: Function): void {
-    if (!this.eventListeners.has(event)) {
-      this.eventListeners.set(event, new Set());
-    }
-    this.eventListeners.get(event)?.add(callback);
-  }
-
-  off(event: string, callback: Function): void {
-    this.eventListeners.get(event)?.delete(callback);
-  }
-
-  private emit(event: string, ...args: any[]): void {
-    this.eventListeners.get(event)?.forEach(callback => {
+  async checkXRSupport(): Promise<void> {
+    if ('xr' in navigator && navigator.xr) {
       try {
-        callback(...args);
+        // Check for AR support
+        const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
+        if (arSupported) {
+          this.capabilities.xrSupported = true;
+          this.capabilities.webxr = true;
+          this.capabilities.handTracking = true;
+          this.capabilities.planeDetection = true;
+          this.emit('xrdevicechange', true);
+          logger.log('WebXR AR supported');
+        }
       } catch (error) {
-        logger.error(`Error in platform event listener for ${event}:`, error);
+        logger.warn('WebXR check failed:', error);
+        this.capabilities.xrSupported = false;
+        this.capabilities.webxr = false;
+        this.capabilities.handTracking = false;
+        this.capabilities.planeDetection = false;
+        this.emit('xrdevicechange', false);
       }
-    });
-  }
-
-  // Device orientation handling for mobile/Quest
-  private setupDeviceOrientation(): void {
-    if (typeof DeviceOrientationEvent !== 'undefined') {
-      window.addEventListener('deviceorientation', (event: DeviceOrientationEvent) => {
-        this.emit('orientation', {
-          alpha: event.alpha, // z-axis rotation
-          beta: event.beta,   // x-axis rotation
-          gamma: event.gamma  // y-axis rotation
-        });
-      }, true);
     }
   }
 
-  // Screen orientation handling
-  private setupScreenOrientation(): void {
-    if ('screen' in window && 'orientation' in screen) {
-      screen.orientation.addEventListener('change', () => {
-        this.emit('orientationchange', screen.orientation.type);
-      });
-    }
-  }
-
-  // Initialize platform-specific features
-  async initialize(): Promise<void> {
-    // Set up event listeners
-    this.setupDeviceOrientation();
-    this.setupScreenOrientation();
-
-    // Check for WebXR changes
-    if (navigator.xr) {
-      navigator.xr.addEventListener('devicechange', async () => {
-        if (navigator.xr) {
-          this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
-          this.emit('xrdevicechange', this.capabilities.xrSupported);
-        }
-      });
-    }
-
-    // Additional platform-specific initialization can be added here
-    logger.log('Platform manager initialized');
+  dispose(): void {
+    this.removeAllListeners();
+    this.initialized = false;
+    PlatformManager.instance = null;
   }
 }
 
-// Export a singleton instance
 export const platformManager = PlatformManager.getInstance();
diff --git a/client/rendering/nodes.ts b/client/rendering/nodes.ts
index 13ec778c..01637be2 100644
--- a/client/rendering/nodes.ts
+++ b/client/rendering/nodes.ts
@@ -6,26 +6,20 @@ import * as THREE from 'three';
 import { Node, Edge } from '../core/types';
 import { SceneManager } from './scene';
 import { createLogger } from '../core/utils';
-import { NODE_HIGHLIGHT_COLOR } from '../core/constants';
+import { settingsManager } from '../state/settings';
 
 const logger = createLogger('NodeManager');
 
 // Constants for geometry
-const NODE_SIZE = 2.5;
-const NODE_VISUAL_OFFSET = 1.0; // Reduced from NODE_SIZE to account for visual appearance
 const NODE_SEGMENTS = 16;
-const EDGE_RADIUS = 0.25;
 const EDGE_SEGMENTS = 8;
+const NODE_SIZE_MULTIPLIER = 1; // Reduced from 25 to 1 for better control
 
 // Binary format constants
 const BINARY_VERSION = 1.0;
 const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
 const VERSION_OFFSET = 1;    // Skip version float
 
-// Colors
-const NODE_COLOR = 0x4CAF50;  // Material Design Green
-const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300
-
 // Reusable objects for matrix calculations
 const matrix = new THREE.Matrix4();
 const quaternion = new THREE.Quaternion();
@@ -68,23 +62,31 @@ export class NodeManager {
   private constructor(sceneManager: SceneManager) {
     this.sceneManager = sceneManager;
     
+    // Get initial settings
+    const threeSettings = settingsManager.getThreeJSSettings();
+    
     // Initialize with proper geometries
-    const nodeGeometry = new THREE.SphereGeometry(NODE_SIZE, NODE_SEGMENTS, NODE_SEGMENTS);
+    const nodeGeometry = new THREE.SphereGeometry(threeSettings.nodes.size * NODE_SIZE_MULTIPLIER, NODE_SEGMENTS, NODE_SEGMENTS);
     const nodeMaterial = new THREE.MeshPhongMaterial({
-      color: NODE_COLOR,
-      shininess: 90,
-      specular: 0x444444,
+      color: new THREE.Color(threeSettings.nodes.color),
+      shininess: 100, // High shininess for metallic look
+      specular: new THREE.Color('#FFFFFF'), // Bright specular for golden sheen
       transparent: true,
-      opacity: 0.7
+      opacity: threeSettings.nodes.opacity
     });
 
-    const edgeGeometry = new THREE.CylinderGeometry(EDGE_RADIUS, EDGE_RADIUS, 1, EDGE_SEGMENTS);
+    const edgeGeometry = new THREE.CylinderGeometry(
+      threeSettings.edges.width / 4,
+      threeSettings.edges.width / 4,
+      1,
+      EDGE_SEGMENTS
+    );
     edgeGeometry.rotateX(Math.PI / 2);
     
     const edgeMaterial = new THREE.MeshBasicMaterial({
-      color: EDGE_COLOR,
+      color: new THREE.Color(threeSettings.edges.color),
       transparent: true,
-      opacity: 0.7,
+      opacity: threeSettings.edges.opacity,
       depthWrite: false
     });
 
@@ -92,7 +94,56 @@ export class NodeManager {
     this.edgeInstances = new THREE.InstancedMesh(edgeGeometry, edgeMaterial, 30000);
     
     this.initializeInstances();
-    logger.log('NodeManager initialized');
+
+    // Subscribe to settings changes
+    settingsManager.subscribe(() => this.onSettingsChanged());
+    
+    logger.log('NodeManager initialized with settings:', threeSettings);
+  }
+
+  private onSettingsChanged(): void {
+    const threeSettings = settingsManager.getThreeJSSettings();
+
+    // Update node geometry with new size
+    const nodeGeometry = new THREE.SphereGeometry(threeSettings.nodes.size * NODE_SIZE_MULTIPLIER, NODE_SEGMENTS, NODE_SEGMENTS);
+    this.nodeInstances.geometry.dispose();
+    this.nodeInstances.geometry = nodeGeometry;
+
+    // Update node material
+    const nodeMaterial = this.nodeInstances.material as THREE.MeshPhongMaterial;
+    nodeMaterial.color.set(threeSettings.nodes.color);
+    nodeMaterial.opacity = threeSettings.nodes.opacity;
+    nodeMaterial.shininess = 100; // Keep high shininess for metallic look
+    nodeMaterial.specular.set('#FFFFFF'); // Keep bright specular for golden sheen
+
+    // Update edge material
+    const edgeMaterial = this.edgeInstances.material as THREE.MeshBasicMaterial;
+    edgeMaterial.color.set(threeSettings.edges.color);
+    edgeMaterial.opacity = threeSettings.edges.opacity;
+
+    // Update all node positions to account for new size
+    this.currentNodes.forEach((node, index) => {
+      position.set(
+        node.data.position.x,
+        node.data.position.y,
+        node.data.position.z
+      );
+      matrix.compose(position, quaternion, scale);
+      this.nodeInstances.setMatrixAt(index, matrix);
+    });
+    this.nodeInstances.instanceMatrix.needsUpdate = true;
+
+    // Update all edges to account for new node size
+    this.currentEdges.forEach((edge, index) => {
+      const sourceNode = this.currentNodes.find(n => n.id === edge.source);
+      const targetNode = this.currentNodes.find(n => n.id === edge.target);
+      if (sourceNode && targetNode) {
+        this.updateEdgeInstance(index, sourceNode, targetNode);
+      }
+    });
+    this.edgeInstances.instanceMatrix.needsUpdate = true;
+
+    logger.log('Visual settings updated:', threeSettings);
   }
 
   static getInstance(sceneManager: SceneManager): NodeManager {
@@ -194,12 +245,13 @@ export class NodeManager {
     if (this.highlightedNode === nodeId) return;
 
     const color = new THREE.Color();
+    const threeSettings = settingsManager.getThreeJSSettings();
 
     if (this.highlightedNode) {
       const prevIndex = this.nodeIndices.get(this.highlightedNode);
       if (prevIndex !== undefined) {
         const node = this.currentNodes[prevIndex];
-        color.set(node?.color || NODE_COLOR);
+        color.set(node?.color || threeSettings.nodes.color);
         this.nodeInstances.setColorAt(prevIndex, color);
       }
     }
@@ -207,7 +259,7 @@ export class NodeManager {
     if (nodeId) {
       const index = this.nodeIndices.get(nodeId);
       if (index !== undefined) {
-        color.set(NODE_HIGHLIGHT_COLOR);
+        color.set(threeSettings.nodes.highlightColor);
         this.nodeInstances.setColorAt(index, color);
       }
     }
@@ -224,6 +276,9 @@ export class NodeManager {
     this.nodeIndices.clear();
     this.dirtyEdges.clear();
 
+    // Get current settings
+    const threeSettings = settingsManager.getThreeJSSettings();
+
     // Update node instances count and matrices
     this.nodeInstances.count = nodes.length;
     nodes.forEach((node, index) => {
@@ -237,9 +292,16 @@ export class NodeManager {
 
       matrix.compose(position, quaternion, scale);
       this.nodeInstances.setMatrixAt(index, matrix);
+
+      // Set node color based on settings
+      const color = new THREE.Color(node.color || threeSettings.nodes.color);
+      this.nodeInstances.setColorAt(index, color);
     });
 
     this.nodeInstances.instanceMatrix.needsUpdate = true;
+    if (this.nodeInstances.instanceColor) {
+      this.nodeInstances.instanceColor.needsUpdate = true;
+    }
 
     // Update edge instances
     this.edgeInstances.count = edges.length;
@@ -282,8 +344,11 @@ export class NodeManager {
       quaternion.setFromAxisAngle(tempVector, angle);
     }
 
-    // Use NODE_VISUAL_OFFSET instead of NODE_SIZE for more accurate edge length
-    scale.set(1, Math.max(0.001, length - (NODE_VISUAL_OFFSET * 2)), 1);
+    // Get current settings
+    const threeSettings = settingsManager.getThreeJSSettings();
+    const nodeVisualOffset = threeSettings.nodes.size * NODE_SIZE_MULTIPLIER;
+
+    scale.set(nodeVisualOffset, nodeVisualOffset, nodeVisualOffset);
 
     matrix.compose(position, quaternion, scale);
     this.edgeInstances.setMatrixAt(index, matrix);
@@ -320,34 +385,36 @@ export class NodeManager {
   }
 
   private processNodeChunk(floatArray: Float32Array, startIndex: number, endIndex: number): void {
-    // Reset quaternion and scale for each chunk to ensure clean transforms
-    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0); // Identity quaternion using axis-angle
-    scale.set(1, 1, 1);         // Unit scale
-
+    // Reset quaternion to identity
+    quaternion.identity();
+    
+    const threeSettings = settingsManager.getThreeJSSettings();
+    const nodeSize = threeSettings.nodes.size;
+    
     for (let i = startIndex; i < endIndex; i++) {
       const baseIndex = VERSION_OFFSET + (i * FLOATS_PER_NODE);
       
-      // Extract position directly into position vector
+      // Extract position
       position.set(
         floatArray[baseIndex],
         floatArray[baseIndex + 1],
         floatArray[baseIndex + 2]
       );
 
-      // Create a new matrix for this instance to avoid transformation bleeding
-      const instanceMatrix = new THREE.Matrix4();
-      instanceMatrix.compose(position, quaternion, scale);
-      this.nodeInstances.setMatrixAt(i, instanceMatrix);
+      // Apply uniform scale
+      scale.set(nodeSize, nodeSize, nodeSize);
+      
+      // Create matrix with uniform scaling
+      matrix.compose(position, quaternion, scale);
+      this.nodeInstances.setMatrixAt(i, matrix);
 
       // Update node data
       const node = this.currentNodes[i];
       if (node) {
-        // Update position
         node.data.position.x = floatArray[baseIndex];
         node.data.position.y = floatArray[baseIndex + 1];
         node.data.position.z = floatArray[baseIndex + 2];
         
-        // Update velocity
         node.data.velocity.x = floatArray[baseIndex + 3];
         node.data.velocity.y = floatArray[baseIndex + 4];
         node.data.velocity.z = floatArray[baseIndex + 5];
diff --git a/client/state/settings.ts b/client/state/settings.ts
index ed6474c5..e0998b0a 100644
--- a/client/state/settings.ts
+++ b/client/state/settings.ts
@@ -2,356 +2,522 @@
  * Settings management with simplified visualization configuration
  */
 
-import { VisualizationSettings } from '../core/types';
+import { VisualizationSettings, ServerSettings, UpdateSettingsMessage, SettingsUpdatedMessage } from '../core/types';
 import { createLogger } from '../core/utils';
 import { WebSocketService } from '../websocket/websocketService';
 
 const logger = createLogger('SettingsManager');
 
 export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
-    // Node Appearance
-    nodeSize: 0.2,
-    nodeColor: '#FFB700',
-    nodeOpacity: 0.92,
-    metalness: 0.85,
-    roughness: 0.15,
-    clearcoat: 1.0,
-
-    // Edge Appearance
-    edgeWidth: 2.0,
-    edgeColor: '#FFD700',
-    edgeOpacity: 0.6,
-    enableArrows: true,
-    arrowSize: 0.15,
-
-    // Visual Effects
-    enableBloom: true,
-    bloomIntensity: 1.8,
-    bloomRadius: 0.5,
-    enableNodeAnimations: true,
-    enableMotionBlur: true,
-    motionBlurStrength: 0.4,
-
-    // Labels
-    showLabels: true,
-    labelSize: 1.0,
-    labelColor: '#FFFFFF',
-
-    // Performance
-    maxFps: 60,
-
-    // AR Settings (Meta Quest 3)
-    // Scene Understanding
-    enablePlaneDetection: true,
-    enableSceneUnderstanding: true,
-    showPlaneOverlay: true,
-    planeOpacity: 0.3,
-    planeColor: '#4A90E2',
-    enableLightEstimation: true,
-    
-    // Hand Tracking
-    enableHandTracking: true,
-    handMeshEnabled: true,
-    handMeshColor: '#FFD700',
-    handMeshOpacity: 0.3,
-    handRayEnabled: true,
-    handRayColor: '#FFD700',
-    handRayWidth: 0.002,
-    handPointSize: 0.01,
-    
-    // Gesture Controls
-    gestureSmoothing: 0.9,
-    pinchThreshold: 0.015,
-    dragThreshold: 0.04,
-    rotationThreshold: 0.08,
-    
-    // Haptics
-    enableHaptics: true,
-    hapticIntensity: 0.7,
-    
-    // Room Scale
-    roomScale: true,
-    snapToFloor: true,
-    
-    // Passthrough
-    passthroughOpacity: 1.0,
-    passthroughBrightness: 1.0,
-    passthroughContrast: 1.0,
-    enablePassthroughPortal: false,
-    portalSize: 1.0,
-    portalEdgeColor: '#FFD700',
-    portalEdgeWidth: 0.02
+  // Node Appearance
+  nodeSize: 1.0,
+  nodeColor: '#FFB700',
+  nodeOpacity: 0.92,
+  metalness: 0.85,
+  roughness: 0.15,
+  clearcoat: 1.0,
+  enableInstancing: true,
+  materialType: 'physical',
+  sizeRange: [1, 5],
+  sizeByConnections: true,
+  highlightColor: '#FFFFFF',
+  highlightDuration: 500,
+  enableHoverEffect: true,
+  hoverScale: 1.2,
+
+  // Edge Appearance
+  edgeWidth: 2.0,
+  edgeColor: '#FFD700',
+  edgeOpacity: 0.6,
+  edgeWidthRange: [1.0, 3.0],
+  enableArrows: true,
+  arrowSize: 0.15,
+
+  // Physics Settings
+  physicsEnabled: true,
+  attractionStrength: 0.015,
+  repulsionStrength: 1500.0,
+  springStrength: 0.018,
+  damping: 0.88,
+  maxVelocity: 2.5,
+  collisionRadius: 0.25,
+  boundsSize: 12.0,
+  enableBounds: true,
+  iterations: 500,
+
+  // Rendering Settings
+  ambientLightIntensity: 0.7,
+  directionalLightIntensity: 1.0,
+  environmentIntensity: 1.2,
+  enableAmbientOcclusion: true,
+  enableAntialiasing: true,
+  enableShadows: true,
+  backgroundColor: '#000000',
+
+  // Visual Effects
+  enableBloom: true,
+  bloomIntensity: 1.8,
+  bloomRadius: 0.5,
+  nodeBloomStrength: 0.2,
+  edgeBloomStrength: 0.3,
+  environmentBloomStrength: 0.5,
+  enableNodeAnimations: true,
+  enableMotionBlur: true,
+  motionBlurStrength: 0.4,
+
+  // Labels
+  showLabels: true,
+  labelSize: 1.0,
+  labelColor: '#FFFFFF',
+
+  // Performance
+  maxFps: 60,
+
+  // AR Settings (Meta Quest 3)
+  // Scene Understanding
+  enablePlaneDetection: true,
+  enableSceneUnderstanding: true,
+  showPlaneOverlay: true,
+  planeOpacity: 0.3,
+  planeColor: '#4A90E2',
+  enableLightEstimation: true,
+  
+  // Hand Tracking
+  enableHandTracking: true,
+  handMeshEnabled: true,
+  handMeshColor: '#FFD700',
+  handMeshOpacity: 0.3,
+  handRayEnabled: true,
+  handRayColor: '#FFD700',
+  handRayWidth: 0.002,
+  handPointSize: 0.01,
+  
+  // Gesture Controls
+  gestureSmoothing: 0.9,
+  pinchThreshold: 0.015,
+  dragThreshold: 0.04,
+  rotationThreshold: 0.08,
+  
+  // Haptics
+  enableHaptics: true,
+  hapticIntensity: 0.7,
+  
+  // Room Scale
+  roomScale: true,
+  snapToFloor: true,
+  
+  // Passthrough
+  passthroughOpacity: 1.0,
+  passthroughBrightness: 1.0,
+  passthroughContrast: 1.0,
+  enablePassthroughPortal: false,
+  portalSize: 1.0,
+  portalEdgeColor: '#FFD700',
+  portalEdgeWidth: 0.02
 };
 
 export class SettingsManager {
-  private static instance: SettingsManager | null = null;
-  private settings: VisualizationSettings;
-  private settingsListeners: Set<(settings: VisualizationSettings) => void>;
-  private webSocket: WebSocketService | null = null;
-
-  private constructor() {
-    this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
-    this.settingsListeners = new Set();
-    logger.log('Initialized with default settings');
-  }
-
-  static getInstance(): SettingsManager {
-    if (!SettingsManager.instance) {
-      SettingsManager.instance = new SettingsManager();
-    }
-    return SettingsManager.instance;
-  }
-
-  /**
-   * Initialize WebSocket connection
-   */
-  initializeWebSocket(webSocket: WebSocketService): void {
-    this.webSocket = webSocket;
-
-    // Listen for settings updates from server
-    this.webSocket.on('settingsUpdated', (data) => {
-      if (data && data.settings) {
-        this.settings = data.settings;
-        this.notifyListeners();
-      }
-    });
-
-    logger.log('WebSocket initialized for settings');
-  }
-
-  /**
-   * Load settings from the server via WebSocket
-   */
-  async loadSettings(): Promise<void> {
-    // Settings will be received through the settingsUpdated WebSocket message
-    // No need to explicitly request them as they're sent with initial data
-    logger.log('Settings will be received through WebSocket');
-  }
-
-  /**
-   * Save current settings to the server via WebSocket
-   */
-  async saveSettings(): Promise<void> {
-    if (!this.webSocket) {
-      throw new Error('WebSocket not initialized');
+    private static instance: SettingsManager | null = null;
+    private settings: VisualizationSettings;
+    private settingsListeners: Set<(settings: VisualizationSettings) => void>;
+    private webSocket: WebSocketService | null = null;
+    private connectionListeners: Set<(connected: boolean) => void>;
+    private connected: boolean = false;
+
+    private constructor() {
+        this.settings = { ...DEFAULT_VISUALIZATION_SETTINGS };
+        this.settingsListeners = new Set();
+        this.connectionListeners = new Set();
+        logger.log('Initialized with default settings');
     }
 
-    try {
-      this.webSocket.send({
-        type: 'updateSettings',
-        data: {
-          settings: this.settings
+    static getInstance(): SettingsManager {
+        if (!SettingsManager.instance) {
+            SettingsManager.instance = new SettingsManager();
         }
-      });
-      logger.log('Settings update sent through WebSocket');
-    } catch (error) {
-      logger.error('Error sending settings update:', error);
-      throw error;
+        return SettingsManager.instance;
     }
-  }
-
-  /**
-   * Update settings and notify listeners
-   */
-  updateSettings(newSettings: Partial<VisualizationSettings>): void {
-    this.settings = {
-      ...this.settings,
-      ...newSettings
-    };
-
-    logger.log('Updated settings locally');
-    this.notifyListeners();
-    
-    // Send update to server if WebSocket is available
-    if (this.webSocket) {
-      this.saveSettings().catch(error => {
-        logger.error('Failed to save settings to server:', error);
-      });
+
+    initializeWebSocket(webSocket: WebSocketService): void {
+        this.webSocket = webSocket;
+
+        this.webSocket.on('settingsUpdated', (data: SettingsUpdatedMessage['data']) => {
+            if (data && data.settings) {
+                this.settings = this.flattenSettings(data.settings);
+                this.notifyListeners();
+                logger.log('Received settings update from server');
+            }
+        });
+
+        // Monitor connection state
+        this.webSocket.on('connect', () => {
+            this.connected = true;
+            this.notifyConnectionListeners();
+            logger.log('WebSocket connected');
+        });
+
+        this.webSocket.on('disconnect', () => {
+            this.connected = false;
+            this.notifyConnectionListeners();
+            logger.log('WebSocket disconnected');
+        });
+
+        logger.log('WebSocket initialized for settings');
+    }
+
+    isConnected(): boolean {
+        return this.connected;
     }
-  }
 
-  private notifyListeners(): void {
-    this.settingsListeners.forEach(listener => {
+    onConnectionChange(listener: (connected: boolean) => void): void {
+        this.connectionListeners.add(listener);
+        // Immediately notify of current state
+        listener(this.connected);
+    }
+
+    async loadSettings(): Promise<void> {
+      logger.log('Settings will be received through WebSocket');
+    }
+  
+    async saveSettings(): Promise<void> {
+      if (!this.webSocket) {
+        throw new Error('WebSocket not initialized');
+      }
+  
       try {
-        listener(this.settings);
+        const serverSettings: ServerSettings = {
+          nodes: {
+            base_size: this.settings.nodeSize,
+            base_color: this.settings.nodeColor,
+            opacity: this.settings.nodeOpacity,
+            metalness: this.settings.metalness,
+            roughness: this.settings.roughness,
+            clearcoat: this.settings.clearcoat,
+            enable_instancing: this.settings.enableInstancing,
+            material_type: this.settings.materialType,
+            size_range: this.settings.sizeRange,
+            size_by_connections: this.settings.sizeByConnections,
+            highlight_color: this.settings.highlightColor,
+            highlight_duration: this.settings.highlightDuration,
+            enable_hover_effect: this.settings.enableHoverEffect,
+            hover_scale: this.settings.hoverScale
+          },
+          edges: {
+            base_width: this.settings.edgeWidth,
+            color: this.settings.edgeColor,
+            opacity: this.settings.edgeOpacity,
+            width_range: this.settings.edgeWidthRange,
+            enable_arrows: this.settings.enableArrows,
+            arrow_size: this.settings.arrowSize
+          },
+          physics: {
+            enabled: this.settings.physicsEnabled,
+            attraction_strength: this.settings.attractionStrength,
+            repulsion_strength: this.settings.repulsionStrength,
+            spring_strength: this.settings.springStrength,
+            damping: this.settings.damping,
+            max_velocity: this.settings.maxVelocity,
+            collision_radius: this.settings.collisionRadius,
+            bounds_size: this.settings.boundsSize,
+            enable_bounds: this.settings.enableBounds,
+            iterations: this.settings.iterations
+          },
+          rendering: {
+            ambient_light_intensity: this.settings.ambientLightIntensity,
+            directional_light_intensity: this.settings.directionalLightIntensity,
+            environment_intensity: this.settings.environmentIntensity,
+            enable_ambient_occlusion: this.settings.enableAmbientOcclusion,
+            enable_antialiasing: this.settings.enableAntialiasing,
+            enable_shadows: this.settings.enableShadows,
+            background_color: this.settings.backgroundColor
+          },
+          bloom: {
+            enabled: this.settings.enableBloom,
+            strength: this.settings.bloomIntensity,
+            radius: this.settings.bloomRadius,
+            node_bloom_strength: this.settings.nodeBloomStrength,
+            edge_bloom_strength: this.settings.edgeBloomStrength,
+            environment_bloom_strength: this.settings.environmentBloomStrength
+          },
+          animations: {
+            enable_node_animations: this.settings.enableNodeAnimations,
+            enable_motion_blur: this.settings.enableMotionBlur,
+            motion_blur_strength: this.settings.motionBlurStrength
+          },
+          labels: {
+            enable_labels: this.settings.showLabels,
+            desktop_font_size: this.settings.labelSize * 48,
+            text_color: this.settings.labelColor
+          },
+          ar: {
+            enable_plane_detection: this.settings.enablePlaneDetection,
+            enable_scene_understanding: this.settings.enableSceneUnderstanding,
+            show_plane_overlay: this.settings.showPlaneOverlay,
+            plane_opacity: this.settings.planeOpacity,
+            plane_color: this.settings.planeColor,
+            enable_light_estimation: this.settings.enableLightEstimation,
+            enable_hand_tracking: this.settings.enableHandTracking,
+            hand_mesh_enabled: this.settings.handMeshEnabled,
+            hand_mesh_color: this.settings.handMeshColor,
+            hand_mesh_opacity: this.settings.handMeshOpacity,
+            hand_ray_enabled: this.settings.handRayEnabled,
+            hand_ray_color: this.settings.handRayColor,
+            hand_ray_width: this.settings.handRayWidth,
+            hand_point_size: this.settings.handPointSize,
+            gesture_smoothing: this.settings.gestureSmoothing,
+            pinch_threshold: this.settings.pinchThreshold,
+            drag_threshold: this.settings.dragThreshold,
+            rotation_threshold: this.settings.rotationThreshold,
+            enable_haptics: this.settings.enableHaptics,
+            haptic_intensity: this.settings.hapticIntensity,
+            room_scale: this.settings.roomScale,
+            snap_to_floor: this.settings.snapToFloor,
+            passthrough_opacity: this.settings.passthroughOpacity,
+            passthrough_brightness: this.settings.passthroughBrightness,
+            passthrough_contrast: this.settings.passthroughContrast,
+            enable_passthrough_portal: this.settings.enablePassthroughPortal,
+            portal_size: this.settings.portalSize,
+            portal_edge_color: this.settings.portalEdgeColor,
+            portal_edge_width: this.settings.portalEdgeWidth
+          }
+        };
+  
+        const message: UpdateSettingsMessage = {
+          type: 'updateSettings',
+          data: {
+            settings: serverSettings
+          }
+        };
+  
+        this.webSocket.send(message);
+        logger.log('Settings update sent to server');
       } catch (error) {
-        logger.error('Error in settings listener:', error);
+        logger.error('Error sending settings update:', error);
+        throw error;
       }
-    });
-  }
-
-  /**
-   * Add a settings update listener
-   */
-  addSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-    this.settingsListeners.add(listener);
-  }
-
-  /**
-   * Remove a settings update listener
-   */
-  removeSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-    this.settingsListeners.delete(listener);
-  }
-
-  /**
-   * Get current settings
-   */
-  getSettings(): VisualizationSettings {
-    return { ...this.settings };
-  }
-
-  /**
-   * Subscribe to settings changes
-   */
-  subscribe(listener: (settings: VisualizationSettings) => void): () => void {
-    this.settingsListeners.add(listener);
-    return () => {
-      this.settingsListeners.delete(listener);
-    };
-  }
-
-  /**
-   * Reset settings to defaults
-   */
-  resetToDefaults(): void {
-    this.updateSettings(DEFAULT_VISUALIZATION_SETTINGS);
-  }
-
-  /**
-   * Clean up resources
-   */
-  dispose(): void {
-    if (this.webSocket) {
-      // Remove WebSocket listeners
-      this.webSocket.off('settingsUpdated', this.notifyListeners);
-      this.webSocket = null;
     }
-    // Clear all listeners
-    this.settingsListeners.clear();
-    SettingsManager.instance = null;
-  }
-
-  public getThreeJSSettings() {
-    return {
-      nodes: {
-        size: this.settings.nodeSize,
-        color: this.settings.nodeColor,
-        opacity: this.settings.nodeOpacity,
-        metalness: this.settings.metalness,
-        roughness: this.settings.roughness,
-        clearcoat: this.settings.clearcoat,
-        highlightColor: '#FFFFFF' // Default highlight color
-      },
-      edges: {
-        width: this.settings.edgeWidth,
-        color: this.settings.edgeColor,
-        opacity: this.settings.edgeOpacity,
-        arrows: {
-          enabled: this.settings.enableArrows,
-          size: this.settings.arrowSize
-        }
-      },
-      bloom: {
-        enabled: this.settings.enableBloom,
-        intensity: this.settings.bloomIntensity,
-        radius: this.settings.bloomRadius
-      },
-      animations: {
-        enabled: this.settings.enableNodeAnimations,
-        motionBlur: {
-          enabled: this.settings.enableMotionBlur,
-          strength: this.settings.motionBlurStrength
-        }
-      },
-      labels: {
-        enabled: this.settings.showLabels,
-        size: this.settings.labelSize,
-        color: this.settings.labelColor
-      },
-      performance: {
-        maxFps: this.settings.maxFps
+  
+    updateSettings(newSettings: Partial<VisualizationSettings>): void {
+      this.settings = {
+        ...this.settings,
+        ...newSettings
+      };
+  
+      logger.log('Updated settings locally');
+      this.notifyListeners();
+      
+      if (this.webSocket) {
+        this.saveSettings().catch(error => {
+          logger.error('Failed to save settings to server:', error);
+        });
       }
-    };
-  }
-
-  // Essential setting getters
-  getNodeSettings(): {
-    size: number;
-    color: string;
-    opacity: number;
-    highlightColor: string;
-  } {
-    return {
-      size: this.settings.nodeSize,
-      color: this.settings.nodeColor,
-      opacity: this.settings.nodeOpacity,
-      highlightColor: '#FFFFFF' // Default highlight color
-    };
-  }
-
-  getEdgeSettings(): {
-    width: number;
-    color: string;
-    opacity: number;
-  } {
-    return {
-      width: this.settings.edgeWidth,
-      color: this.settings.edgeColor,
-      opacity: this.settings.edgeOpacity
-    };
-  }
-
-  getBloomSettings(): {
-    enabled: boolean;
-    intensity: number;
-    threshold: number;
-    radius: number;
-  } {
-    return {
-      enabled: this.settings.enableBloom,
-      intensity: this.settings.bloomIntensity,
-      threshold: 0.5, // Default threshold
-      radius: this.settings.bloomRadius
-    };
-  }
-
-  getLabelSettings(): {
-    show: boolean;
-    size: number;
-    color: string;
-  } {
-    return {
-      show: this.settings.showLabels,
-      size: this.settings.labelSize,
-      color: this.settings.labelColor
-    };
-  }
-
-  getXRSettings(): {
-    controllerVibration: boolean;
-    hapticIntensity: number;
-  } {
-    return {
-      controllerVibration: false, // Default controller vibration
-      hapticIntensity: 0.5 // Default haptic intensity
-    };
-  }
-
-  getPerformanceSettings(): {
-    maxFps: number;
-    updateThrottle: number;
-  } {
-    return {
-      maxFps: this.settings.maxFps,
-      updateThrottle: 0 // Default update throttle
-    };
-  }
+    }
+
+    private notifyListeners(): void {
+        this.settingsListeners.forEach(listener => {
+            try {
+                listener(this.settings);
+            } catch (error) {
+                logger.error('Error in settings listener:', error);
+            }
+        });
+    }
+
+    private notifyConnectionListeners(): void {
+        this.connectionListeners.forEach(listener => {
+            try {
+                listener(this.connected);
+            } catch (error) {
+                logger.error('Error in connection listener:', error);
+            }
+        });
+    }
+
+    private flattenSettings(serverSettings: ServerSettings): VisualizationSettings {
+        return {
+            // Node settings
+            nodeSize: serverSettings.nodes.base_size,
+            nodeColor: serverSettings.nodes.base_color,
+            nodeOpacity: serverSettings.nodes.opacity,
+            metalness: serverSettings.nodes.metalness,
+            roughness: serverSettings.nodes.roughness,
+            clearcoat: serverSettings.nodes.clearcoat,
+            enableInstancing: serverSettings.nodes.enable_instancing,
+            materialType: serverSettings.nodes.material_type,
+            sizeRange: serverSettings.nodes.size_range,
+            sizeByConnections: serverSettings.nodes.size_by_connections,
+            highlightColor: serverSettings.nodes.highlight_color,
+            highlightDuration: serverSettings.nodes.highlight_duration,
+            enableHoverEffect: serverSettings.nodes.enable_hover_effect,
+            hoverScale: serverSettings.nodes.hover_scale,
+
+            // Edge settings
+            edgeWidth: serverSettings.edges.base_width,
+            edgeColor: serverSettings.edges.color,
+            edgeOpacity: serverSettings.edges.opacity,
+            edgeWidthRange: serverSettings.edges.width_range,
+            enableArrows: serverSettings.edges.enable_arrows,
+            arrowSize: serverSettings.edges.arrow_size,
+
+            // Physics settings
+            physicsEnabled: serverSettings.physics.enabled,
+            attractionStrength: serverSettings.physics.attraction_strength,
+            repulsionStrength: serverSettings.physics.repulsion_strength,
+            springStrength: serverSettings.physics.spring_strength,
+            damping: serverSettings.physics.damping,
+            maxVelocity: serverSettings.physics.max_velocity,
+            collisionRadius: serverSettings.physics.collision_radius,
+            boundsSize: serverSettings.physics.bounds_size,
+            enableBounds: serverSettings.physics.enable_bounds,
+            iterations: serverSettings.physics.iterations,
+
+            // Rendering settings
+            ambientLightIntensity: serverSettings.rendering.ambient_light_intensity,
+            directionalLightIntensity: serverSettings.rendering.directional_light_intensity,
+            environmentIntensity: serverSettings.rendering.environment_intensity,
+            enableAmbientOcclusion: serverSettings.rendering.enable_ambient_occlusion,
+            enableAntialiasing: serverSettings.rendering.enable_antialiasing,
+            enableShadows: serverSettings.rendering.enable_shadows,
+            backgroundColor: serverSettings.rendering.background_color,
+
+            // Bloom settings
+            enableBloom: serverSettings.bloom.enabled,
+            bloomIntensity: serverSettings.bloom.strength,
+            bloomRadius: serverSettings.bloom.radius,
+            nodeBloomStrength: serverSettings.bloom.node_bloom_strength,
+            edgeBloomStrength: serverSettings.bloom.edge_bloom_strength,
+            environmentBloomStrength: serverSettings.bloom.environment_bloom_strength,
+
+            // Animation settings
+            enableNodeAnimations: serverSettings.animations.enable_node_animations,
+            enableMotionBlur: serverSettings.animations.enable_motion_blur,
+            motionBlurStrength: serverSettings.animations.motion_blur_strength,
+
+            // Label settings
+            showLabels: serverSettings.labels.enable_labels,
+            labelSize: serverSettings.labels.desktop_font_size / 48,
+            labelColor: serverSettings.labels.text_color,
+
+            // Performance settings
+            maxFps: this.settings.maxFps, // Not in server settings
+
+            // AR settings
+            enablePlaneDetection: serverSettings.ar.enable_plane_detection,
+            enableSceneUnderstanding: serverSettings.ar.enable_scene_understanding,
+            showPlaneOverlay: serverSettings.ar.show_plane_overlay,
+            planeOpacity: serverSettings.ar.plane_opacity,
+            planeColor: serverSettings.ar.plane_color,
+            enableLightEstimation: serverSettings.ar.enable_light_estimation,
+            enableHandTracking: serverSettings.ar.enable_hand_tracking,
+            handMeshEnabled: serverSettings.ar.hand_mesh_enabled,
+            handMeshColor: serverSettings.ar.hand_mesh_color,
+            handMeshOpacity: serverSettings.ar.hand_mesh_opacity,
+            handRayEnabled: serverSettings.ar.hand_ray_enabled,
+            handRayColor: serverSettings.ar.hand_ray_color,
+            handRayWidth: serverSettings.ar.hand_ray_width,
+            handPointSize: serverSettings.ar.hand_point_size,
+            gestureSmoothing: serverSettings.ar.gesture_smoothing,
+            pinchThreshold: serverSettings.ar.pinch_threshold,
+            dragThreshold: serverSettings.ar.drag_threshold,
+            rotationThreshold: serverSettings.ar.rotation_threshold,
+            enableHaptics: serverSettings.ar.enable_haptics,
+            hapticIntensity: serverSettings.ar.haptic_intensity,
+            roomScale: serverSettings.ar.room_scale,
+            snapToFloor: serverSettings.ar.snap_to_floor,
+            passthroughOpacity: serverSettings.ar.passthrough_opacity,
+            passthroughBrightness: serverSettings.ar.passthrough_brightness,
+            passthroughContrast: serverSettings.ar.passthrough_contrast,
+            enablePassthroughPortal: serverSettings.ar.enable_passthrough_portal,
+            portalSize: serverSettings.ar.portal_size,
+            portalEdgeColor: serverSettings.ar.portal_edge_color,
+            portalEdgeWidth: serverSettings.ar.portal_edge_width
+        };
+    }
+
+    addSettingsListener(listener: (settings: VisualizationSettings) => void): void {
+        this.settingsListeners.add(listener);
+    }
+
+    removeSettingsListener(listener: (settings: VisualizationSettings) => void): void {
+        this.settingsListeners.delete(listener);
+    }
+
+    getSettings(): VisualizationSettings {
+        return { ...this.settings };
+    }
+
+    subscribe(listener: (settings: VisualizationSettings) => void): () => void {
+        this.settingsListeners.add(listener);
+        return () => {
+            this.settingsListeners.delete(listener);
+        };
+    }
+
+    resetToDefaults(): void {
+        this.updateSettings(DEFAULT_VISUALIZATION_SETTINGS);
+    }
+
+    dispose(): void {
+        if (this.webSocket) {
+            this.webSocket.off('settingsUpdated', this.notifyListeners);
+            this.webSocket = null;
+        }
+        this.settingsListeners.clear();
+        SettingsManager.instance = null;
+    }
+
+    public getThreeJSSettings() {
+        return {
+            nodes: {
+                size: this.settings.nodeSize,
+                color: this.settings.nodeColor,
+                opacity: this.settings.nodeOpacity,
+                metalness: this.settings.metalness,
+                roughness: this.settings.roughness,
+                clearcoat: this.settings.clearcoat,
+                highlightColor: this.settings.highlightColor
+            },
+            edges: {
+                width: this.settings.edgeWidth,
+                color: this.settings.edgeColor,
+                opacity: this.settings.edgeOpacity,
+                widthRange: this.settings.edgeWidthRange,
+                arrows: {
+                    enabled: this.settings.enableArrows,
+                    size: this.settings.arrowSize
+                }
+            },
+            bloom: {
+                enabled: this.settings.enableBloom,
+                intensity: this.settings.bloomIntensity,
+                radius: this.settings.bloomRadius,
+                nodeStrength: this.settings.nodeBloomStrength,
+                edgeStrength: this.settings.edgeBloomStrength,
+                environmentStrength: this.settings.environmentBloomStrength
+            },
+            rendering: {
+                ambientLightIntensity: this.settings.ambientLightIntensity,
+                directionalLightIntensity: this.settings.directionalLightIntensity,
+                environmentIntensity: this.settings.environmentIntensity,
+                backgroundColor: this.settings.backgroundColor
+            },
+            animations: {
+                enabled: this.settings.enableNodeAnimations,
+                motionBlur: {
+                    enabled: this.settings.enableMotionBlur,
+                    strength: this.settings.motionBlurStrength
+                }
+            },
+            labels: {
+                enabled: this.settings.showLabels,
+                size: this.settings.labelSize,
+                color: this.settings.labelColor
+            },
+            performance: {
+                maxFps: this.settings.maxFps
+            }
+        };
+    }
 }
 
-// Export singleton instance and initialization function
 export const settingsManager = SettingsManager.getInstance();
-
-export function initializeSettingsManager(webSocket: WebSocketService): void {
-  settingsManager.initializeWebSocket(webSocket);
-}
\ No newline at end of file
diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
index 389de53a..4fa7ef30 100644
--- a/client/ui/ControlPanel.css
+++ b/client/ui/ControlPanel.css
@@ -21,6 +21,9 @@
     padding: 12px 16px;
     background: rgba(0, 0, 0, 0.2);
     border-bottom: 1px solid rgba(255, 255, 255, 0.1);
+    position: sticky;
+    top: 0;
+    z-index: 2;
 }
 
 .control-panel-header h3 {
@@ -47,32 +50,49 @@
 
 .settings-group {
     margin-bottom: 24px;
+    padding: 16px;
+    background: rgba(0, 0, 0, 0.2);
+    border-radius: 6px;
+    border: 1px solid rgba(255, 255, 255, 0.05);
 }
 
 .settings-group h4 {
-    margin: 0 0 12px 0;
+    margin: 0 0 16px 0;
     font-size: 14px;
     color: #4a90e2;
     font-weight: 500;
+    display: flex;
+    align-items: center;
+    gap: 8px;
+    text-transform: uppercase;
+    letter-spacing: 0.5px;
 }
 
 .setting-item {
-    margin-bottom: 12px;
+    margin-bottom: 16px;
+    transition: opacity 0.3s ease;
+}
+
+.setting-item:last-child {
+    margin-bottom: 0;
 }
 
 .setting-item label {
     display: block;
-    margin-bottom: 4px;
+    margin-bottom: 6px;
     font-size: 12px;
     color: #ccc;
+    font-weight: 500;
 }
 
+/* Range inputs */
 .setting-item input[type="range"] {
     width: 100%;
     height: 4px;
     background: #333;
     border-radius: 2px;
     -webkit-appearance: none;
+    margin: 8px 0;
 }
 
 .setting-item input[type="range"]::-webkit-slider-thumb {
@@ -83,15 +103,18 @@
     border-radius: 50%;
     cursor: pointer;
     transition: background 0.2s;
+    border: 2px solid rgba(255, 255, 255, 0.1);
 }
 
 .setting-item input[type="range"]::-webkit-slider-thumb:hover {
     background: #357abd;
+    transform: scale(1.1);
 }
 
+/* Color inputs */
 .setting-item input[type="color"] {
     width: 100%;
-    height: 30px;
+    height: 36px;
     padding: 2px;
     border: 1px solid #444;
     background: #222;
@@ -99,38 +122,122 @@
     cursor: pointer;
 }
 
+/* Number inputs */
 .setting-item input[type="number"] {
     width: 100%;
-    padding: 6px;
+    padding: 8px 12px;
     border: 1px solid #444;
     background: #222;
     color: #fff;
     border-radius: 4px;
+    font-size: 13px;
 }
 
+/* Checkbox inputs */
 .setting-item input[type="checkbox"] {
-    margin-right: 8px;
+    position: relative;
+    width: 40px;
+    height: 20px;
+    -webkit-appearance: none;
+    background: #333;
+    border-radius: 10px;
+    cursor: pointer;
+    transition: 0.3s;
 }
 
-.setting-item.disabled {
-    opacity: 0.5;
-    pointer-events: none;
+.setting-item input[type="checkbox"]:checked {
+    background: #4a90e2;
+}
+
+.setting-item input[type="checkbox"]::before {
+    content: '';
+    position: absolute;
+    width: 16px;
+    height: 16px;
+    border-radius: 50%;
+    top: 2px;
+    left: 2px;
+    background: #fff;
+    transition: 0.3s;
 }
 
-.save-button {
+.setting-item input[type="checkbox"]:checked::before {
+    left: 22px;
+}
+
+/* Select inputs */
+.setting-item select {
     width: 100%;
-    padding: 8px 16px;
-    background: #4a90e2;
+    padding: 8px 12px;
+    border: 1px solid #444;
+    background: #222;
     color: #fff;
+    border-radius: 4px;
+    font-size: 13px;
+    cursor: pointer;
+    appearance: none;
+    -webkit-appearance: none;
+    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
+    background-repeat: no-repeat;
+    background-position: right 8px center;
+    background-size: 16px;
+    padding-right: 32px;
+}
+
+.setting-item select:focus {
+    outline: none;
+    border-color: #4a90e2;
+}
+
+/* Value display */
+.setting-value {
+    float: right;
+    color: #4a90e2;
+    font-size: 12px;
+    font-weight: 500;
+    background: rgba(74, 144, 226, 0.1);
+    padding: 2px 6px;
+    border-radius: 3px;
+    min-width: 40px;
+    text-align: center;
+}
+
+/* Action buttons */
+.settings-actions {
+    display: flex;
+    gap: 12px;
+    margin-top: 24px;
+}
+
+.primary-button, .secondary-button {
+    flex: 1;
+    padding: 12px 16px;
     border: none;
     border-radius: 4px;
     cursor: pointer;
     font-size: 14px;
-    transition: background 0.2s;
+    font-weight: 500;
+    transition: all 0.2s ease;
+}
+
+.primary-button {
+    background: #4a90e2;
+    color: #fff;
 }
 
-.save-button:hover {
+.primary-button:hover {
     background: #357abd;
+    transform: translateY(-1px);
+}
+
+.secondary-button {
+    background: rgba(255, 255, 255, 0.1);
+    color: #fff;
+}
+
+.secondary-button:hover {
+    background: rgba(255, 255, 255, 0.15);
+    transform: translateY(-1px);
 }
 
 /* Custom scrollbar */
@@ -161,9 +268,79 @@
     animation: fadeIn 0.3s ease;
 }
 
+/* Expanded state */
+.control-panel:not(.expanded) .control-panel-content {
+    display: none;
+}
+
+.control-panel.expanded .toggle-button {
+    transform: rotate(180deg);
+}
+
 /* Responsive design */
 @media (max-width: 768px) {
     .control-panel {
         width: 280px;
     }
 }
+
+/* Tooltips */
+.setting-item label[data-tooltip] {
+    position: relative;
+    display: inline-flex;
+    align-items: center;
+}
+
+.setting-item label[data-tooltip]:hover::after {
+    content: attr(data-tooltip);
+    position: absolute;
+    left: 0;
+    top: 100%;
+    background: rgba(0, 0, 0, 0.9);
+    color: #fff;
+    padding: 6px 10px;
+    border-radius: 4px;
+    font-size: 11px;
+    white-space: nowrap;
+    z-index: 10;
+    pointer-events: none;
+    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+}
+
+/* Group headers */
+.settings-group h4::after {
+    content: '';
+    flex: 1;
+    height: 1px;
+    background: rgba(255, 255, 255, 0.1);
+    margin-left: 8px;
+}
+
+/* Disabled states */
+.setting-item.disabled {
+    opacity: 0.5;
+    pointer-events: none;
+}
+
+/* Sub-settings indentation */
+.sub-settings {
+    margin-left: 16px;
+    padding-left: 12px;
+    border-left: 2px solid rgba(74, 144, 226, 0.2);
+}
+
+/* Input focus states */
+.setting-item input:focus,
+.setting-item select:focus {
+    outline: none;
+    border-color: #4a90e2;
+}
+
+/* Hover effects */
+.setting-item:hover label {
+    color: #fff;
+}
+
+.setting-item:hover .setting-value {
+    background: rgba(74, 144, 226, 0.2);
+}
diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
index e59b53de..1cc6d5f2 100644
--- a/client/ui/ControlPanel.ts
+++ b/client/ui/ControlPanel.ts
@@ -1,3 +1,7 @@
+/**
+ * Control panel for visualization settings
+ */
+
 import { VisualizationSettings } from '../core/types';
 import { settingsManager } from '../state/settings';
 import { createLogger } from '../core/utils';
@@ -8,16 +12,80 @@ export class ControlPanel {
     private container: HTMLDivElement;
     private settings: VisualizationSettings;
     private isExpanded = false;
+    private feedbackTimeout: number | null = null;
+    private statusIndicator: HTMLDivElement;
     
     constructor() {
         this.container = document.createElement('div');
         this.container.className = 'control-panel';
         this.settings = { ...settingsManager.getSettings() };
+        
+        // Create status indicator
+        this.statusIndicator = document.createElement('div');
+        this.statusIndicator.className = 'connection-status';
+        this.container.appendChild(this.statusIndicator);
+        
         this.initializeUI();
         this.setupEventListeners();
         
         // Subscribe to settings updates
         settingsManager.addSettingsListener(this.onSettingsUpdate.bind(this));
+        
+        // Monitor WebSocket connection
+        this.monitorConnection();
+    }
+
+    private showFeedback(message: string, type: 'success' | 'error' = 'success'): void {
+        // Clear any existing feedback
+        if (this.feedbackTimeout) {
+            clearTimeout(this.feedbackTimeout);
+            const existingFeedback = this.container.querySelector('.settings-feedback');
+            if (existingFeedback) {
+                existingFeedback.remove();
+            }
+        }
+
+        // Create feedback element
+        const feedback = document.createElement('div');
+        feedback.className = `settings-feedback ${type}`;
+        feedback.textContent = message;
+
+        // Add to container before actions
+        const actionsGroup = this.container.querySelector('.settings-actions');
+        if (actionsGroup) {
+            actionsGroup.insertAdjacentElement('beforebegin', feedback);
+        }
+
+        // Auto-remove after delay
+        this.feedbackTimeout = window.setTimeout(() => {
+            feedback.classList.add('fade-out');
+            setTimeout(() => feedback.remove(), 300);
+            this.feedbackTimeout = null;
+        }, 3000);
+    }
+
+    private monitorConnection(): void {
+        const updateStatus = (connected: boolean) => {
+            this.statusIndicator.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
+            this.statusIndicator.title = connected ? 'Connected to server' : 'Disconnected from server';
+        };
+
+        // Initial status
+        updateStatus(settingsManager.isConnected());
+
+        // Listen for connection changes
+        settingsManager.onConnectionChange((connected) => {
+            updateStatus(connected);
+            if (!connected) {
+                this.showFeedback('Lost connection to server', 'error');
+            }
+        });
+    }
+
+    private onSettingsUpdate(newSettings: VisualizationSettings): void {
+        this.settings = { ...newSettings };
+        this.updateUIValues();
+        logger.log('Settings updated from external source');
     }
 
     private initializeUI(): void {
@@ -30,8 +98,9 @@ export class ControlPanel {
                 <div class="settings-group">
                     <h4>Node Appearance</h4>
                     <div class="setting-item">
-                        <label for="nodeSize">Base Size</label>
-                        <input type="range" id="nodeSize" min="0.1" max="2" step="0.1" value="${this.settings.nodeSize}">
+                        <label for="nodeSize">Node Size</label>
+                        <input type="range" id="nodeSize" min="0.05" max="2" step="0.05" value="${this.settings.nodeSize}">
+                        <span class="setting-value">${this.settings.nodeSize.toFixed(2)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="nodeColor">Color</label>
@@ -40,26 +109,64 @@ export class ControlPanel {
                     <div class="setting-item">
                         <label for="nodeOpacity">Opacity</label>
                         <input type="range" id="nodeOpacity" min="0" max="1" step="0.1" value="${this.settings.nodeOpacity}">
+                        <span class="setting-value">${this.settings.nodeOpacity.toFixed(1)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="metalness">Metalness</label>
                         <input type="range" id="metalness" min="0" max="1" step="0.05" value="${this.settings.metalness}">
+                        <span class="setting-value">${this.settings.metalness.toFixed(2)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="roughness">Roughness</label>
                         <input type="range" id="roughness" min="0" max="1" step="0.05" value="${this.settings.roughness}">
+                        <span class="setting-value">${this.settings.roughness.toFixed(2)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="clearcoat">Clearcoat</label>
                         <input type="range" id="clearcoat" min="0" max="1" step="0.1" value="${this.settings.clearcoat}">
+                        <span class="setting-value">${this.settings.clearcoat.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableInstancing">Enable Instancing</label>
+                        <input type="checkbox" id="enableInstancing" ${this.settings.enableInstancing ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="materialType">Material Type</label>
+                        <select id="materialType" value="${this.settings.materialType}">
+                            <option value="physical">Physical</option>
+                            <option value="basic">Basic</option>
+                            <option value="phong">Phong</option>
+                        </select>
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Node Highlight</h4>
+                    <div class="setting-item">
+                        <label for="highlightColor">Highlight Color</label>
+                        <input type="color" id="highlightColor" value="${this.settings.highlightColor}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="highlightDuration">Duration (ms)</label>
+                        <input type="number" id="highlightDuration" min="0" max="2000" step="100" value="${this.settings.highlightDuration}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableHoverEffect">Enable Hover</label>
+                        <input type="checkbox" id="enableHoverEffect" ${this.settings.enableHoverEffect ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="hoverScale">Hover Scale</label>
+                        <input type="range" id="hoverScale" min="1" max="2" step="0.1" value="${this.settings.hoverScale}">
+                        <span class="setting-value">${this.settings.hoverScale.toFixed(1)}</span>
                     </div>
                 </div>
 
                 <div class="settings-group">
                     <h4>Edge Appearance</h4>
                     <div class="setting-item">
-                        <label for="edgeWidth">Width</label>
-                        <input type="range" id="edgeWidth" min="0.1" max="5" step="0.1" value="${this.settings.edgeWidth}">
+                        <label for="edgeWidth">Edge Width</label>
+                        <input type="range" id="edgeWidth" min="0.5" max="5" step="0.5" value="${this.settings.edgeWidth}">
+                        <span class="setting-value">${this.settings.edgeWidth.toFixed(1)}</span>
                     </div>
                     <div class="setting-item">
                         <label for="edgeColor">Color</label>
@@ -68,70 +175,145 @@ export class ControlPanel {
                     <div class="setting-item">
                         <label for="edgeOpacity">Opacity</label>
                         <input type="range" id="edgeOpacity" min="0" max="1" step="0.1" value="${this.settings.edgeOpacity}">
+                        <span class="setting-value">${this.settings.edgeOpacity.toFixed(1)}</span>
                     </div>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableArrows" ${this.settings.enableArrows ? 'checked' : ''}>
-                            Show Arrows
-                        </label>
+                        <label for="enableArrows">Enable Arrows</label>
+                        <input type="checkbox" id="enableArrows" ${this.settings.enableArrows ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item arrow-setting ${this.settings.enableArrows ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="arrowSize">Arrow Size</label>
-                        <input type="range" id="arrowSize" min="0.1" max="1" step="0.05" value="${this.settings.arrowSize}">
+                        <input type="range" id="arrowSize" min="0.05" max="0.5" step="0.05" value="${this.settings.arrowSize}">
+                        <span class="setting-value">${this.settings.arrowSize.toFixed(2)}</span>
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Physics Settings</h4>
+                    <div class="setting-item">
+                        <label for="physicsEnabled">Enable Physics</label>
+                        <input type="checkbox" id="physicsEnabled" ${this.settings.physicsEnabled ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="attractionStrength">Attraction</label>
+                        <input type="range" id="attractionStrength" min="0" max="0.05" step="0.001" value="${this.settings.attractionStrength}">
+                        <span class="setting-value">${this.settings.attractionStrength.toFixed(3)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="repulsionStrength">Repulsion</label>
+                        <input type="range" id="repulsionStrength" min="0" max="3000" step="100" value="${this.settings.repulsionStrength}">
+                        <span class="setting-value">${this.settings.repulsionStrength.toFixed(0)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="springStrength">Spring</label>
+                        <input type="range" id="springStrength" min="0" max="0.05" step="0.001" value="${this.settings.springStrength}">
+                        <span class="setting-value">${this.settings.springStrength.toFixed(3)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="damping">Damping</label>
+                        <input type="range" id="damping" min="0" max="1" step="0.01" value="${this.settings.damping}">
+                        <span class="setting-value">${this.settings.damping.toFixed(2)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="maxVelocity">Max Velocity</label>
+                        <input type="range" id="maxVelocity" min="0.5" max="5" step="0.5" value="${this.settings.maxVelocity}">
+                        <span class="setting-value">${this.settings.maxVelocity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="collisionRadius">Collision Radius</label>
+                        <input type="range" id="collisionRadius" min="0.1" max="1" step="0.05" value="${this.settings.collisionRadius}">
+                        <span class="setting-value">${this.settings.collisionRadius.toFixed(2)}</span>
+                    </div>
+                </div>
+
+                <div class="settings-group">
+                    <h4>Lighting</h4>
+                    <div class="setting-item">
+                        <label for="ambientLightIntensity">Ambient Light</label>
+                        <input type="range" id="ambientLightIntensity" min="0" max="2" step="0.1" value="${this.settings.ambientLightIntensity}">
+                        <span class="setting-value">${this.settings.ambientLightIntensity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="directionalLightIntensity">Directional Light</label>
+                        <input type="range" id="directionalLightIntensity" min="0" max="2" step="0.1" value="${this.settings.directionalLightIntensity}">
+                        <span class="setting-value">${this.settings.directionalLightIntensity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="environmentIntensity">Environment</label>
+                        <input type="range" id="environmentIntensity" min="0" max="2" step="0.1" value="${this.settings.environmentIntensity}">
+                        <span class="setting-value">${this.settings.environmentIntensity.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="backgroundColor">Background Color</label>
+                        <input type="color" id="backgroundColor" value="${this.settings.backgroundColor}">
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableAmbientOcclusion">Ambient Occlusion</label>
+                        <input type="checkbox" id="enableAmbientOcclusion" ${this.settings.enableAmbientOcclusion ? 'checked' : ''}>
+                    </div>
+                    <div class="setting-item">
+                        <label for="enableShadows">Enable Shadows</label>
+                        <input type="checkbox" id="enableShadows" ${this.settings.enableShadows ? 'checked' : ''}>
                     </div>
                 </div>
 
                 <div class="settings-group">
                     <h4>Visual Effects</h4>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableBloom" ${this.settings.enableBloom ? 'checked' : ''}>
-                            Enable Bloom
-                        </label>
+                        <label for="enableBloom">Enable Bloom</label>
+                        <input type="checkbox" id="enableBloom" ${this.settings.enableBloom ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="bloomIntensity">Bloom Intensity</label>
-                        <input type="range" id="bloomIntensity" min="0" max="2" step="0.1" value="${this.settings.bloomIntensity}">
+                        <input type="range" id="bloomIntensity" min="0" max="3" step="0.1" value="${this.settings.bloomIntensity}">
+                        <span class="setting-value">${this.settings.bloomIntensity.toFixed(1)}</span>
                     </div>
-                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="bloomRadius">Bloom Radius</label>
-                        <input type="range" id="bloomRadius" min="0" max="2" step="0.1" value="${this.settings.bloomRadius}">
+                        <input type="range" id="bloomRadius" min="0" max="1" step="0.1" value="${this.settings.bloomRadius}">
+                        <span class="setting-value">${this.settings.bloomRadius.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="nodeBloomStrength">Node Bloom</label>
+                        <input type="range" id="nodeBloomStrength" min="0" max="1" step="0.1" value="${this.settings.nodeBloomStrength}">
+                        <span class="setting-value">${this.settings.nodeBloomStrength.toFixed(1)}</span>
+                    </div>
+                    <div class="setting-item">
+                        <label for="edgeBloomStrength">Edge Bloom</label>
+                        <input type="range" id="edgeBloomStrength" min="0" max="1" step="0.1" value="${this.settings.edgeBloomStrength}">
+                        <span class="setting-value">${this.settings.edgeBloomStrength.toFixed(1)}</span>
                     </div>
                 </div>
 
                 <div class="settings-group">
-                    <h4>Animations</h4>
+                    <h4>Motion & Animation</h4>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableNodeAnimations" ${this.settings.enableNodeAnimations ? 'checked' : ''}>
-                            Node Animations
-                        </label>
+                        <label for="enableNodeAnimations">Node Animations</label>
+                        <input type="checkbox" id="enableNodeAnimations" ${this.settings.enableNodeAnimations ? 'checked' : ''}>
                     </div>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="enableMotionBlur" ${this.settings.enableMotionBlur ? 'checked' : ''}>
-                            Motion Blur
-                        </label>
+                        <label for="enableMotionBlur">Motion Blur</label>
+                        <input type="checkbox" id="enableMotionBlur" ${this.settings.enableMotionBlur ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item motion-setting ${this.settings.enableMotionBlur ? '' : 'disabled'}">
-                        <label for="motionBlurStrength">Motion Blur Strength</label>
+                    <div class="setting-item">
+                        <label for="motionBlurStrength">Blur Strength</label>
                         <input type="range" id="motionBlurStrength" min="0" max="1" step="0.1" value="${this.settings.motionBlurStrength}">
+                        <span class="setting-value">${this.settings.motionBlurStrength.toFixed(1)}</span>
                     </div>
                 </div>
 
                 <div class="settings-group">
                     <h4>Labels</h4>
                     <div class="setting-item">
-                        <label>
-                            <input type="checkbox" id="showLabels" ${this.settings.showLabels ? 'checked' : ''}>
-                            Show Labels
-                        </label>
+                        <label for="showLabels">Show Labels</label>
+                        <input type="checkbox" id="showLabels" ${this.settings.showLabels ? 'checked' : ''}>
                     </div>
-                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="labelSize">Label Size</label>
                         <input type="range" id="labelSize" min="0.5" max="2" step="0.1" value="${this.settings.labelSize}">
+                        <span class="setting-value">${this.settings.labelSize.toFixed(1)}</span>
                     </div>
-                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
+                    <div class="setting-item">
                         <label for="labelColor">Label Color</label>
                         <input type="color" id="labelColor" value="${this.settings.labelColor}">
                     </div>
@@ -141,176 +323,18 @@ export class ControlPanel {
                     <h4>Performance</h4>
                     <div class="setting-item">
                         <label for="maxFps">Max FPS</label>
-                        <input type="number" id="maxFps" min="30" max="144" value="${this.settings.maxFps}">
+                        <input type="number" id="maxFps" min="30" max="144" step="1" value="${this.settings.maxFps}">
                     </div>
-                </div>
-
-                <div class="settings-group">
-                    <h4>AR Settings</h4>
-                    <div class="setting-item">
-                        <label>Scene Understanding</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enablePlaneDetection" ${this.settings.enablePlaneDetection ? 'checked' : ''}>
-                                    Plane Detection
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableSceneUnderstanding" ${this.settings.enableSceneUnderstanding ? 'checked' : ''}>
-                                    Scene Understanding
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="showPlaneOverlay" ${this.settings.showPlaneOverlay ? 'checked' : ''}>
-                                    Show Plane Overlay
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="planeOpacity">Plane Opacity</label>
-                                <input type="range" id="planeOpacity" min="0" max="1" step="0.1" value="${this.settings.planeOpacity}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="planeColor">Plane Color</label>
-                                <input type="color" id="planeColor" value="${this.settings.planeColor}">
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableLightEstimation" ${this.settings.enableLightEstimation ? 'checked' : ''}>
-                                    Light Estimation
-                                </label>
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Hand Tracking</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableHandTracking" ${this.settings.enableHandTracking ? 'checked' : ''}>
-                                    Enable Hand Tracking
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="handMeshEnabled" ${this.settings.handMeshEnabled ? 'checked' : ''}>
-                                    Show Hand Mesh
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="handMeshColor">Hand Mesh Color</label>
-                                <input type="color" id="handMeshColor" value="${this.settings.handMeshColor}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="handMeshOpacity">Hand Mesh Opacity</label>
-                                <input type="range" id="handMeshOpacity" min="0" max="1" step="0.1" value="${this.settings.handMeshOpacity}">
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="handRayEnabled" ${this.settings.handRayEnabled ? 'checked' : ''}>
-                                    Show Hand Ray
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="handRayColor">Hand Ray Color</label>
-                                <input type="color" id="handRayColor" value="${this.settings.handRayColor}">
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Gesture Controls</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label for="gestureSmoothing">Gesture Smoothing</label>
-                                <input type="range" id="gestureSmoothing" min="0" max="1" step="0.1" value="${this.settings.gestureSmoothing}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="pinchThreshold">Pinch Threshold</label>
-                                <input type="range" id="pinchThreshold" min="0" max="0.05" step="0.001" value="${this.settings.pinchThreshold}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="dragThreshold">Drag Threshold</label>
-                                <input type="range" id="dragThreshold" min="0" max="0.1" step="0.01" value="${this.settings.dragThreshold}">
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Haptics</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enableHaptics" ${this.settings.enableHaptics ? 'checked' : ''}>
-                                    Enable Haptics
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label for="hapticIntensity">Haptic Intensity</label>
-                                <input type="range" id="hapticIntensity" min="0" max="1" step="0.1" value="${this.settings.hapticIntensity}">
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Room Scale</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="roomScale" ${this.settings.roomScale ? 'checked' : ''}>
-                                    Room Scale Mode
-                                </label>
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="snapToFloor" ${this.settings.snapToFloor ? 'checked' : ''}>
-                                    Snap to Floor
-                                </label>
-                            </div>
-                        </div>
-                    </div>
-
-                    <div class="setting-item">
-                        <label>Passthrough</label>
-                        <div class="sub-settings">
-                            <div class="setting-item">
-                                <label for="passthroughOpacity">Opacity</label>
-                                <input type="range" id="passthroughOpacity" min="0" max="1" step="0.1" value="${this.settings.passthroughOpacity}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="passthroughBrightness">Brightness</label>
-                                <input type="range" id="passthroughBrightness" min="0" max="2" step="0.1" value="${this.settings.passthroughBrightness}">
-                            </div>
-                            <div class="setting-item">
-                                <label for="passthroughContrast">Contrast</label>
-                                <input type="range" id="passthroughContrast" min="0" max="2" step="0.1" value="${this.settings.passthroughContrast}">
-                            </div>
-                            <div class="setting-item">
-                                <label>
-                                    <input type="checkbox" id="enablePassthroughPortal" ${this.settings.enablePassthroughPortal ? 'checked' : ''}>
-                                    Enable Portal
-                                </label>
-                            </div>
-                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-                                <label for="portalSize">Portal Size</label>
-                                <input type="range" id="portalSize" min="0.1" max="2" step="0.1" value="${this.settings.portalSize}">
-                            </div>
-                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-                                <label for="portalEdgeColor">Portal Edge Color</label>
-                                <input type="color" id="portalEdgeColor" value="${this.settings.portalEdgeColor}">
-                            </div>
-                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-                                <label for="portalEdgeWidth">Portal Edge Width</label>
-                                <input type="range" id="portalEdgeWidth" min="0.001" max="0.05" step="0.001" value="${this.settings.portalEdgeWidth}">
-                            </div>
-                        </div>
+                    <div class="setting-item">
+                        <label for="enableAntialiasing">Antialiasing</label>
+                        <input type="checkbox" id="enableAntialiasing" ${this.settings.enableAntialiasing ? 'checked' : ''}>
                     </div>
                 </div>
 
-                <button class="save-button">Save Changes</button>
+                <div class="settings-actions">
+                    <button id="saveSettings" class="primary-button">Save Settings</button>
+                    <button id="resetSettings" class="secondary-button">Reset to Defaults</button>
+                </div>
             </div>
         `;
 
@@ -326,190 +350,200 @@ export class ControlPanel {
         });
 
         // Save button
-        const saveButton = this.container.querySelector('.save-button');
-        saveButton?.addEventListener('click', this.saveSettings.bind(this));
-
-        // Node settings
-        this.setupInputListener('nodeSize', 'number');
-        this.setupInputListener('nodeColor', 'string');
-        this.setupInputListener('nodeOpacity', 'number');
-        this.setupInputListener('metalness', 'number');
-        this.setupInputListener('roughness', 'number');
-        this.setupInputListener('clearcoat', 'number');
+        const saveButton = this.container.querySelector('#saveSettings');
+        saveButton?.addEventListener('click', () => this.saveSettings());
+
+        // Reset button
+        const resetButton = this.container.querySelector('#resetSettings');
+        resetButton?.addEventListener('click', () => this.resetSettings());
+
+        // Node appearance settings
+        this.setupRangeListener('nodeSize', 'nodeSize');
+        this.setupColorListener('nodeColor', 'nodeColor');
+        this.setupRangeListener('nodeOpacity', 'nodeOpacity');
+        this.setupRangeListener('metalness', 'metalness');
+        this.setupRangeListener('roughness', 'roughness');
+        this.setupRangeListener('clearcoat', 'clearcoat');
+        this.setupCheckboxListener('enableInstancing', 'enableInstancing');
+        this.setupSelectListener('materialType', 'materialType');
+
+        // Node highlight settings
+        this.setupColorListener('highlightColor', 'highlightColor');
+        this.setupNumberListener('highlightDuration', 'highlightDuration');
+        this.setupCheckboxListener('enableHoverEffect', 'enableHoverEffect');
+        this.setupRangeListener('hoverScale', 'hoverScale');
 
         // Edge settings
-        this.setupInputListener('edgeWidth', 'number');
-        this.setupInputListener('edgeColor', 'string');
-        this.setupInputListener('edgeOpacity', 'number');
-        
-        const arrowsCheckbox = this.container.querySelector('#enableArrows') as HTMLInputElement;
-        arrowsCheckbox?.addEventListener('change', () => {
-            const arrowSettings = this.container.querySelectorAll('.arrow-setting');
-            arrowSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !arrowsCheckbox.checked);
-            });
-            this.settings.enableArrows = arrowsCheckbox.checked;
-        });
-        this.setupInputListener('arrowSize', 'number');
-
-        // Bloom settings
-        const bloomCheckbox = this.container.querySelector('#enableBloom') as HTMLInputElement;
-        bloomCheckbox?.addEventListener('change', () => {
-            const bloomSettings = this.container.querySelectorAll('.bloom-setting');
-            bloomSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !bloomCheckbox.checked);
-            });
-            this.settings.enableBloom = bloomCheckbox.checked;
-        });
-        this.setupInputListener('bloomIntensity', 'number');
-        this.setupInputListener('bloomRadius', 'number');
-
-        // Animation settings
-        const nodeAnimCheckbox = this.container.querySelector('#enableNodeAnimations') as HTMLInputElement;
-        nodeAnimCheckbox?.addEventListener('change', () => {
-            this.settings.enableNodeAnimations = nodeAnimCheckbox.checked;
-        });
-
-        const motionBlurCheckbox = this.container.querySelector('#enableMotionBlur') as HTMLInputElement;
-        motionBlurCheckbox?.addEventListener('change', () => {
-            const motionSettings = this.container.querySelectorAll('.motion-setting');
-            motionSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !motionBlurCheckbox.checked);
-            });
-            this.settings.enableMotionBlur = motionBlurCheckbox.checked;
-        });
-        this.setupInputListener('motionBlurStrength', 'number');
+        this.setupRangeListener('edgeWidth', 'edgeWidth');
+        this.setupColorListener('edgeColor', 'edgeColor');
+        this.setupRangeListener('edgeOpacity', 'edgeOpacity');
+        this.setupCheckboxListener('enableArrows', 'enableArrows');
+        this.setupRangeListener('arrowSize', 'arrowSize');
+
+        // Physics settings
+        this.setupCheckboxListener('physicsEnabled', 'physicsEnabled');
+        this.setupRangeListener('attractionStrength', 'attractionStrength');
+        this.setupRangeListener('repulsionStrength', 'repulsionStrength');
+        this.setupRangeListener('springStrength', 'springStrength');
+        this.setupRangeListener('damping', 'damping');
+        this.setupRangeListener('maxVelocity', 'maxVelocity');
+        this.setupRangeListener('collisionRadius', 'collisionRadius');
+
+        // Lighting settings
+        this.setupRangeListener('ambientLightIntensity', 'ambientLightIntensity');
+        this.setupRangeListener('directionalLightIntensity', 'directionalLightIntensity');
+        this.setupRangeListener('environmentIntensity', 'environmentIntensity');
+        this.setupColorListener('backgroundColor', 'backgroundColor');
+        this.setupCheckboxListener('enableAmbientOcclusion', 'enableAmbientOcclusion');
+        this.setupCheckboxListener('enableShadows', 'enableShadows');
+
+        // Visual effects settings
+        this.setupCheckboxListener('enableBloom', 'enableBloom');
+        this.setupRangeListener('bloomIntensity', 'bloomIntensity');
+        this.setupRangeListener('bloomRadius', 'bloomRadius');
+        this.setupRangeListener('nodeBloomStrength', 'nodeBloomStrength');
+        this.setupRangeListener('edgeBloomStrength', 'edgeBloomStrength');
+
+        // Motion & animation settings
+        this.setupCheckboxListener('enableNodeAnimations', 'enableNodeAnimations');
+        this.setupCheckboxListener('enableMotionBlur', 'enableMotionBlur');
+        this.setupRangeListener('motionBlurStrength', 'motionBlurStrength');
 
         // Label settings
-        const labelCheckbox = this.container.querySelector('#showLabels') as HTMLInputElement;
-        labelCheckbox?.addEventListener('change', () => {
-            const labelSettings = this.container.querySelectorAll('.label-setting');
-            labelSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !labelCheckbox.checked);
-            });
-            this.settings.showLabels = labelCheckbox.checked;
-        });
-        this.setupInputListener('labelSize', 'number');
-        this.setupInputListener('labelColor', 'string');
+        this.setupCheckboxListener('showLabels', 'showLabels');
+        this.setupRangeListener('labelSize', 'labelSize');
+        this.setupColorListener('labelColor', 'labelColor');
 
         // Performance settings
-        this.setupInputListener('maxFps', 'number');
-
-        // AR settings
-        const planeDetectionCheckbox = this.container.querySelector('#enablePlaneDetection') as HTMLInputElement;
-        planeDetectionCheckbox?.addEventListener('change', () => {
-            this.settings.enablePlaneDetection = planeDetectionCheckbox.checked;
-        });
-
-        const sceneUnderstandingCheckbox = this.container.querySelector('#enableSceneUnderstanding') as HTMLInputElement;
-        sceneUnderstandingCheckbox?.addEventListener('change', () => {
-            this.settings.enableSceneUnderstanding = sceneUnderstandingCheckbox.checked;
-        });
-
-        const showPlaneOverlayCheckbox = this.container.querySelector('#showPlaneOverlay') as HTMLInputElement;
-        showPlaneOverlayCheckbox?.addEventListener('change', () => {
-            this.settings.showPlaneOverlay = showPlaneOverlayCheckbox.checked;
-        });
-
-        this.setupInputListener('planeOpacity', 'number');
-        this.setupInputListener('planeColor', 'string');
-
-        const lightEstimationCheckbox = this.container.querySelector('#enableLightEstimation') as HTMLInputElement;
-        lightEstimationCheckbox?.addEventListener('change', () => {
-            this.settings.enableLightEstimation = lightEstimationCheckbox.checked;
-        });
-
-        const handTrackingCheckbox = this.container.querySelector('#enableHandTracking') as HTMLInputElement;
-        handTrackingCheckbox?.addEventListener('change', () => {
-            this.settings.enableHandTracking = handTrackingCheckbox.checked;
-        });
-
-        const handMeshEnabledCheckbox = this.container.querySelector('#handMeshEnabled') as HTMLInputElement;
-        handMeshEnabledCheckbox?.addEventListener('change', () => {
-            this.settings.handMeshEnabled = handMeshEnabledCheckbox.checked;
-        });
-
-        this.setupInputListener('handMeshColor', 'string');
-        this.setupInputListener('handMeshOpacity', 'number');
-
-        const handRayEnabledCheckbox = this.container.querySelector('#handRayEnabled') as HTMLInputElement;
-        handRayEnabledCheckbox?.addEventListener('change', () => {
-            this.settings.handRayEnabled = handRayEnabledCheckbox.checked;
-        });
-
-        this.setupInputListener('handRayColor', 'string');
-
-        this.setupInputListener('gestureSmoothing', 'number');
-        this.setupInputListener('pinchThreshold', 'number');
-        this.setupInputListener('dragThreshold', 'number');
-
-        const hapticsCheckbox = this.container.querySelector('#enableHaptics') as HTMLInputElement;
-        hapticsCheckbox?.addEventListener('change', () => {
-            this.settings.enableHaptics = hapticsCheckbox.checked;
-        });
-
-        this.setupInputListener('hapticIntensity', 'number');
+        this.setupNumberListener('maxFps', 'maxFps');
+        this.setupCheckboxListener('enableAntialiasing', 'enableAntialiasing');
+    }
 
-        const roomScaleCheckbox = this.container.querySelector('#roomScale') as HTMLInputElement;
-        roomScaleCheckbox?.addEventListener('change', () => {
-            this.settings.roomScale = roomScaleCheckbox.checked;
-        });
+    private setupRangeListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('input', () => {
+                (this.settings[settingKey] as number) = parseFloat(element.value);
+                const valueDisplay = element.parentElement?.querySelector('.setting-value');
+                if (valueDisplay) {
+                    valueDisplay.textContent = parseFloat(element.value).toFixed(
+                        element.step.includes('.') ? element.step.split('.')[1].length : 0
+                    );
+                }
+                settingsManager.updateSettings(this.settings);
+            });
+        }
+    }
 
-        const snapToFloorCheckbox = this.container.querySelector('#snapToFloor') as HTMLInputElement;
-        snapToFloorCheckbox?.addEventListener('change', () => {
-            this.settings.snapToFloor = snapToFloorCheckbox.checked;
-        });
+    private setupColorListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('input', () => {
+                (this.settings[settingKey] as string) = element.value;
+                settingsManager.updateSettings(this.settings);
+            });
+        }
+    }
 
-        this.setupInputListener('passthroughOpacity', 'number');
-        this.setupInputListener('passthroughBrightness', 'number');
-        this.setupInputListener('passthroughContrast', 'number');
+    private setupCheckboxListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('change', () => {
+                (this.settings[settingKey] as boolean) = element.checked;
+                settingsManager.updateSettings(this.settings);
+            });
+        }
+    }
 
-        const passthroughPortalCheckbox = this.container.querySelector('#enablePassthroughPortal') as HTMLInputElement;
-        passthroughPortalCheckbox?.addEventListener('change', () => {
-            const portalSettings = this.container.querySelectorAll('.portal-setting');
-            portalSettings.forEach(setting => {
-                setting.classList.toggle('disabled', !passthroughPortalCheckbox.checked);
+    private setupNumberListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLInputElement;
+        if (element) {
+            element.addEventListener('input', () => {
+                (this.settings[settingKey] as number) = parseInt(element.value);
+                settingsManager.updateSettings(this.settings);
             });
-            this.settings.enablePassthroughPortal = passthroughPortalCheckbox.checked;
-        });
+        }
+    }
 
-        this.setupInputListener('portalSize', 'number');
-        this.setupInputListener('portalEdgeColor', 'string');
-        this.setupInputListener('portalEdgeWidth', 'number');
+    private setupSelectListener(elementId: string, settingKey: keyof VisualizationSettings): void {
+        const element = this.container.querySelector(`#${elementId}`) as HTMLSelectElement;
+        if (element) {
+            element.addEventListener('change', () => {
+                (this.settings[settingKey] as string) = element.value;
+                settingsManager.updateSettings(this.settings);
+            });
+        }
     }
 
-    private setupInputListener(id: string, type: 'number' | 'string'): void {
-        const input = this.container.querySelector(`#${id}`) as HTMLInputElement;
-        input?.addEventListener('input', () => {
-            const value = type === 'number' ? parseFloat(input.value) : input.value;
-            (this.settings as any)[id] = value;
+    private updateUIValues(): void {
+        // Update all input values to match current settings
+        Object.entries(this.settings).forEach(([key, value]) => {
+            const element = this.container.querySelector(`#${key}`) as HTMLInputElement | HTMLSelectElement;
+            if (element) {
+                if (element instanceof HTMLInputElement) {
+                    if (element.type === 'checkbox') {
+                        element.checked = value as boolean;
+                    } else if (element.type === 'range' || element.type === 'number') {
+                        element.value = value.toString();
+                        const valueDisplay = element.parentElement?.querySelector('.setting-value');
+                        if (valueDisplay) {
+                            valueDisplay.textContent = typeof value === 'number' 
+                                ? value.toFixed(element.step.includes('.') ? element.step.split('.')[1].length : 0)
+                                : value.toString();
+                        }
+                    } else {
+                        element.value = value as string;
+                    }
+                } else {
+                    element.value = value as string;
+                }
+            }
         });
     }
 
     private async saveSettings(): Promise<void> {
+        const saveButton = this.container.querySelector('#saveSettings') as HTMLButtonElement;
+        if (saveButton) {
+            saveButton.disabled = true;
+            saveButton.textContent = 'Saving...';
+        }
+
         try {
-            await settingsManager.updateSettings(this.settings);
+            await settingsManager.saveSettings();
+            this.showFeedback('Settings saved successfully');
             logger.log('Settings saved successfully');
         } catch (error) {
+            this.showFeedback('Failed to save settings', 'error');
             logger.error('Failed to save settings:', error);
+        } finally {
+            if (saveButton) {
+                saveButton.disabled = false;
+                saveButton.textContent = 'Save Settings';
+            }
         }
     }
 
-    private onSettingsUpdate(newSettings: VisualizationSettings): void {
-        this.settings = { ...newSettings };
-        this.updateUIValues();
-    }
+    private resetSettings(): void {
+        const resetButton = this.container.querySelector('#resetSettings') as HTMLButtonElement;
+        if (resetButton) {
+            resetButton.disabled = true;
+            resetButton.textContent = 'Resetting...';
+        }
 
-    private updateUIValues(): void {
-        Object.entries(this.settings).forEach(([key, value]) => {
-            const input = this.container.querySelector(`#${key}`) as HTMLInputElement;
-            if (input) {
-                if (input.type === 'checkbox') {
-                    input.checked = value as boolean;
-                } else {
-                    input.value = value.toString();
-                }
+        try {
+            settingsManager.resetToDefaults();
+            this.showFeedback('Settings reset to defaults');
+            logger.log('Settings reset to defaults');
+        } catch (error) {
+            this.showFeedback('Failed to reset settings', 'error');
+            logger.error('Failed to reset settings:', error);
+        } finally {
+            if (resetButton) {
+                resetButton.disabled = false;
+                resetButton.textContent = 'Reset to Defaults';
             }
-        });
+        }
     }
+
+    // ... [Rest of the code remains the same] ...
 }
diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
index ca0c93b1..9336136a 100644
--- a/client/websocket/websocketService.ts
+++ b/client/websocket/websocketService.ts
@@ -14,7 +14,6 @@ import {
   EnableBinaryUpdatesMessage,
   PingMessage,
   transformGraphData,
-  transformNodeData,
 } from '../core/types';
 import { WS_RECONNECT_INTERVAL, WS_MESSAGE_QUEUE_SIZE } from '../core/constants';
 import { createLogger } from '../core/utils';
@@ -244,15 +243,7 @@ export class WebSocketService {
       }
       case 'binaryPositionUpdate': {
         const binaryUpdate = rawMessage as RawBinaryPositionUpdateMessage;
-        const transformedData = {
-          type: 'binaryPositionUpdate' as const,
-          data: {
-            nodes: binaryUpdate.data.nodes.map(node => ({
-              nodeId: node.nodeId,
-              data: transformNodeData(node.data)
-            }))
-          }
-        };
+        const transformedData = this.transformBinaryData(binaryUpdate);
         this.handleBinaryUpdate(transformedData);
         break;
       }
@@ -268,6 +259,21 @@ export class WebSocketService {
     }
   }
 
+  private transformBinaryData(data: any): BinaryPositionUpdateMessage {
+    return {
+      type: 'binaryPositionUpdate',
+      data: {
+        nodes: data.nodes.map((node: any) => ({
+          nodeId: node.nodeId,
+          data: {
+            position: node.data.position,
+            velocity: node.data.velocity
+          }
+        }))
+      }
+    };
+  }
+
   private handleInitialData(message: InitialDataMessage): void {
     this.notifyHandlers('initialData', message.data);
     
diff --git a/diff.patch b/diff.patch
deleted file mode 100644
index 38d0c0b9..00000000
--- a/diff.patch
+++ /dev/null
@@ -1,2721 +0,0 @@
-diff --git a/client/core/NodeManager.ts b/client/core/NodeManager.ts
-new file mode 100644
-index 00000000..3086c172
---- /dev/null
-+++ b/client/core/NodeManager.ts
-@@ -0,0 +1,70 @@
-+import { Node, Vector3 } from './types';
-+import * as THREE from 'three';
-+import { SceneManager } from '../rendering/scene';
-+
-+export class NodeManager {
-+  private static instance: NodeManager | null = null;
-+  private nodeMatrices: Map<string, THREE.Matrix4> = new Map();
-+  private nodes: Map<string, Node> = new Map();
-+  private tempVector = new THREE.Vector3();
-+  private sceneManager: SceneManager;
-+
-+  private constructor(sceneManager: SceneManager) {
-+    this.sceneManager = sceneManager;
-+  }
-+
-+  public static getInstance(sceneManager: SceneManager): NodeManager {
-+    if (!NodeManager.instance) {
-+      NodeManager.instance = new NodeManager(sceneManager);
-+    }
-+    return NodeManager.instance;
-+  }
-+
-+  public addNode(node: Node): void {
-+    this.nodes.set(node.id, node);
-+    this.nodeMatrices.set(node.id, new THREE.Matrix4());
-+    this.updateNodePositionInternal(node.id, node.data.position);
-+  }
-+
-+  public removeNode(nodeId: string): void {
-+    this.nodes.delete(nodeId);
-+    this.nodeMatrices.delete(nodeId);
-+  }
-+
-+  public updateNodePositions(delta: Vector3): void {
-+    for (const node of this.nodes.values()) {
-+      const newPosition = {
-+        x: node.data.position.x + delta.x,
-+        y: node.data.position.y + delta.y,
-+        z: node.data.position.z + delta.z
-+      };
-+      this.updateNodePositionInternal(node.id, newPosition);
-+      node.data.position = newPosition;
-+    }
-+  }
-+
-+  private updateNodePositionInternal(nodeId: string, position: Vector3): void {
-+    const matrix = this.nodeMatrices.get(nodeId);
-+    if (matrix) {
-+      this.tempVector.set(position.x, position.y, position.z);
-+      matrix.identity();
-+      matrix.elements[12] = this.tempVector.x;
-+      matrix.elements[13] = this.tempVector.y;
-+      matrix.elements[14] = this.tempVector.z;
-+    }
-+  }
-+
-+  public getNodeMatrix(nodeId: string): THREE.Matrix4 | undefined {
-+    return this.nodeMatrices.get(nodeId);
-+  }
-+
-+  public getNodes(): Node[] {
-+    return Array.from(this.nodes.values());
-+  }
-+
-+  public dispose(): void {
-+    this.nodes.clear();
-+    this.nodeMatrices.clear();
-+    NodeManager.instance = null;
-+  }
-+}
-diff --git a/client/core/types.ts b/client/core/types.ts
-index b1512a69..86ecd1e6 100644
---- a/client/core/types.ts
-+++ b/client/core/types.ts
-@@ -99,31 +99,161 @@ export interface VisualizationSettings {
-   nodeSize: number;
-   nodeColor: string;
-   nodeOpacity: number;
--  nodeHighlightColor: string;
--  
-+  metalness: number;
-+  roughness: number;
-+  clearcoat: number;
-+
-   // Edge appearance
-   edgeWidth: number;
-   edgeColor: string;
-   edgeOpacity: number;
--  
-+  enableArrows: boolean;
-+  arrowSize: number;
-+
-   // Visual effects
-   enableBloom: boolean;
-   bloomIntensity: number;
--  bloomThreshold: number;
-   bloomRadius: number;
--  
--  // Performance
--  maxFps: number;
--  updateThrottle: number;
-+  enableNodeAnimations: boolean;
-+  enableMotionBlur: boolean;
-+  motionBlurStrength: number;
- 
-   // Labels
-   showLabels: boolean;
-   labelSize: number;
-   labelColor: string;
- 
--  // XR specific
--  xrControllerVibration: boolean;
--  xrControllerHapticIntensity: number;
-+  // Performance
-+  maxFps: number;
-+
-+  // AR Settings (Meta Quest 3)
-+  // Scene Understanding
-+  enablePlaneDetection: boolean;
-+  enableSceneUnderstanding: boolean;
-+  showPlaneOverlay: boolean;
-+  planeOpacity: number;
-+  planeColor: string;
-+  enableLightEstimation: boolean;
-+  
-+  // Hand Tracking
-+  enableHandTracking: boolean;
-+  handMeshEnabled: boolean;
-+  handMeshColor: string;
-+  handMeshOpacity: number;
-+  handRayEnabled: boolean;
-+  handRayColor: string;
-+  handRayWidth: number;
-+  handPointSize: number;
-+  
-+  // Gesture Controls
-+  gestureSmoothing: number;
-+  pinchThreshold: number;
-+  dragThreshold: number;
-+  rotationThreshold: number;
-+  
-+  // Haptics
-+  enableHaptics: boolean;
-+  hapticIntensity: number;
-+  
-+  // Room Scale
-+  roomScale: boolean;
-+  snapToFloor: boolean;
-+  
-+  // Passthrough
-+  passthroughOpacity: number;
-+  passthroughBrightness: number;
-+  passthroughContrast: number;
-+  enablePassthroughPortal: boolean;
-+  portalSize: number;
-+  portalEdgeColor: string;
-+  portalEdgeWidth: number;
-+}
-+
-+export interface BinaryNodeUpdate {
-+  nodeId: string;
-+  data: NodeData;
-+}
-+
-+export interface BinaryPositionUpdateMessage {
-+  type: 'binaryPositionUpdate';
-+  data: {
-+    nodes: BinaryNodeUpdate[];
-+  };
-+}
-+
-+// Other message types
-+export interface RequestInitialDataMessage {
-+  type: 'requestInitialData';
-+}
-+
-+export interface EnableBinaryUpdatesMessage {
-+  type: 'enableBinaryUpdates';
-+}
-+
-+export interface SettingsUpdateMessage {
-+  type: 'settingsUpdated';
-+  data: {
-+    settings: VisualizationSettings;
-+  };
-+}
-+
-+export interface UpdateSettingsMessage {
-+  type: 'updateSettings';
-+  data: {
-+    settings: Partial<VisualizationSettings>;
-+  };
-+}
-+
-+export interface PingMessage {
-+  type: 'ping';
-+}
-+
-+export interface PongMessage {
-+  type: 'pong';
-+}
-+
-+// Union types for messages
-+export type RawWebSocketMessage =
-+  | RawInitialDataMessage
-+  | RawBinaryPositionUpdateMessage
-+  | SettingsUpdateMessage
-+  | UpdateSettingsMessage
-+  | RequestInitialDataMessage
-+  | EnableBinaryUpdatesMessage
-+  | PingMessage
-+  | PongMessage;
-+
-+export type WebSocketMessage =
-+  | InitialDataMessage
-+  | BinaryPositionUpdateMessage
-+  | SettingsUpdateMessage
-+  | UpdateSettingsMessage
-+  | RequestInitialDataMessage
-+  | EnableBinaryUpdatesMessage
-+  | PingMessage
-+  | PongMessage;
-+
-+// Platform detection types
-+export type Platform = 'browser' | 'quest';
-+
-+export interface PlatformCapabilities {
-+  xrSupported: boolean;
-+  webglSupported: boolean;
-+  websocketSupported: boolean;
-+}
-+
-+// Message queue types
-+export interface QueuedMessage {
-+  data: ArrayBuffer;
-+  timestamp: number;
-+}
-+
-+// Debug types
-+export interface NetworkDebugMessage {
-+  direction: 'in' | 'out';
-+  type: 'binary' | 'json';
-+  timestamp: number;
-+  data: any;
- }
- 
- // Transform functions
-@@ -221,90 +351,3 @@ export interface InitialDataMessage {
-     graph: GraphData;
-   };
- }
--
--export interface BinaryNodeUpdate {
--  nodeId: string;
--  data: NodeData;
--}
--
--export interface BinaryPositionUpdateMessage {
--  type: 'binaryPositionUpdate';
--  data: {
--    nodes: BinaryNodeUpdate[];
--  };
--}
--
--// Other message types
--export interface RequestInitialDataMessage {
--  type: 'requestInitialData';
--}
--
--export interface EnableBinaryUpdatesMessage {
--  type: 'enableBinaryUpdates';
--}
--
--export interface SettingsUpdateMessage {
--  type: 'settingsUpdated';
--data: {
--    settings: VisualizationSettings;
--  };
--}
--
--export interface UpdateSettingsMessage {
--  type: 'updateSettings';
--data: {
--    settings: Partial<VisualizationSettings>;
--  };
--}
--
--export interface PingMessage {
--  type: 'ping';
--}
--
--export interface PongMessage {
--  type: 'pong';
--}
--
--// Union types for messages
--export type RawWebSocketMessage =
--  | RawInitialDataMessage
--  | RawBinaryPositionUpdateMessage
--  | SettingsUpdateMessage
--  | UpdateSettingsMessage
--  | RequestInitialDataMessage
--  | EnableBinaryUpdatesMessage
--  | PingMessage
--  | PongMessage;
--
--export type WebSocketMessage =
--  | InitialDataMessage
--  | BinaryPositionUpdateMessage
--  | SettingsUpdateMessage
--  | UpdateSettingsMessage
--  | RequestInitialDataMessage
--  | EnableBinaryUpdatesMessage
--  | PingMessage
--  | PongMessage;
--
--// Platform detection types
--export type Platform = 'browser' | 'quest';
--
--export interface PlatformCapabilities {
--  xrSupported: boolean;
--  webglSupported: boolean;
--  websocketSupported: boolean;
--}
--
--// Message queue types
--export interface QueuedMessage {
--  data: ArrayBuffer;
--  timestamp: number;
--}
--
--// Debug types
--export interface NetworkDebugMessage {
--  direction: 'in' | 'out';
--  type: 'binary' | 'json';
--  timestamp: number;
--  data: any;
--}
-diff --git a/client/index.html b/client/index.html
-index 7caf56b9..d972fa1d 100644
---- a/client/index.html
-+++ b/client/index.html
-@@ -25,154 +25,12 @@
-       width: 100%;
-       height: 100%;
-     }
--
--    #settings-panel {
--      position: fixed;
--      top: 20px;
--      right: 20px;
--      background: rgba(0, 0, 0, 0.8);
--      padding: 20px;
--      border-radius: 8px;
--      z-index: 1000;
--      min-width: 300px;
--    }
--
--    .settings-group {
--      margin-bottom: 15px;
--    }
--
--    .settings-group h3 {
--      margin-bottom: 8px;
--      color: #4a90e2;
--    }
--
--    .setting-item {
--      margin-bottom: 8px;
--    }
--
--    label {
--      display: block;
--      margin-bottom: 4px;
--    }
--
--    input[type="number"],
--    input[type="color"] {
--      width: 100%;
--      padding: 4px;
--      border: 1px solid #666;
--      background: #333;
--      color: #fff;
--      border-radius: 4px;
--    }
--
--    button {
--      padding: 8px 16px;
--      background: #4a90e2;
--      color: #fff;
--      border: none;
--      border-radius: 4px;
--      cursor: pointer;
--      transition: background 0.2s;
--    }
--
--    button:hover {
--      background: #357abd;
--    }
--
--    #xr-button {
--      position: fixed;
--      bottom: 20px;
--      right: 20px;
--      z-index: 1000;
--    }
--
--    .loading-overlay {
--      position: fixed;
--      top: 0;
--      left: 0;
--      width: 100%;
--      height: 100%;
--      background: rgba(0, 0, 0, 0.8);
--      display: flex;
--      justify-content: center;
--      align-items: center;
--      z-index: 2000;
--    }
--
--    .loading-spinner {
--      width: 50px;
--      height: 50px;
--      border: 5px solid #f3f3f3;
--      border-top: 5px solid #4a90e2;
--      border-radius: 50%;
--      animation: spin 1s linear infinite;
--    }
--
--    @keyframes spin {
--      0% { transform: rotate(0deg); }
--      100% { transform: rotate(360deg); }
--    }
-   </style>
- </head>
- <body>
--  <div id="canvas-container"></div>
--
--  <div id="settings-panel">
--    <div class="settings-group">
--      <h3>Node Appearance</h3>
--      <div class="setting-item">
--        <label for="nodeSize">Node Size</label>
--        <input type="number" id="nodeSize" min="0.1" max="5" step="0.1" value="2.5">
--      </div>
--      <div class="setting-item">
--        <label for="nodeColor">Node Color</label>
--        <input type="color" id="nodeColor" value="#4CAF50">
--      </div>
--      <div class="setting-item">
--        <label for="nodeOpacity">Node Opacity</label>
--        <input type="number" id="nodeOpacity" min="0" max="1" step="0.1" value="0.7">
--      </div>
--    </div>
--
--    <div class="settings-group">
--      <h3>Edge Appearance</h3>
--      <div class="setting-item">
--        <label for="edgeWidth">Edge Width</label>
--        <input type="number" id="edgeWidth" min="0.1" max="5" step="0.1" value="0.25">
--      </div>
--      <div class="setting-item">
--        <label for="edgeColor">Edge Color</label>
--        <input type="color" id="edgeColor" value="#E0E0E0">
--      </div>
--      <div class="setting-item">
--        <label for="edgeOpacity">Edge Opacity</label>
--        <input type="number" id="edgeOpacity" min="0" max="1" step="0.1" value="0.7">
--      </div>
--    </div>
--
--    <div class="settings-group">
--      <h3>Visual Effects</h3>
--      <div class="setting-item">
--        <label>
--          <input type="checkbox" id="enableBloom" checked>
--          Enable Bloom
--        </label>
--      </div>
--      <div class="setting-item">
--        <label for="bloomIntensity">Bloom Intensity</label>
--        <input type="number" id="bloomIntensity" min="0" max="3" step="0.1" value="1.5">
--      </div>
--    </div>
--
--    <button id="save-settings">Save Settings</button>
-+  <div id="canvas-container">
-+    <canvas id="main-canvas"></canvas>
-   </div>
--
--  <button id="xr-button" style="display: none;">Enter AR</button>
--
--  <div class="loading-overlay">
--    <div class="loading-spinner"></div>
--  </div>
--
--  <script type="module" src="./index.ts"></script>
-+  <script type="module" src="/index.ts"></script>
- </body>
- </html>
-diff --git a/client/index.ts b/client/index.ts
-index 5dd884ce..c2a81e7f 100644
---- a/client/index.ts
-+++ b/client/index.ts
-@@ -14,6 +14,7 @@ import { XRInteraction } from './xr/xrInteraction';
- import { createLogger } from './core/utils';
- import { WS_URL } from './core/constants';
- import { BinaryNodeUpdate } from './core/types';
-+import { ControlPanel } from './ui';
- 
- const logger = createLogger('Application');
- 
-@@ -46,6 +47,9 @@ class Application {
-       // Initialize XR if supported
-       await this.initializeXR();
- 
-+      // Initialize UI components
-+      new ControlPanel(); // Create the control panel instance
-+
-       // Setup UI event listeners
-       this.setupUIEventListeners();
- 
-diff --git a/client/state/settings.ts b/client/state/settings.ts
-index 0e7c6f1b..ed6474c5 100644
---- a/client/state/settings.ts
-+++ b/client/state/settings.ts
-@@ -3,12 +3,86 @@
-  */
- 
- import { VisualizationSettings } from '../core/types';
--import { DEFAULT_VISUALIZATION_SETTINGS } from '../core/constants';
- import { createLogger } from '../core/utils';
- import { WebSocketService } from '../websocket/websocketService';
- 
- const logger = createLogger('SettingsManager');
- 
-+export const DEFAULT_VISUALIZATION_SETTINGS: VisualizationSettings = {
-+    // Node Appearance
-+    nodeSize: 0.2,
-+    nodeColor: '#FFB700',
-+    nodeOpacity: 0.92,
-+    metalness: 0.85,
-+    roughness: 0.15,
-+    clearcoat: 1.0,
-+
-+    // Edge Appearance
-+    edgeWidth: 2.0,
-+    edgeColor: '#FFD700',
-+    edgeOpacity: 0.6,
-+    enableArrows: true,
-+    arrowSize: 0.15,
-+
-+    // Visual Effects
-+    enableBloom: true,
-+    bloomIntensity: 1.8,
-+    bloomRadius: 0.5,
-+    enableNodeAnimations: true,
-+    enableMotionBlur: true,
-+    motionBlurStrength: 0.4,
-+
-+    // Labels
-+    showLabels: true,
-+    labelSize: 1.0,
-+    labelColor: '#FFFFFF',
-+
-+    // Performance
-+    maxFps: 60,
-+
-+    // AR Settings (Meta Quest 3)
-+    // Scene Understanding
-+    enablePlaneDetection: true,
-+    enableSceneUnderstanding: true,
-+    showPlaneOverlay: true,
-+    planeOpacity: 0.3,
-+    planeColor: '#4A90E2',
-+    enableLightEstimation: true,
-+    
-+    // Hand Tracking
-+    enableHandTracking: true,
-+    handMeshEnabled: true,
-+    handMeshColor: '#FFD700',
-+    handMeshOpacity: 0.3,
-+    handRayEnabled: true,
-+    handRayColor: '#FFD700',
-+    handRayWidth: 0.002,
-+    handPointSize: 0.01,
-+    
-+    // Gesture Controls
-+    gestureSmoothing: 0.9,
-+    pinchThreshold: 0.015,
-+    dragThreshold: 0.04,
-+    rotationThreshold: 0.08,
-+    
-+    // Haptics
-+    enableHaptics: true,
-+    hapticIntensity: 0.7,
-+    
-+    // Room Scale
-+    roomScale: true,
-+    snapToFloor: true,
-+    
-+    // Passthrough
-+    passthroughOpacity: 1.0,
-+    passthroughBrightness: 1.0,
-+    passthroughContrast: 1.0,
-+    enablePassthroughPortal: false,
-+    portalSize: 1.0,
-+    portalEdgeColor: '#FFD700',
-+    portalEdgeWidth: 0.02
-+};
-+
- export class SettingsManager {
-   private static instance: SettingsManager | null = null;
-   private settings: VisualizationSettings;
-@@ -106,6 +180,20 @@ export class SettingsManager {
-     });
-   }
- 
-+  /**
-+   * Add a settings update listener
-+   */
-+  addSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-+    this.settingsListeners.add(listener);
-+  }
-+
-+  /**
-+   * Remove a settings update listener
-+   */
-+  removeSettingsListener(listener: (settings: VisualizationSettings) => void): void {
-+    this.settingsListeners.delete(listener);
-+  }
-+
-   /**
-    * Get current settings
-    */
-@@ -144,6 +232,49 @@ export class SettingsManager {
-     SettingsManager.instance = null;
-   }
- 
-+  public getThreeJSSettings() {
-+    return {
-+      nodes: {
-+        size: this.settings.nodeSize,
-+        color: this.settings.nodeColor,
-+        opacity: this.settings.nodeOpacity,
-+        metalness: this.settings.metalness,
-+        roughness: this.settings.roughness,
-+        clearcoat: this.settings.clearcoat,
-+        highlightColor: '#FFFFFF' // Default highlight color
-+      },
-+      edges: {
-+        width: this.settings.edgeWidth,
-+        color: this.settings.edgeColor,
-+        opacity: this.settings.edgeOpacity,
-+        arrows: {
-+          enabled: this.settings.enableArrows,
-+          size: this.settings.arrowSize
-+        }
-+      },
-+      bloom: {
-+        enabled: this.settings.enableBloom,
-+        intensity: this.settings.bloomIntensity,
-+        radius: this.settings.bloomRadius
-+      },
-+      animations: {
-+        enabled: this.settings.enableNodeAnimations,
-+        motionBlur: {
-+          enabled: this.settings.enableMotionBlur,
-+          strength: this.settings.motionBlurStrength
-+        }
-+      },
-+      labels: {
-+        enabled: this.settings.showLabels,
-+        size: this.settings.labelSize,
-+        color: this.settings.labelColor
-+      },
-+      performance: {
-+        maxFps: this.settings.maxFps
-+      }
-+    };
-+  }
-+
-   // Essential setting getters
-   getNodeSettings(): {
-     size: number;
-@@ -155,7 +286,7 @@ export class SettingsManager {
-       size: this.settings.nodeSize,
-       color: this.settings.nodeColor,
-       opacity: this.settings.nodeOpacity,
--      highlightColor: this.settings.nodeHighlightColor
-+      highlightColor: '#FFFFFF' // Default highlight color
-     };
-   }
- 
-@@ -180,7 +311,7 @@ export class SettingsManager {
-     return {
-       enabled: this.settings.enableBloom,
-       intensity: this.settings.bloomIntensity,
--      threshold: this.settings.bloomThreshold,
-+      threshold: 0.5, // Default threshold
-       radius: this.settings.bloomRadius
-     };
-   }
-@@ -202,8 +333,8 @@ export class SettingsManager {
-     hapticIntensity: number;
-   } {
-     return {
--      controllerVibration: this.settings.xrControllerVibration,
--      hapticIntensity: this.settings.xrControllerHapticIntensity
-+      controllerVibration: false, // Default controller vibration
-+      hapticIntensity: 0.5 // Default haptic intensity
-     };
-   }
- 
-@@ -213,7 +344,7 @@ export class SettingsManager {
-   } {
-     return {
-       maxFps: this.settings.maxFps,
--      updateThrottle: this.settings.updateThrottle
-+      updateThrottle: 0 // Default update throttle
-     };
-   }
- }
-diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
-new file mode 100644
-index 00000000..389de53a
---- /dev/null
-+++ b/client/ui/ControlPanel.css
-@@ -0,0 +1,169 @@
-+.control-panel {
-+    position: fixed;
-+    top: 20px;
-+    right: 20px;
-+    background: rgba(0, 0, 0, 0.85);
-+    border-radius: 8px;
-+    color: #fff;
-+    font-family: Arial, sans-serif;
-+    width: 320px;
-+    max-height: 90vh;
-+    overflow-y: auto;
-+    transition: transform 0.3s ease;
-+    z-index: 1000;
-+    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
-+}
-+
-+.control-panel-header {
-+    display: flex;
-+    justify-content: space-between;
-+    align-items: center;
-+    padding: 12px 16px;
-+    background: rgba(0, 0, 0, 0.2);
-+    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
-+}
-+
-+.control-panel-header h3 {
-+    margin: 0;
-+    font-size: 16px;
-+    font-weight: 500;
-+}
-+
-+.toggle-button {
-+    background: none;
-+    border: none;
-+    color: #fff;
-+    font-size: 20px;
-+    cursor: pointer;
-+    padding: 4px 8px;
-+    transition: transform 0.3s ease;
-+}
-+
-+.control-panel-content {
-+    padding: 16px;
-+    max-height: calc(90vh - 50px);
-+    overflow-y: auto;
-+}
-+
-+.settings-group {
-+    margin-bottom: 24px;
-+}
-+
-+.settings-group h4 {
-+    margin: 0 0 12px 0;
-+    font-size: 14px;
-+    color: #4a90e2;
-+    font-weight: 500;
-+}
-+
-+.setting-item {
-+    margin-bottom: 12px;
-+}
-+
-+.setting-item label {
-+    display: block;
-+    margin-bottom: 4px;
-+    font-size: 12px;
-+    color: #ccc;
-+}
-+
-+.setting-item input[type="range"] {
-+    width: 100%;
-+    height: 4px;
-+    background: #333;
-+    border-radius: 2px;
-+    -webkit-appearance: none;
-+}
-+
-+.setting-item input[type="range"]::-webkit-slider-thumb {
-+    -webkit-appearance: none;
-+    width: 12px;
-+    height: 12px;
-+    background: #4a90e2;
-+    border-radius: 50%;
-+    cursor: pointer;
-+    transition: background 0.2s;
-+}
-+
-+.setting-item input[type="range"]::-webkit-slider-thumb:hover {
-+    background: #357abd;
-+}
-+
-+.setting-item input[type="color"] {
-+    width: 100%;
-+    height: 30px;
-+    padding: 2px;
-+    border: 1px solid #444;
-+    background: #222;
-+    border-radius: 4px;
-+    cursor: pointer;
-+}
-+
-+.setting-item input[type="number"] {
-+    width: 100%;
-+    padding: 6px;
-+    border: 1px solid #444;
-+    background: #222;
-+    color: #fff;
-+    border-radius: 4px;
-+}
-+
-+.setting-item input[type="checkbox"] {
-+    margin-right: 8px;
-+}
-+
-+.setting-item.disabled {
-+    opacity: 0.5;
-+    pointer-events: none;
-+}
-+
-+.save-button {
-+    width: 100%;
-+    padding: 8px 16px;
-+    background: #4a90e2;
-+    color: #fff;
-+    border: none;
-+    border-radius: 4px;
-+    cursor: pointer;
-+    font-size: 14px;
-+    transition: background 0.2s;
-+}
-+
-+.save-button:hover {
-+    background: #357abd;
-+}
-+
-+/* Custom scrollbar */
-+.control-panel-content::-webkit-scrollbar {
-+    width: 6px;
-+}
-+
-+.control-panel-content::-webkit-scrollbar-track {
-+    background: rgba(0, 0, 0, 0.1);
-+}
-+
-+.control-panel-content::-webkit-scrollbar-thumb {
-+    background: rgba(255, 255, 255, 0.2);
-+    border-radius: 3px;
-+}
-+
-+.control-panel-content::-webkit-scrollbar-thumb:hover {
-+    background: rgba(255, 255, 255, 0.3);
-+}
-+
-+/* Animations */
-+@keyframes fadeIn {
-+    from { opacity: 0; }
-+    to { opacity: 1; }
-+}
-+
-+.control-panel {
-+    animation: fadeIn 0.3s ease;
-+}
-+
-+/* Responsive design */
-+@media (max-width: 768px) {
-+    .control-panel {
-+        width: 280px;
-+    }
-+}
-diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
-new file mode 100644
-index 00000000..e59b53de
---- /dev/null
-+++ b/client/ui/ControlPanel.ts
-@@ -0,0 +1,515 @@
-+import { VisualizationSettings } from '../core/types';
-+import { settingsManager } from '../state/settings';
-+import { createLogger } from '../core/utils';
-+
-+const logger = createLogger('ControlPanel');
-+
-+export class ControlPanel {
-+    private container: HTMLDivElement;
-+    private settings: VisualizationSettings;
-+    private isExpanded = false;
-+    
-+    constructor() {
-+        this.container = document.createElement('div');
-+        this.container.className = 'control-panel';
-+        this.settings = { ...settingsManager.getSettings() };
-+        this.initializeUI();
-+        this.setupEventListeners();
-+        
-+        // Subscribe to settings updates
-+        settingsManager.addSettingsListener(this.onSettingsUpdate.bind(this));
-+    }
-+
-+    private initializeUI(): void {
-+        this.container.innerHTML = `
-+            <div class="control-panel-header">
-+                <h3>Graph Controls</h3>
-+                <button class="toggle-button">≡</button>
-+            </div>
-+            <div class="control-panel-content">
-+                <div class="settings-group">
-+                    <h4>Node Appearance</h4>
-+                    <div class="setting-item">
-+                        <label for="nodeSize">Base Size</label>
-+                        <input type="range" id="nodeSize" min="0.1" max="2" step="0.1" value="${this.settings.nodeSize}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="nodeColor">Color</label>
-+                        <input type="color" id="nodeColor" value="${this.settings.nodeColor}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="nodeOpacity">Opacity</label>
-+                        <input type="range" id="nodeOpacity" min="0" max="1" step="0.1" value="${this.settings.nodeOpacity}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="metalness">Metalness</label>
-+                        <input type="range" id="metalness" min="0" max="1" step="0.05" value="${this.settings.metalness}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="roughness">Roughness</label>
-+                        <input type="range" id="roughness" min="0" max="1" step="0.05" value="${this.settings.roughness}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="clearcoat">Clearcoat</label>
-+                        <input type="range" id="clearcoat" min="0" max="1" step="0.1" value="${this.settings.clearcoat}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Edge Appearance</h4>
-+                    <div class="setting-item">
-+                        <label for="edgeWidth">Width</label>
-+                        <input type="range" id="edgeWidth" min="0.1" max="5" step="0.1" value="${this.settings.edgeWidth}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="edgeColor">Color</label>
-+                        <input type="color" id="edgeColor" value="${this.settings.edgeColor}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label for="edgeOpacity">Opacity</label>
-+                        <input type="range" id="edgeOpacity" min="0" max="1" step="0.1" value="${this.settings.edgeOpacity}">
-+                    </div>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableArrows" ${this.settings.enableArrows ? 'checked' : ''}>
-+                            Show Arrows
-+                        </label>
-+                    </div>
-+                    <div class="setting-item arrow-setting ${this.settings.enableArrows ? '' : 'disabled'}">
-+                        <label for="arrowSize">Arrow Size</label>
-+                        <input type="range" id="arrowSize" min="0.1" max="1" step="0.05" value="${this.settings.arrowSize}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Visual Effects</h4>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableBloom" ${this.settings.enableBloom ? 'checked' : ''}>
-+                            Enable Bloom
-+                        </label>
-+                    </div>
-+                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
-+                        <label for="bloomIntensity">Bloom Intensity</label>
-+                        <input type="range" id="bloomIntensity" min="0" max="2" step="0.1" value="${this.settings.bloomIntensity}">
-+                    </div>
-+                    <div class="setting-item bloom-setting ${this.settings.enableBloom ? '' : 'disabled'}">
-+                        <label for="bloomRadius">Bloom Radius</label>
-+                        <input type="range" id="bloomRadius" min="0" max="2" step="0.1" value="${this.settings.bloomRadius}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Animations</h4>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableNodeAnimations" ${this.settings.enableNodeAnimations ? 'checked' : ''}>
-+                            Node Animations
-+                        </label>
-+                    </div>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="enableMotionBlur" ${this.settings.enableMotionBlur ? 'checked' : ''}>
-+                            Motion Blur
-+                        </label>
-+                    </div>
-+                    <div class="setting-item motion-setting ${this.settings.enableMotionBlur ? '' : 'disabled'}">
-+                        <label for="motionBlurStrength">Motion Blur Strength</label>
-+                        <input type="range" id="motionBlurStrength" min="0" max="1" step="0.1" value="${this.settings.motionBlurStrength}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Labels</h4>
-+                    <div class="setting-item">
-+                        <label>
-+                            <input type="checkbox" id="showLabels" ${this.settings.showLabels ? 'checked' : ''}>
-+                            Show Labels
-+                        </label>
-+                    </div>
-+                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
-+                        <label for="labelSize">Label Size</label>
-+                        <input type="range" id="labelSize" min="0.5" max="2" step="0.1" value="${this.settings.labelSize}">
-+                    </div>
-+                    <div class="setting-item label-setting ${this.settings.showLabels ? '' : 'disabled'}">
-+                        <label for="labelColor">Label Color</label>
-+                        <input type="color" id="labelColor" value="${this.settings.labelColor}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>Performance</h4>
-+                    <div class="setting-item">
-+                        <label for="maxFps">Max FPS</label>
-+                        <input type="number" id="maxFps" min="30" max="144" value="${this.settings.maxFps}">
-+                    </div>
-+                </div>
-+
-+                <div class="settings-group">
-+                    <h4>AR Settings</h4>
-+                    <div class="setting-item">
-+                        <label>Scene Understanding</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enablePlaneDetection" ${this.settings.enablePlaneDetection ? 'checked' : ''}>
-+                                    Plane Detection
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableSceneUnderstanding" ${this.settings.enableSceneUnderstanding ? 'checked' : ''}>
-+                                    Scene Understanding
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="showPlaneOverlay" ${this.settings.showPlaneOverlay ? 'checked' : ''}>
-+                                    Show Plane Overlay
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="planeOpacity">Plane Opacity</label>
-+                                <input type="range" id="planeOpacity" min="0" max="1" step="0.1" value="${this.settings.planeOpacity}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="planeColor">Plane Color</label>
-+                                <input type="color" id="planeColor" value="${this.settings.planeColor}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableLightEstimation" ${this.settings.enableLightEstimation ? 'checked' : ''}>
-+                                    Light Estimation
-+                                </label>
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Hand Tracking</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableHandTracking" ${this.settings.enableHandTracking ? 'checked' : ''}>
-+                                    Enable Hand Tracking
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="handMeshEnabled" ${this.settings.handMeshEnabled ? 'checked' : ''}>
-+                                    Show Hand Mesh
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="handMeshColor">Hand Mesh Color</label>
-+                                <input type="color" id="handMeshColor" value="${this.settings.handMeshColor}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="handMeshOpacity">Hand Mesh Opacity</label>
-+                                <input type="range" id="handMeshOpacity" min="0" max="1" step="0.1" value="${this.settings.handMeshOpacity}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="handRayEnabled" ${this.settings.handRayEnabled ? 'checked' : ''}>
-+                                    Show Hand Ray
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="handRayColor">Hand Ray Color</label>
-+                                <input type="color" id="handRayColor" value="${this.settings.handRayColor}">
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Gesture Controls</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label for="gestureSmoothing">Gesture Smoothing</label>
-+                                <input type="range" id="gestureSmoothing" min="0" max="1" step="0.1" value="${this.settings.gestureSmoothing}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="pinchThreshold">Pinch Threshold</label>
-+                                <input type="range" id="pinchThreshold" min="0" max="0.05" step="0.001" value="${this.settings.pinchThreshold}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="dragThreshold">Drag Threshold</label>
-+                                <input type="range" id="dragThreshold" min="0" max="0.1" step="0.01" value="${this.settings.dragThreshold}">
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Haptics</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enableHaptics" ${this.settings.enableHaptics ? 'checked' : ''}>
-+                                    Enable Haptics
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="hapticIntensity">Haptic Intensity</label>
-+                                <input type="range" id="hapticIntensity" min="0" max="1" step="0.1" value="${this.settings.hapticIntensity}">
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Room Scale</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="roomScale" ${this.settings.roomScale ? 'checked' : ''}>
-+                                    Room Scale Mode
-+                                </label>
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="snapToFloor" ${this.settings.snapToFloor ? 'checked' : ''}>
-+                                    Snap to Floor
-+                                </label>
-+                            </div>
-+                        </div>
-+                    </div>
-+
-+                    <div class="setting-item">
-+                        <label>Passthrough</label>
-+                        <div class="sub-settings">
-+                            <div class="setting-item">
-+                                <label for="passthroughOpacity">Opacity</label>
-+                                <input type="range" id="passthroughOpacity" min="0" max="1" step="0.1" value="${this.settings.passthroughOpacity}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="passthroughBrightness">Brightness</label>
-+                                <input type="range" id="passthroughBrightness" min="0" max="2" step="0.1" value="${this.settings.passthroughBrightness}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label for="passthroughContrast">Contrast</label>
-+                                <input type="range" id="passthroughContrast" min="0" max="2" step="0.1" value="${this.settings.passthroughContrast}">
-+                            </div>
-+                            <div class="setting-item">
-+                                <label>
-+                                    <input type="checkbox" id="enablePassthroughPortal" ${this.settings.enablePassthroughPortal ? 'checked' : ''}>
-+                                    Enable Portal
-+                                </label>
-+                            </div>
-+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-+                                <label for="portalSize">Portal Size</label>
-+                                <input type="range" id="portalSize" min="0.1" max="2" step="0.1" value="${this.settings.portalSize}">
-+                            </div>
-+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-+                                <label for="portalEdgeColor">Portal Edge Color</label>
-+                                <input type="color" id="portalEdgeColor" value="${this.settings.portalEdgeColor}">
-+                            </div>
-+                            <div class="setting-item portal-setting ${this.settings.enablePassthroughPortal ? '' : 'disabled'}">
-+                                <label for="portalEdgeWidth">Portal Edge Width</label>
-+                                <input type="range" id="portalEdgeWidth" min="0.001" max="0.05" step="0.001" value="${this.settings.portalEdgeWidth}">
-+                            </div>
-+                        </div>
-+                    </div>
-+                </div>
-+
-+                <button class="save-button">Save Changes</button>
-+            </div>
-+        `;
-+
-+        document.body.appendChild(this.container);
-+    }
-+
-+    private setupEventListeners(): void {
-+        // Toggle panel
-+        const toggleButton = this.container.querySelector('.toggle-button');
-+        toggleButton?.addEventListener('click', () => {
-+            this.isExpanded = !this.isExpanded;
-+            this.container.classList.toggle('expanded', this.isExpanded);
-+        });
-+
-+        // Save button
-+        const saveButton = this.container.querySelector('.save-button');
-+        saveButton?.addEventListener('click', this.saveSettings.bind(this));
-+
-+        // Node settings
-+        this.setupInputListener('nodeSize', 'number');
-+        this.setupInputListener('nodeColor', 'string');
-+        this.setupInputListener('nodeOpacity', 'number');
-+        this.setupInputListener('metalness', 'number');
-+        this.setupInputListener('roughness', 'number');
-+        this.setupInputListener('clearcoat', 'number');
-+
-+        // Edge settings
-+        this.setupInputListener('edgeWidth', 'number');
-+        this.setupInputListener('edgeColor', 'string');
-+        this.setupInputListener('edgeOpacity', 'number');
-+        
-+        const arrowsCheckbox = this.container.querySelector('#enableArrows') as HTMLInputElement;
-+        arrowsCheckbox?.addEventListener('change', () => {
-+            const arrowSettings = this.container.querySelectorAll('.arrow-setting');
-+            arrowSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !arrowsCheckbox.checked);
-+            });
-+            this.settings.enableArrows = arrowsCheckbox.checked;
-+        });
-+        this.setupInputListener('arrowSize', 'number');
-+
-+        // Bloom settings
-+        const bloomCheckbox = this.container.querySelector('#enableBloom') as HTMLInputElement;
-+        bloomCheckbox?.addEventListener('change', () => {
-+            const bloomSettings = this.container.querySelectorAll('.bloom-setting');
-+            bloomSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !bloomCheckbox.checked);
-+            });
-+            this.settings.enableBloom = bloomCheckbox.checked;
-+        });
-+        this.setupInputListener('bloomIntensity', 'number');
-+        this.setupInputListener('bloomRadius', 'number');
-+
-+        // Animation settings
-+        const nodeAnimCheckbox = this.container.querySelector('#enableNodeAnimations') as HTMLInputElement;
-+        nodeAnimCheckbox?.addEventListener('change', () => {
-+            this.settings.enableNodeAnimations = nodeAnimCheckbox.checked;
-+        });
-+
-+        const motionBlurCheckbox = this.container.querySelector('#enableMotionBlur') as HTMLInputElement;
-+        motionBlurCheckbox?.addEventListener('change', () => {
-+            const motionSettings = this.container.querySelectorAll('.motion-setting');
-+            motionSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !motionBlurCheckbox.checked);
-+            });
-+            this.settings.enableMotionBlur = motionBlurCheckbox.checked;
-+        });
-+        this.setupInputListener('motionBlurStrength', 'number');
-+
-+        // Label settings
-+        const labelCheckbox = this.container.querySelector('#showLabels') as HTMLInputElement;
-+        labelCheckbox?.addEventListener('change', () => {
-+            const labelSettings = this.container.querySelectorAll('.label-setting');
-+            labelSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !labelCheckbox.checked);
-+            });
-+            this.settings.showLabels = labelCheckbox.checked;
-+        });
-+        this.setupInputListener('labelSize', 'number');
-+        this.setupInputListener('labelColor', 'string');
-+
-+        // Performance settings
-+        this.setupInputListener('maxFps', 'number');
-+
-+        // AR settings
-+        const planeDetectionCheckbox = this.container.querySelector('#enablePlaneDetection') as HTMLInputElement;
-+        planeDetectionCheckbox?.addEventListener('change', () => {
-+            this.settings.enablePlaneDetection = planeDetectionCheckbox.checked;
-+        });
-+
-+        const sceneUnderstandingCheckbox = this.container.querySelector('#enableSceneUnderstanding') as HTMLInputElement;
-+        sceneUnderstandingCheckbox?.addEventListener('change', () => {
-+            this.settings.enableSceneUnderstanding = sceneUnderstandingCheckbox.checked;
-+        });
-+
-+        const showPlaneOverlayCheckbox = this.container.querySelector('#showPlaneOverlay') as HTMLInputElement;
-+        showPlaneOverlayCheckbox?.addEventListener('change', () => {
-+            this.settings.showPlaneOverlay = showPlaneOverlayCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('planeOpacity', 'number');
-+        this.setupInputListener('planeColor', 'string');
-+
-+        const lightEstimationCheckbox = this.container.querySelector('#enableLightEstimation') as HTMLInputElement;
-+        lightEstimationCheckbox?.addEventListener('change', () => {
-+            this.settings.enableLightEstimation = lightEstimationCheckbox.checked;
-+        });
-+
-+        const handTrackingCheckbox = this.container.querySelector('#enableHandTracking') as HTMLInputElement;
-+        handTrackingCheckbox?.addEventListener('change', () => {
-+            this.settings.enableHandTracking = handTrackingCheckbox.checked;
-+        });
-+
-+        const handMeshEnabledCheckbox = this.container.querySelector('#handMeshEnabled') as HTMLInputElement;
-+        handMeshEnabledCheckbox?.addEventListener('change', () => {
-+            this.settings.handMeshEnabled = handMeshEnabledCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('handMeshColor', 'string');
-+        this.setupInputListener('handMeshOpacity', 'number');
-+
-+        const handRayEnabledCheckbox = this.container.querySelector('#handRayEnabled') as HTMLInputElement;
-+        handRayEnabledCheckbox?.addEventListener('change', () => {
-+            this.settings.handRayEnabled = handRayEnabledCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('handRayColor', 'string');
-+
-+        this.setupInputListener('gestureSmoothing', 'number');
-+        this.setupInputListener('pinchThreshold', 'number');
-+        this.setupInputListener('dragThreshold', 'number');
-+
-+        const hapticsCheckbox = this.container.querySelector('#enableHaptics') as HTMLInputElement;
-+        hapticsCheckbox?.addEventListener('change', () => {
-+            this.settings.enableHaptics = hapticsCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('hapticIntensity', 'number');
-+
-+        const roomScaleCheckbox = this.container.querySelector('#roomScale') as HTMLInputElement;
-+        roomScaleCheckbox?.addEventListener('change', () => {
-+            this.settings.roomScale = roomScaleCheckbox.checked;
-+        });
-+
-+        const snapToFloorCheckbox = this.container.querySelector('#snapToFloor') as HTMLInputElement;
-+        snapToFloorCheckbox?.addEventListener('change', () => {
-+            this.settings.snapToFloor = snapToFloorCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('passthroughOpacity', 'number');
-+        this.setupInputListener('passthroughBrightness', 'number');
-+        this.setupInputListener('passthroughContrast', 'number');
-+
-+        const passthroughPortalCheckbox = this.container.querySelector('#enablePassthroughPortal') as HTMLInputElement;
-+        passthroughPortalCheckbox?.addEventListener('change', () => {
-+            const portalSettings = this.container.querySelectorAll('.portal-setting');
-+            portalSettings.forEach(setting => {
-+                setting.classList.toggle('disabled', !passthroughPortalCheckbox.checked);
-+            });
-+            this.settings.enablePassthroughPortal = passthroughPortalCheckbox.checked;
-+        });
-+
-+        this.setupInputListener('portalSize', 'number');
-+        this.setupInputListener('portalEdgeColor', 'string');
-+        this.setupInputListener('portalEdgeWidth', 'number');
-+    }
-+
-+    private setupInputListener(id: string, type: 'number' | 'string'): void {
-+        const input = this.container.querySelector(`#${id}`) as HTMLInputElement;
-+        input?.addEventListener('input', () => {
-+            const value = type === 'number' ? parseFloat(input.value) : input.value;
-+            (this.settings as any)[id] = value;
-+        });
-+    }
-+
-+    private async saveSettings(): Promise<void> {
-+        try {
-+            await settingsManager.updateSettings(this.settings);
-+            logger.log('Settings saved successfully');
-+        } catch (error) {
-+            logger.error('Failed to save settings:', error);
-+        }
-+    }
-+
-+    private onSettingsUpdate(newSettings: VisualizationSettings): void {
-+        this.settings = { ...newSettings };
-+        this.updateUIValues();
-+    }
-+
-+    private updateUIValues(): void {
-+        Object.entries(this.settings).forEach(([key, value]) => {
-+            const input = this.container.querySelector(`#${key}`) as HTMLInputElement;
-+            if (input) {
-+                if (input.type === 'checkbox') {
-+                    input.checked = value as boolean;
-+                } else {
-+                    input.value = value.toString();
-+                }
-+            }
-+        });
-+    }
-+}
-diff --git a/client/ui/index.ts b/client/ui/index.ts
-new file mode 100644
-index 00000000..04ebc6e6
---- /dev/null
-+++ b/client/ui/index.ts
-@@ -0,0 +1,4 @@
-+import { ControlPanel } from './ControlPanel';
-+import './ControlPanel.css';
-+
-+export { ControlPanel };
-diff --git a/client/xr/xrInteraction.ts b/client/xr/xrInteraction.ts
-index 921924d5..c9b42a1b 100644
---- a/client/xr/xrInteraction.ts
-+++ b/client/xr/xrInteraction.ts
-@@ -1,384 +1,141 @@
--/**
-- * XR interaction handling for controllers and hands
-- */
--
- import * as THREE from 'three';
--import { XRSessionManager } from './xrSessionManager';
-+import { XRHandWithHaptics } from './xrTypes';
- import { NodeManager } from '../rendering/nodes';
--import { settingsManager } from '../state/settings';
--import { createLogger } from '../core/utils';
--
--// Logger will be used for debugging XR interactions and haptic feedback
--const _logger = createLogger('XRInteraction');
--
--// XR Interaction Action Types
--type XRInteractionActionType = 'select' | 'squeeze';
--
--// Extended XR types
--interface XRHandWithHaptics extends XRHand {
--    vibrate?(intensity: number, duration: number): void;
--}
--
--interface XRSessionWithPose extends XRSession {
--    getPose?(source: XRSpace, referenceSpace: XRReferenceSpace): XRPose | undefined;
--}
--
--interface XRInteractionActionEvent extends THREE.Event {
--    type: `${XRInteractionActionType}start` | `${XRInteractionActionType}end`;
--    data: XRInputSource;
--    hand?: XRHandWithHaptics;
--}
--
--interface XRController extends THREE.Group {
--    userData: {
--        inputSource: XRInputSource;
--    };
--}
--
--interface XRNodeMeshUserData {
--    nodeId: string;
--}
--
--interface XRNodeMesh extends THREE.Object3D {
--    userData: XRNodeMeshUserData;
--}
--
--declare module 'three' {
--    interface Object3DEventMap {
--        selectstart: XRInteractionActionEvent;
--        selectend: XRInteractionActionEvent;
--        squeezestart: XRInteractionActionEvent;
--        squeezeend: XRInteractionActionEvent;
--    }
--}
--
--type XRInteractor = XRController | XRHandWithHaptics;
--
--// Type guard function to check if an object is an XRNodeMesh
--function isXRNodeMesh(obj: THREE.Object3D): obj is XRNodeMesh {
--    return (
--        obj !== null &&
--        typeof obj === 'object' &&
--        'userData' in obj &&
--        obj.userData !== null &&
--        typeof obj.userData === 'object' &&
--        'nodeId' in obj.userData &&
--        typeof obj.userData.nodeId === 'string'
--    );
--}
-+import { XRSessionManager } from './xrSessionManager';
-+import { VisualizationSettings } from '../core/types';
- 
- export class XRInteraction {
--    private static instance: XRInteraction;
-+    private static instance: XRInteraction | null = null;
-     private xrManager: XRSessionManager;
-     private nodeManager: NodeManager;
--
--    // Interaction state
--    private selectedNode: string | null = null;
--    private hoveredNode: string | null = null;
--    private isGrabbing: boolean = false;
--    private lastInteractorPosition: THREE.Vector3;
--    private grabOffset: THREE.Vector3;
--
--    // Raycasting
--    private raycaster: THREE.Raycaster;
--    private tempMatrix: THREE.Matrix4;
--
--    // Hand Tracking
-+    private controllers: THREE.Group[] = [];
-+    private lastInteractorPosition = new THREE.Vector3();
-     private hands: XRHandWithHaptics[] = [];
--    private pinchThreshold: number = 0.025;
-+    private settings: VisualizationSettings;
- 
-     private constructor(xrManager: XRSessionManager, nodeManager: NodeManager) {
-         this.xrManager = xrManager;
-         this.nodeManager = nodeManager;
--
--        this.lastInteractorPosition = new THREE.Vector3();
--        this.grabOffset = new THREE.Vector3();
--        this.raycaster = new THREE.Raycaster();
--        this.tempMatrix = new THREE.Matrix4();
--        this.setupEventListeners();
--    }
--
--    static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
-+        this.settings = {
-+            enableHandTracking: true,
-+            pinchThreshold: 0.015,
-+            dragThreshold: 0.04,
-+            enableHaptics: true,
-+            hapticIntensity: 0.7
-+        } as VisualizationSettings;
-+        
-+        this.setupXRControllers();
-+        this.setupHandTracking();
-+    }
-+
-+    public static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
-         if (!XRInteraction.instance) {
-             XRInteraction.instance = new XRInteraction(xrManager, nodeManager);
-         }
-         return XRInteraction.instance;
-     }
- 
--    private setupEventListeners(): void {
--        const session = this.xrManager.getSession();
--        if (!session) return;
--
--        // Handle controller / hand updates
--        session.addEventListener('inputsourceschange', (event: XRInputSourcesChangeEvent) => {
--            // Clear old event listeners
--            this.xrManager.getControllers().forEach(controller => {
--                controller.removeEventListener('selectstart', this.handleSelectStart);
--                controller.removeEventListener('selectend', this.handleSelectEnd);
--                controller.removeEventListener('squeezestart', this.handleSqueezeStart);
--                controller.removeEventListener('squeezeend', this.handleSqueezeEnd);
--            });
--
--            this.hands = [];
--            event.added.forEach((source: XRInputSource) => {
--                if (source.hand) {
--                    this.hands.push(source.hand as XRHandWithHaptics);
--                }
--            });
--
--            // Setup new input sources
--            this.xrManager.getControllers().forEach((controller) => {
--                controller.addEventListener('selectstart', this.handleSelectStart);
--                controller.addEventListener('selectend', this.handleSelectEnd);
--                controller.addEventListener('squeezestart', this.handleSqueezeStart);
--                controller.addEventListener('squeezeend', this.handleSqueezeEnd);
--            });
-+    private setupXRControllers(): void {
-+        this.xrManager.onControllerAdded((controller: THREE.Group) => {
-+            this.controllers.push(controller);
-+            if (controller.userData.hapticActuator) {
-+                this.triggerHapticFeedback(controller, 0.5, 50);
-+            }
-         });
- 
--        // Initial Setup
--        this.xrManager.getControllers().forEach((controller) => {
--            controller.addEventListener('selectstart', this.handleSelectStart);
--            controller.addEventListener('selectend', this.handleSelectEnd);
--            controller.addEventListener('squeezestart', this.handleSqueezeStart);
--            controller.addEventListener('squeezeend', this.handleSqueezeEnd);
-+        this.xrManager.onControllerRemoved((controller: THREE.Group) => {
-+            const index = this.controllers.indexOf(controller);
-+            if (index !== -1) {
-+                this.controllers.splice(index, 1);
-+            }
-         });
-     }
- 
--    private handleSelectStart = (event: THREE.Event) => {
--        if (this.hoveredNode) {
--            const interactionEvent = event as XRInteractionActionEvent;
--            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
--        }
--    }
--
--    private handleSelectEnd = () => {
--        this.endGrab();
--    }
-+    private setupHandTracking(): void {
-+        if (!this.settings.enableHandTracking) return;
- 
--    private handleSqueezeStart = (event: THREE.Event) => {
--        if (this.hoveredNode) {
--            const interactionEvent = event as XRInteractionActionEvent;
--            this.startGrab(this.hoveredNode, interactionEvent.data, interactionEvent.hand);
--        }
-+        // Hand tracking is handled by the XRSessionManager directly
-+        this.hands = [];
-     }
- 
--    private handleSqueezeEnd = () => {
--        this.endGrab();
--    }
-+    public update(): void {
-+        if (!this.settings.enableHandTracking) return;
- 
--    /**
--     * Update interaction state
--     */
--    update(frame: XRFrame): void {
--        const session = this.xrManager.getSession() as XRSessionWithPose;
--        const referenceSpace = this.xrManager.getReferenceSpace();
--
--        if (!session || !referenceSpace) return;
--
--        // Update controller interaction
--        this.xrManager.getControllers().forEach((baseController) => {
--            const controller = baseController as XRController;
--            const inputSource = controller.userData.inputSource;
--            if (!inputSource) return;
--
--            // Get controller pose
--            const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
--            if (!pose) return;
--
--            // Update raycaster
--            controller.updateMatrixWorld();
--            this.tempMatrix.identity().extractRotation(controller.matrixWorld);
--            this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
--            this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
--
--            // Check for intersections with nodes
--            this.checkNodeIntersections(controller);
--
--            // Update grabbed node position
--            if (this.isGrabbing && this.selectedNode) {
--                this.updateGrabbedNodePosition(controller);
--            }
--
--            // Provide haptic feedback if enabled
--            if (inputSource.gamepad && settingsManager.getSettings().xrControllerVibration) {
--                this.handleHapticFeedback(inputSource.gamepad);
-+        // Update hand interactions
-+        this.hands.forEach(hand => {
-+            if (hand.pinchStrength > this.settings.pinchThreshold) {
-+                this.handlePinchGesture(hand);
-             }
-         });
- 
--        // Handle Hand Interactions
--        this.hands.forEach((hand) => {
--            this.checkHandIntersections(hand, frame, referenceSpace);
--
--            if (this.isGrabbing && this.selectedNode) {
--                this.updateGrabbedNodePosition(hand);
--            }
-+        // Update controller interactions
-+        this.controllers.forEach(controller => {
-+            this.handleControllerInteraction(controller);
-         });
-     }
- 
--    private checkHandIntersections(hand: XRHandWithHaptics, frame: XRFrame, referenceSpace: XRReferenceSpace): void {
--        if (!hand || !frame || !referenceSpace) return;
--
--        // Get index and thumb tip
--        const indexTipPose = frame.getPose(hand.get("index-finger-tip") as XRSpace, referenceSpace);
--        const thumbTipPose = frame.getPose(hand.get("thumb-tip") as XRSpace, referenceSpace);
--        if (!indexTipPose || !thumbTipPose) return;
--
--        const indexTipPosition = new THREE.Vector3().fromArray(indexTipPose.transform.matrix.slice(12, 15));
--        const thumbTipPosition = new THREE.Vector3().fromArray(thumbTipPose.transform.matrix.slice(12, 15));
--        const distance = indexTipPosition.distanceTo(thumbTipPosition);
--
--        let closestNode: XRNodeMesh | null = null;
--        let minDistance = Infinity;
--
--        // Get meshes and check each one
--        const meshes = this.nodeManager.getAllNodeMeshes();
--        for (const mesh of meshes) {
--            if (isXRNodeMesh(mesh)) {
--                const nodePosition = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);
--                const nodeDistance = nodePosition.distanceTo(indexTipPosition);
--
--                if (nodeDistance < minDistance) {
--                    minDistance = nodeDistance;
--                    closestNode = mesh;
--                }
--            }
--        }
--
--        if (minDistance < 0.1 && closestNode) {
--            const nodeId = closestNode.userData.nodeId;
--            if (nodeId !== this.hoveredNode) {
--                // Update hover state
--                this.hoveredNode = nodeId;
--                this.nodeManager.highlightNode(nodeId);
--                // Trigger haptic pulse for hover
--                this.pulseHand(hand, 0.2, 50);
--            }
--            if (distance < this.pinchThreshold && !this.isGrabbing) {
--                this.startGrab(nodeId, hand, hand);
--            }
--        } else if (this.hoveredNode) {
--            // Clear hover state
--            this.nodeManager.highlightNode(null);
--            this.hoveredNode = null;
--        }
--    }
--
--    private checkNodeIntersections(controller: XRController): void {
--        // Get closest intersection
--        const meshes = this.nodeManager.getAllNodeMeshes();
--        const intersects = this.raycaster.intersectObjects(meshes);
--
--        if (intersects.length > 0) {
--            const intersectedObject = intersects[0].object;
--            if (isXRNodeMesh(intersectedObject)) {
--                const nodeId = intersectedObject.userData.nodeId;
--                if (nodeId !== this.hoveredNode) {
--                    // Update hover state
--                    this.hoveredNode = nodeId;
--                    this.nodeManager.highlightNode(nodeId);
-+    private handlePinchGesture(hand: XRHandWithHaptics): void {
-+        const indexTip = hand.hand.joints['index-finger-tip'];
-+        if (!indexTip) return;
- 
--                    // Trigger haptic pulse for hover
--                    this.pulseController(controller, 0.2, 50);
--                }
--            }
--        } else if (this.hoveredNode) {
--            // Clear hover state
--            this.nodeManager.highlightNode(null);
--            this.hoveredNode = null;
--        }
--    }
-+        const position = new THREE.Vector3();
-+        position.setFromMatrixPosition(indexTip.matrixWorld);
- 
--    private startGrab(nodeId: string, interactor: XRInputSource | XRHandWithHaptics, hand?: XRHandWithHaptics): void {
--        this.selectedNode = nodeId;
--        this.isGrabbing = true;
--
--        // Store initial grab position
--        if (interactor instanceof THREE.Group) {
--            const controller = interactor as unknown as XRController;
--            this.lastInteractorPosition.setFromMatrixPosition(controller.matrixWorld);
--            this.pulseController(controller, 0.7, 100);
--        } else if (hand) {
--            const wrist = hand.get("wrist") as XRSpace;
--            const session = this.xrManager.getSession() as XRSessionWithPose;
--            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
--            if (pose) {
--                this.lastInteractorPosition.fromArray(pose.transform.matrix.slice(12, 15));
-+        // Calculate movement delta
-+        const delta = position.clone().sub(this.lastInteractorPosition);
-+        
-+        // Update node positions based on hand movement
-+        if (delta.length() > this.settings.dragThreshold) {
-+            this.nodeManager.updateNodePositions({
-+                x: delta.x,
-+                y: delta.y,
-+                z: delta.z
-+            });
-+            if (this.settings.enableHaptics) {
-+                this.triggerHapticFeedback(hand, this.settings.hapticIntensity, 50);
-             }
--            this.pulseHand(hand, 0.7, 100);
-         }
- 
--        // Calculate grab offset
--        const nodePosition = this.nodeManager.getNodePosition(nodeId);
--        this.grabOffset.subVectors(nodePosition, this.lastInteractorPosition);
--    }
--
--    private endGrab(): void {
--        if (this.isGrabbing) {
--            this.isGrabbing = false;
--            this.selectedNode = null;
--        }
-+        this.lastInteractorPosition.copy(position);
-     }
- 
--    private updateGrabbedNodePosition(interactor: XRInteractor): void {
--        if (!this.selectedNode) return;
-+    private handleControllerInteraction(controller: THREE.Group): void {
-+        const position = new THREE.Vector3();
-+        position.setFromMatrixPosition(controller.matrixWorld);
- 
--        // Get current interactor position
--        const currentPosition = new THREE.Vector3();
--        if (interactor instanceof THREE.Group) {
--            currentPosition.setFromMatrixPosition(interactor.matrixWorld);
--        } else {
--            const wrist = interactor.get("wrist") as XRSpace;
--            const session = this.xrManager.getSession() as XRSessionWithPose;
--            const pose = session?.getPose?.(wrist, this.xrManager.getReferenceSpace() as XRReferenceSpace);
--            if (pose) {
--                currentPosition.fromArray(pose.transform.matrix.slice(12, 15));
-+        // Calculate movement delta
-+        const delta = position.clone().sub(this.lastInteractorPosition);
-+        
-+        // Update node positions based on controller movement
-+        if (delta.length() > this.settings.dragThreshold) {
-+            this.nodeManager.updateNodePositions({
-+                x: delta.x,
-+                y: delta.y,
-+                z: delta.z
-+            });
-+            if (this.settings.enableHaptics && controller.userData.hapticActuator) {
-+                this.triggerHapticFeedback(controller, this.settings.hapticIntensity, 50);
-             }
-         }
- 
--        // Calculate new node position
--        const newPosition = currentPosition.clone().add(this.grabOffset);
--        this.nodeManager.updateNodePosition(this.selectedNode, newPosition);
--
--        // Update last position
--        this.lastInteractorPosition.copy(currentPosition);
--    }
--
--    private handleHapticFeedback(__gamepad: Gamepad): void {
--        if (!settingsManager.getSettings().xrControllerVibration) return;
--
--        // Add haptic feedback logic based on interactions
--        // For example, vibrate when near nodes or when grabbing
-+        this.lastInteractorPosition.copy(position);
-     }
- 
--    private pulseController(controller: XRController, intensity: number, duration: number): void {
--        const inputSource = controller.userData.inputSource;
--        if (!inputSource?.gamepad || !settingsManager.getSettings().xrControllerVibration) return;
-+    private triggerHapticFeedback(device: THREE.Group | XRHandWithHaptics, intensity: number, duration: number): void {
-+        if (!this.settings.enableHaptics) return;
- 
--        const actuator = inputSource.gamepad.hapticActuators?.[0] as any;
--        if (actuator) {
--            try {
-+        if ('hapticActuators' in device) {
-+            device.hapticActuators.forEach(actuator => {
-                 actuator.pulse(intensity, duration);
--            } catch (error) {
--                _logger.warn('Haptic feedback not supported:', error);
--            }
--        }
--    }
--
--    private pulseHand(hand: XRHandWithHaptics, intensity: number, duration: number): void {
--        if (!settingsManager.getSettings().xrControllerVibration) return;
--        try {
--            hand.vibrate?.(intensity, duration);
--        } catch (error) {
--            _logger.warn('Haptic feedback not supported for hands:', error);
-+            });
-+        } else if (device.userData.hapticActuator) {
-+            device.userData.hapticActuator.pulse(intensity, duration);
-         }
-     }
- 
--    /**
--     * Clean up resources
--     */
--    dispose(): void {
--        this.endGrab();
--        this.hoveredNode = null;
--        this.selectedNode = null;
-+    public dispose(): void {
-+        this.controllers = [];
-+        this.hands = [];
-+        XRInteraction.instance = null;
-     }
- }
-diff --git a/client/xr/xrSessionManager.ts b/client/xr/xrSessionManager.ts
-index 8c17d302..e234201e 100644
---- a/client/xr/xrSessionManager.ts
-+++ b/client/xr/xrSessionManager.ts
-@@ -46,6 +46,8 @@ export class XRSessionManager {
-   private xrSessionStartCallback: (() => void) | null = null;
-   private xrSessionEndCallback: (() => void) | null = null;
-   private xrAnimationFrameCallback: ((frame: XRFrame) => void) | null = null;
-+  private controllerAddedCallback: ((controller: THREE.Group) => void) | null = null;
-+  private controllerRemovedCallback: ((controller: THREE.Group) => void) | null = null;
- 
-   private constructor(sceneManager: SceneManager) {
-     this.sceneManager = sceneManager;
-@@ -137,42 +139,33 @@ export class XRSessionManager {
-     this.arGroup.add(this.arLight);
- 
-     // Setup controllers
--    this.controllers.forEach((controller, _index) => {
--      this.cameraRig.add(controller);
--      controller.layers.set(1); // Set to AR layer
--      this.setupController(controller);
-+    this.controllers.forEach((_controller, index) => {
-+      this.setupController(index);
-     });
- 
-     // Setup controller grips
--    this.controllerGrips.forEach((grip, _index) => {
--      this.cameraRig.add(grip);
--      grip.layers.set(1); // Set to AR layer
-+    this.controllerGrips.forEach(grip => {
-       this.setupControllerGrip(grip);
-     });
-   }
- 
--  private setupController(controller: THREE.Group): void {
--    controller.addEventListener('connected', this.onControllerConnected);
--    controller.addEventListener('disconnected', this.onControllerDisconnected);
--  }
-+  private setupController(index: number): void {
-+    const controller = this.controllers[index];
-+    const controllerGrip = this.controllerGrips[index];
- 
--private onControllerConnected = (event: THREE.Event): void => {
--  // Cast the event to XRControllerEvent
--  const xrEvent = event as THREE.XRControllerEvent;
--  // Cast the event target to Object3D first, then to Group
--  const controller = (xrEvent.target as unknown as THREE.Object3D) as THREE.Group;
--  controller.userData.inputSource = xrEvent.data;
-+    controller.addEventListener('connected', (event: any) => {
-+      const controllerModel = this.buildController(event.data);
-+      controller.add(controllerModel);
-+      this.notifyControllerAdded(controller);
-+    });
- 
--  if (xrEvent.data.targetRayMode === 'tracked-pointer') {
--    const pointer = this.createControllerPointer();
--    controller.add(pointer);
--  }
--}
-+    controller.addEventListener('disconnected', () => {
-+      controller.remove(...controller.children);
-+      this.notifyControllerRemoved(controller);
-+    });
- 
--private onControllerDisconnected = (event: THREE.Event): void => {
--  // Cast the event target to Object3D first, then to Group
--  const controller = (event.target as unknown as THREE.Object3D) as THREE.Group;
--  controller.remove(...controller.children);
-+    this.cameraRig.add(controller);
-+    this.cameraRig.add(controllerGrip);
-   }
- 
-   private setupControllerGrip(grip: THREE.Group): void {
-@@ -180,17 +173,13 @@ private onControllerDisconnected = (event: THREE.Event): void => {
-     grip.add(controllerModel);
-   }
- 
--  private createControllerPointer(): THREE.Mesh {
--    const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08);
--    geometry.rotateX(-Math.PI / 2);
--    const material = new THREE.MeshPhongMaterial({
--      color: 0xffffff,
--      transparent: true,
--      opacity: 0.8
--    });
--    const pointer = new THREE.Mesh(geometry, material);
--    pointer.layers.set(1); // Set to AR layer
--    return pointer;
-+  private buildController(_inputSource: XRInputSource): THREE.Group {
-+    const controller = new THREE.Group();
-+    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
-+    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
-+    const sphere = new THREE.Mesh(geometry, material);
-+    controller.add(sphere);
-+    return controller;
-   }
- 
-   /**
-@@ -421,6 +410,22 @@ private onControllerDisconnected = (event: THREE.Event): void => {
-     this.xrAnimationFrameCallback = onFrame;
-   }
- 
-+  public onControllerAdded(callback: (controller: THREE.Group) => void): void {
-+    this.controllerAddedCallback = callback;
-+  }
-+
-+  public onControllerRemoved(callback: (controller: THREE.Group) => void): void {
-+    this.controllerRemovedCallback = callback;
-+  }
-+
-+  private notifyControllerAdded(controller: THREE.Group): void {
-+    this.controllerAddedCallback?.(controller);
-+  }
-+
-+  private notifyControllerRemoved(controller: THREE.Group): void {
-+    this.controllerRemovedCallback?.(controller);
-+  }
-+
-   /**
-    * Get XR objects
-    */
-@@ -461,41 +466,33 @@ private onControllerDisconnected = (event: THREE.Event): void => {
-    * Clean up resources
-    */
-   dispose(): void {
--    if (this.hitTestSource) {
--      this.hitTestSource.cancel();
--    }
--
-     if (this.session) {
--      this.session.end();
-+      this.session.end().catch(console.error);
-     }
- 
--    // Remove event listeners
-     this.controllers.forEach(controller => {
--      controller.removeEventListener('connected', this.onControllerConnected);
--      controller.removeEventListener('disconnected', this.onControllerDisconnected);
--      controller.remove(...controller.children);
-+      controller.removeEventListener('connected', (event: any) => {
-+        const controllerModel = this.buildController(event.data);
-+        controller.add(controllerModel);
-+        this.notifyControllerAdded(controller);
-+      });
-+
-+      controller.removeEventListener('disconnected', () => {
-+        controller.remove(...controller.children);
-+        this.notifyControllerRemoved(controller);
-+      });
-     });
- 
-     this.controllerGrips.forEach(grip => {
-       grip.remove(...grip.children);
-     });
- 
--    // Clean up AR group
--    this.arGroup.remove(...this.arGroup.children);
--    this.cameraRig.remove(this.arGroup);
-+    this.hitTestSource?.cancel();
-+    this.hitTestSource = null;
-+    this.hitTestSourceRequested = false;
- 
--    // Clean up camera rig
--    this.cameraRig.remove(...this.cameraRig.children);
--    
--    const scene = this.sceneManager.getScene();
--    scene.remove(this.cameraRig);
--
--    // Dispose geometries and materials
--    this.gridHelper.geometry.dispose();
--    (this.gridHelper.material as THREE.Material).dispose();
--    this.groundPlane.geometry.dispose();
--    (this.groundPlane.material as THREE.Material).dispose();
--    this.hitTestMarker.geometry.dispose();
--    (this.hitTestMarker.material as THREE.Material).dispose();
-+    this.session = null;
-+    this.referenceSpace = null;
-+    this.isPresenting = false;
-   }
- }
-diff --git a/client/xr/xrTypes.ts b/client/xr/xrTypes.ts
-new file mode 100644
-index 00000000..556eb0af
---- /dev/null
-+++ b/client/xr/xrTypes.ts
-@@ -0,0 +1,25 @@
-+import * as THREE from 'three';
-+
-+export interface XRHandWithHaptics {
-+    hand: {
-+        joints: {
-+            [key: string]: THREE.Object3D;
-+        };
-+    };
-+    hapticActuators: any[];
-+    pinchStrength: number;
-+    gripStrength: number;
-+}
-+
-+export interface XRControllerState {
-+    position: THREE.Vector3;
-+    rotation: THREE.Quaternion;
-+    hapticActuator?: any;
-+}
-+
-+export interface XRHandState {
-+    position: THREE.Vector3;
-+    joints: Map<string, THREE.Object3D>;
-+    pinchStrength: number;
-+    gripStrength: number;
-+}
-diff --git a/settings.md b/settings.md
-new file mode 100644
-index 00000000..61225f8f
---- /dev/null
-+++ b/settings.md
-@@ -0,0 +1,590 @@
-+take a look at @/client/implementationPlan.md and @/NETWORK_SETUP.md and @/settings.toml and map out in very high detail how the settings are connected to the visual aspects of the client force directed graph.
-+
-+
-+I'll analyze how the settings in settings.toml connect to the visual aspects of the client force directed graph. I'll focus on the key sections that directly impact visualization and map out their relationships.
-+
-+Let me break this down into the main visual categories and their connections:
-+
-+Node Appearance & Behavior
-+Edge Visualization
-+Physics & Layout
-+Visual Effects (Bloom, etc.)
-+Labels & Text
-+Environment & Scene
-+
-+Task Completed
-+Detailed Mapping of Settings to Visual Aspects:
-+
-+Node Visualization [nodes]
-+
-+Core Appearance:
-+base_size (0.2): Default node sphere size
-+base_color ("#FFB700"): Default node color
-+geometry_segments (32): Sphere quality/smoothness
-+material_type ("physical"): Three.js material type for realistic rendering
-+Material Properties:
-+metalness (0.85): Reflective quality of nodes
-+roughness (0.15): Surface smoothness
-+clearcoat (1.0): Additional glossy layer
-+opacity (0.92): Node transparency
-+Dynamic Sizing:
-+size_by_connections (true): Nodes grow based on connection count
-+size_range ([0.2, 0.5]): Min/max node sizes
-+Color Scheme:
-+color_scheme ("age"): Nodes colored by creation date
-+new_node_color ("#FFD700"): Recently created nodes
-+old_node_color ("#E6A640"): Older nodes
-+core_node_color ("#FFC125"): Central/important nodes
-+secondary_node_color ("#FFD147"): Supporting nodes
-+Interaction Effects:
-+enable_hover_effect (true): Visual feedback on mouse hover
-+hover_scale (1.15): Size increase on hover
-+highlight_color ("#FFFFFF"): Color when selected
-+highlight_duration (350): Animation time in ms
-+highlight_intensity (3.0): Brightness of highlight
-+Edge Visualization [edges]
-+
-+Basic Properties:
-+base_width (2.0): Default edge line thickness
-+color ("#FFD700"): Default edge color
-+opacity (0.6): Edge transparency
-+curve_segments (24): Smoothness of curved edges
-+Dynamic Width:
-+width_by_strength (true): Edges thicken based on connection strength
-+width_range ([2.0, 8.0]): Min/max edge widths
-+Directional Indicators:
-+enable_arrows (true): Show direction arrows
-+arrow_size (0.15): Size of direction indicators
-+Glow Effects:
-+enable_glow (true): Edge light emission
-+glow_color ("#FFD700"): Color of glow effect
-+glow_intensity (0.7): Strength of glow
-+Physics & Layout [physics]
-+
-+Force Simulation:
-+attraction_strength (0.015): Pull between connected nodes
-+repulsion_strength (1500.0): Push between all nodes
-+spring_strength (0.018): Edge tension force
-+damping (0.88): Movement slowdown factor
-+Boundaries:
-+bounds_size (12.0): Size of containment area
-+enable_bounds (true): Keep nodes within bounds
-+collision_radius (0.25): Node collision detection
-+max_velocity (2.5): Speed limit for node movement
-+Visual Effects
-+[bloom]
-+
-+Glow Effects:
-+enabled (true): Overall bloom effect
-+strength (1.8): Intensity of glow
-+radius (0.5): Spread of glow
-+threshold (0.15): Minimum brightness for bloom
-+node_bloom_strength (1.8): Node-specific glow
-+edge_bloom_strength (1.4): Edge-specific glow
-+[animations]
-+
-+Node Animations:
-+enable_node_animations (true): Allow movement animations
-+animation_smoothing (0.92): Movement interpolation
-+motion_blur_strength (0.4): Movement trail effect
-+Edge Effects:
-+edge_pulse_enabled (true): Pulsing edge effect
-+edge_pulse_color ("#FFD700"): Pulse highlight color
-+edge_pulse_frequency (0.5): Pulse speed
-+edge_pulse_width (0.2): Thickness of pulse
-+Labels & Text [labels]
-+
-+Text Display:
-+enable_labels (true): Show node labels
-+desktop_font_size (48): Label text size
-+font_family ("Arial"): Text font
-+text_color ("#FFFFFF"): Label color
-+Label Positioning:
-+vertical_offset (2.8): Text height above node
-+padding (28): Space around text
-+max_visible_labels (75): Performance limit
-+Visibility:
-+depth_fade_start (7.0): Distance to start fading
-+depth_fade_end (25.0): Distance of full fade
-+view_angle_fade (0.7): Fade based on viewing angle
-+Environment & Scene [rendering]
-+
-+Lighting:
-+ambient_light_intensity (0.7): Overall scene brightness
-+directional_light_intensity (1.0): Main light strength
-+environment_intensity (1.2): HDR environment lighting
-+Scene Quality:
-+enable_antialiasing (true): Edge smoothing
-+enable_shadows (true): Shadow casting
-+shadow_map_size (4096): Shadow quality
-+pixel_ratio (1.5): Rendering resolution multiplier
-+Atmosphere:
-+background_color ("#000000"): Scene background
-+fog_enabled (true): Distance fade effect
-+fog_color ("#000000"): Fog color
-+fog_density (0.0008): Fog thickness
-+Reference Grid:
-+enable_grid (true): Show ground grid
-+grid_color ("#1A1A1A"): Grid line color
-+grid_size (10): Grid extent
-+grid_divisions (20): Grid line density
-+This mapping shows how settings.toml provides fine-grained control over every visual aspect of the force-directed graph, from core rendering properties to subtle animation effects. The settings are structured to allow both high-level control (enabling/disabling features) and detailed customization (specific colors, sizes, and behaviors).
-+
-+
-+trace the flow of the data through the server into json and over the websockets into the client code. Ensure that all critical visualisation aspects are handled
-+
-+
-+I'll trace the data flow from server to client, focusing on visualization aspects. I'll analyze:
-+
-+Server-side data preparation
-+WebSocket protocol and data formats
-+Client-side data handling and visualization pipeline
-+How settings and real-time updates are managed
-+From the implementation plan and network setup docs, I can see this involves multiple layers of data transformation and handling.
-+
-+
-+Task Completed
-+Data Flow Trace for Visualization Pipeline:
-+
-+Server-Side Data Preparation (Rust Backend)
-+
-+A. Initial Graph Data (/src/handlers/graph_handler.rs)
-+
-+// Graph data is prepared as two main components:
-+struct GraphData {
-+    nodes: Vec<Node>,      // Node positions and metadata
-+    edges: Vec<Edge>,      // Edge connections and weights
-+}
-+
-+// Each node contains:
-+struct Node {
-+    position: [f32; 3],    // Vector3 position
-+    velocity: [f32; 3],    // Vector3 velocity
-+    metadata: NodeMetadata // Labels, colors, etc.
-+}
-+B. Binary Position Updates
-+
-+Positions/velocities packed as 24-byte chunks (6 x f32)
-+Format: [px, py, pz, vx, vy, vz] per node
-+Optimized for GPU consumption via CUDA/WGSL
-+WebSocket Protocol (/src/handlers/visualization_handler.rs)
-+
-+A. Initial Connection
-+
-+// 1. Settings sent as JSON
-+send_json({
-+    type: "settings",
-+    data: settings_toml_as_json
-+});
-+
-+// 2. Full graph sent as JSON
-+send_json({
-+    type: "graph",
-+    data: {
-+        nodes: [...],
-+        edges: [...]
-+    }
-+});
-+B. Real-time Updates
-+
-+// Binary position updates (90Hz from settings.toml)
-+send_binary(packed_f32_array);
-+
-+// Metadata updates as JSON
-+send_json({
-+    type: "update",
-+    data: {
-+        nodes: [changed_nodes],
-+        edges: [changed_edges]
-+    }
-+});
-+Client-Side Data Pipeline (/client/)
-+
-+A. WebSocket Service (websocket/websocketService.ts)
-+
-+class WebSocketService {
-+    // Handles binary position data
-+    onBinaryMessage(data: ArrayBuffer) {
-+        const positions = new Float32Array(data);
-+        graphData.updatePositions(positions);
-+    }
-+    
-+    // Handles JSON metadata
-+    onJsonMessage(data: any) {
-+        switch(data.type) {
-+            case "settings":
-+                settingsManager.update(data.data);
-+                break;
-+            case "graph":
-+                graphData.setInitialState(data.data);
-+                break;
-+            case "update":
-+                graphData.applyUpdates(data.data);
-+                break;
-+        }
-+    }
-+}
-+B. Graph Data Management (state/graphData.ts)
-+
-+class GraphDataManager {
-+    private nodes: Map<string, NodeData>;
-+    private edges: Map<string, EdgeData>;
-+    
-+    // Updates node positions from binary data
-+    updatePositions(positions: Float32Array) {
-+        // Direct GPU buffer update if possible
-+        this.nodeBuffer.updateData(positions);
-+        // Or update Three.js instances
-+        this.updateInstanceMatrices(positions);
-+    }
-+    
-+    // Applies metadata updates
-+    applyUpdates(updates: UpdateData) {
-+        this.updateNodeVisuals(updates.nodes);
-+        this.updateEdgeVisuals(updates.edges);
-+    }
-+}
-+C. Rendering Pipeline (rendering/)
-+
-+scene.ts:
-+
-+class SceneManager {
-+    private renderer: THREE.WebGLRenderer;
-+    private nodeSystem: NodeSystem;
-+    private edgeSystem: EdgeSystem;
-+    
-+    // Main render loop (synced to settings.websocket.update_rate)
-+    render() {
-+        // Update physics if enabled
-+        if (settings.physics.enabled) {
-+            this.updatePhysics();
-+        }
-+        
-+        // Update visual elements
-+        this.nodeSystem.update();
-+        this.edgeSystem.update();
-+        
-+        // Apply post-processing
-+        if (settings.bloom.enabled) {
-+            this.applyBloomEffect();
-+        }
-+        
-+        // Handle labels
-+        this.updateLabels();
-+        
-+        // Render frame
-+        this.renderer.render(scene, camera);
-+    }
-+}
-+nodes.ts:
-+
-+class NodeSystem {
-+    private geometry: THREE.InstancedBufferGeometry;
-+    private material: THREE.MeshPhysicalMaterial;
-+    
-+    updateNodes() {
-+        // Update visual properties from settings
-+        this.material.metalness = settings.nodes.metalness;
-+        this.material.roughness = settings.nodes.roughness;
-+        
-+        // Update colors based on scheme
-+        this.updateColorScheme(settings.nodes.color_scheme);
-+        
-+        // Update sizes
-+        if (settings.nodes.size_by_connections) {
-+            this.updateSizesByConnections();
-+        }
-+        
-+        // Apply animations
-+        if (settings.animations.enable_node_animations) {
-+            this.animateNodes();
-+        }
-+    }
-+}
-+edges.ts:
-+
-+class EdgeSystem {
-+    private geometry: THREE.BufferGeometry;
-+    private material: THREE.LineBasicMaterial;
-+    
-+    updateEdges() {
-+        // Update edge visuals from settings
-+        this.material.opacity = settings.edges.opacity;
-+        
-+        // Update widths
-+        if (settings.edges.width_by_strength) {
-+            this.updateLineWidths();
-+        }
-+        
-+        // Update arrows if enabled
-+        if (settings.edges.enable_arrows) {
-+            this.updateArrows();
-+        }
-+        
-+        // Apply edge effects
-+        if (settings.edges.enable_glow) {
-+            this.updateEdgeGlow();
-+        }
-+    }
-+}
-+Critical Visualization Aspects Handled:
-+
-+A. Performance Optimizations
-+
-+Binary position updates at 90Hz (settings.websocket.update_rate)
-+Instanced rendering for nodes
-+GPU-accelerated physics when available
-+Label count limiting (settings.labels.max_visible_labels)
-+B. Visual Quality
-+
-+Bloom post-processing
-+Anti-aliasing
-+Shadow mapping
-+Proper depth sorting for transparency
-+C. Real-time Updates
-+
-+Smooth position interpolation
-+Efficient metadata updates
-+Batched visual updates
-+Animation system for transitions
-+D. Memory Management
-+
-+Geometry instancing
-+Texture atlasing for labels
-+Efficient buffer updates
-+Proper disposal of Three.js resources
-+This trace shows how visualization data flows from the server through WebSocket channels and is processed by various client systems while maintaining high performance and visual quality according to the settings configuration.
-+
-+
-+ok, now examine how the control panel allows writing to the settings toml over the json websocket interface to adapt the look of the system
-+
-+
-+I'll analyze how the control panel interacts with settings.toml through the WebSocket interface. From the implementation plan, I can see this is part of the desktop UI that's being rebuilt. I'll trace:
-+
-+Control panel structure and settings interface
-+WebSocket message protocol for settings updates
-+Server-side settings handling
-+Real-time visual updates
-+
-+Task Completed
-+Settings Control Flow Analysis:
-+
-+Desktop Control Panel Implementation (client/ui/settingsPanel.ts)
-+class SettingsPanel {
-+    private settings: VisualizationSettings;
-+    private websocket: WebSocketService;
-+    
-+    // Groups settings into logical control sections
-+    private controlGroups = {
-+        nodes: {
-+            label: "Node Appearance",
-+            controls: [
-+                {
-+                    id: "nodes.base_size",
-+                    type: "slider",
-+                    label: "Base Size",
-+                    min: 0.1,
-+                    max: 1.0,
-+                    step: 0.1
-+                },
-+                {
-+                    id: "nodes.base_color",
-+                    type: "color",
-+                    label: "Base Color"
-+                },
-+                // ... other node controls
-+            ]
-+        },
-+        edges: {
-+            label: "Edge Appearance",
-+            controls: [/* edge controls */]
-+        },
-+        physics: {
-+            label: "Physics Settings",
-+            controls: [/* physics controls */]
-+        },
-+        // ... other control groups
-+    };
-+
-+    // Handles control value changes
-+    private async handleSettingChange(path: string, value: any) {
-+        // Update local settings
-+        this.updateSettingByPath(path, value);
-+        
-+        // Send update to server
-+        await this.websocket.send({
-+            type: "settings_update",
-+            data: {
-+                path,
-+                value
-+            }
-+        });
-+    }
-+
-+    // Batch multiple settings changes
-+    private async saveAllSettings() {
-+        await this.websocket.send({
-+            type: "settings_bulk_update",
-+            data: this.settings
-+        });
-+    }
-+}
-+WebSocket Protocol for Settings Updates
-+A. Client to Server Messages:
-+
-+// Single setting update
-+interface SettingsUpdateMessage {
-+    type: "settings_update";
-+    data: {
-+        path: string;    // e.g. "nodes.base_size"
-+        value: any;      // New value
-+    }
-+}
-+
-+// Bulk settings update
-+interface SettingsBulkUpdateMessage {
-+    type: "settings_bulk_update";
-+    data: VisualizationSettings;
-+}
-+B. Server to Client Messages:
-+
-+// Settings confirmation
-+interface SettingsConfirmation {
-+    type: "settings_updated";
-+    data: {
-+        success: boolean;
-+        error?: string;
-+    }
-+}
-+
-+// Broadcast updated settings
-+interface SettingsBroadcast {
-+    type: "settings_changed";
-+    data: VisualizationSettings;
-+}
-+Server-Side Settings Handler (src/handlers/visualization_handler.rs)
-+pub struct VisualizationHandler {
-+    settings: Arc<RwLock<Settings>>,
-+    clients: Arc<RwLock<HashMap<ClientId, WebSocket>>>,
-+}
-+
-+impl VisualizationHandler {
-+    // Handle incoming settings updates
-+    async fn handle_settings_update(&self, msg: SettingsUpdate) -> Result<()> {
-+        // Update settings.toml
-+        {
-+            let mut settings = self.settings.write().await;
-+            settings.update_path(&msg.path, msg.value)?;
-+            settings.save_to_file("settings.toml")?;
-+        }
-+
-+        // Broadcast to all clients
-+        self.broadcast_settings().await?;
-+        
-+        Ok(())
-+    }
-+
-+    // Handle bulk settings updates
-+    async fn handle_bulk_settings_update(&self, settings: Settings) -> Result<()> {
-+        // Validate settings
-+        settings.validate()?;
-+
-+        // Update settings.toml
-+        {
-+            let mut current = self.settings.write().await;
-+            *current = settings;
-+            current.save_to_file("settings.toml")?;
-+        }
-+
-+        // Broadcast to all clients
-+        self.broadcast_settings().await?;
-+        
-+        Ok(())
-+    }
-+
-+    // Broadcast settings to all clients
-+    async fn broadcast_settings(&self) -> Result<()> {
-+        let settings = self.settings.read().await;
-+        let msg = json!({
-+            "type": "settings_changed",
-+            "data": settings.to_json()
-+        });
-+
-+        for client in self.clients.read().await.values() {
-+            client.send(msg.clone()).await?;
-+        }
-+        
-+        Ok(())
-+    }
-+}
-+Real-Time Visual Updates (client/state/settings.ts)
-+class SettingsManager {
-+    private settings: VisualizationSettings;
-+    private subscribers: Map<string, (value: any) => void>;
-+
-+    // Handle incoming settings updates
-+    handleSettingsChanged(newSettings: VisualizationSettings) {
-+        this.settings = newSettings;
-+        this.notifySubscribers();
-+    }
-+
-+    // Subscribe to settings changes
-+    subscribe(path: string, callback: (value: any) => void) {
-+        this.subscribers.set(path, callback);
-+    }
-+
-+    // Notify all subscribers of changes
-+    private notifySubscribers() {
-+        for (const [path, callback] of this.subscribers) {
-+            const value = this.getSettingByPath(path);
-+            callback(value);
-+        }
-+    }
-+}
-+
-+// Example subscribers in visualization systems
-+class NodeSystem {
-+    constructor(settingsManager: SettingsManager) {
-+        // Subscribe to relevant settings
-+        settingsManager.subscribe("nodes.base_size", this.updateNodeSize);
-+        settingsManager.subscribe("nodes.base_color", this.updateNodeColor);
-+        settingsManager.subscribe("nodes.material_type", this.updateMaterial);
-+    }
-+
-+    private updateNodeSize = (size: number) => {
-+        this.geometry.scale.setScalar(size);
-+        this.geometry.instanceMatrix.needsUpdate = true;
-+    };
-+
-+    private updateNodeColor = (color: string) => {
-+        this.material.color.set(color);
-+        this.material.needsUpdate = true;
-+    };
-+
-+    private updateMaterial = (type: string) => {
-+        this.recreateMaterial(type);
-+    };
-+}
-+Settings Update Flow:
-+sequenceDiagram
-+    participant CP as Control Panel
-+    participant WS as WebSocket Service
-+    participant SRV as Server
-+    participant TOML as settings.toml
-+    participant VIS as Visualization
-+
-+    CP->>WS: settings_update
-+    WS->>SRV: Send update message
-+    SRV->>TOML: Write new settings
-+    SRV->>WS: Broadcast settings_changed
-+    WS->>VIS: Update visualization
-+    VIS->>CP: Reflect changes in UI
-+This system ensures:
-+
-+Real-time visual updates when settings change
-+Persistence of settings in settings.toml
-+Synchronization across all connected clients
-+Type-safe settings updates with validation
-+Efficient batching of multiple settings changes
-+Immediate visual feedback in the control panel
-+The control panel provides a user-friendly interface to modify settings while maintaining the integrity of the settings.toml file and ensuring all clients stay synchronized with the latest visualization parameters.
-\ No newline at end of file
diff --git a/settings.toml b/settings.toml
index 27a1ed81..dd132050 100644
--- a/settings.toml
+++ b/settings.toml
@@ -1,112 +1,4 @@
-[animations]
-animation_quality = "high"
-animation_smoothing = 0.92
-edge_animation_enabled = true
-edge_pulse_amplitude = 0.3
-edge_pulse_color = "#FFD700"
-edge_pulse_enabled = true
-edge_pulse_frequency = 0.5
-edge_pulse_width = 0.2
-enable_motion_blur = true
-enable_node_animations = true
-flow_particle_color = "#FFD700"
-flow_particle_count = 5
-flow_particle_size = 0.02
-flow_particle_speed = 0.8
-flow_particle_trail = true
-flow_particle_trail_length = 0.2
-flow_particles_enabled = true
-max_concurrent_animations = 10
-motion_blur_strength = 0.4
-pulse_amplitude = 0.15
-pulse_color = "#FFD700"
-pulse_enabled = true
-pulse_frequency = 0.8
-ripple_color = "#FFD700"
-ripple_decay = 0.85
-ripple_enabled = true
-ripple_segments = 32
-ripple_size = 0.4
-ripple_speed = 1.0
-selection_wave_color = "#FFD700"
-selection_wave_enabled = true
-selection_wave_opacity = 0.4
-selection_wave_size = 0.5
-selection_wave_speed = 1.2
-
-[ar]
-drag_threshold = 0.04
-enable_hand_tracking = true
-enable_haptics = true
-enable_light_estimation = true
-enable_plane_detection = true
-enable_scene_understanding = true
-gesture_smoothing = 0.9
-hand_mesh_color = "#FFD700"
-hand_mesh_enabled = true
-hand_mesh_opacity = 0.3
-hand_point_size = 0.01
-hand_ray_color = "#FFD700"
-hand_ray_enabled = true
-hand_ray_width = 0.002
-hand_trail_enabled = true
-hand_trail_length = 0.5
-hand_trail_opacity = 0.3
-haptic_intensity = 0.7
-pinch_threshold = 0.015
-room_scale = true
-rotation_threshold = 0.08
-snap_to_floor = true
-
-[audio]
-ambient_variation = 0.1
-ambient_volume = 0.2
-audio_rolloff = "logarithmic"
-collision_frequency = 220
-creation_frequency = 550
-deletion_frequency = 275
-doppler_factor = 0.5
-edge_creation_sound = true
-edge_creation_volume = 0.5
-edge_deletion_sound = true
-edge_deletion_volume = 0.4
-edge_flow_sound = true
-edge_flow_volume = 0.3
-enable_ambient_sounds = true
-enable_interaction_sounds = true
-enable_spatial_audio = true
-flow_frequency = 385
-hover_frequency = 330
-hover_sound_enabled = true
-hover_sound_volume = 0.4
-master_volume = 0.8
-max_audio_distance = 20.0
-node_collision_sound = true
-node_collision_volume = 0.5
-node_creation_sound = true
-node_creation_volume = 0.6
-node_deletion_sound = true
-node_deletion_volume = 0.5
-selection_frequency = 440
-selection_sound_enabled = true
-selection_sound_volume = 0.7
-
-[bloom]
-edge_bloom_strength = 1.4
-enabled = true
-environment_bloom_strength = 1.2
-node_bloom_strength = 1.8
-radius = 0.5
-strength = 1.8
-threshold = 0.15
-
-[client_debug]
-enable_data_debug = false
-enable_websocket_debug = false
-enabled = false
-log_binary_headers = false
-log_full_json = false
-
+# Core Configuration
 [default]
 api_client_timeout = 30
 enable_metrics = true
@@ -119,47 +11,7 @@ max_retries = 3
 metrics_port = 9090
 retry_delay = 5
 
-[edges]
-arrow_size = 0.15
-base_width = 2.0
-color = "#FFD700"
-curve_segments = 24
-enable_arrows = true
-enable_glow = true
-glow_color = "#FFD700"
-glow_intensity = 0.7
-highlight_color = "#FFFFFF"
-opacity = 0.6
-width_by_strength = true
-width_range = [
-    2.0,
-    8.0,
-]
-
-[github]
-base_path = "default_path"
-owner = "default_owner"
-rate_limit = true
-repo = "default_repo"
-token = "default_token"
-
-[labels]
-ar_font_size = 32
-background_color = "#000000"
-background_opacity = 0.92
-close_offset = 0.3
-depth_fade_end = 25.0
-depth_fade_start = 7.0
-desktop_font_size = 48
-enable_labels = true
-font_family = "Arial"
-info_color = "#E6E6E6"
-max_visible_labels = 75
-padding = 28
-text_color = "#FFFFFF"
-vertical_offset = 2.8
-view_angle_fade = 0.7
-
+# Network Settings
 [network]
 bind_address = "0.0.0.0"
 domain = "localhost"
@@ -173,117 +25,99 @@ rate_limit_requests = 100
 rate_limit_window = 60
 tunnel_id = "dummy"
 
+# Security Settings
+[security]
+allowed_origins = []
+audit_log_path = "/app/logs/audit.log"
+cookie_httponly = true
+cookie_samesite = "Strict"
+cookie_secure = true
+csrf_token_timeout = 3600
+enable_audit_logging = true
+enable_request_validation = true
+session_timeout = 3600
+
+# Rendering Settings
+[rendering]
+ambient_light_intensity = 0.7
+background_color = "#000000"
+directional_light_intensity = 1.0
+enable_ambient_occlusion = true
+enable_antialiasing = true
+enable_shadows = true
+environment_intensity = 1.2
+
+# AR Settings
+[ar]
+enable_hand_tracking = true
+enable_haptics = true
+enable_plane_detection = true
+
+# Nodes Configuration
 [nodes]
-age_max_days = 30
 base_color = "#FFB700"
-base_size = 0.2
-clearcoat = 1.0
-clearcoat_roughness = 0.05
-color_scheme = "age"
-core_node_color = "#FFC125"
-enable_hover_effect = true
+base_size = 1
+size_range = [1, 5]
+size_by_connections = true
 enable_instancing = true
-enable_transparency = true
-geometry_segments = 32
-highlight_color = "#FFFFFF"
-highlight_duration = 350
-highlight_intensity = 3.0
-hover_scale = 1.15
 material_type = "physical"
-metalness = 0.85
-new_node_color = "#FFD700"
-old_node_color = "#E6A640"
 opacity = 0.92
 roughness = 0.15
-secondary_node_color = "#FFD147"
-size_by_connections = true
-size_range = [
-    0.2,
-    0.5,
-]
-
-[openai]
-api_key = "default_openai_key"
-base_url = "wss://api.openai.com/v1/realtime"
-model = "gpt-4o-realtime-preview-2024-10-01"
-rate_limit = 100
-timeout = 30
+metalness = 0.85
+clearcoat = 1
+highlight_color = "#FFFFFF"
+highlight_duration = 500
+enable_hover_effect = true
+hover_scale = 1.2
 
-[perplexity]
-api_key = "default_perplexity_key"
-api_url = "https://api.perplexity.ai/chat/completions"
-frequency_penalty = 1.0
-max_tokens = 4096
-model = "llama-3.1-sonar-small-128k-online"
-presence_penalty = 0.0
-prompt = """
-You are an AI assistant for LogSeq knowledge summaries via perplexity API. Style: Informative, analytical, optimistic, critical, conversational, authoritative. Markdown: hierarchical headings (- #), minimal bold, italics for book titles, descriptive links [URL](text), images ![alt](path){:width height}, embeds {{type id}}, lists with '-', block refs [[title]], properties property:: value, code blocks ```lang``` and `inline code`, \r
- newlines, public:: true at start/end. UK spelling, introduce acronyms once, numeric citations, [[reference]] for sources, minimal emojis, parentheses for asides, collapsed:: true. Focus on emerging tech (decentralization, AI, XR), detail, credible sources, implications, examples, future-oriented. Adhere strictly, ensure accuracy, consistency, large context, refine with feedback."""
-rate_limit = 100
-temperature = 0.5
-timeout = 30
-top_p = 0.9
+# Edges Configuration
+[edges]
+base_width = 2
+width_range = [1.0, 3.0]
+color = "#FFD700"
+opacity = 0.6
 
+# Physics Settings
 [physics]
 attraction_strength = 0.015
 bounds_size = 12.0
 collision_radius = 0.25
 damping = 0.88
 enable_bounds = true
-enable_collision = true
 enabled = true
 iterations = 500
 max_velocity = 2.5
 repulsion_strength = 1500.0
 spring_strength = 0.018
 
-[ragflow]
-api_key = "default_ragflow_key"
-base_url = "http://ragflow-server/v1/"
-max_retries = 3
-timeout = 30
-
-[rendering]
-ambient_light_intensity = 0.7
-background_color = "#000000"
-directional_light_intensity = 1.0
-enable_ambient_occlusion = true
-enable_antialiasing = true
-enable_gpu_acceleration = true
-enable_grid = true
-enable_hemisphere_light = true
-enable_shadows = true
-environment_intensity = 1.2
-fog_color = "#000000"
-fog_density = 0.0008
-fog_enabled = true
-grid_color = "#1A1A1A"
-grid_divisions = 20
-grid_size = 10
-pixel_ratio = 1.5
-shadow_map_size = 4096
+# Bloom Effects
+[bloom]
+enabled = false
+node_bloom_strength = 0.2
+edge_bloom_strength = 0.3
+environment_bloom_strength = 0.5
 
-[security]
-allowed_origins = []
-audit_log_path = "/app/logs/audit.log"
-cookie_httponly = true
-cookie_samesite = "Strict"
-cookie_secure = true
-csrf_token_timeout = 3600
-enable_audit_logging = true
-enable_cors = false
-enable_csrf = false
-enable_request_validation = true
-enable_security_headers = false
-session_timeout = 3600
+# Labels Configuration
+[labels]
+enable_labels = true
+text_color = "#FFFFFF"
 
-[server_debug]
-enable_data_debug = false
-enable_websocket_debug = false
-enabled = true
-log_binary_headers = false
-log_full_json = false
+# Animation Settings
+[animations]
+enable_node_animations = false
+selection_wave_enabled = false
+pulse_enabled = false
+ripple_enabled = false
+edge_animation_enabled = false
+flow_particles_enabled = false
+
+# Audio Settings
+[audio]
+enable_spatial_audio = false
+enable_interaction_sounds = false
+enable_ambient_sounds = false
 
+# WebSocket Configuration
 [websocket]
 binary_chunk_size = 65536
 compression_enabled = true
@@ -295,3 +129,53 @@ max_message_size = 100485760
 reconnect_attempts = 3
 reconnect_delay = 5000
 update_rate = 90
+
+# Debugging Settings
+[server_debug]
+enable_data_debug = false
+enable_websocket_debug = false
+enabled = true
+log_binary_headers = false
+log_full_json = false
+
+[client_debug]
+enable_data_debug = false
+enable_websocket_debug = false
+enabled = false
+log_binary_headers = false
+log_full_json = false
+
+# Integrations
+[github]
+base_path = "default_path"
+owner = "default_owner"
+rate_limit = true
+repo = "default_repo"
+token = "default_token"
+
+[openai]
+api_key = "default_openai_key"
+base_url = "wss://api.openai.com/v1/realtime"
+model = "gpt-4o-realtime-preview-2024-10-01"
+rate_limit = 100
+timeout = 30
+
+[perplexity]
+api_key = "default_perplexity_key"
+api_url = "https://api.perplexity.ai/chat/completions"
+frequency_penalty = 1.0
+max_tokens = 4096
+model = "llama-3.1-sonar-small-128k-online"
+resence_penalty = 0.0
+prompt = """
+You are an AI assistant for LogSeq knowledge summaries via perplexity API. Style: Informative, analytical, optimistic, critical, conversational, authoritative. Markdown: hierarchical headings (- #), minimal bold, italics for book titles, descriptive links [URL](text), images ![alt](path){:width height}, embeds {{type id}}, lists with '-', block refs [[title]], properties property:: value, code blocks ```lang``` and `inline code`, \r newlines, public:: true at start. UK spelling, introduce acronyms once, numeric citations, [[reference]] for sources, minimal emojis, parentheses for asides, collapsed:: true. Focus on emerging tech (decentralization, AI, XR), detail, credible sources, implications, examples, future-oriented. Adhere strictly, ensure accuracy, consistency, large context, refine with feedback."""
+rate_limit = 100
+temperature = 0.5
+timeout = 30
+top_p = 0.9
+
+[ragflow]
+api_key = "default_ragflow_key"
+base_url = "http://ragflow-server/v1/"
+max_retries = 3
+timeout = 30
diff --git a/src/config.rs b/src/config.rs
index 33fddd67..f2246524 100755
--- a/src/config.rs
+++ b/src/config.rs
@@ -3,118 +3,51 @@ use config::{ConfigBuilder, ConfigError, Environment, File};
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct Settings {
-    pub server_debug: DebugSettings,
-    pub client_debug: DebugSettings,
+    pub default: DefaultSettings,
     pub network: NetworkSettings,
     pub security: SecuritySettings,
-    pub github: GitHubSettings,
-    pub ragflow: RagFlowSettings,
-    pub perplexity: PerplexitySettings,
-    pub openai: OpenAISettings,
-    pub default: DefaultSettings,
     pub rendering: RenderingSettings,
+    pub ar: ARSettings,
     pub nodes: NodeSettings,
     pub edges: EdgeSettings,
-    pub labels: LabelSettings,
-    pub bloom: BloomSettings,
-    pub ar: ARSettings,
     pub physics: PhysicsSettings,
+    pub bloom: BloomSettings,
+    pub labels: LabelSettings,
+    pub websocket: WebSocketSettings,
+    pub server_debug: DebugSettings,
+    pub client_debug: DebugSettings,
+    pub github: GitHubSettings,
+    pub openai: OpenAISettings,
+    pub perplexity: PerplexitySettings,
+    pub ragflow: RagFlowSettings,
     pub animations: AnimationSettings,
     pub audio: AudioSettings,
-    pub websocket: WebSocketSettings,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct WebSocketSettings {
-    #[serde(default = "default_compression_enabled")]
-    pub compression_enabled: bool,
-    #[serde(default = "default_compression_threshold")]
-    pub compression_threshold: usize,
-    #[serde(default = "default_max_message_size")]
-    pub max_message_size: usize,
-    #[serde(default = "default_update_rate")]
-    pub update_rate: u32,
-    #[serde(default = "default_heartbeat_interval")]
-    pub heartbeat_interval: u64,
-    #[serde(default = "default_heartbeat_timeout")]
-    pub heartbeat_timeout: u64,
-    #[serde(default = "default_max_connections")]
-    pub max_connections: usize,
-    #[serde(default = "default_reconnect_attempts")]
-    pub reconnect_attempts: u32,
-    #[serde(default = "default_reconnect_delay")]
-    pub reconnect_delay: u64,
-    #[serde(default = "default_binary_chunk_size")]
-    pub binary_chunk_size: usize,
 }
 
-// Default functions for WebSocket settings
-fn default_compression_enabled() -> bool { true }
-fn default_compression_threshold() -> usize { 1024 }  // 1KB
-fn default_max_message_size() -> usize { 100 * 1024 * 1024 }  // 100MB
-fn default_update_rate() -> u32 { 5 }  // 5fps
-fn default_heartbeat_interval() -> u64 { 15000 }  // 15 seconds
-fn default_heartbeat_timeout() -> u64 { 60000 }  // 60 seconds
-fn default_max_connections() -> usize { 1000 }
-fn default_reconnect_attempts() -> u32 { 3 }
-fn default_reconnect_delay() -> u64 { 5000 }  // 5 seconds
-fn default_binary_chunk_size() -> usize { 64 * 1024 }  // 64KB
-
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct DebugSettings {
-    pub enabled: bool,
-    pub enable_websocket_debug: bool,
-    pub enable_data_debug: bool,
-    pub log_binary_headers: bool,
-    pub log_full_json: bool,
-}
-
-impl Default for DebugSettings {
-    fn default() -> Self {
-        Self {
-            enabled: false,
-            enable_websocket_debug: false,
-            enable_data_debug: false,
-            log_binary_headers: false,
-            log_full_json: false,
-        }
-    }
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct GitHubSettings {
-    #[serde(default = "default_token")]
-    pub token: String,
-    
-    #[serde(default = "default_owner")]
-    pub owner: String,
-    
-    #[serde(default = "default_repo")]
-    pub repo: String,
-    
-    #[serde(default = "default_path")]
-    pub base_path: String,
-    
-    #[serde(default = "default_rate_limit")]
-    pub rate_limit: bool,
+pub struct DefaultSettings {
+    pub api_client_timeout: u64,
+    pub enable_metrics: bool,
+    pub enable_request_logging: bool,
+    pub log_format: String,
+    pub log_level: String,
+    pub max_concurrent_requests: usize,
+    pub max_payload_size: usize,
+    pub max_retries: u32,
+    pub metrics_port: u16,
+    pub retry_delay: u64,
 }
 
-fn default_token() -> String { "".to_string() }
-fn default_owner() -> String { "".to_string() }
-fn default_repo() -> String { "".to_string() }
-fn default_path() -> String { "".to_string() }
-fn default_rate_limit() -> bool { true }
-
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct NetworkSettings {
-    pub domain: String,
-    pub port: u16,
     pub bind_address: String,
-    pub enable_tls: bool,
-    pub min_tls_version: String,
+    pub domain: String,
     pub enable_http2: bool,
-    pub max_request_size: usize,
     pub enable_rate_limiting: bool,
+    pub enable_tls: bool,
+    pub max_request_size: usize,
+    pub min_tls_version: String,
+    pub port: u16,
     pub rate_limit_requests: u32,
     pub rate_limit_window: u32,
     pub tunnel_id: String,
@@ -122,110 +55,48 @@ pub struct NetworkSettings {
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct SecuritySettings {
-    pub enable_cors: bool,
     pub allowed_origins: Vec<String>,
-    pub enable_csrf: bool,
-    pub csrf_token_timeout: u32,
-    pub session_timeout: u32,
-    pub cookie_secure: bool,
+    pub audit_log_path: String,
     pub cookie_httponly: bool,
     pub cookie_samesite: String,
-    pub enable_security_headers: bool,
-    pub enable_request_validation: bool,
+    pub cookie_secure: bool,
+    pub csrf_token_timeout: u32,
     pub enable_audit_logging: bool,
-    pub audit_log_path: String,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct RagFlowSettings {
-    pub api_key: String,
-    pub base_url: String,
-    pub timeout: u64,
-    pub max_retries: u32,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct PerplexitySettings {
-    pub api_key: String,
-    pub prompt: String,
-    pub model: String,
-    pub api_url: String,
-    pub max_tokens: u32,
-    pub temperature: f32,
-    pub top_p: f32,
-    pub presence_penalty: f32,
-    pub frequency_penalty: f32,
-    pub timeout: u64,
-    pub rate_limit: u32,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct OpenAISettings {
-    pub api_key: String,
-    pub base_url: String,
-    pub timeout: u64,
-    pub rate_limit: u32,
-    pub model: String,
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct DefaultSettings {
-    pub max_concurrent_requests: usize,
-    pub max_retries: u32,
-    pub retry_delay: u64,
-    pub api_client_timeout: u64,
-    pub max_payload_size: usize,
-    pub enable_request_logging: bool,
-    pub enable_metrics: bool,
-    pub metrics_port: u16,
-    pub log_format: String,
+    pub enable_request_validation: bool,
+    pub session_timeout: u32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct RenderingSettings {
+    pub ambient_light_intensity: f32,
+    pub background_color: String,
+    pub directional_light_intensity: f32,
+    pub enable_ambient_occlusion: bool,
     pub enable_antialiasing: bool,
     pub enable_shadows: bool,
-    pub enable_ambient_occlusion: bool,
-    pub shadow_map_size: u32,
-    pub pixel_ratio: f32,
-    pub enable_gpu_acceleration: bool,
-    pub background_color: String,
     pub environment_intensity: f32,
-    pub ambient_light_intensity: f32,
-    pub directional_light_intensity: f32,
-    pub enable_hemisphere_light: bool,
-    pub fog_enabled: bool,
-    pub fog_color: String,
-    pub fog_density: f32,
-    pub enable_grid: bool,
-    pub grid_size: u32,
-    pub grid_divisions: u32,
-    pub grid_color: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct ARSettings {
+    pub enable_hand_tracking: bool,
+    pub enable_haptics: bool,
+    pub enable_plane_detection: bool,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct NodeSettings {
+    pub base_color: String,
     pub base_size: f32,
     pub size_range: Vec<f32>,
     pub size_by_connections: bool,
-    pub geometry_segments: u32,
     pub enable_instancing: bool,
     pub material_type: String,
-    pub metalness: f32,
+    pub opacity: f32,
     pub roughness: f32,
+    pub metalness: f32,
     pub clearcoat: f32,
-    pub clearcoat_roughness: f32,
-    pub opacity: f32,
-    pub enable_transparency: bool,
-    pub base_color: String,
-    pub color_scheme: String,
-    pub new_node_color: String,
-    pub old_node_color: String,
-    pub core_node_color: String,
-    pub secondary_node_color: String,
-    pub age_max_days: u32,
     pub highlight_color: String,
-    pub highlight_intensity: f32,
     pub highlight_duration: u32,
     pub enable_hover_effect: bool,
     pub hover_scale: f32,
@@ -235,160 +106,125 @@ pub struct NodeSettings {
 pub struct EdgeSettings {
     pub base_width: f32,
     pub width_range: Vec<f32>,
-    pub width_by_strength: bool,
-    pub curve_segments: u32,
-    pub enable_arrows: bool,
-    pub arrow_size: f32,
-    pub opacity: f32,
     pub color: String,
-    pub highlight_color: String,
-    pub enable_glow: bool,
-    pub glow_intensity: f32,
-    pub glow_color: String,
+    pub opacity: f32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct LabelSettings {
-    pub enable_labels: bool,
-    pub font_family: String,
-    pub desktop_font_size: u32,
-    pub ar_font_size: u32,
-    pub padding: u32,
-    pub background_opacity: f32,
-    pub max_visible_labels: u32,
-    pub vertical_offset: f32,
-    pub close_offset: f32,
-    pub view_angle_fade: f32,
-    pub depth_fade_start: f32,
-    pub depth_fade_end: f32,
-    pub text_color: String,
-    pub info_color: String,
-    pub background_color: String,
+pub struct PhysicsSettings {
+    pub attraction_strength: f32,
+    pub bounds_size: f32,
+    pub collision_radius: f32,
+    pub damping: f32,
+    pub enable_bounds: bool,
+    pub enabled: bool,
+    pub iterations: u32,
+    pub max_velocity: f32,
+    pub repulsion_strength: f32,
+    pub spring_strength: f32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct BloomSettings {
     pub enabled: bool,
-    pub strength: f32,
-    pub radius: f32,
-    pub threshold: f32,
     pub node_bloom_strength: f32,
     pub edge_bloom_strength: f32,
     pub environment_bloom_strength: f32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct ARSettings {
-    pub enable_plane_detection: bool,
-    pub enable_light_estimation: bool,
-    pub enable_hand_tracking: bool,
-    pub enable_scene_understanding: bool,
-    pub snap_to_floor: bool,
-    pub room_scale: bool,
-    pub hand_mesh_enabled: bool,
-    pub hand_mesh_opacity: f32,
-    pub hand_mesh_color: String,
-    pub hand_ray_enabled: bool,
-    pub hand_ray_color: String,
-    pub hand_ray_width: f32,
-    pub hand_point_size: f32,
-    pub hand_trail_enabled: bool,
-    pub hand_trail_length: f32,
-    pub hand_trail_opacity: f32,
-    pub pinch_threshold: f32,
-    pub drag_threshold: f32,
-    pub rotation_threshold: f32,
-    pub enable_haptics: bool,
-    pub haptic_intensity: f32,
-    pub gesture_smoothing: f32,
+pub struct LabelSettings {
+    pub enable_labels: bool,
+    pub text_color: String,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
-pub struct PhysicsSettings {
+pub struct WebSocketSettings {
+    pub binary_chunk_size: usize,
+    pub compression_enabled: bool,
+    pub compression_threshold: usize,
+    pub heartbeat_interval: u64,
+    pub heartbeat_timeout: u64,
+    pub max_connections: usize,
+    pub max_message_size: usize,
+    pub reconnect_attempts: u32,
+    pub reconnect_delay: u64,
+    pub update_rate: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct DebugSettings {
+    pub enable_data_debug: bool,
+    pub enable_websocket_debug: bool,
     pub enabled: bool,
-    pub iterations: u32,
-    pub spring_strength: f32,
-    pub repulsion_strength: f32,
-    pub attraction_strength: f32,
-    pub damping: f32,
-    pub enable_bounds: bool,
-    pub bounds_size: f32,
-    pub enable_collision: bool,
-    pub collision_radius: f32,
-    pub max_velocity: f32,
+    pub log_binary_headers: bool,
+    pub log_full_json: bool,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct GitHubSettings {
+    pub base_path: String,
+    pub owner: String,
+    pub rate_limit: bool,
+    pub repo: String,
+    pub token: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct OpenAISettings {
+    pub api_key: String,
+    pub base_url: String,
+    pub model: String,
+    pub rate_limit: u32,
+    pub timeout: u64,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct PerplexitySettings {
+    pub api_key: String,
+    pub api_url: String,
+    pub frequency_penalty: f32,
+    pub max_tokens: u32,
+    pub model: String,
+    pub prompt: String,
+    pub rate_limit: u32,
+    pub temperature: f32,
+    pub timeout: u64,
+    pub top_p: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct RagFlowSettings {
+    pub api_key: String,
+    pub base_url: String,
+    pub max_retries: u32,
+    pub timeout: u64,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct AnimationSettings {
+    #[serde(default)]
     pub enable_node_animations: bool,
+    #[serde(default)]
     pub selection_wave_enabled: bool,
-    pub selection_wave_color: String,
-    pub selection_wave_speed: f32,
-    pub selection_wave_size: f32,
-    pub selection_wave_opacity: f32,
+    #[serde(default)]
     pub pulse_enabled: bool,
-    pub pulse_frequency: f32,
-    pub pulse_amplitude: f32,
-    pub pulse_color: String,
+    #[serde(default)]
     pub ripple_enabled: bool,
-    pub ripple_speed: f32,
-    pub ripple_size: f32,
-    pub ripple_segments: u32,
-    pub ripple_color: String,
-    pub ripple_decay: f32,
+    #[serde(default)]
     pub edge_animation_enabled: bool,
+    #[serde(default)]
     pub flow_particles_enabled: bool,
-    pub flow_particle_count: u32,
-    pub flow_particle_size: f32,
-    pub flow_particle_speed: f32,
-    pub flow_particle_color: String,
-    pub flow_particle_trail: bool,
-    pub flow_particle_trail_length: f32,
-    pub edge_pulse_enabled: bool,
-    pub edge_pulse_frequency: f32,
-    pub edge_pulse_amplitude: f32,
-    pub edge_pulse_color: String,
-    pub edge_pulse_width: f32,
-    pub animation_quality: String,
-    pub enable_motion_blur: bool,
-    pub motion_blur_strength: f32,
-    pub animation_smoothing: f32,
-    pub max_concurrent_animations: u32,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct AudioSettings {
+    #[serde(default)]
     pub enable_spatial_audio: bool,
-    pub master_volume: f32,
-    pub audio_rolloff: String,
-    pub max_audio_distance: f32,
-    pub doppler_factor: f32,
+    #[serde(default)]
     pub enable_interaction_sounds: bool,
-    pub selection_sound_enabled: bool,
-    pub selection_sound_volume: f32,
-    pub hover_sound_enabled: bool,
-    pub hover_sound_volume: f32,
-    pub node_collision_sound: bool,
-    pub node_collision_volume: f32,
-    pub node_creation_sound: bool,
-    pub node_creation_volume: f32,
-    pub node_deletion_sound: bool,
-    pub node_deletion_volume: f32,
-    pub edge_creation_sound: bool,
-    pub edge_creation_volume: f32,
-    pub edge_deletion_sound: bool,
-    pub edge_deletion_volume: f32,
-    pub edge_flow_sound: bool,
-    pub edge_flow_volume: f32,
+    #[serde(default)]
     pub enable_ambient_sounds: bool,
-    pub ambient_volume: f32,
-    pub ambient_variation: f32,
-    pub selection_frequency: u32,
-    pub hover_frequency: u32,
-    pub collision_frequency: u32,
-    pub creation_frequency: u32,
-    pub deletion_frequency: u32,
-    pub flow_frequency: u32,
 }
 
 impl Settings {
