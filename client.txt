The following text represents a project with code. The structure of the text consists of sections beginning with ----, followed by a single line containing the file path and file name, and then a variable number of lines containing the file contents. The text representing the project ends when the symbols --END-- are encountered. Any further text beyond --END-- is meant to be interpreted as instructions using the aforementioned project as context.
----
index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Graph Visualization</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }
        #scene-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            background: #000000;
            touch-action: none;
        }
        #app {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        #app > * {
            pointer-events: auto;
        }
        #connection-status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.7);
        }
        canvas {
            display: block;
            outline: none;
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="app"></div>
    <div id="connection-status" class="disconnected">Disconnected</div>

    <script type="module">
        // Import and initialize app
        import('./index.ts')
            .then(() => {
                console.info('Application loaded successfully');
            })
            .catch(error => {
                console.error('Failed to load application', {
                    message: error.message,
                    stack: error.stack,
                    context: 'Application Load'
                });
            });
    </script>
</body>
</html>

----
index.ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './components/App.vue'
import { errorTracking } from './services/errorTracking'

// Disable Vue devtools
window.__VUE_PROD_DEVTOOLS__ = false

// Create Vue application
const app = createApp(App)

// Configure global error handler for Vue
app.config.errorHandler = (err, instance, info) => {
  // Track error with our service
  errorTracking.trackError(err, {
    context: 'Vue Error Handler',
    component: (instance as any)?.$options?.name || 'Unknown Component',
    additional: { info }
  })

  // Log to console in development
  if (process.env.NODE_ENV === 'development') {
    console.error('Vue Error:', err)
    console.error('Component:', instance)
    console.error('Error Info:', info)
  }
}

// Create and use Pinia
const pinia = createPinia()
app.use(pinia)

// Add error tracking to Pinia
pinia.use(() => {
  return {
    error: (error: Error) => {
      errorTracking.trackError(error, {
        context: 'Pinia Store',
        additional: { store: error?.cause }
      })
    }
  }
})

// Mount the app
app.mount('#app')

// Log successful initialization
console.info('Application initialized', {
  context: 'App Initialization',
  environment: process.env.NODE_ENV
})

----
utils/gpuUtils.ts
import type { Vector3 } from 'three';

export interface GPUContext {
  initialized: boolean;
  webgl2: boolean;
}

export interface PositionUpdate {
  isInitialLayout: boolean;
  positions: NodePosition[];
}

export interface NodePosition {
  x: number;
  y: number;
  z: number;
  vx: number;
  vy: number;
  vz: number;
}

/**
 * Check if GPU/WebGL is available for rendering
 * @returns Promise that resolves to true if GPU rendering is available
 */
export async function isGPUAvailable(): Promise<boolean> {
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2') || 
               canvas.getContext('webgl') || 
               canvas.getContext('experimental-webgl');
    
    if (!gl) {
      console.warn('WebGL not available, rendering may be limited');
      return false;
    }

    // Check if it's WebGL 2
    if (gl instanceof WebGL2RenderingContext) {
      console.log('WebGL 2 available');
    } else {
      console.log('WebGL 1 available');
    }

    return true;
  } catch (error) {
    console.error('Error checking GPU availability:', error);
    return false;
  }
}

/**
 * Initialize GPU/WebGL context
 * @returns Promise that resolves to GPU context if available
 */
export async function initGPU(): Promise<GPUContext | null> {
  const available = await isGPUAvailable();
  if (available) {
    return {
      initialized: true,
      webgl2: typeof WebGL2RenderingContext !== 'undefined' && 
              document.createElement('canvas').getContext('webgl2') instanceof WebGL2RenderingContext
    };
  }
  return null;
}

/**
 * Apply position updates received from server
 * @param buffer - Binary position data from server
 * @returns Processed position data
 */
export function processPositionUpdate(buffer: ArrayBuffer): PositionUpdate | null {
  try {
    const dataView = new Float32Array(buffer);
    const isInitialLayout = dataView[0] === 1.0;
    const positions: NodePosition[] = [];
    
    // Skip header (first float32)
    for (let i = 1; i < dataView.length; i += 6) {
      if (i + 5 < dataView.length) {
        positions.push({
          x: dataView[i],
          y: dataView[i + 1],
          z: dataView[i + 2],
          vx: dataView[i + 3],
          vy: dataView[i + 4],
          vz: dataView[i + 5]
        });
      }
    }

    return {
      isInitialLayout,
      positions
    };
  } catch (error) {
    console.error('Error processing position update:', error);
    return null;
  }
}

/**
 * Convert NodePosition to Vector3
 * @param position - Node position data
 * @returns THREE.Vector3 position
 */
export function positionToVector3(position: NodePosition): Vector3 {
  return {
    x: position.x,
    y: position.y,
    z: position.z
  } as Vector3;
}

/**
 * Convert Vector3 to NodePosition
 * @param vector - THREE.Vector3 position
 * @returns Node position data
 */
export function vector3ToPosition(vector: Vector3): NodePosition {
  return {
    x: vector.x,
    y: vector.y,
    z: vector.z,
    vx: 0,
    vy: 0,
    vz: 0
  };
}

----
utils/threeUtils.ts
import type { 
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  Camera,
  WebGLRenderTarget,
  Texture,
  Object3D
} from 'three';

import type { Pass } from 'three/examples/jsm/postprocessing/Pass';
import type { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';

// Base pass interface that matches actual implementation
export interface BasePass extends Pass {
  render(
    renderer: WebGLRenderer,
    writeBuffer: WebGLRenderTarget<Texture> | null,
    readBuffer: WebGLRenderTarget<Texture>,
    deltaTime?: number,
    maskActive?: boolean
  ): void;
}

// Extended pass interface for custom functionality
export interface ExtendedPass extends BasePass {
  selectedObjects?: Object3D[];
  output?: number;
}

// Type assertion functions with any to bypass strict checks
export function asRenderer(renderer: any): WebGLRenderer {
  return renderer;
}

export function asScene(scene: any): Scene {
  return scene;
}

export function asCamera(camera: any): Camera {
  return camera;
}

export function asPass(pass: any): ExtendedPass {
  return pass;
}

export function asEffectComposer(composer: any): EffectComposer {
  return composer;
}

// Type guard for checking if an object is a valid Pass
export function isValidPass(obj: any): obj is ExtendedPass {
  return obj && typeof obj.render === 'function';
}

// Constants for pass outputs
export const PASS_OUTPUT = {
  Default: 0,
  Beauty: 1,
  Depth: 2,
  Normal: 3
};

----
utils/three.ts
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Export everything from three
export * from 'three';
// Export specific imports
export { OrbitControls };
// Export THREE as default
export default THREE;

----
xr/xrSetup.js
import * as THREE from 'three';
import { XRButton } from 'three/examples/jsm/webxr/XRButton.js';
import { initXRInteraction, handleXRInput } from './xrInteraction.js';

// Constants
const MOVEMENT_SPEED = 0.05;
const XR_SPRITE_SCALE = 0.5;

/**
 * Enhanced XR Session Manager using Three.js WebXR
 */
class XRSessionManager {
    constructor(renderer, scene, camera, effectsManager) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.effectsManager = effectsManager;
        this.referenceSpace = null;
        this.originalScales = new WeakMap();
        this.xrInteraction = null;
        this.sessionActive = false;
        this.cameraRig = null;
        this.effectsEnabled = true;
    }

    /**
     * Initialize XR session manager
     */
    async init() {
        try {
            // Check if XR is supported
            if (!this.renderer.xr) {
                console.warn('WebXR not supported by renderer');
                return;
            }

            // Enable XR on renderer
            this.renderer.xr.enabled = true;

            // Initialize camera rig
            this.initCameraRig();

            // Initialize XR interaction
            this.xrInteraction = initXRInteraction(this.scene, this.camera, this.renderer);

            // Set up session event handlers
            this.setupEventHandlers();

        } catch (error) {
            console.error('Error initializing XR session manager:', error);
        }
    }

    /**
     * Initialize camera rig with proper hierarchy
     */
    initCameraRig() {
        // Create camera rig if it doesn't exist
        if (!this.cameraRig) {
            this.cameraRig = new THREE.Group();
            this.cameraRig.name = 'cameraRig';
        }

        // Create camera offset for height adjustment if not already a child of the rig
        let cameraOffset = this.cameraRig.children.find(child => child.name === 'cameraOffset');
        if (!cameraOffset) {
            cameraOffset = new THREE.Group();
            cameraOffset.name = 'cameraOffset';
            cameraOffset.position.y = 1.6; // Average eye height
            this.cameraRig.add(cameraOffset);
        }

        // Add camera to offset if not already there
        if (!cameraOffset.children.includes(this.camera)) {
            this.camera.name = 'xrCamera';
            cameraOffset.add(this.camera);
        }

        // Add rig to scene if not already there
        if (!this.scene.children.includes(this.cameraRig)) {
            this.scene.add(this.cameraRig);
        }

        // Set initial positions
        this.camera.position.set(0, 0, 0);
        this.cameraRig.position.set(0, 0, 0);
    }

    /**
     * Set up session event handlers
     */
    setupEventHandlers() {
        // Session start handler
        this.renderer.xr.addEventListener('sessionstart', async (event) => {
            console.log('XR session started');
            this.sessionActive = true;

            const session = this.renderer.xr.getSession();
            await this.setupReferenceSpace(session);
            this.handleXRSprites(true);

            // Initialize camera position
            this.cameraRig.position.set(0, 0, 0);
            this.camera.position.set(0, 0, 0);

            // Initialize XR-specific effects
            if (this.effectsManager) {
                try {
                    await this.effectsManager.initPostProcessing(true);
                    this.effectsEnabled = true;
                } catch (error) {
                    console.error('Failed to initialize XR effects:', error);
                    this.effectsEnabled = false;
                }
            }

            window.dispatchEvent(new CustomEvent('xrsessionstart'));
        });

        // Session end handler
        this.renderer.xr.addEventListener('sessionend', () => {
            console.log('XR session ended');
            this.sessionActive = false;
            this.handleXRSprites(false);
            this.resetCameraRig();

            // Reinitialize desktop effects
            if (this.effectsManager) {
                try {
                    this.effectsManager.initPostProcessing(false);
                    this.effectsEnabled = true;
                } catch (error) {
                    console.error('Failed to reinitialize desktop effects:', error);
                    this.effectsEnabled = false;
                }
            }

            window.dispatchEvent(new CustomEvent('xrsessionend'));
        });
    }

    /**
     * Render scene with effects fallback
     */
    render() {
        if (this.effectsManager && this.effectsEnabled) {
            try {
                this.effectsManager.render();
            } catch (error) {
                console.error('Error in effects rendering:', error);
                this.effectsEnabled = false;
                this.fallbackRender();
            }
        } else {
            this.fallbackRender();
        }
    }

    /**
     * Fallback render without effects
     */
    fallbackRender() {
        const currentCamera = this.sessionActive ? this.renderer.xr.getCamera() : this.camera;
        this.renderer.render(this.scene, currentCamera);
    }

    /**
     * Add XR button to the scene
     * @returns {Promise<void>}
     */
    async addXRButton() {
        try {
            if (!this.renderer.xr.enabled) {
                console.warn('XR not enabled on renderer');
                return;
            }

            const sessionInit = {
                optionalFeatures: [
                    'local-floor',
                    'bounded-floor',
                    'hand-tracking',
                    'layers'
                ]
            };

            // Check if VR is supported
            const isVRSupported = await navigator.xr?.isSessionSupported('immersive-vr');
            
            if (isVRSupported) {
                const button = XRButton.createButton(this.renderer, {
                    mode: 'immersive-vr',
                    sessionInit,
                    onSessionStarted: (session) => this.onSessionStarted(session),
                    onSessionEnded: () => this.onSessionEnded()
                });
                document.body.appendChild(button);
            } else {
                console.warn('VR not supported on this device');
            }
        } catch (error) {
            console.error('Error adding XR button:', error);
        }
    }

    /**
     * Handle session start
     * @param {XRSession} session - The XR session
     */
    async onSessionStarted(session) {
        try {
            await this.setupReferenceSpace(session);
            this.handleXRSprites(true);
        } catch (error) {
            console.error('Error starting XR session:', error);
        }
    }

    /**
     * Handle session end
     */
    onSessionEnded() {
        this.handleXRSprites(false);
        this.resetCameraRig();
    }

    /**
     * Set up reference space with fallback options
     * @param {XRSession} session - The XR session
     */
    async setupReferenceSpace(session) {
        try {
            this.referenceSpace = await session.requestReferenceSpace('local-floor');
            console.log('Using local-floor reference space');
        } catch (error) {
            console.warn('Failed to get local-floor reference space:', error);
            try {
                this.referenceSpace = await session.requestReferenceSpace('local');
                console.log('Falling back to local reference space');
            } catch (error) {
                console.error('Failed to get any reference space:', error);
            }
        }
    }

    /**
     * Handle sprite scaling for XR
     * @param {boolean} enteringXR - Whether entering or exiting XR
     */
    handleXRSprites(enteringXR) {
        this.scene.traverse((object) => {
            if (object.isSprite) {
                if (enteringXR) {
                    this.originalScales.set(object, object.scale.clone());
                    object.scale.multiplyScalar(XR_SPRITE_SCALE);
                    object.layers.enableAll();
                    
                    if (object.material.map) {
                        object.material.map.generateMipmaps = false;
                        object.material.map.minFilter = THREE.LinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                } else {
                    const originalScale = this.originalScales.get(object);
                    if (originalScale) {
                        object.scale.copy(originalScale);
                    }
                    
                    if (object.material.map) {
                        object.material.map.generateMipmaps = true;
                        object.material.map.minFilter = THREE.LinearMipmapLinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                }
            }
        });
    }

    /**
     * Reset camera rig to initial position
     */
    resetCameraRig() {
        if (this.cameraRig) {
            this.cameraRig.position.set(0, 0, 0);
            this.cameraRig.rotation.set(0, 0, 0);
        }
        if (this.camera) {
            this.camera.position.set(0, 0, 0);
            this.camera.rotation.set(0, 0, 0);
        }
    }

    /**
     * Update XR frame
     * @param {number} timestamp - Frame timestamp
     * @param {XRFrame} frame - XR frame
     */
    update(timestamp, frame) {
        if (!this.sessionActive || !frame) return;

        try {
            // Update XR camera pose
            if (this.referenceSpace) {
                const pose = frame.getViewerPose(this.referenceSpace);
                if (pose) {
                    // Update camera rig based on pose
                    const position = pose.transform.position;
                    const orientation = pose.transform.orientation;
                    
                    this.cameraRig.position.set(position.x, position.y, position.z);
                    this.cameraRig.quaternion.set(
                        orientation.x,
                        orientation.y,
                        orientation.z,
                        orientation.w
                    );
                }
            }

            // Update XR interaction
            if (this.xrInteraction) {
                this.xrInteraction.update();
                handleXRInput(frame, this.referenceSpace);
            }

            // Handle input sources
            const session = frame.session;
            for (const inputSource of session.inputSources) {
                if (inputSource.gamepad) {
                    this.handleControllerInput(inputSource.gamepad);
                }
            }

        } catch (error) {
            console.error('Error updating XR frame:', error);
        }
    }

    /**
     * Handle controller input
     * @param {Gamepad} gamepad - The XR gamepad
     */
    handleControllerInput(gamepad) {
        if (!gamepad?.axes || gamepad.axes.length < 2) return;

        try {
            const [x, y] = gamepad.axes;
            const deadzone = 0.1;

            if (Math.abs(x) > deadzone || Math.abs(y) > deadzone) {
                // Get movement direction in camera space
                const forward = new THREE.Vector3();
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);

                // Calculate movement
                const movement = new THREE.Vector3();
                movement.addScaledVector(right, x * MOVEMENT_SPEED);
                movement.addScaledVector(forward, -y * MOVEMENT_SPEED);

                // Apply movement to camera rig
                this.cameraRig.position.add(movement);
            }
        } catch (error) {
            console.error('Error handling controller input:', error);
        }
    }

    /**
     * Clean up resources
     */
    dispose() {
        this.originalScales.clear();
        if (this.xrInteraction) {
            this.xrInteraction.cleanup();
        }
    }
}

// Export functions
export function initXRSession(renderer, scene, camera, effectsManager) {
    // Check if renderer has XR capability
    if (!renderer.xr) {
        console.warn('WebXR not supported by renderer');
        return null;
    }

    const xrSessionManager = new XRSessionManager(renderer, scene, camera, effectsManager);
    xrSessionManager.init();
    return xrSessionManager;
}

/**
 * Add XR button to enable VR mode
 * @param {XRSessionManager} xrSessionManager - The XR session manager
 * @returns {Promise<void>}
 */
export async function addXRButton(xrSessionManager) {
    if (!xrSessionManager) {
        console.warn('XR session manager not initialized');
        return;
    }
    await xrSessionManager.addXRButton();
}

export function handleXRSession(renderer, scene, camera, xrSessionManager) {
    if (!xrSessionManager) return;

    renderer.setAnimationLoop((timestamp, frame) => {
        // Update XR session
        xrSessionManager.update(timestamp, frame);

        // Render scene with effects fallback
        xrSessionManager.render();
    });
}

export function updateXRFrame(renderer, scene, camera, xrSessionManager) {
    if (!xrSessionManager?.sessionActive) return;

    // Update XR session
    const frame = renderer.xr.getFrame();
    xrSessionManager.update(performance.now(), frame);

    // Render scene with effects fallback
    xrSessionManager.render();
}

----
xr/xrInteraction.js
import * as THREE from 'three';
import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory.js';

// Constants for interaction
const PINCH_THRESHOLD = 0.015;
const GRAB_THRESHOLD = 0.08;
const PINCH_STRENGTH_THRESHOLD = 0.7;
const LABEL_SIZE = { width: 256, height: 128 };
const LABEL_SCALE = { x: 0.5, y: 0.25, z: 1 };

/**
 * Enhanced XR Interaction Handler
 */
class EnhancedXRInteractionHandler {
    constructor(scene, camera, renderer) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Hand tracking
        this.handModelFactory = new XRHandModelFactory();
        this.hands = { left: null, right: null };
        this.handModels = { left: null, right: null };
        
        // Interaction states
        this.grabStates = {
            left: { grabbedObject: null, pinching: false },
            right: { grabbedObject: null, pinching: false }
        };
        
        // Visual feedback
        this.pinchIndicators = { left: null, right: null };
        
        // Interactable objects
        this.interactableObjects = new Set();
        
        // Resource pools
        this.materialPool = new Map();
        this.geometryPool = new Map();
        
        // Initialize resources
        this.initResources();
    }

    /**
     * Initialize shared resources
     */
    initResources() {
        // Create pinch indicator geometry
        const geometry = new THREE.SphereGeometry(0.01, 8, 8);
        this.geometryPool.set('pinchIndicator', geometry);

        // Create pinch indicator material
        const material = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5,
            depthWrite: false
        });
        this.materialPool.set('pinchIndicator', material);

        // Create pinch indicators
        this.pinchIndicators.left = this.createPinchIndicator();
        this.pinchIndicators.right = this.createPinchIndicator();
        this.scene.add(this.pinchIndicators.left);
        this.scene.add(this.pinchIndicators.right);
    }

    /**
     * Initialize hand tracking
     * @param {XRSession} session - The XR session
     */
    async initHandTracking(session) {
        try {
            // Set up hand tracking
            for (const handedness of ['left', 'right']) {
                const hand = this.renderer.xr.getHand(handedness === 'left' ? 0 : 1);
                const handModel = this.handModelFactory.createHandModel(hand, 'mesh');
                
                this.hands[handedness] = hand;
                this.handModels[handedness] = handModel;
                
                hand.add(handModel);
                this.scene.add(hand);

                // Add hand input event listeners
                hand.addEventListener('pinchstart', () => this.onPinchStart(handedness));
                hand.addEventListener('pinchend', () => this.onPinchEnd(handedness));
            }

            // Set up hand tracking events
            session.addEventListener('handtracking', (event) => {
                const hand = event.hand;
                const handedness = hand.handedness;
                
                // Update hand model visibility
                if (this.handModels[handedness]) {
                    this.handModels[handedness].visible = hand.visible;
                }
            });
        } catch (error) {
            console.error('Error initializing hand tracking:', error);
        }
    }

    /**
     * Create visual feedback for pinch state
     * @returns {THREE.Mesh} Pinch indicator mesh
     */
    createPinchIndicator() {
        const geometry = this.geometryPool.get('pinchIndicator');
        const material = this.materialPool.get('pinchIndicator').clone();
        return new THREE.Mesh(geometry, material);
    }

    /**
     * Update pinch indicator position and appearance
     * @param {XRHand} hand - The XR hand
     * @param {THREE.Mesh} indicator - The pinch indicator mesh
     */
    updatePinchIndicator(hand, indicator) {
        if (!hand?.joints || !indicator) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];
            
            if (indexTip && thumbTip) {
                // Position indicator between finger and thumb
                indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
                
                // Update appearance based on pinch strength
                const { strength } = this.isPinching(hand);
                indicator.material.opacity = strength * 0.8;
                indicator.scale.setScalar(1 - (strength * 0.5));
            }
        } catch (error) {
            console.error('Error updating pinch indicator:', error);
        }
    }

    /**
     * Check if hand is performing pinch gesture
     * @param {XRHand} hand - The XR hand
     * @returns {object} Pinch state and strength
     */
    isPinching(hand) {
        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];

            if (indexTip && thumbTip) {
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
                return { isPinched: distance < PINCH_THRESHOLD, strength };
            }
        } catch (error) {
            console.error('Error detecting pinch:', error);
        }
        return { isPinched: false, strength: 0 };
    }

    /**
     * Handle pinch start event
     * @param {string} handedness - The hand that started pinching
     */
    onPinchStart(handedness) {
        const hand = this.hands[handedness];
        const grabState = this.grabStates[handedness];

        if (!hand || grabState.pinching) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            
            // Find closest interactable object
            let closestObject = null;
            let closestDistance = GRAB_THRESHOLD;

            for (const object of this.interactableObjects) {
                if (!object.userData.isGrabbed) {
                    const distance = indexTip.position.distanceTo(object.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestObject = object;
                    }
                }
            }

            if (closestObject) {
                grabState.grabbedObject = closestObject;
                closestObject.userData.isGrabbed = true;
                
                // Highlight grabbed object
                if (closestObject.material?.emissive) {
                    closestObject.material.emissive.setHex(0x222222);
                }
            }

            grabState.pinching = true;
        } catch (error) {
            console.error('Error handling pinch start:', error);
        }
    }

    /**
     * Handle pinch end event
     * @param {string} handedness - The hand that ended pinching
     */
    onPinchEnd(handedness) {
        const grabState = this.grabStates[handedness];

        if (!grabState.pinching) return;

        try {
            if (grabState.grabbedObject) {
                grabState.grabbedObject.userData.isGrabbed = false;
                if (grabState.grabbedObject.material?.emissive) {
                    grabState.grabbedObject.material.emissive.setHex(0x000000);
                }
                grabState.grabbedObject = null;
            }

            grabState.pinching = false;
        } catch (error) {
            console.error('Error handling pinch end:', error);
        }
    }

    /**
     * Make an object interactable
     * @param {THREE.Object3D} object - The object to make interactable
     */
    makeInteractable(object) {
        object.userData.interactable = true;
        this.interactableObjects.add(object);
    }

    /**
     * Remove interactable status from object
     * @param {THREE.Object3D} object - The object to remove
     */
    removeInteractable(object) {
        object.userData.interactable = false;
        this.interactableObjects.delete(object);
    }

    /**
     * Update interaction state
     */
    update() {
        try {
            // Update both hands
            for (const [handedness, hand] of Object.entries(this.hands)) {
                if (hand?.joints) {
                    const grabState = this.grabStates[handedness];
                    const { isPinched, strength } = this.isPinching(hand);
                    
                    this.updatePinchIndicator(hand, this.pinchIndicators[handedness]);

                    if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                        if (grabState.grabbedObject) {
                            // Update grabbed object position
                            const indexTip = hand.joints['index-finger-tip'];
                            grabState.grabbedObject.position.copy(indexTip.position);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error in XR interaction update:', error);
        }
    }

    /**
     * Clean up resources
     */
    cleanup() {
        try {
            // Dispose of geometries
            this.geometryPool.forEach(geometry => geometry.dispose());
            this.geometryPool.clear();

            // Dispose of materials
            this.materialPool.forEach(material => material.dispose());
            this.materialPool.clear();

            // Remove pinch indicators
            Object.values(this.pinchIndicators).forEach(indicator => {
                if (indicator) {
                    if (indicator.geometry) indicator.geometry.dispose();
                    if (indicator.material) indicator.material.dispose();
                    this.scene.remove(indicator);
                }
            });

            // Remove hand models
            Object.values(this.hands).forEach(hand => {
                if (hand) {
                    this.scene.remove(hand);
                }
            });

            // Clear collections
            this.interactableObjects.clear();
            this.grabStates.left = { grabbedObject: null, pinching: false };
            this.grabStates.right = { grabbedObject: null, pinching: false };
        } catch (error) {
            console.error('Error cleaning up XR interaction:', error);
        }
    }
}

// Export functions
export function initXRInteraction(scene, camera, renderer) {
    return new EnhancedXRInteractionHandler(scene, camera, renderer);
}

export function handleXRInput(frame, referenceSpace) {
    // This function is now handled internally by EnhancedXRInteractionHandler
    // Left for backward compatibility
}

----
platform/platformManager.ts
import { ref, shallowRef } from 'vue';
import type { CoreState, PlatformCapabilities, SceneConfig, Transform } from '../types/core';
import type { BrowserState, BrowserInitOptions } from '../types/platform/browser';
import type { QuestState, QuestInitOptions, XRController, XRHand, XRHandedness, XRSession, XRHitTestSource } from '../types/platform/quest';
import * as THREE from 'three';
import type { Object3D, Material, BufferGeometry, PerspectiveCamera, OrthographicCamera, Group, WebGLRenderer, Camera } from 'three';

// Import OrbitControls dynamically to avoid type conflicts
let OrbitControls: any;

export type PlatformState = BrowserState | QuestState;
type ResizeCallback = (width: number, height: number) => void;
type RenderCallback = (renderer: WebGLRenderer, scene: THREE.Scene, camera: Camera) => void;

/**
 * Platform Manager Interface
 * Defines the contract for platform-specific implementations
 */
export interface IPlatformManager {
  initialize(options: BrowserInitOptions | QuestInitOptions): Promise<void>;
  dispose(): void;
  getState(): PlatformState | null;
  getCapabilities(): PlatformCapabilities | null;
  getPlatform(): 'browser' | 'quest';
  isQuest(): boolean;
  isBrowser(): boolean;
  hasXRSupport(): boolean;
  startXRSession(mode: 'immersive-vr' | 'immersive-ar'): Promise<XRSession>;
  endXRSession(): Promise<void>;
  isInXRSession(): boolean;
  getXRSessionMode(): 'immersive-vr' | 'immersive-ar' | null;
  onResize(callback: ResizeCallback): () => void;
  onBeforeRender(callback: RenderCallback): () => void;
}

/**
 * Platform Manager Implementation
 * Handles platform-specific initialization and XR session management
 */
export class PlatformManager implements IPlatformManager {
  private static instance: PlatformManager;
  private state = shallowRef<PlatformState | null>(null);
  private capabilities = ref<PlatformCapabilities | null>(null);
  private platform: 'browser' | 'quest' = 'browser';
  private animationFrameId: number | null = null;
  private resizeCallbacks: Set<ResizeCallback> = new Set();
  private renderCallbacks: Set<RenderCallback> = new Set();
  private lastFrameTime = 0;
  private xrSessionMode: 'immersive-vr' | 'immersive-ar' | null = null;

  private constructor() {
    this.detectPlatform();
    this.setupResizeHandler();
  }

  /**
   * Get singleton instance of PlatformManager
   */
  static getInstance(): PlatformManager {
    if (!PlatformManager.instance) {
      PlatformManager.instance = new PlatformManager();
    }
    return PlatformManager.instance;
  }

  /**
   * Initialize platform with given options
   */
  async initialize(options: BrowserInitOptions | QuestInitOptions): Promise<void> {
    if (this.platform === 'quest') {
      await this.initializeQuest(options as QuestInitOptions);
    } else {
      await this.initializeBrowser(options as BrowserInitOptions);
    }

    if (this.state.value?.canvas) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      this.resizeCallbacks.forEach(callback => callback(width, height));
    }
  }

  /**
   * Initialize Quest platform with XR support
   */
  private async initializeQuest(options: QuestInitOptions): Promise<void> {
    const sceneConfig: SceneConfig = {
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance'
    };

    const renderer = new THREE.WebGLRenderer({
      canvas: options.canvas,
      ...sceneConfig,
      xr: { enabled: true }
    });

    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType(options.xr?.referenceSpaceType ?? 'local-floor');

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    const scene = new THREE.Scene();

    const controllers = new Map<XRHandedness, XRController>();
    const hands = new Map<XRHandedness, XRHand>();

    // Initialize controllers
    const handednesses: XRHandedness[] = ['left', 'right'];
    handednesses.forEach((handedness, index) => {
      const controller = renderer.xr.getController(index);
      const grip = renderer.xr.getControllerGrip(index);

      controllers.set(handedness, {
        controller,
        grip,
        ray: new THREE.Group(),
        handedness,
        targetRayMode: 'tracked-pointer',
        visible: true,
        connected: false
      });

      scene.add(controller);
      scene.add(grip);
    });

    // Initialize hands
    handednesses.forEach((handedness, index) => {
      const hand = renderer.xr.getHand(index);
      
      hands.set(handedness, {
        hand,
        joints: new Map(),
        visible: true,
        connected: false
      });

      scene.add(hand);
    });

    const transform: Transform = {
      position: [0, 0, 0],
      rotation: [0, 0, 0],
      scale: [1, 1, 1]
    };

    this.state.value = {
      type: 'xr',
      renderer,
      camera,
      scene,
      canvas: options.canvas,
      isInitialized: true,
      isXRSupported: true,
      isWebGL2: true,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0,
      xrSession: null,
      xrSpace: null,
      xrLayer: null,
      hitTestSource: null,
      controllers,
      hands,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio
      },
      transform,
      config: {
        scene: sceneConfig,
        performance: {
          targetFPS: 90,
          maxDrawCalls: 10000,
          enableStats: false
        },
        xr: {
          referenceSpaceType: options.xr?.referenceSpaceType ?? 'local-floor',
          sessionMode: options.xr?.sessionMode ?? 'immersive-vr',
          optionalFeatures: options.xr?.optionalFeatures ?? ['hand-tracking'],
          requiredFeatures: options.xr?.requiredFeatures ?? ['local-floor']
        }
      }
    };

    renderer.setAnimationLoop(this.render.bind(this));
  }

  /**
   * Initialize browser platform with standard WebGL support
   */
  private async initializeBrowser(options: BrowserInitOptions): Promise<void> {
    if (!OrbitControls) {
      const module = await import('three/examples/jsm/controls/OrbitControls.js');
      OrbitControls = module.OrbitControls;
    }

    const sceneConfig: SceneConfig = {
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance'
    };

    const renderer = new THREE.WebGLRenderer({
      canvas: options.canvas,
      ...sceneConfig
    });

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    const scene = new THREE.Scene();

    const controls = new OrbitControls(camera, options.canvas);
    Object.assign(controls, options.controls ?? {});
    controls.enableDamping = true;

    const transform: Transform = {
      position: [0, 0, 0],
      rotation: [0, 0, 0],
      scale: [1, 1, 1]
    };

    this.state.value = {
      type: 'browser',
      renderer,
      camera,
      scene,
      canvas: options.canvas,
      controls,
      isInitialized: true,
      isXRSupported: false,
      isWebGL2: true,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0,
      mousePosition: new THREE.Vector2(),
      touchActive: false,
      pointerLocked: false,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio
      },
      transform,
      config: {
        scene: sceneConfig,
        performance: {
          targetFPS: 60,
          maxDrawCalls: 10000,
          enableStats: false
        }
      }
    };

    this.startRenderLoop();
  }

  /**
   * Start XR session with specified mode (VR or AR)
   */
  async startXRSession(mode: 'immersive-vr' | 'immersive-ar'): Promise<XRSession> {
    const state = this.state.value;
    if (!state?.renderer) {
      throw new Error('Renderer not initialized');
    }

    try {
      if (!navigator.xr) {
        throw new Error('WebXR not supported');
      }

      const isSupported = await navigator.xr.isSessionSupported(mode);
      if (!isSupported) {
        throw new Error(`${mode} not supported`);
      }

      // Configure session features based on mode
      const sessionInit: XRSessionInit = {
        optionalFeatures: [],
        requiredFeatures: []
      };

      // Base features for both modes
      sessionInit.optionalFeatures = [
        'local-floor',
        'bounded-floor',
        'hand-tracking',
        'layers'
      ];

      // Add AR-specific features
      if (mode === 'immersive-ar') {
        sessionInit.optionalFeatures.push(
          'dom-overlay',
          'hit-test',
          'anchors',
          'plane-detection',
          'light-estimation'
        );
        sessionInit.requiredFeatures = ['hit-test'];
        sessionInit.domOverlay = { root: document.body };
      } else {
        // VR-specific features
        sessionInit.requiredFeatures = ['local-floor'];
      }

      const session = await navigator.xr.requestSession(mode, sessionInit);
      if (!session) {
        throw new Error('Failed to create XR session');
      }

      // Set up XR layer
      const gl = state.renderer.getContext();
      const xrLayer = new XRWebGLLayer(session, gl);
      await session.updateRenderState({ baseLayer: xrLayer });

      // Set reference space based on mode
      const referenceSpaceType = mode === 'immersive-ar' ? 'unbounded' : 'local-floor';
      const referenceSpace = await session.requestReferenceSpace(referenceSpaceType);

      // Set up hit testing for AR
      if (mode === 'immersive-ar' && 'requestHitTestSource' in session) {
        try {
          const hitTestSourcePromise = session.requestHitTestSource?.({
            space: referenceSpace
          });

          if (hitTestSourcePromise) {
            const hitTestSource = await hitTestSourcePromise;
            if (this.state.value && 'xrSession' in this.state.value) {
              this.state.value.hitTestSource = hitTestSource;
            }
          }
        } catch (error) {
          console.warn('Hit testing not available:', error);
        }
      }

      if (this.state.value && 'xrSession' in this.state.value) {
        this.state.value.xrSession = session;
        this.state.value.xrSpace = referenceSpace;
        this.state.value.xrLayer = xrLayer;
      }

      this.xrSessionMode = mode;

      // Set up session end handler
      session.addEventListener('end', () => {
        this.xrSessionMode = null;
        if (this.state.value && 'xrSession' in this.state.value) {
          this.state.value.xrSession = null;
          this.state.value.xrSpace = null;
          this.state.value.xrLayer = null;
          this.state.value.hitTestSource = null;
        }
      });

      // Update renderer and camera for AR
      if (mode === 'immersive-ar') {
        state.renderer.xr.setReferenceSpaceType('unbounded');
        const camera = state.camera;
        if (camera && 'aspect' in camera) {
          camera.near = 0.01;
          camera.far = 1000;
          camera.updateProjectionMatrix();
        }
      }

      return session;

    } catch (error) {
      console.error(`Error starting ${mode} session:`, error);
      throw error;
    }
  }

  /**
   * End current XR session
   */
  async endXRSession(): Promise<void> {
    const state = this.state.value;
    if (state && 'xrSession' in state && state.xrSession) {
      await state.xrSession.end();
    }
  }

  /**
   * Get current platform state
   */
  getState(): PlatformState | null {
    return this.state.value;
  }

  /**
   * Get platform capabilities
   */
  getCapabilities(): PlatformCapabilities | null {
    return this.capabilities.value;
  }

  /**
   * Get current platform type
   */
  getPlatform(): 'browser' | 'quest' {
    return this.platform;
  }

  /**
   * Check if current platform is Quest
   */
  isQuest(): boolean {
    return this.platform === 'quest';
  }

  /**
   * Check if current platform is browser
   */
  isBrowser(): boolean {
    return this.platform === 'browser';
  }

  /**
   * Check if XR is supported
   */
  hasXRSupport(): boolean {
    return !!this.capabilities.value?.xr;
  }

  /**
   * Check if XR session is active
   */
  isInXRSession(): boolean {
    return this.xrSessionMode !== null;
  }

  /**
   * Get current XR session mode
   */
  getXRSessionMode(): 'immersive-vr' | 'immersive-ar' | null {
    return this.xrSessionMode;
  }

  /**
   * Add resize callback
   */
  onResize(callback: ResizeCallback): () => void {
    this.resizeCallbacks.add(callback);
    return () => this.resizeCallbacks.delete(callback);
  }

  /**
   * Add render callback
   */
  onBeforeRender(callback: RenderCallback): () => void {
    this.renderCallbacks.add(callback);
    return () => this.renderCallbacks.delete(callback);
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.state.value) {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }

      this.resizeCallbacks.clear();
      this.renderCallbacks.clear();

      if (this.isQuest()) {
        const questState = this.state.value as QuestState;
        if (questState.xrSession) {
          questState.xrSession.end().catch(console.error);
        }
      }

      if (this.state.value.renderer) {
        this.state.value.renderer.dispose();
        this.state.value.renderer.forceContextLoss();
      }

      this.state.value = null;
    }
  }

  /**
   * Detect platform and capabilities
   */
  private async detectPlatform() {
    const isQuest = /Oculus|Quest|VR/i.test(navigator.userAgent);
    const xrSupported = 'xr' in navigator;
    const webgl2 = this.checkWebGL2Support();

    // Check AR and VR support
    let arSupported = false;
    let vrSupported = false;
    
    if (xrSupported && navigator.xr) {
      try {
        arSupported = await navigator.xr.isSessionSupported('immersive-ar');
        vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      } catch (error) {
        console.warn('Error checking XR support:', error);
      }
    }

    this.capabilities.value = {
      webgl2,
      xr: xrSupported,
      ar: arSupported,
      vr: vrSupported,
      maxTextureSize: 4096,
      maxDrawCalls: 10000,
      gpuTier: 1
    };

    this.platform = isQuest ? 'quest' : 'browser';
  }

  /**
   * Check WebGL2 support
   */
  private checkWebGL2Support(): boolean {
    try {
      const canvas = document.createElement('canvas');
      return !!canvas.getContext('webgl2');
    } catch {
      return false;
    }
  }

  /**
   * Set up resize handler
   */
  private setupResizeHandler() {
    const handleResize = () => {
      const state = this.state.value;
      if (!state?.canvas || !state.renderer) return;

      const width = window.innerWidth;
      const height = window.innerHeight;
      const pixelRatio = window.devicePixelRatio;

      state.renderer.setSize(width, height);
      state.renderer.setPixelRatio(pixelRatio);

      if (state.camera && 'aspect' in state.camera) {
        state.camera.aspect = width / height;
        state.camera.updateProjectionMatrix();
      }

      state.viewport = {
        width,
        height,
        pixelRatio
      };

      this.resizeCallbacks.forEach(callback => callback(width, height));
    };

    window.addEventListener('resize', handleResize);
  }

  /**
   * Render loop
   */
  private render() {
    const state = this.state.value;
    if (!state?.renderer || !state.scene || !state.camera) return;

    const now = performance.now();
    const deltaTime = now - this.lastFrameTime;
    this.lastFrameTime = now;

    // Update FPS
    state.fps = 1000 / deltaTime;
    state.lastFrameTime = now;

    if (this.platform === 'browser') {
      const browserState = state as BrowserState;
      if (browserState.controls) {
        browserState.controls.update();
      }
    }

    // Execute render callbacks
    this.renderCallbacks.forEach(callback => {
      if (state.renderer && state.scene && state.camera) {
        callback(state.renderer, state.scene, state.camera);
      }
    });

    // Final render
    state.renderer.render(state.scene, state.camera);
  }

  /**
   * Start render loop
   */
  private startRenderLoop() {
    const animate = () => {
      this.render();
      this.animationFrameId = requestAnimationFrame(animate);
    };
    animate();
  }
}

export const platformManager = PlatformManager.getInstance();

----
constants/visualization.ts
import * as THREE from 'three';

export const VISUALIZATION_CONSTANTS = {
  TRANSLATION_SPEED: 0.01,
  ROTATION_SPEED: 0.01,
  VR_MOVEMENT_SPEED: 0.05,
  MIN_CAMERA_DISTANCE: 50,
  MAX_CAMERA_DISTANCE: 500,
  DEFAULT_FOV: 50,
  NEAR_PLANE: 0.1,
  FAR_PLANE: 2000,
  DEFAULT_CAMERA_POSITION: [0, 75, 200] as [number, number, number],
  DEFAULT_CAMERA_TARGET: [0, 0, 0] as [number, number, number]
};

export const WEBGL_CONTEXT_ATTRIBUTES: WebGLContextAttributes = {
  alpha: false,
  antialias: true,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  preserveDrawingBuffer: true,
  xrCompatible: true
};

export const RENDERER_SETTINGS = {
  clearColor: 0x000000,
  clearAlpha: 1,
  pixelRatio: Math.min(window.devicePixelRatio, 2),
  toneMapping: THREE.ACESFilmicToneMapping,
  toneMappingExposure: 1.5,
  outputColorSpace: THREE.SRGBColorSpace
};

export const LIGHT_SETTINGS = {
  ambient: {
    color: 0xffffff,
    intensity: 1.5
  },
  directional: {
    color: 0xffffff,
    intensity: 2.0,
    position: [10, 20, 10] as [number, number, number]
  },
  hemisphere: {
    skyColor: 0xffffff,
    groundColor: 0x444444,
    intensity: 1.5
  },
  points: [
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [100, 100, 100] as [number, number, number]
    },
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [-100, -100, -100] as [number, number, number]
    }
  ]
};

export const CONTROLS_SETTINGS = {
  enableDamping: true,
  dampingFactor: 0.1,
  rotateSpeed: 0.4,
  panSpeed: 0.6,
  zoomSpeed: 1.2,
  minDistance: 50,
  maxDistance: 500
};

----
constants/websocket.ts
// Binary protocol scale factors for network transmission
export const POSITION_SCALE = 10000; // Increased from 1000 to handle larger boundaries (up to 600 units)
export const VELOCITY_SCALE = 20000; // Increased from 10000 to handle higher velocities (up to 20 units)

// WebSocket configuration defaults
export const DEFAULT_RECONNECT_ATTEMPTS = 3;
export const DEFAULT_RECONNECT_DELAY = 5000;
export const DEFAULT_MESSAGE_RATE_LIMIT = 60;
export const DEFAULT_MESSAGE_TIME_WINDOW = 1000;
export const DEFAULT_MAX_MESSAGE_SIZE = 5 * 1024 * 1024; // 5MB
export const DEFAULT_MAX_AUDIO_SIZE = 10 * 1024 * 1024; // 10MB
export const DEFAULT_MAX_QUEUE_SIZE = 1000;

// Binary protocol constants
export const BINARY_UPDATE_HEADER_SIZE = 4; // Float32 for initial layout flag
export const BINARY_UPDATE_NODE_SIZE = 24;  // 6 float32s per node (position + velocity)

// Validation constants
export const MAX_VALID_POSITION = 1000;  // Maximum valid position value
export const MAX_VALID_VELOCITY = 50;    // Maximum valid velocity value

// Debug flags
export const ENABLE_BINARY_DEBUG = true;  // Enable detailed binary update logging
export const ENABLE_POSITION_VALIDATION = true;  // Enable position/velocity validation

----
composables/useForceGraph.ts
import { ref, onBeforeUnmount } from 'vue';
import * as THREE from 'three';
import { useSettingsStore } from '../stores/settings';
import type { Scene, InstancedMesh, Material } from 'three';
import type { Node, Edge } from '../types/core';

interface NodeInstance {
  id: string;
  index: number;
  x: number;
  y: number;
  z: number;
  metadata?: Record<string, any>;
}

interface LinkInstance {
  source: string;
  target: string;
  weight?: number;
}

interface NodeColors {
  NEW: THREE.Color;
  RECENT: THREE.Color;
  MEDIUM: THREE.Color;
  OLD: THREE.Color;
  CORE: THREE.Color;
  SECONDARY: THREE.Color;
  DEFAULT: THREE.Color;
}

interface NodeInstancedMeshes {
  high: THREE.InstancedMesh;
  medium: THREE.InstancedMesh;
  low: THREE.InstancedMesh;
}

interface ForceGraphResources {
  lod: THREE.LOD;
  nodeInstancedMeshes: NodeInstancedMeshes;
  linkInstancedMesh: THREE.InstancedMesh;
  nodeInstances: Map<string, number>;
  linkInstances: Map<string, number>;
  nodeInstanceCount: number;
  linkInstanceCount: number;
}

export function useForceGraph(scene: Scene) {
  const settingsStore = useSettingsStore();
  const resources = ref<ForceGraphResources | null>(null);
  
  // Temporary objects for matrix calculations
  const tempMatrix = new THREE.Matrix4();
  const tempColor = new THREE.Color();
  const tempVector = new THREE.Vector3();
  const tempQuaternion = new THREE.Quaternion();
  const tempScale = new THREE.Vector3();

  // Data
  const nodes = ref<NodeInstance[]>([]);
  const links = ref<LinkInstance[]>([]);

  // Initialize node colors from settings
  const nodeColors: NodeColors = {
    NEW: new THREE.Color(settingsStore.getVisualizationSettings.node_color_new),
    RECENT: new THREE.Color(settingsStore.getVisualizationSettings.node_color_recent),
    MEDIUM: new THREE.Color(settingsStore.getVisualizationSettings.node_color_medium),
    OLD: new THREE.Color(settingsStore.getVisualizationSettings.node_color_old),
    CORE: new THREE.Color(settingsStore.getVisualizationSettings.node_color_core),
    SECONDARY: new THREE.Color(settingsStore.getVisualizationSettings.node_color_secondary),
    DEFAULT: new THREE.Color(settingsStore.getVisualizationSettings.node_color)
  };

  const initInstancedMeshes = () => {
    // Create node geometry with different LOD levels
    const highDetailGeometry = new THREE.SphereGeometry(1, 32, 32);
    const mediumDetailGeometry = new THREE.SphereGeometry(1, 16, 16);
    const lowDetailGeometry = new THREE.SphereGeometry(1, 8, 8);

    const settings = settingsStore.getVisualizationSettings;

    // Create node material
    const nodeMaterial = new THREE.MeshPhysicalMaterial({
      metalness: settings.material.node_material_metalness,
      roughness: settings.material.node_material_roughness,
      transparent: true,
      opacity: settings.material.node_material_opacity,
      envMapIntensity: 1.0,
      clearcoat: settings.material.node_material_clearcoat,
      clearcoatRoughness: settings.material.node_material_clearcoat_roughness
    });

    // Create instanced meshes for each LOD level
    const maxInstances = 10000; // Adjust based on expected graph size
    const nodeInstancedMeshes: NodeInstancedMeshes = {
      high: new THREE.InstancedMesh(highDetailGeometry, nodeMaterial.clone(), maxInstances),
      medium: new THREE.InstancedMesh(mediumDetailGeometry, nodeMaterial.clone(), maxInstances),
      low: new THREE.InstancedMesh(lowDetailGeometry, nodeMaterial.clone(), maxInstances)
    };

    // Create LOD
    const lod = new THREE.LOD();
    lod.addLevel(nodeInstancedMeshes.high, 0);
    lod.addLevel(nodeInstancedMeshes.medium, 10);
    lod.addLevel(nodeInstancedMeshes.low, 20);
    scene.add(lod);

    // Create link geometry
    const linkGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 8, 1);
    linkGeometry.rotateX(Math.PI / 2); // Align with Z-axis

    // Create link material
    const linkMaterial = new THREE.MeshBasicMaterial({
      color: settings.edge_color,
      transparent: true,
      opacity: settings.edge_opacity,
      depthWrite: false
    });

    // Create instanced mesh for links
    const linkInstancedMesh = new THREE.InstancedMesh(
      linkGeometry,
      linkMaterial,
      maxInstances * 2 // Links typically more numerous than nodes
    );
    scene.add(linkInstancedMesh);

    resources.value = {
      lod,
      nodeInstancedMeshes,
      linkInstancedMesh,
      nodeInstances: new Map(),
      linkInstances: new Map(),
      nodeInstanceCount: 0,
      linkInstanceCount: 0
    };
  };

  const getNodeSize = (node: NodeInstance): number => {
    const settings = settingsStore.getVisualizationSettings;
    const baseSize = (node.metadata?.size || 1) * settings.min_node_size;
    const weight = node.metadata?.weight || 1;
    return Math.min(baseSize * Math.sqrt(weight), settings.max_node_size);
  };

  const getNodeColor = (node: NodeInstance): THREE.Color => {
    const type = node.metadata?.type || 'DEFAULT';
    return nodeColors[type as keyof NodeColors] || nodeColors.DEFAULT;
  };

  const calculateEmissiveIntensity = (node: NodeInstance): number => {
    const settings = settingsStore.getVisualizationSettings;
    const lastModified = node.metadata?.github_last_modified || 
                        node.metadata?.last_modified || 
                        new Date().toISOString();
    const now = Date.now();
    const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
    
    const normalizedAge = Math.min(ageInDays / 30, 1);
    return settings.material.node_emissive_max_intensity - 
           (normalizedAge * (settings.material.node_emissive_max_intensity - 
                           settings.material.node_emissive_min_intensity));
  };

  const updateNodes = () => {
    const res = resources.value;
    if (!res) return;

    // Reset instance count
    res.nodeInstanceCount = 0;

    // Update node instances
    nodes.value.forEach((node: NodeInstance, index: number) => {
      const size = getNodeSize(node);
      const color = getNodeColor(node);
      const emissiveIntensity = calculateEmissiveIntensity(node);

      // Set transform matrix
      tempMatrix.compose(
        new THREE.Vector3(node.x, node.y, node.z),
        tempQuaternion,
        new THREE.Vector3(size, size, size)
      );

      // Update instances for each LOD level
      (Object.values(res.nodeInstancedMeshes) as THREE.InstancedMesh[]).forEach(instancedMesh => {
        instancedMesh.setMatrixAt(index, tempMatrix);
        instancedMesh.setColorAt(index, color);
        (instancedMesh.material as THREE.MeshPhysicalMaterial).emissiveIntensity = emissiveIntensity;
      });

      res.nodeInstances.set(node.id, index);
      res.nodeInstanceCount = Math.max(res.nodeInstanceCount, index + 1);
    });

    // Update instance meshes
    (Object.values(res.nodeInstancedMeshes) as THREE.InstancedMesh[]).forEach(instancedMesh => {
      instancedMesh.count = res.nodeInstanceCount;
      instancedMesh.instanceMatrix.needsUpdate = true;
      if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
    });
  };

  const updateLinks = () => {
    const res = resources.value;
    if (!res) return;

    // Reset instance count
    res.linkInstanceCount = 0;

    // Update link instances
    links.value.forEach((link: LinkInstance, index: number) => {
      const sourceIndex = res.nodeInstances.get(link.source);
      const targetIndex = res.nodeInstances.get(link.target);

      if (sourceIndex === undefined || targetIndex === undefined) return;

      const sourceNode = nodes.value[sourceIndex];
      const targetNode = nodes.value[targetIndex];

      const sourcePos = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
      const targetPos = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);

      // Calculate link transform
      const distance = sourcePos.distanceTo(targetPos);
      tempVector.subVectors(targetPos, sourcePos);
      tempQuaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, 1),
        tempVector.normalize()
      );

      tempMatrix.compose(
        sourcePos.lerp(targetPos, 0.5), // Position at midpoint
        tempQuaternion,
        new THREE.Vector3(1, 1, distance)
      );

      // Update link instance
      res.linkInstancedMesh.setMatrixAt(index, tempMatrix);
      
      const weight = link.weight || 1;
      const normalizedWeight = Math.min(weight / 10, 1);
      const settings = settingsStore.getVisualizationSettings;
      tempColor.set(settings.edge_color).multiplyScalar(normalizedWeight);
      res.linkInstancedMesh.setColorAt(index, tempColor);

      res.linkInstances.set(`${link.source}-${link.target}`, index);
      res.linkInstanceCount = Math.max(res.linkInstanceCount, index + 1);
    });

    // Update link instance mesh
    res.linkInstancedMesh.count = res.linkInstanceCount;
    res.linkInstancedMesh.instanceMatrix.needsUpdate = true;
    if (res.linkInstancedMesh.instanceColor) {
      res.linkInstancedMesh.instanceColor.needsUpdate = true;
    }
  };

  const updateGraph = (graphNodes: Node[], graphEdges: Edge[]) => {
    // Convert graph data to internal format
    nodes.value = graphNodes.map(node => ({
      id: node.id,
      index: 0,
      x: node.position?.[0] || 0,
      y: node.position?.[1] || 0,
      z: node.position?.[2] || 0,
      metadata: node.metadata
    }));

    links.value = graphEdges.map(edge => ({
      source: edge.source,
      target: edge.target,
      weight: edge.weight
    }));

    // Update visualization
    updateNodes();
    updateLinks();
  };

  const dispose = () => {
    const res = resources.value;
    if (!res) return;

    // Dispose of node resources
    (Object.values(res.nodeInstancedMeshes) as THREE.InstancedMesh[]).forEach(instancedMesh => {
      instancedMesh.geometry.dispose();
      if (instancedMesh.material instanceof THREE.Material) {
        instancedMesh.material.dispose();
      } else if (Array.isArray(instancedMesh.material)) {
        instancedMesh.material.forEach((mat: Material) => mat.dispose());
      }
    });

    // Dispose of link resources
    res.linkInstancedMesh.geometry.dispose();
    if (res.linkInstancedMesh.material instanceof THREE.Material) {
      res.linkInstancedMesh.material.dispose();
    } else if (Array.isArray(res.linkInstancedMesh.material)) {
      res.linkInstancedMesh.material.forEach((mat: Material) => mat.dispose());
    }

    // Remove from scene
    scene.remove(res.lod);
    scene.remove(res.linkInstancedMesh);

    // Clear collections
    res.nodeInstances.clear();
    res.linkInstances.clear();
    nodes.value = [];
    links.value = [];
    resources.value = null;
  };

  // Initialize on creation
  initInstancedMeshes();

  // Clean up on unmount
  onBeforeUnmount(() => {
    dispose();
  });

  return {
    updateGraph,
    dispose
  };
}

----
composables/useEffectsSystem.ts
import { ref, computed, watch, onMounted, onBeforeUnmount } from 'vue';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
import { useSettingsStore } from '@stores/settings';
import { usePlatform } from './usePlatform';
import { PASS_OUTPUT } from '../utils/threeUtils';

// Configure color management for modern Three.js
THREE.ColorManagement.enabled = true;

interface ExtendedUnrealBloomPass extends UnrealBloomPass {
  selectedObjects?: THREE.Object3D[];
}

export function useEffectsSystem(
  renderer: THREE.WebGLRenderer,
  scene: THREE.Scene,
  camera: THREE.PerspectiveCamera
) {
  const settingsStore = useSettingsStore();
  const { getPlatformInfo } = usePlatform();

  // Effect composer and passes
  const composer = ref<EffectComposer | null>(null);
  const bloomPass = ref<ExtendedUnrealBloomPass | null>(null);
  const ssaoPass = ref<SSAOPass | null>(null);
  const fxaaPass = ref<ShaderPass | null>(null);

  // Settings
  const bloomSettings = computed(() => settingsStore.getBloomSettings);
  const platformInfo = computed(() => getPlatformInfo());

  // Resolution
  const resolution = computed(() => {
    const pixelRatio = renderer.getPixelRatio();
    const size = new THREE.Vector2();
    renderer.getSize(size);
    return new THREE.Vector2(
      size.width * pixelRatio,
      size.height * pixelRatio
    );
  });

  // Initialize effect composer
  const initializeComposer = () => {
    // Create render target with appropriate color space
    const renderTarget = new THREE.WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight,
      {
        colorSpace: THREE.SRGBColorSpace,
        samples: (renderer as any).capabilities.isWebGL2 ? 4 : 0
      }
    );

    // Create new composer
    composer.value = new EffectComposer(renderer as any, renderTarget as any);

    // Add render pass
    const renderPass = new RenderPass(scene as any, camera as any);
    (composer.value as any).addPass(renderPass);

    // Initialize bloom if enabled
    if (bloomSettings.value.enabled) {
      const bloom = new UnrealBloomPass(
        resolution.value,
        bloomSettings.value.strength,
        bloomSettings.value.radius,
        bloomSettings.value.threshold
      ) as ExtendedUnrealBloomPass;
      bloomPass.value = bloom;
      (composer.value as any).addPass(bloom);
    }

    // Initialize SSAO for browser platform
    if (platformInfo.value.isBrowser) {
      const ssao = new SSAOPass(scene as any, camera as any);
      ssao.output = PASS_OUTPUT.Default;
      ssaoPass.value = ssao;
      (composer.value as any).addPass(ssao);
    }

    // Initialize FXAA
    const fxaa = new ShaderPass(FXAAShader);
    const uniforms = fxaa.material.uniforms;
    if (uniforms['resolution']) {
      uniforms['resolution'].value.x = 1 / resolution.value.x;
      uniforms['resolution'].value.y = 1 / resolution.value.y;
    }
    fxaaPass.value = fxaa;
    (composer.value as any).addPass(fxaa);
  };

  // Update effect settings
  const updateBloomSettings = () => {
    if (!bloomPass.value) return;

    const settings = bloomSettings.value;
    bloomPass.value.strength = settings.strength;
    bloomPass.value.radius = settings.radius;
    bloomPass.value.threshold = settings.threshold;

    // Update selective bloom settings
    const selectedObjects: THREE.Object3D[] = [];

    // Add objects based on bloom settings
    scene.traverse((object) => {
      if (object.userData.bloomLayer) {
        if (settings.node_bloom_strength > 0 && object.userData.type === 'node') {
          selectedObjects.push(object);
        }
        if (settings.edge_bloom_strength > 0 && object.userData.type === 'edge') {
          selectedObjects.push(object);
        }
        if (settings.environment_bloom_strength > 0 && object.userData.type === 'environment') {
          selectedObjects.push(object);
        }
      }
    });

    // Set selected objects for bloom
    bloomPass.value.selectedObjects = selectedObjects;
  };

  // Handle resize
  const handleResize = () => {
    if (!composer.value || !fxaaPass.value) return;

    const size = new THREE.Vector2();
    renderer.getSize(size);
    composer.value.setSize(size.width, size.height);

    // Update FXAA resolution
    const pixelRatio = renderer.getPixelRatio();
    const uniforms = fxaaPass.value.material.uniforms;
    if (uniforms['resolution']) {
      uniforms['resolution'].value.x = 1 / (size.width * pixelRatio);
      uniforms['resolution'].value.y = 1 / (size.height * pixelRatio);
    }
  };

  // Render function
  const render = () => {
    if (composer.value) {
      composer.value.render();
    }
  };

  // Watch for settings changes
  watch(() => bloomSettings.value, () => {
    updateBloomSettings();
  }, { deep: true });

  // Lifecycle
  onMounted(() => {
    initializeComposer();
    window.addEventListener('resize', handleResize);
  });

  onBeforeUnmount(() => {
    window.removeEventListener('resize', handleResize);
    
    // Dispose of resources
    if (composer.value) {
      composer.value.passes.forEach(pass => {
        if ('dispose' in pass && typeof pass.dispose === 'function') {
          pass.dispose();
        }
      });
    }

    // Clear references
    bloomPass.value = null;
    ssaoPass.value = null;
    fxaaPass.value = null;
    composer.value = null;
  });

  return {
    composer,
    bloomPass,
    ssaoPass,
    fxaaPass,
    render,
    handleResize,
    updateBloomSettings
  };
}

----
composables/useControlGroups.ts
import { ref, reactive } from 'vue';
import type { ControlGroup, ControlItem } from '../types/components';

export function useControlGroups() {
  const collapsedGroups = reactive<Record<string, boolean>>({
    appearance: true,
    material: true,
    physics: true,
    bloom: true,
    environment: true,
    fisheye: true
  });

  const toggleGroup = (groupName: string) => {
    collapsedGroups[groupName] = !collapsedGroups[groupName];
  };

  const createControlGroup = (
    name: string,
    label: string,
    controls: ControlItem[]
  ): ControlGroup => ({
    name,
    label,
    controls,
    collapsed: collapsedGroups[name]
  });

  const createRangeControl = (
    name: string,
    label: string,
    value: number,
    min: number,
    max: number,
    step: number
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'range',
    min,
    max,
    step
  });

  const createColorControl = (
    name: string,
    label: string,
    value: string
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'color'
  });

  const createCheckboxControl = (
    name: string,
    label: string,
    value: boolean
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'checkbox'
  });

  return {
    collapsedGroups,
    toggleGroup,
    createControlGroup,
    createRangeControl,
    createColorControl,
    createCheckboxControl
  };
}

----
composables/useVisualization.ts
import { ref, computed, onBeforeUnmount, provide, markRaw, shallowRef } from 'vue';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { useSettingsStore } from '../stores/settings';
import type { Node, Edge, CoreState, InitializationOptions, GraphNode, GraphEdge } from '../types/core';
import type { PositionUpdate } from '../types/websocket';
import { POSITION_SCALE, VELOCITY_SCALE } from '../constants/websocket';
import { VISUALIZATION_CONSTANTS, LIGHT_SETTINGS } from '../constants/visualization';

// Symbol for providing scene to components
export const SCENE_KEY = Symbol('three-scene');

// Adjusted camera settings for scaled positions
const CAMERA_SETTINGS = {
  fov: 60,
  near: 0.01,
  far: 10000,
  position: new THREE.Vector3(0, 0.5, 2),
  target: new THREE.Vector3(0, 0, 0)
};

// Scene settings
const SCENE_SETTINGS = {
  fogNear: 1,
  fogFar: 5,
  gridSize: 2,
  gridDivisions: 20
};

// Helper function to scale positions
const scalePosition = (pos: [number, number, number]): [number, number, number] => [
  pos[0] / POSITION_SCALE,
  pos[1] / POSITION_SCALE,
  pos[2] / POSITION_SCALE
];

export function useVisualization() {
  const settingsStore = useSettingsStore();
  
  // Core visualization state - using shallowRef for Three.js objects
  const state = shallowRef<CoreState>({
    renderer: null,
    camera: null,
    scene: null,
    canvas: null,
    isInitialized: false,
    isXRSupported: false,
    isWebGL2: false,
    isGPUMode: false,
    fps: 0,
    lastFrameTime: 0
  });

  // Track meshes for updates - using Maps to avoid reactivity issues
  const nodeMeshes = new Map<string, THREE.Mesh>();
  const edgeMeshes = new Map<string, THREE.Line>();
  const nodeContainer = markRaw(new THREE.Group());
  const edgeContainer = markRaw(new THREE.Group());
  
  // Track animation frame for cleanup
  let animationFrameId: number | null = null;
  let controls: OrbitControls | null = null;

  // Create or update node mesh
  const createNodeMesh = (node: Node): THREE.Mesh => {
    const geometry = new THREE.SphereGeometry(0.02, 32, 32); // Smaller radius for scaled scene
    const material = new THREE.MeshStandardMaterial({
      color: node.color || 0xffffff,
      metalness: 0.3,
      roughness: 0.7,
      emissive: node.color || 0xffffff,
      emissiveIntensity: 0.2
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    // Set initial position
    if (node.position) {
      const scaledPos = scalePosition(node.position);
      mesh.position.set(...scaledPos);
    }
    
    // Set scale based on node size
    const size = (node.size || 1) * 0.02; // Smaller scale for scaled scene
    mesh.scale.setScalar(size);

    // Store node data in userData
    mesh.userData = {
      id: node.id,
      type: 'node',
      originalData: { ...node }
    };

    return markRaw(mesh);
  };

  // Create or update edge mesh
  const createEdgeMesh = (edge: Edge, startPos: THREE.Vector3, endPos: THREE.Vector3): THREE.Line => {
    const geometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
    const material = new THREE.LineBasicMaterial({
      color: edge.color || 0xffffff,
      linewidth: (edge.width || 1) * 0.02 // Smaller width for scaled scene
    });

    const line = new THREE.Line(geometry, material);
    line.userData = {
      id: edge.id,
      type: 'edge',
      originalData: { ...edge }
    };

    return markRaw(line);
  };

  // Initialize Three.js scene
  const initScene = (canvas: HTMLCanvasElement) => {
    console.debug('Initializing Three.js scene...');

    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, SCENE_SETTINGS.fogNear, SCENE_SETTINGS.fogFar);

    // Add containers to scene
    scene.add(nodeContainer);
    scene.add(edgeContainer);

    // Initialize scene userData
    scene.userData = {
      needsRender: true,
      lastUpdate: performance.now(),
      nodeContainer,
      edgeContainer
    };

    // Create camera
    const camera = new THREE.PerspectiveCamera(
      CAMERA_SETTINGS.fov,
      window.innerWidth / window.innerHeight,
      CAMERA_SETTINGS.near,
      CAMERA_SETTINGS.far
    );
    camera.position.copy(CAMERA_SETTINGS.position);
    camera.lookAt(CAMERA_SETTINGS.target);

    // Create renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance',
      logarithmicDepthBuffer: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Add lights
    const ambientLight = new THREE.AmbientLight(
      LIGHT_SETTINGS.ambient.color,
      LIGHT_SETTINGS.ambient.intensity
    );
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(
      LIGHT_SETTINGS.directional.color,
      LIGHT_SETTINGS.directional.intensity
    );
    directionalLight.position.set(...LIGHT_SETTINGS.directional.position);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    const hemiLight = new THREE.HemisphereLight(
      LIGHT_SETTINGS.hemisphere.skyColor,
      LIGHT_SETTINGS.hemisphere.groundColor,
      LIGHT_SETTINGS.hemisphere.intensity
    );
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    // Add controls
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxDistance = 5; // Adjusted for scaled scene
    controls.minDistance = 0.1; // Adjusted for scaled scene
    controls.maxPolarAngle = Math.PI * 0.8;
    controls.target.copy(CAMERA_SETTINGS.target);

    // Add grid helper for scale reference
    const gridHelper = new THREE.GridHelper(
      SCENE_SETTINGS.gridSize,
      SCENE_SETTINGS.gridDivisions,
      0x444444,
      0x222222
    );
    scene.add(gridHelper);

    // Add axes helper for orientation
    const axesHelper = new THREE.AxesHelper(1); // Smaller for scaled scene
    scene.add(axesHelper);

    // Provide scene to components
    provide(SCENE_KEY, scene);

    // Return raw objects
    return {
      scene: markRaw(scene),
      camera: markRaw(camera),
      renderer: markRaw(renderer)
    };
  };

  // Animation loop
  const animate = () => {
    if (!state.value.isInitialized) return;

    const { renderer, scene, camera } = state.value;
    if (renderer && scene && camera) {
      controls?.update();

      const currentTime = performance.now();
      const delta = currentTime - state.value.lastFrameTime;
      state.value.fps = 1000 / delta;
      state.value.lastFrameTime = currentTime;

      const needsRender = scene.userData?.needsRender !== false || 
                         controls?.enabled || 
                         currentTime - (scene.userData?.lastUpdate || 0) > 1000;

      if (needsRender) {
        renderer.render(scene, camera);
        scene.userData.needsRender = false;
        scene.userData.lastUpdate = currentTime;

        // Log performance stats in development
        if (process.env.NODE_ENV === 'development' && currentTime % 5000 < 16) {
          console.debug('Render stats:', {
            fps: state.value.fps.toFixed(1),
            meshes: nodeMeshes.size,
            edges: edgeMeshes.size,
            drawCalls: renderer.info.render.calls,
            triangles: renderer.info.render.triangles
          });
        }
      }
    }

    animationFrameId = requestAnimationFrame(animate);
  };

  // Initialize visualization system
  const initialize = async (options: InitializationOptions) => {
    if (state.value.isInitialized) return;

    try {
      const { scene, camera, renderer } = initScene(options.canvas);

      state.value = markRaw({
        renderer,
        camera,
        scene,
        canvas: options.canvas,
        isInitialized: true,
        isXRSupported: false,
        isWebGL2: renderer.capabilities.isWebGL2,
        isGPUMode: false,
        fps: 0,
        lastFrameTime: performance.now()
      });

      animate();

      // Handle window resize
      const handleResize = () => {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      };
      window.addEventListener('resize', handleResize);

      console.log('Visualization system initialized');
    } catch (error) {
      console.error('Failed to initialize visualization:', error);
      throw error;
    }
  };

  // Handle binary position updates
  const updatePositions = (positions: PositionUpdate[], isInitialLayout: boolean) => {
    if (!state.value.scene || !state.value.isInitialized) return;

    positions.forEach(pos => {
      const mesh = nodeMeshes.get(pos.id);
      if (mesh) {
        // Positions are already scaled in WebSocket service
        mesh.position.set(pos.x, pos.y, pos.z);

        // Store velocity in userData for potential use in animations
        mesh.userData.velocity = new THREE.Vector3(pos.vx, pos.vy, pos.vz);

        // Update connected edges
        const nodeData = mesh.userData.originalData as GraphNode;
        if (nodeData.edges) {
          nodeData.edges.forEach((edge: GraphEdge) => {
            const edgeId = `${edge.source}-${edge.target}`;
            const edgeMesh = edgeMeshes.get(edgeId);
            if (edgeMesh) {
              const geometry = edgeMesh.geometry as THREE.BufferGeometry;
              const positions = geometry.getAttribute('position');
              
              if (edge.source === pos.id) {
                positions.setXYZ(0, mesh.position.x, mesh.position.y, mesh.position.z);
              } else if (edge.target === pos.id) {
                positions.setXYZ(1, mesh.position.x, mesh.position.y, mesh.position.z);
              }
              positions.needsUpdate = true;
            }
          });
        }
      }
    });

    if (state.value.scene) {
      state.value.scene.userData.needsRender = true;
    }

    // Log update in development
    if (process.env.NODE_ENV === 'development') {
      const samplePos = positions[0];
      console.debug('Position update:', {
        count: positions.length,
        isInitial: isInitialLayout,
        meshCount: nodeMeshes.size,
        sample: samplePos ? {
          id: samplePos.id,
          position: [samplePos.x, samplePos.y, samplePos.z],
          velocity: [samplePos.vx, samplePos.vy, samplePos.vz]
        } : null
      });
    }
  };

  // Update nodes
  const updateNodes = (nodes: Node[]) => {
    if (!state.value.scene) return;

    // Remove old nodes
    const currentIds = new Set(nodes.map(n => n.id));
    nodeMeshes.forEach((mesh, id) => {
      if (!currentIds.has(id)) {
        nodeContainer.remove(mesh);
        mesh.geometry.dispose();
        (mesh.material as THREE.Material).dispose();
        nodeMeshes.delete(id);
      }
    });

    // Add or update nodes
    nodes.forEach(node => {
      let mesh = nodeMeshes.get(node.id);
      
      if (!mesh) {
        // Create new mesh
        mesh = createNodeMesh(node);
        nodeContainer.add(mesh);
        nodeMeshes.set(node.id, mesh);
      } else {
        // Update existing mesh
        if (node.position) {
          const scaledPos = scalePosition(node.position);
          mesh.position.set(...scaledPos);
        }
        if (node.size) {
          const size = node.size * 0.1;
          mesh.scale.setScalar(size);
        }
        if (node.color) {
          (mesh.material as THREE.MeshStandardMaterial).color.set(node.color);
          (mesh.material as THREE.MeshStandardMaterial).emissive.set(node.color);
        }
      }

      // Update edges if node is a GraphNode
      const graphNode = node as GraphNode;
      if (graphNode.edges) {
        graphNode.edges.forEach(edge => {
          const edgeId = `${edge.source}-${edge.target}`;
          let edgeMesh = edgeMeshes.get(edgeId);
          
          if (!edgeMesh) {
            const startNode = nodeMeshes.get(edge.source);
            const endNode = nodeMeshes.get(edge.target);
            if (startNode && endNode) {
              edgeMesh = createEdgeMesh(edge, startNode.position, endNode.position);
              edgeContainer.add(edgeMesh);
              edgeMeshes.set(edgeId, edgeMesh);
            }
          }
        });
      }
    });

    if (state.value.scene) {
      state.value.scene.userData.needsRender = true;
    }

    // Log update in development
    if (process.env.NODE_ENV === 'development') {
      console.debug('Nodes updated:', {
        count: nodes.length,
        meshCount: nodeMeshes.size,
        edgeCount: edgeMeshes.size,
        sample: nodes[0] ? {
          id: nodes[0].id,
          position: nodes[0].position ? scalePosition(nodes[0].position) : null,
          size: nodes[0].size
        } : null
      });
    }
  };

  // Cleanup
  onBeforeUnmount(() => {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
    }

    if (controls) {
      controls.dispose();
    }

    // Clean up meshes
    nodeMeshes.forEach(mesh => {
      mesh.geometry.dispose();
      (mesh.material as THREE.Material).dispose();
    });
    nodeMeshes.clear();

    edgeMeshes.forEach(edge => {
      edge.geometry.dispose();
      (edge.material as THREE.Material).dispose();
    });
    edgeMeshes.clear();

    if (state.value.renderer) {
      state.value.renderer.dispose();
      state.value.renderer.forceContextLoss();
    }
    
    state.value.canvas?.remove();
    state.value = {
      renderer: null,
      camera: null,
      scene: null,
      canvas: null,
      isInitialized: false,
      isXRSupported: false,
      isWebGL2: false,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0
    };
  });

  return {
    state,
    initialize,
    updateNodes,
    updatePositions
  };
}

----
composables/useControlSettings.ts
import { computed } from 'vue';
import type { 
  VisualizationConfig, 
  BloomConfig, 
  FisheyeConfig,
  ControlGroup,
  ControlItem 
} from '../types/components';
import { useControlGroups } from './useControlGroups';
import { useSettingsStore } from '../stores/settings';
import { storeToRefs } from 'pinia';

export function useControlSettings() {
  const settingsStore = useSettingsStore();
  const { 
    createControlGroup, 
    createRangeControl, 
    createColorControl, 
    createCheckboxControl 
  } = useControlGroups();

  // Create appearance controls
  const createAppearanceGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createColorControl('node_color', 'Base Node Color', config.node_color),
      createColorControl('node_color_new', 'New Nodes', config.node_color_new),
      createColorControl('node_color_recent', 'Recent Nodes', config.node_color_recent),
      createColorControl('node_color_medium', 'Medium Age', config.node_color_medium),
      createColorControl('node_color_old', 'Old Nodes', config.node_color_old),
      createColorControl('node_color_core', 'Core Nodes', config.node_color_core),
      createColorControl('node_color_secondary', 'Secondary Nodes', config.node_color_secondary),
      createRangeControl('min_node_size', 'Minimum Size', config.min_node_size, 0.05, 0.5, 0.05),
      createRangeControl('max_node_size', 'Maximum Size', config.max_node_size, 0.1, 1.0, 0.1)
    ];

    return createControlGroup('appearance', 'Node Appearance', controls);
  };

  // Create material controls
  const createMaterialGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('node_material_metalness', 'Metalness', config.material.node_material_metalness, 0, 1, 0.1),
      createRangeControl('node_material_roughness', 'Roughness', config.material.node_material_roughness, 0, 1, 0.1),
      createRangeControl('node_material_clearcoat', 'Clearcoat', config.material.node_material_clearcoat, 0, 1, 0.1),
      createRangeControl('node_material_clearcoat_roughness', 'Clearcoat Roughness', config.material.node_material_clearcoat_roughness, 0, 1, 0.1),
      createRangeControl('node_material_opacity', 'Opacity', config.material.node_material_opacity, 0, 1, 0.1),
      createRangeControl('node_emissive_min_intensity', 'Min Emissive', config.material.node_emissive_min_intensity, 0, 1, 0.1),
      createRangeControl('node_emissive_max_intensity', 'Max Emissive', config.material.node_emissive_max_intensity, 0, 2, 0.1)
    ];

    return createControlGroup('material', 'Material Properties', controls);
  };

  // Create physics controls
  const createPhysicsGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('force_directed_iterations', 'Iterations', config.physics.force_directed_iterations, 100, 500, 10),
      createRangeControl('force_directed_spring', 'Spring Strength', config.physics.force_directed_spring, 0.001, 0.1, 0.001),
      createRangeControl('force_directed_repulsion', 'Repulsion', config.physics.force_directed_repulsion, 100, 2000, 100),
      createRangeControl('force_directed_attraction', 'Attraction', config.physics.force_directed_attraction, 0.001, 0.1, 0.001),
      createRangeControl('force_directed_damping', 'Damping', config.physics.force_directed_damping, 0.1, 1.0, 0.1)
    ];

    return createControlGroup('physics', 'Physics Simulation', controls);
  };

  // Create bloom controls
  const createBloomGroup = (config: BloomConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('node_bloom_strength', 'Node Strength', config.node_bloom_strength, 0, 2, 0.1),
      createRangeControl('node_bloom_radius', 'Node Radius', config.node_bloom_radius, 0, 1, 0.1),
      createRangeControl('node_bloom_threshold', 'Node Threshold', config.node_bloom_threshold, 0, 1, 0.1),
      createRangeControl('edge_bloom_strength', 'Edge Strength', config.edge_bloom_strength, 0, 2, 0.1),
      createRangeControl('edge_bloom_radius', 'Edge Radius', config.edge_bloom_radius, 0, 1, 0.1),
      createRangeControl('edge_bloom_threshold', 'Edge Threshold', config.edge_bloom_threshold, 0, 1, 0.1),
      createRangeControl('environment_bloom_strength', 'Environment Strength', config.environment_bloom_strength, 0, 2, 0.1),
      createRangeControl('environment_bloom_radius', 'Environment Radius', config.environment_bloom_radius, 0, 1, 0.1),
      createRangeControl('environment_bloom_threshold', 'Environment Threshold', config.environment_bloom_threshold, 0, 1, 0.1)
    ];

    return createControlGroup('bloom', 'Bloom Effects', controls);
  };

  // Create environment controls
  const createEnvironmentGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createColorControl('hologram_color', 'Hologram Color', config.hologram_color),
      createRangeControl('hologram_scale', 'Hologram Scale', config.hologram_scale, 1, 10, 1),
      createRangeControl('hologram_opacity', 'Hologram Opacity', config.hologram_opacity, 0, 1, 0.05),
      createRangeControl('fog_density', 'Fog Density', config.fog_density, 0, 0.01, 0.0001)
    ];

    return createControlGroup('environment', 'Environment', controls);
  };

  // Create fisheye controls
  const createFisheyeGroup = (config: FisheyeConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createCheckboxControl('enabled', 'Enable Fisheye', config.enabled),
      createRangeControl('strength', 'Strength', config.strength, 0, 1, 0.1),
      createRangeControl('radius', 'Radius', config.radius, 10, 200, 10),
      createRangeControl('focus_x', 'Focus X', config.focus_x, -100, 100, 1),
      createRangeControl('focus_y', 'Focus Y', config.focus_y, -100, 100, 1),
      createRangeControl('focus_z', 'Focus Z', config.focus_z, -100, 100, 1)
    ];

    return createControlGroup('fisheye', 'Fisheye Effect', controls);
  };

  // Handle control changes
  const handleControlChange = (groupName: string, controlName: string, value: any) => {
    const { getVisualizationSettings } = storeToRefs(settingsStore);
    const currentSettings = getVisualizationSettings.value;

    switch (groupName) {
      case 'appearance':
      case 'environment':
        settingsStore.updateVisualizationSettings({ [controlName]: value });
        break;
      case 'material':
        settingsStore.updateVisualizationSettings({
          material: {
            ...currentSettings.material,
            [controlName]: value
          }
        });
        break;
      case 'physics':
        settingsStore.updateVisualizationSettings({
          physics: {
            ...currentSettings.physics,
            [controlName]: value
          }
        });
        break;
      case 'bloom':
        settingsStore.updateBloomSettings({ [controlName]: value });
        break;
      case 'fisheye':
        settingsStore.updateFisheyeSettings({ [controlName]: value });
        break;
    }
  };

  return {
    createAppearanceGroup,
    createMaterialGroup,
    createPhysicsGroup,
    createBloomGroup,
    createEnvironmentGroup,
    createFisheyeGroup,
    handleControlChange
  };
}

----
composables/useGraphSystem.ts
import { ref, computed, inject, onMounted, watch } from 'vue';
import { Vector3, Scene, Group } from 'three';
import { useVisualizationStore } from '../stores/visualization';
import type { GraphNode, GraphEdge } from '../types/core';
import type { VisualizationConfig } from '../types/components';
import type { CoreState } from '../types/core';

export function useGraphSystem() {
  const visualizationStore = useVisualizationStore();
  
  // Get scene from visualization state
  const visualizationState = inject<{ value: CoreState }>('visualizationState');
  
  // Create Three.js groups
  const graphGroup = new Group();
  const nodesGroup = new Group();
  const edgesGroup = new Group();

  // Add groups to scene hierarchy
  graphGroup.add(nodesGroup);
  graphGroup.add(edgesGroup);

  // Initialize scene when available
  watch(() => visualizationState?.value.scene, (scene) => {
    if (scene) {
      console.debug('Initializing graph system with scene:', {
        sceneId: scene.id,
        timestamp: new Date().toISOString()
      });

      // Add groups to scene
      scene.add(graphGroup);

      // Initialize scene userData if needed
      scene.userData = scene.userData || {};
      scene.userData.graphGroup = graphGroup;
      scene.userData.nodesGroup = nodesGroup;
      scene.userData.edgesGroup = edgesGroup;

      console.debug('Graph system groups created:', {
        graphGroup: graphGroup.id,
        nodesGroup: nodesGroup.id,
        edgesGroup: edgesGroup.id,
        sceneChildren: scene.children.length,
        timestamp: new Date().toISOString()
      });
    }
  }, { immediate: true });

  // State
  const hoveredNode = ref<string | null>(null);

  // Node position management with caching
  const nodePositions = new Map<string, Vector3>();
  const nodeVelocities = new Map<string, Vector3>();
  const positionCache = new Map<string, { position: Vector3; timestamp: number }>();

  // Watch for graph data changes with enhanced logging
  watch(() => visualizationStore.getGraphData, (newData) => {
    if (newData && visualizationState?.value.scene) {
      console.debug('Graph data update detected:', {
        nodes: newData.nodes.length,
        edges: newData.edges.length,
        hasScene: !!visualizationState.value.scene,
        timestamp: new Date().toISOString()
      });

      const scene = visualizationState.value.scene;
      // Mark scene for update
      scene.userData.needsRender = true;
      scene.userData.lastUpdate = performance.now();

      // Update graph data
      updateGraphData(newData);
    }
  }, { deep: true });

  // Get settings from store
  const settings = computed<VisualizationConfig>(() => {
    return visualizationStore.getVisualizationSettings;
  });

  // Node helpers with enhanced logging
  const getNodePosition = (node: GraphNode): Vector3 => {
    // Check cache first
    const cached = positionCache.get(node.id);
    const now = Date.now();
    if (cached && now - cached.timestamp < 1000) {
      return cached.position;
    }

    if (!nodePositions.has(node.id)) {
      console.debug('Creating new node position:', {
        nodeId: node.id,
        hasDefinedPosition: !!node.position,
        timestamp: new Date().toISOString()
      });

      const position = node.position 
        ? new Vector3(...node.position)
        : new Vector3(
            Math.random() * 100 - 50,
            Math.random() * 100 - 50,
            Math.random() * 100 - 50
          );
      nodePositions.set(node.id, position);
      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
      }
    }

    const position = nodePositions.get(node.id)!;
    positionCache.set(node.id, { position: position.clone(), timestamp: now });
    return position;
  };

  const getNodeScale = (node: GraphNode): number => {
    const baseSize = node.size || 1;
    const minSize = settings.value.min_node_size;
    const maxSize = settings.value.max_node_size;
    const scale = minSize + (baseSize * (maxSize - minSize));

    console.debug('Node scale calculated:', {
      nodeId: node.id,
      baseSize,
      minSize,
      maxSize,
      finalScale: scale,
      timestamp: new Date().toISOString()
    });

    return scale;
  };

  const getNodeColor = (node: GraphNode): string => {
    const color = node.id === hoveredNode.value
      ? settings.value.node_color_core
      : (node.color || settings.value.node_color);

    console.debug('Node color determined:', {
      nodeId: node.id,
      isHovered: node.id === hoveredNode.value,
      hasCustomColor: !!node.color,
      finalColor: color,
      timestamp: new Date().toISOString()
    });

    return color;
  };

  // Edge helpers with enhanced logging
  const getEdgePoints = (edge: GraphEdge): [Vector3, Vector3] => {
    const sourceNode = edge.sourceNode;
    const targetNode = edge.targetNode;
    
    if (!sourceNode || !targetNode) {
      console.warn('Edge missing nodes:', {
        edge: `${edge.source}-${edge.target}`,
        hasSource: !!sourceNode,
        hasTarget: !!targetNode,
        timestamp: new Date().toISOString()
      });
      return [new Vector3(), new Vector3()];
    }

    const sourcePos = getNodePosition(sourceNode);
    const targetPos = getNodePosition(targetNode);

    console.debug('Edge points calculated:', {
      edgeId: `${edge.source}-${edge.target}`,
      sourcePosition: sourcePos.toArray(),
      targetPosition: targetPos.toArray(),
      timestamp: new Date().toISOString()
    });

    return [sourcePos, targetPos];
  };

  const getEdgeColor = (edge: GraphEdge): string => {
    const color = edge.color || settings.value.edge_color;

    console.debug('Edge color determined:', {
      edgeId: `${edge.source}-${edge.target}`,
      hasCustomColor: !!edge.color,
      finalColor: color,
      timestamp: new Date().toISOString()
    });

    return color;
  };

  const getEdgeWidth = (edge: GraphEdge): number => {
    const baseWidth = edge.weight || 1;
    const minWidth = settings.value.edge_min_width;
    const maxWidth = settings.value.edge_max_width;
    const width = minWidth + (baseWidth * (maxWidth - minWidth));

    console.debug('Edge width calculated:', {
      edgeId: `${edge.source}-${edge.target}`,
      baseWidth,
      minWidth,
      maxWidth,
      finalWidth: width,
      timestamp: new Date().toISOString()
    });

    return width;
  };

  // Event handlers with enhanced logging
  const handleNodeClick = (node: GraphNode) => {
    console.debug('Node clicked:', {
      id: node.id,
      position: getNodePosition(node).toArray(),
      scale: getNodeScale(node),
      color: getNodeColor(node),
      timestamp: new Date().toISOString()
    });
  };

  const handleNodeHover = (node: GraphNode | null) => {
    console.debug('Node hover state changed:', {
      previousHovered: hoveredNode.value,
      newHovered: node?.id || null,
      timestamp: new Date().toISOString()
    });

    hoveredNode.value = node?.id || null;
    if (visualizationState?.value.scene) {
      visualizationState.value.scene.userData.needsRender = true;
    }
  };

  // Graph data management with enhanced logging
  const updateGraphData = (graphData: { nodes: GraphNode[]; edges: GraphEdge[] }) => {
    console.debug('Starting graph data update:', {
      nodeCount: graphData.nodes.length,
      edgeCount: graphData.edges.length,
      existingPositions: nodePositions.size,
      timestamp: new Date().toISOString()
    });

    // Initialize positions for new nodes
    let newNodeCount = 0;
    graphData.nodes.forEach(node => {
      if (!nodePositions.has(node.id)) {
        getNodePosition(node);
        newNodeCount++;
      }
    });

    // Clean up removed nodes
    const nodeIds = new Set(graphData.nodes.map(n => n.id));
    let removedNodeCount = 0;
    nodePositions.forEach((_, id) => {
      if (!nodeIds.has(id)) {
        nodePositions.delete(id);
        nodeVelocities.delete(id);
        positionCache.delete(id);
        removedNodeCount++;
      }
    });

    console.debug('Graph data update completed:', {
      totalNodes: graphData.nodes.length,
      newNodes: newNodeCount,
      removedNodes: removedNodeCount,
      finalPositionCount: nodePositions.size,
      timestamp: new Date().toISOString()
    });

    // Mark scene for update
    if (visualizationState?.value.scene) {
      visualizationState.value.scene.userData.needsRender = true;
      visualizationState.value.scene.userData.lastUpdate = performance.now();
    }
  };

  // Clean up on unmount
  onMounted(() => {
    if (visualizationState?.value.scene) {
      console.debug('Graph system mounted:', {
        groups: {
          graph: graphGroup.id,
          nodes: nodesGroup.id,
          edges: edgesGroup.id
        },
        sceneChildren: visualizationState.value.scene.children.length,
        timestamp: new Date().toISOString()
      });
    }
  });

  return {
    // Groups
    graphGroup,
    nodesGroup,
    edgesGroup,
    
    // State
    hoveredNode,
    
    // Node helpers
    getNodePosition,
    getNodeScale,
    getNodeColor,
    
    // Edge helpers
    getEdgePoints,
    getEdgeColor,
    getEdgeWidth,
    
    // Event handlers
    handleNodeClick,
    handleNodeHover,
    
    // Data management
    updateGraphData
  };
}

----
composables/useThreeScene.ts
import { ref, onBeforeUnmount } from 'vue';
import THREE, { OrbitControls } from '../utils/three';
import type { Scene, PerspectiveCamera, WebGLRenderer, Object3D, Material, Texture } from 'three';

interface ThreeResources {
  scene: Scene;
  camera: PerspectiveCamera;
  renderer: WebGLRenderer;
  controls?: OrbitControls;
  environment?: {
    ground: THREE.Mesh;
    gridHelper: THREE.GridHelper;
    dispose: () => void;
  };
}

interface MaterialWithMap extends Material {
  map?: Texture | null;
}

export function useThreeScene() {
  const resources = ref<ThreeResources | null>(null);

  const handleContextLost = (event: Event) => {
    event.preventDefault();
    console.warn('WebGL context lost. Attempting to restore...');
  };

  const handleContextRestored = () => {
    console.log('WebGL context restored');
    window.dispatchEvent(new Event('webglcontextrestored'));
  };

  const setupLighting = (scene: Scene) => {
    // Main directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    
    // Optimize shadow map settings
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.bias = -0.0001;
    
    scene.add(directionalLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    // Ambient light for overall scene brightness
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
  };

  const initScene = async () => {
    try {
      // Create scene
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      // Create camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 3);

      // Create renderer
      const canvas = document.createElement('canvas');
      const contextAttributes = {
        alpha: true,
        antialias: true,
        powerPreference: "high-performance" as WebGLPowerPreference,
        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false
      };

      // Try WebGL2 first
      let gl = canvas.getContext('webgl2', contextAttributes);
      let isWebGL2 = !!gl;

      if (!gl) {
        console.warn('WebGL2 not available, falling back to WebGL1');
        gl = canvas.getContext('webgl', contextAttributes) ||
             canvas.getContext('experimental-webgl', contextAttributes);
        isWebGL2 = false;
      }

      if (!gl) {
        throw new Error('WebGL not supported');
      }

      const renderer = new THREE.WebGLRenderer({
        canvas,
        context: gl as WebGLRenderingContext | WebGL2RenderingContext,
        antialias: true,
        alpha: true,
        powerPreference: "high-performance",
        preserveDrawingBuffer: false
      });

      // Configure renderer based on WebGL version
      if (isWebGL2) {
        console.log('Using WebGL2 renderer');
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      } else {
        console.log('Using WebGL1 renderer');
        renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
        renderer.shadowMap.type = THREE.PCFShadowMap;
      }

      // Common renderer settings
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;

      // Store WebGL version
      (renderer as any).capabilities.isWebGL2 = isWebGL2;

      // Add context loss handling
      renderer.domElement.addEventListener('webglcontextlost', handleContextLost, false);
      renderer.domElement.addEventListener('webglcontextrestored', handleContextRestored, false);

      // Set up lighting
      setupLighting(scene);

      // Append renderer to DOM
      const container = document.getElementById('scene-container');
      if (container) {
        container.appendChild(renderer.domElement);
      } else {
        document.body.appendChild(renderer.domElement);
      }

      // Create orbit controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI * 0.95;
      controls.minDistance = 1;
      controls.maxDistance = 50;
      controls.enablePan = true;
      controls.panSpeed = 0.5;
      controls.rotateSpeed = 0.5;
      controls.zoomSpeed = 0.5;

      // Disable controls in XR
      renderer.xr.addEventListener('sessionstart', () => {
        controls.enabled = false;
      });
      
      renderer.xr.addEventListener('sessionend', () => {
        controls.enabled = true;
      });

      // Create basic environment
      const environment = createBasicEnvironment(scene);

      // Store resources
      resources.value = {
        scene,
        camera,
        renderer,
        controls,
        environment
      };

      // Handle window resize
      window.addEventListener('resize', handleResize);

      return resources.value;

    } catch (error) {
      console.error('Error initializing Three.js scene:', error);
      throw error;
    }
  };

  const createBasicEnvironment = (scene: Scene) => {
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      roughness: 0.8,
      metalness: 0.2,
      transparent: true,
      opacity: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 100);
    (gridHelper.material as THREE.Material).transparent = true;
    (gridHelper.material as THREE.Material).opacity = 0.2;
    scene.add(gridHelper);

    return {
      ground,
      gridHelper,
      dispose: () => {
        groundGeometry.dispose();
        groundMaterial.dispose();
        if (gridHelper.material) {
          (gridHelper.material as THREE.Material).dispose();
        }
        if (gridHelper.geometry) {
          gridHelper.geometry.dispose();
        }
        scene.remove(ground);
        scene.remove(gridHelper);
      }
    };
  };

  const handleResize = () => {
    if (!resources.value) return;

    const { camera, renderer } = resources.value;
    if (!renderer.xr.isPresenting) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  };

  const dispose = () => {
    if (!resources.value) return;

    const { scene, renderer, controls, environment } = resources.value;

    // Dispose of scene objects
    scene.traverse((object: Object3D) => {
      if ((object as THREE.Mesh).geometry) {
        (object as THREE.Mesh).geometry.dispose();
      }
      
      if ((object as THREE.Mesh).material) {
        const material = (object as THREE.Mesh).material;
        if (Array.isArray(material)) {
          material.forEach(mat => {
            const matWithMap = mat as MaterialWithMap;
            if (matWithMap.map) matWithMap.map.dispose();
            mat.dispose();
          });
        } else {
          const matWithMap = material as MaterialWithMap;
          if (matWithMap.map) matWithMap.map.dispose();
          material.dispose();
        }
      }
    });

    // Dispose of environment
    if (environment) {
      environment.dispose();
    }

    // Dispose of renderer
    renderer.dispose();
    renderer.forceContextLoss();
    renderer.domElement.remove();

    // Remove context loss listeners
    renderer.domElement.removeEventListener('webglcontextlost', handleContextLost);
    renderer.domElement.removeEventListener('webglcontextrestored', handleContextRestored);

    // Dispose of controls
    if (controls) {
      controls.dispose();
    }

    // Remove resize listener
    window.removeEventListener('resize', handleResize);

    resources.value = null;
  };

  onBeforeUnmount(() => {
    dispose();
  });

  return {
    resources,
    initScene,
    dispose
  };
}

----
composables/usePlatform.ts
import { ref, onMounted, onBeforeUnmount } from 'vue';
import { platformManager, type PlatformState } from '../platform/platformManager';
import type { SceneConfig } from '../types/core';
import type { BrowserState, BrowserInitOptions } from '../types/platform/browser';
import type { QuestState, QuestInitOptions, XRHandedness, XRHand } from '../types/platform/quest';
import type { Camera, Group, WebGLRenderer, Scene } from 'three';

// Convert core initialization options to platform-specific options
const convertToPlatformOptions = (options: {
  canvas: HTMLCanvasElement;
  scene?: Partial<SceneConfig>;
}): BrowserInitOptions | QuestInitOptions => {
  const baseOptions = {
    canvas: options.canvas,
    scene: options.scene ? {
      antialias: options.scene.antialias ?? true,
      alpha: options.scene.alpha ?? true,
      preserveDrawingBuffer: options.scene.preserveDrawingBuffer ?? true,
      powerPreference: options.scene.powerPreference ?? 'high-performance'
    } : undefined
  };

  if (platformManager.isQuest()) {
    return {
      ...baseOptions,
      xr: {
        referenceSpaceType: 'local-floor',
        sessionMode: 'immersive-vr',
        optionalFeatures: ['hand-tracking'],
        requiredFeatures: ['local-floor']
      }
    } as QuestInitOptions;
  }

  return baseOptions as BrowserInitOptions;
};

export function usePlatform() {
  const isInitialized = ref(false);
  const isLoading = ref(false);
  const error = ref<Error | null>(null);

  const initialize = async (options: { canvas: HTMLCanvasElement; scene?: Partial<SceneConfig> }) => {
    isLoading.value = true;
    error.value = null;

    try {
      const platformOptions = convertToPlatformOptions(options);
      await platformManager.initialize(platformOptions);
      isInitialized.value = true;
    } catch (err) {
      error.value = err instanceof Error ? err : new Error('Failed to initialize platform');
      console.error('Platform initialization failed:', err);
    } finally {
      isLoading.value = false;
    }
  };

  // Alias for backward compatibility
  const initializePlatform = initialize;

  const getState = <T extends PlatformState>(): T | null => {
    return platformManager.getState() as T | null;
  };

  const getBrowserState = (): BrowserState | null => {
    if (!platformManager.isBrowser()) return null;
    return getState<BrowserState>();
  };

  const getQuestState = (): QuestState | null => {
    if (!platformManager.isQuest()) return null;
    return getState<QuestState>();
  };

  const getPlatformInfo = () => {
    return {
      platform: platformManager.getPlatform(),
      capabilities: platformManager.getCapabilities(),
      isQuest: platformManager.isQuest(),
      isBrowser: platformManager.isBrowser(),
      hasXRSupport: platformManager.hasXRSupport()
    };
  };

  // XR Session Management
  const enableVR = async () => {
    if (!platformManager.hasXRSupport()) {
      throw new Error('WebXR not supported');
    }
    return platformManager.startXRSession('immersive-vr');
  };

  const enableAR = async () => {
    if (!platformManager.hasXRSupport()) {
      throw new Error('WebXR not supported');
    }
    const capabilities = platformManager.getCapabilities();
    if (!capabilities?.ar) {
      throw new Error('AR not supported on this device');
    }
    return platformManager.startXRSession('immersive-ar');
  };

  const disableXR = async () => {
    return platformManager.endXRSession();
  };

  const isXRActive = () => platformManager.isInXRSession();
  const isVRActive = () => platformManager.getXRSessionMode() === 'immersive-vr';
  const isARActive = () => platformManager.getXRSessionMode() === 'immersive-ar';

  // Controller and Hand Access
  const getControllerGrip = (handedness: XRHandedness): Group | null => {
    const state = getQuestState();
    return state?.controllers.get(handedness)?.grip ?? null;
  };

  const getControllerRay = (handedness: XRHandedness): Group | null => {
    const state = getQuestState();
    return state?.controllers.get(handedness)?.ray ?? null;
  };

  const getHand = (handedness: XRHandedness): XRHand | null => {
    const state = getQuestState();
    return state?.hands.get(handedness) ?? null;
  };

  // Haptic Feedback
  const vibrate = (handedness: XRHandedness, intensity = 1.0, duration = 100) => {
    const state = getQuestState();
    const controller = state?.controllers.get(handedness);
    if (controller?.gamepad?.hapticActuators?.[0]) {
      controller.gamepad.hapticActuators[0].pulse(intensity, duration);
    }
  };

  // Render and Resize Callbacks
  const onResize = (callback: (width: number, height: number) => void) => {
    return platformManager.onResize(callback);
  };

  const onBeforeRender = (callback: (renderer: WebGLRenderer, scene: Scene, camera: Camera) => void) => {
    return platformManager.onBeforeRender(callback);
  };

  // Lifecycle
  onMounted(() => {
    // Platform manager handles resize internally
  });

  onBeforeUnmount(() => {
    if (isInitialized.value) {
      platformManager.dispose();
    }
  });

  return {
    // State
    isInitialized,
    isLoading,
    error,

    // Core Methods
    initialize,
    initializePlatform,
    getState,
    getBrowserState,
    getQuestState,
    getPlatformInfo,

    // Platform Checks
    isQuest: platformManager.isQuest,
    isBrowser: platformManager.isBrowser,
    hasXRSupport: platformManager.hasXRSupport,

    // XR Methods
    enableVR,
    enableAR,
    disableXR,
    isXRActive,
    isVRActive,
    isARActive,

    // Controller Methods
    getControllerGrip,
    getControllerRay,
    getHand,
    vibrate,

    // Event Callbacks
    onResize,
    onBeforeRender
  };
}

----
types/three-ext.d.ts
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { Pass } from 'three/examples/jsm/postprocessing/Pass';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Extend existing types
declare module 'three' {
  interface ColorManagement {
    enabled: boolean;
    legacyMode?: boolean;
  }

  interface WebGLRendererParameters {
    antialias?: boolean;
    alpha?: boolean;
    depth?: boolean;
    stencil?: boolean;
    premultipliedAlpha?: boolean;
    preserveDrawingBuffer?: boolean;
    powerPreference?: string;
    failIfMajorPerformanceCaveat?: boolean;
    canvas?: HTMLCanvasElement;
    context?: WebGLRenderingContext | WebGL2RenderingContext;
    xr?: {
      enabled: boolean;
    };
  }

  interface WebGLRenderer {
    capabilities: {
      isWebGL2: boolean;
      maxTextures: number;
      maxVertexTextures: number;
      maxTextureSize: number;
      maxCubemapSize: number;
      maxAttributes: number;
      maxVertexUniforms: number;
      maxVaryings: number;
      maxFragmentUniforms: number;
      vertexTextures: boolean;
      floatFragmentTextures: boolean;
      floatVertexTextures: boolean;
    };
  }
}

// Extend OrbitControls type
declare module 'three/examples/jsm/controls/OrbitControls' {
  export interface OrbitControls {
    enabled: boolean;
    enableDamping: boolean;
    dampingFactor: number;
    enableZoom: boolean;
    enableRotate: boolean;
    enablePan: boolean;
    autoRotate: boolean;
    autoRotateSpeed: number;
    minDistance: number;
    maxDistance: number;
    minPolarAngle: number;
    maxPolarAngle: number;
    target: THREE.Vector3;
    update(): void;
    dispose(): void;
  }
}

// Custom type helpers
export type SafeWebGLRenderer = Omit<THREE.WebGLRenderer, 'readRenderTargetPixelsAsync' | 'initRenderTarget' | 'outputEncoding' | 'useLegacyLights'>;

export type SafePass = Omit<Pass, 'render'> & {
  render(
    renderer: SafeWebGLRenderer,
    writeBuffer: THREE.WebGLRenderTarget | null,
    readBuffer: THREE.WebGLRenderTarget,
    deltaTime?: number,
    maskActive?: boolean
  ): void;
};

export type SafeEffectComposer = Omit<EffectComposer, 'addPass'> & {
  addPass(pass: SafePass): void;
};

// Type assertion functions
export function asSafeRenderer(renderer: THREE.WebGLRenderer): SafeWebGLRenderer {
  return renderer as unknown as SafeWebGLRenderer;
}

export function asSafePass(pass: Pass): SafePass {
  return pass as unknown as SafePass;
}

export function asSafeEffectComposer(composer: EffectComposer): SafeEffectComposer {
  return composer as unknown as SafeEffectComposer;
}

// Camera type compatibility helper
export function asCompatibleCamera(camera: THREE.Camera): THREE.Camera {
  return camera as THREE.Camera & { matrixWorldInverse: THREE.Matrix4 };
}

----
types/global.d.ts
declare global {
  interface Window {
    __VUE_PROD_DEVTOOLS__?: boolean;
    __VUE_PROD_ERROR_HANDLER__?: (err: Error, vm: any, info: string) => void;
  }
}

export {};

----
types/vue-threejs.d.ts
declare module 'vue-threejs' {
  import { Plugin, Component } from 'vue'
  import { Scene, PerspectiveCamera, WebGLRenderer, Vector3, Color } from 'three'

  interface RendererProps {
    antialias?: boolean;
    xr?: boolean;
    size: {
      w: number;
      h: number;
    };
  }

  interface SceneProps {
    ref?: string;
  }

  interface GroupProps {
    ref?: string;
    position?: { x: number; y: number; z: number };
    rotation?: { x: number; y: number; z: number };
    scale?: { x: number; y: number; z: number };
  }

  interface CameraProps {
    position?: {
      x: number;
      y: number;
      z: number;
    };
    fov?: number;
    aspect?: number;
    near?: number;
    far?: number;
  }

  interface LightProps {
    intensity?: number;
    position?: {
      x: number;
      y: number;
      z: number;
    };
    color?: number | string;
    castShadow?: boolean;
  }

  interface HemisphereLightProps extends LightProps {
    skyColor?: number | string;
    groundColor?: number | string;
  }

  interface MeshProps {
    position?: { x: number; y: number; z: number };
    rotation?: { x: number; y: number; z: number };
    scale?: { x: number; y: number; z: number } | number;
  }

  interface GeometryProps {
    args?: any[];
  }

  interface MaterialProps {
    color?: number | string;
    metalness?: number;
    roughness?: number;
    opacity?: number;
    transparent?: boolean;
  }

  interface LineProps {
    points: Vector3[];
    color?: number | string;
    linewidth?: number;
    opacity?: number;
    transparent?: boolean;
  }

  interface HtmlProps {
    position: Vector3;
    occlude?: boolean;
    center?: boolean;
    sprite?: boolean;
  }

  export const Renderer: Component<RendererProps>
  export const Scene: Component<SceneProps>
  export const Group: Component<GroupProps>
  export const Camera: Component<CameraProps>
  export const AmbientLight: Component<LightProps>
  export const DirectionalLight: Component<LightProps>
  export const HemisphereLight: Component<HemisphereLightProps>
  export const Mesh: Component<MeshProps>
  export const SphereGeometry: Component<GeometryProps>
  export const MeshStandardMaterial: Component<MaterialProps>
  export const Line: Component<LineProps>
  export const Html: Component<HtmlProps>

  const VueThreejs: Plugin
  export default VueThreejs
}

----
types/stores.ts
import type { Node, Edge } from './core';
import type { 
  BaseMessage, 
  MaterialSettings, 
  PhysicsSettings, 
  BloomSettings, 
  FisheyeSettings 
} from './websocket';

// Re-export Node and Edge types
export type { Node, Edge };

// Binary message format types (no state storage needed)
export type BinaryMessageHeader = {
  isInitialLayout: boolean;
  timeStep: number;
  nodeCount: number;
};

export type BinaryPositionUpdate = {
  nodeId: string;
  position: [number, number, number];
};

// WebSocket Store State
export interface WebSocketState {
  isConnected: boolean;
  reconnectAttempts: number;
  messageQueue: (BaseMessage | ArrayBuffer)[];
  lastError: string | null;
  graphData: {
    nodes: Node[];
    edges: Edge[];
    metadata: Record<string, any>;
  } | null;
}

// Visualization Store State
export interface VisualizationState {
  nodes: Node[];
  edges: Edge[];
  metadata: Record<string, any>;
  selectedNode: Node | null;
  hoveredNode: Node | null;
  cameraPosition: [number, number, number];
  cameraTarget: [number, number, number];
  isLoading: boolean;
  error: string | null;
  renderSettings: {
    nodeSize: number;
    nodeColor: string;
    edgeWidth: number;
    edgeColor: string;
    highlightColor: string;
    opacity: number;
    bloom: {
      enabled: boolean;
      strength: number;
      radius: number;
      threshold: number;
    };
    fisheye: {
      enabled: boolean;
      strength: number;
      focusPoint: [number, number, number];
      radius: number;
    };
  };
  physicsSettings: {
    enabled: boolean;
    gravity: number;
    springLength: number;
    springStrength: number;
    repulsion: number;
    damping: number;
    timeStep: number;
  };
}

// Settings Store State
export interface SettingsState {
  visualization: MaterialSettings;
  physics: PhysicsSettings;
  bloom: BloomSettings;
  fisheye: FisheyeSettings;
  audio: {
    enabled: boolean;
    volume: number;
    useOpenAI: boolean;
    ttsEnabled: boolean;
  };
  performance: {
    gpuAcceleration: boolean;
    maxFPS: number;
    quality: 'low' | 'medium' | 'high';
    autoAdjust: boolean;
  };
  debug: {
    showStats: boolean;
    logLevel: 'error' | 'warn' | 'info' | 'debug';
    showGrid: boolean;
    showAxes: boolean;
  };
}

// Store Actions
export interface WebSocketActions {
  connect(): Promise<void>;
  disconnect(): void;
  send(message: BaseMessage | ArrayBuffer): void;
  handleMessage(message: BaseMessage): void;
  handleBinaryMessage(data: ArrayBuffer): void;
}

export interface VisualizationActions {
  updateNodePositions(updates: Array<[string, [number, number, number]]>): void;
  setGraphData(nodes: Node[], edges: Edge[], metadata: Record<string, any>): void;
  selectNode(node: Node | null): void;
  hoverNode(node: Node | null): void;
  updateCamera(position: [number, number, number], target: [number, number, number]): void;
  updateRenderSettings(settings: Partial<VisualizationState['renderSettings']>): void;
  updatePhysicsSettings(settings: Partial<VisualizationState['physicsSettings']>): void;
  startAnimation(): void;
  stopAnimation(): void;
  updatePerformanceMetrics(): void;
}

export interface SettingsActions {
  updateVisualization(settings: Partial<MaterialSettings>): void;
  updatePhysics(settings: Partial<PhysicsSettings>): void;
  updateBloom(settings: Partial<BloomSettings>): void;
  updateFisheye(settings: Partial<FisheyeSettings>): void;
  updateAudio(settings: Partial<SettingsState['audio']>): void;
  updatePerformance(settings: Partial<SettingsState['performance']>): void;
  updateDebug(settings: Partial<SettingsState['debug']>): void;
  resetToDefaults(): void;
  applyServerSettings(settings: {
    visualization?: Partial<MaterialSettings>;
    physics?: Partial<PhysicsSettings>;
    bloom?: Partial<BloomSettings>;
    fisheye?: Partial<FisheyeSettings>;
  }): void;
}

// Store Getters
export interface WebSocketGetters {
  isConnected: boolean;
  hasError: boolean;
  queueLength: number;
  graphData: WebSocketState['graphData'];
}

export interface VisualizationGetters {
  selectedNode: Node | null;
  hoveredNode: Node | null;
  nodeCount: number;
  edgeCount: number;
  fps: number;
  isPerformant: boolean;
}

export interface SettingsGetters {
  isGPUAccelerated: boolean;
  currentQuality: SettingsState['performance']['quality'];
  debugEnabled: boolean;
  audioEnabled: boolean;
}

----
types/core.ts
import type { WebGLRenderer, Scene, PerspectiveCamera, Object3D, Vector3 } from 'three';

/**
 * Core visualization state interface
 */
export interface CoreState {
  renderer: WebGLRenderer | null;
  camera: PerspectiveCamera | null;
  scene: Scene | null;
  canvas: HTMLCanvasElement | null;
  isInitialized: boolean;
  isXRSupported: boolean;
  isWebGL2: boolean;
  isGPUMode: boolean;
  fps: number;
  lastFrameTime: number;
}

/**
 * Platform-specific core states
 */
export interface BrowserCoreState extends CoreState {
  type: 'browser';
}

export interface XRCoreState extends CoreState {
  type: 'xr';
  xrSession: any; // XRSession type from WebXR
}

/**
 * Transform interface for object positioning
 */
export interface Transform {
  position: [number, number, number];
  rotation: [number, number, number];
  scale: [number, number, number];
}

/**
 * Viewport configuration
 */
export interface Viewport {
  width: number;
  height: number;
  pixelRatio: number;
}

/**
 * Scene configuration
 */
export interface SceneConfig {
  antialias: boolean;
  alpha: boolean;
  preserveDrawingBuffer: boolean;
  powerPreference: 'high-performance' | 'low-power' | 'default';
}

/**
 * Performance configuration
 */
export interface PerformanceConfig {
  targetFPS: number;
  maxDrawCalls: number;
  enableStats: boolean;
}

/**
 * Platform capabilities
 */
export interface PlatformCapabilities {
  webgl2: boolean;
  xr: boolean;
  ar: boolean;  // Added AR support flag
  vr: boolean;  // Added VR support flag
  maxTextureSize: number;
  maxDrawCalls: number;
  gpuTier: number;
}

/**
 * Node interfaces
 */
export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  velocity?: [number, number, number];
  size?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  weight?: number;  // Added to match Rust struct
  group?: string;   // Added to match Rust struct
}

export interface GraphNode extends Node {
  edges: GraphEdge[];  // Changed from Edge[] to GraphEdge[]
  weight: number;      // Required in GraphNode
  group?: string;
}

/**
 * Edge interfaces
 */
export interface Edge {
  id: string;
  source: string;
  target: string;
  weight?: number;
  width?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  directed?: boolean;  // Added to match Rust struct
}

export interface GraphEdge extends Edge {
  sourceNode: GraphNode;
  targetNode: GraphNode;
  directed: boolean;   // Required in GraphEdge
}

/**
 * Graph data structure
 */
export interface GraphData {
  nodes: GraphNode[];
  edges: GraphEdge[];
  metadata: Record<string, any>;
}

/**
 * Fisheye effect settings
 */
export interface FisheyeSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  focus_x: number;
  focus_y: number;
  focus_z: number;

}

/**
 * Material settings
 */
export interface MaterialSettings {
  nodeSize: number;
  nodeColor: string;
  edgeWidth: number;
  edgeColor: string;
  highlightColor: string;
  opacity: number;
  metalness: number;
  roughness: number;
}

/**
 * Physics simulation settings
 */
export interface PhysicsSettings {
  enabled: boolean;
  gravity: number;
  springLength: number;
  springStrength: number;
  repulsion: number;
  damping: number;
  timeStep: number;
}

/**
 * Bloom effect settings
 */
export interface BloomSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
}

/**
 * Complete visualization settings
 */
export interface VisualizationSettings {
  material: MaterialSettings;
  physics: PhysicsSettings;
  bloom: BloomSettings;
  fisheye: FisheyeSettings;
}

/**
 * Performance metrics
 */
export interface PerformanceMetrics {
  fps: number;
  drawCalls: number;
  triangles: number;
  points: number;
}

/**
 * Camera state
 */
export interface CameraState {
  position: [number, number, number];
  target: [number, number, number];
  zoom: number;
}

/**
 * Renderer capabilities
 */
export interface RendererCapabilities {
  isWebGL2: boolean;
  maxTextures: number;
  maxAttributes: number;
  maxVertices: number;
  precision: string;
}

/**
 * Initialization options
 */
export interface InitializationOptions {
  canvas: HTMLCanvasElement;
  scene?: Partial<SceneConfig>;
  performance?: Partial<PerformanceConfig>;
}

/**
 * Object3D with additional properties
 */
export interface EnhancedObject3D extends Object3D {
  userData: {
    id?: string;
    type?: string;
    originalPosition?: Vector3;
    velocity?: Vector3;
    [key: string]: any;
  };
}

// Rest of the file remains the same...

----
types/components.ts
// Control Panel Types
export interface ControlGroup {
  label: string;
  name: string;
  controls: ControlItem[];
  collapsed: boolean;
}

export interface ControlItem {
  name: string;
  label: string;
  value: number | string | boolean;
  type: 'range' | 'color' | 'checkbox' | 'select';
  min?: number;
  max?: number;
  step?: number;
  options?: string[];
}

// Visualization Config Types
export interface VisualizationConfig {
  // Node appearance
  node_color: string;
  node_color_new: string;
  node_color_recent: string;
  node_color_medium: string;
  node_color_old: string;
  node_color_core: string;
  node_color_secondary: string;
  min_node_size: number;
  max_node_size: number;

  // Edge appearance
  edge_color: string;
  edge_opacity: number;
  edge_min_width: number;
  edge_max_width: number;

  // Material properties
  material: {
    node_material_metalness: number;
    node_material_roughness: number;
    node_material_clearcoat: number;
    node_material_clearcoat_roughness: number;
    node_material_opacity: number;
    node_emissive_min_intensity: number;
    node_emissive_max_intensity: number;
  };

  // Physics simulation
  physics: {
    force_directed_iterations: number;
    force_directed_spring: number;
    force_directed_repulsion: number;
    force_directed_attraction: number;
    force_directed_damping: number;
  };

  // Label settings
  label_font_size: number;
  label_font_family: string;
  label_padding: number;
  label_vertical_offset: number;
  label_close_offset: number;
  label_background_color: string;
  label_text_color: string;
  label_info_text_color: string;
  label_xr_font_size: number;

  // Environment settings
  fog_density: number;
  hologram_color: string;
  hologram_scale: number;
  hologram_opacity: number;
}

// Effect Settings
export interface BloomConfig {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
  node_bloom_strength: number;
  node_bloom_radius: number;
  node_bloom_threshold: number;
  edge_bloom_strength: number;
  edge_bloom_radius: number;
  edge_bloom_threshold: number;
  environment_bloom_strength: number;
  environment_bloom_radius: number;
  environment_bloom_threshold: number;
}

export interface FisheyeConfig {
  enabled: boolean;
  strength: number;
  radius: number;
  focus_x: number;
  focus_y: number;
  focus_z: number;
}

export interface ControlPanelProps {
  visualizationConfig: VisualizationConfig;
  bloomConfig: BloomConfig;
  fisheyeConfig: FisheyeConfig;
}

export interface ControlPanelEmits {
  (event: 'update:visualizationConfig', value: Partial<VisualizationConfig>): void;
  (event: 'update:bloomConfig', value: Partial<BloomConfig>): void;
  (event: 'update:fisheyeConfig', value: Partial<FisheyeConfig>): void;
  (event: 'saveSettings'): void;
}

// Default Values
export const DEFAULT_VISUALIZATION_CONFIG: VisualizationConfig = {
  // Node appearance
  node_color: '#FFA500',
  node_color_new: '#FFD700',
  node_color_recent: '#FFA500',
  node_color_medium: '#DAA520',
  node_color_old: '#CD853F',
  node_color_core: '#FFB90F',
  node_color_secondary: '#FFC125',
  min_node_size: 0.15,
  max_node_size: 0.4,

  // Edge appearance
  edge_color: '#FFD700',
  edge_opacity: 0.4,
  edge_min_width: 1.5,
  edge_max_width: 6.0,

  // Material properties
  material: {
    node_material_metalness: 0.7,
    node_material_roughness: 0.2,
    node_material_clearcoat: 0.8,
    node_material_clearcoat_roughness: 0.1,
    node_material_opacity: 0.95,
    node_emissive_min_intensity: 0.4,
    node_emissive_max_intensity: 1.0
  },

  // Physics simulation
  physics: {
    force_directed_iterations: 300,
    force_directed_spring: 0.015,
    force_directed_repulsion: 1200.0,
    force_directed_attraction: 0.012,
    force_directed_damping: 0.85
  },

  // Label settings
  label_font_size: 42,
  label_font_family: 'Arial',
  label_padding: 24,
  label_vertical_offset: 2.5,
  label_close_offset: 0.25,
  label_background_color: 'rgba(0, 0, 0, 0.85)',
  label_text_color: 'white',
  label_info_text_color: 'lightgray',
  label_xr_font_size: 28,

  // Environment settings
  fog_density: 0.001,
  hologram_color: '#FFC125',
  hologram_scale: 6.0,
  hologram_opacity: 0.15
};

export const DEFAULT_BLOOM_CONFIG: BloomConfig = {
  enabled: true,
  strength: 1.5,
  radius: 0.4,
  threshold: 0.2,
  node_bloom_strength: 1.5,
  node_bloom_radius: 0.4,
  node_bloom_threshold: 0.2,
  edge_bloom_strength: 1.2,
  edge_bloom_radius: 0.4,
  edge_bloom_threshold: 0.2,
  environment_bloom_strength: 1.0,
  environment_bloom_radius: 0.4,
  environment_bloom_threshold: 0.2
};

export const DEFAULT_FISHEYE_CONFIG: FisheyeConfig = {
  enabled: false,
  strength: 0.5,
  radius: 100.0,
  focus_x: 0.0,
  focus_y: 0.0,
  focus_z: 0.0
};

----
types/visualization.ts
import type { Scene, PerspectiveCamera, WebGLRenderer, Vector3, Quaternion } from 'three';
import type { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import type { VisualizationConfig, BloomConfig, FisheyeConfig } from './components';

export interface GraphData {
  nodes: Node[];
  edges: Edge[];
  metadata?: Record<string, any>;
}

export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  color?: string;
  size?: number;
  type?: string;
  [key: string]: any;
}

export interface Edge {
  source: string;
  target: string;
  weight?: number;
  color?: string;
  width?: number;
  [key: string]: any;
}

export interface XRSessionManager {
  session: XRSession | null;
  referenceSpace: XRReferenceSpace | null;
  init(): Promise<void>;
  update(): void;
  dispose(): void;
}

export interface NodeManagerOptions {
  minNodeSize: number;
  maxNodeSize: number;
  nodeColor: string;
  edgeColor: string;
  edgeOpacity: number;
  labelFontSize: number;
  labelFontFamily: string;
  materialMetalness: number;
  materialRoughness: number;
  materialClearcoat: number;
  materialOpacity: number;
}

export interface VisualizationSettings {
  visualization: VisualizationConfig;
  bloom: BloomConfig;
  fisheye: FisheyeConfig;
}

export interface WebXRVisualizationState {
  initialized: boolean;
  pendingInitialization: boolean;
  scene: Scene | null;
  camera: PerspectiveCamera | null;
  renderer: WebGLRenderer | null;
  controls: OrbitControls | null;
  xrSessionManager: XRSessionManager | null;
  canvas: HTMLCanvasElement | null;
}

export interface CameraState {
  position: Vector3;
  rotation: Quaternion;
  target: Vector3;
}

export interface RenderState {
  fps: number;
  lastFrameTime: number;
  frameCount: number;
}

// Constants
export const VISUALIZATION_CONSTANTS = {
  TRANSLATION_SPEED: 0.01,
  ROTATION_SPEED: 0.01,
  VR_MOVEMENT_SPEED: 0.05,
  MIN_CAMERA_DISTANCE: 50,
  MAX_CAMERA_DISTANCE: 500,
  DEFAULT_FOV: 50,
  NEAR_PLANE: 0.1,
  FAR_PLANE: 2000,
  DEFAULT_CAMERA_POSITION: [0, 75, 200] as [number, number, number],
  DEFAULT_CAMERA_TARGET: [0, 0, 0] as [number, number, number]
} as const;

// WebGL Context Attributes
export const WEBGL_CONTEXT_ATTRIBUTES: WebGLContextAttributes = {
  alpha: false,
  antialias: true,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  preserveDrawingBuffer: true,
  xrCompatible: true
} as const;

// Renderer Settings
export const RENDERER_SETTINGS = {
  clearColor: 0x000000,
  clearAlpha: 1,
  pixelRatio: Math.min(window.devicePixelRatio, 2),
  toneMapping: 'ACESFilmic',
  toneMappingExposure: 1.5,
  outputColorSpace: 'srgb'
} as const;

// Light Settings
export const LIGHT_SETTINGS = {
  ambient: {
    color: 0xffffff,
    intensity: 1.5
  },
  directional: {
    color: 0xffffff,
    intensity: 2.0,
    position: [10, 20, 10] as [number, number, number]
  },
  hemisphere: {
    skyColor: 0xffffff,
    groundColor: 0x444444,
    intensity: 1.5
  },
  points: [
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [100, 100, 100] as [number, number, number]
    },
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [-100, -100, -100] as [number, number, number]
    }
  ]
} as const;

// Controls Settings
export const CONTROLS_SETTINGS = {
  enableDamping: true,
  dampingFactor: 0.1,
  rotateSpeed: 0.4,
  panSpeed: 0.6,
  zoomSpeed: 1.2,
  minDistance: 50,
  maxDistance: 500
} as const;

----
types/shims-vue.d.ts
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

declare module 'vue-threejs' {
  import type { Plugin } from 'vue'
  const VueThreejs: Plugin
  export default VueThreejs
}

declare module 'three/*' {
  import * as THREE from 'three'
  export * from 'three'
}

----
types/websocket.ts
// Message Types
export type MessageType = 
  | 'getInitialData'
  | 'graphUpdate'
  | 'audioData'
  | 'answer'
  | 'error'
  | 'ragflowResponse'
  | 'openaiResponse'
  | 'simulationModeSet'
  | 'fisheye_settings_updated'
  | 'completion'
  | 'position_update_complete'
  | 'graphData'
  | 'visualSettings'
  | 'materialSettings'
  | 'physicsSettings'
  | 'bloomSettings'
  | 'fisheyeSettings'
  | 'updateSettings'
  | 'settings_updated'
  | 'chatMessage'
  | 'setTTSMethod'
  | 'updateNodePosition'
  | 'updateNodeVelocity';

// Binary Protocol Types
export interface PositionUpdate {
  id: string;
  x: number;
  y: number;
  z: number;
  vx: number;
  vy: number;
  vz: number;
}

export interface BinaryMessage {
  isInitialLayout: boolean;
  positions: PositionUpdate[];
}

// WebSocket Message Interfaces
export interface BaseMessage {
  type: MessageType;
  [key: string]: any;
}

export interface GraphData {
  nodes: Node[];
  edges: Edge[];
  metadata?: Record<string, any>;
}

export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  velocity?: [number, number, number];
  [key: string]: any;
}

export interface Edge {
  source: string;
  target: string;
  [key: string]: any;
}

export interface GraphUpdateMessage extends BaseMessage {
  type: 'graphUpdate' | 'graphData';
  graphData: GraphData;
}

export interface FisheyeSettings {
  enabled: boolean;
  strength: number;
  focusPoint: [number, number, number];
  radius: number;
}

export interface MaterialSettings {
  nodeSize: number;
  nodeColor: string;
  edgeWidth: number;
  edgeColor: string;
  highlightColor: string;
  opacity: number;
}

export interface PhysicsSettings {
  gravity: number;
  springLength: number;
  springStrength: number;
  repulsion: number;
  damping: number;
  timeStep: number;
}

export interface BloomSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
}

export interface FisheyeUpdateMessage extends BaseMessage {
  type: 'fisheye_settings_updated';
  fisheye_enabled: boolean;
  fisheye_strength: number;
  fisheye_focus_x: number;
  fisheye_focus_y: number;
  fisheye_focus_z: number;
  fisheye_radius: number;
}

export interface ErrorMessage extends BaseMessage {
  type: 'error';
  message: string;
  details?: string;
}

export interface AudioMessage extends BaseMessage {
  type: 'audioData';
  audio_data: Blob;
}

export interface RagflowResponse extends BaseMessage {
  type: 'ragflowResponse';
  answer: string;
  audio?: string;
}

export interface SimulationModeMessage extends BaseMessage {
  type: 'simulationModeSet';
  mode: string;
}

export interface SettingsUpdateMessage extends BaseMessage {
  type: 'updateSettings';
  settings: {
    material?: Partial<MaterialSettings>;
    physics?: Partial<PhysicsSettings>;
    bloom?: Partial<BloomSettings>;
    fisheye?: Partial<FisheyeSettings>;
  };
}

export interface SettingsUpdatedMessage extends BaseMessage {
  type: 'settings_updated';
  settings: {
    material?: MaterialSettings;
    physics?: PhysicsSettings;
    bloom?: BloomSettings;
    fisheye?: FisheyeSettings;
  };
}

// WebSocket Service Configuration Types
export interface WebSocketConfig {
  messageRateLimit: number;
  messageTimeWindow: number;
  maxMessageSize: number;
  maxAudioSize: number;
  maxQueueSize: number;
  maxRetries: number;
  retryDelay: number;
}

// Event System Types
export type WebSocketEventMap = {
  open: void;
  close: void;
  error: ErrorMessage;
  message: BaseMessage;
  graphUpdate: GraphUpdateMessage;
  serverSettings: Record<string, any>;
  ragflowAnswer: string;
  openaiResponse: string;
  simulationModeSet: string;
  completion: string;
  positionUpdateComplete: string;
  gpuPositions: BinaryMessage;
  maxReconnectAttemptsReached: void;
};

export type WebSocketEventCallback<T> = (data: T) => void;

----
types/platform/quest.ts
import type { XRCoreState, Transform, Viewport, SceneConfig, PerformanceConfig } from '../core';
import type { Group, Object3D } from 'three';

// Base XR interfaces
export interface XRRigidTransform {
    position: { x: number; y: number; z: number };
    orientation: { x: number; y: number; z: number; w: number };
    matrix: Float32Array;
}

export interface XRSpace extends EventTarget {
    // Base XR space interface
}

export interface XRReferenceSpace extends XRSpace {
    getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
}

export interface XRRay {
    origin: DOMPointReadOnly;
    direction: DOMPointReadOnly;
    matrix: Float32Array;
}

export interface XRHitTestSource {
    cancel(): void;
}

export interface XRHitTestOptionsInit {
    space: XRSpace;
    offsetRay?: XRRay;
    entityTypes?: string[];
}

// Use the global XRWebGLLayer type
export type XRWebGLLayer = globalThis.XRWebGLLayer;

// Extend XRSession type with AR-specific methods
export interface XRSession extends globalThis.XRSession {
    requestHitTestSource?(options: XRHitTestOptionsInit): Promise<XRHitTestSource> | undefined;
}

export interface XRRenderStateInit {
    baseLayer?: XRWebGLLayer;
    depthFar?: number;
    depthNear?: number;
    inlineVerticalFieldOfView?: number;
}

export interface XRView {
    eye: 'left' | 'right' | 'none';
    projectionMatrix: Float32Array;
    transform: XRRigidTransform;
}

export interface XRViewport {
    x: number;
    y: number;
    width: number;
    height: number;
}

export type XRFrameRequestCallback = (time: number, frame: XRFrame) => void;
export type XRReferenceSpaceType = 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
export type XRSessionMode = 'inline' | 'immersive-vr' | 'immersive-ar';
export type XRHandedness = 'none' | 'left' | 'right';
export type XRTargetRayMode = 'gaze' | 'tracked-pointer' | 'screen';

export interface XRControllerEvent extends Event {
    data?: any;
    target: EventTarget & {
        handedness: XRHandedness;
        targetRayMode: XRTargetRayMode;
    };
}

export interface XRController {
    grip: Group;
    ray: Group;
    hand?: XRHand;
    handedness: XRHandedness;
    targetRayMode: XRTargetRayMode;
    gamepad?: Gamepad;
    controller: Object3D;
    model?: Object3D;
    visible: boolean;
    connected: boolean;
}

export interface XRHand {
    joints: Map<XRHandJoint, XRJointSpace>;
    hand: Object3D;
    model?: Object3D;
    visible: boolean;
    connected: boolean;
}

export type XRHandJoint = 
    | 'wrist'
    | 'thumb-metacarpal'
    | 'thumb-phalanx-proximal'
    | 'thumb-phalanx-distal'
    | 'thumb-tip'
    | 'index-finger-metacarpal'
    | 'index-finger-phalanx-proximal'
    | 'index-finger-phalanx-intermediate'
    | 'index-finger-phalanx-distal'
    | 'index-finger-tip';

export interface XRJointSpace extends XRSpace {
    jointRadius: number;
}

export interface QuestInitOptions {
    canvas: HTMLCanvasElement;
    scene?: SceneConfig;
    performance?: PerformanceConfig;
    xr?: {
        referenceSpaceType?: XRReferenceSpaceType;
        sessionMode?: XRSessionMode;
        optionalFeatures?: string[];
        requiredFeatures?: string[];
    };
}

export interface QuestState extends XRCoreState {
    xrSession: XRSession | null;
    xrSpace: XRReferenceSpace | null;
    xrLayer: XRWebGLLayer | null;
    hitTestSource: XRHitTestSource | null;
    controllers: Map<XRHandedness, XRController>;
    hands: Map<XRHandedness, XRHand>;
    viewport: Viewport;
    transform: Transform;
    config: {
        scene: SceneConfig;
        performance: PerformanceConfig;
        xr: {
            referenceSpaceType: XRReferenceSpaceType;
            sessionMode: XRSessionMode;
            optionalFeatures: string[];
            requiredFeatures: string[];
        };
    };
}

export interface QuestPlatform {
    state: QuestState;
    initialize(options: QuestInitOptions): Promise<void>;
    dispose(): void;
    render(): void;
    resize(width: number, height: number): void;
    setPixelRatio(ratio: number): void;
    getViewport(): Viewport;
    setTransform(transform: Partial<Transform>): void;
    getTransform(): Transform;
    enableVR(): Promise<void>;
    disableVR(): void;
    isVRSupported(): boolean;
    isVRActive(): boolean;
    getControllerGrip(handedness: XRHandedness): Group | null;
    getControllerRay(handedness: XRHandedness): Group | null;
    getHand(handedness: XRHandedness): XRHand | null;
    vibrate(handedness: XRHandedness, intensity?: number, duration?: number): void;
}

----
types/platform/browser.ts
import type { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import type { BrowserCoreState, Transform, Viewport, SceneConfig, PerformanceConfig } from '../core';
import type { Vector2 } from 'three';

export interface BrowserInitOptions {
  canvas: HTMLCanvasElement;
  scene?: SceneConfig;
  performance?: PerformanceConfig;
  controls?: {
    enableDamping?: boolean;
    dampingFactor?: number;
    enableZoom?: boolean;
    enableRotate?: boolean;
    enablePan?: boolean;
    autoRotate?: boolean;
    autoRotateSpeed?: number;
    minDistance?: number;
    maxDistance?: number;
    minPolarAngle?: number;
    maxPolarAngle?: number;
  };
}

export interface BrowserState extends BrowserCoreState {
  controls: OrbitControls | null;
  viewport: Viewport;
  transform: Transform;
  mousePosition: Vector2;
  touchActive: boolean;
  pointerLocked: boolean;
  config: {
    scene: SceneConfig;
    performance: PerformanceConfig;
  };
}

export interface BrowserPlatform {
  state: BrowserState;
  initialize(options: BrowserInitOptions): Promise<void>;
  dispose(): void;
  render(): void;
  resize(width: number, height: number): void;
  setPixelRatio(ratio: number): void;
  getViewport(): Viewport;
  setTransform(transform: Partial<Transform>): void;
  getTransform(): Transform;
  enableVR(): Promise<void>;
  disableVR(): void;
  isVRSupported(): boolean;
  isVRActive(): boolean;
}

----
services/graphDataManager.ts
import type WebsocketService from './websocketService'
import type { GraphUpdateMessage, BinaryMessage, Node as WSNode, Edge as WSEdge } from '../types/websocket'
import type { GraphNode, GraphEdge, GraphData } from '../types/core'

// Transform websocket node to graph node
const transformNode = (wsNode: WSNode): GraphNode => ({
  id: wsNode.id,
  label: wsNode.label || wsNode.id,
  position: wsNode.position,
  velocity: wsNode.velocity,
  size: wsNode.size,
  color: wsNode.color,
  type: wsNode.type,
  metadata: wsNode.metadata || {},
  userData: wsNode.userData || {},
  edges: [], // Will be populated after edges are transformed
  weight: wsNode.weight || 1,
  group: wsNode.group
})

// Transform websocket edge to graph edge
const transformEdge = (sourceNode: GraphNode, targetNode: GraphNode, wsEdge: WSEdge): GraphEdge => {
  return {
    id: `${wsEdge.source}-${wsEdge.target}`,
    source: wsEdge.source,
    target: wsEdge.target,
    weight: wsEdge.weight || 1,
    width: wsEdge.width,
    color: wsEdge.color,
    type: wsEdge.type,
    metadata: wsEdge.metadata || {},
    userData: wsEdge.userData || {},
    sourceNode,
    targetNode,
    directed: wsEdge.directed || false
  };
}

export default class GraphDataManager {
  private websocketService: WebsocketService
  private graphData: GraphData | null = null
  // Map for quick node lookups by ID
  private nodeMap: Map<string, GraphNode> = new Map()

  constructor(websocketService: WebsocketService) {
    this.websocketService = websocketService
    
    // Set up event listeners with proper types
    this.websocketService.on('graphUpdate', this.handleGraphUpdate.bind(this))
    this.websocketService.on('gpuPositions', this.handleBinaryPositionUpdate.bind(this))

    // Debug listener for websocket connection state
    this.websocketService.on('open', () => {
      console.log('GraphDataManager detected websocket connection')
      console.log('Requesting initial data')
      this.requestInitialData()
    })
  }

  private handleGraphUpdate(message: GraphUpdateMessage) {
    if (!message.graphData) {
      console.warn('Received graph update with no data')
      return
    }

    console.log('Received graph update:', {
      nodes: message.graphData.nodes?.length || 0,
      edges: message.graphData.edges?.length || 0,
      metadata: message.graphData.metadata ? Object.keys(message.graphData.metadata).length : 0
    })

    // Transform nodes first
    const nodes = (message.graphData.nodes || []).map(transformNode)
    
    // Create a map of nodes by ID for quick lookup
    this.nodeMap = new Map(nodes.map(node => [node.id, node]))

    // Transform edges and link them to nodes
    const edges = (message.graphData.edges || []).map(edge => {
      const sourceNode = this.nodeMap.get(edge.source)
      const targetNode = this.nodeMap.get(edge.target)
      if (!sourceNode || !targetNode) {
        console.warn(`Edge references missing node: ${edge.source} -> ${edge.target}`)
        return null
      }
      const graphEdge = transformEdge(sourceNode, targetNode, edge)
      sourceNode.edges.push(graphEdge)
      targetNode.edges.push(graphEdge)
      return graphEdge
    }).filter((edge): edge is GraphEdge => edge !== null)

    // Store the transformed data
    this.graphData = {
      nodes,
      edges,
      metadata: message.graphData.metadata || {}
    }

    console.log('Graph data transformed:', {
      nodes: this.graphData.nodes.length,
      edges: this.graphData.edges.length,
      metadata: Object.keys(this.graphData.metadata).length
    })

    // Emit custom event for graph update
    window.dispatchEvent(new CustomEvent('graphData:update', {
      detail: this.graphData
    }))
  }

  private handleBinaryPositionUpdate(data: BinaryMessage) {
    if (!this.graphData?.nodes) {
      console.warn('Received binary update but no graph data exists')
      return
    }

    // Log binary update stats
    console.debug('Processing binary position update:', {
      numPositions: data.positions.length,
      isInitialLayout: data.isInitialLayout,
      numNodes: this.graphData.nodes.length,
      numMappedNodes: this.nodeMap.size
    })

    // Update node positions from binary data using node IDs
    data.positions.forEach((pos) => {
      const node = this.nodeMap.get(pos.id)
      if (node) {
        node.position = [pos.x, pos.y, pos.z]
        node.velocity = [pos.vx, pos.vy, pos.vz]
      } else {
        console.warn(`No node found for ID: ${pos.id}`)
      }
    })

    // Log sample of updated positions
    if (data.positions.length > 0) {
      const sampleNode = this.nodeMap.get(data.positions[0].id)
      console.debug('Sample node update:', {
        id: data.positions[0].id,
        position: sampleNode?.position,
        velocity: sampleNode?.velocity
      })
    }

    // Emit custom event for position update
    window.dispatchEvent(new CustomEvent('graphData:positions', {
      detail: {
        positions: data.positions,
        isInitialLayout: data.isInitialLayout
      }
    }))
  }

  public requestInitialData(): void {
    console.log('Requesting initial graph data')
    this.websocketService.send({ type: 'getInitialData' })
  }

  public getGraphData(): GraphData | null {
    return this.graphData
  }

  public updateNodePosition(nodeId: string, position: [number, number, number]) {
    const node = this.nodeMap.get(nodeId)
    if (node) {
      node.position = position
      this.websocketService.send({
        type: 'updateNodePosition',
        nodeId,
        position
      })
    }
  }

  public updateNodeVelocity(nodeId: string, velocity: [number, number, number]) {
    const node = this.nodeMap.get(nodeId)
    if (node) {
      node.velocity = velocity
      this.websocketService.send({
        type: 'updateNodeVelocity',
        nodeId,
        velocity
      })
    }
  }

  public cleanup() {
    if (this.websocketService) {
      this.websocketService.off('graphUpdate', this.handleGraphUpdate.bind(this))
      this.websocketService.off('gpuPositions', this.handleBinaryPositionUpdate.bind(this))
    }
    this.graphData = null
    this.nodeMap.clear()
  }
}

----
services/websocketService.ts
import type {
  WebSocketConfig,
  WebSocketEventMap,
  WebSocketEventCallback,
  BaseMessage,
  ErrorMessage,
  BinaryMessage,
  GraphUpdateMessage,
  PositionUpdate
} from '../types/websocket'

import {
  DEFAULT_RECONNECT_ATTEMPTS,
  DEFAULT_RECONNECT_DELAY,
  DEFAULT_MESSAGE_RATE_LIMIT,
  DEFAULT_MESSAGE_TIME_WINDOW,
  DEFAULT_MAX_MESSAGE_SIZE,
  DEFAULT_MAX_AUDIO_SIZE,
  DEFAULT_MAX_QUEUE_SIZE
} from '../constants/websocket'

const DEFAULT_CONFIG: WebSocketConfig = {
  messageRateLimit: DEFAULT_MESSAGE_RATE_LIMIT,
  messageTimeWindow: DEFAULT_MESSAGE_TIME_WINDOW,
  maxMessageSize: DEFAULT_MAX_MESSAGE_SIZE,
  maxAudioSize: DEFAULT_MAX_AUDIO_SIZE,
  maxQueueSize: DEFAULT_MAX_QUEUE_SIZE,
  maxRetries: DEFAULT_RECONNECT_ATTEMPTS,
  retryDelay: DEFAULT_RECONNECT_DELAY
}

export default class WebsocketService {
  private ws: WebSocket | null = null;
  private config: WebSocketConfig;
  private messageQueue: any[] = [];
  private messageCount = 0;
  private lastMessageTime = 0;
  private reconnectAttempts = 0;
  private reconnectTimeout: number | null = null;
  private eventListeners: Map<keyof WebSocketEventMap, Set<WebSocketEventCallback<any>>> = new Map();
  private url: string;
  // Store node IDs in order they appear in initial graph data
  private nodeIds: string[] = [];

  constructor(config: Partial<WebSocketConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    
    // Use relative path for WebSocket to maintain protocol and host
    this.url = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws`;

    console.debug('WebSocket URL:', this.url);
  }

  public async connect(): Promise<void> {
    if (this.ws?.readyState === WebSocket.OPEN) {
      console.debug('WebSocket already connected');
      return;
    }

    return new Promise((resolve, reject) => {
      try {
        console.debug(`Attempting WebSocket connection (attempt ${this.reconnectAttempts + 1}/${this.config.maxRetries})...`);
        
        this.ws = new WebSocket(this.url);
        this.ws.binaryType = 'arraybuffer';

        // Set a connection timeout
        const connectionTimeout = setTimeout(() => {
          if (this.ws?.readyState !== WebSocket.OPEN) {
            console.error('WebSocket connection timeout');
            this.ws?.close();
            reject(new Error('WebSocket connection timeout'));
          }
        }, 10000); // 10 second timeout

        this.ws.onopen = () => {
          clearTimeout(connectionTimeout);
          console.debug('WebSocket connection established');
          this.reconnectAttempts = 0;
          this.emit('open');
          this.processQueuedMessages();
          resolve();
        };

        this.ws.onclose = (event) => {
          clearTimeout(connectionTimeout);
          console.debug('WebSocket connection closed:', {
            code: event.code,
            reason: event.reason,
            wasClean: event.wasClean
          });
          this.handleConnectionClose();
        };

        this.ws.onerror = (error) => {
          clearTimeout(connectionTimeout);
          console.error('WebSocket connection error:', error);
          const errorMsg: ErrorMessage = {
            type: 'error',
            message: 'WebSocket connection error'
          };
          this.emit('error', errorMsg);
          reject(error);
        };

        this.ws.onmessage = this.handleMessage.bind(this);

      } catch (error) {
        console.error('Error creating WebSocket connection:', error);
        reject(error);
      }
    });
  }

  private handleMessage(event: MessageEvent): void {
    try {
      if (event.data instanceof ArrayBuffer) {
        // Handle binary message (position updates)
        const view = new DataView(event.data);
        const isInitialLayout = view.getFloat32(0, true) >= 1.0;
        const numPositions = (event.data.byteLength - 4) / 24; // 24 bytes per position (6 float32s * 4 bytes)
        
        // Log binary update stats
        console.debug('Binary position update:', {
          isInitialLayout,
          numPositions,
          numStoredIds: this.nodeIds.length,
          dataSize: event.data.byteLength
        });
        
        const positions: PositionUpdate[] = [];
        let offset = 4; // Skip isInitialLayout flag
        
        for (let i = 0; i < numPositions; i++) {
          // Use stored node ID for this position index
          const nodeId = this.nodeIds[i];
          if (!nodeId) {
            console.warn(`No stored ID for node index ${i}`);
            continue;
          }
          
          // Read raw float32 values
          const x = view.getFloat32(offset, true);
          const y = view.getFloat32(offset + 4, true);
          const z = view.getFloat32(offset + 8, true);
          const vx = view.getFloat32(offset + 12, true);
          const vy = view.getFloat32(offset + 16, true);
          const vz = view.getFloat32(offset + 20, true);
          
          positions.push({
            id: nodeId,
            x, y, z,
            vx, vy, vz
          });
          offset += 24;
        }

        // Log first few positions for debugging
        if (positions.length > 0) {
          console.debug('Sample positions:', positions.slice(0, 3));
        }

        const binaryMessage: BinaryMessage = {
          isInitialLayout,
          positions
        };

        this.emit('gpuPositions', binaryMessage);
      } else {
        // Handle JSON message
        const message: BaseMessage = JSON.parse(event.data);
        this.emit('message', message);

        // Store node IDs from initial graph data
        if (message.type === 'graphUpdate' || message.type === 'graphData') {
          const graphMessage = message as GraphUpdateMessage;
          if (graphMessage.graphData?.nodes) {
            // Store node IDs in order they appear in the array
            this.nodeIds = graphMessage.graphData.nodes.map(node => node.id);
            console.debug('Stored node IDs:', {
              count: this.nodeIds.length,
              sample: this.nodeIds.slice(0, 3)
            });
          }
          this.emit('graphUpdate', graphMessage);
        } else if (message.type === 'error') {
          this.emit('error', message as ErrorMessage);
        }
      }
    } catch (error) {
      console.error('Error handling WebSocket message:', error);
      const errorMsg: ErrorMessage = {
        type: 'error',
        message: 'Error processing message'
      };
      this.emit('error', errorMsg);
    }
  }

  private handleConnectionClose(): void {
    this.emit('close');
    
    if (this.reconnectAttempts < this.config.maxRetries) {
      this.reconnectAttempts++;
      const delay = this.config.retryDelay * Math.pow(2, this.reconnectAttempts - 1); // Exponential backoff
      console.debug(`Connection failed. Retrying in ${delay}ms...`);
      
      this.reconnectTimeout = window.setTimeout(() => {
        this.connect().catch(error => {
          console.error('Reconnection attempt failed:', error);
        });
      }, delay);
    } else {
      console.error('Max reconnection attempts reached');
      this.emit('maxReconnectAttemptsReached');
    }
  }

  public send(data: any): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      if (this.messageQueue.length < this.config.maxQueueSize) {
        this.messageQueue.push(data);
      } else {
        console.warn('Message queue full, dropping message');
      }
      return;
    }

    const now = Date.now();
    if (now - this.lastMessageTime > this.config.messageTimeWindow) {
      this.messageCount = 0;
      this.lastMessageTime = now;
    }

    if (this.messageCount >= this.config.messageRateLimit) {
      if (this.messageQueue.length < this.config.maxQueueSize) {
        this.messageQueue.push(data);
      }
      return;
    }

    try {
      const message = JSON.stringify(data);
      if (message.length > this.config.maxMessageSize) {
        throw new Error('Message exceeds maximum size');
      }
      
      this.ws.send(message);
      this.messageCount++;
      this.lastMessageTime = now;

      // Process queued messages
      this.processQueue();
    } catch (error) {
      console.error('Error sending message:', error);
      const errorMsg: ErrorMessage = {
        type: 'error',
        message: 'Error sending message'
      };
      this.emit('error', errorMsg);
    }
  }

  private processQueue(): void {
    while (
      this.messageQueue.length > 0 &&
      this.messageCount < this.config.messageRateLimit
    ) {
      const data = this.messageQueue.shift();
      if (data) {
        this.send(data);
      }
    }
  }

  private processQueuedMessages(): void {
    if (this.messageQueue.length > 0) {
      console.debug(`Processing ${this.messageQueue.length} queued messages`);
      const messages = [...this.messageQueue];
      this.messageQueue = [];
      messages.forEach(message => this.send(message));
    }
  }

  public on<K extends keyof WebSocketEventMap>(
    event: K,
    callback: WebSocketEventCallback<WebSocketEventMap[K]>
  ): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, new Set());
    }
    this.eventListeners.get(event)!.add(callback);
  }

  public off<K extends keyof WebSocketEventMap>(
    event: K,
    callback: WebSocketEventCallback<WebSocketEventMap[K]>
  ): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.delete(callback);
    }
  }

  private emit<K extends keyof WebSocketEventMap>(
    event: K,
    data?: WebSocketEventMap[K]
  ): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach(callback => callback(data));
    }
  }

  public cleanup(): void {
    if (this.reconnectTimeout !== null) {
      window.clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.ws) {
      this.ws.onclose = null; // Prevent reconnection attempt
      this.ws.close();
      this.ws = null;
    }

    this.messageQueue = [];
    this.messageCount = 0;
    this.lastMessageTime = 0;
    this.reconnectAttempts = 0;
    this.eventListeners.clear();
    this.nodeIds = []; // Clear stored node IDs
  }
}

----
services/spacemouse.js
// Spacemouse HID interface

const SPACEMOUSE_VENDOR_ID = 0x256F; // 3Dconnexion vendor ID
const SPACEMOUSE_PRODUCT_ID = 0xC635; // SpaceMouse Compact product ID (may vary for different models)

let spacemouseDevice = null;

async function requestHIDAccess() {
    try {
        const devices = await navigator.hid.requestDevice({
            filters: [{ vendorId: SPACEMOUSE_VENDOR_ID, productId: SPACEMOUSE_PRODUCT_ID }]
        });
        if (devices.length > 0) {
            spacemouseDevice = devices[0];
            await spacemouseDevice.open();
            console.log('HID device opened:', spacemouseDevice.productName);
            spacemouseDevice.addEventListener('inputreport', handleHIDInput);
        }
    } catch (error) {
        console.error('HID access denied:', error);
    }
}

function handleHIDInput(event) {
    const { data } = event;
    
    // Parse the input data
    const x = data.getInt16(1, true);
    const y = data.getInt16(3, true);
    const z = data.getInt16(5, true);

    // Normalize values (adjust as needed based on your Spacemouse model)
    const normalizedX = x / 350;
    const normalizedY = y / 350;
    const normalizedZ = z / 350;

    // Emit an event with the normalized values
    const spacemouseEvent = new CustomEvent('spacemouse-move', {
        detail: { x: normalizedX, y: normalizedY, z: normalizedZ }
    });
    window.dispatchEvent(spacemouseEvent);
}

// Function to be called when the "Enable Spacemouse" button is clicked
function enableSpacemouse() {
    if (navigator.hid) {
        requestHIDAccess();
    } else {
        console.error('WebHID is not supported in this browser');
        alert('WebHID is not supported in this browser. Please use a compatible browser like Chrome or Edge.');
    }
}

// Export the function to be used in Vue components
export { enableSpacemouse };
----
services/visualizationSettings.js
// Manages visualization settings received from the server
export class VisualizationSettings {
    constructor() {
        // Initialize empty settings structure - will be populated from server
        this.settings = null;

        // Bind the WebSocket message handler
        this.handleServerSettings = this.handleServerSettings.bind(this);
        window.addEventListener('serverSettings', this.handleServerSettings);

        console.log('Visualization settings initialized - waiting for server settings');
    }

    handleServerSettings(event) {
        console.log('Received server settings:', event.detail);
        
        // Store settings received from server
        this.settings = event.detail;

        console.log('Updated settings with server values');

        // Dispatch event to notify components of updated settings
        window.dispatchEvent(new CustomEvent('visualizationSettingsUpdated', {
            detail: this.settings
        }));
    }

    getSettings() {
        if (!this.settings) {
            console.warn('Settings not yet received from server');
            return null;
        }
        return this.settings;
    }

    getNodeSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            color: vis.node_color,
            colorNew: vis.node_color_new,
            colorRecent: vis.node_color_recent,
            colorMedium: vis.node_color_medium,
            colorOld: vis.node_color_old,
            colorCore: vis.node_color_core,
            colorSecondary: vis.node_color_secondary,
            colorDefault: vis.node_color_default,
            minNodeSize: vis.min_node_size,
            maxNodeSize: vis.max_node_size,
            material: {
                metalness: vis.node_material_metalness,
                roughness: vis.node_material_roughness,
                clearcoat: vis.node_material_clearcoat,
                clearcoatRoughness: vis.node_material_clearcoat_roughness,
                opacity: vis.node_material_opacity,
                emissiveMinIntensity: vis.node_emissive_min_intensity,
                emissiveMaxIntensity: vis.node_emissive_max_intensity
            },
            ageMaxDays: vis.node_age_max_days,
            geometryMinSegments: vis.geometry_min_segments,
            geometryMaxSegments: vis.geometry_max_segments,
            geometrySegmentPerHyperlink: vis.geometry_segment_per_hyperlink,
            clickEmissiveBoost: vis.click_emissive_boost,
            clickFeedbackDuration: vis.click_feedback_duration
        };
    }

    getEdgeSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            color: vis.edge_color,
            opacity: vis.edge_opacity,
            weightNormalization: vis.edge_weight_normalization,
            minWidth: vis.edge_min_width,
            maxWidth: vis.edge_max_width
        };
    }

    getLabelSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            fontSize: vis.label_font_size,
            fontFamily: vis.label_font_family,
            padding: vis.label_padding,
            verticalOffset: vis.label_vertical_offset,
            closeOffset: vis.label_close_offset,
            backgroundColor: vis.label_background_color,
            textColor: vis.label_text_color,
            infoTextColor: vis.label_info_text_color,
            xrFontSize: vis.label_xr_font_size
        };
    }

    getLayoutSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            iterations: vis.force_directed_iterations,
            spring_strength: vis.force_directed_spring,
            repulsion_strength: vis.force_directed_repulsion,
            attraction_strength: vis.force_directed_attraction,
            damping: vis.force_directed_damping
        };
    }

    getEnvironmentSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            fogDensity: vis.fog_density
        };
    }

    getBloomSettings() {
        if (!this.settings?.bloom) {
            console.warn('Bloom settings not yet received from server');
            return null;
        }
        return this.settings.bloom;
    }

    getFisheyeSettings() {
        if (!this.settings?.fisheye) {
            console.warn('Fisheye settings not yet received from server');
            return null;
        }
        return this.settings.fisheye;
    }

    updateSettings(settings) {
        // Send settings update to server
        window.dispatchEvent(new CustomEvent('updateSettings', {
            detail: settings
        }));
    }
}

// Create and export singleton instance
export const visualizationSettings = new VisualizationSettings();

----
services/errorTracking.ts
interface ErrorInfo {
  message: string;
  context?: string;
  component?: string;
  stack?: string;
  timestamp: number;
  additional?: any;
}

class ErrorTrackingService {
  private errors: ErrorInfo[] = [];
  private maxErrors = 100;

  private constructor() {
    this.setupGlobalHandlers();
  }

  private static instance: ErrorTrackingService;

  public static getInstance(): ErrorTrackingService {
    if (!ErrorTrackingService.instance) {
      ErrorTrackingService.instance = new ErrorTrackingService();
    }
    return ErrorTrackingService.instance;
  }

  private setupGlobalHandlers() {
    window.onerror = (message, source, lineno, colno, error) => {
      this.trackError(error || new Error(String(message)), {
        context: 'Global Error Handler',
        additional: { source, lineno, colno }
      });
    };

    window.onunhandledrejection = (event) => {
      this.trackError(event.reason, {
        context: 'Unhandled Promise Rejection'
      });
    };
  }

  public trackError(error: Error | unknown, info?: {
    context?: string;
    component?: string;
    additional?: any;
  }) {
    const errorInfo: ErrorInfo = {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      context: info?.context,
      component: info?.component,
      additional: info?.additional,
      timestamp: Date.now()
    };

    this.errors.unshift(errorInfo);

    // Trim old errors
    if (this.errors.length > this.maxErrors) {
      this.errors = this.errors.slice(0, this.maxErrors);
    }

    // Emit event for any listeners
    window.dispatchEvent(new CustomEvent('error-tracked', {
      detail: errorInfo
    }));
  }

  public getErrors(): ErrorInfo[] {
    return [...this.errors];
  }

  public clearErrors(): void {
    this.errors = [];
  }
}

export const errorTracking = ErrorTrackingService.getInstance();

----
services/graphDataManager.js
// public/js/services/graphDataManager.js

/**
 * GraphDataManager handles the management and updating of graph data received from the server.
 */
export class GraphDataManager {
    constructor(websocketService) {
        this.websocketService = websocketService;
        this.graphData = null;
        
        console.log('GraphDataManager initialized');
        
        // Bind methods to preserve this context
        this.handleGraphUpdate = this.handleGraphUpdate.bind(this);
        this.handleBinaryPositionUpdate = this.handleBinaryPositionUpdate.bind(this);
        
        // Set up event listeners
        if (this.websocketService) {
            this.websocketService.on('graphUpdate', this.handleGraphUpdate);
            this.websocketService.on('gpuPositions', this.handleBinaryPositionUpdate);

            // Debug listener for websocket connection state
            this.websocketService.on('connect', () => {
                console.log('GraphDataManager detected websocket connection');
                this.requestInitialData();
            });
        } else {
            console.error('GraphDataManager initialized without websocket service');
        }
    }

    requestInitialData() {
        console.log('Requesting initial data');
        if (this.websocketService) {
            this.websocketService.send({ type: 'getInitialData' });
        }
    }

    handleBinaryPositionUpdate(update) {
        if (!this.graphData || !this.graphData.nodes) {
            console.error('Cannot apply position update: No graph data exists');
            return;
        }

        const { positions } = update;
        console.log('Received position update for', positions.length, 'nodes');
        
        // Transform position array into node objects
        const updatedNodes = this.graphData.nodes.map((node, index) => {
            if (positions[index]) {
                const pos = positions[index];
                return {
                    ...node,
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    vx: pos.vx,
                    vy: pos.vy,
                    vz: pos.vz
                };
            }
            return node;
        });

        // Update the graph data with the new nodes
        this.graphData = {
            ...this.graphData,
            nodes: updatedNodes
        };

        // Notify visualization of position updates
        this.dispatchGraphUpdate();
    }

    handleGraphUpdate(data) {
        console.log('Received graph update:', data);
        if (!data || !data.graphData) {
            console.error('Invalid graph update data received:', data);
            return;
        }
        this.updateGraphData(data.graphData);
    }

    // Helper function to generate initial positions in a sphere
    generateInitialPositions(count) {
        const positions = [];
        const radius = 100; // Increased sphere radius for better visibility
        const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle

        for (let i = 0; i < count; i++) {
            const y = 1 - (i / (count - 1)) * 2; // y goes from 1 to -1
            const radius_at_y = Math.sqrt(1 - y * y); // radius at y
            const theta = phi * i; // Golden angle increment

            const x = Math.cos(theta) * radius_at_y;
            const z = Math.sin(theta) * radius_at_y;

            // Add some random offset to prevent perfect sphere
            const randomOffset = 20; // Increased random offset
            positions.push({
                x: x * radius + (Math.random() - 0.5) * randomOffset,
                y: y * radius + (Math.random() - 0.5) * randomOffset,
                z: z * radius + (Math.random() - 0.5) * randomOffset
            });
        }

        return positions;
    }

    updateGraphData(newData) {
        console.log('Updating graph data with:', newData);
        
        if (!newData) {
            console.error('Received null or undefined graph data');
            return;
        }

        // Preserve metadata if it exists in newData
        const metadata = newData.metadata || {};
        console.log('Received metadata:', metadata);

        let nodes = [];
        let edges = [];

        // Handle the case where newData already has nodes and edges arrays
        if (Array.isArray(newData.nodes) && Array.isArray(newData.edges)) {
            console.log('Processing complete graph data with nodes and edges');
            
            // Process nodes with existing positions
            nodes = newData.nodes.map(node => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === node.id);
                const nodeMetadata = metadata[`${node.id}.md`] || {};
                
                // If no position exists, generate a random position within view range
                const randomPosition = {
                    x: (Math.random() - 0.5) * 200, // Increased range
                    y: (Math.random() - 0.5) * 200,
                    z: (Math.random() - 0.5) * 200
                };
                
                return {
                    ...node,
                    x: (typeof node.x === 'number' && !isNaN(node.x)) ? node.x : (existingNode?.x || randomPosition.x),
                    y: (typeof node.y === 'number' && !isNaN(node.y)) ? node.y : (existingNode?.y || randomPosition.y),
                    z: (typeof node.z === 'number' && !isNaN(node.z)) ? node.z : (existingNode?.z || randomPosition.z),
                    metadata: nodeMetadata
                };
            });

            edges = newData.edges;
        }
        // Handle the case where we need to construct nodes from edges
        else if (Array.isArray(newData.edges)) {
            console.log('Constructing nodes from edges');
            
            // Extract unique node IDs from edges
            const nodeSet = new Set();
            newData.edges.forEach(edge => {
                nodeSet.add(edge.source);
                nodeSet.add(edge.target);
            });

            // Generate initial positions for nodes
            const initialPositions = this.generateInitialPositions(nodeSet.size);
            
            // Create nodes with positions
            nodes = Array.from(nodeSet).map((id, index) => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === id);
                const nodeMetadata = metadata[`${id}.md`] || {};
                const position = existingNode || initialPositions[index];
                
                return {
                    id,
                    label: id,
                    x: position.x,
                    y: position.y,
                    z: position.z,
                    metadata: nodeMetadata
                };
            });

            edges = newData.edges;
        } else {
            console.error('Invalid graph data format:', newData);
            return;
        }

        // Process edges
        const processedEdges = edges.map(edge => ({
            source: edge.source,
            target: edge.target,
            weight: edge.weight || 1,
            hyperlinks: edge.hyperlinks || []
        }));

        // Update graph data
        this.graphData = {
            nodes,
            edges: processedEdges,
            metadata
        };

        console.log(`Graph data updated: ${nodes.length} nodes, ${processedEdges.length} edges`);
        
        // Log sample of node positions
        console.log('Node positions sample:', 
            nodes.slice(0, 3).map(n => 
                `Node ${n.id}: (${n.x.toFixed(2)}, ${n.y.toFixed(2)}, ${n.z.toFixed(2)})`
            )
        );

        // Dispatch update event
        this.dispatchGraphUpdate();
    }

    dispatchGraphUpdate() {
        if (!this.graphData) return;

        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
            detail: {
                nodes: this.graphData.nodes,
                edges: this.graphData.edges,
                metadata: this.graphData.metadata
            }
        }));
    }

    getGraphData() {
        if (this.graphData) {
            console.log(`Returning graph data: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
            console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
        } else {
            console.warn('Graph data is null');
        }
        return {
            nodes: this.graphData?.nodes || [],
            edges: this.graphData?.edges || [],
            metadata: this.graphData?.metadata || {}
        };
    }

    isGraphDataValid() {
        return this.graphData && 
               Array.isArray(this.graphData.nodes) && 
               Array.isArray(this.graphData.edges) &&
               this.graphData.nodes.length > 0;
    }
}

----
components/App.vue
<template>
  <ErrorBoundary>
    <div id="app">
      <div id="scene-container" ref="sceneContainer">
        <canvas ref="canvas" />
        <GraphSystem 
          v-if="visualizationState.scene" 
          :visual-settings="visualSettings" 
        />
      </div>
      <ControlPanel />
      <div class="connection-status" :class="{ connected: isConnected }">
        WebSocket: {{ isConnected ? 'Connected' : 'Disconnected' }}
      </div>
      <div v-if="error" class="error-message">
        {{ error }}
      </div>
      <div v-if="process.env.NODE_ENV === 'development'" class="debug-info">
        Scene Status: {{ visualizationState.isInitialized ? 'Ready' : 'Initializing' }}
        <br />
        Nodes: {{ visualizationStore.nodes.length }}
        <br />
        Edges: {{ visualizationStore.edges.length }}
      </div>
    </div>
  </ErrorBoundary>
</template>

<script lang="ts">
import { defineComponent, onMounted, onErrorCaptured, ref, onBeforeUnmount, ComponentPublicInstance, watch, computed, provide } from 'vue'
import { storeToRefs } from 'pinia'
import { useSettingsStore } from '../stores/settings'
import { useVisualizationStore } from '../stores/visualization'
import { useWebSocketStore } from '../stores/websocket'
import { useBinaryUpdateStore } from '../stores/binaryUpdate'
import ControlPanel from '@components/ControlPanel.vue'
import ErrorBoundary from '@components/ErrorBoundary.vue'
import GraphSystem from '@components/visualization/GraphSystem.vue'
import { errorTracking } from '../services/errorTracking'
import { useVisualization, SCENE_KEY } from '../composables/useVisualization'
import type { BaseMessage, GraphUpdateMessage, ErrorMessage, Node as WSNode, Edge as WSEdge, BinaryMessage } from '../types/websocket'
import type { Node as CoreNode, Edge as CoreEdge, GraphNode, GraphEdge, GraphData } from '../types/core'
import type { FisheyeConfig } from '../types/components'

// Transform websocket node to core node
const transformNode = (wsNode: WSNode): CoreNode => ({
  id: wsNode.id,
  label: wsNode.label || wsNode.id,
  position: wsNode.position,
  velocity: wsNode.velocity,
  size: wsNode.size,
  color: wsNode.color,
  type: wsNode.type,
  metadata: wsNode.metadata || {},
  userData: wsNode.userData || {},
  weight: wsNode.weight || 1,
  group: wsNode.group
});

// Transform websocket edge to core edge
const transformEdge = (wsEdge: WSEdge): CoreEdge => ({
  id: `${wsEdge.source}-${wsEdge.target}`,
  source: wsEdge.source,
  target: wsEdge.target,
  weight: wsEdge.weight || 1,
  width: wsEdge.width,
  color: wsEdge.color,
  type: wsEdge.type,
  metadata: wsEdge.metadata || {},
  userData: wsEdge.userData || {},
  directed: wsEdge.directed || false
});

export default defineComponent({
  name: 'App',
  components: {
    ControlPanel,
    ErrorBoundary,
    GraphSystem
  },
  setup() {
    // Initialize stores
    const settingsStore = useSettingsStore()
    const visualizationStore = useVisualizationStore()
    const websocketStore = useWebSocketStore()
    const binaryUpdateStore = useBinaryUpdateStore()

    // Get reactive refs from stores
    const { connected: isConnected } = storeToRefs(websocketStore)
    
    const sceneContainer = ref<HTMLElement | null>(null)
    const canvas = ref<HTMLCanvasElement | null>(null)
    const error = ref<string | null>(null)

    // Get visualization settings
    const visualSettings = computed(() => {
      const settings = settingsStore.getVisualizationSettings;
      console.debug('Visualization settings:', {
        material: {
          metalness: settings.material.node_material_metalness,
          roughness: settings.material.node_material_roughness,
          opacity: settings.material.node_material_opacity
        },
        nodeColors: {
          base: settings.node_color,
          core: settings.node_color_core
        },
        sizes: {
          min: settings.min_node_size,
          max: settings.max_node_size
        }
      });
      return settings;
    });

    // Initialize visualization system
    const { initialize: initVisualization, updateNodes, updatePositions, state: visualizationState } = useVisualization()

    // Provide visualization state to child components
    provide('visualizationState', visualizationState)

    // Set up WebSocket message handlers
    if (websocketStore.service) {
      // Handle JSON messages
      websocketStore.service.on('message', (message: BaseMessage) => {
        console.debug('Received message:', message)
        switch (message.type) {
          case 'graphUpdate':
          case 'graphData':
            const graphMsg = message as GraphUpdateMessage
            if (!graphMsg.graphData) {
              console.warn('Received graph update with no data')
              return
            }

            console.log('Received graph update:', {
              nodes: graphMsg.graphData.nodes?.length || 0,
              edges: graphMsg.graphData.edges?.length || 0,
              metadata: graphMsg.graphData.metadata ? Object.keys(graphMsg.graphData.metadata).length : 0,
              sampleNode: graphMsg.graphData.nodes?.[0] ? {
                id: graphMsg.graphData.nodes[0].id,
                position: graphMsg.graphData.nodes[0].position
              } : null
            })

            // Transform nodes and edges before setting graph data
            const transformedNodes = (graphMsg.graphData.nodes || []).map(transformNode)
            const transformedEdges = (graphMsg.graphData.edges || []).map(transformEdge)
            
            // Set graph data in store
            visualizationStore.setGraphData(
              transformedNodes,
              transformedEdges,
              graphMsg.graphData.metadata || {}
            )

            // Update visualization
            updateNodes(transformedNodes)

            // Log graph data state after update
            console.log('Graph data state after update:', {
              storeNodes: visualizationStore.nodes.length,
              storeEdges: visualizationStore.edges.length,
              graphData: visualizationStore.graphData ? {
                nodes: visualizationStore.graphData.nodes.length,
                edges: visualizationStore.graphData.edges.length
              } : null
            })
            break

          case 'settings_updated':
            settingsStore.applyServerSettings(message.settings)
            break

          case 'position_update_complete':
            console.debug('Position update completed:', message.status)
            break
        }
      })

      // Handle binary messages (GPU position updates)
      websocketStore.service.on('gpuPositions', (data: BinaryMessage) => {
        console.debug('Received GPU positions update:', {
          positions: data.positions.length,
          isInitial: data.isInitialLayout,
          sample: data.positions[0] ? {
            id: data.positions[0].id,
            position: [data.positions[0].x, data.positions[0].y, data.positions[0].z],
            velocity: [data.positions[0].vx, data.positions[0].vy, data.positions[0].vz]
          } : null
        })
        // Update visualization with position data
        updatePositions(data.positions, data.isInitialLayout)
        
        // Store transient position updates
        binaryUpdateStore.updatePositions(
          data.positions,
          data.isInitialLayout
        )
      })

      // Handle connection events
      websocketStore.service.on('open', () => {
        console.log('WebSocket connected')
        error.value = null
        // Request initial data
        websocketStore.requestInitialData()
      })

      websocketStore.service.on('close', () => {
        console.log('WebSocket disconnected')
        binaryUpdateStore.clear()
      })

      websocketStore.service.on('error', (err: ErrorMessage) => {
        console.error('WebSocket error:', err)
        error.value = err.message
        errorTracking.trackError(new Error(err.message), {
          context: 'WebSocket Error',
          component: 'App'
        })
      })
    }

    onMounted(async () => {
      try {
        // Initialize settings with defaults
        settingsStore.applyServerSettings({})
        console.info('Settings initialized', {
          context: 'App Setup',
          settings: settingsStore.$state
        })

        // Initialize visualization system
        if (canvas.value && sceneContainer.value) {
          console.log('Initializing visualization system...')
          
          // Set initial canvas size
          const rect = sceneContainer.value.getBoundingClientRect()
          canvas.value.width = rect.width
          canvas.value.height = rect.height
          
          await initVisualization({
            canvas: canvas.value,
            scene: {
              antialias: true,
              alpha: true,
              preserveDrawingBuffer: true,
              powerPreference: 'high-performance'
            }
          })
          console.log('Visualization system initialized')

          // Provide scene to child components
          if (visualizationState.value.scene) {
            provide(SCENE_KEY, visualizationState.value.scene)
          }
        }

        // Initialize WebSocket through store
        await websocketStore.initialize()

        // Log environment info
        console.info('Application initialized', {
          context: 'App Initialization',
          environment: process.env.NODE_ENV
        })

      } catch (err) {
        console.error('Error during App setup:', err)
        error.value = err instanceof Error ? err.message : 'Unknown error during setup'
        errorTracking.trackError(err, {
          context: 'App Setup',
          component: 'App'
        })
      }
    })

    onBeforeUnmount(() => {
      // Clean up stores
      websocketStore.cleanup()
      binaryUpdateStore.clear()
    })

    // Additional error handling at app level
    onErrorCaptured((err, instance: ComponentPublicInstance | null, info) => {
      error.value = err instanceof Error ? err.message : 'An error occurred'
      errorTracking.trackError(err, {
        context: 'App Root Error',
        component: (instance as any)?.$options?.name || 'Unknown',
        additional: { info }
      })
      // Let the error boundary handle it
      return false
    })

    return {
      sceneContainer,
      canvas,
      isConnected,
      error,
      visualSettings,
      visualizationState,
      visualizationStore,
      process: {
        env: {
          NODE_ENV: process.env.NODE_ENV
        }
      }
    }
  }
})
</script>

<style>
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  background: #000000;
}

#scene-container {
  width: 100%;
  height: 100%;
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  background: #000000;
  touch-action: none;
}

#scene-container canvas {
  width: 100%;
  height: 100%;
  display: block;
}

#app {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
  pointer-events: none;
}

#app > * {
  pointer-events: auto;
}

.connection-status {
  position: fixed;
  top: 10px;
  right: 10px;
  padding: 5px 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: #ff4444;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
}

.connection-status.connected {
  color: #44ff44;
}

.error-message {
  position: fixed;
  top: 50px;
  right: 10px;
  padding: 10px;
  background-color: rgba(255, 0, 0, 0.8);
  color: white;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
  max-width: 300px;
  word-wrap: break-word;
}

.debug-info {
  position: fixed;
  top: 90px;
  right: 10px;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
  max-width: 300px;
  word-wrap: break-word;
}
</style>

----
components/ErrorMessage.vue
<template>
  <Transition name="fade">
    <div 
      v-if="error"
      class="error-message"
      @click="dismiss"
    >
      {{ error }}
    </div>
  </Transition>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted, onBeforeUnmount } from 'vue';

interface Props {
  message: string;
  duration: number;
  dismissible: boolean;
}

export default defineComponent({
  name: 'ErrorMessage',
  
  props: {
    message: {
      type: String,
      required: true
    },
    duration: {
      type: Number,
      default: 5000
    },
    dismissible: {
      type: Boolean,
      default: true
    }
  },

  emits: ['dismiss'],

  setup(props: Props, { emit }: { emit: (event: 'dismiss') => void }) {
    const error = ref<string | null>(props.message);
    let timeout: number | null = null;

    const dismiss = () => {
      if (props.dismissible) {
        error.value = null;
        emit('dismiss');
      }
    };

    onMounted(() => {
      if (props.duration > 0) {
        timeout = window.setTimeout(() => {
          error.value = null;
          emit('dismiss');
        }, props.duration);
      }
    });

    onBeforeUnmount(() => {
      if (timeout) {
        clearTimeout(timeout);
      }
    });

    return {
      error,
      dismiss
    };
  }
});
</script>

<style scoped>
.error-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(255, 0, 0, 0.85);
  color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  cursor: pointer;
  max-width: 80vw;
  text-align: center;
  font-weight: 500;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>

----
components/ControlPanel.vue
<template>
  <div id="control-panel" :class="{ hidden: isHidden }">
    <button class="toggle-button" @click="togglePanel">
      {{ isHidden ? 'Show Controls' : 'Hide Controls' }}
    </button>
    
    <div class="panel-content">
      <!-- Node Appearance -->
      <div v-for="group in controlGroups" :key="group.name" class="control-group">
        <div class="group-header" @click="toggleGroup(group.name)">
          <h3>{{ group.label }}</h3>
        </div>
        <div v-if="!collapsedGroups[group.name]" class="group-content">
          <div v-for="control in group.controls" :key="control.name" class="control-item">
            <label>{{ control.label }}</label>
            
            <!-- Color Input -->
            <template v-if="control.type === 'color'">
              <input type="color"
                     :value="control.value"
                     @input="($event: Event) => handleColorInput($event, group.name, control.name)">
            </template>
            
            <!-- Range Input -->
            <template v-if="control.type === 'range'">
              <input type="range"
                     :min="control.min"
                     :max="control.max"
                     :step="control.step"
                     :value="control.value"
                     @input="($event: Event) => handleRangeInput($event, group.name, control.name)">
              <span class="range-value">{{ typeof control.value === 'number' ? control.value.toFixed(2) : control.value }}</span>
            </template>
            
            <!-- Checkbox Input -->
            <template v-if="control.type === 'checkbox'">
              <input type="checkbox"
                     :value="control.value"
                     :checked="Boolean(control.value)"
                     @change="($event: Event) => handleCheckboxChange($event, group.name, control.name)">
            </template>
          </div>
        </div>
      </div>

      <!-- Save Settings Button -->
      <button class="save-button" 
              @click="saveSettings"
              :disabled="!hasUnsavedChanges">
        {{ hasUnsavedChanges ? 'Save Settings' : 'No Changes' }}
      </button>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useSettingsStore } from '../stores/settings';
import { useControlGroups } from '../composables/useControlGroups';
import { useControlSettings } from '../composables/useControlSettings';
import type { ControlGroup } from '../types/components';

export default defineComponent({
  name: 'ControlPanel',
  
  setup() {
    const settingsStore = useSettingsStore();
    const { collapsedGroups, toggleGroup } = useControlGroups();
    const { 
      createAppearanceGroup,
      createMaterialGroup,
      createPhysicsGroup,
      createBloomGroup,
      createEnvironmentGroup,
      createFisheyeGroup,
      handleControlChange
    } = useControlSettings();

    const isHidden = ref(false);
    const { visualization, bloom, fisheye, isDirty: hasUnsavedChanges } = storeToRefs(settingsStore);

    // Compute control groups based on current settings
    const controlGroups = computed<ControlGroup[]>(() => [
      createAppearanceGroup(visualization.value),
      createMaterialGroup(visualization.value),
      createPhysicsGroup(visualization.value),
      createBloomGroup(bloom.value),
      createEnvironmentGroup(visualization.value),
      createFisheyeGroup(fisheye.value)
    ]);

    const togglePanel = () => {
      isHidden.value = !isHidden.value;
    };

    // Type-safe event handlers
    const handleColorInput = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, input.value);
    };

    const handleRangeInput = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, parseFloat(input.value));
    };

    const handleCheckboxChange = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, input.checked);
    };

    const saveSettings = () => {
      const settings = {
        visualization: visualization.value,
        bloom: bloom.value,
        fisheye: fisheye.value
      };
      
      // Dispatch event for settings update
      window.dispatchEvent(new CustomEvent('settingsUpdate', {
        detail: settings
      }));
      
      settingsStore.markSaved();
    };

    onMounted(() => {
      console.log('ControlPanel mounted');
    });

    return {
      isHidden,
      collapsedGroups,
      controlGroups,
      hasUnsavedChanges,
      togglePanel,
      toggleGroup,
      handleColorInput,
      handleRangeInput,
      handleCheckboxChange,
      saveSettings
    };
  }
});
</script>

<style scoped>
#control-panel {
  position: fixed;
  top: 20px;
  right: 0;
  width: 300px;
  max-height: 90vh;
  background-color: rgba(20, 20, 20, 0.9);
  color: #ffffff;
  border-radius: 10px 0 0 10px;
  overflow-y: auto;
  z-index: 1000;
  transition: transform 0.3s ease-in-out;
  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
}

#control-panel.hidden {
  transform: translateX(calc(100% - 40px));
}

.toggle-button {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%) rotate(-90deg);
  transform-origin: left center;
  background-color: rgba(20, 20, 20, 0.9);
  color: #ffffff;
  border: none;
  padding: 8px 16px;
  cursor: pointer;
  border-radius: 5px 5px 0 0;
  font-size: 0.9em;
  white-space: nowrap;
  z-index: 1001;
}

.panel-content {
  padding: 20px;
}

.control-group {
  margin-bottom: 16px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  overflow: hidden;
}

.group-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background-color: rgba(255, 255, 255, 0.1);
  cursor: pointer;
}

.group-header h3 {
  margin: 0;
  font-size: 1em;
  font-weight: 500;
}

.group-content {
  padding: 12px;
}

.control-item {
  margin-bottom: 12px;
}

.control-item label {
  display: block;
  margin-bottom: 4px;
  font-size: 0.9em;
  color: #cccccc;
}

.control-item input[type="range"] {
  width: 100%;
  height: 6px;
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
  -webkit-appearance: none;
}

.control-item input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background-color: #ffffff;
  border-radius: 50%;
  cursor: pointer;
}

.control-item input[type="color"] {
  width: 100%;
  height: 30px;
  border: none;
  border-radius: 4px;
  background-color: transparent;
}

.range-value {
  float: right;
  font-size: 0.8em;
  color: #999999;
}

.save-button {
  width: 100%;
  padding: 12px;
  margin-top: 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s;
}

.save-button:hover:not(:disabled) {
  background-color: #218838;
}

.save-button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  opacity: 0.65;
}
</style>

----
components/ErrorBoundary.vue
<template>
  <div>
    <div v-if="error" class="error-boundary">
      <div class="error-content">
        <h3>Component Error</h3>
        <div class="error-message">{{ error.message }}</div>
        <div class="error-info">
          <div class="error-component">Component: {{ error.component }}</div>
          <div class="error-stack">{{ error.stack }}</div>
        </div>
        <button @click="handleError" class="retry-button">
          Retry
        </button>
      </div>
    </div>
    <slot v-else></slot>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, onErrorCaptured, ComponentPublicInstance } from 'vue'

export default defineComponent({
  name: 'ErrorBoundary',
  
  setup() {
    const error = ref<{
      message: string;
      component?: string;
      stack?: string;
    } | null>(null)

    onErrorCaptured((err, instance: ComponentPublicInstance | null, info) => {
      // Get component name
      const componentName = (instance as any)?.$options?.name || 'Unknown Component'
      
      // Format error for display
      error.value = {
        message: err.message || String(err),
        component: componentName,
        stack: err.stack
      }

      // Log to debug console
      console.error('Component Error:', {
        message: err.message,
        component: componentName,
        stack: err.stack,
        context: `Vue Component: ${componentName}`
      })

      // Prevent error from propagating
      return false
    })

    const handleError = () => {
      error.value = null
    }

    return {
      error,
      handleError
    }
  }
})
</script>

<style scoped>
.error-boundary {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.85);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.error-content {
  background-color: #2c3e50;
  padding: 20px;
  border-radius: 8px;
  max-width: 80%;
  max-height: 80%;
  overflow-y: auto;
  color: white;
  font-family: monospace;
}

.error-content h3 {
  color: #e74c3c;
  margin-top: 0;
}

.error-message {
  color: #f1c40f;
  margin: 10px 0;
  font-size: 16px;
}

.error-info {
  margin: 15px 0;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

.error-component {
  color: #3498db;
  margin-bottom: 8px;
}

.error-stack {
  color: #95a5a6;
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.retry-button {
  background-color: #2ecc71;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin-top: 15px;
}

.retry-button:hover {
  background-color: #27ae60;
}
</style>

----
components/chatManager.vue
<template>
  <div class="chat-manager">
    <div class="chat-messages" ref="messagesContainer">
      <div v-for="(message, index) in messages" :key="index" class="message">
        {{ message }}
      </div>
    </div>
    <div class="chat-input">
      <input
        v-model="chatInput"
        @keyup.enter="sendMessage"
        placeholder="Type your message..."
        :disabled="!websocketService"
      />
      <div class="button-group">
        <button @click="sendMessage" :disabled="!websocketService || !chatInput.trim()">
          Send
        </button>
        <button 
          @click="toggleTTS" 
          :disabled="!websocketService"
          :class="{ active: useOpenAI }"
          :title="useOpenAI ? 'Using OpenAI for TTS' : 'Using Sonata for TTS'"
        >
          TTS: {{ useOpenAI ? 'OpenAI' : 'Sonata' }}
        </button>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, PropType, onMounted, onBeforeUnmount, nextTick } from 'vue'
import type WebsocketService from '../services/websocketService'

export default defineComponent({
  name: 'ChatManager',
  
  props: {
    websocketService: {
      type: Object as PropType<WebsocketService>,
      required: true
    }
  },

  setup(props) {
    const chatInput = ref('')
    const messages = ref<string[]>([])
    const useOpenAI = ref(false)
    const messagesContainer = ref<HTMLElement | null>(null)

    const scrollToBottom = async () => {
      await nextTick()
      if (messagesContainer.value) {
        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
      }
    }

    const handleRagflowAnswer = (answer: string) => {
      messages.value.push(`AI: ${answer}`)
      scrollToBottom()
    }

    const handleOpenAIResponse = (response: string) => {
      messages.value.push(`OpenAI: ${response}`)
      scrollToBottom()
    }

    const sendMessage = () => {
      if (chatInput.value.trim()) {
        messages.value.push(`You: ${chatInput.value}`)
        props.websocketService.send({
          type: 'chatMessage',
          message: chatInput.value,
          useOpenAI: useOpenAI.value
        })
        chatInput.value = ''
        scrollToBottom()
      }
    }

    const toggleTTS = () => {
      useOpenAI.value = !useOpenAI.value
      props.websocketService.send({
        type: 'setTTSMethod',
        useOpenAI: useOpenAI.value
      })
      console.log(`TTS method set to: ${useOpenAI.value ? 'OpenAI' : 'Sonata'}`)
    }

    onMounted(() => {
      props.websocketService.on('ragflowAnswer', handleRagflowAnswer)
      props.websocketService.on('openaiResponse', handleOpenAIResponse)
    })

    onBeforeUnmount(() => {
      props.websocketService.off('ragflowAnswer', handleRagflowAnswer)
      props.websocketService.off('openaiResponse', handleOpenAIResponse)
    })

    return {
      chatInput,
      messages,
      useOpenAI,
      messagesContainer,
      sendMessage,
      toggleTTS
    }
  }
})
</script>

<style scoped>
.chat-manager {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 300px;
  height: 400px;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  padding: 10px;
  z-index: 1000;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.chat-messages {
  flex-grow: 1;
  overflow-y: auto;
  margin-bottom: 10px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

.message {
  margin: 8px 0;
  padding: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  color: #fff;
  word-wrap: break-word;
}

.chat-input {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.chat-input input {
  width: 100%;
  padding: 8px;
  border: none;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  font-size: 14px;
}

.chat-input input::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.chat-input input:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.15);
}

.button-group {
  display: flex;
  gap: 8px;
}

button {
  flex: 1;
  padding: 8px;
  border: none;
  border-radius: 4px;
  background: #2196f3;
  color: white;
  cursor: pointer;
  transition: background-color 0.2s;
}

button:hover:not(:disabled) {
  background: #1976d2;
}

button:disabled {
  background: #ccc;
  cursor: not-allowed;
  opacity: 0.7;
}

button.active {
  background: #4caf50;
}

button.active:hover:not(:disabled) {
  background: #388e3c;
}

/* Scrollbar styling */
.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
</style>

----
components/NodeInfoPanel.vue
<template>
  <div 
    v-if="nodeData"
    class="node-info-panel"
  >
    <h3>Node Information</h3>
    <p><strong>ID:</strong> {{ nodeData.id }}</p>
    <p v-if="nodeData.label"><strong>Name:</strong> {{ nodeData.label }}</p>
    <template v-if="nodeData.metadata">
      <div v-for="(value, key) in nodeData.metadata" :key="key" class="metadata-item">
        <strong>{{ formatKey(key) }}:</strong> {{ formatValue(value) }}
      </div>
    </template>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue';
import { useVisualizationStore } from '../stores/visualization';
import type { Node } from '../types/core';

export default defineComponent({
  name: 'NodeInfoPanel',
  
  setup() {
    const store = useVisualizationStore();
    
    const nodeData = computed(() => store.selectedNode);

    const formatKey = (key: string) => {
      return key
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    };

    const formatValue = (value: any) => {
      if (typeof value === 'object') {
        return JSON.stringify(value, null, 2);
      }
      return value;
    };

    return {
      nodeData,
      formatKey,
      formatValue
    };
  }
});
</script>

<style scoped>
.node-info-panel {
  position: absolute;
  top: 20px;
  left: 20px;
  width: 300px;
  max-height: 40vh;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  overflow-y: auto;
}

.metadata-item {
  margin: 5px 0;
}

h3 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 1.2em;
}

p {
  margin: 8px 0;
}

strong {
  font-weight: 600;
}
</style>

----
components/three/index.ts
import { defineComponent, h, onMounted, onBeforeUnmount, watch, ref, inject, type Ref } from 'vue'
import * as THREE from 'three'
import { SCENE_KEY } from '../../composables/useVisualization'

// Define our supported event types
type SupportedEventType = 'click' | 'pointerenter' | 'pointerleave' | 'pointerdown' | 'pointermove' | 'pointerup';

// Event handler setup
const setupEventHandlers = (
  mesh: THREE.Mesh,
  emit: (event: SupportedEventType, data: THREE.Event) => void
) => {
  // Map Vue events to Three.js events
  const handlers: Record<string, (event: THREE.Event) => void> = {
    'click': (event) => {
      debugLog('Mesh', 'Event: click', { id: mesh.id });
      emit('click', event);
    },
    'pointermove': (event) => {
      debugLog('Mesh', 'Event: pointermove', { id: mesh.id });
      emit('pointermove', event);
    },
    'pointerdown': (event) => {
      debugLog('Mesh', 'Event: pointerdown', { id: mesh.id });
      emit('pointerdown', event);
    },
    'pointerup': (event) => {
      debugLog('Mesh', 'Event: pointerup', { id: mesh.id });
      emit('pointerup', event);
    },
    'pointerover': (event) => {
      debugLog('Mesh', 'Event: pointerenter', { id: mesh.id });
      emit('pointerenter', event);
    },
    'pointerout': (event) => {
      debugLog('Mesh', 'Event: pointerleave', { id: mesh.id });
      emit('pointerleave', event);
    }
  };

  // Add event listeners
  Object.entries(handlers).forEach(([type, handler]) => {
    mesh.addEventListener(type as keyof THREE.Object3DEventMap, handler);
  });

  return () => {
    // Remove event listeners on cleanup
    Object.entries(handlers).forEach(([type, handler]) => {
      mesh.removeEventListener(type as keyof THREE.Object3DEventMap, handler);
    });
  };
};

// Debug logging helper
const debugLog = (component: string, action: string, details: any) => {
  console.debug(`[Three.js ${component}] ${action}:`, details);
};

// Helper to safely get fog properties
const getFogDetails = (fog: THREE.Fog | THREE.FogExp2 | null) => {
  if (!fog) return null;
  if (fog instanceof THREE.Fog) {
    return {
      type: 'Fog',
      near: fog.near,
      far: fog.far
    };
  }
  if (fog instanceof THREE.FogExp2) {
    return {
      type: 'FogExp2',
      density: fog.density
    };
  }
  return null;
};

// Provide/inject keys
const PARENT_KEY = Symbol('three-parent');
const GEOMETRY_REF = Symbol('geometry-ref');
const MATERIAL_REF = Symbol('material-ref');

// Basic Three.js component wrapper
export const Group = defineComponent({
  name: 'Group',
  setup(_, { slots }) {
    const group = new THREE.Group();
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;
    const scene = inject(SCENE_KEY, null) as THREE.Scene | null;
    
    debugLog('Group', 'Created', { id: group.id });
    
    onMounted(() => {
      if (parent) {
        parent.add(group);
      } else if (scene) {
        scene.add(group);
      }
      debugLog('Group', 'Mounted', { 
        id: group.id,
        parent: parent?.type || 'Scene',
        childCount: group.children.length
      });
    });

    onBeforeUnmount(() => {
      debugLog('Group', 'Disposing', { id: group.id });
      if (parent) {
        parent.remove(group);
      } else if (scene) {
        scene.remove(group);
      }
      group.clear();
    });

    return () => h('div', { provide: { [PARENT_KEY]: group } }, slots.default?.());
  }
});

export const Scene = defineComponent({
  name: 'Scene',
  props: {
    background: {
      type: [Number, String],
      default: 0x000000
    }
  },
  setup(props, { slots }) {
    // Create scene
    const scene = new THREE.Scene();
    
    // Set initial background
    scene.background = new THREE.Color(props.background);
    
    debugLog('Scene', 'Created', { 
      id: scene.id,
      background: scene.background instanceof THREE.Color ? scene.background.getHexString() : 'none'
    });

    // Watch for background changes
    watch(() => props.background, (newColor) => {
      scene.background = new THREE.Color(newColor);
      debugLog('Scene', 'Background updated', { 
        background: scene.background instanceof THREE.Color ? scene.background.getHexString() : 'none'
      });
    });

    // Clean up
    onBeforeUnmount(() => {
      debugLog('Scene', 'Disposing', { id: scene.id });
      scene.clear();
    });

    // Provide scene to child components
    return () => h('div', { provide: { [SCENE_KEY]: scene } }, slots.default?.());
  }
});

// Mesh component that wraps Three.js mesh
export const Mesh = defineComponent({
  name: 'Mesh',
  props: {
    position: {
      type: Object as () => THREE.Vector3,
      required: true
    },
    scale: {
      type: Object as () => { x: number; y: number; z: number },
      default: () => ({ x: 1, y: 1, z: 1 })
    }
  },
  emits: ['click', 'pointerenter', 'pointerleave', 'pointerdown', 'pointermove', 'pointerup'] as const,
  setup(props, { emit, slots }) {
    const mesh = new THREE.Mesh();
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;
    const scene = inject(SCENE_KEY, null) as THREE.Scene | null;
    let cleanup: (() => void) | null = null;

    if (!parent && !scene) {
      throw new Error('Mesh must be used within a Scene or Group component');
    }

    // Wait for geometry and material from child components
    const geometryRef = ref<THREE.BufferGeometry | null>(null);
    const materialRef = ref<THREE.Material | null>(null);

    // Update mesh when geometry or material change
    watch([geometryRef, materialRef], ([geometry, material]) => {
      if (geometry && material) {
        mesh.geometry = geometry;
        mesh.material = material;
        
        // Force geometry update
        geometry.attributes.position.needsUpdate = true;
        if (geometry.index) {
          geometry.index.needsUpdate = true;
        }
        
        // Force transform update
        mesh.updateMatrix();
        mesh.updateMatrixWorld(true);
        
        // Mark for render
        if (scene?.userData) {
          scene.userData.needsRender = true;
        }

        debugLog('Mesh', 'Updated geometry and material', {
          id: mesh.id,
          geometryType: geometry.type,
          materialType: material.type,
          vertices: geometry.attributes.position?.count,
          needsUpdate: geometry.attributes.position.needsUpdate
        });
      }
    }, { immediate: true });

    onMounted(() => {
      mesh.position.copy(props.position);
      mesh.scale.set(props.scale.x, props.scale.y, props.scale.z);
      
      if (parent) {
        parent.add(mesh);
      } else if (scene) {
        scene.add(mesh);
      }

      debugLog('Mesh', 'Added to scene', {
        id: mesh.id,
        position: mesh.position.toArray(),
        scale: [mesh.scale.x, mesh.scale.y, mesh.scale.z],
        parent: parent?.type || 'Scene',
        hasGeometry: !!mesh.geometry,
        hasMaterial: !!mesh.material
      });

      // Set up event handlers
      cleanup = setupEventHandlers(mesh, emit);
    });

    // Watch for prop changes
    watch(() => props.position, (newPos) => {
      mesh.position.copy(newPos);
      debugLog('Mesh', 'Position updated', {
        id: mesh.id,
        position: mesh.position.toArray()
      });
    });

    watch(() => props.scale, (newScale) => {
      mesh.scale.set(newScale.x, newScale.y, newScale.z);
      debugLog('Mesh', 'Scale updated', {
        id: mesh.id,
        scale: [mesh.scale.x, mesh.scale.y, mesh.scale.z]
      });
    });

    onBeforeUnmount(() => {
      // Clean up event handlers
      if (cleanup) {
        cleanup();
      }

      debugLog('Mesh', 'Removing from scene', {
        id: mesh.id,
        position: mesh.position.toArray()
      });
      if (parent) {
        parent.remove(mesh);
      } else if (scene) {
        scene.remove(mesh);
      }
      mesh.geometry?.dispose();
      if (Array.isArray(mesh.material)) {
        mesh.material.forEach(m => m.dispose());
      } else if (mesh.material) {
        mesh.material.dispose();
      }
    });

    // Provide mesh to child components and handle their setup
    return () => h('div', { 
      provide: { 
        [PARENT_KEY]: mesh,
        [GEOMETRY_REF]: geometryRef,
        [MATERIAL_REF]: materialRef
      } 
    }, slots.default?.());
  }
});

// Update SphereGeometry to connect with parent mesh
export const SphereGeometry = defineComponent({
  name: 'SphereGeometry',
  props: {
    args: {
      type: Array as unknown as () => [number, number, number],
      default: () => [1, 32, 32]
    }
  },
  setup(props) {
    const geometry = new THREE.SphereGeometry(...props.args);
    const geometryRef = inject<Ref<THREE.BufferGeometry | null>>(GEOMETRY_REF);
    
    if (geometryRef) {
      geometryRef.value = geometry;
    }
    
    debugLog('SphereGeometry', 'Created', {
      radius: props.args[0],
      segments: [props.args[1], props.args[2]],
      vertices: geometry.attributes.position.count
    });

    onBeforeUnmount(() => {
      if (geometryRef) {
        geometryRef.value = null;
      }
      debugLog('SphereGeometry', 'Disposing', {
        vertices: geometry.attributes.position.count
      });
      geometry.dispose();
    });

    return { geometry };
  }
});

// Update MeshStandardMaterial to connect with parent mesh
export const MeshStandardMaterial = defineComponent({
  name: 'MeshStandardMaterial',
  props: {
    color: {
      type: String,
      default: '#ffffff'
    },
    metalness: {
      type: Number,
      default: 0.1
    },
    roughness: {
      type: Number,
      default: 0.5
    },
    opacity: {
      type: Number,
      default: 1.0
    },
    transparent: {
      type: Boolean,
      default: false
    },
    emissive: {
      type: String,
      default: '#000000'
    },
    emissiveIntensity: {
      type: Number,
      default: 1.0
    }
  },
  setup(props) {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color(props.color),
      metalness: props.metalness,
      roughness: props.roughness,
      opacity: props.opacity,
      transparent: props.transparent,
      emissive: new THREE.Color(props.emissive),
      emissiveIntensity: props.emissiveIntensity
    });

    const materialRef = inject<Ref<THREE.Material | null>>(MATERIAL_REF);
    
    if (materialRef) {
      materialRef.value = material;
    }

    debugLog('MeshStandardMaterial', 'Created', {
      color: props.color,
      metalness: props.metalness,
      roughness: props.roughness,
      opacity: props.opacity,
      emissive: props.emissive,
      emissiveIntensity: props.emissiveIntensity
    });

    watch(() => props.color, (newColor) => {
      material.color.set(newColor);
      debugLog('MeshStandardMaterial', 'Color updated', { color: newColor });
    });

    watch(() => props.emissive, (newColor) => {
      material.emissive.set(newColor);
      debugLog('MeshStandardMaterial', 'Emissive updated', { emissive: newColor });
    });

    onBeforeUnmount(() => {
      if (materialRef) {
        materialRef.value = null;
      }
      debugLog('MeshStandardMaterial', 'Disposing', {
        color: material.color.getHexString(),
        emissive: material.emissive.getHexString()
      });
      material.dispose();
    });

    return { material };
  }
});

// Line component
export const Line = defineComponent({
  name: 'Line',
  props: {
    points: {
      type: Array as unknown as () => [THREE.Vector3, THREE.Vector3],
      required: true,
      validator: (value: unknown) => {
        if (!Array.isArray(value) || value.length !== 2) return false;
        return value.every(v => v instanceof THREE.Vector3);
      }
    },
    color: {
      type: String,
      default: '#ffffff'
    },
    linewidth: {
      type: Number,
      default: 1
    },
    opacity: {
      type: Number,
      default: 1
    },
    transparent: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const scene = inject(SCENE_KEY) as THREE.Scene | null;
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;

    if (!scene && !parent) {
      throw new Error('Line must be used within a Scene or Group component');
    }

    const geometry = new THREE.BufferGeometry().setFromPoints(props.points);
    const material = new THREE.LineBasicMaterial({
      color: props.color,
      linewidth: props.linewidth,
      opacity: props.opacity,
      transparent: props.transparent
    });
    const line = new THREE.Line(geometry, material);

    onMounted(() => {
      if (parent) {
        parent.add(line);
      } else if (scene) {
        scene.add(line);
      }

      debugLog('Line', 'Added to scene', {
        points: props.points.map(p => p.toArray()),
        color: props.color,
        linewidth: props.linewidth,
        opacity: props.opacity,
        parent: parent?.type || 'Scene'
      });
    });

    watch(() => props.points, (newPoints) => {
      geometry.setFromPoints(newPoints);
      geometry.attributes.position.needsUpdate = true;
      debugLog('Line', 'Points updated', {
        points: newPoints.map(p => p.toArray())
      });
    });

    onBeforeUnmount(() => {
      debugLog('Line', 'Removing from scene', {
        points: props.points.map(p => p.toArray())
      });
      if (parent) {
        parent.remove(line);
      } else if (scene) {
        scene.remove(line);
      }
      geometry.dispose();
      material.dispose();
    });

    return { line };
  }
});

// Html component for labels
export const Html = defineComponent({
  name: 'Html',
  props: {
    position: {
      type: Object as () => THREE.Vector3,
      required: true
    },
    occlude: {
      type: Boolean,
      default: true
    },
    center: {
      type: Boolean,
      default: true
    },
    sprite: {
      type: Boolean,
      default: false
    },
    style: {
      type: Object as () => Record<string, string>,
      default: () => ({})
    }
  },
  setup(props, { slots }) {
    const container = ref<HTMLDivElement | null>(null);

    onMounted(() => {
      if (container.value) {
        const pos = props.position;
        container.value.style.transform = `translate3d(${pos.x}px, ${pos.y}px, ${pos.z}px)`;
        Object.assign(container.value.style, props.style);
        
        if (props.center) {
          container.value.style.transform += ' translate(-50%, -50%)';
        }

        debugLog('Html', 'Mounted', {
          position: [pos.x, pos.y, pos.z],
          center: props.center,
          occlude: props.occlude,
          sprite: props.sprite
        });
      }
    });

    watch(() => props.position, (newPos) => {
      if (container.value) {
        container.value.style.transform = `translate3d(${newPos.x}px, ${newPos.y}px, ${newPos.z}px)`;
        if (props.center) {
          container.value.style.transform += ' translate(-50%, -50%)';
        }
        debugLog('Html', 'Position updated', {
          position: [newPos.x, newPos.y, newPos.z]
        });
      }
    });

    return () => h('div', {
      ref: container,
      class: 'html-overlay',
      style: {
        position: 'absolute',
        pointerEvents: 'none',
        ...props.style
      }
    }, slots.default?.());
  }
});

// Export all components
export default {
  Scene,
  Mesh,
  SphereGeometry,
  MeshStandardMaterial,
  Line,
  Html
};

----
components/vr/VRControlPanel.vue
<template>
  <!-- This is a 3D component, so no template needed -->
</template>

<script lang="ts">
import { defineComponent, onMounted, onBeforeUnmount, ref } from 'vue';
import * as THREE from 'three';
import { useVisualizationStore } from '../../stores/visualization';
import { useSettingsStore } from '../../stores/settings';
import type { VisualizationConfig } from '../../types/components';

interface Props {
  scene: THREE.Scene;
  camera: THREE.Camera;
}

interface ControlChange {
  name: string;
  value: number | string;
}

interface Control {
  group: THREE.Group;
  min?: number;
  max?: number;
  value: number | string;
}

export default defineComponent({
  name: 'VRControlPanel',

  props: {
    scene: {
      type: Object as () => THREE.Scene,
      required: true
    },
    camera: {
      type: Object as () => THREE.Camera,
      required: true
    }
  },

  emits: {
    controlChange: (payload: ControlChange) => true
  },

  setup(props: Props, { emit }: { emit: (event: 'controlChange', payload: ControlChange) => void }) {
    const panel = ref<THREE.Group>(new THREE.Group());
    const controls = ref<Map<string, Control>>(new Map());
    const visualizationStore = useVisualizationStore();
    const settingsStore = useSettingsStore();

    const createTextTexture = (text: string): THREE.CanvasTexture => {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (!context) throw new Error('Could not get 2D context');

      canvas.width = 256;
      canvas.height = 64;
      context.font = '48px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 128, 32);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    };

    const mapValue = (value: number, inMin: number, inMax: number, outMin: number, outMax: number): number => {
      return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    };

    const initPanel = () => {
      // Create background panel
      const panelGeometry = new THREE.PlaneGeometry(1, 1.5);
      const panelMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x202020, 
        transparent: true, 
        opacity: 0.7 
      });
      const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
      panel.value.add(panelMesh);

      // Position panel in front of camera
      panel.value.position.set(0, 0, -2);
      panel.value.lookAt(props.camera.position);

      props.scene.add(panel.value);
    };

    const createSlider = (name: string, min: number, max: number, value: number, y: number) => {
      const sliderGroup = new THREE.Group();
      sliderGroup.name = name;

      // Create slider track
      const trackGeometry = new THREE.PlaneGeometry(0.8, 0.05);
      const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x505050 });
      const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
      sliderGroup.add(trackMesh);

      // Create slider handle
      const handleGeometry = new THREE.SphereGeometry(0.03);
      const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
      handleMesh.position.x = mapValue(value, min, max, -0.4, 0.4);
      sliderGroup.add(handleMesh);

      // Create label
      const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
      const labelMaterial = new THREE.MeshBasicMaterial({ 
        map: createTextTexture(name) 
      });
      const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
      labelMesh.position.set(-0.6, 0, 0);
      sliderGroup.add(labelMesh);

      sliderGroup.position.set(0, y, 0.01);
      panel.value.add(sliderGroup);
      controls.value.set(name, { group: sliderGroup, min, max, value });
    };

    const createColorPicker = (name: string, value: string, y: number) => {
      const pickerGroup = new THREE.Group();
      pickerGroup.name = name;

      // Create color swatch
      const swatchGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const swatchMaterial = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color(value) 
      });
      const swatchMesh = new THREE.Mesh(swatchGeometry, swatchMaterial);
      pickerGroup.add(swatchMesh);

      // Create label
      const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
      const labelMaterial = new THREE.MeshBasicMaterial({ 
        map: createTextTexture(name) 
      });
      const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
      labelMesh.position.set(-0.3, 0, 0);
      pickerGroup.add(labelMesh);

      pickerGroup.position.set(0, y, 0.01);
      panel.value.add(pickerGroup);
      controls.value.set(name, { group: pickerGroup, value });
    };

    const updateControl = (name: string, value: number | string) => {
      const control = controls.value.get(name);
      if (!control) return;

      if ('min' in control && 'max' in control && typeof value === 'number') {
        // Slider
        const handle = control.group.children[1];
        handle.position.x = mapValue(value, control.min!, control.max!, -0.4, 0.4);
      } else if (typeof value === 'string') {
        // Color picker
        const swatch = control.group.children[0] as THREE.Mesh;
        if (swatch.material instanceof THREE.MeshBasicMaterial) {
          swatch.material.color.set(value);
        }
      }
      control.value = value;
    };

    const handleInteraction = (intersection: THREE.Intersection) => {
      const controlName = intersection.object.parent?.name;
      if (!controlName) return null;

      const control = controls.value.get(controlName);
      if (!control) return null;

      if ('min' in control && 'max' in control) {
        // Slider
        const newValue = mapValue(intersection.point.x, -0.4, 0.4, control.min!, control.max!);
        updateControl(controlName, newValue);
        emit('controlChange', { name: controlName, value: newValue });
        return { name: controlName, value: newValue };
      } else {
        // Color picker
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        const currentIndex = colors.indexOf(parseInt(control.value as string));
        const newValue = colors[(currentIndex + 1) % colors.length];
        const hexValue = '#' + newValue.toString(16).padStart(6, '0');
        updateControl(controlName, hexValue);
        emit('controlChange', { name: controlName, value: hexValue });
        return { name: controlName, value: hexValue };
      }
    };

    onMounted(() => {
      initPanel();

      // Initialize controls based on current settings
      const settings = settingsStore.getVisualizationSettings;
      let yPosition = 0.6;

      // Add sliders
      createSlider('Scale', 0.1, 2.0, settings.min_node_size, yPosition);
      yPosition -= 0.2;
      createSlider('Opacity', 0, 1, settings.material.node_material_opacity, yPosition);
      yPosition -= 0.2;

      // Add color pickers
      createColorPicker('Node Color', settings.node_color, yPosition);
      yPosition -= 0.2;
      createColorPicker('Edge Color', settings.edge_color, yPosition);
    });

    onBeforeUnmount(() => {
      // Cleanup Three.js objects
      controls.value.forEach((control: Control) => {
        control.group.traverse((obj: THREE.Object3D) => {
          if (obj instanceof THREE.Mesh) {
            obj.geometry.dispose();
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => m.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
      });

      if (panel.value.parent) {
        panel.value.parent.remove(panel.value);
      }
    });

    return {
      panel,
      controls,
      handleInteraction,
      updateControl
    };
  }
});
</script>

----
components/visualization/BaseVisualization.vue
<template>
  <Renderer
    :antialias="true"
    :xr="platformInfo.hasXRSupport"
    :size="{ w: windowSize.width, h: windowSize.height }"
    ref="renderer"
  >
    <Scene ref="scene">
      <!-- Camera System -->
      <Camera
        :position="cameraPosition"
        :fov="75"
        :aspect="aspect"
        :near="0.1"
        :far="1000"
        ref="camera"
      />

      <!-- Lighting -->
      <AmbientLight :intensity="1.5" />
      <DirectionalLight
        :position="{ x: 10, y: 20, z: 10 }"
        :intensity="2.0"
        :cast-shadow="true"
      />
      <HemisphereLight
        :sky-color="0xffffff"
        :ground-color="0x444444"
        :intensity="1.5"
      />

      <!-- Graph Visualization -->
      <graph-system
        v-if="graphData"
        :nodes="graphData.nodes"
        :edges="graphData.edges"
        :settings="visualSettings"
      />

      <!-- XR Controllers and Hands -->
      <template v-if="platformInfo.isQuest">
        <xr-controllers />
        <xr-hands />
      </template>

      <!-- Effects -->
      <effects-system :settings="effectsSettings">
        <bloom v-if="effectsSettings.bloom.enabled" v-bind="effectsSettings.bloom" />
        <ssao v-if="effectsSettings.ssao.enabled" v-bind="effectsSettings.ssao" />
      </effects-system>
    </Scene>
  </Renderer>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted, onBeforeUnmount } from 'vue';
import { useSettingsStore } from '../../stores/settings';
import { usePlatform } from '../../composables/usePlatform';
import type { GraphData } from '../../types/core';
import { WebGLRenderer, Scene as ThreeScene, PerspectiveCamera } from 'three';
import {
  Renderer,
  Scene,
  Camera,
  AmbientLight,
  DirectionalLight,
  HemisphereLight
} from 'vue-threejs';

export default defineComponent({
  name: 'BaseVisualization',

  components: {
    Renderer,
    Scene,
    Camera,
    AmbientLight,
    DirectionalLight,
    HemisphereLight
  },

  setup() {
    // Refs for Three.js components
    const renderer = ref<WebGLRenderer | null>(null);
    const scene = ref<ThreeScene | null>(null);
    const camera = ref<PerspectiveCamera | null>(null);

    // Platform and settings
    const { getPlatformInfo } = usePlatform();
    const settingsStore = useSettingsStore();
    const platformInfo = computed(() => getPlatformInfo());

    // Window size reactive state
    const windowSize = ref({
      width: window.innerWidth,
      height: window.innerHeight
    });
    const aspect = computed(() => windowSize.value.width / windowSize.value.height);

    // Camera position with reactive updates
    const cameraPosition = ref({ x: 0, y: 75, z: 200 });

    // Graph data
    const graphData = ref<GraphData | null>(null);

    // Settings from store
    const visualSettings = computed(() => settingsStore.getVisualizationSettings);
    const effectsSettings = computed(() => ({
      bloom: settingsStore.getBloomSettings,
      ssao: {
        enabled: false,
        radius: 0.5,
        intensity: 1.0,
        bias: 0.5
      }
    }));

    // Window resize handler
    const handleResize = () => {
      windowSize.value = {
        width: window.innerWidth,
        height: window.innerHeight
      };
    };

    // Lifecycle hooks
    onMounted(() => {
      window.addEventListener('resize', handleResize);
      
      // Initialize platform-specific features
      if (platformInfo.value.isQuest) {
        initializeXR();
      }
    });

    onBeforeUnmount(() => {
      window.removeEventListener('resize', handleResize);
    });

    // XR initialization
    const initializeXR = async () => {
      if (!renderer.value || !platformInfo.value.hasXRSupport) return;

      try {
        const session = await navigator.xr?.requestSession('immersive-vr', {
          requiredFeatures: ['local-floor', 'bounded-floor'],
          optionalFeatures: ['hand-tracking']
        });

        if (session && renderer.value.xr) {
          await renderer.value.xr.setSession(session);
        }
      } catch (error) {
        console.error('Failed to initialize XR:', error);
      }
    };

    // Public methods
    const updateGraphData = (data: GraphData) => {
      graphData.value = data;
    };

    return {
      // Template refs
      renderer,
      scene,
      camera,

      // Computed properties
      platformInfo,
      windowSize,
      aspect,
      cameraPosition,
      graphData,
      visualSettings,
      effectsSettings,

      // Methods
      updateGraphData
    };
  }
});
</script>

<style scoped>
.renderer-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
</style>

----
components/visualization/GraphSystem.vue
<template>
  <div v-if="isReady && graphData">
    <!-- Graph Content -->
    <primitive :object="graphGroup" />
    <div v-if="process.env.NODE_ENV === 'development'" class="debug-info">
      Nodes: {{ graphData.nodes.length }} | Edges: {{ graphData.edges.length }}
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, watch, onMounted, inject } from 'vue';
import { Vector3, Vector2, Plane, Raycaster } from 'three';
import { useGraphSystem } from '../../composables/useGraphSystem';
import { useWebSocketStore } from '../../stores/websocket';
import { useBinaryUpdateStore } from '../../stores/binaryUpdate';
import { useVisualizationStore } from '../../stores/visualization';
import { usePlatform } from '../../composables/usePlatform';
import type { VisualizationConfig } from '../../types/components';
import type { GraphNode, GraphEdge, GraphData, CoreState } from '../../types/core';
import type { PositionUpdate } from '../../types/websocket';

export default defineComponent({
  name: 'GraphSystem',

  props: {
    visualSettings: {
      type: Object as () => VisualizationConfig,
      required: true
    }
  },

  setup(props) {
    // Get visualization state
    const visualizationState = inject<{ value: CoreState }>('visualizationState');
    const isReady = computed(() => {
      const ready = visualizationState?.value.scene != null && 
             visualizationState?.value.isInitialized === true;
      console.debug('Graph system ready state:', {
        hasScene: visualizationState?.value.scene != null,
        isInitialized: visualizationState?.value.isInitialized,
        ready,
        timestamp: new Date().toISOString()
      });
      return ready;
    });

    // Get platform info
    const { 
      getPlatformInfo, 
      enableVR, 
      enableAR, 
      disableXR,
      isXRActive,
      isVRActive,
      isARActive 
    } = usePlatform();
    
    const platformInfo = getPlatformInfo();

    // Initialize graph system
    const {
      graphGroup,
      hoveredNode,
      getNodePosition,
      getNodeScale,
      getNodeColor,
      getEdgePoints,
      getEdgeColor,
      getEdgeWidth,
      handleNodeClick,
      handleNodeHover,
      updateGraphData
    } = useGraphSystem();

    const websocketStore = useWebSocketStore();
    const binaryUpdateStore = useBinaryUpdateStore();
    const visualizationStore = useVisualizationStore();
    
    // Drag state
    const isDragging = ref(false);
    const draggedNode = ref<GraphNode | null>(null);
    const dragStartPosition = ref<Vector3 | null>(null);
    const dragPlane = ref<Plane | null>(null);
    const dragIntersection = new Vector3();

    // Graph data from store with enhanced debug logging
    const graphData = computed<GraphData>(() => {
      const data = visualizationStore.getGraphData || { nodes: [], edges: [], metadata: {} };
      console.debug('Graph data computed:', {
        nodes: data.nodes.length,
        edges: data.edges.length,
        hasMetadata: Object.keys(data.metadata || {}).length > 0,
        sampleNodes: data.nodes.slice(0, 3).map(n => ({
          id: n.id,
          hasPosition: !!n.position,
          edgeCount: n.edges?.length || 0
        })),
        timestamp: new Date().toISOString()
      });
      return data;
    });

    // Watch for binary updates with enhanced logging
    watch(() => binaryUpdateStore.positions, (positions) => {
      const positionEntries = Array.from(positions.entries());
      if (positionEntries.length > 0) {
        console.debug('Processing binary position update:', {
          updateCount: positionEntries.length,
          sample: positionEntries.slice(0, 3).map(([id, pos]) => ({
            id,
            position: [pos.x, pos.y, pos.z],
            velocity: [pos.vx, pos.vy, pos.vz]
          })),
          timestamp: new Date().toISOString()
        });
        
        // Update node positions
        let updatedCount = 0;
        positionEntries.forEach(([id, pos]) => {
          const node = graphData.value.nodes.find(n => n.id === id);
          if (node) {
            node.position = [pos.x, pos.y, pos.z];
            node.velocity = [pos.vx, pos.vy, pos.vz];
            updatedCount++;
          }
        });

        console.debug('Position updates applied:', {
          totalUpdates: positionEntries.length,
          successfulUpdates: updatedCount,
          timestamp: new Date().toISOString()
        });

        // Trigger graph update
        if (visualizationState?.value.scene) {
          visualizationState.value.scene.userData.needsRender = true;
          updateGraphData(graphData.value);
        }
      }
    }, { deep: true });

    // Drag handlers with enhanced logging
    const onDragStart = (event: PointerEvent, node: GraphNode) => {
      console.debug('Starting node drag:', {
        nodeId: node.id,
        initialPosition: getNodePosition(node),
        timestamp: new Date().toISOString()
      });

      isDragging.value = true;
      draggedNode.value = node;

      const camera = visualizationState?.value.camera;
      if (!camera) return;

      const normal = new Vector3(0, 0, 1);
      normal.applyQuaternion(camera.quaternion);
      dragPlane.value = new Plane(normal, 0);
      dragStartPosition.value = getNodePosition(node).clone();

      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
      }
    };

    const onDragMove = (event: PointerEvent) => {
      if (!isDragging.value || !draggedNode.value || !dragPlane.value) return;

      const camera = visualizationState?.value.camera;
      if (!camera) return;

      const target = event.currentTarget as HTMLElement;
      const rect = target.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      const raycaster = new Raycaster();
      const pointer = new Vector2(x, y);
      raycaster.setFromCamera(pointer, camera);

      if (raycaster.ray.intersectPlane(dragPlane.value, dragIntersection)) {
        const node = draggedNode.value;
        const position = getNodePosition(node);
        position.copy(dragIntersection);

        console.debug('Node drag update:', {
          nodeId: node.id,
          newPosition: [position.x, position.y, position.z],
          timestamp: new Date().toISOString()
        });

        if (websocketStore.service) {
          websocketStore.service.send({
            type: 'updateNodePosition',
            nodeId: node.id,
            position: [position.x, position.y, position.z]
          });
        }

        if (visualizationState?.value.scene) {
          visualizationState.value.scene.userData.needsRender = true;
        }
      }
    };

    const onDragEnd = () => {
      if (!isDragging.value || !draggedNode.value || !dragStartPosition.value) return;

      const finalPosition = getNodePosition(draggedNode.value);

      console.debug('Node drag ended:', {
        nodeId: draggedNode.value.id,
        startPosition: dragStartPosition.value.toArray(),
        finalPosition: finalPosition.toArray(),
        timestamp: new Date().toISOString()
      });

      if (websocketStore.service) {
        websocketStore.service.send({
          type: 'updateNodePosition',
          nodeId: draggedNode.value.id,
          position: [finalPosition.x, finalPosition.y, finalPosition.z]
        });
      }

      isDragging.value = false;
      draggedNode.value = null;
      dragStartPosition.value = null;
      dragPlane.value = null;

      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
      }
    };

    // XR handlers
    const handleEnableAR = async () => {
      try {
        if (isARActive()) {
          await disableXR();
        } else {
          await enableAR();
        }
      } catch (err) {
        console.error('Failed to toggle AR:', err);
      }
    };

    const handleEnableVR = async () => {
      try {
        if (isVRActive()) {
          await disableXR();
        } else {
          await enableVR();
        }
      } catch (err) {
        console.error('Failed to toggle VR:', err);
      }
    };

    // Watch for graph data changes with enhanced logging
    watch(() => graphData.value, (newData) => {
      if (newData && newData.nodes.length > 0) {
        console.debug('Graph data changed:', {
          nodes: newData.nodes.length,
          edges: newData.edges.length,
          sampleNode: newData.nodes[0] ? {
            id: newData.nodes[0].id,
            hasPosition: !!newData.nodes[0].position,
            edgeCount: newData.nodes[0].edges?.length || 0
          } : null,
          timestamp: new Date().toISOString()
        });
        updateGraphData(newData);
      }
    }, { deep: true });

    // Update graph data when component mounts
    onMounted(() => {
      console.debug('GraphSystem mounted');
      if (graphData.value) {
        console.debug('Initial graph data update:', {
          nodes: graphData.value.nodes.length,
          edges: graphData.value.edges.length,
          timestamp: new Date().toISOString()
        });
        updateGraphData(graphData.value);
      }
    });

    return {
      isReady,
      platformInfo,
      isXRActive,
      isVRActive,
      isARActive,
      enableAR: handleEnableAR,
      enableVR: handleEnableVR,
      graphGroup,
      hoveredNode,
      isDragging,
      graphData,
      onDragStart,
      onDragMove,
      onDragEnd,
      process: {
        env: {
          NODE_ENV: process.env.NODE_ENV
        }
      }
    };
  }
});
</script>

<style scoped>
.debug-info {
  position: fixed;
  top: 40px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 5px 10px;
  border-radius: 4px;
  font-family: monospace;
  font-size: 12px;
  z-index: 1000;
}

.xr-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 10px;
  z-index: 1000;
}

.ar-button,
.vr-button {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.2s;
}

.ar-button {
  background: #4CAF50;
  color: white;
}

.ar-button:hover:not(:disabled) {
  background: #45a049;
}

.vr-button {
  background: #2196F3;
  color: white;
}

.vr-button:hover:not(:disabled) {
  background: #1976D2;
}

.ar-button:disabled,
.vr-button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  opacity: 0.65;
}
</style>

----
visualization/effects.js
import * as THREE from 'three';
import { BloomEffect } from './effects/BloomEffect.js';
import { CompositionEffect } from './effects/CompositionEffect.js';
import { LAYERS } from './layerManager.js';
import { visualizationSettings } from '../services/visualizationSettings.js';

export class EffectsManager {
    constructor(scene, camera, renderer) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to EffectsManager');
        }
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Store original renderer settings
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();
        this.originalAutoClear = this.renderer.autoClear;
        
        // Configure renderer for optimal performance
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        // Initialize effects
        this.bloomEffect = null;
        this.compositionEffect = null;
        this.initialized = false;
        this.pendingInitialization = true;
        
        // XR properties
        this.isXRActive = false;
        
        // Bind methods
        this.render = this.render.bind(this);
        this.handleResize = this.handleResize.bind(this);
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.dispose = this.dispose.bind(this);
        
        // Add event listeners
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }
    
    async initPostProcessing(isXR = false) {
        try {
            console.log('Starting post-processing initialization');
            if (!this.renderer || !this.renderer.domElement) {
                throw new Error('Renderer not ready for post-processing initialization');
            }

            // Wait for settings if needed
            if (this.pendingInitialization) {
                console.log('Waiting for settings before initializing effects...');
                return false;
            }

            // Clean up existing effects if reinitializing
            if (this.initialized) {
                this.dispose();
            }

            // Configure renderer
            this.renderer.autoClear = true;
            this.isXRActive = isXR;

            // Get settings from server
            const settings = visualizationSettings.getSettings();
            if (!settings?.bloom) {
                console.error('Bloom settings not available from server');
                return false;
            }

            // Initialize bloom effect with server settings
            this.bloomEffect = new BloomEffect(this.renderer, this.scene, this.camera);
            await this.bloomEffect.init(settings.bloom);

            // Initialize composition effect
            this.compositionEffect = new CompositionEffect(this.renderer);
            await this.compositionEffect.init(this.bloomEffect.getRenderTargets());
            
            this.initialized = true;
            console.log('Post-processing initialization complete with server settings');
            return true;
        } catch (error) {
            console.error('Error in post-processing initialization:', error);
            this.dispose();
            return false;
        }
    }

    handleXRSessionStart() {
        console.log('XR session started');
        this.isXRActive = true;
        if (this.initialized) {
            // Reinitialize effects for XR
            this.initPostProcessing(true);
        }
    }

    handleXRSessionEnd() {
        console.log('XR session ended');
        this.isXRActive = false;
        if (this.initialized) {
            // Reinitialize effects for non-XR
            this.initPostProcessing(false);
        }
    }
    
    render() {
        if (!this.initialized) {
            // Fallback to direct rendering if effects aren't initialized
            this.renderer.render(this.scene, this.camera);
            return;
        }

        try {
            const currentCamera = this.isXRActive ? this.renderer.xr.getCamera() : this.camera;
            
            // Render bloom passes
            if (this.bloomEffect) {
                this.bloomEffect.render(currentCamera);
            }

            // Render final composition
            if (this.compositionEffect) {
                const baseTexture = this.bloomEffect.getRenderTargets().get('base').texture;
                this.compositionEffect.render(baseTexture);
            }
        } catch (error) {
            console.error('Error during rendering:', error);
            // Fallback to direct rendering on error
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    handleResize(width = window.innerWidth, height = window.innerHeight) {
        if (!this.initialized) return;

        try {
            // Update renderer size
            this.renderer.setSize(width, height);

            // Update effect sizes
            if (this.bloomEffect) {
                this.bloomEffect.resize(width, height);
            }
            if (this.compositionEffect) {
                this.compositionEffect.resize(width, height);
            }
        } catch (error) {
            console.error('Error handling resize:', error);
        }
    }
    
    handleSettingsUpdate(event) {
        console.log('Received settings update:', event.detail);

        // If waiting for initial settings, initialize
        if (this.pendingInitialization) {
            this.pendingInitialization = false;
            this.initPostProcessing(this.isXRActive);
            return;
        }

        // Update existing effects with new settings
        if (!this.initialized) return;

        try {
            const settings = event.detail;
            
            if (settings.bloom && this.bloomEffect) {
                this.bloomEffect.updateSettings(settings.bloom);
                if (this.compositionEffect) {
                    this.compositionEffect.updateSettings(this.bloomEffect.getRenderTargets());
                }
            }

            if (settings.visualization?.material && this.bloomEffect) {
                this.bloomEffect.updateMaterialSettings(settings.visualization.material);
            }
        } catch (error) {
            console.error('Error handling settings update:', error);
        }
    }
    
    dispose() {
        // Remove event listeners
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);
        
        // Dispose effects
        if (this.bloomEffect) {
            this.bloomEffect.dispose();
            this.bloomEffect = null;
        }
        
        if (this.compositionEffect) {
            this.compositionEffect.dispose();
            this.compositionEffect = null;
        }
        
        // Restore renderer settings
        if (this.renderer) {
            this.renderer.autoClear = this.originalAutoClear;
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        this.initialized = false;
        this.isXRActive = false;
    }

    isInitialized() {
        return this.initialized;
    }

    isXREnabled() {
        return this.isXRActive;
    }
}

----
visualization/layout.js
export class LayoutManager {
    constructor(settings = {}) {
        // Configuration
        this.initialIterations = settings.iterations || 250;
        this.updateIterations = 1;       // Single iteration for smooth continuous updates
        this.targetRadius = 200;
        this.naturalLength = 100;
        this.attraction = settings.attraction_strength || 0.01;
        this.repulsion = settings.repulsion_strength || 1000;
        this.spring = settings.spring_strength || 0.1;
        this.damping = settings.damping || 0.8;
        
        // State
        this.isInitialized = false;
        this.isSimulating = false;
        this.animationFrameId = null;
        this.lastPositions = null;       // Store previous positions for change detection
        this.updateThreshold = 0.001;    // Minimum position change to trigger update
        this.lastUpdateTime = 0;         // Last time positions were sent to server
        this.updateInterval = 16.67;     // Exactly 60fps
        this.positionBuffer = null;
        this.edges = [];                 // Store computed edges
        this.nodeCount = 0;              // Track number of nodes
        this.waitingForInitialData = true; // Wait for initial data before sending updates
    }

    initializePositions(nodes) {
        console.log('Initializing positions for nodes:', nodes);
        this.nodeCount = nodes.length;
        nodes.forEach(node => {
            // Initialize only if positions are invalid
            if (isNaN(node.x) || isNaN(node.y) || isNaN(node.z)) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = this.targetRadius * Math.cbrt(Math.random());
                
                node.x = r * Math.sin(phi) * Math.cos(theta);
                node.y = r * Math.sin(phi) * Math.sin(theta);
                node.z = r * Math.cos(phi);
            }
            // Always ensure velocities are initialized
            if (!node.vx) node.vx = 0;
            if (!node.vy) node.vy = 0;
            if (!node.vz) node.vz = 0;
        });

        // Initialize last positions with velocities
        this.lastPositions = nodes.map(node => ({
            x: node.x,
            y: node.y,
            z: node.z,
            vx: node.vx,
            vy: node.vy,
            vz: node.vz
        }));

        this.isInitialized = true;
        this.waitingForInitialData = false; // Initial data received
        console.log('Position initialization complete');

        // Send initial positions to server
        this.sendPositionUpdates(nodes, true);
    }

    applyForceDirectedLayout(nodes, edges) {
        if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
            console.warn('Invalid nodes array provided to force-directed layout');
            return;
        }

        if (!this.isInitialized || this.waitingForInitialData) {
            console.warn('Layout manager not initialized or waiting for initial data');
            return;
        }

        console.log('Applying force-directed layout to', nodes.length, 'nodes');
        const dt = 0.1;

        // Apply forces based on edges (topic counts)
        edges.forEach(edge => {
            const sourceNode = nodes.find(n => n.id === edge.source);
            const targetNode = nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                // Calculate spring force based on topic counts
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dz = targetNode.z - sourceNode.z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) return;

                // Use edge weight (from topic counts) to scale the force
                const force = (distance - this.naturalLength) * this.spring * (edge.weight || 1);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                // Apply forces to both nodes
                sourceNode.vx += fx * this.attraction;
                sourceNode.vy += fy * this.attraction;
                sourceNode.vz += fz * this.attraction;
                targetNode.vx -= fx * this.attraction;
                targetNode.vy -= fy * this.attraction;
                targetNode.vz -= fz * this.attraction;
            }
        });

        // Apply repulsion between all nodes
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dz = nodes[j].z - nodes[i].z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) continue;

                const force = this.repulsion / (distance * distance);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                nodes[i].vx -= fx;
                nodes[i].vy -= fy;
                nodes[i].vz -= fz;
                nodes[j].vx += fx;
                nodes[j].vy += fy;
                nodes[j].vz += fz;
            }
        }

        // Update positions and apply damping
        nodes.forEach(node => {
            // Apply current velocity
            node.x += node.vx * dt;
            node.y += node.vy * dt;
            node.z += node.vz * dt;

            // Apply damping
            node.vx *= this.damping;
            node.vy *= this.damping;
            node.vz *= this.damping;

            // Bound checking
            const bound = 500;
            if (Math.abs(node.x) > bound) node.vx *= -0.5;
            if (Math.abs(node.y) > bound) node.vy *= -0.5;
            if (Math.abs(node.z) > bound) node.vz *= -0.5;
        });
    }

    updateFeature(control, value) {
        console.log(`Updating layout feature: ${control} = ${value}`);
        
        // Convert from forceDirected prefixed names to internal parameter names
        const paramMap = {
            'forceDirectedIterations': 'iterations',
            'forceDirectedSpring': 'spring_strength',
            'forceDirectedRepulsion': 'repulsion_strength',
            'forceDirectedAttraction': 'attraction_strength',
            'forceDirectedDamping': 'damping'
        };

        const paramName = paramMap[control] || control;
        switch(paramName) {
            case 'iterations':
                this.initialIterations = value;
                break;
            case 'spring_strength':
                this.spring = value;
                break;
            case 'repulsion_strength':
                this.repulsion = value;
                break;
            case 'attraction_strength':
                this.attraction = value;
                break;
            case 'damping':
                this.damping = value;
                break;
            default:
                console.warn(`Unknown layout parameter: ${control}`);
        }
    }

    updatePhysics(settings) {
        console.log('Updating physics settings:', settings);
        
        // Update all physics parameters at once
        if (settings.iterations !== undefined) {
            this.initialIterations = settings.iterations;
        }
        if (settings.spring_strength !== undefined) {
            this.spring = settings.spring_strength;
        }
        if (settings.repulsion_strength !== undefined) {
            this.repulsion = settings.repulsion_strength;
        }
        if (settings.attraction_strength !== undefined) {
            this.attraction = settings.attraction_strength;
        }
        if (settings.damping !== undefined) {
            this.damping = settings.damping;
        }

        // If simulation is running, apply new settings immediately
        if (this.isSimulating) {
            console.log('Applying new physics settings to running simulation');
        }
    }

    performLayout(graphData) {
        if (!this.isInitialized || !graphData || this.waitingForInitialData) {
            console.warn('Cannot perform layout: not initialized, no graph data, or waiting for initial data');
            return;
        }

        const now = Date.now();
        if (now - this.lastUpdateTime >= this.updateInterval) {
            // Apply force-directed layout
            this.applyForceDirectedLayout(graphData.nodes, graphData.edges);
            
            // Send position updates
            this.sendPositionUpdates(graphData.nodes, false);
            this.lastUpdateTime = now;
        }
    }

    sendPositionUpdates(nodes, isInitialLayout = false) {
        if (!this.lastPositions || !this.isInitialized || nodes.length !== this.nodeCount || this.waitingForInitialData) {
            console.warn('Cannot send position updates: not initialized, node count mismatch, or waiting for initial data');
            return;
        }

        // Create binary buffer for all node positions and velocities (24 bytes per node)
        const buffer = new ArrayBuffer(nodes.length * 24 + 4); // Extra 4 bytes for is_initial_layout flag
        const dataView = new Float32Array(buffer);
        let hasChanges = false;

        // Set is_initial_layout flag (1.0 for true, 0.0 for false)
        dataView[0] = isInitialLayout ? 1.0 : 0.0;

        nodes.forEach((node, index) => {
            const offset = index * 6 + 1; // +1 to account for is_initial_layout flag
            const lastPos = this.lastPositions[index];

            if (!lastPos || 
                Math.abs(node.x - lastPos.x) > this.updateThreshold ||
                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
                Math.abs(node.z - lastPos.z) > this.updateThreshold ||
                Math.abs(node.vx - lastPos.vx) > this.updateThreshold ||
                Math.abs(node.vy - lastPos.vy) > this.updateThreshold ||
                Math.abs(node.vz - lastPos.vz) > this.updateThreshold) {
                
                hasChanges = true;
                
                // Update last position and velocity
                if (lastPos) {
                    lastPos.x = node.x;
                    lastPos.y = node.y;
                    lastPos.z = node.z;
                    lastPos.vx = node.vx;
                    lastPos.vy = node.vy;
                    lastPos.vz = node.vz;
                }

                // Position (vec3<f32>)
                dataView[offset] = node.x;
                dataView[offset + 1] = node.y;
                dataView[offset + 2] = node.z;

                // Velocity (vec3<f32>)
                dataView[offset + 3] = node.vx || 0;
                dataView[offset + 4] = node.vy || 0;
                dataView[offset + 5] = node.vz || 0;
            }
        });

        if (hasChanges || isInitialLayout) {
            // Log the buffer size before sending
            console.log(`Sending position update buffer of size: ${buffer.byteLength} bytes for ${nodes.length} nodes (isInitialLayout: ${isInitialLayout})`);
            
            // Dispatch binary data event
            window.dispatchEvent(new CustomEvent('positionUpdate', {
                detail: buffer
            }));
        }
    }

    startContinuousSimulation(graphData) {
        if (this.isSimulating) return;
        
        console.log('Starting continuous simulation');
        this.isSimulating = true;
        const animate = () => {
            if (!this.isSimulating) return;
            
            // Send position updates at regular intervals
            this.performLayout(graphData);
            this.animationFrameId = requestAnimationFrame(animate);
        };
        
        animate();
    }

    stopSimulation() {
        console.log('Stopping simulation');
        this.isSimulating = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
}

----
visualization/nodes.js
import * as THREE from 'three';
import { visualizationSettings } from '../services/visualizationSettings.js';
import { LAYERS, LAYER_GROUPS, LayerManager } from './layerManager.js';

/**
 * NodeManager handles the efficient rendering and updating of nodes and edges in the graph visualization.
 * It uses THREE.js InstancedMesh for performance and supports both regular updates and binary position updates.
 */
export class NodeManager {
    constructor(scene, camera, settings = {}) {
        // Core references
        this.scene = scene;
        this.camera = camera;
        
        // Data structures
        this.nodeData = new Map();          // Stores node data
        this.labelPool = new Map();         // Reusable label sprites
        this.instanceIds = new Map();       // Maps positions to node IDs
        
        // Rendering structures
        this.nodeInstancedMeshes = null;    // Different LOD meshes for nodes
        this.edgeInstancedMesh = null;      // Single mesh for all edges
        this.instancedContainer = null;      // Container for all instanced meshes
        
        // Binary update optimization
        this.instancePositions = new Float32Array(30000);  // Pre-allocated for position updates
        this.instanceSizes = new Float32Array(10000);      // Pre-allocated for size updates
        this._labelUpdateTimeout = null;                   // For throttling label updates
        
        // Reusable objects for matrix operations
        this.matrix = new THREE.Matrix4();
        this.quaternion = new THREE.Quaternion();
        this.position = new THREE.Vector3();
        this.scale = new THREE.Vector3();
        this.color = new THREE.Color();
        
        // Initialize settings
        this.initializeSettings(settings);
        
        // Create container and initialize meshes
        this.instancedContainer = new THREE.Group();
        this.instancedContainer.name = 'instancedContainer';
        this.scene.add(this.instancedContainer);
        
        // Initialize instanced meshes
        this.initInstancedMeshes();
        
        // Set up label rendering
        this.initializeLabelRenderer();
        
        // Bind methods
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.updateNodePositions = this.updateNodePositions.bind(this);
        
        // Add event listeners
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
    }

    /**
     * Initializes settings from server or defaults
     */
    initializeSettings(settings) {
        const nodeSettings = visualizationSettings.getNodeSettings();
        if (!nodeSettings) {
            console.warn('Using default node settings');
        }

        // Node appearance
        this.minNodeSize = settings.minNodeSize || nodeSettings?.minNodeSize || 0.15;
        this.maxNodeSize = settings.maxNodeSize || nodeSettings?.maxNodeSize || 0.4;
        this.nodeColor = new THREE.Color(settings.nodeColor || nodeSettings?.color || 0xffa500);
        
        // Material settings
        this.materialSettings = {
            metalness: nodeSettings?.material?.metalness || 0.3,
            roughness: nodeSettings?.material?.roughness || 0.5,
            clearcoat: nodeSettings?.material?.clearcoat || 0.8,
            opacity: nodeSettings?.material?.opacity || 0.95,
            emissiveMinIntensity: nodeSettings?.material?.emissiveMinIntensity || 0.0,
            emissiveMaxIntensity: nodeSettings?.material?.emissiveMaxIntensity || 0.3
        };

        // Age-based colors
        this.ageColors = {
            NEW: new THREE.Color(nodeSettings?.colorNew || 0x00ff88),
            RECENT: new THREE.Color(nodeSettings?.colorRecent || 0x4444ff),
            MEDIUM: new THREE.Color(nodeSettings?.colorMedium || 0xffaa00),
            OLD: new THREE.Color(nodeSettings?.colorOld || 0xff4444)
        };
        
        // Edge appearance
        const edgeSettings = visualizationSettings.getEdgeSettings();
        this.edgeColor = new THREE.Color(settings.edgeColor || edgeSettings?.color || 0xffffff);
        this.edgeOpacity = settings.edgeOpacity || edgeSettings?.opacity || 0.4;
        
        // Label settings
        this.labelFontSize = settings.labelFontSize || 32;
        this.maxAge = settings.maxAge || 30; // days
    }

    /**
     * Initializes instanced meshes for efficient rendering
     */
    initInstancedMeshes() {
        try {
            // Create geometries for different LOD levels
            const highDetailGeometry = new THREE.SphereGeometry(1, 32, 32);
            const mediumDetailGeometry = new THREE.SphereGeometry(1, 16, 16);
            const lowDetailGeometry = new THREE.SphereGeometry(1, 8, 8);

            // Create base material
            const nodeMaterial = new THREE.MeshPhysicalMaterial({
                metalness: this.materialSettings.metalness,
                roughness: this.materialSettings.roughness,
                transparent: true,
                opacity: this.materialSettings.opacity,
                clearcoat: this.materialSettings.clearcoat,
                clearcoatRoughness: 0.1,
                emissive: this.nodeColor,
                emissiveIntensity: this.materialSettings.emissiveMinIntensity
            });

            // Initialize instanced meshes
            const maxInstances = 10000;
            this.nodeInstancedMeshes = {
                high: new THREE.InstancedMesh(highDetailGeometry, nodeMaterial.clone(), maxInstances),
                medium: new THREE.InstancedMesh(mediumDetailGeometry, nodeMaterial.clone(), maxInstances),
                low: new THREE.InstancedMesh(lowDetailGeometry, nodeMaterial.clone(), maxInstances)
            };

            // Set up edge instanced mesh
            const edgeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
            edgeGeometry.rotateX(Math.PI / 2);
            
            const edgeMaterial = new THREE.MeshBasicMaterial({
                color: this.edgeColor,
                transparent: true,
                opacity: this.edgeOpacity,
                depthWrite: false
            });

            this.edgeInstancedMesh = new THREE.InstancedMesh(
                edgeGeometry,
                edgeMaterial,
                maxInstances * 2
            );

            // Add meshes to container
            Object.values(this.nodeInstancedMeshes).forEach(mesh => {
                mesh.count = 0;
                LayerManager.setLayerGroup(mesh, 'BLOOM');
                this.instancedContainer.add(mesh);
            });

            LayerManager.setLayerGroup(this.edgeInstancedMesh, 'EDGE');
            this.instancedContainer.add(this.edgeInstancedMesh);

        } catch (error) {
            console.error('Error initializing instanced meshes:', error);
            throw error;
        }
    }

    /**
     * Initializes the label renderer
     */
    initializeLabelRenderer() {
        this.labelCanvas = document.createElement('canvas');
        this.labelContext = this.labelCanvas.getContext('2d', {
            alpha: true,
            desynchronized: true,
            willReadFrequently: false
        });
    }

    /**
     * Handles binary position updates from WebSocket
     * @param {Float32Array} positions - Array of [x,y,z,vx,vy,vz] values
     * @param {boolean} isInitialLayout - Whether this is the initial layout
     */
    updateNodePositions(positions, isInitialLayout = false) {
        if (!this.nodeInstancedMeshes) return;

        const matrix = this.matrix;
        const position = this.position;
        const quaternion = this.quaternion;
        const updatedNodes = new Set();

        // Update positions in batches
        for (let i = 0; i < positions.length; i++) {
            const nodeId = Array.from(this.nodeData.keys())[i];
            if (!nodeId) continue;

            const pos = positions[i];
            const node = this.nodeData.get(nodeId);
            
            // Update node data
            node.x = pos[0];
            node.y = pos[1];
            node.z = pos[2];
            node.vx = pos[3];
            node.vy = pos[4];
            node.vz = pos[5];

            // Update instance matrix
            position.set(pos[0], pos[1], pos[2]);
            const size = this.getNodeSize(node.metadata || {});
            this.scale.set(size, size, size);
            matrix.compose(position, quaternion, this.scale);

            // Update appropriate LOD mesh
            const distance = this.camera.position.distanceTo(position);
            let targetMesh;
            if (distance < 50) targetMesh = this.nodeInstancedMeshes.high;
            else if (distance < 100) targetMesh = this.nodeInstancedMeshes.medium;
            else targetMesh = this.nodeInstancedMeshes.low;

            targetMesh.setMatrixAt(i, matrix);

            // Track updates
            updatedNodes.add(nodeId);

            // Update instance lookup data
            const posIndex = i * 3;
            this.instancePositions[posIndex] = pos[0];
            this.instancePositions[posIndex + 1] = pos[1];
            this.instancePositions[posIndex + 2] = pos[2];
            this.instanceIds.set(`${[pos[0], pos[1], pos[2]]}`, nodeId);
        }

        // Update instance matrices
        Object.values(this.nodeInstancedMeshes).forEach(mesh => {
            mesh.instanceMatrix.needsUpdate = true;
        });

        // Update edges and labels
        if (updatedNodes.size > 0) {
            this.updateEdgesForNodes(updatedNodes);
            this.throttledLabelUpdate(updatedNodes);
        }

        // Center camera on initial layout
        if (isInitialLayout) {
            this.centerCamera();
        }
    }

    /**
     * Updates edges connected to moved nodes
     * @param {Set<string>} updatedNodes - Set of node IDs that moved
     */
    updateEdgesForNodes(updatedNodes) {
        if (!this.edgeInstancedMesh) return;

        const matrix = this.matrix;
        const position = this.position;
        const quaternion = this.quaternion;
        const scale = this.scale;
        let edgeIndex = 0;

        // Update only affected edges
        this.nodeData.forEach((sourceNode, sourceId) => {
            this.nodeData.forEach((targetNode, targetId) => {
                if (sourceId === targetId) return;
                if (!updatedNodes.has(sourceId) && !updatedNodes.has(targetId)) return;

                const start = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
                const end = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);
                const direction = end.clone().sub(start);
                const length = direction.length();

                if (length === 0) return;

                // Update edge transform
                const center = start.clone().add(end).multiplyScalar(0.5);
                position.copy(center);
                direction.normalize();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                scale.set(0.15, length, 0.15);

                matrix.compose(position, quaternion, scale);
                this.edgeInstancedMesh.setMatrixAt(edgeIndex++, matrix);
            });
        });

        this.edgeInstancedMesh.count = edgeIndex;
        this.edgeInstancedMesh.instanceMatrix.needsUpdate = true;
    }

    /**
     * Throttled label update to improve performance
     * @param {Set<string>} updatedNodes - Set of node IDs that need label updates
     */
    throttledLabelUpdate(updatedNodes) {
        if (this._labelUpdateTimeout) return;

        this._labelUpdateTimeout = setTimeout(() => {
            updatedNodes.forEach(nodeId => {
                const node = this.nodeData.get(nodeId);
                if (!node) return;

                const label = this.labelPool.get(nodeId);
                if (label) {
                    const size = this.getNodeSize(node.metadata || {});
                    label.position.set(node.x, node.y + size * 1.5, node.z);
                    label.visible = true;
                }
            });
            this._labelUpdateTimeout = null;
        }, 100);
    }

    dispose() {
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.removeEventListener('xrsessionstart', () => this.handleXRStateChange(true));
        window.removeEventListener('xrsessionend', () => this.handleXRStateChange(false));
        
        if (this.xrController) {
            this.xrController.removeEventListener('select', this.handleXRSelect);
            this.scene.remove(this.xrController);
        }

        Object.values(this.nodeInstancedMeshes).forEach(mesh => {
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
            this.instancedContainer.remove(mesh);
        });

        if (this.edgeInstancedMesh) {
            if (this.edgeInstancedMesh.geometry) this.edgeInstancedMesh.geometry.dispose();
            if (this.edgeInstancedMesh.material) this.edgeInstancedMesh.material.dispose();
            this.instancedContainer.remove(this.edgeInstancedMesh);
        }

        this.labelPool.forEach(label => {
            if (label.material) {
                if (label.material.map) label.material.map.dispose();
                label.material.dispose();
            }
            this.scene.remove(label);
        });

        this.scene.remove(this.instancedContainer);
        
        this.nodeData.clear();
        this.labelPool.clear();
        this.instanceIds.clear();
    }
}

----
visualization/core.js
// Previous imports unchanged...
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { NodeManager } from './nodes.js';
import { EffectsManager } from './effects.js';
import { visualizationSettings } from '../services/visualizationSettings.js';
import { initXRSession, addXRButton, handleXRSession } from '../xr/xrSetup.js';
import { initXRInteraction } from '../xr/xrInteraction.js';

// Constants for input sensitivity
const TRANSLATION_SPEED = 0.01;
const ROTATION_SPEED = 0.01;
const VR_MOVEMENT_SPEED = 0.05;

export class WebXRVisualization {
    constructor(graphDataManager) {
        console.log('WebXRVisualization constructor called with graphDataManager:', !!graphDataManager);
        if (!graphDataManager) {
            throw new Error('GraphDataManager is required for WebXRVisualization');
        }
        this.graphDataManager = graphDataManager;

        // Wait for settings before initializing
        this.initialized = false;
        this.pendingInitialization = true;

        // Store references that will be initialized once settings are received
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.nodeManager = null;
        this.controls = null;
        this.xrSessionManager = null;
        this.canvas = null;

        // Position tracking
        this.nodePositions = new Map();
        this.positionBuffer = null;

        // Bind methods
        this.onWindowResize = this.onWindowResize.bind(this);
        this.animate = this.animate.bind(this);
        this.updateVisualization = this.updateVisualization.bind(this);
        this.handleSpacemouseInput = this.handleSpacemouseInput.bind(this);
        this.renderFrame = this.renderFrame.bind(this);
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.handleBinaryUpdate = this.handleBinaryUpdate.bind(this);

        // Add event listeners
        window.addEventListener('binaryPositionUpdate', this.handleBinaryUpdate);
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
    }

    handleBinaryUpdate(event) {
        if (!this.initialized || !this.nodeManager) return;

        const { positions, isInitialLayout } = event.detail;
        
        // Update position cache
        this.nodeManager.nodes.forEach((node, index) => {
            if (positions[index]) {
                const pos = positions[index];
                // Update node position directly
                node.position.set(pos[0], pos[1], pos[2]);
                // Cache position for quick access
                this.nodePositions.set(node.id, {
                    position: [pos[0], pos[1], pos[2]],
                    velocity: [pos[3], pos[4], pos[5]]
                });
            }
        });

        // Update edges if needed (they might need to follow node positions)
        if (this.nodeManager.updateEdgePositions) {
            this.nodeManager.updateEdgePositions();
        }

        // If this is an initial layout, center the camera
        if (isInitialLayout) {
            this.centerCamera();
        }
    }

    centerCamera() {
        if (!this.nodeManager || !this.camera || this.nodeManager.nodes.length === 0) return;

        // Calculate bounding box
        const bbox = new THREE.Box3();
        this.nodeManager.nodes.forEach(node => {
            bbox.expandByPoint(node.position);
        });

        // Get center and size
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        const size = new THREE.Vector3();
        bbox.getSize(size);

        // Calculate optimal camera position
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = this.camera.fov * (Math.PI / 180);
        const cameraZ = Math.abs(maxDim / Math.sin(fov / 2));

        // Update camera and controls
        this.camera.position.set(center.x, center.y, center.z + cameraZ);
        if (this.controls) {
            this.controls.target.copy(center);
            this.controls.update();
        }
    }

    updateVisualization(data) {
        if (!this.nodeManager || !data) {
            console.warn('Cannot update visualization: missing manager or data');
            return;
        }

        console.log(`Updating visualization with ${data.nodes?.length || 0} nodes and ${data.edges?.length || 0} edges`);

        // Handle full graph updates (structure changes)
        if (data.nodes || data.edges) {
            if (Array.isArray(data.nodes)) {
                console.log('Updating nodes');
                this.nodeManager.updateNodes(data.nodes);
                // Update position cache
                data.nodes.forEach(node => {
                    this.nodePositions.set(node.id, {
                        position: [node.x, node.y, node.z],
                        velocity: [node.vx || 0, node.vy || 0, node.vz || 0]
                    });
                });
            }
            
            if (Array.isArray(data.edges)) {
                console.log('Updating edges');
                this.nodeManager.updateEdges(data.edges);
            }
        }
    }

    async initializeXR() {
        try {
            // Enable XR on renderer
            this.renderer.xr.enabled = true;

            // Initialize XR session manager
            this.xrSessionManager = await initXRSession(this.renderer, this.scene, this.camera);
            
            if (this.xrSessionManager) {
                // Add XR button to the scene
                await addXRButton(this.xrSessionManager);
                console.log('XR initialization complete');
            } else {
                console.warn('XR not supported or initialization failed');
            }
        } catch (error) {
            console.error('Error initializing XR:', error);
        }
    }

    renderFrame() {
        // Update controls if not in XR mode
        if (this.controls && (!this.xrSessionManager || !this.renderer.xr.isPresenting)) {
            this.controls.update();
        }

        // Update XR session if active
        if (this.xrSessionManager && this.renderer.xr.isPresenting) {
            this.xrSessionManager.update();
        }

        // Update node labels using cached positions
        if (this.nodeManager) {
            this.nodeManager.updateLabelOrientations(this.camera);
        }

        // Render scene
        this.renderer.render(this.scene, this.camera);
    }

    animate() {
        // Use requestAnimationFrame for non-XR rendering
        if (!this.renderer.xr.isPresenting) {
            requestAnimationFrame(this.animate);
            this.renderFrame();
        }
    }

    initializeSettings() {
        console.log('Initializing settings');
        
        const settings = visualizationSettings.getSettings();
        if (!settings?.visualization) {
            console.warn('No visualization settings available');
            return;
        }

        const vis = settings.visualization;
        
        // Add strong ambient light for better visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        this.scene.add(ambientLight);

        // Add directional light for shadows and highlights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
        directionalLight.position.set(10, 20, 10);
        this.scene.add(directionalLight);

        // Add hemisphere light for better ambient illumination
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        this.scene.add(hemisphereLight);

        // Add point lights for better illumination
        const pointLight1 = new THREE.PointLight(0xffffff, 1.0, 300);
        pointLight1.position.set(100, 100, 100);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1.0, 300);
        pointLight2.position.set(-100, -100, -100);
        this.scene.add(pointLight2);

        // Set fog from settings
        this.scene.fog = new THREE.FogExp2(0x000000, vis.fog_density);

        console.log('Scene settings initialized with settings from server');
    }

    onWindowResize() {
        if (this.camera && this.renderer && this.canvas) {
            // Update canvas size
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            
            // Update camera
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            
            // Update renderer
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    setupEventListeners() {
        console.log('Setting up event listeners');
        
        window.addEventListener('graphDataUpdated', (event) => {
            console.log('Received graphDataUpdated event:', event.detail);
            if (event.detail && Array.isArray(event.detail.nodes)) {
                this.updateVisualization(event.detail);
            } else {
                console.warn('Invalid graph data in event:', event.detail);
            }
        });

        window.addEventListener('resize', this.onWindowResize);
    }

    handleSpacemouseInput(x, y, z) {
        if (!this.camera) return;

        this.camera.position.x += x * TRANSLATION_SPEED;
        this.camera.position.y += y * TRANSLATION_SPEED;
        this.camera.position.z += z * TRANSLATION_SPEED;

        if (this.controls) {
            this.controls.target.copy(this.camera.position).add(
                new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion)
            );
            this.controls.update();
        }
    }

    dispose() {
        console.log('Disposing WebXRVisualization');
        
        // Remove event listeners
        window.removeEventListener('binaryPositionUpdate', this.handleBinaryUpdate);
        window.removeEventListener('resize', this.onWindowResize);
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);

        // Clear position cache
        this.nodePositions.clear();
        this.positionBuffer = null;

        // Clean up renderer
        this.renderer.setAnimationLoop(null);

        // Clean up managers
        if (this.nodeManager) {
            this.nodeManager.dispose();
        }

        // Clean up DOM elements
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }

        // Dispose of Three.js resources
        if (this.renderer) {
            this.renderer.dispose();
        }

        if (this.controls) {
            this.controls.dispose();
        }

        console.log('WebXRVisualization disposed');
    }
}

----
visualization/textRenderer.js
import * as THREE from 'three';

// SDF font atlas generation
function generateSDFData(text, fontSize, padding) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size to power of 2 for better texture performance
    const size = Math.pow(2, Math.ceil(Math.log2(fontSize * 2 + padding * 2)));
    canvas.width = size;
    canvas.height = size;
    
    // Setup font
    ctx.font = `${fontSize}px Arial`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    
    // Draw text
    ctx.fillStyle = 'white';
    ctx.fillText(text, size/2, size/2);
    
    // Generate SDF
    const imageData = ctx.getImageData(0, 0, size, size);
    const sdf = new Float32Array(size * size);
    
    // Calculate SDF values
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            const alpha = imageData.data[idx + 3] / 255;
            
            // Calculate distance field
            let minDist = Number.MAX_VALUE;
            const maxSearchDist = fontSize / 2;
            
            for (let sy = -maxSearchDist; sy <= maxSearchDist; sy++) {
                for (let sx = -maxSearchDist; sx <= maxSearchDist; sx++) {
                    const sampX = x + sx;
                    const sampY = y + sy;
                    
                    if (sampX >= 0 && sampX < size && sampY >= 0 && sampY < size) {
                        const sampIdx = (sampY * size + sampX) * 4;
                        const sampAlpha = imageData.data[sampIdx + 3] / 255;
                        
                        if (sampAlpha !== alpha) {
                            const dist = Math.sqrt(sx*sx + sy*sy);
                            minDist = Math.min(minDist, dist);
                        }
                    }
                }
            }
            
            // Normalize and store SDF value
            sdf[y * size + x] = alpha === 1 ? minDist / maxSearchDist : -minDist / maxSearchDist;
        }
    }
    
    return {
        data: sdf,
        size: size,
        texture: new THREE.DataTexture(
            sdf,
            size,
            size,
            THREE.RedFormat,
            THREE.FloatType
        )
    };
}

export class TextRenderer {
    constructor() {
        // SDF shader for high-quality text rendering
        this.material = new THREE.ShaderMaterial({
            uniforms: {
                sdfTexture: { value: null },
                color: { value: new THREE.Color(0xffffff) },
                smoothing: { value: 0.25 },
                threshold: { value: 0.5 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D sdfTexture;
                uniform vec3 color;
                uniform float smoothing;
                uniform float threshold;
                varying vec2 vUv;
                
                void main() {
                    float sdf = texture2D(sdfTexture, vUv).r;
                    float alpha = smoothstep(threshold - smoothing, threshold + smoothing, sdf);
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });
    }
    
    createTextSprite(text, options = {}) {
        const {
            fontSize = 32,
            padding = 8,
            color = 0xffffff,
            backgroundColor = 0x000000,
            backgroundOpacity = 0.85
        } = options;
        
        // Generate SDF data
        const sdfData = generateSDFData(text, fontSize, padding);
        
        // Create geometry
        const geometry = new THREE.PlaneGeometry(1, 1);
        
        // Update material with new texture
        const material = this.material.clone();
        material.uniforms.sdfTexture.value = sdfData.texture;
        material.uniforms.color.value = new THREE.Color(color);
        
        // Create mesh
        const mesh = new THREE.Mesh(geometry, material);
        
        // Add background plane if needed
        if (backgroundOpacity > 0) {
            const bgGeometry = new THREE.PlaneGeometry(1.1, 1.1);
            const bgMaterial = new THREE.MeshBasicMaterial({
                color: backgroundColor,
                transparent: true,
                opacity: backgroundOpacity,
                depthWrite: false
            });
            const background = new THREE.Mesh(bgGeometry, bgMaterial);
            background.position.z = -0.001;
            mesh.add(background);
        }
        
        // Scale mesh based on texture size
        const scale = fontSize / sdfData.size;
        mesh.scale.set(sdfData.size * scale, sdfData.size * scale, 1);
        
        return mesh;
    }
    
    dispose() {
        this.material.dispose();
    }
}

----
visualization/layerManager.js
import * as THREE from 'three';

// Layer constants for rendering pipeline
export const LAYERS = {
    NORMAL_LAYER: 0,  // Base layer for regular rendering
    BLOOM: 1,        // Layer for node bloom effects
    HOLOGRAM: 2,     // Layer for hologram effects
    EDGE: 3,         // Layer for edge bloom effects
    LABEL: 4         // Layer for labels
};

// Simplified layer groups - everything visible on normal layer
export const LAYER_GROUPS = {
    // Base scene elements
    BASE: [LAYERS.NORMAL_LAYER],
    
    // Nodes
    BLOOM: [LAYERS.NORMAL_LAYER],
    
    // Hologram elements
    HOLOGRAM: [LAYERS.NORMAL_LAYER],
    
    // Edge elements
    EDGE: [LAYERS.NORMAL_LAYER],
    
    // Label elements
    LABEL: [LAYERS.NORMAL_LAYER]
};

// Simplified material presets for basic rendering
const MATERIAL_PRESETS = {
    BLOOM: {
        transparent: true,
        opacity: 1.0,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    },
    HOLOGRAM: {
        transparent: true,
        opacity: 0.8,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    },
    EDGE: {
        transparent: true,
        opacity: 0.8,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    }
};

// Enhanced LayerManager with simplified rendering
export const LayerManager = {
    // Enable multiple layers for an object
    enableLayers(object, layers) {
        if (!object || !object.layers) {
            console.error('Invalid object provided to enableLayers');
            return;
        }

        // Always enable normal layer
        object.layers.set(LAYERS.NORMAL_LAYER);
    },

    // Set object to specific layer group with basic material settings
    setLayerGroup(object, groupName) {
        if (!object || !object.layers) {
            console.error('Invalid object provided to setLayerGroup');
            return;
        }

        // Always set to normal layer for visibility
        object.layers.set(LAYERS.NORMAL_LAYER);

        // Apply basic material presets if object has material
        if (object.material && MATERIAL_PRESETS[groupName]) {
            // Clone material to avoid affecting other objects
            if (!object.material._isCloned) {
                object.material = object.material.clone();
                object.material._isCloned = true;
            }
            
            // Apply basic preset properties
            Object.assign(object.material, MATERIAL_PRESETS[groupName]);
            
            // Ensure material is visible and properly rendered
            object.material.needsUpdate = true;
        }
    },

    // Check if object is in layer
    isInLayer(object, layer) {
        if (!object || !object.layers || typeof layer !== 'number') {
            return false;
        }
        return object.layers.test(new THREE.Layers().set(layer));
    },

    // Get all objects in a specific layer
    getObjectsInLayer(scene, layer, options = {}) {
        if (!scene || typeof layer !== 'number') {
            console.error('Invalid parameters provided to getObjectsInLayer');
            return [];
        }

        const objects = [];
        const {
            includeInvisible = false,
            includeHelpers = false
        } = options;

        scene.traverse(object => {
            if (this.isInLayer(object, layer)) {
                if (!includeInvisible && !object.visible) return;
                if (!includeHelpers && object.isHelper) return;
                objects.push(object);
            }
        });
        return objects;
    },

    // Reset object to base layer with standard material
    resetToBaseLayer(object) {
        if (!object || !object.layers) return;
        
        object.layers.set(LAYERS.NORMAL_LAYER);
        
        if (object.material && object.material._isCloned) {
            object.material.dispose();
            object.material = new THREE.MeshStandardMaterial({
                color: object.material.color,
                transparent: true,
                opacity: 1.0,
                toneMapped: true
            });
            object.material._isCloned = false;
        }
    },

    // Create a standard material
    createStandardMaterial(color) {
        return new THREE.MeshStandardMaterial({
            color: color,
            transparent: true,
            opacity: 1.0,
            toneMapped: true,
            depthWrite: true,
            blending: THREE.NormalBlending
        });
    }
};

----
visualization/effects/BloomEffect.js
import * as THREE from 'three';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { LAYERS } from '../layerManager.js';

export class BloomEffect {
    constructor(renderer, scene, camera) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to BloomEffect');
        }
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.composers = new Map();
        this.renderTargets = new Map();
        this.xrRenderTargets = new Map();
        this.initialized = false;
        this.isXRActive = false;

        // Store original renderer state
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();

        // Bind XR session change handlers
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);

        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }

    handleXRSessionStart() {
        this.isXRActive = true;
        // Create XR-specific render targets if needed
        if (this.initialized) {
            this.createXRRenderTargets();
        }
    }

    handleXRSessionEnd() {
        this.isXRActive = false;
        // Clean up XR render targets
        this.xrRenderTargets.forEach(target => {
            if (target && target.dispose) {
                target.dispose();
            }
        });
        this.xrRenderTargets.clear();
    }

    createRenderTarget(isXR = false) {
        let width, height;
        
        if (isXR && this.renderer.xr.getSession()) {
            const glProperties = this.renderer.properties.get(this.renderer.xr.getSession());
            const renderWidth = glProperties?.renderWidth || window.innerWidth * 2;
            const renderHeight = glProperties?.renderHeight || window.innerHeight;
            width = renderWidth;
            height = renderHeight;
        } else {
            const pixelRatio = this.renderer.getPixelRatio();
            width = Math.floor(window.innerWidth * pixelRatio);
            height = Math.floor(window.innerHeight * pixelRatio);
        }

        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        return new THREE.WebGLRenderTarget(
            width,
            height,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType,
                colorSpace: isWebGL2 ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace,
                stencilBuffer: false,
                depthBuffer: true,
                samples: isWebGL2 ? 4 : 0
            }
        );
    }

    createXRRenderTargets() {
        const layers = [LAYERS.BLOOM, LAYERS.HOLOGRAM, LAYERS.EDGE];
        
        // Create base XR render target
        const baseTarget = this.createRenderTarget(true);
        this.xrRenderTargets.set('base', baseTarget);

        // Create XR render targets for each layer
        layers.forEach(layer => {
            const renderTarget = this.createRenderTarget(true);
            this.xrRenderTargets.set(layer, renderTarget);
        });
    }

    init(settings) {
        if (!settings) {
            console.error('No bloom settings provided');
            return;
        }

        if (this.initialized) {
            this.dispose();
        }

        if (!this.renderer || !this.renderer.domElement) {
            console.error('Renderer not ready for bloom effect initialization');
            return;
        }

        // Create base render target for scene
        const baseTarget = this.createRenderTarget();
        this.renderTargets.set('base', baseTarget);

        // Create XR render targets if in XR mode
        if (this.isXRActive) {
            this.createXRRenderTargets();
        }

        // Adjust settings based on WebGL version and XR state
        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        let adjustedSettings = { ...settings };

        if (!isWebGL2) {
            // Reduce quality for WebGL1
            adjustedSettings = {
                ...adjustedSettings,
                node_bloom_strength: settings.node_bloom_strength * 0.8,
                node_bloom_radius: settings.node_bloom_radius * 0.7,
                edge_bloom_strength: settings.edge_bloom_strength * 0.8,
                edge_bloom_radius: settings.edge_bloom_radius * 0.7,
                environment_bloom_strength: settings.environment_bloom_strength * 0.8,
                environment_bloom_radius: settings.environment_bloom_radius * 0.7
            };
        }

        if (this.isXRActive) {
            // Adjust bloom for XR
            adjustedSettings = {
                ...adjustedSettings,
                node_bloom_strength: adjustedSettings.node_bloom_strength * 1.2,
                node_bloom_radius: adjustedSettings.node_bloom_radius * 0.8,
                edge_bloom_strength: adjustedSettings.edge_bloom_strength * 1.2,
                edge_bloom_radius: adjustedSettings.edge_bloom_radius * 0.8
            };
        }

        const layers = [
            {
                layer: LAYERS.BLOOM,
                settings: {
                    strength: adjustedSettings.node_bloom_strength,
                    radius: adjustedSettings.node_bloom_radius,
                    threshold: adjustedSettings.node_bloom_threshold
                }
            },
            {
                layer: LAYERS.HOLOGRAM,
                settings: {
                    strength: adjustedSettings.environment_bloom_strength,
                    radius: adjustedSettings.environment_bloom_radius,
                    threshold: adjustedSettings.environment_bloom_threshold
                }
            },
            {
                layer: LAYERS.EDGE,
                settings: {
                    strength: adjustedSettings.edge_bloom_strength,
                    radius: adjustedSettings.edge_bloom_radius,
                    threshold: adjustedSettings.edge_bloom_threshold
                }
            }
        ];

        try {
            // Set renderer color space based on WebGL version
            this.renderer.outputColorSpace = isWebGL2 ? 
                THREE.LinearSRGBColorSpace : 
                THREE.SRGBColorSpace;

            // Create composers for both regular and XR rendering
            this.createComposers(layers, false); // Regular composers
            if (this.isXRActive) {
                this.createComposers(layers, true); // XR composers
            }

            this.initialized = true;
        } catch (error) {
            console.error('Error initializing bloom effect:', error);
            this.dispose();
        }
    }

    updateSettings(settings) {
        if (!this.initialized || !settings) return;

        try {
            const layers = [
                {
                    layer: LAYERS.BLOOM,
                    settings: {
                        strength: settings.node_bloom_strength,
                        radius: settings.node_bloom_radius,
                        threshold: settings.node_bloom_threshold
                    }
                },
                {
                    layer: LAYERS.HOLOGRAM,
                    settings: {
                        strength: settings.environment_bloom_strength,
                        radius: settings.environment_bloom_radius,
                        threshold: settings.environment_bloom_threshold
                    }
                },
                {
                    layer: LAYERS.EDGE,
                    settings: {
                        strength: settings.edge_bloom_strength,
                        radius: settings.edge_bloom_radius,
                        threshold: settings.edge_bloom_threshold
                    }
                }
            ];

            // Update bloom passes in composers
            layers.forEach(({ layer, settings }) => {
                const composer = this.composers.get(layer.toString());
                if (composer) {
                    const bloomPass = composer.passes.find(pass => pass instanceof UnrealBloomPass);
                    if (bloomPass) {
                        bloomPass.strength = settings.strength;
                        bloomPass.radius = settings.radius;
                        bloomPass.threshold = settings.threshold;
                    }
                }

                // Update XR composers if active
                if (this.isXRActive) {
                    const xrComposer = this.composers.get(`xr_${layer}`);
                    if (xrComposer) {
                        const bloomPass = xrComposer.passes.find(pass => pass instanceof UnrealBloomPass);
                        if (bloomPass) {
                            bloomPass.strength = settings.strength * 1.2; // Adjust for XR
                            bloomPass.radius = settings.radius * 0.8; // Adjust for XR
                            bloomPass.threshold = settings.threshold;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error updating bloom settings:', error);
        }
    }

    createComposers(layers, isXR) {
        const targets = isXR ? this.xrRenderTargets : this.renderTargets;
        const composerPrefix = isXR ? 'xr_' : '';

        // Create base composer
        const baseComposer = new EffectComposer(this.renderer, targets.get('base'));
        const baseRenderPass = new RenderPass(this.scene, this.camera);
        baseRenderPass.clear = true;
        baseComposer.addPass(baseRenderPass);
        this.composers.set(`${composerPrefix}base`, baseComposer);

        // Create bloom composers for each layer
        layers.forEach(({ layer, settings }) => {
            const composer = new EffectComposer(this.renderer, targets.get(layer));
            composer.renderToScreen = false;
            
            const renderPass = new RenderPass(this.scene, this.camera);
            renderPass.clear = true;
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(
                    targets.get(layer).width,
                    targets.get(layer).height
                ),
                settings.strength,
                settings.radius,
                settings.threshold
            );
            
            bloomPass.highQualityBloom = this.renderer.capabilities.isWebGL2;
            bloomPass.gammaCorrectionInShader = this.renderer.capabilities.isWebGL2;
            
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            
            this.composers.set(`${composerPrefix}${layer}`, composer);
        });
    }

    render(currentCamera) {
        if (!this.initialized || !currentCamera) return;

        try {
            const isXRFrame = this.renderer.xr.isPresenting;
            const composerPrefix = isXRFrame ? 'xr_' : '';
            
            // Store original camera layers
            const originalLayerMask = currentCamera.layers.mask;

            // Render base scene first
            currentCamera.layers.set(LAYERS.NORMAL_LAYER);
            this.composers.get(`${composerPrefix}base`).render();

            // Render bloom layers
            this.composers.forEach((composer, key) => {
                if (key.startsWith(composerPrefix) && !key.endsWith('base')) {
                    const layer = parseInt(key.split('_').pop());
                    currentCamera.layers.set(layer);
                    composer.render();
                }
            });

            // Restore camera layers
            currentCamera.layers.mask = originalLayerMask;
        } catch (error) {
            console.error('Error rendering bloom effect:', error);
        }
    }

    resize(width, height) {
        if (!this.initialized) return;

        const pixelRatio = this.renderer.getPixelRatio();
        const actualWidth = Math.floor(width * pixelRatio);
        const actualHeight = Math.floor(height * pixelRatio);

        // Resize regular render targets and composers
        this.renderTargets.forEach(target => {
            if (target && target.setSize) {
                target.setSize(actualWidth, actualHeight);
            }
        });
        
        this.composers.forEach((composer, key) => {
            if (!key.startsWith('xr_') && composer && composer.setSize) {
                composer.setSize(actualWidth, actualHeight);
            }
        });

        // Don't resize XR targets - they're managed by the XR system
    }

    dispose() {
        // Remove event listeners
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);

        // Dispose render targets
        this.renderTargets.forEach(target => {
            if (target && target.dispose) target.dispose();
        });
        
        this.xrRenderTargets.forEach(target => {
            if (target && target.dispose) target.dispose();
        });
        
        // Dispose composers
        this.composers.forEach(composer => {
            if (composer && composer.dispose) composer.dispose();
        });
        
        // Reset renderer state
        if (this.renderer) {
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        // Clear collections
        this.renderTargets.clear();
        this.xrRenderTargets.clear();
        this.composers.clear();
        this.initialized = false;
        this.isXRActive = false;
    }

    getRenderTargets() {
        if (!this.initialized) return null;
        return this.isXRActive ? this.xrRenderTargets : this.renderTargets;
    }
}

----
visualization/effects/CompositionEffect.js
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { LAYERS } from '../layerManager.js';
import { visualizationSettings } from '../../services/visualizationSettings.js';

export class CompositionEffect {
    constructor(renderer) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to CompositionEffect');
        }
        this.renderer = renderer;
        this.composer = null;
        this.xrComposer = null;
        this.initialized = false;
        this.isXRActive = false;

        // Store original renderer state
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();

        // Bind XR session handlers
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);

        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }

    handleXRSessionStart() {
        this.isXRActive = true;
        if (this.initialized) {
            // Create XR-specific composer if needed
            this.createXRComposer();
        }
    }

    handleXRSessionEnd() {
        this.isXRActive = false;
        if (this.xrComposer) {
            this.xrComposer.dispose();
            this.xrComposer = null;
        }
    }

    createRenderTarget(isXR = false) {
        let width, height;
        
        if (isXR && this.renderer.xr.getSession()) {
            const glProperties = this.renderer.properties.get(this.renderer.xr.getSession());
            const renderWidth = glProperties?.renderWidth || window.innerWidth * 2;
            const renderHeight = glProperties?.renderHeight || window.innerHeight;
            width = renderWidth;
            height = renderHeight;
        } else {
            const pixelRatio = this.renderer.getPixelRatio();
            width = Math.floor(window.innerWidth * pixelRatio);
            height = Math.floor(window.innerHeight * pixelRatio);
        }

        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        return new THREE.WebGLRenderTarget(
            width,
            height,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType,
                colorSpace: isWebGL2 ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace,
                stencilBuffer: false,
                depthBuffer: true,
                samples: isWebGL2 ? 4 : 0
            }
        );
    }

    createCompositionShader(isXR = false) {
        // Get bloom settings from server
        const settings = visualizationSettings.getBloomSettings();
        if (!settings) {
            console.warn('No bloom settings available, using defaults');
        }

        return {
            uniforms: {
                baseTexture: { value: null },
                bloomTexture0: { value: null },
                bloomTexture1: { value: null },
                bloomTexture2: { value: null },
                bloomStrength0: { value: settings?.node_bloom_strength || 1.5 },
                bloomStrength1: { value: settings?.environment_bloom_strength || 1.2 },
                bloomStrength2: { value: settings?.edge_bloom_strength || 0.8 },
                exposure: { value: isXR ? 1.0 : 1.2 },
                gamma: { value: 2.2 },
                saturation: { value: isXR ? 1.1 : 1.2 },
                isXR: { value: isXR ? 1.0 : 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D baseTexture;
                uniform sampler2D bloomTexture0;
                uniform sampler2D bloomTexture1;
                uniform sampler2D bloomTexture2;
                uniform float bloomStrength0;
                uniform float bloomStrength1;
                uniform float bloomStrength2;
                uniform float exposure;
                uniform float gamma;
                uniform float saturation;
                uniform float isXR;
                
                varying vec2 vUv;

                vec3 adjustSaturation(vec3 color, float saturation) {
                    float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
                    return mix(vec3(luminance), color, saturation);
                }

                vec3 toneMap(vec3 color) {
                    // ACES filmic tone mapping
                    float a = 2.51;
                    float b = 0.03;
                    float c = 2.43;
                    float d = 0.59;
                    float e = 0.14;
                    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
                }

                void main() {
                    // Adjust UV for XR if needed
                    vec2 adjustedUV = vUv;
                    if (isXR > 0.5) {
                        // Handle stereo rendering
                        adjustedUV.x = adjustedUV.x * 0.5;
                        if (gl_FragCoord.x > gl_FragCoord.w) {
                            adjustedUV.x += 0.5;
                        }
                    }
                    
                    // Sample all textures in linear space
                    vec3 baseColor = texture2D(baseTexture, adjustedUV).rgb;
                    vec3 bloom0 = texture2D(bloomTexture0, adjustedUV).rgb * bloomStrength0;
                    vec3 bloom1 = texture2D(bloomTexture1, adjustedUV).rgb * bloomStrength1;
                    vec3 bloom2 = texture2D(bloomTexture2, adjustedUV).rgb * bloomStrength2;
                    
                    // Combine bloom layers
                    vec3 bloomSum = bloom0 + bloom1 + bloom2;
                    
                    // Add bloom to base color
                    vec3 hdrColor = baseColor + bloomSum;
                    
                    // Apply exposure
                    hdrColor *= exposure;
                    
                    // Tone mapping
                    vec3 color = toneMap(hdrColor);
                    
                    // Adjust saturation
                    color = adjustSaturation(color, saturation);
                    
                    // Gamma correction
                    color = pow(color, vec3(1.0 / gamma));
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };
    }

    createComposer(bloomRenderTargets, isXR = false) {
        const renderTarget = this.createRenderTarget(isXR);
        const composer = new EffectComposer(this.renderer, renderTarget);

        const shader = this.createCompositionShader(isXR);
        shader.uniforms.baseTexture.value = bloomRenderTargets.get('base').texture;
        shader.uniforms.bloomTexture0.value = bloomRenderTargets.get(LAYERS.BLOOM).texture;
        shader.uniforms.bloomTexture1.value = bloomRenderTargets.get(LAYERS.HOLOGRAM).texture;
        shader.uniforms.bloomTexture2.value = bloomRenderTargets.get(LAYERS.EDGE).texture;

        const finalPass = new ShaderPass(new THREE.ShaderMaterial(shader));
        finalPass.renderToScreen = true;
        finalPass.clear = false;
        composer.addPass(finalPass);

        return composer;
    }

    init(bloomRenderTargets) {
        try {
            if (this.initialized) {
                this.dispose();
            }

            if (!bloomRenderTargets) {
                throw new Error('No bloom render targets provided');
            }

            // Verify all required textures are available
            const requiredLayers = [LAYERS.BLOOM, LAYERS.HOLOGRAM, LAYERS.EDGE];
            requiredLayers.forEach(layer => {
                const target = bloomRenderTargets.get(layer);
                if (!target || !target.texture) {
                    throw new Error(`Missing bloom render target for layer ${layer}`);
                }
            });

            // Create regular composer
            this.composer = this.createComposer(bloomRenderTargets, false);

            // Create XR composer if in XR mode
            if (this.isXRActive) {
                this.createXRComposer(bloomRenderTargets);
            }

            this.initialized = true;
        } catch (error) {
            console.error('Error initializing composition effect:', error);
            this.dispose();
        }
    }

    updateSettings(bloomRenderTargets) {
        if (!this.initialized) return;

        try {
            const settings = visualizationSettings.getBloomSettings();
            if (!settings) return;

            // Update regular composer
            if (this.composer) {
                const finalPass = this.composer.passes[0];
                if (finalPass && finalPass.uniforms) {
                    finalPass.uniforms.bloomStrength0.value = settings.node_bloom_strength;
                    finalPass.uniforms.bloomStrength1.value = settings.environment_bloom_strength;
                    finalPass.uniforms.bloomStrength2.value = settings.edge_bloom_strength;
                }
            }

            // Update XR composer
            if (this.xrComposer) {
                const finalPass = this.xrComposer.passes[0];
                if (finalPass && finalPass.uniforms) {
                    finalPass.uniforms.bloomStrength0.value = settings.node_bloom_strength * 1.2;
                    finalPass.uniforms.bloomStrength1.value = settings.environment_bloom_strength * 1.2;
                    finalPass.uniforms.bloomStrength2.value = settings.edge_bloom_strength * 1.2;
                }
            }
        } catch (error) {
            console.error('Error updating composition settings:', error);
        }
    }

    createXRComposer(bloomRenderTargets) {
        if (!this.renderer.xr.getSession()) return;
        this.xrComposer = this.createComposer(bloomRenderTargets, true);
    }

    render(baseTexture) {
        if (!this.initialized) return;

        try {
            const activeComposer = this.isXRActive ? this.xrComposer : this.composer;
            if (!activeComposer) return;

            const finalPass = activeComposer.passes[0];
            if (finalPass && finalPass.uniforms) {
                finalPass.uniforms.baseTexture.value = baseTexture;
                activeComposer.render();
            }
        } catch (error) {
            console.error('Error rendering composition effect:', error);
        }
    }

    resize(width, height) {
        if (!this.initialized) return;

        try {
            const pixelRatio = this.renderer.getPixelRatio();
            const actualWidth = Math.floor(width * pixelRatio);
            const actualHeight = Math.floor(height * pixelRatio);
            
            // Only resize non-XR composer
            if (this.composer) {
                this.composer.setSize(actualWidth, actualHeight);
            }
        } catch (error) {
            console.error('Error resizing composition effect:', error);
        }
    }

    dispose() {
        // Remove event listeners
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);

        // Dispose composers
        if (this.composer) {
            this.composer.dispose();
            this.composer = null;
        }
        
        if (this.xrComposer) {
            this.xrComposer.dispose();
            this.xrComposer = null;
        }
        
        if (this.renderer) {
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        this.initialized = false;
        this.isXRActive = false;
    }
}

----
stores/binaryUpdate.ts
import { defineStore } from 'pinia'
import type { PositionUpdate } from '../types/websocket'
import { POSITION_SCALE, VELOCITY_SCALE } from '../constants/websocket'

interface BinaryUpdateState {
  positions: Map<string, PositionUpdate>
  lastUpdateTime: number
  isInitialLayout: boolean
  pendingUpdates: PositionUpdate[]
  batchSize: number
}

/**
 * Store for handling transient binary position/velocity updates
 * These updates are frequent and superseded by full mesh updates
 */
export const useBinaryUpdateStore = defineStore('binaryUpdate', {
  state: (): BinaryUpdateState => ({
    positions: new Map(),
    lastUpdateTime: 0,
    isInitialLayout: false,
    pendingUpdates: [],
    batchSize: 100 // Default batch size
  }),

  getters: {
    /**
     * Get latest position update for a node
     */
    getNodePosition: (state) => (nodeId: string): PositionUpdate | undefined => {
      return state.positions.get(nodeId)
    },

    /**
     * Get all current position updates
     */
    getAllPositions: (state): PositionUpdate[] => {
      return Array.from(state.positions.values())
    },

    /**
     * Check if this is initial layout data
     */
    isInitial: (state): boolean => state.isInitialLayout,

    /**
     * Get number of pending updates
     */
    pendingUpdateCount: (state): number => state.pendingUpdates.length,

    /**
     * Get current batch size
     */
    getBatchSize: (state): number => state.batchSize
  },

  actions: {
    /**
     * Process a single position update
     */
    processUpdate(pos: PositionUpdate): void {
      if (!pos.id) {
        console.warn('Received position update without node ID')
        return
      }

      // Enhanced debug logging for position updates
      console.debug('Processing position update:', {
        nodeId: pos.id,
        oldPosition: this.positions.get(pos.id),
        newPosition: {
          x: pos.x,
          y: pos.y,
          z: pos.z,
          vx: pos.vx,
          vy: pos.vy,
          vz: pos.vz
        },
        timestamp: new Date().toISOString()
      })

      // Store update with node ID - no scaling needed as values are already scaled
      this.positions.set(pos.id, {
        id: pos.id,
        x: pos.x,
        y: pos.y,
        z: pos.z,
        vx: pos.vx,
        vy: pos.vy,
        vz: pos.vz
      })
    },

    /**
     * Update positions from binary WebSocket message
     */
    updatePositions(positions: PositionUpdate[], isInitial: boolean) {
      // Enhanced debug logging for batch updates
      console.debug('Starting batch position update:', {
        updateCount: positions.length,
        isInitial,
        currentPositionsCount: this.positions.size,
        pendingUpdatesCount: this.pendingUpdates.length,
        timestamp: new Date().toISOString()
      })

      // Clear previous positions if this is initial layout
      if (isInitial) {
        console.debug('Clearing previous positions for initial layout')
        this.positions.clear()
        this.pendingUpdates = []
      }

      // Process any pending updates first
      if (this.pendingUpdates.length > 0) {
        console.debug(`Processing ${this.pendingUpdates.length} pending updates`)
        this.pendingUpdates.forEach(pos => this.processUpdate(pos))
        this.pendingUpdates = []
      }

      // Process new updates
      positions.forEach(pos => this.processUpdate(pos))

      // Update state
      this.lastUpdateTime = Date.now()
      this.isInitialLayout = isInitial

      // Enhanced debug logging for update completion
      console.debug('Batch position update completed:', {
        finalPositionsCount: this.positions.size,
        isInitial,
        samplePositions: Array.from(this.positions.entries())
          .slice(0, 3)
          .map(([id, pos]) => ({
            id,
            position: {
              x: pos.x,
              y: pos.y,
              z: pos.z
            },
            velocity: {
              vx: pos.vx,
              vy: pos.vy,
              vz: pos.vz
            }
          })),
        timestamp: new Date().toISOString()
      })
    },

    /**
     * Set batch size for processing updates
     */
    setBatchSize(size: number) {
      const oldSize = this.batchSize
      this.batchSize = Math.max(1, Math.min(1000, size)) // Clamp between 1-1000
      console.debug('Batch size updated:', {
        oldSize,
        newSize: this.batchSize,
        timestamp: new Date().toISOString()
      })
    },

    /**
     * Clear all position data
     * Called when receiving full mesh update or on cleanup
     */
    clear() {
      console.debug('Clearing binary update store:', {
        clearedPositions: this.positions.size,
        clearedPending: this.pendingUpdates.length,
        timestamp: new Date().toISOString()
      })
      this.positions.clear()
      this.pendingUpdates = []
      this.lastUpdateTime = 0
      this.isInitialLayout = false
    }
  }
})

----
stores/visualization.ts
import { defineStore } from 'pinia'
import type { 
  Node, 
  Edge, 
  GraphNode,
  GraphEdge,
  GraphData,
  FisheyeSettings as CoreFisheyeSettings, 
  PhysicsSettings as CorePhysicsSettings,
  MaterialSettings as CoreMaterialSettings,
  BloomSettings as CoreBloomSettings
} from '../types/core'
import type {
  VisualizationConfig,
  BloomConfig,
  FisheyeConfig
} from '../types/components'
import {
  DEFAULT_VISUALIZATION_CONFIG,
  DEFAULT_BLOOM_CONFIG,
  DEFAULT_FISHEYE_CONFIG
} from '../types/components'

interface VisualizationState {
  nodes: Node[]
  edges: Edge[]
  graphData: GraphData | null
  selectedNode: Node | null
  metadata: Record<string, any>
  visualConfig: VisualizationConfig
  bloomConfig: BloomConfig
  fisheyeConfig: FisheyeConfig
}

export const useVisualizationStore = defineStore('visualization', {
  state: (): VisualizationState => ({
    nodes: [],
    edges: [],
    graphData: null,
    selectedNode: null,
    metadata: {},
    visualConfig: { ...DEFAULT_VISUALIZATION_CONFIG },
    bloomConfig: { ...DEFAULT_BLOOM_CONFIG },
    fisheyeConfig: { ...DEFAULT_FISHEYE_CONFIG }
  }),

  getters: {
    getNodeById: (state) => (id: string) => {
      return state.nodes.find(node => node.id === id)
    },

    getEdgesByNodeId: (state) => (nodeId: string) => {
      return state.edges.filter(edge => 
        edge.source === nodeId || edge.target === nodeId
      )
    },

    getGraphData: (state): GraphData | null => state.graphData,
    getVisualizationSettings: (state): VisualizationConfig => state.visualConfig,
    getBloomSettings: (state): BloomConfig => state.bloomConfig,
    getFisheyeSettings: (state): FisheyeConfig => state.fisheyeConfig,
  },

  actions: {
    setGraphData(nodes: Node[], edges: Edge[], metadata: Record<string, any> = {}) {
      console.debug('Setting graph data:', {
        nodeCount: nodes.length,
        edgeCount: edges.length,
        metadataKeys: Object.keys(metadata),
        timestamp: new Date().toISOString(),
        sampleNodes: nodes.slice(0, 3).map(n => ({
          id: n.id,
          position: n.position,
          hasPosition: !!n.position
        }))
      })

      // Convert to graph data structure
      const graphNodes = nodes.map(node => ({
        ...node,
        edges: [],
        weight: node.weight || 1
      })) as GraphNode[]

      // Create node lookup for edge processing
      const nodeLookup = new Map<string, GraphNode>()
      graphNodes.forEach(node => nodeLookup.set(node.id, node))

      console.debug('Node lookup created:', {
        lookupSize: nodeLookup.size,
        sampleEntries: Array.from(nodeLookup.entries()).slice(0, 3)
      })

      // Convert edges and link to nodes
      const graphEdges = edges.map(edge => {
        const sourceNode = nodeLookup.get(edge.source)
        const targetNode = nodeLookup.get(edge.target)
        if (!sourceNode || !targetNode) {
          console.warn('Edge references missing node:', {
            edge,
            hasSource: !!sourceNode,
            hasTarget: !!targetNode,
            timestamp: new Date().toISOString()
          })
          return null
        }
        const graphEdge: GraphEdge = {
          ...edge,
          sourceNode,
          targetNode,
          directed: edge.directed || false
        }
        sourceNode.edges.push(graphEdge)
        targetNode.edges.push(graphEdge)
        return graphEdge
      }).filter((edge): edge is GraphEdge => edge !== null)

      console.debug('Graph data transformation complete:', {
        originalNodes: nodes.length,
        originalEdges: edges.length,
        transformedNodes: graphNodes.length,
        transformedEdges: graphEdges.length,
        sampleGraphNode: graphNodes[0] ? {
          id: graphNodes[0].id,
          edgeCount: graphNodes[0].edges.length,
          position: graphNodes[0].position,
          hasPosition: !!graphNodes[0].position
        } : null,
        timestamp: new Date().toISOString()
      })

      this.nodes = nodes
      this.edges = edges
      this.metadata = metadata
      this.graphData = {
        nodes: graphNodes,
        edges: graphEdges,
        metadata
      }
    },

    updateNode(nodeId: string, updates: Partial<Node>) {
      console.debug('Updating node:', {
        nodeId,
        updates,
        hasPosition: !!updates.position,
        timestamp: new Date().toISOString()
      })

      const index = this.nodes.findIndex(n => n.id === nodeId)
      if (index !== -1) {
        this.nodes[index] = { ...this.nodes[index], ...updates }
        
        // Update graph data if it exists
        if (this.graphData) {
          const graphNodeIndex = this.graphData.nodes.findIndex(n => n.id === nodeId)
          if (graphNodeIndex !== -1) {
            const graphNode = this.graphData.nodes[graphNodeIndex]
            this.graphData.nodes[graphNodeIndex] = {
              ...graphNode,
              ...updates,
              edges: graphNode.edges // Preserve edges array
            } as GraphNode

            console.debug('Graph node updated:', {
              nodeId,
              position: updates.position,
              edgeCount: graphNode.edges.length,
              timestamp: new Date().toISOString()
            })
          }
        }
      } else {
        console.warn('Node not found for update:', {
          nodeId,
          timestamp: new Date().toISOString()
        })
      }
    },

    updateNodePositions(updates: { id: string; position: [number, number, number]; velocity?: [number, number, number] }[]) {
      console.debug('Batch updating node positions:', {
        updateCount: updates.length,
        timestamp: new Date().toISOString(),
        sampleUpdates: updates.slice(0, 3)
      })

      let updatedCount = 0
      let skippedCount = 0

      updates.forEach(update => {
        const node = this.nodes.find(n => n.id === update.id)
        if (node) {
          // Update position and velocity directly (already scaled)
          node.position = update.position
          if (update.velocity) {
            node.velocity = update.velocity
          }

          // Update graph data if it exists
          if (this.graphData) {
            const graphNode = this.graphData.nodes.find(n => n.id === update.id)
            if (graphNode) {
              graphNode.position = node.position
              if (update.velocity) {
                graphNode.velocity = node.velocity
              }
              updatedCount++
            }
          }
        } else {
          skippedCount++
        }
      })

      console.debug('Node position updates complete:', {
        totalUpdates: updates.length,
        successfulUpdates: updatedCount,
        skippedUpdates: skippedCount,
        timestamp: new Date().toISOString()
      })
    },

    updateVisualizationSettings(settings: Partial<VisualizationConfig>) {
      console.debug('Updating visualization settings:', {
        oldSettings: this.visualConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      })
      this.visualConfig = {
        ...this.visualConfig,
        ...settings
      }
    },

    updateBloomSettings(settings: Partial<BloomConfig>) {
      console.debug('Updating bloom settings:', {
        oldSettings: this.bloomConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      })
      this.bloomConfig = {
        ...this.bloomConfig,
        ...settings
      }
    },

    updateFisheyeSettings(settings: Partial<FisheyeConfig>) {
      console.debug('Updating fisheye settings:', {
        oldSettings: this.fisheyeConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      })
      
      if ('focusPoint' in settings) {
        const [focus_x, focus_y, focus_z] = settings.focusPoint as [number, number, number]
        this.fisheyeConfig = {
          ...this.fisheyeConfig,
          ...settings,
          focus_x,
          focus_y,
          focus_z
        }
      } else {
        this.fisheyeConfig = {
          ...this.fisheyeConfig,
          ...settings
        }
      }
    },

    clear() {
      console.debug('Clearing visualization store:', {
        nodeCount: this.nodes.length,
        edgeCount: this.edges.length,
        hasGraphData: !!this.graphData,
        timestamp: new Date().toISOString()
      })
      
      this.nodes = []
      this.edges = []
      this.graphData = null
      this.selectedNode = null
      this.metadata = {}
      
      // Reset settings to defaults
      this.visualConfig = { ...DEFAULT_VISUALIZATION_CONFIG }
      this.bloomConfig = { ...DEFAULT_BLOOM_CONFIG }
      this.fisheyeConfig = { ...DEFAULT_FISHEYE_CONFIG }
    }
  }
})

----
stores/settings.ts
import { defineStore } from 'pinia';
import type { 
  VisualizationConfig, 
  BloomConfig, 
  FisheyeConfig 
} from '../types/components';
import { 
  DEFAULT_VISUALIZATION_CONFIG,
  DEFAULT_BLOOM_CONFIG,
  DEFAULT_FISHEYE_CONFIG
} from '../types/components';

interface SettingsState {
  visualization: VisualizationConfig;
  bloom: BloomConfig;
  fisheye: FisheyeConfig;
  isDirty: boolean;
}

export const useSettingsStore = defineStore('settings', {
  state: (): SettingsState => ({
    visualization: { ...DEFAULT_VISUALIZATION_CONFIG },
    bloom: { ...DEFAULT_BLOOM_CONFIG },
    fisheye: { ...DEFAULT_FISHEYE_CONFIG },
    isDirty: false
  }),

  getters: {
    getVisualizationSettings: (state) => state.visualization,
    getBloomSettings: (state) => state.bloom,
    getFisheyeSettings: (state) => state.fisheye,
    hasUnsavedChanges: (state) => state.isDirty
  },

  actions: {
    updateVisualizationSettings(settings: Partial<VisualizationConfig>) {
      this.visualization = {
        ...this.visualization,
        ...settings
      };
      this.isDirty = true;
    },

    updateBloomSettings(settings: Partial<BloomConfig>) {
      this.bloom = {
        ...this.bloom,
        ...settings
      };
      this.isDirty = true;
    },

    updateFisheyeSettings(settings: Partial<FisheyeConfig>) {
      this.fisheye = {
        ...this.fisheye,
        ...settings
      };
      this.isDirty = true;
    },

    applyServerSettings(settings: {
      visualization?: Partial<VisualizationConfig>;
      bloom?: Partial<BloomConfig>;
      fisheye?: Partial<FisheyeConfig>;
    }) {
      if (settings.visualization) {
        this.visualization = {
          ...this.visualization,
          ...settings.visualization
        };
      }
      if (settings.bloom) {
        this.bloom = {
          ...this.bloom,
          ...settings.bloom
        };
      }
      if (settings.fisheye) {
        this.fisheye = {
          ...this.fisheye,
          ...settings.fisheye
        };
      }
      this.isDirty = false;
    },

    resetToDefaults() {
      this.visualization = { ...DEFAULT_VISUALIZATION_CONFIG };
      this.bloom = { ...DEFAULT_BLOOM_CONFIG };
      this.fisheye = { ...DEFAULT_FISHEYE_CONFIG };
      this.isDirty = true;
    },

    markSaved() {
      this.isDirty = false;
    }
  }
});

----
stores/websocket.ts
import { defineStore } from 'pinia'
import WebsocketService from '../services/websocketService'
import type { BaseMessage, ErrorMessage } from '../types/websocket'

interface WebSocketState {
  connected: boolean
  error: string | null
  service: WebsocketService | null
  lastMessageTime: number
  messageCount: number
  queueSize: number
}

export const useWebSocketStore = defineStore('websocket', {
  state: (): WebSocketState => ({
    connected: false,
    error: null,
    service: null,
    lastMessageTime: 0,
    messageCount: 0,
    queueSize: 0
  }),

  actions: {
    async initialize() {
      if (this.service) {
        console.log('WebSocket service already initialized')
        return
      }

      this.service = new WebsocketService()
      
      // Set up event handlers
      this.service.on('open', () => {
        this.connected = true
        this.error = null
      })

      this.service.on('close', () => {
        this.connected = false
      })

      this.service.on('error', (error: ErrorMessage) => {
        this.error = error.message || 'Unknown error'
      })

      // Connect to server
      try {
        await this.service.connect()
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'Unknown error'
        throw error
      }
    },

    setConnected(value: boolean) {
      this.connected = value
    },

    setError(message: string) {
      this.error = message
    },

    handleMessage(message: BaseMessage) {
      // Handle incoming messages
      if (message.type === 'error') {
        this.error = (message as ErrorMessage).message
      }
    },

    send(data: any) {
      if (!this.service) {
        console.error('Cannot send message: WebSocket service not initialized')
        return
      }
      this.service.send(data)
    },

    requestInitialData() {
      this.send({ type: 'getInitialData' })
    },

    async reconnect() {
      if (this.service) {
        this.service.cleanup()
        this.service = null
      }
      await this.initialize()
    },

    cleanup() {
      if (this.service) {
        this.service.cleanup()
        this.service = null
      }
      this.connected = false
      this.error = null
      this.lastMessageTime = 0
      this.messageCount = 0
      this.queueSize = 0
    }
  }
})

--END--