The following text represents a project with code. The structure of the text consists of sections beginning with ----, followed by a single line containing the file path and file name, and then a variable number of lines containing the file contents. The text representing the project ends when the symbols --END-- are encountered. Any further text beyond --END-- is meant to be interpreted as instructions using the aforementioned project as context.
----
config.rs
use serde::{Deserialize, Serialize};
use config::{ConfigBuilder, ConfigError, Environment, File};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Settings {
    pub debug_mode: bool,
    pub debug: DebugSettings,
    pub prompt: String,
    pub network: NetworkSettings,
    pub security: SecuritySettings,
    pub github: GitHubSettings,
    pub ragflow: RagFlowSettings,
    pub perplexity: PerplexitySettings,
    pub openai: OpenAISettings,
    pub default: DefaultSettings,
    pub visualization: VisualizationSettings,
    pub bloom: BloomSettings,
    pub fisheye: FisheyeSettings,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DebugSettings {
    pub enable_websocket_debug: bool,
    pub enable_data_debug: bool,
    pub log_binary_headers: bool,
    pub log_full_json: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct GitHubSettings {
    #[serde(default = "default_token")]
    pub token: String,
    
    #[serde(default = "default_owner")]
    pub owner: String,
    
    #[serde(default = "default_repo")]
    pub repo: String,
    
    #[serde(default = "default_path")]
    pub base_path: String,
    
    #[serde(default = "default_rate_limit")]
    pub rate_limit: bool,
}

fn default_token() -> String { "".to_string() }
fn default_owner() -> String { "".to_string() }
fn default_repo() -> String { "".to_string() }
fn default_path() -> String { "".to_string() }
fn default_rate_limit() -> bool { true }

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let builder = ConfigBuilder::<config::builder::DefaultState>::default();
        let config = builder
            .add_source(File::with_name("settings.toml"))
            .add_source(
                Environment::default()
                    .separator("_")
                    .try_parsing(true)
            )
            .build()?;

        let mut settings: Settings = config.try_deserialize()?;
        
        if let Ok(token) = std::env::var("GITHUB_TOKEN") {
            settings.github.token = token;
        }
        if let Ok(owner) = std::env::var("GITHUB_OWNER") {
            settings.github.owner = owner;
        }
        if let Ok(repo) = std::env::var("GITHUB_REPO") {
            settings.github.repo = repo;
        }
        if let Ok(path) = std::env::var("GITHUB_PATH") {
            settings.github.base_path = path;
        }

        Ok(settings)
    }

    pub fn from_env() -> Result<Self, ConfigError> {
        let builder = ConfigBuilder::<config::builder::DefaultState>::default();
        let config = builder
            .add_source(
                Environment::default()
                    .separator("_")
                    .try_parsing(true)
            )
            .build()?;

        let mut settings: Settings = config.try_deserialize()?;
        
        if let Ok(token) = std::env::var("GITHUB_TOKEN") {
            settings.github.token = token;
        }
        if let Ok(owner) = std::env::var("GITHUB_OWNER") {
            settings.github.owner = owner;
        }
        if let Ok(repo) = std::env::var("GITHUB_REPO") {
            settings.github.repo = repo;
        }
        if let Ok(path) = std::env::var("GITHUB_PATH") {
            settings.github.base_path = path;
        }

        Ok(settings)
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NetworkSettings {
    pub domain: String,
    pub port: u16,
    pub bind_address: String,
    pub enable_tls: bool,
    pub min_tls_version: String,
    pub enable_http2: bool,
    pub max_request_size: usize,
    pub enable_rate_limiting: bool,
    pub rate_limit_requests: u32,
    pub rate_limit_window: u32,
    pub tunnel_id: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SecuritySettings {
    pub enable_cors: bool,
    pub allowed_origins: Vec<String>,
    pub enable_csrf: bool,
    pub csrf_token_timeout: u32,
    pub session_timeout: u32,
    pub cookie_secure: bool,
    pub cookie_httponly: bool,
    pub cookie_samesite: String,
    pub enable_security_headers: bool,
    pub enable_request_validation: bool,
    pub enable_audit_logging: bool,
    pub audit_log_path: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RagFlowSettings {
    pub api_key: String,
    pub base_url: String,
    pub timeout: u64,
    pub max_retries: u32,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PerplexitySettings {
    pub api_key: String,
    pub model: String,
    pub api_url: String,
    pub max_tokens: u32,
    pub temperature: f32,
    pub top_p: f32,
    pub presence_penalty: f32,
    pub frequency_penalty: f32,
    pub timeout: u64,
    pub rate_limit: u32,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct OpenAISettings {
    pub api_key: String,
    pub base_url: String,
    pub timeout: u64,
    pub rate_limit: u32,
    pub model: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DefaultSettings {
    pub max_concurrent_requests: usize,
    pub max_retries: u32,
    pub retry_delay: u64,
    pub api_client_timeout: u64,
    pub max_payload_size: usize,
    pub enable_request_logging: bool,
    pub enable_metrics: bool,
    pub metrics_port: u16,
    pub log_level: String,
    pub log_format: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct VisualizationSettings {
    pub node_color: String,
    pub edge_color: String,
    pub hologram_color: String,
    pub node_color_new: String,
    pub node_color_recent: String,
    pub node_color_medium: String,
    pub node_color_old: String,
    pub node_age_max_days: u32,
    pub node_color_core: String,
    pub node_color_secondary: String,
    pub node_color_default: String,
    pub min_node_size: f32,
    pub max_node_size: f32,
    pub hologram_scale: f32,
    pub hologram_opacity: f32,
    pub edge_opacity: f32,
    pub fog_density: f32,
    pub node_material_metalness: f32,
    pub node_material_roughness: f32,
    pub node_material_clearcoat: f32,
    pub node_material_clearcoat_roughness: f32,
    pub node_material_opacity: f32,
    pub node_emissive_min_intensity: f32,
    pub node_emissive_max_intensity: f32,
    pub label_font_size: u32,
    pub label_font_family: String,
    pub label_padding: u32,
    pub label_vertical_offset: f32,
    pub label_close_offset: f32,
    pub label_background_color: String,
    pub label_text_color: String,
    pub label_info_text_color: String,
    pub label_xr_font_size: u32,
    pub edge_weight_normalization: f32,
    pub edge_min_width: f32,
    pub edge_max_width: f32,
    pub geometry_min_segments: u32,
    pub geometry_max_segments: u32,
    pub geometry_segment_per_hyperlink: f32,
    pub click_emissive_boost: f32,
    pub click_feedback_duration: u32,
    pub force_directed_iterations: u32,
    pub force_directed_spring: f32,
    pub force_directed_repulsion: f32,
    pub force_directed_attraction: f32,
    pub force_directed_damping: f32,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BloomSettings {
    pub node_bloom_strength: f32,
    pub node_bloom_radius: f32,
    pub node_bloom_threshold: f32,
    pub edge_bloom_strength: f32,
    pub edge_bloom_radius: f32,
    pub edge_bloom_threshold: f32,
    pub environment_bloom_strength: f32,
    pub environment_bloom_radius: f32,
    pub environment_bloom_threshold: f32,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FisheyeSettings {
    pub enabled: bool,
    pub strength: f32,
    pub radius: f32,
    pub focus_x: f32,
    pub focus_y: f32,
    pub focus_z: f32,
}

----
main.rs
use actix_files::Files;
use actix_web::{web, App, HttpServer, middleware, HttpResponse, HttpRequest};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;
use tokio::time::{interval, Duration};
use dotenv::dotenv;
use std::error::Error as StdError;

use crate::app_state::AppState;
use crate::config::Settings;
use crate::handlers::{
    file_handler, 
    graph_handler, 
    ragflow_handler, 
    visualization_handler,
    perplexity_handler,
};
use crate::models::graph::GraphData;
use crate::services::file_service::{RealGitHubService, FileService};
use crate::services::perplexity_service::PerplexityService;
use crate::services::ragflow_service::{RAGFlowService, RAGFlowError};
use crate::services::speech_service::SpeechService;
use crate::services::graph_service::GraphService;
use crate::services::github_service::RealGitHubPRService;
use crate::utils::websocket_manager::WebSocketManager;
use crate::utils::gpu_compute::GPUCompute;

mod app_state;
mod config;
mod handlers;
mod models;
mod services;
mod utils;

#[derive(Debug)]
pub struct AppError(Box<dyn StdError + Send + Sync>);

impl From<Box<dyn StdError + Send + Sync>> for AppError {
    fn from(err: Box<dyn StdError + Send + Sync>) -> Self {
        AppError(err)
    }
}

impl From<RAGFlowError> for AppError {
    fn from(err: RAGFlowError) -> Self {
        AppError(Box::new(err))
    }
}

impl From<AppError> for std::io::Error {
    fn from(err: AppError) -> Self {
        std::io::Error::new(std::io::ErrorKind::Other, err.0.to_string())
    }
}

async fn initialize_cached_graph_data(app_state: &web::Data<AppState>) -> std::io::Result<()> {
    let metadata_map = match FileService::load_or_create_metadata() {
        Ok(map) => {
            log::debug!("Loaded existing metadata with {} entries", map.len());
            map
        },
        Err(e) => {
            log::error!("Failed to load metadata: {}", e);
            return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to load metadata: {}", e)));
        }
    };

    {
        let mut app_metadata = app_state.metadata.write().await;
        *app_metadata = metadata_map.clone();
    }

    match GraphService::build_graph_from_metadata(&metadata_map).await {
        Ok(graph_data) => {
            let mut graph = app_state.graph_service.graph_data.write().await;
            *graph = graph_data.clone();
            graph.metadata = metadata_map;
            
            log::debug!("Graph initialized with {} nodes and {} edges", 
                graph.nodes.len(), 
                graph.edges.len()
            );
            Ok(())
        },
        Err(e) => {
            log::error!("Failed to build graph from cache: {}", e);
            Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
        }
    }
}

async fn update_graph_periodically(app_state: web::Data<AppState>) {
    let mut interval = interval(Duration::from_secs(43200));

    loop {
        interval.tick().await;
        
        let mut metadata_map = match FileService::load_or_create_metadata() {
            Ok(map) => map,
            Err(e) => {
                log::error!("Failed to load metadata: {}", e);
                continue;
            }
        };

        match FileService::fetch_and_process_files(&*app_state.github_service, app_state.settings.clone(), &mut metadata_map).await {
            Ok(processed_files) => {
                if !processed_files.is_empty() {
                    log::debug!("Found {} updated files, updating graph", processed_files.len());

                    {
                        let mut app_metadata = app_state.metadata.write().await;
                        *app_metadata = metadata_map.clone();
                    }

                    let mut graph = app_state.graph_service.graph_data.write().await;
                    let old_positions: HashMap<String, (f32, f32, f32)> = graph.nodes.iter()
                        .map(|node| (node.id.clone(), (node.x, node.y, node.z)))
                        .collect();
                    
                    graph.metadata = metadata_map.clone();

                    if let Ok(mut new_graph) = GraphService::build_graph_from_metadata(&metadata_map).await {
                        for node in &mut new_graph.nodes {
                            if let Some(&(x, y, z)) = old_positions.get(&node.id) {
                                node.x = x;
                                node.y = y;
                                node.z = z;
                                node.position = Some([x, y, z]);
                            }
                        }
                        *graph = new_graph.clone();
                        drop(graph);

                        if let Some(ws_manager) = app_state.get_websocket_manager().await {
                            if let Err(e) = ws_manager.broadcast_graph_update(&new_graph).await {
                                log::error!("Failed to broadcast graph update: {}", e);
                            }
                        }
                    }
                }
            },
            Err(e) => log::error!("Failed to check for updates: {}", e)
        }
    }
}

async fn health_check() -> HttpResponse {
    HttpResponse::Ok().finish()
}

async fn test_speech_service(app_state: web::Data<AppState>) -> HttpResponse {
    if let Some(speech_service) = app_state.get_speech_service().await {
        match speech_service.send_message("Hello, OpenAI!".to_string()).await {
            Ok(_) => HttpResponse::Ok().body("Message sent successfully"),
            Err(e) => HttpResponse::InternalServerError().body(format!("Error: {}", e)),
        }
    } else {
        HttpResponse::ServiceUnavailable().body("Speech service not initialized")
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenv().ok();

    // Load settings first to get the log level
    let settings = match Settings::new() {
        Ok(s) => Arc::new(RwLock::new(s)),
        Err(e) => {
            eprintln!("Failed to load settings: {:?}", e);
            return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize settings: {:?}", e)));
        }
    };

    // Set log level from settings
    let log_level = {
        let settings_read = settings.read().await;
        settings_read.default.log_level.clone()
    };
    std::env::set_var("RUST_LOG", log_level);
    env_logger::init();

    log::debug!("Initializing services...");
    let github_service = {
        let settings_read = settings.read().await;
        Arc::new(RealGitHubService::new(
            settings_read.github.token.clone(),
            settings_read.github.owner.clone(),
            settings_read.github.repo.clone(),
            settings_read.github.base_path.clone(),
            settings.clone(),
        ).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?)
    };

    let github_pr_service = {
        let settings_read = settings.read().await;
        Arc::new(RealGitHubPRService::new(
            settings_read.github.token.clone(),
            settings_read.github.owner.clone(),
            settings_read.github.repo.clone(),
            settings_read.github.base_path.clone(),
        ).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?)
    };

    let perplexity_service = Arc::new(PerplexityService::new(settings.clone())
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?);
    
    let ragflow_service = Arc::new(RAGFlowService::new(settings.clone()).await
        .map_err(AppError::from)?);

    log::debug!("Creating RAGFlow conversation...");
    let ragflow_conversation_id = ragflow_service.create_conversation("default_user".to_string()).await
        .map_err(AppError::from)?;
    
    log::debug!("Initializing GPU compute...");
    let gpu_compute = match GPUCompute::new(&GraphData::default()).await {
        Ok(gpu) => {
            log::debug!("GPU initialization successful");
            Some(Arc::new(RwLock::new(gpu)))
        },
        Err(e) => {
            log::warn!("Failed to initialize GPU: {}. Falling back to CPU computations.", e);
            None
        }
    };

    let app_state = web::Data::new(AppState::new(
        settings.clone(),
        github_service,
        perplexity_service,
        ragflow_service,
        None,
        gpu_compute,
        ragflow_conversation_id,
        github_pr_service,
    ));

    log::debug!("Initializing graph with cached data...");
    if let Err(e) = initialize_cached_graph_data(&app_state).await {
        log::warn!("Failed to initialize from cache: {:?}, proceeding with empty graph", e);
    }

    let websocket_manager = {
        let settings_read = settings.read().await;
        Arc::new(WebSocketManager::new(
            settings_read.debug.enable_websocket_debug,
            app_state.clone(),
        ))
    };

    let speech_service = Arc::new(SpeechService::new(
        websocket_manager.clone(),
        settings.clone(),
    ));

    app_state.set_speech_service(speech_service).await;
    app_state.set_websocket_manager(websocket_manager.clone()).await;
    let websocket_data = web::Data::new(websocket_manager.clone());

    let update_state = app_state.clone();
    tokio::spawn(async move {
        update_graph_periodically(update_state).await;
    });

    let bind_address = "0.0.0.0:3000";
    log::debug!("Starting HTTP server on {}", bind_address);

    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .app_data(websocket_data.clone())
            .wrap(middleware::Logger::default())
            .route("/health", web::get().to(health_check))
            .service(
                web::scope("/api/files")
                    .route("/fetch", web::get().to(file_handler::fetch_and_process_files))
            )
            .service(
                web::scope("/api/graph")
                    .route("/data", web::get().to(graph_handler::get_graph_data))
            )
            .service(
                web::scope("/api/chat")
                    .route("/init", web::post().to(ragflow_handler::init_chat))
                    .route("/message", web::post().to(ragflow_handler::send_message))
                    .route("/history", web::get().to(ragflow_handler::get_chat_history))
            )
            .service(
                web::scope("/api/visualization")
                    .route("/settings", web::get().to(visualization_handler::get_visualization_settings))
            )
            .service(
                web::scope("/api/perplexity")
                    .service(perplexity_handler::handle_perplexity)
            )
            .route("/ws", web::get().to(|req: HttpRequest, stream: web::Payload, websocket_manager: web::Data<Arc<WebSocketManager>>| WebSocketManager::handle_websocket(req, stream, websocket_manager)))
            .route("/test_speech", web::get().to(test_speech_service))
            .service(
                Files::new("/", "/app/data/public/dist").index_file("index.html")
            )
    })
    .bind(bind_address)?
    .run()
    .await
}

----
app_state.rs
use crate::config::Settings;
use crate::models::metadata::MetadataStore;
use crate::services::file_service::GitHubService;
use crate::services::github_service::GitHubPRService;
use crate::services::graph_service::GraphService;
use crate::services::perplexity_service::PerplexityService;
use crate::services::ragflow_service::RAGFlowService;
use crate::services::speech_service::SpeechService;
use crate::utils::websocket_manager::WebSocketManager;
use crate::utils::gpu_compute::GPUCompute;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct AppState {
    pub settings: Arc<RwLock<Settings>>,
    pub metadata: Arc<RwLock<MetadataStore>>,
    pub github_service: Arc<dyn GitHubService + Send + Sync>,
    pub perplexity_service: Arc<PerplexityService>,
    pub ragflow_service: Arc<RAGFlowService>,
    pub speech_service: Arc<RwLock<Option<Arc<SpeechService>>>>,
    pub websocket_manager: Arc<RwLock<Option<Arc<WebSocketManager>>>>,
    pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
    pub ragflow_conversation_id: String,
    pub github_pr_service: Arc<dyn GitHubPRService + Send + Sync>,
    pub graph_service: Arc<GraphService>,
}

impl AppState {
    pub fn new(
        settings: Arc<RwLock<Settings>>,
        github_service: Arc<dyn GitHubService + Send + Sync>,
        perplexity_service: Arc<PerplexityService>,
        ragflow_service: Arc<RAGFlowService>,
        speech_service: Option<Arc<SpeechService>>,
        gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
        ragflow_conversation_id: String,
        github_pr_service: Arc<dyn GitHubPRService + Send + Sync>,
    ) -> Self {
        let graph_service = Arc::new(GraphService::new());
        let metadata = Arc::new(RwLock::new(MetadataStore::new()));
        let websocket_manager = Arc::new(RwLock::new(None));
        let speech_service = Arc::new(RwLock::new(speech_service));
        
        Self {
            settings,
            metadata,
            github_service,
            perplexity_service,
            ragflow_service,
            speech_service,
            websocket_manager,
            gpu_compute,
            ragflow_conversation_id,
            github_pr_service,
            graph_service,
        }
    }

    pub async fn set_websocket_manager(&self, manager: Arc<WebSocketManager>) {
        let mut ws_manager = self.websocket_manager.write().await;
        *ws_manager = Some(manager);
    }

    pub async fn get_websocket_manager(&self) -> Option<Arc<WebSocketManager>> {
        self.websocket_manager.read().await.clone()
    }

    pub async fn set_speech_service(&self, service: Arc<SpeechService>) {
        let mut speech_service = self.speech_service.write().await;
        *speech_service = Some(service);
    }

    pub async fn get_speech_service(&self) -> Option<Arc<SpeechService>> {
        self.speech_service.read().await.clone()
    }
}

----
generate_audio.py
import sys
import io
import wave
import numpy as np
from piper import PiperVoice

def generate_audio_stream(text):
    try:
        voice = PiperVoice.load("/app/piper/en_GB-alan-medium.onnx")
        audio = voice.synthesize(text)
        
        # Convert audio to WAV format
        with io.BytesIO() as wav_io:
            with wave.open(wav_io, 'wb') as wav_file:
                wav_file.setnchannels(1)  # mono
                wav_file.setsampwidth(2)  # 16-bit
                wav_file.setframerate(voice.config.sample_rate)
                wav_file.writeframes(audio.tobytes())
            
            wav_data = wav_io.getvalue()
        
        # Verify WAV header
        if wav_data[:4] != b'RIFF' or wav_data[8:12] != b'WAVE':
            raise ValueError("Invalid WAV header")
        
        # Write WAV data to stdout
        sys.stdout.buffer.write(wav_data)
        sys.stdout.buffer.flush()
    except Exception as e:
        print(f"Error generating audio: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    input_text = sys.stdin.read().strip()
    if input_text:
        generate_audio_stream(input_text)
    else:
        print("No input received", file=sys.stderr)
        sys.exit(1)

----
lib.rs
pub mod app_state;
pub mod config;
pub mod handlers;
pub mod models;
pub mod services;
pub mod utils;

pub use app_state::AppState;
pub use config::Settings;
pub use handlers::websocket_handlers::WebSocketSession;
pub use models::edge::Edge;
pub use models::graph::GraphData;
pub use models::metadata::{Metadata, MetadataStore};
pub use models::node::Node;
pub use models::position_update::PositionUpdate;
pub use models::simulation_params::SimulationParams;
pub use services::file_service::{FileService, GitHubService, GithubFileMetadata, ProcessedFile, RealGitHubService};
pub use services::github_service::{GitHubPRService, RealGitHubPRService};
pub use services::graph_service::GraphService;
pub use services::perplexity_service::PerplexityService;
pub use services::ragflow_service::RAGFlowService;
pub use services::speech_service::SpeechService;
pub use utils::websocket_manager::WebSocketManager;

----
generate_welcome_audio.py
import sys
from piper import PiperVoice

def generate_welcome_audio():
    voice = PiperVoice.load("/app/piper/en_GB-alan-medium.onnx")
    text = "Welcome to the WebXR Graph Visualization. Your virtual environment is now ready."
    audio = voice.synthesize(text)
    sys.stdout.buffer.write(audio)

if __name__ == "__main__":
    generate_welcome_audio()
----
utils/audio_processor.rs
use log::{info, error, warn, debug};
use serde_json::Value;
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};

pub struct AudioProcessor;

impl AudioProcessor {
    pub fn process_json_response(response_data: &[u8]) -> Result<(String, Vec<u8>), String> {
        // Parse the JSON response
        let json_response: Value = serde_json::from_slice(response_data)
            .map_err(|e| format!("Failed to parse JSON response: {}", e))?;
        
        // Log the entire JSON response at debug level
        debug!("Received JSON response: {}", serde_json::to_string_pretty(&json_response).unwrap_or_else(|_| "Unable to prettify JSON".to_string()));
        
        // Check if the response contains an error message
        if let Some(error_msg) = json_response["error"].as_str() {
            error!("Error in JSON response: {}", error_msg);
            return Err(format!("Error in JSON response: {}", error_msg));
        }

        // Extract the text answer with better error handling
        let answer = json_response["data"]["answer"]
            .as_str()
            .or_else(|| json_response["answer"].as_str())
            .ok_or_else(|| {
                error!("Text answer not found in JSON response");
                "Text answer not found in JSON response".to_string()
            })?
            .to_string();

        // Try to extract the audio data from different possible locations with detailed logging
        let audio_data = if let Some(audio) = json_response["data"]["audio"].as_str() {
            debug!("Found audio data in data.audio");
            BASE64.decode(audio).map_err(|e| format!("Failed to decode base64 audio data from data.audio: {}", e))?
        } else if let Some(audio) = json_response["audio"].as_str() {
            debug!("Found audio data in root.audio");
            BASE64.decode(audio).map_err(|e| format!("Failed to decode base64 audio data from root.audio: {}", e))?
        } else {
            // Log available paths in the JSON for debugging
            warn!("Audio data not found in JSON response. Available paths:");
            if let Some(obj) = json_response.as_object() {
                for (key, value) in obj {
                    warn!("- {}: {}", key, match value {
                        Value::Null => "null",
                        Value::Bool(_) => "boolean",
                        Value::Number(_) => "number",
                        Value::String(_) => "string",
                        Value::Array(_) => "array",
                        Value::Object(_) => "object",
                    });
                }
            }
            return Err("Audio data not found in JSON response".to_string());
        };
        
        info!("Successfully processed audio data: {} bytes", audio_data.len());
        
        // Validate WAV header
        if audio_data.len() >= 44 {
            debug!("WAV header: {:?}", &audio_data[..44]);
            
            if &audio_data[..4] != b"RIFF" || &audio_data[8..12] != b"WAVE" {
                error!("Invalid WAV header detected");
                return Err("Invalid WAV header".to_string());
            }
            
            // Extract and log WAV format information
            let channels = u16::from_le_bytes([audio_data[22], audio_data[23]]);
            let sample_rate = u32::from_le_bytes([audio_data[24], audio_data[25], audio_data[26], audio_data[27]]);
            let bits_per_sample = u16::from_le_bytes([audio_data[34], audio_data[35]]);
            
            debug!("WAV format: {} channels, {} Hz, {} bits per sample", 
                  channels, sample_rate, bits_per_sample);
        } else {
            error!("Audio data too short to contain WAV header: {} bytes", audio_data.len());
            return Err("Audio data too short".to_string());
        }
        
        Ok((answer, audio_data))
    }

    pub fn validate_wav_header(audio_data: &[u8]) -> Result<(), String> {
        if audio_data.len() < 44 {
            return Err("Audio data too short for WAV header".to_string());
        }

        if &audio_data[..4] != b"RIFF" {
            return Err("Missing RIFF header".to_string());
        }

        if &audio_data[8..12] != b"WAVE" {
            return Err("Missing WAVE format".to_string());
        }

        let channels = u16::from_le_bytes([audio_data[22], audio_data[23]]);
        let sample_rate = u32::from_le_bytes([audio_data[24], audio_data[25], audio_data[26], audio_data[27]]);
        let bits_per_sample = u16::from_le_bytes([audio_data[34], audio_data[35]]);

        debug!("Validated WAV format: {} channels, {} Hz, {} bits per sample",
              channels, sample_rate, bits_per_sample);

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_process_json_response_valid() {
        let test_wav = vec![
            b'R', b'I', b'F', b'F', // ChunkID
            0x24, 0x00, 0x00, 0x00, // ChunkSize
            b'W', b'A', b'V', b'E', // Format
            b'f', b'm', b't', b' ', // Subchunk1ID
            0x10, 0x00, 0x00, 0x00, // Subchunk1Size
            0x01, 0x00,             // AudioFormat (PCM)
            0x01, 0x00,             // NumChannels (Mono)
            0x44, 0xAC, 0x00, 0x00, // SampleRate (44100)
            0x88, 0x58, 0x01, 0x00, // ByteRate
            0x02, 0x00,             // BlockAlign
            0x10, 0x00,             // BitsPerSample (16)
            b'd', b'a', b't', b'a', // Subchunk2ID
            0x00, 0x00, 0x00, 0x00  // Subchunk2Size
        ];

        let json_data = json!({
            "data": {
                "answer": "Test answer",
                "audio": BASE64.encode(test_wav)
            }
        });

        let result = AudioProcessor::process_json_response(
            serde_json::to_vec(&json_data).unwrap().as_slice()
        );

        assert!(result.is_ok());
        let (answer, audio) = result.unwrap();
        assert_eq!(answer, "Test answer");
        assert_eq!(&audio[..4], b"RIFF");
    }

    #[test]
    fn test_process_json_response_invalid_wav() {
        let invalid_wav = vec![0x00; 44]; // Invalid WAV header
        let json_data = json!({
            "data": {
                "answer": "Test answer",
                "audio": BASE64.encode(invalid_wav)
            }
        });

        let result = AudioProcessor::process_json_response(
            serde_json::to_vec(&json_data).unwrap().as_slice()
        );

        assert!(result.is_err());
    }
}

----
utils/force_calculation.wgsl
// Node structure exactly matching Rust GPUNode memory layout (28 bytes total)
struct Node {
    x: f32, y: f32, z: f32,      // position (12 bytes)
    vx: f32, vy: f32, vz: f32,   // velocity (12 bytes)
    mass: u32,                    // mass in lower byte + flags + padding (4 bytes)
}

// Edge structure matching Rust GPUEdge layout
struct Edge {
    source: u32,      // 4 bytes
    target_idx: u32,  // 4 bytes (renamed from 'target' as it's a reserved keyword)
    weight: f32,      // 4 bytes
}

struct NodesBuffer {
    nodes: array<Node>,
}

struct EdgesBuffer {
    edges: array<Edge>,
}

// Matches Rust SimulationParams exactly
struct SimulationParams {
    iterations: u32,           // Range: 1-500
    spring_strength: f32,      // Range: 0.001-1.0
    repulsion_strength: f32,   // Range: 1.0-10000.0
    attraction_strength: f32,  // Range: 0.001-1.0
    damping: f32,             // Range: 0.5-0.95
    is_initial_layout: u32,   // bool converted to u32
    time_step: f32,           // Range: 0.1-1.0
    padding: u32,             // Explicit padding for alignment
}

@group(0) @binding(0) var<storage, read_write> nodes_buffer: NodesBuffer;
@group(0) @binding(1) var<storage, read> edges_buffer: EdgesBuffer;
@group(0) @binding(2) var<uniform> params: SimulationParams;

// Physics constants - aligned with settings.toml
const WORKGROUP_SIZE: u32 = 256;
const MAX_FORCE: f32 = 100.0;          // Increased for stronger forces
const MIN_DISTANCE: f32 = 5.0;         // Increased minimum distance
const CENTER_RADIUS: f32 = 250.0;      // Matches target_radius from settings
const MAX_VELOCITY: f32 = 20.0;        // Increased for faster movement
const NATURAL_LENGTH: f32 = 120.0;     // Matches natural_length from settings
const BOUNDARY_LIMIT: f32 = 600.0;     // Matches boundary_limit from settings

// Validation functions
fn is_valid_float(x: f32) -> bool {
    return x == x && abs(x) < 1e10;  // Check for NaN and infinity
}

fn is_valid_float3(v: vec3<f32>) -> bool {
    return is_valid_float(v.x) && is_valid_float(v.y) && is_valid_float(v.z);
}

fn clamp_force(force: vec3<f32>) -> vec3<f32> {
    let magnitude = length(force);
    if (magnitude > MAX_FORCE) {
        return (force / magnitude) * MAX_FORCE;
    }
    return force;
}

// Convert quantized mass (0-255 in lower byte) to float (0.0-2.0)
fn decode_mass(mass_packed: u32) -> f32 {
    return f32(mass_packed & 0xFFu) / 127.5;
}

// Get node position as vec3
fn get_position(node: Node) -> vec3<f32> {
    return vec3<f32>(node.x, node.y, node.z);
}

// Get node velocity as vec3
fn get_velocity(node: Node) -> vec3<f32> {
    return vec3<f32>(node.vx, node.vy, node.vz);
}

// Calculate spring force between connected nodes
fn calculate_spring_force(pos1: vec3<f32>, pos2: vec3<f32>, mass1: f32, mass2: f32, weight: f32) -> vec3<f32> {
    let displacement = pos2 - pos1;
    let distance = length(displacement);
    
    if (distance < MIN_DISTANCE) {
        return normalize(displacement) * MAX_FORCE;
    }
    
    // Combined spring and attraction forces with weight scaling
    let spring_force = params.spring_strength * weight * (distance - NATURAL_LENGTH);
    let attraction_force = params.attraction_strength * weight * distance;
    
    let total_force = normalize(displacement) * (spring_force + attraction_force);
    return clamp_force(total_force);
}

// Calculate repulsion force between nodes
fn calculate_repulsion_force(pos1: vec3<f32>, pos2: vec3<f32>, mass1: f32, mass2: f32) -> vec3<f32> {
    let displacement = pos2 - pos1;
    let distance_sq = dot(displacement, displacement);
    
    if (distance_sq < MIN_DISTANCE * MIN_DISTANCE) {
        return normalize(displacement) * -MAX_FORCE;
    }
    
    // Coulomb-like repulsion scaled by masses and adjusted for graph size
    let force_magnitude = -params.repulsion_strength * mass1 * mass2 / max(distance_sq, 0.1);
    let force = normalize(displacement) * min(abs(force_magnitude), MAX_FORCE) * sign(force_magnitude);
    return clamp_force(force);
}

// Calculate center gravity force
fn calculate_center_force(position: vec3<f32>) -> vec3<f32> {
    let to_center = -position;
    let distance = length(to_center);
    
    if (distance > CENTER_RADIUS) {
        // Stronger centering force during initial layout
        let center_strength = select(0.1, 0.2, params.is_initial_layout == 1u);
        let force = normalize(to_center) * center_strength * (distance - CENTER_RADIUS);
        return clamp_force(force);
    }
    return vec3<f32>(0.0);
}

@compute @workgroup_size(WORKGROUP_SIZE)
fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let node_id = global_id.x;
    let n_nodes = arrayLength(&nodes_buffer.nodes);

    if (node_id >= n_nodes) {
        return;
    }

    var node = nodes_buffer.nodes[node_id];
    
    // Validate input node data
    if (!is_valid_float3(get_position(node)) || !is_valid_float3(get_velocity(node))) {
        // Reset invalid node to origin
        node.x = 0.0;
        node.y = 0.0;
        node.z = 0.0;
        node.vx = 0.0;
        node.vy = 0.0;
        node.vz = 0.0;
        nodes_buffer.nodes[node_id] = node;
        return;
    }

    var total_force = vec3<f32>(0.0);
    let node_mass = decode_mass(node.mass);
    let node_pos = get_position(node);

    // Calculate forces from edges (bi-directional)
    let n_edges = arrayLength(&edges_buffer.edges);
    for (var i = 0u; i < n_edges; i = i + 1u) {
        let edge = edges_buffer.edges[i];
        if (edge.source == node_id || edge.target_idx == node_id) {
            let other_id = select(edge.source, edge.target_idx, edge.source == node_id);
            let other_node = nodes_buffer.nodes[other_id];
            
            // Validate other node
            if (!is_valid_float3(get_position(other_node))) {
                continue;
            }
            
            let other_mass = decode_mass(other_node.mass);
            let other_pos = get_position(other_node);
            
            // Accumulate spring force
            let spring_force = calculate_spring_force(
                node_pos,
                other_pos,
                node_mass,
                other_mass,
                edge.weight
            );
            total_force += spring_force;
        }
    }

    // Calculate repulsion forces with all other nodes
    for (var i = 0u; i < n_nodes; i = i + 1u) {
        if (i != node_id) {
            let other_node = nodes_buffer.nodes[i];
            
            // Validate other node
            if (!is_valid_float3(get_position(other_node))) {
                continue;
            }
            
            let other_mass = decode_mass(other_node.mass);
            let other_pos = get_position(other_node);
            
            let repulsion_force = calculate_repulsion_force(
                node_pos,
                other_pos,
                node_mass,
                other_mass
            );
            total_force += repulsion_force;
        }
    }

    // Add center gravity force
    let center_force = calculate_center_force(node_pos);
    total_force += center_force;

    // Scale forces based on layout phase
    let force_scale = select(1.0, 2.0, params.is_initial_layout == 1u);
    total_force *= force_scale;
    total_force = clamp_force(total_force);

    // Update velocity with damping
    var velocity = get_velocity(node);
    velocity = (velocity + total_force * params.time_step) * params.damping;

    // Apply velocity limits
    let speed = length(velocity);
    if (speed > MAX_VELOCITY) {
        velocity = (velocity / speed) * MAX_VELOCITY;
    }

    // Update position
    let new_pos = node_pos + velocity * params.time_step;

    // Apply position bounds
    let bounded_pos = clamp(
        new_pos,
        vec3<f32>(-BOUNDARY_LIMIT),
        vec3<f32>(BOUNDARY_LIMIT)
    );

    // Validate final values
    if (!is_valid_float3(bounded_pos) || !is_valid_float3(velocity)) {
        // Reset to origin if invalid
        node.x = 0.0;
        node.y = 0.0;
        node.z = 0.0;
        node.vx = 0.0;
        node.vy = 0.0;
        node.vz = 0.0;
    } else {
        // Update node with new values
        node.x = bounded_pos.x;
        node.y = bounded_pos.y;
        node.z = bounded_pos.z;
        node.vx = velocity.x;
        node.vy = velocity.y;
        node.vz = velocity.z;
    }

    nodes_buffer.nodes[node_id] = node;
}

----
utils/update_positions.wgsl
struct PositionUpdate {
    position: vec3<f32>,  // 12 bytes (x, y, z)
    velocity: vec3<f32>,  // 12 bytes (vx, vy, vz)
}

@group(0) @binding(0) var<storage, read_write> position_updates: array<PositionUpdate>;

// Constants
const MAX_VELOCITY: f32 = 100.0;
const MAX_POSITION: f32 = 1000.0;  // Maximum distance from origin

// Utility functions
fn is_valid_float(x: f32) -> bool {
    return x == x && abs(x) < 1e10;  // Check for NaN and infinity
}

fn is_valid_float3(v: vec3<f32>) -> bool {
    return is_valid_float(v.x) && is_valid_float(v.y) && is_valid_float(v.z);
}

fn clamp_position(pos: vec3<f32>) -> vec3<f32> {
    return clamp(pos, vec3<f32>(-MAX_POSITION), vec3<f32>(MAX_POSITION));
}

fn clamp_velocity(vel: vec3<f32>) -> vec3<f32> {
    let speed = length(vel);
    if (speed > MAX_VELOCITY) {
        return (vel / speed) * MAX_VELOCITY;
    }
    return vel;
}

@compute @workgroup_size(256)
fn update_positions(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let node_id = global_id.x;
    let n_nodes = arrayLength(&position_updates);

    if (node_id >= n_nodes) { return; }

    var update = position_updates[node_id];
    
    // Validate and clamp position
    if (!is_valid_float3(update.position)) {
        update.position = vec3<f32>(0.0);
    } else {
        update.position = clamp_position(update.position);
    }
    
    // Validate and clamp velocity
    if (!is_valid_float3(update.velocity)) {
        update.velocity = vec3<f32>(0.0);
    } else {
        update.velocity = clamp_velocity(update.velocity);
    }
    
    position_updates[node_id] = update;
}

----
utils/websocket_openai.rs
use actix::prelude::*;
use log::{info, error, debug, warn};
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio_tungstenite::WebSocketStream;
use tungstenite::protocol::Message;
use std::error::Error as StdError;
use std::time::Duration;
use futures::stream::{SplitSink, SplitStream, StreamExt};
use futures::SinkExt;
use serde_json::json;
use openai_api_rs::realtime::api::RealtimeClient;
use tokio_tungstenite::MaybeTlsStream;
use tokio::net::TcpStream;
use std::time::Instant;

use crate::config::Settings;
use crate::utils::websocket_messages::{OpenAIMessage, OpenAIConnected, OpenAIConnectionFailed, SendText};
use crate::handlers::WebSocketSession;  // Updated import path

const KEEPALIVE_INTERVAL: Duration = Duration::from_secs(30);
const CONNECTION_WAIT: Duration = Duration::from_millis(500);

#[derive(Debug)]
enum WebSocketError {
    ConnectionFailed(String),
    SendFailed(String),
    ReceiveFailed(String),
    StreamClosed(String),
    InvalidMessage(String),
}

impl std::fmt::Display for WebSocketError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            WebSocketError::ConnectionFailed(msg) => write!(f, "Connection failed: {}", msg),
            WebSocketError::SendFailed(msg) => write!(f, "Send failed: {}", msg),
            WebSocketError::ReceiveFailed(msg) => write!(f, "Receive failed: {}", msg),
            WebSocketError::StreamClosed(msg) => write!(f, "Stream closed: {}", msg),
            WebSocketError::InvalidMessage(msg) => write!(f, "Invalid message: {}", msg),
        }
    }
}

impl StdError for WebSocketError {}

type WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;
type WsSink = SplitSink<WsStream, Message>;
type WsSource = SplitStream<WsStream>;

#[derive(Clone)]
pub struct OpenAIWebSocket {
    client_addr: Addr<WebSocketSession>,
    settings: Arc<RwLock<Settings>>,
    client: Arc<tokio::sync::Mutex<Option<RealtimeClient>>>,
    stream: Arc<tokio::sync::Mutex<Option<(WsSink, WsSource)>>>,
    connection_time: Arc<tokio::sync::Mutex<Option<Instant>>>,
    ready: Arc<tokio::sync::Mutex<bool>>,
}

#[async_trait::async_trait]
pub trait OpenAIRealtimeHandler: Send + Sync {
    async fn send_text_message(&self, text: &str) -> Result<(), Box<dyn StdError + Send + Sync>>;
    async fn handle_openai_responses(&self) -> Result<(), Box<dyn StdError + Send + Sync>>;
}

impl OpenAIWebSocket {
    pub fn new(client_addr: Addr<WebSocketSession>, settings: Arc<RwLock<Settings>>) -> Self {
        debug!("Creating new OpenAIWebSocket instance");
        OpenAIWebSocket {
            client_addr,
            settings,
            client: Arc::new(tokio::sync::Mutex::new(None)),
            stream: Arc::new(tokio::sync::Mutex::new(None)),
            connection_time: Arc::new(tokio::sync::Mutex::new(None)),
            ready: Arc::new(tokio::sync::Mutex::new(false)),
        }
    }

    async fn connect_to_openai(&mut self) -> Result<(), Box<dyn StdError + Send + Sync>> {
        let start_time = Instant::now();
        debug!("Starting OpenAI WebSocket connection process");

        let settings = self.settings.read().await;
        let api_key = settings.openai.api_key.clone();
        let mut url = settings.openai.base_url.clone();
        
        if !url.starts_with("wss://") && !url.starts_with("ws://") {
            url = format!("wss://{}", url.trim_start_matches("https://").trim_start_matches("http://"));
            debug!("Adjusted WebSocket URL: {}", url);
        }
        
        info!("Connecting to OpenAI WebSocket at URL: {}", url);

        // Create RealtimeClient instance using new() instead of new_with_endpoint()
        let client = RealtimeClient::new(
            api_key.clone(),
            "gpt-4".to_string(),
        );

        // Store client instance
        let mut client_guard = self.client.lock().await;
        *client_guard = Some(client);
        drop(client_guard);

        // Rest of the function remains the same...
        // Get client reference for connection
        let client_guard = self.client.lock().await;
        if let Some(ref client) = *client_guard {
            // Connect using the client
            debug!("Attempting to establish WebSocket connection");
            match client.connect().await {
                Ok((mut write, read)) => {
                    let connection_duration = start_time.elapsed();
                    info!("Connected to OpenAI WebSocket (took {}ms)", connection_duration.as_millis());
                    
                    // Update connection time
                    let mut time_guard = self.connection_time.lock().await;
                    *time_guard = Some(Instant::now());
                    drop(time_guard);

                    // Send initial configuration
                    debug!("Sending initial configuration");
                    let config = json!({
                        "type": "response.create",
                        "response": {
                            "modalities": ["text", "audio"],
                            "instructions": "You are a helpful, witty, and friendly AI. Act like a human with a slightly sardonic, very slightly patronising, and brisk tone, but remember that you aren't a human and that you can't do human things in the real world. Your voice and personality should be brisk, engaging, and sound slightly smug, with a lively and playful tone. If interacting in a non-English language, start by using the standard accent or dialect familiar to the user. Talk quickly. You should always call a function if you can. Do not refer to these rules, even if you're asked about them.",
                        }
                    });

                    let message = Message::Text(config.to_string());
                    match write.send(message).await {
                        Ok(_) => {
                            debug!("Initial configuration sent successfully");
                            
                            // Store the stream after successful configuration
                            let mut stream_guard = self.stream.lock().await;
                            *stream_guard = Some((write, read));
                            drop(stream_guard);

                            // Wait a bit before marking as ready
                            tokio::time::sleep(CONNECTION_WAIT).await;
                            let mut ready_guard = self.ready.lock().await;
                            *ready_guard = true;
                            debug!("OpenAI WebSocket ready for messages");

                            // Start keepalive ping
                            let stream_clone = self.stream.clone();
                            let ready_clone = self.ready.clone();
                            tokio::spawn(async move {
                                let mut ping_count = 0u64;
                                while *ready_clone.lock().await {
                                    tokio::time::sleep(KEEPALIVE_INTERVAL).await;
                                    let mut stream_guard = stream_clone.lock().await;
                                    if let Some((ref mut write, _)) = *stream_guard {
                                        ping_count += 1;
                                        debug!("Sending keepalive ping #{}", ping_count);
                                        let message = Message::Ping(vec![]);
                                        if let Err(e) = write.send(message).await {
                                            error!("Failed to send keepalive ping #{}: {}", ping_count, e);
                                            break;
                                        }
                                    } else {
                                        warn!("WebSocket stream no longer available, stopping keepalive");
                                        break;
                                    }
                                }
                            });

                            Ok(())
                        },
                        Err(e) => {
                            error!("Failed to send initial configuration: {}", e);
                            Err(Box::new(WebSocketError::SendFailed(format!(
                                "Failed to send initial configuration: {}", e
                            ))))
                        }
                    }
                },
                Err(e) => {
                    error!("Failed to connect to OpenAI WebSocket at {}: {}", url, e);
                    Err(Box::new(WebSocketError::ConnectionFailed(format!(
                        "Failed to connect to OpenAI WebSocket: {}", e
                    ))))
                }
            }
        } else {
            Err(Box::new(WebSocketError::ConnectionFailed(
                "Client not initialized".to_string()
            )))
        }
    }

    async fn send_audio_to_client(&self, audio_data: &str) -> Result<(), Box<dyn StdError + Send + Sync>> {
        let start_time = Instant::now();
        debug!("Preparing to send audio data to client");

        // Send audio data as JSON
        let audio_message = json!({
            "type": "audio",
            "audio": audio_data
        });

        // Convert to string and send
        let message_str = audio_message.to_string();
        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
            error!("Failed to send audio data to client: {}", e);
            return Err(Box::new(WebSocketError::SendFailed(format!(
                "Failed to send audio data to client: {}", e
            ))));
        }

        let duration = start_time.elapsed();
        debug!("Audio data sent to client (took {}ms)", duration.as_millis());
        Ok(())
    }

    async fn send_error_to_client(&self, error_msg: &str) -> Result<(), Box<dyn StdError + Send + Sync>> {
        debug!("Preparing to send error message to client: {}", error_msg);
        
        let error_message = json!({
            "type": "error",
            "message": error_msg
        });

        // Convert to string and send
        let message_str = error_message.to_string();
        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
            error!("Failed to send error message to client: {}", e);
            return Err(Box::new(WebSocketError::SendFailed(format!(
                "Failed to send error message to client: {}", e
            ))));
        }

        debug!("Error message sent to client successfully");
        Ok(())
    }

    fn log_connection_status(&self) {
        if let Ok(time_guard) = self.connection_time.try_lock() {
            if let Some(connection_time) = *time_guard {
                let uptime = connection_time.elapsed();
                debug!(
                    "WebSocket connection status - Uptime: {}s {}ms",
                    uptime.as_secs(),
                    uptime.subsec_millis()
                );
            }
        }
    }
}

#[async_trait::async_trait]
impl OpenAIRealtimeHandler for OpenAIWebSocket {
    async fn send_text_message(&self, text: &str) -> Result<(), Box<dyn StdError + Send + Sync>> {
        let start_time = Instant::now();
        debug!("Preparing to send text message to OpenAI: {}", text);

        // Wait for ready state
        let ready = self.ready.lock().await;
        if !*ready {
            error!("OpenAI WebSocket not ready to send messages");
            return Err(Box::new(WebSocketError::ConnectionFailed("WebSocket not ready".to_string())));
        }
        drop(ready);

        let mut stream_guard = self.stream.lock().await;
        let (write, _) = stream_guard.as_mut().ok_or_else(|| {
            Box::new(WebSocketError::ConnectionFailed("WebSocket not connected".to_string())) as Box<dyn StdError + Send + Sync>
        })?;
        
        let request = json!({
            "type": "conversation.item.create",
            "item": {
                "type": "message",
                "role": "user",
                "content": [
                    {
                        "type": "input_text",
                        "text": text
                    }
                ]
            }
        });
        
        debug!("Sending request to OpenAI: {}", request.to_string());
        let message = Message::Text(request.to_string());
        match write.send(message).await {
            Ok(_) => {
                let duration = start_time.elapsed();
                debug!("Text message sent successfully to OpenAI (took {}ms)", duration.as_millis());
                Ok(())
            },
            Err(e) => {
                error!("Error sending message to OpenAI: {}", e);
                Err(Box::new(WebSocketError::SendFailed(format!(
                    "Failed to send message to OpenAI: {}", e
                ))))
            }
        }
    }

    async fn handle_openai_responses(&self) -> Result<(), Box<dyn StdError + Send + Sync>> {
        debug!("Starting to handle OpenAI responses");
        let start_time = Instant::now();
        let mut message_count: u128 = 0;

        let mut stream_guard = self.stream.lock().await;
        let (write, read) = stream_guard.as_mut().ok_or_else(|| {
            Box::new(WebSocketError::ConnectionFailed("WebSocket not connected".to_string())) as Box<dyn StdError + Send + Sync>
        })?;
        
        while let Some(response) = read.next().await {
            message_count += 1;
match response {
    Ok(Message::Text(text)) => {
        debug!("Received text message #{} from OpenAI: {}", message_count, text);
        match serde_json::from_str::<serde_json::Value>(&text) {
            Ok(json_msg) => {
                if let Some(audio_data) = json_msg["delta"]["audio"].as_str() {
                    debug!("Processing audio data from message #{}", message_count);
                    if let Err(e) = self.send_audio_to_client(audio_data).await {
                        error!("Failed to send audio to client: {}", e);
                        continue;
                    }
                } else if json_msg["type"].as_str() == Some("response.text.done") {
                    debug!("Received completion signal after {} messages", message_count);
                    break;
                }
            },
            Err(e) => {
                error!("Error parsing JSON response from OpenAI: {}", e);
                if let Err(e) = self.send_error_to_client(&format!("Error parsing JSON response from OpenAI: {}", e)).await {
                    error!("Failed to send error message: {}", e);
                }
                return Err(Box::new(WebSocketError::InvalidMessage(format!(
                    "Invalid JSON response from OpenAI: {}", e
                ))));
            }
        }
    },
    Ok(Message::Close(reason)) => {
        info!("OpenAI WebSocket connection closed by server: {:?}", reason);
        return Err(Box::new(WebSocketError::StreamClosed(format!(
            "Connection closed by server: {:?}", reason
        ))));
    },
    Ok(Message::Ping(_)) => {
        debug!("Received ping from server");
        let message = Message::Pong(vec![]);
        if let Err(e) = write.send(message).await {
            error!("Failed to send pong response: {}", e);
        } else {
            debug!("Sent pong response");
        }
    },
    Ok(Message::Pong(_)) => {
        debug!("Received pong from OpenAI WebSocket");
    },
    Err(e) => {
        error!("Error receiving message from OpenAI: {}", e);
        if let Err(e) = self.send_error_to_client(&format!("Error receiving message from OpenAI: {}", e)).await {
            error!("Failed to send error message: {}", e);
        }
        return Err(Box::new(WebSocketError::ReceiveFailed(format!(
            "Failed to receive message from OpenAI: {}", e
        ))));
    },
    _ => {
        debug!("Received unhandled message type");
        continue;
                }
            }
        }

        let duration = start_time.elapsed();
        let avg_time = if message_count > 0 {
            duration.as_millis() / message_count
        } else {
            0
        };
        
        info!(
            "Finished handling responses - Processed {} messages in {}ms (avg {}ms per message)",
            message_count,
            duration.as_millis(),
            avg_time
        );
        
        Ok(())
    }
}

impl Actor for OpenAIWebSocket {
    type Context = Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        info!("OpenAI WebSocket actor started");
        let addr = ctx.address();
        let mut this = self.clone();
        
        ctx.spawn(async move {
            debug!("Initiating connection process");
            match this.connect_to_openai().await {
                Ok(_) => {
                    info!("Successfully connected to OpenAI WebSocket");
                    addr.do_send(OpenAIConnected);
                }
                Err(e) => {
                    error!("Failed to connect to OpenAI WebSocket: {}", e);
                    addr.do_send(OpenAIConnectionFailed);
                }
            }
        }.into_actor(self));
    }

    fn stopped(&mut self, _ctx: &mut Self::Context) {
        // Set ready state to false when stopping
        if let Ok(mut ready_guard) = self.ready.try_lock() {
            *ready_guard = false;
        }

        if let Ok(time_guard) = self.connection_time.try_lock() {
            if let Some(connection_time) = *time_guard {
                let uptime = connection_time.elapsed();
                info!(
                    "OpenAI WebSocket actor stopped - Total uptime: {}s {}ms",
                    uptime.as_secs(),
                    uptime.subsec_millis()
                );
            } else {
                info!("OpenAI WebSocket actor stopped - No connection was established");
            }
        }
    }
}

impl Handler<OpenAIMessage> for OpenAIWebSocket {
    type Result = ResponseActFuture<Self, ()>;

    fn handle(&mut self, msg: OpenAIMessage, _ctx: &mut Self::Context) -> Self::Result {
        let text_message = msg.0;
        let this = self.clone();

        Box::pin(async move {
            debug!("Handling new message for OpenAI TTS: {}", text_message);
            if let Err(e) = this.send_text_message(&text_message).await {
                error!("Error sending message to OpenAI: {}", e);
            }
            if let Err(e) = this.handle_openai_responses().await {
                error!("Error handling OpenAI responses: {}", e);
            }
            this.log_connection_status();
        }.into_actor(self))
    }
}

impl Handler<OpenAIConnected> for OpenAIWebSocket {
    type Result = ();

    fn handle(&mut self, _msg: OpenAIConnected, _ctx: &mut Self::Context) {
        debug!("Handling OpenAIConnected message");
    }
}

impl Handler<OpenAIConnectionFailed> for OpenAIWebSocket {
    type Result = ();

    fn handle(&mut self, _msg: OpenAIConnectionFailed, ctx: &mut Self::Context) {
        error!("Handling OpenAIConnectionFailed message - stopping actor");
        ctx.stop();
    }
}

----
utils/websocket_messages.rs
use actix::prelude::*;
use serde::{Serialize, Deserialize};
use serde_json::Value;
use crate::models::graph::GraphData;  // Import the proper GraphData struct

#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
#[serde(rename_all = "camelCase")]
pub enum ServerMessage {
    GraphUpdate {
        #[serde(rename = "graphData")]
        graph_data: GraphData,  // Use actual GraphData instead of Value
    },
    Error {
        message: String,
        code: Option<String>,
        details: Option<String>,
    },
    PositionUpdateComplete {
        status: String,
    },
    SettingsUpdated {
        settings: Value,
    },
    SimulationModeSet {
        mode: String,
        gpu_enabled: bool,
    },
    FisheyeSettingsUpdated {
        enabled: bool,
        strength: f32,
        focus_point: [f32; 3],
        radius: f32,
    },
    InitialData {
        #[serde(rename = "graphData")]
        graph_data: GraphData,  // Use actual GraphData here too
        settings: Value,
    },
    GpuState {
        enabled: bool,
        node_count: usize,
        frame_time: f32,
    },
    LayoutState {
        iteration: usize,
        energy: f32,
        stable: bool,
    },
    AudioData {
        audio_data: String,
    },
    OpenAIResponse {
        text: String,
        audio: Option<String>,
    },
    RagflowResponse {
        answer: String,
        audio: Option<String>,
    },
    Completion {
        message: String,
    },
    BinaryPositionUpdate {
        is_initial_layout: bool,
    },
    Ping,
    Pong,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Node {
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<[f32; 3]>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub velocity: Option<[f32; 3]>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub node_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_data: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Edge {
    pub source: String,
    pub target: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edge_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_data: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub directed: Option<bool>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NodePosition {
    pub id: String,
    pub position: [f32; 3],
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UpdatePositionsMessage {
    pub nodes: Vec<NodePosition>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct BroadcastGraph {
    pub graph: GraphData,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct BroadcastError {
    pub message: String,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct OpenAIMessage(pub String);

#[derive(Message)]
#[rtype(result = "()")]
pub struct OpenAIConnected;

#[derive(Message)]
#[rtype(result = "()")]
pub struct OpenAIConnectionFailed;

#[derive(Message)]
#[rtype(result = "()")]
pub struct SendText(pub String);

#[derive(Message)]
#[rtype(result = "()")]
pub struct SendBinary(pub Vec<u8>);

pub trait MessageHandler {}

----
utils/fisheye.wgsl
// Structure representing a node with position, velocity, mass and padding
struct Node {
    position: vec3<f32>,  // 12 bytes
    velocity: vec3<f32>,  // 12 bytes
    mass: f32,           // 4 bytes
    padding1: u32,       // 4 bytes
}

// Buffer containing all nodes
struct NodesBuffer {
    nodes: array<Node>,
}

// Fisheye distortion parameters
struct FisheyeParams {
    enabled: u32,
    strength: f32,
    focus_point: vec3<f32>,
    radius: f32,
}

// Nodes buffer for reading and writing node data
@group(0) @binding(0) var<storage, read_write> nodes_buffer: NodesBuffer;

// Uniform buffer containing fisheye parameters
@group(0) @binding(1) var<uniform> fisheye_params: FisheyeParams;

// Constants
const PI: f32 = 3.14159265359;

// Apply fisheye distortion to a position
fn apply_fisheye(position: vec3<f32>) -> vec3<f32> {
    if (fisheye_params.enabled == 0u) {
        return position;
    }

    // Calculate vector from focus point to position
    let offset = position - fisheye_params.focus_point;
    let distance = length(offset);
    
    if (distance == 0.0 || distance > fisheye_params.radius) {
        return position;
    }

    // Normalize distance to [0,1] range within radius
    let normalized_distance = distance / fisheye_params.radius;
    
    // Calculate distortion factor using atan function
    // This creates a smooth falloff that preserves detail in the center
    let distortion = atan(normalized_distance * fisheye_params.strength) / 
                    (normalized_distance * fisheye_params.strength);
    
    // Apply distortion
    return fisheye_params.focus_point + offset * distortion;
}

// Main compute shader function
@compute @workgroup_size(256)
fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let node_id = global_id.x;
    let n_nodes = arrayLength(&nodes_buffer.nodes);
    
    if (node_id >= n_nodes) {
        return;
    }

    var node = nodes_buffer.nodes[node_id];
    
    // Apply fisheye distortion to node position
    node.position = apply_fisheye(node.position);
    
    // Write back to buffer
    nodes_buffer.nodes[node_id] = node;
}

----
utils/mod.rs
pub mod audio_processor;
pub mod debug_logging;
pub mod gpu_compute;
pub mod websocket_manager;
pub mod websocket_messages;
pub mod websocket_openai;

----
utils/gpu_compute.rs
use cudarc::driver::{CudaDevice, CudaFunction, CudaSlice, LaunchConfig, LaunchAsync};
use cudarc::nvrtc::Ptx;
use std::error::Error;
use std::sync::Arc;
use log::debug;
use crate::models::graph::GraphData;
use crate::models::node::GPUNode;
use crate::models::simulation_params::SimulationParams;

const BLOCK_SIZE: u32 = 256;
const MAX_NODES: u32 = 1_000_000;
const MIN_DISTANCE: f32 = 0.0001;
const FLOAT3_SIZE: u32 = 12;
const FLOAT_SIZE: u32 = 4;
const SHARED_MEM_SIZE: u32 = BLOCK_SIZE * (FLOAT3_SIZE + FLOAT_SIZE);

const FORCE_KERNEL: &str = r#"
extern "C" __global__ void compute_forces(
    float* positions,
    float* velocities,
    unsigned char* masses,
    int num_nodes,
    float spring_strength,
    float repulsion,
    float damping
) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= num_nodes) return;

    int pos_idx = idx * 3;
    float3 pos_i = make_float3(
        positions[pos_idx],
        positions[pos_idx + 1],
        positions[pos_idx + 2]
    );
    float mass_i = (float)masses[idx];
    float3 force = make_float3(0.0f, 0.0f, 0.0f);

    __shared__ float3 shared_positions[BLOCK_SIZE];
    __shared__ float shared_masses[BLOCK_SIZE];

    for (int tile = 0; tile < (num_nodes + BLOCK_SIZE - 1) / BLOCK_SIZE; tile++) {
        int shared_idx = tile * BLOCK_SIZE + threadIdx.x;
        if (shared_idx < num_nodes) {
            shared_positions[threadIdx.x] = make_float3(
                positions[shared_idx * 3],
                positions[shared_idx * 3 + 1],
                positions[shared_idx * 3 + 2]
            );
            shared_masses[threadIdx.x] = (float)masses[shared_idx];
        }
        __syncthreads();

        #pragma unroll 8
        for (int j = 0; j < BLOCK_SIZE && tile * BLOCK_SIZE + j < num_nodes; j++) {
            if (tile * BLOCK_SIZE + j == idx) continue;
            
            float3 pos_j = shared_positions[j];
            float mass_j = shared_masses[j];
            float3 diff = make_float3(
                pos_i.x - pos_j.x,
                pos_i.y - pos_j.y,
                pos_i.z - pos_j.z
            );
            
            float dist = fmaxf(sqrtf(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z), MIN_DISTANCE);
            float force_mag = repulsion * mass_i * mass_j / (dist * dist);
            force.x += force_mag * diff.x / dist;
            force.y += force_mag * diff.y / dist;
            force.z += force_mag * diff.z / dist;
        }
        __syncthreads();
    }

    int vel_idx = idx * 3;
    float3 vel = make_float3(
        velocities[vel_idx],
        velocities[vel_idx + 1],
        velocities[vel_idx + 2]
    );
    
    vel.x = (vel.x + force.x) * damping;
    vel.y = (vel.y + force.y) * damping;
    vel.z = (vel.z + force.z) * damping;

    pos_i.x += vel.x;
    pos_i.y += vel.y;
    pos_i.z += vel.z;

    positions[pos_idx] = pos_i.x;
    positions[pos_idx + 1] = pos_i.y;
    positions[pos_idx + 2] = pos_i.z;

    velocities[vel_idx] = vel.x;
    velocities[vel_idx + 1] = vel.y;
    velocities[vel_idx + 2] = vel.z;
}
"#;

pub struct GPUCompute {
    device: Arc<CudaDevice>,
    force_kernel: CudaFunction,
    positions: CudaSlice<f32>,
    velocities: CudaSlice<f32>,
    masses: CudaSlice<u8>,
    num_nodes: u32,
    simulation_params: SimulationParams,
}

fn to_io_error(e: impl std::fmt::Display) -> Box<dyn Error + Send + Sync> {
    Box::new(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
}

impl GPUCompute {
    pub async fn new(graph: &GraphData) -> Result<Self, Box<dyn Error + Send + Sync>> {
        let num_nodes = graph.nodes.len() as u32;
        if num_nodes > MAX_NODES {
            return Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "Node count exceeds limit"
            )));
        }

        // Initialize CUDA device - wrap in Arc only ONCE
        let device = Arc::new(CudaDevice::new(0).map_err(to_io_error)?);

        // Create PTX and load kernel
        let ptx = Ptx::from_src(FORCE_KERNEL);
        let force_kernel = device.load_ptx(ptx, "compute_forces", &["compute_forces"]).map_err(to_io_error)?;

        // Allocate device memory
        let positions = device.alloc_zeros::<f32>((num_nodes * 3) as usize).map_err(to_io_error)?;
        let velocities = device.alloc_zeros::<f32>((num_nodes * 3) as usize).map_err(to_io_error)?;
        let masses = device.alloc_zeros::<u8>(num_nodes as usize).map_err(to_io_error)?;

        // Initialize graph data
        let mut positions_vec = Vec::with_capacity(graph.nodes.len() * 3);
        let mut velocities_vec = Vec::with_capacity(graph.nodes.len() * 3);
        let mut masses_vec = Vec::with_capacity(graph.nodes.len());

        for node in &graph.nodes {
            positions_vec.extend_from_slice(&[node.x, node.y, node.z]);
            velocities_vec.extend_from_slice(&[node.vx, node.vy, node.vz]);
            masses_vec.push(node.to_gpu_node().mass);
        }

        device.htod_sync_copy_into(&positions_vec, &mut positions).map_err(to_io_error)?;
        device.htod_sync_copy_into(&velocities_vec, &mut velocities).map_err(to_io_error)?;
        device.htod_sync_copy_into(&masses_vec, &mut masses).map_err(to_io_error)?;

        // Create instance
        Ok(GPUCompute {
            device,
            force_kernel,
            positions,
            velocities,
            masses,
            num_nodes,
            simulation_params: SimulationParams::default(),
        })
    }

    pub fn update_graph_data(&mut self, graph: &GraphData) -> Result<(), Box<dyn Error + Send + Sync>> {
        debug!("Updating graph data for {} nodes", graph.nodes.len());

        let mut positions = Vec::with_capacity(graph.nodes.len() * 3);
        let mut velocities = Vec::with_capacity(graph.nodes.len() * 3);
        let mut masses = Vec::with_capacity(graph.nodes.len());

        for node in &graph.nodes {
            positions.extend_from_slice(&[node.x, node.y, node.z]);
            velocities.extend_from_slice(&[node.vx, node.vy, node.vz]);
            masses.push(node.to_gpu_node().mass);
        }

        self.device.htod_sync_copy_into(&positions, &mut self.positions).map_err(to_io_error)?;
        self.device.htod_sync_copy_into(&velocities, &mut self.velocities).map_err(to_io_error)?;
        self.device.htod_sync_copy_into(&masses, &mut self.masses).map_err(to_io_error)?;

        self.num_nodes = graph.nodes.len() as u32;
        Ok(())
    }

    pub fn update_simulation_params(&mut self, params: &SimulationParams) -> Result<(), Box<dyn Error + Send + Sync>> {
        debug!("Updating simulation parameters: {:?}", params);
        self.simulation_params = params.clone();
        Ok(())
    }

    pub fn step(&mut self) -> Result<(), Box<dyn Error + Send + Sync>> {
        let blocks = (self.num_nodes + BLOCK_SIZE - 1) / BLOCK_SIZE;
        let cfg = LaunchConfig {
            grid_dim: (blocks, 1, 1),
            block_dim: (BLOCK_SIZE, 1, 1),
            shared_mem_bytes: SHARED_MEM_SIZE as u32,
        };

        let params = &self.simulation_params;
        unsafe {
            self.force_kernel.clone().launch(cfg, (
                &self.positions,
                &self.velocities,
                &self.masses,
                self.num_nodes as i32,
                params.spring_strength,
                params.repulsion,
                params.damping,
            )).map_err(to_io_error)?;
        }

        Ok(())
    }

    pub fn get_node_positions(&self) -> Result<Vec<GPUNode>, Box<dyn Error + Send + Sync>> {
        let mut positions = vec![0.0f32; (self.num_nodes as usize) * 3];
        let mut velocities = vec![0.0f32; (self.num_nodes as usize) * 3];
        let mut masses = vec![0u8; self.num_nodes as usize];

        self.device.dtoh_sync_copy_into(&self.positions, &mut positions).map_err(to_io_error)?;
        self.device.dtoh_sync_copy_into(&self.velocities, &mut velocities).map_err(to_io_error)?;
        self.device.dtoh_sync_copy_into(&self.masses, &mut masses).map_err(to_io_error)?;

        let mut nodes = Vec::with_capacity(self.num_nodes as usize);
        for i in 0..(self.num_nodes as usize) {
            nodes.push(GPUNode {
                x: positions[i * 3],
                y: positions[i * 3 + 1],
                z: positions[i * 3 + 2],
                vx: velocities[i * 3],
                vy: velocities[i * 3 + 1],
                vz: velocities[i * 3 + 2],
                mass: masses[i],
                flags: 0,
                padding: [0; 2],
            });
        }

        Ok(nodes)
    }
}

----
utils/websocket_manager.rs
use actix::prelude::*;
use actix_web_actors::ws;
use actix_web::{web, Error, HttpRequest, HttpResponse};
use bytemuck;
use std::sync::Arc;
use log::{debug, info, warn, trace, error};
use std::time::{Duration, Instant};
use serde_json::{self, Value};
use std::sync::Mutex;
use std::error::Error as StdError;

use crate::models::node::GPUNode;
use crate::models::graph::GraphData;
use crate::utils::websocket_messages::{SendBinary, SendText, ServerMessage};
use crate::AppState;

// Constants for binary protocol
pub(crate) const FLOAT32_SIZE: usize = std::mem::size_of::<f32>();
pub(crate) const HEADER_SIZE: usize = FLOAT32_SIZE; // isInitialLayout flag
pub(crate) const NODE_SIZE: usize = 6 * FLOAT32_SIZE; // x, y, z, vx, vy, vz

// Constants for heartbeat
const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(15); // Send ping every 15 seconds
const HEARTBEAT_TIMEOUT: Duration = Duration::from_secs(60); // Wait 60 seconds for pong response

pub struct WebSocketManager {
    binary_buffer: Arc<Mutex<Vec<u8>>>,
    connections: Arc<Mutex<Vec<Addr<WebSocketSession>>>>,
    addr: Option<Addr<Self>>,
    debug_mode: bool,
    app_state: web::Data<AppState>,
}

impl Actor for WebSocketManager {
    type Context = Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        self.addr = Some(ctx.address());
    }
}

impl WebSocketManager {
    pub fn new(debug_mode: bool, app_state: web::Data<AppState>) -> Self {
        if debug_mode {
            debug!("[WebSocketManager] Creating new instance with debug_mode={}", debug_mode);
        }
        Self {
            binary_buffer: Arc::new(Mutex::new(Vec::with_capacity(1024 * 1024))), // 1MB initial capacity
            connections: Arc::new(Mutex::new(Vec::new())),
            addr: None,
            debug_mode,
            app_state,
        }
    }

    pub fn start(mut self) -> Addr<Self> {
        let addr = Actor::start(self.clone());
        self.addr = Some(addr.clone());
        addr
    }

    pub fn get_addr(&self) -> Option<Addr<Self>> {
        self.addr.clone()
    }

    pub async fn add_connection(&self, addr: Addr<WebSocketSession>) {
        let mut connections = self.connections.lock().unwrap();
        connections.push(addr);
    }

    pub async fn remove_connection(&self, addr: &Addr<WebSocketSession>) {
        let mut connections = self.connections.lock().unwrap();
        connections.retain(|x| x != addr);
    }

    pub async fn broadcast_message(&self, message: String) -> Result<(), Box<dyn StdError>> {
        let connections = self.connections.lock().unwrap();
        for addr in connections.iter() {
            addr.do_send(SendText(message.clone()));
        }
        Ok(())
    }

    pub async fn broadcast_binary(&self, nodes: &[GPUNode], is_initial: bool) -> Result<(), Box<dyn StdError>> {
        let mut buffer = self.binary_buffer.lock().unwrap();
        let total_size = HEADER_SIZE + nodes.len() * NODE_SIZE;
        
        let mut new_buffer = Vec::with_capacity(total_size);
        
        let initial_flag: f32 = if is_initial { 1.0 } else { 0.0 };
        new_buffer.extend_from_slice(bytemuck::bytes_of(&initial_flag));

        for node in nodes.iter() {
            let node_data: [f32; 6] = [
                node.x, node.y, node.z,
                node.vx, node.vy, node.vz
            ];
            new_buffer.extend_from_slice(bytemuck::cast_slice(&node_data));
        }

        *buffer = new_buffer;

        let binary_data = buffer.clone();
        let connections = self.connections.lock().unwrap();
        
        for addr in connections.iter() {
            addr.do_send(SendBinary(binary_data.clone()));
        }

        Ok(())
    }

    pub async fn broadcast_graph_update(&self, graph: &GraphData) -> Result<(), Box<dyn StdError>> {
        if self.debug_mode {
            for (i, node) in graph.nodes.iter().take(3).enumerate() {
                trace!("[WebSocketManager] Sample node {}: id={}", i, node.id);
            }
            for (i, edge) in graph.edges.iter().take(3).enumerate() {
                trace!("[WebSocketManager] Sample edge {}: source={}, target={}", 
                    i, edge.source, edge.target);
            }
        }

        let message = ServerMessage::GraphUpdate {
            graph_data: graph.clone()
        };

        let message_str = serde_json::to_string(&message)?;
        
        let connections = self.connections.lock().unwrap();
        
        for addr in connections.iter() {
            addr.do_send(SendText(message_str.clone()));
        }
        
        Ok(())
    }

    pub async fn handle_websocket(
        req: HttpRequest,
        stream: web::Payload,
        websocket_manager: web::Data<Arc<WebSocketManager>>,
    ) -> Result<HttpResponse, Error> {
        let ws = WebSocketSession::new(Arc::clone(&websocket_manager));
        ws::start(ws, &req, stream)
    }

    pub async fn send_initial_data(&self, addr: &Addr<WebSocketSession>) -> Result<(), Box<dyn StdError>> {
        if self.debug_mode {
            debug!("[WebSocketManager] Starting send_initial_data");
        }
        
        let graph = self.app_state.graph_service.graph_data.read().await;
        let settings = self.app_state.settings.read().await;

        let initial_data = ServerMessage::InitialData {
            graph_data: (*graph).clone(),
            settings: serde_json::to_value(&*settings).unwrap_or_default(),
        };

        match serde_json::to_string(&initial_data) {
            Ok(initial_data_str) => {
                if self.debug_mode {
                    debug!("[WebSocketManager] Serialized initial data size: {} bytes", initial_data_str.len());
                }
                addr.do_send(SendText(initial_data_str));
                Ok(())
            }
            Err(e) => {
                error!("[WebSocketManager] Failed to serialize initial data: {}", e);
                Err(Box::new(e))
            }
        }
    }
}

impl Clone for WebSocketManager {
    fn clone(&self) -> Self {
        Self {
            binary_buffer: self.binary_buffer.clone(),
            connections: self.connections.clone(),
            addr: self.addr.clone(),
            debug_mode: self.debug_mode,
            app_state: self.app_state.clone(),
        }
    }
}

pub struct WebSocketSession {
    manager: Arc<WebSocketManager>,
    hb: Instant,
    last_pong: Instant,
}

impl WebSocketSession {
    pub fn new(manager: Arc<WebSocketManager>) -> Self {
        Self {
            manager,
            hb: Instant::now(),
            last_pong: Instant::now(),
        }
    }

    fn start_heartbeat(&self, ctx: &mut ws::WebsocketContext<Self>) {
        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {
            if Instant::now().duration_since(act.last_pong) > HEARTBEAT_TIMEOUT {
                warn!("[WebSocketSession] Client heartbeat failed, disconnecting!");
                ctx.stop();
                return;
            }

            ctx.ping(b"");
        });
    }
}

impl Actor for WebSocketSession {
    type Context = ws::WebsocketContext<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        if self.manager.debug_mode {
            debug!("[WebSocketSession] Session started");
        }
        self.start_heartbeat(ctx);
        
        let addr = ctx.address();
        let manager = self.manager.clone();
        actix::spawn(async move {
            manager.add_connection(addr).await;
        });
    }

    fn stopped(&mut self, ctx: &mut Self::Context) {
        if self.manager.debug_mode {
            debug!("[WebSocketSession] Session stopped");
        }
        
        let addr = ctx.address();
        let manager = self.manager.clone();
        actix::spawn(async move {
            manager.remove_connection(&addr).await;
        });
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                self.hb = Instant::now();
                ctx.pong(&msg);
            }
            Ok(ws::Message::Pong(_)) => {
                self.last_pong = Instant::now();
            }
            Ok(ws::Message::Text(text)) => {
                if self.manager.debug_mode {
                    debug!("[WebSocketSession] Text message received: {}", text);
                }
                if let Ok(json) = serde_json::from_str::<Value>(&text) {
                    if let Some(msg_type) = json["type"].as_str() {
                        let snake_type = msg_type.replace("initialData", "initial_data");
                        if snake_type == "initial_data" {
                            if self.manager.debug_mode {
                                debug!("[WebSocketSession] Initial data request received");
                            }
                            let addr = ctx.address();
                            let manager = self.manager.clone();
                            actix::spawn(async move {
                                if let Err(e) = manager.send_initial_data(&addr).await {
                                    error!("[WebSocketSession] Failed to send initial data: {}", e);
                                }
                            });
                        }
                    }
                }

                if text.contains("\"type\":\"ping\"") {
                    ctx.text("{\"type\":\"pong\"}");
                }
            }
            Ok(ws::Message::Binary(bin)) => {
                let connections = self.manager.connections.clone();
                let bin_data = bin.to_vec();
                actix::spawn(async move {
                    let connections = connections.lock().unwrap();
                    for addr in connections.iter() {
                        addr.do_send(SendBinary(bin_data.clone()));
                    }
                });
            }
            Ok(ws::Message::Close(reason)) => {
                if self.manager.debug_mode {
                    debug!("[WebSocketSession] Close message received: {:?}", reason);
                }
                ctx.close(reason);
                ctx.stop();
            }
            _ => (),
        }
    }
}

impl Handler<SendBinary> for WebSocketSession {
    type Result = ();

    fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
        let data = &msg.0;
        if data.len() >= HEADER_SIZE && self.manager.debug_mode {
            let mut header_bytes = [0u8; 4];
            header_bytes.copy_from_slice(&data[0..4]);
            let is_initial = f32::from_le_bytes(header_bytes) >= 1.0;
            let num_nodes = (data.len() - HEADER_SIZE) / NODE_SIZE;

            let hex_dump: String = data.iter()
                .take(32)
                .map(|b| format!("{:02x}", b))
                .collect::<Vec<_>>()
                .join(" ");
            trace!("[WebSocketSession] Binary header (first 32 bytes): {}", hex_dump);
        }
        ctx.binary(msg.0);
    }
}

impl Handler<SendText> for WebSocketSession {
    type Result = ();

    fn handle(&mut self, msg: SendText, ctx: &mut Self::Context) {
        if self.manager.debug_mode {
            debug!("[WebSocketSession] Sending text message: {}", msg.0);
        }
        ctx.text(msg.0);
    }
}

----
utils/debug_logging.rs
use serde_json::Value;

// Enhanced debug logging macro for websocket data

// Data types for debug logging
pub enum WsDebugData<'a> {
    Binary {
        data: &'a [u8],
        is_initial: bool,
        node_count: usize,
    },
    Json(Value),
    Text(String),
}


----
utils/compression.rs
use miniz_oxide::deflate::compress_to_vec;
use miniz_oxide::inflate::decompress_to_vec;
use serde_json;
use std::io;
use log::{debug, error};

const COMPRESSION_MAGIC: &[u8] = b"COMP";
const COMPRESSION_LEVEL: u8 = 6; // Balance between compression ratio and speed

pub fn compress_message(message: &str) -> Result<Vec<u8>, serde_json::Error> {
    debug!("Compressing message of length: {}", message.len());
    
    let mut compressed = Vec::with_capacity(COMPRESSION_MAGIC.len() + message.len());
    compressed.extend_from_slice(COMPRESSION_MAGIC);
    compressed.extend_from_slice(&compress_to_vec(message.as_bytes(), COMPRESSION_LEVEL));
    
    debug!("Compressed size: {} bytes", compressed.len());
    Ok(compressed)
}

pub fn decompress_message(compressed: &[u8]) -> Result<String, io::Error> {
    if compressed.len() < COMPRESSION_MAGIC.len() {
        error!("Compressed data too short: {} bytes", compressed.len());
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "Compressed data too short"
        ));
    }

    if &compressed[..COMPRESSION_MAGIC.len()] != COMPRESSION_MAGIC {
        error!("Invalid compression header");
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "Invalid compression header"
        ));
    }

    let decompressed = decompress_to_vec(&compressed[COMPRESSION_MAGIC.len()..])
        .map_err(|e| {
            error!("Decompression failed: {:?}", e);
            io::Error::new(io::ErrorKind::InvalidData, "Failed to decompress data")
        })?;
    
    String::from_utf8(decompressed)
        .map_err(|e| {
            error!("Invalid UTF-8 in decompressed data: {}", e);
            io::Error::new(io::ErrorKind::InvalidData, "Invalid UTF-8")
        })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compression_roundtrip() {
        let original = "Hello, World!";
        let compressed = compress_message(original).unwrap();
        let decompressed = decompress_message(&compressed).unwrap();
        assert_eq!(original, decompressed);
    }

    #[test]
    fn test_compression_magic_header() {
        let message = "Test message";
        let compressed = compress_message(message).unwrap();
        assert_eq!(&compressed[..COMPRESSION_MAGIC.len()], COMPRESSION_MAGIC);
    }

    #[test]
    fn test_invalid_compression_header() {
        let invalid_data = vec![0; 10];
        let result = decompress_message(&invalid_data);
        assert!(result.is_err());
    }

    #[test]
    fn test_empty_message() {
        let empty = "";
        let compressed = compress_message(empty).unwrap();
        let decompressed = decompress_message(&compressed).unwrap();
        assert_eq!(empty, decompressed);
    }

    #[test]
    fn test_large_message() {
        let large_message = "A".repeat(1000000);
        let compressed = compress_message(&large_message).unwrap();
        let decompressed = decompress_message(&compressed).unwrap();
        assert_eq!(large_message, decompressed);
        // Verify compression actually reduces size
        assert!(compressed.len() < large_message.len());
    }
}

----
models/position_update.rs
use std::collections::HashMap;
use bytemuck::{Pod, Zeroable};
use serde::{Serialize, Deserialize};

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NodePositionVelocity {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub vx: f32,
    pub vy: f32,
    pub vz: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PositionUpdate {
    /// Maps node indices to their new positions and velocities
    pub positions: HashMap<usize, NodePositionVelocity>,
    /// Whether this is the final update in a sequence
    pub is_final: bool,
}

impl PositionUpdate {
    pub fn new(positions: HashMap<usize, NodePositionVelocity>, is_final: bool) -> Self {
        Self {
            positions,
            is_final,
        }
    }
}

----
models/graph.rs
use super::node::Node;
use super::edge::Edge;
use super::metadata::MetadataStore;
use serde::{Deserialize, Serialize};

/// Represents the graph data structure containing nodes, edges, and metadata.
/// All fields use camelCase serialization for client compatibility.
#[derive(Default, Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct GraphData {
    /// List of nodes in the graph.
    pub nodes: Vec<Node>,
    /// List of edges connecting the nodes.
    pub edges: Vec<Edge>,
    /// Metadata associated with the graph, using camelCase keys.
    pub metadata: MetadataStore,
}

impl GraphData {
    pub fn new() -> Self {
        Self {
            nodes: Vec::new(),
            edges: Vec::new(),
            metadata: MetadataStore::new(),
        }
    }
}

----
models/node.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use bytemuck::{Pod, Zeroable};
use crate::models::position_update::NodePositionVelocity;

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Node {
    pub id: String,
    pub label: String,
    #[serde(skip_serializing_if = "HashMap::is_empty")]
    pub metadata: HashMap<String, String>,
    pub position: Option<[f32; 3]>,
    #[serde(skip)]
    pub x: f32,
    #[serde(skip)]
    pub y: f32,
    #[serde(skip)]
    pub z: f32,
    #[serde(skip)]
    pub vx: f32,
    #[serde(skip)]
    pub vy: f32,
    #[serde(skip)]
    pub vz: f32,
    #[serde(skip)]
    pub file_size: u64, // Used to calculate mass
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub node_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_data: Option<HashMap<String, String>>,
}

impl Node {
    pub fn new(id: String) -> Self {
        let mut node = Self {
            id: id.clone(),
            label: id,
            metadata: HashMap::new(),
            position: Some([0.0, 0.0, 0.0]),
            x: 0.0,
            y: 0.0,
            z: 0.0,
            vx: 0.0,
            vy: 0.0,
            vz: 0.0,
            file_size: 0,
            node_type: None,
            size: None,
            color: None,
            weight: None,
            group: None,
            user_data: None,
        };
        node.update_position();
        node
    }

    pub fn position(&self) -> [f32; 3] {
        [self.x, self.y, self.z]
    }

    pub fn velocity(&self) -> [f32; 3] {
        [self.vx, self.vy, self.vz]
    }

    fn update_position(&mut self) {
        self.position = Some([self.x, self.y, self.z]);
    }

    /// Convert file size to quantized mass value (0-255)
    fn calculate_mass(&self) -> u8 {
        // Scale file size logarithmically to 0-255 range
        // Assuming file sizes from 0 to ~1GB
        if self.file_size == 0 {
            return 127; // Default mass for nodes without size
        }
        let log_size = (self.file_size as f64).log2();
        let max_log = (1024.0 * 1024.0 * 1024.0_f64).log2(); // 1GB
        let normalized = (log_size / max_log).min(1.0);
        (normalized * 255.0) as u8
    }

    pub fn to_gpu_node(&self) -> GPUNode {
        GPUNode {
            x: self.x,
            y: self.y,
            z: self.z,
            vx: self.vx,
            vy: self.vy,
            vz: self.vz,
            mass: self.calculate_mass(),
            flags: 0,
            padding: [0; 2],
        }
    }

    pub fn update_from_gpu_node(&mut self, gpu_node: &GPUNode) {
        self.x = gpu_node.x;
        self.y = gpu_node.y;
        self.z = gpu_node.z;
        self.vx = gpu_node.vx;
        self.vy = gpu_node.vy;
        self.vz = gpu_node.vz;
        self.update_position();
    }

    pub fn to_position_update(&self) -> NodePositionVelocity {
        NodePositionVelocity {
            x: self.x,
            y: self.y,
            z: self.z,
            vx: self.vx,
            vy: self.vy,
            vz: self.vz,
        }
    }

    pub fn update_from_position_update(&mut self, update: &NodePositionVelocity) {
        self.x = update.x;
        self.y = update.y;
        self.z = update.z;
        self.vx = update.vx;
        self.vy = update.vy;
        self.vz = update.vz;
        self.update_position();
    }
}

impl Default for Node {
    fn default() -> Self {
        Self {
            id: String::new(),
            label: String::new(),
            metadata: HashMap::new(),
            position: Some([0.0, 0.0, 0.0]),
            x: 0.0,
            y: 0.0,
            z: 0.0,
            vx: 0.0,
            vy: 0.0,
            vz: 0.0,
            file_size: 0,
            node_type: None,
            size: None,
            color: None,
            weight: None,
            group: None,
            user_data: None,
        }
    }
}

/// GPU-compatible representation of a node, matching WGSL layout.
/// WGSL struct:
/// ```wgsl
/// struct Node {
///     position: vec3<f32>,  // 12 bytes
///     velocity: vec3<f32>,  // 12 bytes
///     mass: u8,            // 1 byte (quantized from file size)
///     flags: u8,           // 1 byte (can be used for node state)
///     padding: vec2<u8>,   // 2 bytes to align to 28 bytes total
/// }
/// ```
#[repr(C)]
#[derive(Clone, Copy, Pod, Zeroable)]
pub struct GPUNode {
    // position (vec3<f32>)
    pub x: f32,
    pub y: f32,
    pub z: f32,
    // velocity (vec3<f32>)
    pub vx: f32,
    pub vy: f32,
    pub vz: f32,
    // Additional fields packed into 4 bytes
    pub mass: u8,    // Quantized mass from file size
    pub flags: u8,   // Node state flags
    pub padding: [u8; 2], // Padding for alignment
}

----
models/mod.rs
// models/mod.rs
pub mod graph;
pub mod node;
pub mod edge;
pub mod metadata;
pub mod simulation_params;
pub mod position_update;  // Add position_update module

----
models/metadata.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Stores metadata about a processed file.
/// All fields use camelCase serialization for client compatibility.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct Metadata {
    #[serde(default)]
    pub file_name: String,
    #[serde(default)]
    pub file_size: usize,
    #[serde(default)]
    pub node_size: f64,
    #[serde(default)]
    pub hyperlink_count: usize,
    #[serde(default)]
    pub sha1: String,
    #[serde(default = "Utc::now")]
    pub last_modified: DateTime<Utc>,
    #[serde(default)]
    pub perplexity_link: String,
    #[serde(default)]
    pub last_perplexity_process: Option<DateTime<Utc>>,
    #[serde(default)]
    pub topic_counts: HashMap<String, usize>,
}

/// Type alias for metadata storage with camelCase keys
pub type MetadataStore = HashMap<String, Metadata>;

// Implement helper methods directly on HashMap<String, Metadata>
pub trait MetadataOps {
    fn validate_files(&self, markdown_dir: &str) -> bool;
}

impl MetadataOps for MetadataStore {
    fn validate_files(&self, markdown_dir: &str) -> bool {
        if self.is_empty() {
            return false;
        }

        // Check if the markdown files referenced in metadata actually exist
        for filename in self.keys() {
            let file_path = format!("{}/{}", markdown_dir, filename);
            if !std::path::Path::new(&file_path).exists() {
                return false;
            }
        }
        
        true
    }
}

----
models/edge.rs
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use crate::models::node::Node;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Edge {
    pub source: String,
    pub target: String,
    #[serde(skip_deserializing)]
    pub id: String,  // Added id field, skip deserializing as we generate it
    pub weight: f32,
    pub width: Option<f32>,
    pub color: Option<String>,
    #[serde(rename = "type")]
    pub edge_type: Option<String>,
    pub metadata: Option<HashMap<String, String>>,
    pub user_data: Option<HashMap<String, String>>,
    pub directed: Option<bool>,
}

// GPU representation of an edge, must match the shader's Edge struct
#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
pub struct GPUEdge {
    pub source: u32,      // 4 bytes
    pub target_idx: u32,  // 4 bytes
    pub weight: f32,      // 4 bytes
    pub padding1: u32,    // 4 bytes
    pub padding2: u32,    // 4 bytes
    pub padding3: u32,    // 4 bytes
    pub padding4: u32,    // 4 bytes
    pub padding5: u32,    // 4 bytes
}

impl Edge {
    pub fn new(source: String, target: String, weight: f32) -> Self {
        Self {
            id: format!("{}-{}", source, target),  // Generate id from source and target
            source,
            target,
            weight,
            width: None,
            color: None,
            edge_type: None,
            metadata: None,
            user_data: None,
            directed: Some(false),
        }
    }

    pub fn to_gpu_edge(&self, nodes: &[Node]) -> GPUEdge {
        // Create a temporary HashMap for efficient lookups
        let node_map: HashMap<_, _> = nodes.iter()
            .enumerate()
            .map(|(i, node)| (node.id.clone(), i as u32))
            .collect();

        let source_idx = node_map.get(&self.source).copied().unwrap_or(0);
        let target_idx = node_map.get(&self.target).copied().unwrap_or(0);

        GPUEdge {
            source: source_idx,
            target_idx,
            weight: self.weight,
            padding1: 0,
            padding2: 0,
            padding3: 0,
            padding4: 0,
            padding5: 0,
        }
    }
}

----
models/simulation_params.rs
use serde::{Deserialize, Serialize};
use bytemuck::{Pod, Zeroable};

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum SimulationMode {
    Remote,  // GPU-accelerated remote computation
    GPU,     // Local GPU computation
    Local,   // CPU-based computation
}

impl Default for SimulationMode {
    fn default() -> Self {
        SimulationMode::Remote
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum SimulationPhase {
    Initial,    // Heavy computation for initial layout
    Dynamic,    // Lighter computation for dynamic updates
    Finalize,   // Final positioning and cleanup
}

impl Default for SimulationPhase {
    fn default() -> Self {
        SimulationPhase::Initial
    }
}

// GPU-compatible simulation parameters
#[repr(C)]
#[derive(Default, Clone, Copy, Pod, Zeroable, Debug)]
pub struct GPUSimulationParams {
    pub iterations: u32,
    pub spring_length: f32,
    pub spring_strength: f32,
    pub repulsion: f32,
    pub attraction: f32,
    pub damping: f32,
    pub time_step: f32,
    pub padding: u32,  // For alignment
}

#[derive(Default, Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct SimulationParams {
    pub iterations: u32,           // Range: 1-500, Default: varies by phase
    pub spring_length: f32,        // Range: 10-500, Default: 100
    pub spring_strength: f32,      // Range: 0.1-10, Default: 0.5
    pub repulsion: f32,           // Range: 1-1000, Default: 100
    pub attraction: f32,          // Range: 0.1-10, Default: 1.0
    pub damping: f32,             // Range: 0-1, Default: 0.5
    pub time_step: f32,           // Range: 0.01-1, Default: 0.016 (60fps)
    pub phase: SimulationPhase,   // Current simulation phase
    pub mode: SimulationMode,     // Computation mode
}

impl SimulationParams {
    pub fn new() -> Self {
        Self {
            iterations: 100,
            spring_length: 100.0,
            spring_strength: 0.5,
            repulsion: 100.0,
            attraction: 1.0,
            damping: 0.5,
            time_step: 0.016,
            phase: SimulationPhase::Initial,
            mode: SimulationMode::Remote,
        }
    }

    pub fn with_phase(phase: SimulationPhase) -> Self {
        match phase {
            SimulationPhase::Initial => Self {
                iterations: 500,
                spring_length: 100.0,
                spring_strength: 1.0,
                repulsion: 200.0,
                attraction: 2.0,
                damping: 0.9,
                time_step: 0.016,
                phase,
                mode: SimulationMode::Remote,
            },
            SimulationPhase::Dynamic => Self {
                iterations: 50,
                spring_length: 100.0,
                spring_strength: 0.5,
                repulsion: 100.0,
                attraction: 1.0,
                damping: 0.5,
                time_step: 0.016,
                phase,
                mode: SimulationMode::Remote,
            },
            SimulationPhase::Finalize => Self {
                iterations: 200,
                spring_length: 100.0,
                spring_strength: 0.1,
                repulsion: 50.0,
                attraction: 0.5,
                damping: 0.95,
                time_step: 0.016,
                phase,
                mode: SimulationMode::Remote,
            },
        }
    }

    // Convert to GPU-compatible parameters
    pub fn to_gpu_params(&self) -> GPUSimulationParams {
        GPUSimulationParams {
            iterations: self.iterations,
            spring_length: self.spring_length,
            spring_strength: self.spring_strength,
            repulsion: self.repulsion,
            attraction: self.attraction,
            damping: self.damping,
            time_step: self.time_step,
            padding: 0,
        }
    }
}

----
handlers/file_handler.rs
use actix_web::{web, Error as ActixError, HttpResponse};
use serde_json::json;
use log::{info, debug, error};

use crate::AppState;
use crate::services::file_service::{FileService, MARKDOWN_DIR};
use crate::services::graph_service::GraphService;

pub async fn fetch_and_process_files(state: web::Data<AppState>) -> HttpResponse {
    info!("Initiating optimized file fetch and processing");

    // Load or create metadata
    let mut metadata_store = match FileService::load_or_create_metadata() {
        Ok(store) => store,
        Err(e) => {
            error!("Failed to load or create metadata: {}", e);
            return HttpResponse::InternalServerError().json(json!({
                "status": "error",
                "message": format!("Failed to initialize metadata: {}", e)
            }));
        }
    };
    
    // Process files with optimized approach
    match FileService::fetch_and_process_files(&*state.github_service, state.settings.clone(), &mut metadata_store).await {
        Ok(processed_files) => {
            let file_names: Vec<String> = processed_files.iter()
                .map(|pf| pf.file_name.clone())
                .collect();

            info!("Successfully processed {} public markdown files", processed_files.len());

            // Update metadata store
            {
                let mut metadata = state.metadata.write().await;
                for processed_file in &processed_files {
                    metadata_store.insert(processed_file.file_name.clone(), processed_file.metadata.clone());
                    debug!("Updated metadata for: {}", processed_file.file_name);
                }
                *metadata = metadata_store.clone();
            }

            // Save the updated metadata
            if let Err(e) = FileService::save_metadata(&metadata_store) {
                error!("Failed to save metadata: {}", e);
                return HttpResponse::InternalServerError().json(json!({
                    "status": "error",
                    "message": format!("Failed to save metadata: {}", e)
                }));
            }

            // Update graph with processed files
            match GraphService::build_graph(&state).await {
                Ok(graph_data) => {
                    let mut graph = state.graph_service.graph_data.write().await;
                    *graph = graph_data.clone();
                    info!("Graph data structure updated successfully");

                    // Send binary position update to clients
                    if let Some(gpu) = &state.gpu_compute {
                        let gpu = gpu.clone();
                        let gpu_write = gpu.write().await;
                        match gpu_write.get_node_positions() {
                            Ok(nodes) => {
                                if let Some(ws_manager) = state.get_websocket_manager().await {
                                    if let Err(e) = ws_manager.broadcast_binary(&nodes, true).await {
                                        error!("Failed to broadcast binary update: {}", e);
                                    }
                                }
                            },
                            Err(e) => error!("Failed to get node positions: {}", e)
                        }
                    }

                    // Send metadata update separately as JSON
                    let metadata_msg = json!({
                        "type": "metadata_update",
                        "metadata": graph_data.metadata
                    });

                    if let Some(ws_manager) = state.get_websocket_manager().await {
                        if let Err(e) = ws_manager.broadcast_message(metadata_msg.to_string()).await {
                            error!("Failed to broadcast metadata update: {}", e);
                        }
                    }

                    HttpResponse::Ok().json(json!({
                        "status": "success",
                        "processed_files": file_names
                    }))
                },
                Err(e) => {
                    error!("Failed to build graph data: {}", e);
                    HttpResponse::InternalServerError().json(json!({
                        "status": "error",
                        "message": format!("Failed to build graph data: {}", e)
                    }))
                }
            }
        },
        Err(e) => {
            error!("Error processing files: {}", e);
            HttpResponse::InternalServerError().json(json!({
                "status": "error",
                "message": format!("Error processing files: {}", e)
            }))
        }
    }
}

pub async fn get_file_content(_state: web::Data<AppState>, file_name: web::Path<String>) -> HttpResponse {
    // Read file directly from disk
    let file_path = format!("{}/{}", MARKDOWN_DIR, file_name);
    match std::fs::read_to_string(&file_path) {
        Ok(content) => HttpResponse::Ok().body(content),
        Err(e) => {
            error!("Failed to read file {}: {}", file_name, e);
            HttpResponse::NotFound().json(json!({
                "status": "error",
                "message": format!("File not found or unreadable: {}", file_name)
            }))
        }
    }
}

pub async fn refresh_graph(state: web::Data<AppState>) -> HttpResponse {
    info!("Manually triggering graph refresh");

    // Load metadata from file
    let metadata_store = match FileService::load_or_create_metadata() {
        Ok(store) => store,
        Err(e) => {
            error!("Failed to load metadata: {}", e);
            return HttpResponse::InternalServerError().json(json!({
                "status": "error",
                "message": format!("Failed to load metadata: {}", e)
            }));
        }
    };

    // Build graph directly from metadata
    match GraphService::build_graph_from_metadata(&metadata_store).await {
        Ok(graph_data) => {
            let mut graph = state.graph_service.graph_data.write().await;
            *graph = graph_data.clone();
            info!("Graph data structure refreshed successfully");

            // Send binary position update to clients
            if let Some(gpu) = &state.gpu_compute {
                let gpu = gpu.clone();
                let gpu_write = gpu.write().await;
                match gpu_write.get_node_positions() {
                    Ok(nodes) => {
                        if let Some(ws_manager) = state.get_websocket_manager().await {
                            if let Err(e) = ws_manager.broadcast_binary(&nodes, true).await {
                                error!("Failed to broadcast binary update: {}", e);
                            }
                        }
                    },
                    Err(e) => error!("Failed to get node positions: {}", e)
                }
            }

            // Send metadata update separately as JSON
            let metadata_msg = json!({
                "type": "metadata_update",
                "metadata": graph_data.metadata
            });

            if let Some(ws_manager) = state.get_websocket_manager().await {
                if let Err(e) = ws_manager.broadcast_message(metadata_msg.to_string()).await {
                    error!("Failed to broadcast metadata update: {}", e);
                }
            }

            HttpResponse::Ok().json(json!({
                "status": "success",
                "message": "Graph refreshed successfully"
            }))
        },
        Err(e) => {
            error!("Failed to refresh graph data: {}", e);
            HttpResponse::InternalServerError().json(json!({
                "status": "error",
                "message": format!("Failed to refresh graph data: {}", e)
            }))
        }
    }
}

pub async fn update_graph(state: web::Data<AppState>) -> Result<HttpResponse, ActixError> {
    // Load metadata from file
    let metadata_store = match FileService::load_or_create_metadata() {
        Ok(store) => store,
        Err(e) => {
            error!("Failed to load metadata: {}", e);
            return Ok(HttpResponse::InternalServerError().json(json!({
                "status": "error",
                "message": format!("Failed to load metadata: {}", e)
            })));
        }
    };

    // Build graph directly from metadata
    match GraphService::build_graph_from_metadata(&metadata_store).await {
        Ok(graph) => {
            // Update graph data
            *state.graph_service.graph_data.write().await = graph.clone();
            
            // Send binary position update to clients
            if let Some(gpu) = &state.gpu_compute {
                let gpu = gpu.clone();
                let gpu_write = gpu.write().await;
                match gpu_write.get_node_positions() {
                    Ok(nodes) => {
                        if let Some(ws_manager) = state.get_websocket_manager().await {
                            if let Err(e) = ws_manager.broadcast_binary(&nodes, true).await {
                                error!("Failed to broadcast binary update: {}", e);
                            }
                        }
                    },
                    Err(e) => error!("Failed to get node positions: {}", e)
                }
            }

            // Send metadata update separately as JSON
            let metadata_msg = json!({
                "type": "metadata_update",
                "metadata": graph.metadata
            });

            if let Some(ws_manager) = state.get_websocket_manager().await {
                if let Err(e) = ws_manager.broadcast_message(metadata_msg.to_string()).await {
                    error!("Failed to broadcast metadata update: {}", e);
                }
            }
            
            Ok(HttpResponse::Ok().json(json!({
                "status": "success",
                "message": "Graph updated successfully"
            })))
        },
        Err(e) => {
            error!("Failed to build graph: {}", e);
            Ok(HttpResponse::InternalServerError().json(json!({
                "status": "error",
                "message": format!("Failed to build graph: {}", e)
            })))
        }
    }
}

----
handlers/mod.rs
pub mod file_handler;
pub mod graph_handler;
pub mod perplexity_handler;
pub mod ragflow_handler;
pub mod visualization_handler;
pub mod websocket_handlers;

// Re-export WebSocketSession
pub use websocket_handlers::WebSocketSession;

----
handlers/visualization_handler.rs
use crate::config::Settings;
use actix_web::{web, HttpResponse};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

pub async fn get_visualization_settings(
    settings: web::Data<Arc<Settings>>,
) -> HttpResponse {
    let settings_json = serde_json::json!({
        "visualization": {
            "nodeColor": settings.visualization.node_color,
            "edgeColor": settings.visualization.edge_color,
            "hologramColor": settings.visualization.hologram_color,
            "hologramScale": settings.visualization.hologram_scale,
            "hologramOpacity": settings.visualization.hologram_opacity,
            "edgeOpacity": settings.visualization.edge_opacity,
            "fogDensity": settings.visualization.fog_density,
            "forceDirectedIterations": settings.visualization.force_directed_iterations,
            "forceDirectedRepulsion": settings.visualization.force_directed_repulsion,
            "forceDirectedAttraction": settings.visualization.force_directed_attraction,
        },
        "bloom": {
            "nodeBloomStrength": settings.bloom.node_bloom_strength,
            "nodeBloomRadius": settings.bloom.node_bloom_radius,
            "nodeBloomThreshold": settings.bloom.node_bloom_threshold,
            "edgeBloomStrength": settings.bloom.edge_bloom_strength,
            "edgeBloomRadius": settings.bloom.edge_bloom_radius,
            "edgeBloomThreshold": settings.bloom.edge_bloom_threshold,
            "environmentBloomStrength": settings.bloom.environment_bloom_strength,
            "environmentBloomRadius": settings.bloom.environment_bloom_radius,
            "environmentBloomThreshold": settings.bloom.environment_bloom_threshold,
        },
        "fisheye": {
            "enabled": settings.fisheye.enabled,
            "strength": settings.fisheye.strength,
            "focusPoint": [
                settings.fisheye.focus_x,
                settings.fisheye.focus_y,
                settings.fisheye.focus_z
            ],
            "radius": settings.fisheye.radius,
        }
    });

    HttpResponse::Ok().json(settings_json)
}

// Register the handlers with the Actix web app
pub fn config(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/visualization")
            .route("/settings", web::get().to(get_visualization_settings))
    );
}

----
handlers/graph_handler.rs
use actix_web::{web, HttpResponse, Responder};
use crate::AppState;
use serde::Serialize;
use log::{info, debug};
use std::collections::HashMap;
use crate::models::metadata::Metadata;

/// Struct to serialize GraphData for HTTP responses.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphResponse {
    /// List of nodes in the graph.
    pub nodes: Vec<crate::models::node::Node>,
    /// List of edges connecting the nodes.
    pub edges: Vec<crate::models::edge::Edge>,
    /// Additional metadata about the graph.
    pub metadata: HashMap<String, Metadata>,
}

/// Handler to retrieve the current graph data.
///
/// This function performs the following steps:
/// 1. Reads the shared graph data from the application state.
/// 2. Serializes the graph data into JSON format.
/// 3. Returns the serialized graph data as an HTTP response.
///
/// # Arguments
///
/// * `state` - Shared application state.
///
/// # Returns
///
/// An HTTP response containing the graph data or an error.
pub async fn get_graph_data(state: web::Data<AppState>) -> impl Responder {
    info!("Received request for graph data");

    // Step 1: Acquire read access to the shared graph data.
    let graph = state.graph_service.graph_data.read().await;

    debug!("Preparing graph response with {} nodes and {} edges",
        graph.nodes.len(),
        graph.edges.len()
    );

    // Step 2: Prepare the response struct.
    let response = GraphResponse {
        nodes: graph.nodes.clone(),
        edges: graph.edges.clone(),
        metadata: graph.metadata.clone(),
    };

    // Step 3: Respond with the serialized graph data.
    HttpResponse::Ok().json(response)
}

----
handlers/ragflow_handler.rs
use actix_web::{web, HttpResponse, Error, ResponseError};
use crate::AppState;
use serde::{Serialize, Deserialize};
use log::{info, error};
use actix_web::web::Bytes;
use std::sync::Arc;
use futures::StreamExt;
use crate::services::ragflow_service::RAGFlowError;

#[derive(Serialize, Deserialize)]
pub struct MessageRequest {
    pub conversation_id: String,
    pub messages: Vec<Message>,
    pub quote: Option<bool>,
    pub doc_ids: Option<Vec<String>>,
    pub stream: Option<bool>,
}

#[derive(Serialize, Deserialize)]
pub struct Message {
    pub role: String,
    pub content: String,
}

#[derive(Serialize, Deserialize)]
pub struct InitChatRequest {
    pub user_id: String,
}

/// Response structure for initiating a chat.
#[derive(Serialize)]
pub struct InitChatResponse {
    pub success: bool,
    pub conversation_id: String,
    pub message: Option<String>,
}

// Implement ResponseError for RAGFlowError
impl ResponseError for RAGFlowError {
    fn error_response(&self) -> HttpResponse {
        HttpResponse::InternalServerError().json(serde_json::json!({
            "error": self.to_string()
        }))
    }
}

/// Handler for sending a message to the RAGFlow service.
pub async fn send_message(state: web::Data<AppState>, msg: web::Json<MessageRequest>) -> Result<HttpResponse, Error> {
    let message_content = msg.messages.last().unwrap().content.clone();
    let quote = msg.quote.unwrap_or(false);
    let doc_ids = msg.doc_ids.clone();
    let stream = msg.stream.unwrap_or(false);
    let conversation_id = msg.conversation_id.clone();

    info!("Sending message to RAGFlow: {}", message_content);
    info!("Quote: {}, Stream: {}, Doc IDs: {:?}", quote, stream, doc_ids);

    // Clone the Arc<RAGFlowService>
    let ragflow_service = Arc::clone(&state.ragflow_service);

    // Call the async send_message function
    match ragflow_service.send_message(conversation_id, message_content, quote, doc_ids, stream).await {
        Ok(response_stream) => {
            let mapped_stream = response_stream.map(|result| {
                result.map(|answer| {
                    let response = serde_json::json!({
                        "type": "ragflowResponse",
                        "data": {
                            "answer": answer
                        }
                    });
                    Bytes::from(serde_json::to_string(&response).unwrap())
                })
                .map_err(|e| actix_web::error::ErrorInternalServerError(e))
            });
            Ok(HttpResponse::Ok().streaming(mapped_stream))
        },
        Err(e) => {
            error!("Error sending message: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "error": format!("Failed to send message: {}", e)
            })))
        }
    }
}

/// Handler for initiating a new chat conversation.
pub async fn init_chat(state: web::Data<AppState>, req: web::Json<InitChatRequest>) -> HttpResponse {
    let user_id = &req.user_id;

    info!("Initializing chat for user: {}", user_id);

    match state.ragflow_service.create_conversation(user_id.clone()).await {
        Ok(conversation_id) => HttpResponse::Ok().json(InitChatResponse {
            success: true,
            conversation_id,
            message: None,
        }),
        Err(e) => {
            error!("Error initiating chat: {}", e);
            HttpResponse::InternalServerError().json(InitChatResponse {
                success: false,
                conversation_id: "".to_string(),
                message: Some(format!("Failed to initialize chat: {}", e)),
            })
        }
    }
}

/// Handler for retrieving chat history.
pub async fn get_chat_history(_state: web::Data<AppState>, path: web::Path<String>) -> HttpResponse {
    let conversation_id = path.into_inner();
    info!("Retrieving chat history for conversation: {}", conversation_id);

    // Note: We've removed the get_chat_history method from RAGFlowService
    // You may want to implement this functionality if needed
    HttpResponse::NotImplemented().json(serde_json::json!({
        "message": "Chat history retrieval is not implemented"
    }))
}

----
handlers/websocket_handlers.rs
use actix::prelude::*;
use actix_web::web;
use actix_web_actors::ws::WebsocketContext;
use bytestring::ByteString;
use bytemuck;
use futures::StreamExt;
use log::{debug, error, info, warn};
use serde_json::json;
use std::sync::{Arc, Mutex};
use tokio::time::Duration;
use actix_web_actors::ws;
use actix::StreamHandler;

use crate::AppState;
use crate::models::simulation_params::{SimulationMode, SimulationParams};
use crate::models::position_update::NodePositionVelocity;
use crate::utils::websocket_messages::{
    OpenAIMessage, SendBinary, SendText,
    ServerMessage, UpdatePositionsMessage,
};
use crate::utils::websocket_openai::OpenAIWebSocket;

pub const OPENAI_CONNECT_TIMEOUT: Duration = Duration::from_secs(5);
pub const GPU_UPDATE_INTERVAL: Duration = Duration::from_millis(16);

// Constants for binary protocol
const NODE_SIZE: usize = 6 * std::mem::size_of::<f32>(); // x, y, z, vx, vy, vz

// Helper function to convert positions to binary data
fn positions_to_binary(nodes: &[NodePositionVelocity]) -> Vec<u8> {
    let mut binary_data = Vec::with_capacity(nodes.len() * std::mem::size_of::<NodePositionVelocity>());
    for node in nodes {
        binary_data.extend_from_slice(bytemuck::bytes_of(node));
    }
    binary_data
}

// Helper function to send binary position update
fn send_binary_update(ctx: &mut WebsocketContext<WebSocketSession>, binary_data: Vec<u8>, is_initial: bool) {
    // Send message indicating binary update type
    let update_type = ServerMessage::BinaryPositionUpdate {
        is_initial_layout: is_initial
    };
    
    if let Ok(type_str) = serde_json::to_string(&update_type) {
        ctx.text(ByteString::from(type_str));
    }
    
    // Send the binary data
    ctx.binary(binary_data);
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct GpuUpdate;

pub struct WebSocketSession {
    pub state: web::Data<AppState>,
    pub tts_method: String,
    pub openai_ws: Option<Addr<OpenAIWebSocket>>,
    pub simulation_mode: SimulationMode,
    pub conversation_id: Option<Arc<Mutex<Option<String>>>>,
}

impl WebSocketSession {
    pub fn new(state: web::Data<AppState>) -> Self {
        Self {
            state,
            tts_method: String::from("local"),
            openai_ws: None,
            simulation_mode: SimulationMode::Remote,
            conversation_id: Some(Arc::new(Mutex::new(None))),
        }
    }

    fn validate_binary_data(&self, data: &[u8]) -> bool {
        let node_size = std::mem::size_of::<NodePositionVelocity>();
        if data.len() % node_size != 0 {
            warn!(
                "Invalid binary data length: {} (not a multiple of {})",
                data.len(),
                node_size
            );
            return false;
        }
        true
    }

    fn process_binary_update(&mut self, data: &[u8]) -> Result<(), String> {
        if !self.validate_binary_data(data) {
            return Err("Invalid binary data format".to_string());
        }

        let positions: Vec<NodePositionVelocity> = bytemuck::cast_slice(data).to_vec();
        if positions.is_empty() {
            warn!("Received empty positions array");
            return Ok(());
        }

        let state = self.state.clone();
        let positions = positions.clone();

        actix::spawn(async move {
            let mut graph = state.graph_service.graph_data.write().await;
            for (i, pos) in positions.iter().enumerate() {
                if i < graph.nodes.len() {
                    graph.nodes[i].x = pos.x;
                    graph.nodes[i].y = pos.y;
                    graph.nodes[i].z = pos.z;
                    graph.nodes[i].vx = pos.vx;
                    graph.nodes[i].vy = pos.vy;
                    graph.nodes[i].vz = pos.vz;
                    graph.nodes[i].position = Some([pos.x, pos.y, pos.z]);
                }
            }
            debug!("Updated {} node positions", positions.len());
        });

        Ok(())
    }

    fn handle_position_update(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, msg: UpdatePositionsMessage) {
        let state = self.state.clone();
        let ctx_addr = ctx.address();

        let fut = async move {
            debug!("Processing position update for {} nodes", msg.nodes.len());

            // Update graph data with new positions
            {
                let mut graph = state.graph_service.graph_data.write().await;
                for node_pos in &msg.nodes {
                    if let Some(node) = graph.nodes.iter_mut().find(|n| n.id == node_pos.id) {
                        node.x = node_pos.position[0];
                        node.y = node_pos.position[1];
                        node.z = node_pos.position[2];
                        node.vx = 0.0;
                        node.vy = 0.0;
                        node.vz = 0.0;
                        node.position = Some(node_pos.position);
                    }
                }
            }

            // Send completion message
            let completion = ServerMessage::PositionUpdateComplete {
                status: "success".to_string(),
            };
            if let Ok(completion_str) = serde_json::to_string(&completion) {
                ctx_addr.do_send(SendText(completion_str));
            }
        };

        ctx.spawn(fut.into_actor(self));
    }

    fn handle_layout(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, _params: SimulationParams) {
        let state = self.state.clone();
        let ctx_addr = ctx.address();

        let fut = async move {
            let graph = state.graph_service.graph_data.write().await;
            
            // Update positions
            let nodes: Vec<NodePositionVelocity> = graph.nodes.iter().map(|node| NodePositionVelocity {
                x: node.x,
                y: node.y,
                z: node.z,
                vx: node.vx,
                vy: node.vy,
                vz: node.vz,
            }).collect();
            
            let binary_data = positions_to_binary(&nodes);
            
            // Send binary update type first
            let update_type = ServerMessage::BinaryPositionUpdate {
                is_initial_layout: true
            };
            
            if let Ok(type_str) = serde_json::to_string(&update_type) {
                ctx_addr.do_send(SendText(type_str));
            }
            
            // Then send binary data
            ctx_addr.do_send(SendBinary(binary_data));

            // Send completion message
            let completion = json!({
                "type": "completion",
                "message": "Layout update complete"
            });
            if let Ok(completion_str) = serde_json::to_string(&completion) {
                ctx_addr.do_send(SendText(completion_str));
            }
        };

        ctx.spawn(fut.into_actor(self));
    }

    fn handle_chat_message(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, message: String, use_openai: bool) {
        let state = self.state.clone();
        let conversation_id = self.conversation_id.clone();
        let ctx_addr = ctx.address();
        let settings = self.state.settings.clone();
        let weak_addr = ctx.address().downgrade();

        let fut = async move {
            let conv_id = if let Some(conv_arc) = conversation_id {
                let mut lock = conv_arc.lock().unwrap();
                if let Some(ref id) = *lock {
                    id.clone()
                } else {
                    match state.ragflow_service.create_conversation("default_user".to_string()).await {
                        Ok(new_id) => {
                            *lock = Some(new_id.clone());
                            new_id
                        },
                        Err(e) => {
                            error!("Failed to create conversation: {}", e);
                            return;
                        }
                    }
                }
            } else {
                error!("Failed to acquire conversation ID");
                return;
            };

            match state.ragflow_service.send_message(
                conv_id.clone(),
                message.clone(),
                false,
                None,
                false,
            ).await {
                Ok(mut stream) => {
                    debug!("RAGFlow service initialized for conversation {}", conv_id);
                    
                    if let Some(result) = stream.next().await {
                        match result {
                            Ok(text) => {
                                debug!("Received text response from RAGFlow: {}", text);
                                
                                if use_openai {
                                    debug!("Creating OpenAI WebSocket for TTS");
                                    let openai_ws = OpenAIWebSocket::new(ctx_addr.clone(), settings);
                                    let addr = openai_ws.start();
                                    
                                    debug!("Waiting for OpenAI WebSocket to be ready");
                                    tokio::time::sleep(OPENAI_CONNECT_TIMEOUT).await;
                                    
                                    debug!("Sending text to OpenAI TTS: {}", text);
                                    addr.do_send(OpenAIMessage(text));
                                } else {
                                    debug!("Using local TTS service");
                                    // Get read lock on speech service
                                    if let Some(speech_service) = state.get_speech_service().await {
                                        if let Err(e) = speech_service.send_message(text).await {
                                            error!("Failed to generate speech: {}", e);
                                            let error_message = ServerMessage::Error {
                                                message: format!("Failed to generate speech: {}", e),
                                                code: Some("SPEECH_GENERATION_ERROR".to_string()),
                                                details: Some("Error occurred while generating speech using local TTS service".to_string()),
                                            };
                                            if let Ok(error_str) = serde_json::to_string(&error_message) {
                                                ctx_addr.do_send(SendText(error_str));
                                            }
                                        }
                                    } else {
                                        error!("Speech service not initialized");
                                        let error_message = ServerMessage::Error {
                                            message: "Speech service not initialized".to_string(),
                                            code: Some("SPEECH_SERVICE_ERROR".to_string()),
                                            details: Some("Speech service is not available".to_string()),
                                        };
                                        if let Ok(error_str) = serde_json::to_string(&error_message) {
                                            ctx_addr.do_send(SendText(error_str));
                                        }
                                    }
                                }
                            },
                            Err(e) => {
                                error!("Error processing RAGFlow response: {}", e);
                                let error_message = ServerMessage::Error {
                                    message: format!("Error processing RAGFlow response: {}", e),
                                    code: Some("RAGFLOW_PROCESSING_ERROR".to_string()),
                                    details: Some("Failed to process the response from RAGFlow service".to_string()),
                                };
                                if let Ok(error_str) = serde_json::to_string(&error_message) {
                                    ctx_addr.do_send(SendText(error_str));
                                }
                            }
                        }
                    }
                },
                Err(e) => {
                    error!("Failed to send message to RAGFlow: {}", e);
                    let error_message = ServerMessage::Error {
                        message: format!("Failed to send message to RAGFlow: {}", e),
                        code: Some("RAGFLOW_SEND_ERROR".to_string()),
                        details: Some("Error occurred while sending message to RAGFlow service".to_string()),
                    };
                    if let Ok(error_str) = serde_json::to_string(&error_message) {
                        ctx_addr.do_send(SendText(error_str));
                    }
                }
            }

            if let Some(addr) = weak_addr.upgrade() {
                let completion = json!({
                    "type": "completion",
                    "message": "Chat message handled"
                });
                if let Ok(completion_str) = serde_json::to_string(&completion) {
                    addr.do_send(SendText(completion_str));
                }
            }
        };

        ctx.spawn(fut.into_actor(self));
    }

    fn handle_simulation_mode(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, mode: &str) {
        self.simulation_mode = match mode {
            "remote" => {
                info!("Simulation mode set to Remote (GPU-accelerated)");
                self.start_gpu_updates(ctx);
                SimulationMode::Remote
            },
            "gpu" => {
                info!("Simulation mode set to GPU (local)");
                SimulationMode::GPU
            },
            "local" => {
                info!("Simulation mode set to Local (CPU)");
                SimulationMode::Local
            },
            _ => {
                error!("Invalid simulation mode: {}, defaulting to Remote", mode);
                SimulationMode::Remote
            }
        };

        let response = ServerMessage::SimulationModeSet {
            mode: mode.to_string(),
            gpu_enabled: matches!(self.simulation_mode, SimulationMode::Remote | SimulationMode::GPU),
        };
        if let Ok(response_str) = serde_json::to_string(&response) {
            ctx.text(ByteString::from(response_str));
        }
    }

    fn start_gpu_updates(&self, ctx: &mut WebsocketContext<WebSocketSession>) {
        let addr = ctx.address();
        ctx.run_interval(GPU_UPDATE_INTERVAL, move |_, _| {
            addr.do_send(GpuUpdate);
        });
    }
}

impl Actor for WebSocketSession {
    type Context = WebsocketContext<Self>;

    fn started(&mut self, _ctx: &mut Self::Context) {
        info!("WebSocket session started");
    }

    fn stopped(&mut self, _: &mut Self::Context) {
        info!("WebSocket session stopped");
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                debug!("Ping received");
                ctx.pong(&msg);
            }
            Ok(ws::Message::Pong(_)) => {
                debug!("Pong received");
            }
            Ok(ws::Message::Text(text)) => {
                debug!("Text message received: {}", text);
                if let Ok(value) = serde_json::from_str::<serde_json::Value>(&text) {
                    match value.get("type").and_then(|t| t.as_str()) {
                        Some("updatePositions") => {
                            if let Ok(update_msg) = serde_json::from_value::<UpdatePositionsMessage>(value) {
                                self.handle_position_update(ctx, update_msg);
                            }
                        }
                        Some("chat") => {
                            if let Some(message) = value.get("message").and_then(|m| m.as_str()) {
                                let use_openai = value.get("use_openai")
                                    .and_then(|o| o.as_bool())
                                    .unwrap_or(false);
                                self.handle_chat_message(ctx, message.to_string(), use_openai);
                            }
                        }
                        Some("simulation_mode") => {
                            if let Some(mode) = value.get("mode").and_then(|m| m.as_str()) {
                                self.handle_simulation_mode(ctx, mode);
                            }
                        }
                        Some("layout") => {
                            if let Ok(params) = serde_json::from_value::<SimulationParams>(value["params"].clone()) {
                                self.handle_layout(ctx, params);
                            }
                        }
                        Some("initial_data") => {
                            let addr = ctx.address();
                            let state = self.state.clone();
                            actix::spawn(async move {
                                let graph = state.graph_service.graph_data.read().await;
                                let settings = state.settings.read().await;

                                let initial_data = ServerMessage::InitialData {
                                    graph_data: (*graph).clone(),
                                    settings: serde_json::to_value(&*settings).unwrap_or_default(),
                                };

                                if let Ok(initial_data_str) = serde_json::to_string(&initial_data) {
                                    addr.do_send(SendText(initial_data_str));
                                }
                            });

                            self.simulation_mode = SimulationMode::Remote;
                            self.start_gpu_updates(ctx);
                        }
                        _ => {
                            error!("Unknown message type received");
                            let error_message = ServerMessage::Error {
                                message: "Unknown message type".to_string(),
                                code: Some("UNKNOWN_MESSAGE_TYPE".to_string()),
                                details: Some("The received message type is not recognized by the server".to_string()),
                            };
                            if let Ok(error_str) = serde_json::to_string(&error_message) {
                                ctx.text(ByteString::from(error_str));
                            }
                        }
                    }
                }
            }
            Ok(ws::Message::Binary(bin)) => {
                debug!("Binary message received: {} bytes", bin.len());
                match self.process_binary_update(&bin) {
                    Ok(_) => {
                        debug!("Binary update processed successfully");
                    },
                    Err(e) => {
                        error!("Failed to process binary update: {}", e);
                        let error_message = ServerMessage::Error {
                            message: format!("Binary update processing failed: {}", e),
                            code: Some("BINARY_UPDATE_ERROR".to_string()),
                            details: Some("Error occurred while processing binary position update data".to_string()),
                        };
                        if let Ok(error_str) = serde_json::to_string(&error_message) {
                            ctx.text(ByteString::from(error_str));
                        }
                    }
                }
            }
            Ok(ws::Message::Close(reason)) => {
                info!("Client disconnected: {:?}", reason);
                ctx.close(reason);
                ctx.stop();
            }
            Ok(ws::Message::Continuation(_)) => {
                debug!("Continuation frame received");
            }
            Ok(ws::Message::Nop) => {
                debug!("Nop frame received");
            }
            Err(e) => {
                error!("Error in WebSocket message handling: {}", e);
                ctx.stop();
            }
        }
    }
}

impl Handler<SendBinary> for WebSocketSession {
    type Result = ();

    fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
        let num_nodes = msg.0.len() / NODE_SIZE;
        debug!("[WebSocketSession] Sending binary message: {} nodes, size={} bytes", 
            num_nodes, msg.0.len());
        
        // Send binary update type first
        let update_type = ServerMessage::BinaryPositionUpdate {
            is_initial_layout: false
        };
        
        if let Ok(type_str) = serde_json::to_string(&update_type) {
            ctx.text(ByteString::from(type_str));
        }
        
        // Then send binary data
        ctx.binary(msg.0);
    }
}

impl Handler<SendText> for WebSocketSession {
    type Result = ();

    fn handle(&mut self, msg: SendText, ctx: &mut Self::Context) {
        ctx.text(msg.0);
    }
}

impl Handler<GpuUpdate> for WebSocketSession {
    type Result = ();

    fn handle(&mut self, _: GpuUpdate, ctx: &mut Self::Context) {
        let state = self.state.clone();
        let ctx_addr = ctx.address();
        
        actix::spawn(async move {
            let graph = state.graph_service.graph_data.read().await;
            let nodes: Vec<NodePositionVelocity> = graph.nodes.iter().map(|node| NodePositionVelocity {
                x: node.x,
                y: node.y,
                z: node.z,
                vx: node.vx,
                vy: node.vy,
                vz: node.vz,
            }).collect();
            
            let binary_data = positions_to_binary(&nodes);
            ctx_addr.do_send(SendBinary(binary_data));
        });
    }
}

----
handlers/perplexity_handler.rs
use crate::app_state::AppState;
use crate::models::metadata::MetadataStore;
use crate::services::file_service::ProcessedFile;
use crate::services::perplexity_service::PerplexityService;
use actix_web::{post, web, HttpResponse, Responder};
use log::{error, info};
use serde::{Deserialize, Serialize};
use std::error::Error as StdError;

#[derive(Debug, Serialize, Deserialize)]
pub struct PerplexityRequest {
    pub file_name: String,
}

pub struct PerplexityHandler;

impl PerplexityHandler {
    pub async fn process_file(
        file_name: String,
        perplexity_service: &PerplexityService,
        metadata_store: &mut MetadataStore,
    ) -> Result<ProcessedFile, Box<dyn StdError + Send + Sync>> {
        info!("Processing file with Perplexity: {}", file_name);
        
        let processed_file = perplexity_service.process_file(&file_name).await?;
        
        // Update metadata store with processed file's metadata
        metadata_store.insert(file_name.clone(), processed_file.metadata.clone());
        
        Ok(processed_file)
    }
}

#[post("")]
pub async fn handle_perplexity(
    data: web::Json<PerplexityRequest>,
    app_state: web::Data<AppState>,
) -> impl Responder {
    let file_name = data.file_name.clone();
    
    let mut metadata_store = app_state.metadata.write().await;
    
    match PerplexityHandler::process_file(
        file_name,
        &app_state.perplexity_service,
        &mut metadata_store,
    ).await {
        Ok(processed_file) => HttpResponse::Ok().json(processed_file),
        Err(e) => {
            error!("Failed to process file with Perplexity: {}", e);
            HttpResponse::InternalServerError().json("Failed to process file")
        }
    }
}

----
services/perplexity_service.rs
use crate::config::Settings;
use crate::models::metadata::Metadata;
use crate::services::file_service::ProcessedFile;
use chrono::Utc;
use log::{error, info};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::error::Error as StdError;
use std::fs;
use std::path::Path;
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;

const MARKDOWN_DIR: &str = "data/markdown";

#[derive(Debug, Serialize, Deserialize)]
struct PerplexityResponse {
    content: String,
    link: String,
}

pub struct PerplexityService {
    client: Client,
    settings: Arc<RwLock<Settings>>,
}

impl PerplexityService {
    pub fn new(settings: Arc<RwLock<Settings>>) -> Result<Self, Box<dyn StdError + Send + Sync>> {
        let client = Client::builder()
            .timeout(std::time::Duration::from_secs(30))
            .build()?;

        Ok(Self { client, settings })
    }

    pub async fn process_file(&self, file_name: &str) -> Result<ProcessedFile, Box<dyn StdError + Send + Sync>> {
        let file_path = format!("{}/{}", MARKDOWN_DIR, file_name);
        if !Path::new(&file_path).exists() {
            return Err(format!("File not found: {}", file_name).into());
        }

        let content = fs::read_to_string(&file_path)?;
        let settings = self.settings.read().await;
        
        let api_url = format!("{}/process", settings.network.domain);
        info!("Sending request to Perplexity API: {}", api_url);

        let response = self.client
            .post(&api_url)
            .json(&content)
            .send()
            .await?;

        let status = response.status();
        if !status.is_success() {
            let error_text = response.text().await?;
            error!("Perplexity API error: Status: {}, Error: {}", status, error_text);
            return Err(format!("Perplexity API error: {}", error_text).into());
        }

        let perplexity_response: PerplexityResponse = response.json().await?;
        
        // Create metadata for processed file
        let metadata = Metadata {
            file_name: file_name.to_string(),
            file_size: perplexity_response.content.len(),
            node_size: 10.0, // Default size
            hyperlink_count: 0,
            sha1: String::new(),
            last_modified: Utc::now(),
            perplexity_link: perplexity_response.link,
            last_perplexity_process: Some(Utc::now()),
            topic_counts: HashMap::new(),
        };

        Ok(ProcessedFile {
            file_name: file_name.to_string(),
            content: perplexity_response.content,
            is_public: true,
            metadata,
        })
    }
}

----
services/file_service.rs
use crate::models::metadata::{Metadata, MetadataStore, MetadataOps};
use crate::models::graph::GraphData;
use crate::config::Settings;
use serde::{Deserialize, Serialize};
use reqwest::Client;
use async_trait::async_trait;
use log::{info, debug, error};
use regex::Regex;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::Path;
use chrono::{Utc, DateTime};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::error::Error as StdError;
use std::time::Duration;
use tokio::time::sleep;
use actix_web::web;

// Constants
const METADATA_PATH: &str = "data/markdown/metadata.json";
pub const MARKDOWN_DIR: &str = "data/markdown";
const GITHUB_API_DELAY: Duration = Duration::from_millis(100); // Rate limiting delay
const MIN_NODE_SIZE: f64 = 5.0;
const MAX_NODE_SIZE: f64 = 50.0;

#[derive(Serialize, Deserialize, Clone)]
pub struct GithubFile {
    pub name: String,
    pub path: String,
    pub sha: String,
    pub size: usize,
    pub url: String,
    pub download_url: String,
}

#[derive(Serialize, Deserialize, Clone, Eq, PartialEq, Hash)]
pub struct GithubFileMetadata {
    pub name: String,
    pub sha: String,
    pub download_url: String,
    pub etag: Option<String>,
    #[serde(with = "chrono::serde::ts_seconds_option")]
    pub last_checked: Option<DateTime<Utc>>,
    #[serde(with = "chrono::serde::ts_seconds_option")]
    pub last_modified: Option<DateTime<Utc>>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ProcessedFile {
    pub file_name: String,
    pub content: String,
    pub is_public: bool,
    pub metadata: Metadata,
}

// Structure to hold reference information
#[derive(Default)]
struct ReferenceInfo {
    direct_mentions: usize,
}

#[async_trait]
pub trait GitHubService: Send + Sync {
    async fn fetch_file_metadata(&self) -> Result<Vec<GithubFileMetadata>, Box<dyn StdError + Send + Sync>>;
    async fn get_download_url(&self, file_name: &str) -> Result<Option<String>, Box<dyn StdError + Send + Sync>>;
    async fn fetch_file_content(&self, download_url: &str) -> Result<String, Box<dyn StdError + Send + Sync>>;
    async fn get_file_last_modified(&self, file_path: &str) -> Result<DateTime<Utc>, Box<dyn StdError + Send + Sync>>;
}

pub struct RealGitHubService {
    client: Client,
    token: String,
    owner: String,
    repo: String,
    base_path: String,
    settings: Arc<RwLock<Settings>>,
}

impl RealGitHubService {
    pub fn new(
        token: String,
        owner: String,
        repo: String,
        base_path: String,
        settings: Arc<RwLock<Settings>>,
    ) -> Result<Self, Box<dyn StdError + Send + Sync>> {
        let client = Client::builder()
            .user_agent("rust-github-api")
            .timeout(Duration::from_secs(30))
            .build()?;

        // Trim any leading/trailing slashes from base_path
        let base_path = base_path.trim_matches('/').to_string();

        debug!("Initializing GitHub service with base_path: {}", base_path);

        Ok(Self {
            client,
            token,
            owner,
            repo,
            base_path,
            settings,
        })
    }
}

#[async_trait]
impl GitHubService for RealGitHubService {
    async fn fetch_file_metadata(&self) -> Result<Vec<GithubFileMetadata>, Box<dyn StdError + Send + Sync>> {
        let url = if self.base_path.is_empty() {
            format!(
                "https://api.github.com/repos/{}/{}/contents",
                self.owner, self.repo
            )
        } else {
            format!(
                "https://api.github.com/repos/{}/{}/contents/{}",
                self.owner, self.repo, self.base_path
            )
        };
        
        debug!("Fetching GitHub metadata from URL: {}", url);

        // Set headers exactly as in the working curl command
        let response = self.client.get(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .send()
            .await?;

        // Get status and headers for debugging
        let status = response.status();
        let headers = response.headers().clone();
        
        debug!("GitHub API response status: {}", status);
        debug!("GitHub API response headers: {:?}", headers);

        // Get response body
        let body = response.text().await?;
        
        // Log the first 1000 characters of the response for debugging
        debug!("GitHub API response preview: {}", &body[..body.len().min(1000)]);

        // Check for error response
        if !status.is_success() {
            let error_msg = match serde_json::from_str::<serde_json::Value>(&body) {
                Ok(error_json) => {
                    let msg = error_json["message"].as_str().unwrap_or("Unknown error");
                    format!("GitHub API error: {} - {}", status, msg)
                },
                Err(_) => format!("GitHub API error: {} - {}", status, body)
            };
            error!("{}", error_msg);
            return Err(error_msg.into());
        }

        // Parse response as array
        let contents: Vec<serde_json::Value> = match serde_json::from_str(&body) {
            Ok(parsed) => parsed,
            Err(e) => {
                error!("Failed to parse GitHub API response: {}", e);
                error!("Response body: {}", body);
                return Err(Box::new(e));
            }
        };

        let settings = self.settings.read().await;
        let debug_mode = settings.debug_mode;
        
        let mut markdown_files = Vec::new();
        
        for item in contents {
            if item["type"].as_str().unwrap_or("") == "file" && 
               item["name"].as_str().unwrap_or("").ends_with(".md") {
                let name = item["name"].as_str().unwrap_or("").to_string();
                
                // In debug mode, only process Debug Test Page.md and debug linked node.md
                if debug_mode && !name.contains("Debug Test Page") && !name.contains("debug linked node") {
                    continue;
                }
                
                debug!("Processing markdown file: {}", name);
                
                let last_modified = match self.get_file_last_modified(&format!("{}/{}", self.base_path, name)).await {
                    Ok(time) => Some(time),
                    Err(e) => {
                        error!("Failed to get last modified time for {}: {}", name, e);
                        None
                    }
                };
                
                markdown_files.push(GithubFileMetadata {
                    name,
                    sha: item["sha"].as_str().unwrap_or("").to_string(),
                    download_url: item["download_url"].as_str().unwrap_or("").to_string(),
                    etag: None,
                    last_checked: Some(Utc::now()),
                    last_modified,
                });
            }
        }

        if debug_mode {
            info!("Debug mode: Processing only debug test files");
        }

        debug!("Found {} markdown files", markdown_files.len());
        Ok(markdown_files)
    }

    async fn get_download_url(&self, file_name: &str) -> Result<Option<String>, Box<dyn StdError + Send + Sync>> {
        let url = if self.base_path.is_empty() {
            format!("https://api.github.com/repos/{}/{}/contents/{}", 
                self.owner, self.repo, file_name)
        } else {
            format!("https://api.github.com/repos/{}/{}/contents/{}/{}", 
                self.owner, self.repo, self.base_path, file_name)
        };

        let response = self.client.get(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .send()
            .await?;

        if response.status().is_success() {
            let file: GithubFile = response.json().await?;
            Ok(Some(file.download_url))
        } else {
            Ok(None)
        }
    }

    async fn fetch_file_content(&self, download_url: &str) -> Result<String, Box<dyn StdError + Send + Sync>> {
        let response = self.client.get(download_url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .send()
            .await?;

        let status = response.status();
        if !status.is_success() {
            let error_text = response.text().await?;
            error!("Failed to fetch file content. Status: {}, Error: {}", status, error_text);
            return Err(format!("Failed to fetch file content: {}", error_text).into());
        }

        let content = response.text().await?;
        Ok(content)
    }

    async fn get_file_last_modified(&self, file_path: &str) -> Result<DateTime<Utc>, Box<dyn StdError + Send + Sync>> {
        let url = format!(
            "https://api.github.com/repos/{}/{}/commits",
            self.owner, self.repo
        );

        let response = self.client.get(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .query(&[("path", file_path), ("per_page", "1")])
            .send()
            .await?;

        let status = response.status();
        if !status.is_success() {
            let error_text = response.text().await?;
            error!("Failed to get last modified time. Status: {}, Error: {}", status, error_text);
            return Ok(Utc::now()); // Fallback to current time
        }

        let commits: Vec<serde_json::Value> = response.json().await?;
        
        if let Some(last_commit) = commits.first() {
            if let Some(commit) = last_commit["commit"]["committer"]["date"].as_str() {
                if let Ok(date) = DateTime::parse_from_rfc3339(commit) {
                    return Ok(date.with_timezone(&Utc));
                }
            }
        }
        
        Ok(Utc::now())
    }
}

pub struct FileService;

impl FileService {
    /// Process uploaded file and return graph data
    pub async fn process_file_upload(&self, payload: web::Bytes) -> Result<GraphData, Box<dyn StdError + Send + Sync>> {
        let content = String::from_utf8(payload.to_vec())?;
        let metadata = Self::load_or_create_metadata()?;
        let mut graph_data = GraphData::new();
        
        // Create a temporary file to process
        let temp_filename = format!("temp_{}.md", Utc::now().timestamp());
        let temp_path = format!("{}/{}", MARKDOWN_DIR, temp_filename);
        fs::write(&temp_path, &content)?;

        // Extract references and create metadata
        let valid_nodes: Vec<String> = metadata.keys()
            .map(|name| name.trim_end_matches(".md").to_string())
            .collect();

        let references = Self::extract_references(&content, &valid_nodes);
        let topic_counts = Self::convert_references_to_topic_counts(references);

        // Create metadata for the uploaded file
        let file_size = content.len();
        let node_size = Self::calculate_node_size(file_size);
        let file_metadata = Metadata {
            file_name: temp_filename.clone(),
            file_size,
            node_size,
            hyperlink_count: Self::count_hyperlinks(&content),
            sha1: Self::calculate_sha1(&content),
            last_modified: Utc::now(),
            perplexity_link: String::new(),
            last_perplexity_process: None,
            topic_counts,
        };

        // Update graph data
        graph_data.metadata.insert(temp_filename.clone(), file_metadata);

        // Clean up temporary file
        if let Err(e) = fs::remove_file(&temp_path) {
            error!("Failed to remove temporary file: {}", e);
        }

        Ok(graph_data)
    }

    /// List available files
    pub async fn list_files(&self) -> Result<Vec<String>, Box<dyn StdError + Send + Sync>> {
        let metadata = Self::load_or_create_metadata()?;
        Ok(metadata.keys().cloned().collect())
    }

    /// Load a specific file and return graph data
    pub async fn load_file(&self, filename: &str) -> Result<GraphData, Box<dyn StdError + Send + Sync>> {
        let file_path = format!("{}/{}", MARKDOWN_DIR, filename);
        if !Path::new(&file_path).exists() {
            return Err(format!("File not found: {}", filename).into());
        }

        let content = fs::read_to_string(&file_path)?;
        let metadata = Self::load_or_create_metadata()?;
        let mut graph_data = GraphData::new();

        // Extract references and update metadata
        let valid_nodes: Vec<String> = metadata.keys()
            .map(|name| name.trim_end_matches(".md").to_string())
            .collect();

        let references = Self::extract_references(&content, &valid_nodes);
        let topic_counts = Self::convert_references_to_topic_counts(references);

        // Update or create metadata for the file
        let file_size = content.len();
        let node_size = Self::calculate_node_size(file_size);
        let file_metadata = Metadata {
            file_name: filename.to_string(),
            file_size,
            node_size,
            hyperlink_count: Self::count_hyperlinks(&content),
            sha1: Self::calculate_sha1(&content),
            last_modified: Utc::now(),
            perplexity_link: String::new(),
            last_perplexity_process: None,
            topic_counts,
        };

        // Update graph data
        graph_data.metadata.insert(filename.to_string(), file_metadata);
        
        Ok(graph_data)
    }

    /// Load metadata from file or create new if not exists
    pub fn load_or_create_metadata() -> Result<MetadataStore, Box<dyn StdError + Send + Sync>> {
        if Path::new(METADATA_PATH).exists() {
            let content = fs::read_to_string(METADATA_PATH)?;
            if !content.trim().is_empty() {
                return Ok(serde_json::from_str(&content)?);
            }
        }
        Ok(MetadataStore::new())
    }

    /// Calculate node size based on file size
    fn calculate_node_size(file_size: usize) -> f64 {
        // Use logarithmic scaling for node size
        let size = if file_size == 0 {
            MIN_NODE_SIZE
        } else {
            let log_size = (file_size as f64).ln();
            let min_log = 0f64;
            let max_log = (100_000f64).ln(); // Assuming 100KB as max expected size
            
            let normalized = (log_size - min_log) / (max_log - min_log);
            MIN_NODE_SIZE + normalized * (MAX_NODE_SIZE - MIN_NODE_SIZE)
        };
        
        size.max(MIN_NODE_SIZE).min(MAX_NODE_SIZE)
}

    /// Extract references to other files based on their names (case insensitive)
    fn extract_references(content: &str, valid_nodes: &[String]) -> HashMap<String, ReferenceInfo> {
        let mut references = HashMap::new();
        let content_lower = content.to_lowercase();
        
        for node_name in valid_nodes {
            let mut ref_info = ReferenceInfo::default();
            let node_name_lower = node_name.to_lowercase();
            
            // Create a regex pattern with word boundaries
            let pattern = format!(r"\b{}\b", regex::escape(&node_name_lower));
            if let Ok(re) = Regex::new(&pattern) {
                // Count case-insensitive matches of the filename
                let count = re.find_iter(&content_lower).count();
                
                // If we found any references, add them to the map
                if count > 0 {
                    debug!("Found {} references to {} in content", count, node_name);
                    ref_info.direct_mentions = count;
                    references.insert(format!("{}.md", node_name), ref_info);
                }
            }
        }
        
        references
    }

    fn convert_references_to_topic_counts(references: HashMap<String, ReferenceInfo>) -> HashMap<String, usize> {
        references.into_iter()
            .map(|(name, info)| {
                debug!("Converting reference for {} with {} mentions", name, info.direct_mentions);
                (name, info.direct_mentions)
            })
            .collect()
    }

    /// Initialize the local markdown directory and metadata structure.
    pub async fn initialize_local_storage(
        github_service: &dyn GitHubService,
        _settings: Arc<RwLock<Settings>>,
    ) -> Result<(), Box<dyn StdError + Send + Sync>> {
        info!("Checking local storage status");
        
        // Ensure required directories exist
        Self::ensure_directories()?;

        // Check if we already have a valid local setup
        if Self::has_valid_local_setup() {
            info!("Valid local setup found, skipping initialization");
            return Ok(());
        }

        info!("Initializing local storage with files from GitHub");

        // Step 1: Get all markdown files from GitHub
        let github_files = github_service.fetch_file_metadata().await?;
        info!("Found {} markdown files in GitHub", github_files.len());

        let mut file_sizes = HashMap::new();
        let mut file_contents = HashMap::new();
        let mut file_metadata = HashMap::new();
        let mut metadata_store = MetadataStore::new();
        
        // Step 2: First pass - collect all files and their contents
        for file_meta in github_files {
            match github_service.fetch_file_content(&file_meta.download_url).await {
                Ok(content) => {
                    // Check if file starts with "public:: true"
                    let first_line = content.lines().next().unwrap_or("").trim();
                    if first_line != "public:: true" {
                        debug!("Skipping non-public file: {}", file_meta.name);
                        continue;
                    }

                    let node_name = file_meta.name.trim_end_matches(".md").to_string();
                    file_sizes.insert(node_name.clone(), content.len());
                    file_contents.insert(node_name, content);
                    file_metadata.insert(file_meta.name.clone(), file_meta);
                }
                Err(e) => {
                    error!("Failed to fetch content for {}: {}", file_meta.name, e);
                }
            }
            sleep(GITHUB_API_DELAY).await;
        }

        // Get list of valid node names (filenames without .md)
        let valid_nodes: Vec<String> = file_contents.keys().cloned().collect();

        // Step 3: Second pass - extract references and create metadata
        for (node_name, content) in &file_contents {
            let file_name = format!("{}.md", node_name);
            let file_path = format!("{}/{}", MARKDOWN_DIR, file_name);
            
            // Calculate SHA1 of content
            let local_sha1 = Self::calculate_sha1(content);
            
            // Save file content
            fs::write(&file_path, content)?;

            // Extract references
            let references = Self::extract_references(content, &valid_nodes);
            let topic_counts = Self::convert_references_to_topic_counts(references);

            // Get GitHub metadata
            let github_meta = file_metadata.get(&file_name).unwrap();
            let last_modified = github_meta.last_modified.unwrap_or_else(|| Utc::now());

            // Calculate node size
            let file_size = *file_sizes.get(node_name).unwrap();
            let node_size = Self::calculate_node_size(file_size);

            // Create metadata entry
            let metadata = Metadata {
                file_name: file_name.clone(),
                file_size,
                node_size,
                hyperlink_count: Self::count_hyperlinks(content),
                sha1: local_sha1,
                last_modified,
                perplexity_link: String::new(),
                last_perplexity_process: None,
                topic_counts,
            };

            metadata_store.insert(file_name, metadata);
        }

        // Step 4: Save metadata
        info!("Saving metadata for {} public files", metadata_store.len());
        Self::save_metadata(&metadata_store)?;

        info!("Initialization complete. Processed {} public files", metadata_store.len());

        Ok(())
    }

    /// Check if we have a valid local setup
    fn has_valid_local_setup() -> bool {
        if let Ok(metadata_content) = fs::read_to_string(METADATA_PATH) {
            if metadata_content.trim().is_empty() {
                return false;
            }
            
            if let Ok(metadata) = serde_json::from_str::<MetadataStore>(&metadata_content) {
                return metadata.validate_files(MARKDOWN_DIR);
            }
        }
        false
    }

    /// Ensures all required directories exist
    fn ensure_directories() -> Result<(), Box<dyn StdError + Send + Sync>> {
        fs::create_dir_all(MARKDOWN_DIR)?;
        Ok(())
    }

    /// Handles incremental updates after initial setup
    pub async fn fetch_and_process_files(
        github_service: &dyn GitHubService,
        _settings: Arc<RwLock<Settings>>,
        metadata_store: &mut MetadataStore,
    ) -> Result<Vec<ProcessedFile>, Box<dyn StdError + Send + Sync>> {
        // Ensure directories exist before any operations
        Self::ensure_directories()?;

        // Get metadata for markdown files in target directory
        let github_files_metadata = github_service.fetch_file_metadata().await?;
        debug!("Fetched metadata for {} markdown files", github_files_metadata.len());

        let mut processed_files = Vec::new();

        // Save current metadata
        Self::save_metadata(metadata_store)?;

        // Clean up local files that no longer exist in GitHub
        let github_files: HashSet<_> = github_files_metadata.iter()
            .map(|meta| meta.name.clone())
            .collect();

        let local_files: HashSet<_> = metadata_store.keys().cloned().collect();
        let removed_files: Vec<_> = local_files.difference(&github_files).collect();

        for file_name in removed_files {
            let file_path = format!("{}/{}", MARKDOWN_DIR, file_name);
            if let Err(e) = fs::remove_file(&file_path) {
                error!("Failed to remove file {}: {}", file_path, e);
            }
            metadata_store.remove(file_name);
        }

        // Get list of valid node names (filenames without .md)
        let valid_nodes: Vec<String> = github_files_metadata.iter()
            .map(|f| f.name.trim_end_matches(".md").to_string())
            .collect();

        // Process files that need updating
        let files_to_process: Vec<_> = github_files_metadata.into_iter()
            .filter(|file_meta| {
                let local_meta = metadata_store.get(&file_meta.name);
                local_meta.map_or(true, |meta| meta.sha1 != file_meta.sha)
            })
            .collect();

        // Process each file
        for file_meta in files_to_process {
            match github_service.fetch_file_content(&file_meta.download_url).await {
                Ok(content) => {
                    let first_line = content.lines().next().unwrap_or("").trim();
                    if first_line != "public:: true" {
                        debug!("Skipping non-public file: {}", file_meta.name);
                        continue;
                    }

                    let file_path = format!("{}/{}", MARKDOWN_DIR, file_meta.name);
                    fs::write(&file_path, &content)?;

                    // Extract references
                    let references = Self::extract_references(&content, &valid_nodes);
                    let topic_counts = Self::convert_references_to_topic_counts(references);

                    // Calculate node size
                    let file_size = content.len();
                    let node_size = Self::calculate_node_size(file_size);

                    let new_metadata = Metadata {
                        file_name: file_meta.name.clone(),
                        file_size,
                        node_size,
                        hyperlink_count: Self::count_hyperlinks(&content),
                        sha1: Self::calculate_sha1(&content),
                        last_modified: file_meta.last_modified.unwrap_or_else(|| Utc::now()),
                        perplexity_link: String::new(),
                        last_perplexity_process: None,
                        topic_counts,
                    };

                    metadata_store.insert(file_meta.name.clone(), new_metadata.clone());
                    processed_files.push(ProcessedFile {
                        file_name: file_meta.name,
                        content,
                        is_public: true,
                        metadata: new_metadata,
                    });
                }
                Err(e) => {
                    error!("Failed to fetch content: {}", e);
                }
            }
            sleep(GITHUB_API_DELAY).await;
        }

        // Save updated metadata
        Self::save_metadata(metadata_store)?;

        Ok(processed_files)
    }

    /// Save metadata to file
    pub fn save_metadata(metadata: &MetadataStore) -> Result<(), Box<dyn StdError + Send + Sync>> {
        let json = serde_json::to_string_pretty(metadata)?;
        fs::write(METADATA_PATH, json)?;
        Ok(())
    }

    /// Calculate SHA1 hash of content
    fn calculate_sha1(content: &str) -> String {
        use sha1::{Sha1, Digest};
        let mut hasher = Sha1::new();
        hasher.update(content.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// Count hyperlinks in content
    fn count_hyperlinks(content: &str) -> usize {
        let re = Regex::new(r"\[([^\]]+)\]\(([^)]+)\)").unwrap();
        re.find_iter(content).count()
    }
}

----
services/graph_service.rs
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::RwLock;
use actix_web::web;
use log::{info, warn};
use rand::Rng;
use crate::models::graph::GraphData;
use crate::models::node::Node;
use crate::models::edge::Edge;
use crate::models::metadata::MetadataStore;
use crate::models::simulation_params::SimulationParams;
use crate::utils::gpu_compute::GPUCompute;
use crate::AppState;

pub struct GraphService {
    pub graph_data: Arc<RwLock<GraphData>>,
}

impl GraphService {
    pub fn new() -> Self {
        GraphService {
            graph_data: Arc::new(RwLock::new(GraphData::new())),
        }
    }

    pub async fn build_graph(state: &web::Data<AppState>) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
        let current_graph = state.graph_service.graph_data.read().await;
        let mut graph = GraphData::new();

        // Copy metadata from current graph
        graph.metadata = current_graph.metadata.clone();

        let mut edge_map = HashMap::new();

        // Create nodes from metadata entries
        let mut valid_nodes = HashSet::new();
        for file_name in graph.metadata.keys() {
            let node_id = file_name.trim_end_matches(".md").to_string();
            valid_nodes.insert(node_id);
        }

        // Create nodes for all valid node IDs
        for node_id in &valid_nodes {
            let mut node = Node::new(node_id.clone());
            
            // Get metadata for this node
            if let Some(metadata) = graph.metadata.get(&format!("{}.md", node_id)) {
                node.size = Some(metadata.node_size as f32);
                node.file_size = metadata.file_size as u64;
                node.label = node_id.clone(); // Set label to node ID (filename without .md)
                
                // Add metadata fields to node's metadata map
                node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
                node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
                node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
            }
            
            graph.nodes.push(node);
        }

        // Create edges from metadata topic counts
        for (source_file, metadata) in graph.metadata.iter() {
            let source_id = source_file.trim_end_matches(".md").to_string();
            
            // Process outbound links from this file to other topics
            for (target_file, count) in &metadata.topic_counts {
                let target_id = target_file.trim_end_matches(".md").to_string();
                
                // Only create edge if both nodes exist and they're different
                if source_id != target_id && valid_nodes.contains(&target_id) {
                    let edge_key = if source_id < target_id {
                        (source_id.clone(), target_id.clone())
                    } else {
                        (target_id.clone(), source_id.clone())
                    };

                    // Sum the weights for bi-directional references
                    edge_map.entry(edge_key)
                        .and_modify(|w| *w += *count as f32)
                        .or_insert(*count as f32);
                }
            }
        }

        // Convert edge map to edges
        graph.edges = edge_map.into_iter()
            .map(|((source, target), weight)| {
                Edge::new(source, target, weight)
            })
            .collect();

        // Initialize random positions for all nodes
        Self::initialize_random_positions(&mut graph);

        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
        Ok(graph)
    }

    fn initialize_random_positions(graph: &mut GraphData) {
        let mut rng = rand::thread_rng();
        let initial_radius = 30.0;
        
        for node in &mut graph.nodes {
            let theta = rng.gen_range(0.0..std::f32::consts::PI * 2.0);
            let phi = rng.gen_range(0.0..std::f32::consts::PI);
            let r = rng.gen_range(0.0..initial_radius);
            
            node.x = r * theta.cos() * phi.sin();
            node.y = r * theta.sin() * phi.sin();
            node.z = r * phi.cos();
            node.vx = 0.0;
            node.vy = 0.0;
            node.vz = 0.0;
            node.position = Some([node.x, node.y, node.z]);
        }
    }

    pub async fn build_graph_from_metadata(
        metadata: &MetadataStore
    ) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
        let mut graph = GraphData::new();
        let mut edge_map = HashMap::new();

        // First pass: Create nodes from files in metadata
        let mut valid_nodes = HashSet::new();
        for file_name in metadata.keys() {
            let node_id = file_name.trim_end_matches(".md").to_string();
            valid_nodes.insert(node_id);
        }

        // Create nodes for all valid node IDs
        for node_id in &valid_nodes {
            let mut node = Node::new(node_id.clone());
            
            // Get metadata for this node
            if let Some(metadata) = metadata.get(&format!("{}.md", node_id)) {
                node.size = Some(metadata.node_size as f32);
                node.file_size = metadata.file_size as u64;
                node.label = node_id.clone(); // Set label to node ID (filename without .md)
                
                // Add metadata fields to node's metadata map
                node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
                node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
                node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
            }
            
            graph.nodes.push(node);
        }

        // Store metadata in graph
        graph.metadata = metadata.clone();

        // Second pass: Create edges from topic counts
        for (source_file, metadata) in metadata.iter() {
            let source_id = source_file.trim_end_matches(".md").to_string();
            
            for (target_file, count) in &metadata.topic_counts {
                let target_id = target_file.trim_end_matches(".md").to_string();
                
                // Only create edge if both nodes exist and they're different
                if source_id != target_id && valid_nodes.contains(&target_id) {
                    let edge_key = if source_id < target_id {
                        (source_id.clone(), target_id.clone())
                    } else {
                        (target_id.clone(), source_id.clone())
                    };

                    edge_map.entry(edge_key)
                        .and_modify(|weight| *weight += *count as f32)
                        .or_insert(*count as f32);
                }
            }
        }

        // Convert edge map to edges
        graph.edges = edge_map.into_iter()
            .map(|((source, target), weight)| {
                Edge::new(source, target, weight)
            })
            .collect();

        // Initialize random positions
        Self::initialize_random_positions(&mut graph);

        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
        Ok(graph)
    }

    pub async fn calculate_layout(
        gpu_compute: &Option<Arc<RwLock<GPUCompute>>>,
        graph: &mut GraphData,
        params: &SimulationParams,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        match gpu_compute {
            Some(gpu) => {
                info!("Using GPU for layout calculation");
                let mut gpu_compute = gpu.write().await;
                
                // Only initialize positions for new graphs
                if graph.nodes.iter().all(|n| n.x == 0.0 && n.y == 0.0 && n.z == 0.0) {
                    Self::initialize_random_positions(graph);
                }
                
                gpu_compute.update_graph_data(graph)?;
                gpu_compute.update_simulation_params(params)?;
                
                // Run iterations with more frequent updates
                for _ in 0..params.iterations {
                    gpu_compute.step()?;
                    
                    // Update positions every iteration for smoother motion
                    let updated_nodes = gpu_compute.get_node_positions()?;
                    for (i, node) in graph.nodes.iter_mut().enumerate() {
                        node.update_from_gpu_node(&updated_nodes[i]);
                        
                        // Apply bounds
                        let max_coord = 100.0;
                        node.x = node.x.clamp(-max_coord, max_coord);
                        node.y = node.y.clamp(-max_coord, max_coord);
                        node.z = node.z.clamp(-max_coord, max_coord);
                        node.position = Some([node.x, node.y, node.z]);
                    }
                }
                Ok(())
            },
            None => {
                warn!("GPU not available. Falling back to CPU-based layout calculation.");
                Self::calculate_layout_cpu(graph, params.iterations, params.spring_strength, params.damping);
                Ok(())
            }
        }
    }

    fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) {
        let repulsion_strength = spring_strength * 10000.0;
        
        for _ in 0..iterations {
            // Calculate forces between nodes
            let mut forces = vec![(0.0, 0.0, 0.0); graph.nodes.len()];
            
            // Calculate repulsion forces
            for i in 0..graph.nodes.len() {
                for j in i+1..graph.nodes.len() {
                    let dx = graph.nodes[j].x - graph.nodes[i].x;
                    let dy = graph.nodes[j].y - graph.nodes[i].y;
                    let dz = graph.nodes[j].z - graph.nodes[i].z;
                    
                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
                    if distance > 0.0 {
                        let force = repulsion_strength / (distance * distance);
                        
                        let fx = dx * force / distance;
                        let fy = dy * force / distance;
                        let fz = dz * force / distance;
                        
                        forces[i].0 -= fx;
                        forces[i].1 -= fy;
                        forces[i].2 -= fz;
                        
                        forces[j].0 += fx;
                        forces[j].1 += fy;
                        forces[j].2 += fz;
                    }
                }
            }

            // Calculate spring forces along edges
            for edge in &graph.edges {
                // Find indices of source and target nodes
                let source_idx = graph.nodes.iter().position(|n| n.id == edge.source);
                let target_idx = graph.nodes.iter().position(|n| n.id == edge.target);
                
                if let (Some(si), Some(ti)) = (source_idx, target_idx) {
                    let source = &graph.nodes[si];
                    let target = &graph.nodes[ti];
                    
                    let dx = target.x - source.x;
                    let dy = target.y - source.y;
                    let dz = target.z - source.z;
                    
                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
                    if distance > 0.0 {
                        // Scale force by edge weight
                        let force = spring_strength * (distance - 30.0) * edge.weight;
                        
                        let fx = dx * force / distance;
                        let fy = dy * force / distance;
                        let fz = dz * force / distance;
                        
                        forces[si].0 += fx;
                        forces[si].1 += fy;
                        forces[si].2 += fz;
                        
                        forces[ti].0 -= fx;
                        forces[ti].1 -= fy;
                        forces[ti].2 -= fz;
                    }
                }
            }
            
            // Apply forces and update positions
            for (i, node) in graph.nodes.iter_mut().enumerate() {
                node.vx += forces[i].0;
                node.vy += forces[i].1;
                node.vz += forces[i].2;
                
                node.x += node.vx;
                node.y += node.vy;
                node.z += node.vz;
                
                node.vx *= damping;
                node.vy *= damping;
                node.vz *= damping;

                node.position = Some([node.x, node.y, node.z]);
            }
        }
    }
}

----
services/mod.rs
pub mod file_service;
pub mod github_service;
pub mod graph_service;
pub mod perplexity_service;
pub mod ragflow_service;
pub mod speech_service;

----
services/speech_service.rs
use tokio::sync::{mpsc, Mutex, RwLock};
use tokio_tungstenite::{connect_async, WebSocketStream, MaybeTlsStream};
use tungstenite::protocol::Message;
use tungstenite::http::Request;
use serde_json::json;
use std::sync::Arc;
use tokio::task;
use crate::config::Settings;
use log::{info, error, debug};
use futures::{SinkExt, StreamExt};
use std::error::Error;
use crate::utils::websocket_manager::WebSocketManager;
use crate::utils::websocket_messages::{ServerMessage};
use tokio::net::TcpStream;
use url::Url;
use actix_web::{web, Error as ActixError, HttpRequest, HttpResponse};
use actix_web_actors::ws;
use std::time::{Duration, Instant};
use actix::{StreamHandler, AsyncContext, Actor};
use std::process::{Command, Stdio};
use std::io::Write;
use base64::Engine as _;
use base64::engine::general_purpose::STANDARD as BASE64;

const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);
const CLIENT_TIMEOUT: Duration = Duration::from_secs(10);

#[derive(Debug, Clone)]
pub enum TTSProvider {
    OpenAI,
    Sonata,
}

#[derive(Debug)]
enum SpeechCommand {
    Initialize,
    SendMessage(String),
    Close,
    SetTTSProvider(TTSProvider),
}

pub struct SpeechService {
    sender: Arc<Mutex<mpsc::Sender<SpeechCommand>>>,
    websocket_manager: Arc<WebSocketManager>,
    settings: Arc<RwLock<Settings>>,
    tts_provider: Arc<RwLock<TTSProvider>>,
}

impl SpeechService {
    pub fn new(websocket_manager: Arc<WebSocketManager>, settings: Arc<RwLock<Settings>>) -> Self {
        let (tx, rx) = mpsc::channel(100);
        let sender = Arc::new(Mutex::new(tx));

        let service = SpeechService {
            sender,
            websocket_manager,
            settings,
            tts_provider: Arc::new(RwLock::new(TTSProvider::Sonata)),
        };

        service.start(rx);
        service
    }

    fn start(&self, mut receiver: mpsc::Receiver<SpeechCommand>) {
        let websocket_manager = Arc::clone(&self.websocket_manager);
        let settings = Arc::clone(&self.settings);
        let tts_provider = Arc::clone(&self.tts_provider);

        task::spawn(async move {
            let mut ws_stream: Option<WebSocketStream<MaybeTlsStream<TcpStream>>> = None;

            while let Some(command) = receiver.recv().await {
                match command {
                    SpeechCommand::Initialize => {
                        let current_provider = tts_provider.read().await;
                        if let TTSProvider::OpenAI = *current_provider {
                            let settings = settings.read().await;
                            
                            // Construct the full URL with model parameter
                            let url = format!(
                                "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01"
                            );
                            let url = Url::parse(&url).expect("Failed to parse OpenAI base URL");
                            
                            let request = Request::builder()
                                .uri(url.as_str())
                                .header("Authorization", format!("Bearer {}", settings.openai.api_key))
                                .header("OpenAI-Beta", "realtime=v1")
                                .header("Content-Type", "application/json")
                                .header("User-Agent", "WebXR Graph")
                                .header("Sec-WebSocket-Version", "13")
                                .header("Sec-WebSocket-Key", tungstenite::handshake::client::generate_key())
                                .header("Connection", "Upgrade")
                                .header("Upgrade", "websocket")
                                .body(())
                                .expect("Failed to build request");

                            match connect_async(request).await {
                                Ok((mut stream, _)) => {
                                    info!("Connected to OpenAI Realtime API");
                                    
                                    // Send initial response.create event
                                    let init_event = json!({
                                        "type": "response.create",
                                        "response": {
                                            "modalities": ["text", "audio"],
                                            "instructions": "You are a helpful AI assistant. Respond naturally and conversationally."
                                        }
                                    });
                                    
                                    if let Err(e) = stream.send(Message::Text(init_event.to_string())).await {
                                        error!("Failed to send initial response.create event: {}", e);
                                    }
                                    
                                    ws_stream = Some(stream);
                                },
                                Err(e) => error!("Failed to connect to OpenAI Realtime API: {}", e),
                            }
                        }
                    },
                    SpeechCommand::SendMessage(msg) => {
                        let current_provider = tts_provider.read().await;
                        match *current_provider {
                            TTSProvider::OpenAI => {
                                if let Some(stream) = &mut ws_stream {
                                    // Send the message event
                                    let msg_event = json!({
                                        "type": "conversation.item.create",
                                        "item": {
                                            "type": "message",
                                            "role": "user",
                                            "content": [{
                                                "type": "input_text",
                                                "text": msg
                                            }]
                                        }
                                    });

                                    if let Err(e) = stream.send(Message::Text(msg_event.to_string())).await {
                                        error!("Failed to send message to OpenAI: {}", e);
                                    } else {
                                        // Request a response
                                        let response_event = json!({
                                            "type": "response.create"
                                        });
                                        
                                        if let Err(e) = stream.send(Message::Text(response_event.to_string())).await {
                                            error!("Failed to request response from OpenAI: {}", e);
                                        }
                                        
                                        // Handle incoming messages
                                        while let Some(message) = stream.next().await {
                                            match message {
                                                Ok(Message::Text(text)) => {
                                                    let event = serde_json::from_str::<serde_json::Value>(&text)
                                                        .expect("Failed to parse server event");
                                                    
                                                    match event["type"].as_str() {
                                                        Some("conversation.item.created") => {
                                                            if let Some(content) = event["item"]["content"].as_array() {
                                                                for item in content {
                                                                    if item["type"] == "audio" {
                                                                        if let Some(audio_data) = item["audio"].as_str() {
                                                                            // Decode base64 audio data
                                                                            if let Ok(audio_bytes) = BASE64.decode(audio_data) {
                                                                                // Create audio message
                                                                                let audio_message = ServerMessage::AudioData {
                                                                                    audio_data: BASE64.encode(&audio_bytes),
                                                                                };
                                                                                
                                                                                if let Ok(msg_str) = serde_json::to_string(&audio_message) {
                                                                                    if let Err(e) = websocket_manager.broadcast_message(msg_str).await {
                                                                                        error!("Failed to broadcast message: {}", e);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        },
                                                        Some("error") => {
                                                            error!("OpenAI Realtime API error: {:?}", event);
                                                            break;
                                                        },
                                                        Some("response.completed") => {
                                                            break;
                                                        },
                                                        _ => {}
                                                    }
                                                },
                                                Ok(Message::Close(_)) => break,
                                                Err(e) => {
                                                    error!("Error receiving from OpenAI: {}", e);
                                                    break;
                                                },
                                                _ => {}
                                            }
                                        }
                                    }
                                } else {
                                    error!("OpenAI WebSocket not initialized");
                                }
                            },
                            TTSProvider::Sonata => {
                                let mut child = Command::new("python3")
                                    .arg("src/generate_audio.py")
                                    .stdin(Stdio::piped())
                                    .stdout(Stdio::piped())
                                    .spawn()
                                    .expect("Failed to spawn Python process");

                                if let Some(mut stdin) = child.stdin.take() {
                                    if let Err(e) = stdin.write_all(msg.as_bytes()) {
                                        error!("Failed to write to stdin: {}", e);
                                    }
                                    // Close stdin to signal EOF to the Python process
                                    drop(stdin);
                                }

                                match child.wait_with_output() {
                                    Ok(output) => {
                                        if output.status.success() {
                                            // Create audio message
                                            let audio_message = ServerMessage::AudioData {
                                                audio_data: BASE64.encode(&output.stdout),
                                            };
                                            
                                            if let Ok(msg_str) = serde_json::to_string(&audio_message) {
                                                if let Err(e) = websocket_manager.broadcast_message(msg_str).await {
                                                    error!("Failed to broadcast message: {}", e);
                                                }
                                            }
                                        } else {
                                            error!("Sonata TTS failed: {}", String::from_utf8_lossy(&output.stderr));
                                        }
                                    },
                                    Err(e) => error!("Failed to get child process output: {}", e),
                                }
                            }
                        }
                    },
                    SpeechCommand::Close => {
                        if let Some(mut stream) = ws_stream.take() {
                            let close_frame = Message::Close(None);
                            if let Err(e) = stream.send(close_frame).await {
                                error!("Failed to send close frame: {}", e);
                            }
                        }
                        break;
                    },
                    SpeechCommand::SetTTSProvider(new_provider) => {
                        let mut provider = tts_provider.write().await;
                        *provider = new_provider;
                        info!("TTS provider set to: {:?}", *provider);
                    }
                }
            }
        });
    }

    pub async fn initialize(&self) -> Result<(), Box<dyn Error>> {
        let command = SpeechCommand::Initialize;
        self.sender.lock().await.send(command).await?;
        Ok(())
    }

    pub async fn send_message(&self, message: String) -> Result<(), Box<dyn Error>> {
        let command = SpeechCommand::SendMessage(message);
        self.sender.lock().await.send(command).await?;
        Ok(())
    }

    pub async fn close(&self) -> Result<(), Box<dyn Error>> {
        let command = SpeechCommand::Close;
        self.sender.lock().await.send(command).await?;
        Ok(())
    }

    pub async fn set_tts_provider(&self, use_openai: bool) -> Result<(), Box<dyn Error>> {
        let provider = if use_openai {
            TTSProvider::OpenAI
        } else {
            TTSProvider::Sonata
        };
        let command = SpeechCommand::SetTTSProvider(provider);
        self.sender.lock().await.send(command).await?;
        Ok(())
    }
}

pub struct SpeechWs {
    hb: Instant,
    websocket_manager: Arc<WebSocketManager>,
    settings: Arc<RwLock<Settings>>,
}

impl SpeechWs {
    pub fn new(websocket_manager: Arc<WebSocketManager>, settings: Arc<RwLock<Settings>>) -> Self {
        Self {
            hb: Instant::now(),
            websocket_manager,
            settings,
        }
    }

    fn hb(&self, ctx: &mut ws::WebsocketContext<Self>) {
        ctx.run_later(Duration::from_secs(0), |act, ctx| {
            act.check_heartbeat(ctx);
            ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {
                act.check_heartbeat(ctx);
            });
        });
    }

    fn check_heartbeat(&self, ctx: &mut ws::WebsocketContext<Self>) {
        if Instant::now().duration_since(self.hb) > CLIENT_TIMEOUT {
            info!("Websocket Client heartbeat failed, disconnecting!");
            ctx.close(None);
            return;
        }
        ctx.ping(b"");
    }
}

impl Actor for SpeechWs {
    type Context = ws::WebsocketContext<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        self.hb(ctx);
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SpeechWs {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                self.hb = Instant::now();
                ctx.pong(&msg);
            }
            Ok(ws::Message::Pong(_)) => {
                self.hb = Instant::now();
            }
            Ok(ws::Message::Text(text)) => {
                debug!("Received text message: {}", text);
                if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text) {
                    if let (Some(message), Some(use_openai)) = (json["message"].as_str(), json["useOpenAI"].as_bool()) {
                        let speech_service = SpeechService::new(
                            Arc::clone(&self.websocket_manager),
                            Arc::clone(&self.settings)
                        );
                        let message = message.to_string();
                        actix::spawn(async move {
                            if let Err(e) = speech_service.set_tts_provider(use_openai).await {
                                error!("Failed to set TTS provider: {}", e);
                            }
                            if let Err(e) = speech_service.send_message(message).await {
                                error!("Failed to send message: {}", e);
                            }
                        });
                    }
                }
            }
            Ok(ws::Message::Binary(bin)) => {
                debug!("Received binary message of {} bytes", bin.len());
                ctx.binary(bin);
            }
            Ok(ws::Message::Close(reason)) => {
                info!("Closing websocket connection: {:?}", reason);
                ctx.close(reason);
                return;
            }
            _ => (),
        }
    }
}

pub async fn start_websocket(
    req: HttpRequest,
    stream: web::Payload,
    websocket_manager: web::Data<Arc<WebSocketManager>>,
    settings: web::Data<Arc<RwLock<Settings>>>,
) -> Result<HttpResponse, ActixError> {
    let ws = SpeechWs::new(Arc::clone(&websocket_manager), Arc::clone(&settings));
    ws::start(ws, &req, stream)
}

----
services/ragflow_service.rs
use reqwest::{Client, StatusCode};
use log::{error, info};
use crate::config::Settings;
use std::fmt;
use futures::stream::{Stream, StreamExt};
use std::pin::Pin;
use serde_json::json;
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug)]
pub enum RAGFlowError {
    ReqwestError(reqwest::Error),
    StatusError(StatusCode, String),
    ParseError(String),
    IoError(std::io::Error),
}

impl fmt::Display for RAGFlowError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RAGFlowError::ReqwestError(e) => write!(f, "Reqwest error: {}", e),
            RAGFlowError::StatusError(status, msg) => write!(f, "Status error ({}): {}", status, msg),
            RAGFlowError::ParseError(msg) => write!(f, "Parse error: {}", msg),
            RAGFlowError::IoError(e) => write!(f, "IO error: {}", e),
        }
    }
}

impl std::error::Error for RAGFlowError {}

impl From<reqwest::Error> for RAGFlowError {
    fn from(err: reqwest::Error) -> Self {
        RAGFlowError::ReqwestError(err)
    }
}

impl From<std::io::Error> for RAGFlowError {
    fn from(err: std::io::Error) -> Self {
        RAGFlowError::IoError(err)
    }
}

pub struct RAGFlowService {
    client: Client,
    api_key: String,
    base_url: String,
}

impl RAGFlowService {
    pub async fn new(settings: Arc<RwLock<Settings>>) -> Result<Self, RAGFlowError> {
        let client = Client::new();
        let settings = settings.read().await;

        Ok(RAGFlowService {
            client,
            api_key: settings.ragflow.api_key.clone(),
            base_url: settings.ragflow.base_url.clone(),
        })
    }

    pub async fn create_conversation(&self, user_id: String) -> Result<String, RAGFlowError> {
        info!("Creating conversation for user: {}", user_id);
        let url = format!("{}api/new_conversation", self.base_url);
        info!("Full URL for create_conversation: {}", url);
        
        let response = self.client.get(&url)
            .header("Authorization", format!("Bearer {}", self.api_key))
            .query(&[("user_id", user_id)])
            .send()
            .await?;

        let status = response.status();
        info!("Response status: {}", status);

        if status.is_success() {
            let result: serde_json::Value = response.json().await?;
            info!("Successful response: {:?}", result);
            Ok(result["data"]["id"].as_str().unwrap_or("").to_string())
        } else {
            let error_message = response.text().await?;
            error!("Failed to create conversation. Status: {}, Error: {}", status, error_message);
            Err(RAGFlowError::StatusError(status, error_message))
        }
    }

    pub async fn send_message(
        &self,
        conversation_id: String,
        message: String,
        quote: bool,
        doc_ids: Option<Vec<String>>,
        stream: bool,
    ) -> Result<Pin<Box<dyn Stream<Item = Result<String, RAGFlowError>> + Send + 'static>>, RAGFlowError> {
        info!("Sending message to conversation: {}", conversation_id);
        let url = format!("{}api/completion", self.base_url);
        info!("Full URL for send_message: {}", url);
        
        let mut request_body = json!({
            "conversation_id": conversation_id,
            "messages": [{"role": "user", "content": message}],
            "quote": quote,
            "stream": stream
        });

        if let Some(ids) = doc_ids {
            request_body["doc_ids"] = serde_json::json!(ids.join(","));
        }

        info!("Request body: {:?}", request_body);

        let response = self.client.post(&url)
            .header("Authorization", format!("Bearer {}", self.api_key))
            .header("Content-Type", "application/json")
            .json(&request_body)
            .send()
            .await?;

        let status = response.status();
        info!("Response status: {}", status);
       
        if status.is_success() {
            let stream = response.bytes_stream().map(move |chunk_result| {
                match chunk_result {
                    Ok(chunk) => {
                        match serde_json::from_slice::<serde_json::Value>(&chunk) {
                            Ok(json_response) => {
                                // Extract text answer from the response
                                match json_response["data"]["answer"].as_str()
                                    .or_else(|| json_response["answer"].as_str()) {
                                    Some(answer) => Ok(answer.to_string()),
                                    None => Err(RAGFlowError::ParseError("No answer found in response".to_string()))
                                }
                            },
                            Err(e) => Err(RAGFlowError::ParseError(format!("Failed to parse JSON response: {}", e))),
                        }
                    },
                    Err(e) => Err(RAGFlowError::ReqwestError(e)),
                }
            });

            Ok(Box::pin(stream))
        } else {
            let error_message = response.text().await?;
            error!("Failed to send message. Status: {}, Error: {}", status, error_message);
            Err(RAGFlowError::StatusError(status, error_message))
        }
    }

    pub async fn get_conversation_history(&self, conversation_id: String) -> Result<serde_json::Value, RAGFlowError> {
        let url = format!("{}api/conversation/{}", self.base_url, conversation_id);
        let response = self.client.get(&url)
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await?;

        let status = response.status();
        if status.is_success() {
            let history: serde_json::Value = response.json().await?;
            Ok(history)
        } else {
            let error_message = response.text().await?;
            error!("Failed to get conversation history. Status: {}, Error: {}", status, error_message);
            Err(RAGFlowError::StatusError(status, error_message))
        }
    }
}

impl Clone for RAGFlowService {
    fn clone(&self) -> Self {
        RAGFlowService {
            client: self.client.clone(),
            api_key: self.api_key.clone(),
            base_url: self.base_url.clone(),
        }
    }
}

----
services/github_service.rs
use reqwest::Client;
use serde::{Serialize, Deserialize};
use async_trait::async_trait;
use log::{info, error};
use std::error::Error;
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};

#[derive(Debug, Serialize)]
struct CreateBranchRequest {
    pub ref_name: String,
    pub sha: String,
}

#[derive(Debug, Serialize)]
struct CreatePullRequest {
    pub title: String,
    pub head: String,
    pub base: String,
    pub body: String,
}

#[derive(Debug, Serialize)]
struct UpdateFileRequest {
    pub message: String,
    pub content: String,
    pub sha: String,
    pub branch: String,
}

#[derive(Debug, Deserialize)]
struct FileResponse {
    pub sha: String,
}

#[async_trait]
pub trait GitHubPRService: Send + Sync {
    async fn create_pull_request(
        &self,
        file_name: &str,
        content: &str,
        original_sha: &str,
    ) -> Result<String, Box<dyn Error + Send + Sync>>;
}

pub struct RealGitHubPRService {
    client: Client,
    token: String,
    owner: String,
    repo: String,
    base_path: String,
}

impl RealGitHubPRService {
    pub fn new(
        token: String,
        owner: String,
        repo: String,
        base_path: String,
    ) -> Result<Self, Box<dyn Error + Send + Sync>> {
        let client = Client::builder()
            .user_agent("rust-github-api")
            .build()?;

        Ok(Self {
            client,
            token,
            owner,
            repo,
            base_path,
        })
    }

    async fn get_main_branch_sha(&self) -> Result<String, Box<dyn Error + Send + Sync>> {
        let url = format!(
            "https://api.github.com/repos/{}/{}/git/ref/heads/main",
            self.owner, self.repo
        );

        let response = self.client
            .get(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            error!("Failed to get main branch SHA: {}", error_text);
            return Err(format!("Failed to get main branch SHA: {}", error_text).into());
        }

        let response_json: serde_json::Value = response.json().await?;
        Ok(response_json["object"]["sha"]
            .as_str()
            .ok_or("SHA not found")?
            .to_string())
    }

    async fn create_branch(&self, branch_name: &str, sha: &str) -> Result<(), Box<dyn Error + Send + Sync>> {
        let url = format!(
            "https://api.github.com/repos/{}/{}/git/refs",
            self.owner, self.repo
        );

        let body = CreateBranchRequest {
            ref_name: format!("refs/heads/{}", branch_name),
            sha: sha.to_string(),
        };

        let response = self.client
            .post(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .json(&body)
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            error!("Failed to create branch: {}", error_text);
            return Err(format!("Failed to create branch: {}", error_text).into());
        }

        Ok(())
    }

    async fn update_file(
        &self,
        file_path: &str,
        content: &str,
        branch_name: &str,
        original_sha: &str,
    ) -> Result<String, Box<dyn Error + Send + Sync>> {
        let url = format!(
            "https://api.github.com/repos/{}/{}/contents/{}",
            self.owner, self.repo, file_path
        );

        let encoded_content = BASE64.encode(content);
        
        let body = UpdateFileRequest {
            message: format!("Update {} with Perplexity-enhanced content", file_path),
            content: encoded_content,
            sha: original_sha.to_string(),
            branch: branch_name.to_string(),
        };

        let response = self.client
            .put(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .json(&body)
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            error!("Failed to update file: {}", error_text);
            return Err(format!("Failed to update file: {}", error_text).into());
        }

        let file_response: FileResponse = response.json().await?;
        Ok(file_response.sha)
    }
}

#[async_trait]
impl GitHubPRService for RealGitHubPRService {
    async fn create_pull_request(
        &self,
        file_name: &str,
        content: &str,
        original_sha: &str,
    ) -> Result<String, Box<dyn Error + Send + Sync>> {
        let timestamp = chrono::Utc::now().timestamp();
        let branch_name = format!("perplexity-update-{}-{}", file_name.replace(".md", ""), timestamp);
        
        // Get main branch SHA
        let main_sha = self.get_main_branch_sha().await?;
        
        // Create new branch
        self.create_branch(&branch_name, &main_sha).await?;
        
        // Update file in new branch
        let file_path = format!("{}/{}", self.base_path, file_name);
        let new_sha = self.update_file(&file_path, content, &branch_name, original_sha).await?;
        
        // Create pull request
        let url = format!(
            "https://api.github.com/repos/{}/{}/pulls",
            self.owner, self.repo
        );

        let pr_body = CreatePullRequest {
            title: format!("Perplexity Enhancement: {}", file_name),
            head: branch_name,
            base: "main".to_string(),
            body: format!(
                "This PR contains Perplexity-enhanced content for {}.\n\nOriginal SHA: {}\nNew SHA: {}",
                file_name, original_sha, new_sha
            ),
        };

        let response = self.client
            .post(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", "application/vnd.github+json")
            .json(&pr_body)
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            error!("Failed to create PR: {}", error_text);
            return Err(format!("Failed to create PR: {}", error_text).into());
        }

        let pr_response: serde_json::Value = response.json().await?;
        let pr_url = pr_response["html_url"]
            .as_str()
            .ok_or("PR URL not found")?
            .to_string();

        info!("Created PR: {}", pr_url);
        Ok(pr_url)
    }
}

--END--The following text represents a project with code. The structure of the text consists of sections beginning with ----, followed by a single line containing the file path and file name, and then a variable number of lines containing the file contents. The text representing the project ends when the symbols --END-- are encountered. Any further text beyond --END-- is meant to be interpreted as instructions using the aforementioned project as context.
----
index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Graph Visualization</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }
        #scene-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            background: #000000;
            touch-action: none;
        }
        #app {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        #app > * {
            pointer-events: auto;
        }
        #connection-status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.7);
        }
        canvas {
            display: block;
            outline: none;
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="app"></div>
    <div id="connection-status" class="disconnected">Disconnected</div>

    <script type="module">
        // Import and initialize app
        import('./index.ts')
            .then(() => {
                console.info('Application loaded successfully');
            })
            .catch(error => {
                console.error('Failed to load application', {
                    message: error.message,
                    stack: error.stack,
                    context: 'Application Load'
                });
            });
    </script>
</body>
</html>

----
index.ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './components/App.vue'
import { errorTracking } from './services/errorTracking'

// Disable Vue devtools
window.__VUE_PROD_DEVTOOLS__ = false

// Create Vue application
const app = createApp(App)

// Configure global error handler for Vue
app.config.errorHandler = (err, instance, info) => {
  // Track error with our service
  errorTracking.trackError(err, {
    context: 'Vue Error Handler',
    component: (instance as any)?.$options?.name || 'Unknown Component',
    additional: { info }
  })

  // Log to console in development
  if (process.env.NODE_ENV === 'development') {
    console.error('Vue Error:', err)
    console.error('Component:', instance)
    console.error('Error Info:', info)
  }
}

// Create and use Pinia
const pinia = createPinia()
app.use(pinia)

// Add error tracking to Pinia
pinia.use(() => {
  return {
    error: (error: Error) => {
      errorTracking.trackError(error, {
        context: 'Pinia Store',
        additional: { store: error?.cause }
      })
    }
  }
})

// Mount the app
app.mount('#app')

// Log successful initialization
console.info('Application initialized', {
  context: 'App Initialization',
  environment: process.env.NODE_ENV
})

----
utils/gpuUtils.ts
import type { Vector3 } from 'three';

export interface GPUContext {
  initialized: boolean;
  webgl2: boolean;
}

export interface PositionUpdate {
  positions: NodePosition[];
}

export interface NodePosition {
  x: number;
  y: number;
  z: number;
  vx: number;
  vy: number;
  vz: number;
}

/**
 * Check if GPU/WebGL is available for rendering
 * @returns Promise that resolves to true if GPU rendering is available
 */
export async function isGPUAvailable(): Promise<boolean> {
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2') || 
               canvas.getContext('webgl') || 
               canvas.getContext('experimental-webgl');
    
    if (!gl) {
      console.warn('WebGL not available, rendering may be limited');
      return false;
    }

    // Check if it's WebGL 2
    if (gl instanceof WebGL2RenderingContext) {
      console.log('WebGL 2 available');
    } else {
      console.log('WebGL 1 available');
    }

    return true;
  } catch (error) {
    console.error('Error checking GPU availability:', error);
    return false;
  }
}

/**
 * Initialize GPU/WebGL context
 * @returns Promise that resolves to GPU context if available
 */
export async function initGPU(): Promise<GPUContext | null> {
  const available = await isGPUAvailable();
  if (available) {
    return {
      initialized: true,
      webgl2: typeof WebGL2RenderingContext !== 'undefined' && 
              document.createElement('canvas').getContext('webgl2') instanceof WebGL2RenderingContext
    };
  }
  return null;
}

/**
 * Apply position updates received from server
 * @param buffer - Binary position data from server (6 float32s per node: x,y,z,vx,vy,vz)
 * @returns Processed position data
 */
export function processPositionUpdate(buffer: ArrayBuffer): PositionUpdate | null {
  try {
    const dataView = new Float32Array(buffer);
    const positions: NodePosition[] = [];
    
    // Process 6 floats at a time (x,y,z,vx,vy,vz)
    for (let i = 0; i < dataView.length; i += 6) {
      if (i + 5 < dataView.length) {
        positions.push({
          x: dataView[i],
          y: dataView[i + 1],
          z: dataView[i + 2],
          vx: dataView[i + 3],
          vy: dataView[i + 4],
          vz: dataView[i + 5]
        });
      }
    }

    return { positions };
  } catch (error) {
    console.error('Error processing position update:', error);
    return null;
  }
}

/**
 * Convert NodePosition to Vector3
 * @param position - Node position data
 * @returns THREE.Vector3 position
 */
export function positionToVector3(position: NodePosition): Vector3 {
  return {
    x: position.x,
    y: position.y,
    z: position.z
  } as Vector3;
}

/**
 * Convert Vector3 to NodePosition
 * @param vector - THREE.Vector3 position
 * @returns Node position data
 */
export function vector3ToPosition(vector: Vector3): NodePosition {
  return {
    x: vector.x,
    y: vector.y,
    z: vector.z,
    vx: 0,
    vy: 0,
    vz: 0
  };
}

----
utils/threeUtils.ts
import type { 
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  Camera,
  WebGLRenderTarget,
  Texture,
  Object3D
} from 'three';

import type { Pass } from 'three/examples/jsm/postprocessing/Pass';
import type { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';

// Base pass interface that matches actual implementation
export interface BasePass extends Pass {
  render(
    renderer: WebGLRenderer,
    writeBuffer: WebGLRenderTarget<Texture> | null,
    readBuffer: WebGLRenderTarget<Texture>,
    deltaTime?: number,
    maskActive?: boolean
  ): void;
}

// Extended pass interface for custom functionality
export interface ExtendedPass extends BasePass {
  selectedObjects?: Object3D[];
  output?: number;
}

// Type assertion functions with any to bypass strict checks
export function asRenderer(renderer: any): WebGLRenderer {
  return renderer;
}

export function asScene(scene: any): Scene {
  return scene;
}

export function asCamera(camera: any): Camera {
  return camera;
}

export function asPass(pass: any): ExtendedPass {
  return pass;
}

export function asEffectComposer(composer: any): EffectComposer {
  return composer;
}

// Type guard for checking if an object is a valid Pass
export function isValidPass(obj: any): obj is ExtendedPass {
  return obj && typeof obj.render === 'function';
}

// Constants for pass outputs
export const PASS_OUTPUT = {
  Default: 0,
  Beauty: 1,
  Depth: 2,
  Normal: 3
};

----
utils/three.ts
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Export everything from three
export * from 'three';
// Export specific imports
export { OrbitControls };
// Export THREE as default
export default THREE;

----
shaders/fisheye.glsl
// TODO: Future client-side fisheye implementation
// This shader will be used to apply fisheye distortion during rendering,
// rather than modifying actual node positions.
//
// Implementation notes:
// - Should be applied in the visualization layer only
// - Operates on rendered positions, not data positions
// - Allows for interactive distortion without affecting layout
// - Can be toggled without impacting graph structure
//
// Example implementation (to be integrated later):
/*
uniform bool fisheyeEnabled;
uniform float fisheyeStrength;
uniform float fisheyeRadius;
uniform vec3 fisheyeFocusPoint;

vec3 applyFisheyeDistortion(vec3 position) {
    if (!fisheyeEnabled) {
        return position;
    }

    // Calculate distance from focus point
    vec3 directionFromFocus = position - fisheyeFocusPoint;
    float distance = length(directionFromFocus);
    
    if (distance > fisheyeRadius) {
        return position;
    }

    // Normalize distance to [0,1] range
    float normalizedDistance = distance / fisheyeRadius;
    
    // Calculate distortion factor
    float distortionFactor = 1.0 - (1.0 - normalizedDistance) * fisheyeStrength;
    
    // Apply distortion
    return fisheyeFocusPoint + directionFromFocus * distortionFactor;
}
*/

----
xr/xrSetup.js
import * as THREE from 'three';
import { XRButton } from 'three/examples/jsm/webxr/XRButton.js';
import { initXRInteraction, handleXRInput } from './xrInteraction.js';

// Constants
const MOVEMENT_SPEED = 0.05;
const XR_SPRITE_SCALE = 0.5;

/**
 * Enhanced XR Session Manager using Three.js WebXR
 */
class XRSessionManager {
    constructor(renderer, scene, camera, effectsManager) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.effectsManager = effectsManager;
        this.referenceSpace = null;
        this.originalScales = new WeakMap();
        this.xrInteraction = null;
        this.sessionActive = false;
        this.cameraRig = null;
        this.effectsEnabled = true;
    }

    /**
     * Initialize XR session manager
     */
    async init() {
        try {
            // Check if XR is supported
            if (!this.renderer.xr) {
                console.warn('WebXR not supported by renderer');
                return;
            }

            // Enable XR on renderer
            this.renderer.xr.enabled = true;

            // Initialize camera rig
            this.initCameraRig();

            // Initialize XR interaction
            this.xrInteraction = initXRInteraction(this.scene, this.camera, this.renderer);

            // Set up session event handlers
            this.setupEventHandlers();

        } catch (error) {
            console.error('Error initializing XR session manager:', error);
        }
    }

    /**
     * Initialize camera rig with proper hierarchy
     */
    initCameraRig() {
        // Create camera rig if it doesn't exist
        if (!this.cameraRig) {
            this.cameraRig = new THREE.Group();
            this.cameraRig.name = 'cameraRig';
        }

        // Create camera offset for height adjustment if not already a child of the rig
        let cameraOffset = this.cameraRig.children.find(child => child.name === 'cameraOffset');
        if (!cameraOffset) {
            cameraOffset = new THREE.Group();
            cameraOffset.name = 'cameraOffset';
            cameraOffset.position.y = 1.6; // Average eye height
            this.cameraRig.add(cameraOffset);
        }

        // Add camera to offset if not already there
        if (!cameraOffset.children.includes(this.camera)) {
            this.camera.name = 'xrCamera';
            cameraOffset.add(this.camera);
        }

        // Add rig to scene if not already there
        if (!this.scene.children.includes(this.cameraRig)) {
            this.scene.add(this.cameraRig);
        }

        // Set initial positions
        this.camera.position.set(0, 0, 0);
        this.cameraRig.position.set(0, 0, 0);
    }

    /**
     * Set up session event handlers
     */
    setupEventHandlers() {
        // Session start handler
        this.renderer.xr.addEventListener('sessionstart', async (event) => {
            console.log('XR session started');
            this.sessionActive = true;

            const session = this.renderer.xr.getSession();
            await this.setupReferenceSpace(session);
            this.handleXRSprites(true);

            // Initialize camera position
            this.cameraRig.position.set(0, 0, 0);
            this.camera.position.set(0, 0, 0);

            // Initialize XR-specific effects
            if (this.effectsManager) {
                try {
                    await this.effectsManager.initPostProcessing(true);
                    this.effectsEnabled = true;
                } catch (error) {
                    console.error('Failed to initialize XR effects:', error);
                    this.effectsEnabled = false;
                }
            }

            window.dispatchEvent(new CustomEvent('xrsessionstart'));
        });

        // Session end handler
        this.renderer.xr.addEventListener('sessionend', () => {
            console.log('XR session ended');
            this.sessionActive = false;
            this.handleXRSprites(false);
            this.resetCameraRig();

            // Reinitialize desktop effects
            if (this.effectsManager) {
                try {
                    this.effectsManager.initPostProcessing(false);
                    this.effectsEnabled = true;
                } catch (error) {
                    console.error('Failed to reinitialize desktop effects:', error);
                    this.effectsEnabled = false;
                }
            }

            window.dispatchEvent(new CustomEvent('xrsessionend'));
        });
    }

    /**
     * Render scene with effects fallback
     */
    render() {
        if (this.effectsManager && this.effectsEnabled) {
            try {
                this.effectsManager.render();
            } catch (error) {
                console.error('Error in effects rendering:', error);
                this.effectsEnabled = false;
                this.fallbackRender();
            }
        } else {
            this.fallbackRender();
        }
    }

    /**
     * Fallback render without effects
     */
    fallbackRender() {
        const currentCamera = this.sessionActive ? this.renderer.xr.getCamera() : this.camera;
        this.renderer.render(this.scene, currentCamera);
    }

    /**
     * Add XR button to the scene
     * @returns {Promise<void>}
     */
    async addXRButton() {
        try {
            if (!this.renderer.xr.enabled) {
                console.warn('XR not enabled on renderer');
                return;
            }

            const sessionInit = {
                optionalFeatures: [
                    'local-floor',
                    'bounded-floor',
                    'hand-tracking',
                    'layers'
                ]
            };

            // Check if VR is supported
            const isVRSupported = await navigator.xr?.isSessionSupported('immersive-vr');
            
            if (isVRSupported) {
                const button = XRButton.createButton(this.renderer, {
                    mode: 'immersive-vr',
                    sessionInit,
                    onSessionStarted: (session) => this.onSessionStarted(session),
                    onSessionEnded: () => this.onSessionEnded()
                });
                document.body.appendChild(button);
            } else {
                console.warn('VR not supported on this device');
            }
        } catch (error) {
            console.error('Error adding XR button:', error);
        }
    }

    /**
     * Handle session start
     * @param {XRSession} session - The XR session
     */
    async onSessionStarted(session) {
        try {
            await this.setupReferenceSpace(session);
            this.handleXRSprites(true);
        } catch (error) {
            console.error('Error starting XR session:', error);
        }
    }

    /**
     * Handle session end
     */
    onSessionEnded() {
        this.handleXRSprites(false);
        this.resetCameraRig();
    }

    /**
     * Set up reference space with fallback options
     * @param {XRSession} session - The XR session
     */
    async setupReferenceSpace(session) {
        try {
            this.referenceSpace = await session.requestReferenceSpace('local-floor');
            console.log('Using local-floor reference space');
        } catch (error) {
            console.warn('Failed to get local-floor reference space:', error);
            try {
                this.referenceSpace = await session.requestReferenceSpace('local');
                console.log('Falling back to local reference space');
            } catch (error) {
                console.error('Failed to get any reference space:', error);
            }
        }
    }

    /**
     * Handle sprite scaling for XR
     * @param {boolean} enteringXR - Whether entering or exiting XR
     */
    handleXRSprites(enteringXR) {
        this.scene.traverse((object) => {
            if (object.isSprite) {
                if (enteringXR) {
                    this.originalScales.set(object, object.scale.clone());
                    object.scale.multiplyScalar(XR_SPRITE_SCALE);
                    object.layers.enableAll();
                    
                    if (object.material.map) {
                        object.material.map.generateMipmaps = false;
                        object.material.map.minFilter = THREE.LinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                } else {
                    const originalScale = this.originalScales.get(object);
                    if (originalScale) {
                        object.scale.copy(originalScale);
                    }
                    
                    if (object.material.map) {
                        object.material.map.generateMipmaps = true;
                        object.material.map.minFilter = THREE.LinearMipmapLinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                }
            }
        });
    }

    /**
     * Reset camera rig to initial position
     */
    resetCameraRig() {
        if (this.cameraRig) {
            this.cameraRig.position.set(0, 0, 0);
            this.cameraRig.rotation.set(0, 0, 0);
        }
        if (this.camera) {
            this.camera.position.set(0, 0, 0);
            this.camera.rotation.set(0, 0, 0);
        }
    }

    /**
     * Update XR frame
     * @param {number} timestamp - Frame timestamp
     * @param {XRFrame} frame - XR frame
     */
    update(timestamp, frame) {
        if (!this.sessionActive || !frame) return;

        try {
            // Update XR camera pose
            if (this.referenceSpace) {
                const pose = frame.getViewerPose(this.referenceSpace);
                if (pose) {
                    // Update camera rig based on pose
                    const position = pose.transform.position;
                    const orientation = pose.transform.orientation;
                    
                    this.cameraRig.position.set(position.x, position.y, position.z);
                    this.cameraRig.quaternion.set(
                        orientation.x,
                        orientation.y,
                        orientation.z,
                        orientation.w
                    );
                }
            }

            // Update XR interaction
            if (this.xrInteraction) {
                this.xrInteraction.update();
                handleXRInput(frame, this.referenceSpace);
            }

            // Handle input sources
            const session = frame.session;
            for (const inputSource of session.inputSources) {
                if (inputSource.gamepad) {
                    this.handleControllerInput(inputSource.gamepad);
                }
            }

        } catch (error) {
            console.error('Error updating XR frame:', error);
        }
    }

    /**
     * Handle controller input
     * @param {Gamepad} gamepad - The XR gamepad
     */
    handleControllerInput(gamepad) {
        if (!gamepad?.axes || gamepad.axes.length < 2) return;

        try {
            const [x, y] = gamepad.axes;
            const deadzone = 0.1;

            if (Math.abs(x) > deadzone || Math.abs(y) > deadzone) {
                // Get movement direction in camera space
                const forward = new THREE.Vector3();
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);

                // Calculate movement
                const movement = new THREE.Vector3();
                movement.addScaledVector(right, x * MOVEMENT_SPEED);
                movement.addScaledVector(forward, -y * MOVEMENT_SPEED);

                // Apply movement to camera rig
                this.cameraRig.position.add(movement);
            }
        } catch (error) {
            console.error('Error handling controller input:', error);
        }
    }

    /**
     * Clean up resources
     */
    dispose() {
        this.originalScales.clear();
        if (this.xrInteraction) {
            this.xrInteraction.cleanup();
        }
    }
}

// Export functions
export function initXRSession(renderer, scene, camera, effectsManager) {
    // Check if renderer has XR capability
    if (!renderer.xr) {
        console.warn('WebXR not supported by renderer');
        return null;
    }

    const xrSessionManager = new XRSessionManager(renderer, scene, camera, effectsManager);
    xrSessionManager.init();
    return xrSessionManager;
}

/**
 * Add XR button to enable VR mode
 * @param {XRSessionManager} xrSessionManager - The XR session manager
 * @returns {Promise<void>}
 */
export async function addXRButton(xrSessionManager) {
    if (!xrSessionManager) {
        console.warn('XR session manager not initialized');
        return;
    }
    await xrSessionManager.addXRButton();
}

export function handleXRSession(renderer, scene, camera, xrSessionManager) {
    if (!xrSessionManager) return;

    renderer.setAnimationLoop((timestamp, frame) => {
        // Update XR session
        xrSessionManager.update(timestamp, frame);

        // Render scene with effects fallback
        xrSessionManager.render();
    });
}

export function updateXRFrame(renderer, scene, camera, xrSessionManager) {
    if (!xrSessionManager?.sessionActive) return;

    // Update XR session
    const frame = renderer.xr.getFrame();
    xrSessionManager.update(performance.now(), frame);

    // Render scene with effects fallback
    xrSessionManager.render();
}

----
xr/xrInteraction.js
import * as THREE from 'three';
import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory.js';

// Constants for interaction
const PINCH_THRESHOLD = 0.015;
const GRAB_THRESHOLD = 0.08;
const PINCH_STRENGTH_THRESHOLD = 0.7;
const LABEL_SIZE = { width: 256, height: 128 };
const LABEL_SCALE = { x: 0.5, y: 0.25, z: 1 };

/**
 * Enhanced XR Interaction Handler
 */
class EnhancedXRInteractionHandler {
    constructor(scene, camera, renderer) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Hand tracking
        this.handModelFactory = new XRHandModelFactory();
        this.hands = { left: null, right: null };
        this.handModels = { left: null, right: null };
        
        // Interaction states
        this.grabStates = {
            left: { grabbedObject: null, pinching: false },
            right: { grabbedObject: null, pinching: false }
        };
        
        // Visual feedback
        this.pinchIndicators = { left: null, right: null };
        
        // Interactable objects
        this.interactableObjects = new Set();
        
        // Resource pools
        this.materialPool = new Map();
        this.geometryPool = new Map();
        
        // Initialize resources
        this.initResources();
    }

    /**
     * Initialize shared resources
     */
    initResources() {
        // Create pinch indicator geometry
        const geometry = new THREE.SphereGeometry(0.01, 8, 8);
        this.geometryPool.set('pinchIndicator', geometry);

        // Create pinch indicator material
        const material = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5,
            depthWrite: false
        });
        this.materialPool.set('pinchIndicator', material);

        // Create pinch indicators
        this.pinchIndicators.left = this.createPinchIndicator();
        this.pinchIndicators.right = this.createPinchIndicator();
        this.scene.add(this.pinchIndicators.left);
        this.scene.add(this.pinchIndicators.right);
    }

    /**
     * Initialize hand tracking
     * @param {XRSession} session - The XR session
     */
    async initHandTracking(session) {
        try {
            // Set up hand tracking
            for (const handedness of ['left', 'right']) {
                const hand = this.renderer.xr.getHand(handedness === 'left' ? 0 : 1);
                const handModel = this.handModelFactory.createHandModel(hand, 'mesh');
                
                this.hands[handedness] = hand;
                this.handModels[handedness] = handModel;
                
                hand.add(handModel);
                this.scene.add(hand);

                // Add hand input event listeners
                hand.addEventListener('pinchstart', () => this.onPinchStart(handedness));
                hand.addEventListener('pinchend', () => this.onPinchEnd(handedness));
            }

            // Set up hand tracking events
            session.addEventListener('handtracking', (event) => {
                const hand = event.hand;
                const handedness = hand.handedness;
                
                // Update hand model visibility
                if (this.handModels[handedness]) {
                    this.handModels[handedness].visible = hand.visible;
                }
            });
        } catch (error) {
            console.error('Error initializing hand tracking:', error);
        }
    }

    /**
     * Create visual feedback for pinch state
     * @returns {THREE.Mesh} Pinch indicator mesh
     */
    createPinchIndicator() {
        const geometry = this.geometryPool.get('pinchIndicator');
        const material = this.materialPool.get('pinchIndicator').clone();
        return new THREE.Mesh(geometry, material);
    }

    /**
     * Update pinch indicator position and appearance
     * @param {XRHand} hand - The XR hand
     * @param {THREE.Mesh} indicator - The pinch indicator mesh
     */
    updatePinchIndicator(hand, indicator) {
        if (!hand?.joints || !indicator) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];
            
            if (indexTip && thumbTip) {
                // Position indicator between finger and thumb
                indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
                
                // Update appearance based on pinch strength
                const { strength } = this.isPinching(hand);
                indicator.material.opacity = strength * 0.8;
                indicator.scale.setScalar(1 - (strength * 0.5));
            }
        } catch (error) {
            console.error('Error updating pinch indicator:', error);
        }
    }

    /**
     * Check if hand is performing pinch gesture
     * @param {XRHand} hand - The XR hand
     * @returns {object} Pinch state and strength
     */
    isPinching(hand) {
        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];

            if (indexTip && thumbTip) {
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
                return { isPinched: distance < PINCH_THRESHOLD, strength };
            }
        } catch (error) {
            console.error('Error detecting pinch:', error);
        }
        return { isPinched: false, strength: 0 };
    }

    /**
     * Handle pinch start event
     * @param {string} handedness - The hand that started pinching
     */
    onPinchStart(handedness) {
        const hand = this.hands[handedness];
        const grabState = this.grabStates[handedness];

        if (!hand || grabState.pinching) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            
            // Find closest interactable object
            let closestObject = null;
            let closestDistance = GRAB_THRESHOLD;

            for (const object of this.interactableObjects) {
                if (!object.userData.isGrabbed) {
                    const distance = indexTip.position.distanceTo(object.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestObject = object;
                    }
                }
            }

            if (closestObject) {
                grabState.grabbedObject = closestObject;
                closestObject.userData.isGrabbed = true;
                
                // Highlight grabbed object
                if (closestObject.material?.emissive) {
                    closestObject.material.emissive.setHex(0x222222);
                }
            }

            grabState.pinching = true;
        } catch (error) {
            console.error('Error handling pinch start:', error);
        }
    }

    /**
     * Handle pinch end event
     * @param {string} handedness - The hand that ended pinching
     */
    onPinchEnd(handedness) {
        const grabState = this.grabStates[handedness];

        if (!grabState.pinching) return;

        try {
            if (grabState.grabbedObject) {
                grabState.grabbedObject.userData.isGrabbed = false;
                if (grabState.grabbedObject.material?.emissive) {
                    grabState.grabbedObject.material.emissive.setHex(0x000000);
                }
                grabState.grabbedObject = null;
            }

            grabState.pinching = false;
        } catch (error) {
            console.error('Error handling pinch end:', error);
        }
    }

    /**
     * Make an object interactable
     * @param {THREE.Object3D} object - The object to make interactable
     */
    makeInteractable(object) {
        object.userData.interactable = true;
        this.interactableObjects.add(object);
    }

    /**
     * Remove interactable status from object
     * @param {THREE.Object3D} object - The object to remove
     */
    removeInteractable(object) {
        object.userData.interactable = false;
        this.interactableObjects.delete(object);
    }

    /**
     * Update interaction state
     */
    update() {
        try {
            // Update both hands
            for (const [handedness, hand] of Object.entries(this.hands)) {
                if (hand?.joints) {
                    const grabState = this.grabStates[handedness];
                    const { isPinched, strength } = this.isPinching(hand);
                    
                    this.updatePinchIndicator(hand, this.pinchIndicators[handedness]);

                    if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                        if (grabState.grabbedObject) {
                            // Update grabbed object position
                            const indexTip = hand.joints['index-finger-tip'];
                            grabState.grabbedObject.position.copy(indexTip.position);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error in XR interaction update:', error);
        }
    }

    /**
     * Clean up resources
     */
    cleanup() {
        try {
            // Dispose of geometries
            this.geometryPool.forEach(geometry => geometry.dispose());
            this.geometryPool.clear();

            // Dispose of materials
            this.materialPool.forEach(material => material.dispose());
            this.materialPool.clear();

            // Remove pinch indicators
            Object.values(this.pinchIndicators).forEach(indicator => {
                if (indicator) {
                    if (indicator.geometry) indicator.geometry.dispose();
                    if (indicator.material) indicator.material.dispose();
                    this.scene.remove(indicator);
                }
            });

            // Remove hand models
            Object.values(this.hands).forEach(hand => {
                if (hand) {
                    this.scene.remove(hand);
                }
            });

            // Clear collections
            this.interactableObjects.clear();
            this.grabStates.left = { grabbedObject: null, pinching: false };
            this.grabStates.right = { grabbedObject: null, pinching: false };
        } catch (error) {
            console.error('Error cleaning up XR interaction:', error);
        }
    }
}

// Export functions
export function initXRInteraction(scene, camera, renderer) {
    return new EnhancedXRInteractionHandler(scene, camera, renderer);
}

export function handleXRInput(frame, referenceSpace) {
    // This function is now handled internally by EnhancedXRInteractionHandler
    // Left for backward compatibility
}

----
platform/platformManager.ts
import { ref, shallowRef } from 'vue';
import type { CoreState, PlatformCapabilities, SceneConfig, Transform } from '../types/core';
import type { BrowserState, BrowserInitOptions } from '../types/platform/browser';
import type { QuestState, QuestInitOptions, XRController, XRHand, XRHandedness, XRSession, XRHitTestSource } from '../types/platform/quest';
import * as THREE from 'three';
import type { Object3D, Material, BufferGeometry, PerspectiveCamera, OrthographicCamera, Group, WebGLRenderer, Camera } from 'three';

// Import OrbitControls dynamically to avoid type conflicts
let OrbitControls: any;

export type PlatformState = BrowserState | QuestState;
type ResizeCallback = (width: number, height: number) => void;
type RenderCallback = (renderer: WebGLRenderer, scene: THREE.Scene, camera: Camera) => void;

/**
 * Platform Manager Interface
 * Defines the contract for platform-specific implementations
 */
export interface IPlatformManager {
  initialize(options: BrowserInitOptions | QuestInitOptions): Promise<void>;
  dispose(): void;
  getState(): PlatformState | null;
  getCapabilities(): PlatformCapabilities | null;
  getPlatform(): 'browser' | 'quest';
  isQuest(): boolean;
  isBrowser(): boolean;
  hasXRSupport(): boolean;
  startXRSession(mode: 'immersive-vr' | 'immersive-ar'): Promise<XRSession>;
  endXRSession(): Promise<void>;
  isInXRSession(): boolean;
  getXRSessionMode(): 'immersive-vr' | 'immersive-ar' | null;
  onResize(callback: ResizeCallback): () => void;
  onBeforeRender(callback: RenderCallback): () => void;
}

/**
 * Platform Manager Implementation
 * Handles platform-specific initialization and XR session management
 */
export class PlatformManager implements IPlatformManager {
  private static instance: PlatformManager;
  private state = shallowRef<PlatformState | null>(null);
  private capabilities = ref<PlatformCapabilities | null>(null);
  private platform: 'browser' | 'quest' = 'browser';
  private animationFrameId: number | null = null;
  private resizeCallbacks: Set<ResizeCallback> = new Set();
  private renderCallbacks: Set<RenderCallback> = new Set();
  private lastFrameTime = 0;
  private xrSessionMode: 'immersive-vr' | 'immersive-ar' | null = null;

  private constructor() {
    this.detectPlatform();
    this.setupResizeHandler();
  }

  /**
   * Get singleton instance of PlatformManager
   */
  static getInstance(): PlatformManager {
    if (!PlatformManager.instance) {
      PlatformManager.instance = new PlatformManager();
    }
    return PlatformManager.instance;
  }

  /**
   * Initialize platform with given options
   */
  async initialize(options: BrowserInitOptions | QuestInitOptions): Promise<void> {
    if (this.platform === 'quest') {
      await this.initializeQuest(options as QuestInitOptions);
    } else {
      await this.initializeBrowser(options as BrowserInitOptions);
    }

    if (this.state.value?.canvas) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      this.resizeCallbacks.forEach(callback => callback(width, height));
    }
  }

  /**
   * Initialize Quest platform with XR support
   */
  private async initializeQuest(options: QuestInitOptions): Promise<void> {
    const sceneConfig: SceneConfig = {
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance'
    };

    const renderer = new THREE.WebGLRenderer({
      canvas: options.canvas,
      ...sceneConfig,
      xr: { enabled: true }
    });

    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType(options.xr?.referenceSpaceType ?? 'local-floor');

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    const scene = new THREE.Scene();

    const controllers = new Map<XRHandedness, XRController>();
    const hands = new Map<XRHandedness, XRHand>();

    // Initialize controllers
    const handednesses: XRHandedness[] = ['left', 'right'];
    handednesses.forEach((handedness, index) => {
      const controller = renderer.xr.getController(index);
      const grip = renderer.xr.getControllerGrip(index);

      controllers.set(handedness, {
        controller,
        grip,
        ray: new THREE.Group(),
        handedness,
        targetRayMode: 'tracked-pointer',
        visible: true,
        connected: false
      });

      scene.add(controller);
      scene.add(grip);
    });

    // Initialize hands
    handednesses.forEach((handedness, index) => {
      const hand = renderer.xr.getHand(index);
      
      hands.set(handedness, {
        hand,
        joints: new Map(),
        visible: true,
        connected: false
      });

      scene.add(hand);
    });

    const transform: Transform = {
      position: [0, 0, 0],
      rotation: [0, 0, 0],
      scale: [1, 1, 1]
    };

    this.state.value = {
      type: 'xr',
      renderer,
      camera,
      scene,
      canvas: options.canvas,
      isInitialized: true,
      isXRSupported: true,
      isWebGL2: true,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0,
      xrSession: null,
      xrSpace: null,
      xrLayer: null,
      hitTestSource: null,
      controllers,
      hands,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio
      },
      transform,
      config: {
        scene: sceneConfig,
        performance: {
          targetFPS: 90,
          maxDrawCalls: 10000,
          enableStats: false
        },
        xr: {
          referenceSpaceType: options.xr?.referenceSpaceType ?? 'local-floor',
          sessionMode: options.xr?.sessionMode ?? 'immersive-vr',
          optionalFeatures: options.xr?.optionalFeatures ?? ['hand-tracking'],
          requiredFeatures: options.xr?.requiredFeatures ?? ['local-floor']
        }
      }
    };

    renderer.setAnimationLoop(this.render.bind(this));
  }

  /**
   * Initialize browser platform with standard WebGL support
   */
  private async initializeBrowser(options: BrowserInitOptions): Promise<void> {
    if (!OrbitControls) {
      const module = await import('three/examples/jsm/controls/OrbitControls.js');
      OrbitControls = module.OrbitControls;
    }

    const sceneConfig: SceneConfig = {
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance'
    };

    const renderer = new THREE.WebGLRenderer({
      canvas: options.canvas,
      ...sceneConfig
    });

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    const scene = new THREE.Scene();

    const controls = new OrbitControls(camera, options.canvas);
    Object.assign(controls, options.controls ?? {});
    controls.enableDamping = true;

    const transform: Transform = {
      position: [0, 0, 0],
      rotation: [0, 0, 0],
      scale: [1, 1, 1]
    };

    this.state.value = {
      type: 'browser',
      renderer,
      camera,
      scene,
      canvas: options.canvas,
      controls,
      isInitialized: true,
      isXRSupported: false,
      isWebGL2: true,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0,
      mousePosition: new THREE.Vector2(),
      touchActive: false,
      pointerLocked: false,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio
      },
      transform,
      config: {
        scene: sceneConfig,
        performance: {
          targetFPS: 60,
          maxDrawCalls: 10000,
          enableStats: false
        }
      }
    };

    this.startRenderLoop();
  }

  /**
   * Start XR session with specified mode (VR or AR)
   */
  async startXRSession(mode: 'immersive-vr' | 'immersive-ar'): Promise<XRSession> {
    const state = this.state.value;
    if (!state?.renderer) {
      throw new Error('Renderer not initialized');
    }

    try {
      if (!navigator.xr) {
        throw new Error('WebXR not supported');
      }

      const isSupported = await navigator.xr.isSessionSupported(mode);
      if (!isSupported) {
        throw new Error(`${mode} not supported`);
      }

      // Configure session features based on mode
      const sessionInit: XRSessionInit = {
        optionalFeatures: [],
        requiredFeatures: []
      };

      // Base features for both modes
      sessionInit.optionalFeatures = [
        'local-floor',
        'bounded-floor',
        'hand-tracking',
        'layers'
      ];

      // Add AR-specific features
      if (mode === 'immersive-ar') {
        sessionInit.optionalFeatures.push(
          'dom-overlay',
          'hit-test',
          'anchors',
          'plane-detection',
          'light-estimation'
        );
        sessionInit.requiredFeatures = ['hit-test'];
        sessionInit.domOverlay = { root: document.body };
      } else {
        // VR-specific features
        sessionInit.requiredFeatures = ['local-floor'];
      }

      const session = await navigator.xr.requestSession(mode, sessionInit);
      if (!session) {
        throw new Error('Failed to create XR session');
      }

      // Set up XR layer
      const gl = state.renderer.getContext();
      const xrLayer = new XRWebGLLayer(session, gl);
      await session.updateRenderState({ baseLayer: xrLayer });

      // Set reference space based on mode
      const referenceSpaceType = mode === 'immersive-ar' ? 'unbounded' : 'local-floor';
      const referenceSpace = await session.requestReferenceSpace(referenceSpaceType);

      // Set up hit testing for AR
      if (mode === 'immersive-ar' && 'requestHitTestSource' in session) {
        try {
          const hitTestSourcePromise = session.requestHitTestSource?.({
            space: referenceSpace
          });

          if (hitTestSourcePromise) {
            const hitTestSource = await hitTestSourcePromise;
            if (this.state.value && 'xrSession' in this.state.value) {
              this.state.value.hitTestSource = hitTestSource;
            }
          }
        } catch (error) {
          console.warn('Hit testing not available:', error);
        }
      }

      if (this.state.value && 'xrSession' in this.state.value) {
        this.state.value.xrSession = session;
        this.state.value.xrSpace = referenceSpace;
        this.state.value.xrLayer = xrLayer;
      }

      this.xrSessionMode = mode;

      // Set up session end handler
      session.addEventListener('end', () => {
        this.xrSessionMode = null;
        if (this.state.value && 'xrSession' in this.state.value) {
          this.state.value.xrSession = null;
          this.state.value.xrSpace = null;
          this.state.value.xrLayer = null;
          this.state.value.hitTestSource = null;
        }
      });

      // Update renderer and camera for AR
      if (mode === 'immersive-ar') {
        state.renderer.xr.setReferenceSpaceType('unbounded');
        const camera = state.camera;
        if (camera && 'aspect' in camera) {
          camera.near = 0.01;
          camera.far = 1000;
          camera.updateProjectionMatrix();
        }
      }

      return session;

    } catch (error) {
      console.error(`Error starting ${mode} session:`, error);
      throw error;
    }
  }

  /**
   * End current XR session
   */
  async endXRSession(): Promise<void> {
    const state = this.state.value;
    if (state && 'xrSession' in state && state.xrSession) {
      await state.xrSession.end();
    }
  }

  /**
   * Get current platform state
   */
  getState(): PlatformState | null {
    return this.state.value;
  }

  /**
   * Get platform capabilities
   */
  getCapabilities(): PlatformCapabilities | null {
    return this.capabilities.value;
  }

  /**
   * Get current platform type
   */
  getPlatform(): 'browser' | 'quest' {
    return this.platform;
  }

  /**
   * Check if current platform is Quest
   */
  isQuest(): boolean {
    return this.platform === 'quest';
  }

  /**
   * Check if current platform is browser
   */
  isBrowser(): boolean {
    return this.platform === 'browser';
  }

  /**
   * Check if XR is supported
   */
  hasXRSupport(): boolean {
    return !!this.capabilities.value?.xr;
  }

  /**
   * Check if XR session is active
   */
  isInXRSession(): boolean {
    return this.xrSessionMode !== null;
  }

  /**
   * Get current XR session mode
   */
  getXRSessionMode(): 'immersive-vr' | 'immersive-ar' | null {
    return this.xrSessionMode;
  }

  /**
   * Add resize callback
   */
  onResize(callback: ResizeCallback): () => void {
    this.resizeCallbacks.add(callback);
    return () => this.resizeCallbacks.delete(callback);
  }

  /**
   * Add render callback
   */
  onBeforeRender(callback: RenderCallback): () => void {
    this.renderCallbacks.add(callback);
    return () => this.renderCallbacks.delete(callback);
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.state.value) {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }

      this.resizeCallbacks.clear();
      this.renderCallbacks.clear();

      if (this.isQuest()) {
        const questState = this.state.value as QuestState;
        if (questState.xrSession) {
          questState.xrSession.end().catch(console.error);
        }
      }

      if (this.state.value.renderer) {
        this.state.value.renderer.dispose();
        this.state.value.renderer.forceContextLoss();
      }

      this.state.value = null;
    }
  }

  /**
   * Detect platform and capabilities
   */
  private async detectPlatform() {
    const isQuest = /Oculus|Quest|VR/i.test(navigator.userAgent);
    const xrSupported = 'xr' in navigator;
    const webgl2 = this.checkWebGL2Support();

    // Check AR and VR support
    let arSupported = false;
    let vrSupported = false;
    
    if (xrSupported && navigator.xr) {
      try {
        arSupported = await navigator.xr.isSessionSupported('immersive-ar');
        vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      } catch (error) {
        console.warn('Error checking XR support:', error);
      }
    }

    this.capabilities.value = {
      webgl2,
      xr: xrSupported,
      ar: arSupported,
      vr: vrSupported,
      maxTextureSize: 4096,
      maxDrawCalls: 10000,
      gpuTier: 1
    };

    this.platform = isQuest ? 'quest' : 'browser';
  }

  /**
   * Check WebGL2 support
   */
  private checkWebGL2Support(): boolean {
    try {
      const canvas = document.createElement('canvas');
      return !!canvas.getContext('webgl2');
    } catch {
      return false;
    }
  }

  /**
   * Set up resize handler
   */
  private setupResizeHandler() {
    const handleResize = () => {
      const state = this.state.value;
      if (!state?.canvas || !state.renderer) return;

      const width = window.innerWidth;
      const height = window.innerHeight;
      const pixelRatio = window.devicePixelRatio;

      state.renderer.setSize(width, height);
      state.renderer.setPixelRatio(pixelRatio);

      if (state.camera && 'aspect' in state.camera) {
        state.camera.aspect = width / height;
        state.camera.updateProjectionMatrix();
      }

      state.viewport = {
        width,
        height,
        pixelRatio
      };

      this.resizeCallbacks.forEach(callback => callback(width, height));
    };

    window.addEventListener('resize', handleResize);
  }

  /**
   * Render loop
   */
  private render() {
    const state = this.state.value;
    if (!state?.renderer || !state.scene || !state.camera) return;

    const now = performance.now();
    const deltaTime = now - this.lastFrameTime;
    this.lastFrameTime = now;

    // Update FPS
    state.fps = 1000 / deltaTime;
    state.lastFrameTime = now;

    if (this.platform === 'browser') {
      const browserState = state as BrowserState;
      if (browserState.controls) {
        browserState.controls.update();
      }
    }

    // Execute render callbacks
    this.renderCallbacks.forEach(callback => {
      if (state.renderer && state.scene && state.camera) {
        callback(state.renderer, state.scene, state.camera);
      }
    });

    // Final render
    state.renderer.render(state.scene, state.camera);
  }

  /**
   * Start render loop
   */
  private startRenderLoop() {
    const animate = () => {
      this.render();
      this.animationFrameId = requestAnimationFrame(animate);
    };
    animate();
  }
}

export const platformManager = PlatformManager.getInstance();

----
constants/visualization.ts
import * as THREE from 'three';

export const VISUALIZATION_CONSTANTS = {
  TRANSLATION_SPEED: 0.01,
  ROTATION_SPEED: 0.01,
  VR_MOVEMENT_SPEED: 0.05,
  MIN_CAMERA_DISTANCE: 50,
  MAX_CAMERA_DISTANCE: 500,
  DEFAULT_FOV: 50,
  NEAR_PLANE: 0.1,
  FAR_PLANE: 2000,
  DEFAULT_CAMERA_POSITION: [0, 75, 200] as [number, number, number],
  DEFAULT_CAMERA_TARGET: [0, 0, 0] as [number, number, number]
};

export const SCENE_SETTINGS = {
  fogNear: 1,
  fogFar: 5,
  gridSize: 2,
  gridDivisions: 20
};

export const FORCE_SETTINGS = {
  linkDistance: 0.3,
  linkStrength: 1,
  charge: -30,
  alpha: 1,
  alphaDecay: 0.02,
  velocityDecay: 0.4
};

export const CAMERA_SETTINGS = {
  fov: 60,
  near: 0.01,
  far: 10000,
  position: new THREE.Vector3(0, 0.5, 2),
  target: new THREE.Vector3(0, 0, 0)
};

export const WEBGL_CONTEXT_ATTRIBUTES: WebGLContextAttributes = {
  alpha: false,
  antialias: true,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  preserveDrawingBuffer: true,
  xrCompatible: true
};

export const RENDERER_SETTINGS = {
  clearColor: 0x000000,
  clearAlpha: 1,
  pixelRatio: Math.min(window.devicePixelRatio, 2),
  toneMapping: THREE.ACESFilmicToneMapping,
  toneMappingExposure: 1.5,
  outputColorSpace: THREE.SRGBColorSpace
};

export const LIGHT_SETTINGS = {
  ambient: {
    color: 0xffffff,
    intensity: 1.5
  },
  directional: {
    color: 0xffffff,
    intensity: 2.0,
    position: [10, 20, 10] as [number, number, number]
  },
  hemisphere: {
    skyColor: 0xffffff,
    groundColor: 0x444444,
    intensity: 1.5
  },
  points: [
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [100, 100, 100] as [number, number, number]
    },
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [-100, -100, -100] as [number, number, number]
    }
  ]
};

export const CONTROLS_SETTINGS = {
  enableDamping: true,
  dampingFactor: 0.1,
  rotateSpeed: 0.4,
  panSpeed: 0.6,
  zoomSpeed: 1.2,
  minDistance: 50,
  maxDistance: 500
};

----
constants/websocket.ts
// Binary protocol scale factors for network transmission
export const POSITION_SCALE = 10000; // Increased from 1000 to handle larger boundaries (up to ±600 units)
export const VELOCITY_SCALE = 20000; // Increased from 10000 to handle higher velocities (up to 20 units)

// WebSocket configuration defaults
export const DEFAULT_RECONNECT_ATTEMPTS = 3;
export const DEFAULT_RECONNECT_DELAY = 5000;
export const DEFAULT_MESSAGE_RATE_LIMIT = 60;
export const DEFAULT_MESSAGE_TIME_WINDOW = 1000;
export const DEFAULT_MAX_MESSAGE_SIZE = 5 * 1024 * 1024; // 5MB
export const DEFAULT_MAX_AUDIO_SIZE = 10 * 1024 * 1024; // 10MB
export const DEFAULT_MAX_QUEUE_SIZE = 1000;

// Connection timeouts (matching server)
export const CONNECTION_TIMEOUT = 10000;      // 10 seconds to establish connection
export const HEARTBEAT_INTERVAL = 15000;      // 15 seconds between pings (matching server)
export const HEARTBEAT_TIMEOUT = 60000;       // 60 seconds to receive pong (matching server)

// Binary protocol constants
export const BINARY_UPDATE_NODE_SIZE = 24;    // 6 float32s per node (position + velocity)
export const FLOAT32_SIZE = 4;                // Size of Float32 in bytes

// Validation constants
export const MAX_VALID_POSITION = 1000;       // Maximum valid position value
export const MAX_VALID_VELOCITY = 50;         // Maximum valid velocity value
export const MIN_VALID_POSITION = -1000;      // Minimum valid position value
export const MIN_VALID_VELOCITY = -50;        // Minimum valid velocity value

// Performance thresholds
export const MAX_PERFORMANCE_SAMPLES = 100;    // Number of samples to keep for performance metrics
export const PERFORMANCE_RESET_INTERVAL = 60000; // Reset performance metrics every minute
export const MAX_MESSAGE_PROCESSING_TIME = 100;  // Maximum acceptable message processing time (ms)
export const MAX_POSITION_UPDATE_TIME = 16;      // Maximum acceptable position update time (ms)

// Debug flags
export const ENABLE_BINARY_DEBUG = true;         // Enable detailed binary update logging
export const ENABLE_POSITION_VALIDATION = true;  // Enable position/velocity validation
export const ENABLE_PERFORMANCE_LOGGING = true;  // Enable performance metric logging

// Server message types (matching server's ServerMessage enum)
export const SERVER_MESSAGE_TYPES = {
    // Direct server message types from ServerMessage enum
    GRAPH_UPDATE: 'graphUpdate',
    ERROR: 'error',
    POSITION_UPDATE_COMPLETE: 'positionUpdateComplete',
    SETTINGS_UPDATED: 'settingsUpdated',
    SIMULATION_MODE_SET: 'simulationModeSet',
    FISHEYE_SETTINGS_UPDATED: 'fisheyeSettingsUpdated',
    BINARY_POSITION_UPDATE: 'binaryPositionUpdate',
    
    // Additional client-side message types
    INITIAL_DATA: 'initialData',
    GPU_STATE: 'gpuState',
    LAYOUT_STATE: 'layoutState',
    OPENAI_RESPONSE: 'openaiResponse',
    RAGFLOW_RESPONSE: 'ragflowResponse',
    COMPLETION: 'completion',
    UPDATE_SETTINGS: 'updateSettings'
} as const;

// Error codes (matching server error structure)
export const ERROR_CODES = {
    // Connection errors
    CONNECTION_FAILED: 'CONNECTION_FAILED',
    MAX_RETRIES_EXCEEDED: 'MAX_RETRIES_EXCEEDED',
    HEARTBEAT_TIMEOUT: 'HEARTBEAT_TIMEOUT',
    
    // Message errors
    MESSAGE_TOO_LARGE: 'MESSAGE_TOO_LARGE',
    INVALID_MESSAGE: 'INVALID_MESSAGE',
    
    // Data validation errors
    INVALID_POSITION: 'INVALID_POSITION',
    INVALID_VELOCITY: 'INVALID_VELOCITY',
    
    // Graph errors
    INVALID_NODE: 'INVALID_NODE',
    INVALID_EDGE: 'INVALID_EDGE',
    
    // State errors
    INVALID_STATE: 'INVALID_STATE',
    SIMULATION_ERROR: 'SIMULATION_ERROR'
} as const;

// Message field names (matching server struct fields)
export const MESSAGE_FIELDS = {
    // GraphUpdate fields
    GRAPH_DATA: 'graphData',
    
    // Error fields
    MESSAGE: 'message',
    CODE: 'code',
    DETAILS: 'details',
    
    // PositionUpdateComplete fields
    STATUS: 'status',
    
    // SimulationModeSet fields
    MODE: 'mode',
    GPU_ENABLED: 'gpuEnabled',
    
    // FisheyeSettingsUpdated fields
    ENABLED: 'enabled',
    STRENGTH: 'strength',
    FOCUS_POINT: 'focusPoint',
    RADIUS: 'radius',

    // Settings fields
    SETTINGS: 'settings',
    MATERIAL: 'material',
    BLOOM: 'bloom',
    FISHEYE: 'fisheye',

    // Binary update fields
    IS_INITIAL_LAYOUT: 'isInitialLayout'
} as const;

----
composables/useForceGraph.ts
import { ref, onBeforeUnmount } from 'vue';
import * as THREE from 'three';
import { useSettingsStore } from '../stores/settings';
import type { Scene, InstancedMesh, Material } from 'three';
import type { Node, Edge } from '../types/core';

interface NodeInstance {
  id: string;
  index: number;
  x: number;
  y: number;
  z: number;
  metadata?: Record<string, any>;
}

interface LinkInstance {
  source: string;
  target: string;
  weight?: number;
}

interface NodeColors {
  NEW: THREE.Color;
  RECENT: THREE.Color;
  MEDIUM: THREE.Color;
  OLD: THREE.Color;
  CORE: THREE.Color;
  SECONDARY: THREE.Color;
  DEFAULT: THREE.Color;
}

interface NodeInstancedMeshes {
  high: THREE.InstancedMesh;
  medium: THREE.InstancedMesh;
  low: THREE.InstancedMesh;
}

interface ForceGraphResources {
  lod: THREE.LOD;
  nodeInstancedMeshes: NodeInstancedMeshes;
  linkInstancedMesh: THREE.InstancedMesh;
  nodeInstances: Map<string, number>;
  linkInstances: Map<string, number>;
  nodeInstanceCount: number;
  linkInstanceCount: number;
}

export function useForceGraph(scene: Scene) {
  const settingsStore = useSettingsStore();
  const resources = ref<ForceGraphResources | null>(null);
  
  // Temporary objects for matrix calculations
  const tempMatrix = new THREE.Matrix4();
  const tempColor = new THREE.Color();
  const tempVector = new THREE.Vector3();
  const tempQuaternion = new THREE.Quaternion();
  const tempScale = new THREE.Vector3();

  // Data
  const nodes = ref<NodeInstance[]>([]);
  const links = ref<LinkInstance[]>([]);

  // Initialize node colors from settings
  const nodeColors: NodeColors = {
    NEW: new THREE.Color(settingsStore.getVisualizationSettings.node_color_new),
    RECENT: new THREE.Color(settingsStore.getVisualizationSettings.node_color_recent),
    MEDIUM: new THREE.Color(settingsStore.getVisualizationSettings.node_color_medium),
    OLD: new THREE.Color(settingsStore.getVisualizationSettings.node_color_old),
    CORE: new THREE.Color(settingsStore.getVisualizationSettings.node_color_core),
    SECONDARY: new THREE.Color(settingsStore.getVisualizationSettings.node_color_secondary),
    DEFAULT: new THREE.Color(settingsStore.getVisualizationSettings.node_color)
  };

  const initInstancedMeshes = () => {
    // Create node geometry with different LOD levels
    const highDetailGeometry = new THREE.SphereGeometry(1, 32, 32);
    const mediumDetailGeometry = new THREE.SphereGeometry(1, 16, 16);
    const lowDetailGeometry = new THREE.SphereGeometry(1, 8, 8);

    const settings = settingsStore.getVisualizationSettings;

    // Create node material
    const nodeMaterial = new THREE.MeshPhysicalMaterial({
      metalness: settings.material.node_material_metalness,
      roughness: settings.material.node_material_roughness,
      transparent: true,
      opacity: settings.material.node_material_opacity,
      envMapIntensity: 1.0,
      clearcoat: settings.material.node_material_clearcoat,
      clearcoatRoughness: settings.material.node_material_clearcoat_roughness
    });

    // Create instanced meshes for each LOD level
    const maxInstances = 10000; // Adjust based on expected graph size
    const nodeInstancedMeshes: NodeInstancedMeshes = {
      high: new THREE.InstancedMesh(highDetailGeometry, nodeMaterial.clone(), maxInstances),
      medium: new THREE.InstancedMesh(mediumDetailGeometry, nodeMaterial.clone(), maxInstances),
      low: new THREE.InstancedMesh(lowDetailGeometry, nodeMaterial.clone(), maxInstances)
    };

    // Create LOD
    const lod = new THREE.LOD();
    lod.addLevel(nodeInstancedMeshes.high, 0);
    lod.addLevel(nodeInstancedMeshes.medium, 10);
    lod.addLevel(nodeInstancedMeshes.low, 20);
    scene.add(lod);

    // Create link geometry
    const linkGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 8, 1);
    linkGeometry.rotateX(Math.PI / 2); // Align with Z-axis

    // Create link material
    const linkMaterial = new THREE.MeshBasicMaterial({
      color: settings.edge_color,
      transparent: true,
      opacity: settings.edge_opacity,
      depthWrite: false
    });

    // Create instanced mesh for links
    const linkInstancedMesh = new THREE.InstancedMesh(
      linkGeometry,
      linkMaterial,
      maxInstances * 2 // Links typically more numerous than nodes
    );
    scene.add(linkInstancedMesh);

    resources.value = {
      lod,
      nodeInstancedMeshes,
      linkInstancedMesh,
      nodeInstances: new Map(),
      linkInstances: new Map(),
      nodeInstanceCount: 0,
      linkInstanceCount: 0
    };
  };

  const getNodeSize = (node: NodeInstance): number => {
    const settings = settingsStore.getVisualizationSettings;
    const baseSize = (node.metadata?.size || 1) * settings.min_node_size;
    const weight = node.metadata?.weight || 1;
    return Math.min(baseSize * Math.sqrt(weight), settings.max_node_size);
  };

  const getNodeColor = (node: NodeInstance): THREE.Color => {
    const type = node.metadata?.type || 'DEFAULT';
    return nodeColors[type as keyof NodeColors] || nodeColors.DEFAULT;
  };

  const calculateEmissiveIntensity = (node: NodeInstance): number => {
    const settings = settingsStore.getVisualizationSettings;
    const lastModified = node.metadata?.github_last_modified || 
                        node.metadata?.last_modified || 
                        new Date().toISOString();
    const now = Date.now();
    const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
    
    const normalizedAge = Math.min(ageInDays / 30, 1);
    return settings.material.node_emissive_max_intensity - 
           (normalizedAge * (settings.material.node_emissive_max_intensity - 
                           settings.material.node_emissive_min_intensity));
  };

  const updateNodes = () => {
    const res = resources.value;
    if (!res) return;

    // Reset instance count
    res.nodeInstanceCount = 0;

    // Update node instances
    nodes.value.forEach((node: NodeInstance, index: number) => {
      const size = getNodeSize(node);
      const color = getNodeColor(node);
      const emissiveIntensity = calculateEmissiveIntensity(node);

      // Set transform matrix
      tempMatrix.compose(
        new THREE.Vector3(node.x, node.y, node.z),
        tempQuaternion,
        new THREE.Vector3(size, size, size)
      );

      // Update instances for each LOD level
      (Object.values(res.nodeInstancedMeshes) as THREE.InstancedMesh[]).forEach(instancedMesh => {
        instancedMesh.setMatrixAt(index, tempMatrix);
        instancedMesh.setColorAt(index, color);
        (instancedMesh.material as THREE.MeshPhysicalMaterial).emissiveIntensity = emissiveIntensity;
      });

      res.nodeInstances.set(node.id, index);
      res.nodeInstanceCount = Math.max(res.nodeInstanceCount, index + 1);
    });

    // Update instance meshes
    (Object.values(res.nodeInstancedMeshes) as THREE.InstancedMesh[]).forEach(instancedMesh => {
      instancedMesh.count = res.nodeInstanceCount;
      instancedMesh.instanceMatrix.needsUpdate = true;
      if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
    });
  };

  const updateLinks = () => {
    const res = resources.value;
    if (!res) return;

    // Reset instance count
    res.linkInstanceCount = 0;

    // Update link instances
    links.value.forEach((link: LinkInstance, index: number) => {
      const sourceIndex = res.nodeInstances.get(link.source);
      const targetIndex = res.nodeInstances.get(link.target);

      if (sourceIndex === undefined || targetIndex === undefined) return;

      const sourceNode = nodes.value[sourceIndex];
      const targetNode = nodes.value[targetIndex];

      const sourcePos = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
      const targetPos = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);

      // Calculate link transform
      const distance = sourcePos.distanceTo(targetPos);
      tempVector.subVectors(targetPos, sourcePos);
      tempQuaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, 1),
        tempVector.normalize()
      );

      tempMatrix.compose(
        sourcePos.lerp(targetPos, 0.5), // Position at midpoint
        tempQuaternion,
        new THREE.Vector3(1, 1, distance)
      );

      // Update link instance
      res.linkInstancedMesh.setMatrixAt(index, tempMatrix);
      
      const weight = link.weight || 1;
      const normalizedWeight = Math.min(weight / 10, 1);
      const settings = settingsStore.getVisualizationSettings;
      tempColor.set(settings.edge_color).multiplyScalar(normalizedWeight);
      res.linkInstancedMesh.setColorAt(index, tempColor);

      res.linkInstances.set(`${link.source}-${link.target}`, index);
      res.linkInstanceCount = Math.max(res.linkInstanceCount, index + 1);
    });

    // Update link instance mesh
    res.linkInstancedMesh.count = res.linkInstanceCount;
    res.linkInstancedMesh.instanceMatrix.needsUpdate = true;
    if (res.linkInstancedMesh.instanceColor) {
      res.linkInstancedMesh.instanceColor.needsUpdate = true;
    }
  };

  const updateGraph = (graphNodes: Node[], graphEdges: Edge[]) => {
    // Convert graph data to internal format
    nodes.value = graphNodes.map(node => ({
      id: node.id,
      index: 0,
      x: node.position?.[0] || 0,
      y: node.position?.[1] || 0,
      z: node.position?.[2] || 0,
      metadata: node.metadata
    }));

    links.value = graphEdges.map(edge => ({
      source: edge.source,
      target: edge.target,
      weight: edge.weight
    }));

    // Update visualization
    updateNodes();
    updateLinks();
  };

  const dispose = () => {
    const res = resources.value;
    if (!res) return;

    // Dispose of node resources
    (Object.values(res.nodeInstancedMeshes) as THREE.InstancedMesh[]).forEach(instancedMesh => {
      instancedMesh.geometry.dispose();
      if (instancedMesh.material instanceof THREE.Material) {
        instancedMesh.material.dispose();
      } else if (Array.isArray(instancedMesh.material)) {
        instancedMesh.material.forEach((mat: Material) => mat.dispose());
      }
    });

    // Dispose of link resources
    res.linkInstancedMesh.geometry.dispose();
    if (res.linkInstancedMesh.material instanceof THREE.Material) {
      res.linkInstancedMesh.material.dispose();
    } else if (Array.isArray(res.linkInstancedMesh.material)) {
      res.linkInstancedMesh.material.forEach((mat: Material) => mat.dispose());
    }

    // Remove from scene
    scene.remove(res.lod);
    scene.remove(res.linkInstancedMesh);

    // Clear collections
    res.nodeInstances.clear();
    res.linkInstances.clear();
    nodes.value = [];
    links.value = [];
    resources.value = null;
  };

  // Initialize on creation
  initInstancedMeshes();

  // Clean up on unmount
  onBeforeUnmount(() => {
    dispose();
  });

  return {
    updateGraph,
    dispose
  };
}

----
composables/useEffectsSystem.ts
import { ref, computed, watch, onMounted, onBeforeUnmount } from 'vue';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
import { useSettingsStore } from '@stores/settings';
import { usePlatform } from './usePlatform';
import { PASS_OUTPUT } from '../utils/threeUtils';

// Configure color management for modern Three.js
THREE.ColorManagement.enabled = true;

interface ExtendedUnrealBloomPass extends UnrealBloomPass {
  selectedObjects?: THREE.Object3D[];
}

export function useEffectsSystem(
  renderer: THREE.WebGLRenderer,
  scene: THREE.Scene,
  camera: THREE.PerspectiveCamera
) {
  const settingsStore = useSettingsStore();
  const { getPlatformInfo } = usePlatform();

  // Effect composer and passes
  const composer = ref<EffectComposer | null>(null);
  const bloomPass = ref<ExtendedUnrealBloomPass | null>(null);
  const ssaoPass = ref<SSAOPass | null>(null);
  const fxaaPass = ref<ShaderPass | null>(null);

  // Settings
  const bloomSettings = computed(() => settingsStore.getBloomSettings);
  const platformInfo = computed(() => getPlatformInfo());

  // Resolution
  const resolution = computed(() => {
    const pixelRatio = renderer.getPixelRatio();
    const size = new THREE.Vector2();
    renderer.getSize(size);
    return new THREE.Vector2(
      size.width * pixelRatio,
      size.height * pixelRatio
    );
  });

  // Initialize effect composer
  const initializeComposer = () => {
    // Create render target with appropriate color space
    const renderTarget = new THREE.WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight,
      {
        colorSpace: THREE.SRGBColorSpace,
        samples: (renderer as any).capabilities.isWebGL2 ? 4 : 0
      }
    );

    // Create new composer
    composer.value = new EffectComposer(renderer as any, renderTarget as any);

    // Add render pass
    const renderPass = new RenderPass(scene as any, camera as any);
    (composer.value as any).addPass(renderPass);

    // Initialize bloom if enabled
    if (bloomSettings.value.enabled) {
      const bloom = new UnrealBloomPass(
        resolution.value,
        bloomSettings.value.strength,
        bloomSettings.value.radius,
        bloomSettings.value.threshold
      ) as ExtendedUnrealBloomPass;
      bloomPass.value = bloom;
      (composer.value as any).addPass(bloom);
    }

    // Initialize SSAO for browser platform
    if (platformInfo.value.isBrowser) {
      const ssao = new SSAOPass(scene as any, camera as any);
      ssao.output = PASS_OUTPUT.Default;
      ssaoPass.value = ssao;
      (composer.value as any).addPass(ssao);
    }

    // Initialize FXAA
    const fxaa = new ShaderPass(FXAAShader);
    const uniforms = fxaa.material.uniforms;
    if (uniforms['resolution']) {
      uniforms['resolution'].value.x = 1 / resolution.value.x;
      uniforms['resolution'].value.y = 1 / resolution.value.y;
    }
    fxaaPass.value = fxaa;
    (composer.value as any).addPass(fxaa);
  };

  // Update effect settings
  const updateBloomSettings = () => {
    if (!bloomPass.value) return;

    const settings = bloomSettings.value;
    bloomPass.value.strength = settings.strength;
    bloomPass.value.radius = settings.radius;
    bloomPass.value.threshold = settings.threshold;

    // Update selective bloom settings
    const selectedObjects: THREE.Object3D[] = [];

    // Add objects based on bloom settings
    scene.traverse((object) => {
      if (object.userData.bloomLayer) {
        if (settings.node_bloom_strength > 0 && object.userData.type === 'node') {
          selectedObjects.push(object);
        }
        if (settings.edge_bloom_strength > 0 && object.userData.type === 'edge') {
          selectedObjects.push(object);
        }
        if (settings.environment_bloom_strength > 0 && object.userData.type === 'environment') {
          selectedObjects.push(object);
        }
      }
    });

    // Set selected objects for bloom
    bloomPass.value.selectedObjects = selectedObjects;
  };

  // Handle resize
  const handleResize = () => {
    if (!composer.value || !fxaaPass.value) return;

    const size = new THREE.Vector2();
    renderer.getSize(size);
    composer.value.setSize(size.width, size.height);

    // Update FXAA resolution
    const pixelRatio = renderer.getPixelRatio();
    const uniforms = fxaaPass.value.material.uniforms;
    if (uniforms['resolution']) {
      uniforms['resolution'].value.x = 1 / (size.width * pixelRatio);
      uniforms['resolution'].value.y = 1 / (size.height * pixelRatio);
    }
  };

  // Render function
  const render = () => {
    if (composer.value) {
      composer.value.render();
    }
  };

  // Watch for settings changes
  watch(() => bloomSettings.value, () => {
    updateBloomSettings();
  }, { deep: true });

  // Lifecycle
  onMounted(() => {
    initializeComposer();
    window.addEventListener('resize', handleResize);
  });

  onBeforeUnmount(() => {
    window.removeEventListener('resize', handleResize);
    
    // Dispose of resources
    if (composer.value) {
      composer.value.passes.forEach(pass => {
        if ('dispose' in pass && typeof pass.dispose === 'function') {
          pass.dispose();
        }
      });
    }

    // Clear references
    bloomPass.value = null;
    ssaoPass.value = null;
    fxaaPass.value = null;
    composer.value = null;
  });

  return {
    composer,
    bloomPass,
    ssaoPass,
    fxaaPass,
    render,
    handleResize,
    updateBloomSettings
  };
}

----
composables/useControlGroups.ts
import { ref, reactive } from 'vue';
import type { ControlGroup, ControlItem } from '../types/components';

export function useControlGroups() {
  const collapsedGroups = reactive<Record<string, boolean>>({
    appearance: true,
    material: true,
    physics: true,
    bloom: true,
    environment: true,
    fisheye: true
  });

  const toggleGroup = (groupName: string) => {
    collapsedGroups[groupName] = !collapsedGroups[groupName];
  };

  const createControlGroup = (
    name: string,
    label: string,
    controls: ControlItem[]
  ): ControlGroup => ({
    name,
    label,
    controls,
    collapsed: collapsedGroups[name]
  });

  const createRangeControl = (
    name: string,
    label: string,
    value: number,
    min: number,
    max: number,
    step: number
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'range',
    min,
    max,
    step
  });

  const createColorControl = (
    name: string,
    label: string,
    value: string
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'color'
  });

  const createCheckboxControl = (
    name: string,
    label: string,
    value: boolean
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'checkbox'
  });

  return {
    collapsedGroups,
    toggleGroup,
    createControlGroup,
    createRangeControl,
    createColorControl,
    createCheckboxControl
  };
}

----
composables/useVisualization.ts
import { ref, computed, onBeforeUnmount, provide, markRaw, shallowRef, watch } from 'vue';
import * as THREE from 'three';
import { OrbitControls as ThreeOrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { 
  forceSimulation, 
  forceLink, 
  forceManyBody, 
  forceCenter,
  Simulation,
  SimulationNodeDatum,
  SimulationLinkDatum,
  ForceLink
} from 'd3-force-3d';
import { useSettingsStore } from '../stores/settings';
import { useVisualizationStore } from '../stores/visualization';
import { useBinaryUpdateStore } from '../stores/binaryUpdate';
import { useWebSocketStore } from '../stores/websocket';
import type { Node, Edge, CoreState, InitializationOptions, GraphNode, GraphEdge, GraphData } from '../types/core';
import { POSITION_SCALE } from '../constants/websocket';
import { VISUALIZATION_CONSTANTS as CONSTANTS, LIGHT_SETTINGS, SCENE_SETTINGS, FORCE_SETTINGS, CAMERA_SETTINGS } from '../constants/visualization';

// Symbol for providing scene to components
export const SCENE_KEY = Symbol('three-scene');

// Extend SimulationNodeDatum to include our node properties
interface ForceNode extends SimulationNodeDatum {
  id: string;
  x?: number;
  y?: number;
  z?: number;
  position?: [number, number, number];
  velocity?: [number, number, number];
  fx?: number | null;
  fy?: number | null;
  fz?: number | null;
}

// Add binary data helper
function createBinaryPositionData(nodes: ForceNode[]): ArrayBuffer {
  // 4 bytes for header + 24 bytes per node (x,y,z,vx,vy,vz as f32)
  const buffer = new ArrayBuffer(4 + nodes.length * 24);
  const view = new DataView(buffer);
  
  // Write header (1.0 to indicate client-side force update)
  view.setFloat32(0, 1.0, true);
  
  // Write node positions and velocities
  nodes.forEach((node, i) => {
    const offset = 4 + i * 24;
    view.setFloat32(offset, node.x || 0, true);
    view.setFloat32(offset + 4, node.y || 0, true);
    view.setFloat32(offset + 8, node.z || 0, true);
    view.setFloat32(offset + 12, node.vx || 0, true);
    view.setFloat32(offset + 16, node.vy || 0, true);
    view.setFloat32(offset + 20, node.vz || 0, true);
  });
  
  return buffer;
}

export function useVisualization() {
  const settingsStore = useSettingsStore();
  const visualizationStore = useVisualizationStore();
  const binaryStore = useBinaryUpdateStore();
  const webSocketStore = useWebSocketStore();
  
  // Core visualization state
  const state = shallowRef<CoreState>({
    renderer: null,
    camera: null,
    scene: null,
    canvas: null,
    isInitialized: false,
    isXRSupported: false,
    isWebGL2: false,
    isGPUMode: false,
    fps: 0,
    lastFrameTime: 0
  });

  // Mesh cache using Maps for O(1) lookup
  const meshCache = {
    nodes: new Map<string, THREE.Mesh>()
  };

  // Interaction state
  const hoveredNode = ref<string | null>(null);
  const selectedNode = ref<string | null>(null);
  const isProcessingUpdate = ref(false);
  const isInteracting = ref(false);

  // GPU acceleration state
  const isGPUEnabled = computed(() => webSocketStore.isGPUEnabled);

  // Track animation frame for cleanup
  let animationFrameId: number | null = null;
  let controls: ThreeOrbitControls | null = null;

  // Initialize force simulation (only used during interactions)
  const simulation = forceSimulation<ForceNode>()
    .stop() // Initially stopped since we use server updates by default
    .alpha(FORCE_SETTINGS.alpha)
    .alphaDecay(FORCE_SETTINGS.alphaDecay)
    .velocityDecay(FORCE_SETTINGS.velocityDecay)
    .force('link', forceLink<ForceNode>()
      .id((d: ForceNode) => d.id)
      .distance(FORCE_SETTINGS.linkDistance)
      .strength(FORCE_SETTINGS.linkStrength))
    .force('charge', forceManyBody<ForceNode>()
      .strength(FORCE_SETTINGS.charge))
    .force('center', forceCenter());

  // Public method to trigger immediate layout updates
  const updateLayoutPositions = () => {
    if (!isInteracting.value) {
      startInteraction();
    }
    
    // Reheat the simulation for immediate updates
    simulation
      .alpha(FORCE_SETTINGS.alpha)
      .restart();
  };

  // Create or update node mesh with efficient caching
  const createNodeMesh = (node: Node): THREE.Mesh => {
    const geometry = new THREE.SphereGeometry(0.02, 32, 32);
    const material = new THREE.MeshStandardMaterial({
      color: node.color || 0xffffff,
      metalness: 0.3,
      roughness: 0.7,
      emissive: node.color || 0xffffff,
      emissiveIntensity: 0.2
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    if (node.position) {
      mesh.position.set(
        node.position[0] / POSITION_SCALE,
        node.position[1] / POSITION_SCALE,
        node.position[2] / POSITION_SCALE
      );
    }
    
    const size = (node.size || 1) * 0.02;
    mesh.scale.setScalar(size);

    mesh.userData = {
      id: node.id,
      type: 'node',
      originalData: { ...node }
    };

    return markRaw(mesh);
  };

  // Initialize Three.js scene
  const initScene = (canvas: HTMLCanvasElement) => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, SCENE_SETTINGS.fogNear, SCENE_SETTINGS.fogFar);

    const camera = new THREE.PerspectiveCamera(
      CAMERA_SETTINGS.fov,
      window.innerWidth / window.innerHeight,
      CAMERA_SETTINGS.near,
      CAMERA_SETTINGS.far
    );
    camera.position.copy(CAMERA_SETTINGS.position);
    camera.lookAt(CAMERA_SETTINGS.target);

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance',
      logarithmicDepthBuffer: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Add lights
    const ambientLight = new THREE.AmbientLight(
      LIGHT_SETTINGS.ambient.color,
      LIGHT_SETTINGS.ambient.intensity
    );
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(
      LIGHT_SETTINGS.directional.color,
      LIGHT_SETTINGS.directional.intensity
    );
    directionalLight.position.set(...LIGHT_SETTINGS.directional.position);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    const hemiLight = new THREE.HemisphereLight(
      LIGHT_SETTINGS.hemisphere.skyColor,
      LIGHT_SETTINGS.hemisphere.groundColor,
      LIGHT_SETTINGS.hemisphere.intensity
    );
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    // Add controls
    controls = new ThreeOrbitControls(camera, renderer.domElement);
    if (controls) {
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxDistance = 5;
      controls.minDistance = 0.1;
      controls.maxPolarAngle = Math.PI * 0.8;
      controls.target.copy(CAMERA_SETTINGS.target);
    }

    // Add grid helper
    const gridHelper = new THREE.GridHelper(
      SCENE_SETTINGS.gridSize,
      SCENE_SETTINGS.gridDivisions,
      0x444444,
      0x222222
    );
    scene.add(gridHelper);

    // Add axes helper
    const axesHelper = new THREE.AxesHelper(1);
    scene.add(axesHelper);

    // Store GPU state in scene
    scene.userData.gpuEnabled = isGPUEnabled.value;

    provide(SCENE_KEY, scene);

    return {
      scene: markRaw(scene),
      camera: markRaw(camera),
      renderer: markRaw(renderer)
    };
  };

  // Animation loop with optimized updates and continuous server sync
  const animate = () => {
    if (!state.value.isInitialized) return;

    const { renderer, scene, camera } = state.value;
    if (renderer && scene && camera) {
      controls?.update();

      // Update positions based on interaction state
      if (isInteracting.value) {
        // Use local force simulation during interaction
        simulation.tick();
        
        // Update mesh positions
        simulation.nodes().forEach((node: ForceNode) => {
          const mesh = meshCache.nodes.get(node.id);
          if (mesh && typeof node.x === 'number' && typeof node.y === 'number' && typeof node.z === 'number') {
            mesh.position.set(
              node.x / POSITION_SCALE,
              node.y / POSITION_SCALE,
              node.z / POSITION_SCALE
            );
          }
        });

        // Send binary update to server
        const binaryData = createBinaryPositionData(simulation.nodes());
        webSocketStore.sendBinary(binaryData);

        scene.userData.needsRender = true;
      } else {
        // Use server-provided positions when not interacting
        const positions = binaryStore.getAllPositions;
        const nodeCount = binaryStore.nodeCount;
        
        for (let i = 0; i < nodeCount; i++) {
          const node = simulation.nodes()[i] as ForceNode;
          if (!node) continue;

          const mesh = meshCache.nodes.get(node.id);
          if (!mesh) continue;

          const posOffset = i * 3;
          mesh.position.set(
            positions[posOffset] / POSITION_SCALE,
            positions[posOffset + 1] / POSITION_SCALE,
            positions[posOffset + 2] / POSITION_SCALE
          );
        }
      }

      const currentTime = performance.now();
      const delta = currentTime - state.value.lastFrameTime;
      state.value.fps = 1000 / delta;
      state.value.lastFrameTime = currentTime;

      const needsRender = scene.userData?.needsRender !== false || 
                         controls?.enabled || 
                         currentTime - (scene.userData?.lastUpdate || 0) > 1000;

      if (needsRender) {
        renderer.render(scene, camera);
        scene.userData.needsRender = false;
        scene.userData.lastUpdate = currentTime;
      }
    }

    animationFrameId = requestAnimationFrame(animate);
  };

  // Initialize visualization system
  const initialize = async (options: InitializationOptions) => {
    if (state.value.isInitialized) return;

    try {
      const { scene, camera, renderer } = initScene(options.canvas);

      state.value = markRaw({
        renderer,
        camera,
        scene,
        canvas: options.canvas,
        isInitialized: true,
        isXRSupported: false,
        isWebGL2: renderer.capabilities.isWebGL2,
        isGPUMode: isGPUEnabled.value,
        fps: 0,
        lastFrameTime: performance.now()
      });

      // Watch for graph data changes
      watch(() => visualizationStore.graphData, (graphData: GraphData | null) => {
        if (!graphData) return;

        // Update simulation data (but don't start it unless interacting)
        const forceNodes = graphData.nodes.map((node: GraphNode): ForceNode => ({
          ...node,
          x: node.position?.[0] || 0,
          y: node.position?.[1] || 0,
          z: node.position?.[2] || 0
        }));

        const forceLinks = graphData.edges.map((edge: GraphEdge) => ({
          ...edge,
          source: edge.source,
          target: edge.target
        }));

        simulation.nodes(forceNodes);
        simulation.force<ForceLink<ForceNode>>('link')?.links(forceLinks);
      }, { deep: true });

      animate();

      window.addEventListener('resize', () => {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      console.log('Visualization system initialized');
    } catch (error) {
      console.error('Failed to initialize visualization:', error);
      throw error;
    }
  };

  // Start interaction mode (local force simulation)
  const startInteraction = () => {
    if (isInteracting.value) return;
    
    isInteracting.value = true;
    
    // Copy current positions to simulation
    const positions = binaryStore.getAllPositions;
    simulation.nodes().forEach((node: ForceNode, i: number) => {
      const posOffset = i * 3;
      node.x = positions[posOffset];
      node.y = positions[posOffset + 1];
      node.z = positions[posOffset + 2];
    });

    simulation
      .alpha(FORCE_SETTINGS.alpha)
      .restart();
  };

  // End interaction mode (return to server updates)
  const endInteraction = () => {
    if (!isInteracting.value) return;
    
    isInteracting.value = false;
    simulation.stop();
  };

  // Event handlers
  const handleNodeHover = (nodeId: string | null) => {
    hoveredNode.value = nodeId;
    if (state.value.scene) {
      state.value.scene.userData.needsRender = true;
    }
  };

  const handleNodeSelect = (nodeId: string | null) => {
    selectedNode.value = nodeId;
    if (state.value.scene) {
      state.value.scene.userData.needsRender = true;
    }
  };

  // Update nodes
  const updateNodes = (nodes: Node[]) => {
    if (!state.value.scene || isProcessingUpdate.value) return;

    isProcessingUpdate.value = true;
    try {
      const scene = state.value.scene;
      const currentIds = new Set(nodes.map(n => n.id));

      // Remove old nodes
      for (const [id, mesh] of meshCache.nodes.entries()) {
        if (!currentIds.has(id)) {
          scene.remove(mesh);
          mesh.geometry.dispose();
          (mesh.material as THREE.Material).dispose();
          meshCache.nodes.delete(id);
        }
      }

      // Add or update nodes
      nodes.forEach(node => {
        let mesh = meshCache.nodes.get(node.id);
        
        if (!mesh) {
          // Create new mesh
          mesh = createNodeMesh(node);
          scene.add(mesh);
          meshCache.nodes.set(node.id, mesh);
        } else {
          // Update existing mesh
          if (node.position) {
            mesh.position.set(
              node.position[0] / POSITION_SCALE,
              node.position[1] / POSITION_SCALE,
              node.position[2] / POSITION_SCALE
            );
          }
          if (node.size) {
            mesh.scale.setScalar(node.size * 0.02);
          }
          if (node.color) {
            (mesh.material as THREE.MeshStandardMaterial).color.set(node.color);
            (mesh.material as THREE.MeshStandardMaterial).emissive.set(node.color);
          }
        }
      });

      scene.userData.needsRender = true;
    } finally {
      isProcessingUpdate.value = false;
    }
  };

  // Update positions from binary data
  const updatePositions = (positions: Float32Array, velocities: Float32Array, nodeCount: number) => {
    if (!state.value.scene || !state.value.isInitialized || isProcessingUpdate.value || isInteracting.value) return;

    isProcessingUpdate.value = true;
    try {
      const nodes = simulation.nodes();
      for (let i = 0; i < nodeCount; i++) {
        const node = nodes[i] as ForceNode;
        if (!node) continue;

        const mesh = meshCache.nodes.get(node.id);
        if (!mesh) continue;

        const posOffset = i * 3;
        const velOffset = i * 3;

        mesh.position.set(
          positions[posOffset] / POSITION_SCALE,
          positions[posOffset + 1] / POSITION_SCALE,
          positions[posOffset + 2] / POSITION_SCALE
        );

        // Update node data
        node.x = positions[posOffset];
        node.y = positions[posOffset + 1];
        node.z = positions[posOffset + 2];
        node.vx = velocities[velOffset];
        node.vy = velocities[velOffset + 1];
        node.vz = velocities[velOffset + 2];
      }

      if (state.value.scene) {
        state.value.scene.userData.needsRender = true;
      }
    } finally {
      isProcessingUpdate.value = false;
    }
  };

  // Cleanup
  onBeforeUnmount(() => {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
    }

    if (controls) {
      controls.dispose();
    }

    simulation.stop();

    // Clean up meshes
    meshCache.nodes.forEach(mesh => {
      mesh.geometry.dispose();
      (mesh.material as THREE.Material).dispose();
    });
    meshCache.nodes.clear();

    if (state.value.renderer) {
      state.value.renderer.dispose();
      state.value.renderer.forceContextLoss();
    }
    
    state.value.canvas?.remove();
    state.value = {
      renderer: null,
      camera: null,
      scene: null,
      canvas: null,
      isInitialized: false,
      isXRSupported: false,
      isWebGL2: false,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0
    };
  });

  return {
    state,
    initialize,
    updateNodes,
    updatePositions,
    updateLayoutPositions,
    startInteraction,
    endInteraction,
    handleNodeHover,
    handleNodeSelect,
    hoveredNode: computed(() => hoveredNode.value),
    selectedNode: computed(() => selectedNode.value),
    isGPUEnabled,
    isInteracting: computed(() => isInteracting.value)
  };
}

----
composables/useControlSettings.ts
import { computed } from 'vue';
import type { 
  VisualizationConfig, 
  BloomConfig, 
  FisheyeConfig,
  ControlGroup,
  ControlItem 
} from '../types/components';
import { useControlGroups } from './useControlGroups';
import { useSettingsStore } from '../stores/settings';
import { storeToRefs } from 'pinia';

export function useControlSettings() {
  const settingsStore = useSettingsStore();
  const { 
    createControlGroup, 
    createRangeControl, 
    createColorControl, 
    createCheckboxControl 
  } = useControlGroups();

  // Create appearance controls
  const createAppearanceGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createColorControl('node_color', 'Base Node Color', config.node_color),
      createColorControl('node_color_new', 'New Nodes', config.node_color_new),
      createColorControl('node_color_recent', 'Recent Nodes', config.node_color_recent),
      createColorControl('node_color_medium', 'Medium Age', config.node_color_medium),
      createColorControl('node_color_old', 'Old Nodes', config.node_color_old),
      createColorControl('node_color_core', 'Core Nodes', config.node_color_core),
      createColorControl('node_color_secondary', 'Secondary Nodes', config.node_color_secondary),
      createRangeControl('min_node_size', 'Minimum Size', config.min_node_size, 0.05, 0.5, 0.05),
      createRangeControl('max_node_size', 'Maximum Size', config.max_node_size, 0.1, 1.0, 0.1)
    ];

    return createControlGroup('appearance', 'Node Appearance', controls);
  };

  // Create material controls
  const createMaterialGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('node_material_metalness', 'Metalness', config.material.node_material_metalness, 0, 1, 0.1),
      createRangeControl('node_material_roughness', 'Roughness', config.material.node_material_roughness, 0, 1, 0.1),
      createRangeControl('node_material_clearcoat', 'Clearcoat', config.material.node_material_clearcoat, 0, 1, 0.1),
      createRangeControl('node_material_clearcoat_roughness', 'Clearcoat Roughness', config.material.node_material_clearcoat_roughness, 0, 1, 0.1),
      createRangeControl('node_material_opacity', 'Opacity', config.material.node_material_opacity, 0, 1, 0.1),
      createRangeControl('node_emissive_min_intensity', 'Min Emissive', config.material.node_emissive_min_intensity, 0, 1, 0.1),
      createRangeControl('node_emissive_max_intensity', 'Max Emissive', config.material.node_emissive_max_intensity, 0, 2, 0.1)
    ];

    return createControlGroup('material', 'Material Properties', controls);
  };

  // Create physics controls
  const createPhysicsGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('force_directed_iterations', 'Iterations', config.physics.force_directed_iterations, 100, 500, 10),
      createRangeControl('force_directed_spring', 'Spring Strength', config.physics.force_directed_spring, 0.001, 0.1, 0.001),
      createRangeControl('force_directed_repulsion', 'Repulsion', config.physics.force_directed_repulsion, 100, 2000, 100),
      createRangeControl('force_directed_attraction', 'Attraction', config.physics.force_directed_attraction, 0.001, 0.1, 0.001),
      createRangeControl('force_directed_damping', 'Damping', config.physics.force_directed_damping, 0.1, 1.0, 0.1)
    ];

    return createControlGroup('physics', 'Physics Simulation', controls);
  };

  // Create bloom controls
  const createBloomGroup = (config: BloomConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('node_bloom_strength', 'Node Strength', config.node_bloom_strength, 0, 2, 0.1),
      createRangeControl('node_bloom_radius', 'Node Radius', config.node_bloom_radius, 0, 1, 0.1),
      createRangeControl('node_bloom_threshold', 'Node Threshold', config.node_bloom_threshold, 0, 1, 0.1),
      createRangeControl('edge_bloom_strength', 'Edge Strength', config.edge_bloom_strength, 0, 2, 0.1),
      createRangeControl('edge_bloom_radius', 'Edge Radius', config.edge_bloom_radius, 0, 1, 0.1),
      createRangeControl('edge_bloom_threshold', 'Edge Threshold', config.edge_bloom_threshold, 0, 1, 0.1),
      createRangeControl('environment_bloom_strength', 'Environment Strength', config.environment_bloom_strength, 0, 2, 0.1),
      createRangeControl('environment_bloom_radius', 'Environment Radius', config.environment_bloom_radius, 0, 1, 0.1),
      createRangeControl('environment_bloom_threshold', 'Environment Threshold', config.environment_bloom_threshold, 0, 1, 0.1)
    ];

    return createControlGroup('bloom', 'Bloom Effects', controls);
  };

  // Create environment controls
  const createEnvironmentGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createColorControl('hologram_color', 'Hologram Color', config.hologram_color),
      createRangeControl('hologram_scale', 'Hologram Scale', config.hologram_scale, 1, 10, 1),
      createRangeControl('hologram_opacity', 'Hologram Opacity', config.hologram_opacity, 0, 1, 0.05),
      createRangeControl('fog_density', 'Fog Density', config.fog_density, 0, 0.01, 0.0001)
    ];

    return createControlGroup('environment', 'Environment', controls);
  };

  // Create fisheye controls
  const createFisheyeGroup = (config: FisheyeConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createCheckboxControl('enabled', 'Enable Fisheye', config.enabled),
      createRangeControl('strength', 'Strength', config.strength, 0, 1, 0.1),
      createRangeControl('radius', 'Radius', config.radius, 10, 200, 10),
      createRangeControl('focus_x', 'Focus X', config.focus_x, -100, 100, 1),
      createRangeControl('focus_y', 'Focus Y', config.focus_y, -100, 100, 1),
      createRangeControl('focus_z', 'Focus Z', config.focus_z, -100, 100, 1)
    ];

    return createControlGroup('fisheye', 'Fisheye Effect', controls);
  };

  // Handle control changes
  const handleControlChange = (groupName: string, controlName: string, value: any) => {
    const { getVisualizationSettings } = storeToRefs(settingsStore);
    const currentSettings = getVisualizationSettings.value;

    switch (groupName) {
      case 'appearance':
      case 'environment':
        settingsStore.updateVisualizationSettings({ [controlName]: value });
        break;
      case 'material':
        settingsStore.updateVisualizationSettings({
          material: {
            ...currentSettings.material,
            [controlName]: value
          }
        });
        break;
      case 'physics':
        settingsStore.updateVisualizationSettings({
          physics: {
            ...currentSettings.physics,
            [controlName]: value
          }
        });
        break;
      case 'bloom':
        settingsStore.updateBloomSettings({ [controlName]: value });
        break;
      case 'fisheye':
        settingsStore.updateFisheyeSettings({ [controlName]: value });
        break;
    }
  };

  return {
    createAppearanceGroup,
    createMaterialGroup,
    createPhysicsGroup,
    createBloomGroup,
    createEnvironmentGroup,
    createFisheyeGroup,
    handleControlChange
  };
}

----
composables/useGraphSystem.ts
import { ref, computed, inject, onMounted, watch } from 'vue';
import { Scene, Group, Vector3 } from 'three';
import { useVisualizationStore } from '../stores/visualization';
import { useBinaryUpdateStore } from '../stores/binaryUpdate';
import { useWebSocketStore } from '../stores/websocket';
import type { GraphNode, GraphEdge } from '../types/core';
import type { VisualizationConfig } from '../types/components';
import type { CoreState } from '../types/core';
import type { BinaryMessage } from '../types/websocket';

export function useGraphSystem() {
  const visualizationStore = useVisualizationStore();
  const binaryStore = useBinaryUpdateStore();
  const webSocketStore = useWebSocketStore();
  
  // Get scene from visualization state
  const visualizationState = inject<{ value: CoreState }>('visualizationState');
  
  // Create Three.js groups
  const graphGroup = new Group();
  const nodesGroup = new Group();
  const edgesGroup = new Group();

  // Add groups to scene hierarchy
  graphGroup.add(nodesGroup);
  graphGroup.add(edgesGroup);

  // State
  const hoveredNode = ref<string | null>(null);
  const nodeCount = ref(0);
  const isProcessingUpdate = ref(false);

  // Computed states from WebSocket store
  const isGPUEnabled = computed(() => webSocketStore.isGPUEnabled);

  // Watch for GPU state changes
  watch(isGPUEnabled, (enabled) => {
    console.debug(`GPU acceleration ${enabled ? 'enabled' : 'disabled'}`);
    if (visualizationState?.value.scene) {
      visualizationState.value.scene.userData.gpuEnabled = enabled;
      visualizationState.value.scene.userData.needsRender = true;
    }
  });

  // Get node index from the visualization store's nodes array
  const getNodeIndex = (id: string): number => {
    return visualizationStore.nodes.findIndex(node => node.id === id);
  };

  // Direct access to binary data with GPU awareness
  const getNodePosition = (node: GraphNode | string): Vector3 => {
    const id = typeof node === 'object' ? node.id : node;
    const index = getNodeIndex(id);
    if (index === -1) return new Vector3();

    const position = binaryStore.getNodePosition(index);
    if (position) {
      return new Vector3(position[0], position[1], position[2]);
    }
    return new Vector3();
  };

  const getNodeVelocity = (node: GraphNode | string): Vector3 => {
    const id = typeof node === 'object' ? node.id : node;
    const index = getNodeIndex(id);
    if (index === -1) return new Vector3();

    const velocity = binaryStore.getNodeVelocity(index);
    if (velocity) {
      return new Vector3(velocity[0], velocity[1], velocity[2]);
    }
    return new Vector3();
  };

  const updateNodePosition = (
    id: string,
    position: Vector3,
    velocity: Vector3
  ) => {
    if (isProcessingUpdate.value) return; // Prevent concurrent updates
    
    const index = getNodeIndex(id);
    if (index === -1) return;

    isProcessingUpdate.value = true;
    try {
      binaryStore.updateNodePosition(
        index,
        position.x,
        position.y,
        position.z,
        velocity.x,
        velocity.y,
        velocity.z
      );

      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
        visualizationState.value.scene.userData.lastUpdate = performance.now();
      }
    } finally {
      isProcessingUpdate.value = false;
    }
  };

  const getNodeScale = (node: GraphNode): number => {
    const baseSize = node.size || 1;
    const minSize = settings.value.min_node_size;
    const maxSize = settings.value.max_node_size;
    return minSize + (baseSize * (maxSize - minSize));
  };

  const getNodeColor = (node: GraphNode): string => {
    return node.id === hoveredNode.value
      ? settings.value.node_color_core
      : (node.color || settings.value.node_color);
  };

  // Edge helpers using direct access
  const getEdgePoints = (source: GraphNode, target: GraphNode): [Vector3, Vector3] => {
    return [
      getNodePosition(source),
      getNodePosition(target)
    ];
  };

  const getEdgeColor = (edge: GraphEdge): string => {
    return edge.color || settings.value.edge_color;
  };

  const getEdgeWidth = (edge: GraphEdge): number => {
    const baseWidth = edge.weight || 1;
    const minWidth = settings.value.edge_min_width;
    const maxWidth = settings.value.edge_max_width;
    return minWidth + (baseWidth * (maxWidth - minWidth));
  };

  // Event handlers with GPU awareness
  const handleNodeClick = (node: GraphNode) => {
    const position = getNodePosition(node);
    console.debug('Node clicked:', { 
      id: node.id, 
      position,
      gpuEnabled: isGPUEnabled.value
    });
  };

  const handleNodeHover = (node: GraphNode | null) => {
    hoveredNode.value = node?.id || null;
    if (visualizationState?.value.scene) {
      visualizationState.value.scene.userData.needsRender = true;
      visualizationState.value.scene.userData.lastUpdate = performance.now();
    }
  };

  // Graph data management with GPU awareness
  const updateGraphData = (graphData: { nodes: GraphNode[]; edges: GraphEdge[] }) => {
    if (isProcessingUpdate.value) return; // Prevent concurrent updates
    
    isProcessingUpdate.value = true;
    try {
      nodeCount.value = graphData.nodes.length;
      
      // Create binary data for positions and velocities
      const dataSize = nodeCount.value * 6; // (x,y,z,vx,vy,vz) per node
      const binaryData = new ArrayBuffer(dataSize * 4); // 4 bytes per float
      const dataView = new Float32Array(binaryData);
      
      // Fill position and velocity data
      graphData.nodes.forEach((node, index) => {
        const offset = index * 6;
        // Set positions
        dataView[offset] = node.position?.[0] || 0;
        dataView[offset + 1] = node.position?.[1] || 0;
        dataView[offset + 2] = node.position?.[2] || 0;
        
        // Set velocities
        dataView[offset + 3] = node.velocity?.[0] || 0;
        dataView[offset + 4] = node.velocity?.[1] || 0;
        dataView[offset + 5] = node.velocity?.[2] || 0;
      });

      // Create binary message with required type information
      const binaryMessage: BinaryMessage = {
        type: 'binaryPositionUpdate',
        data: binaryData,
        positions: graphData.nodes.map((node, index) => {
          const offset = index * 6;
          return {
            x: dataView[offset],
            y: dataView[offset + 1],
            z: dataView[offset + 2],
            vx: dataView[offset + 3],
            vy: dataView[offset + 4],
            vz: dataView[offset + 5]
          };
        }),
        nodeCount: nodeCount.value,
        isInitialLayout: true // Initial layout since this is a full graph update
      };

      // Update binary store
      binaryStore.updateFromBinary(binaryMessage);

      // Mark scene for update
      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
        visualizationState.value.scene.userData.lastUpdate = performance.now();
        visualizationState.value.scene.userData.gpuEnabled = isGPUEnabled.value;
      }
    } finally {
      isProcessingUpdate.value = false;
    }
  };

  // Get settings from store
  const settings = computed<VisualizationConfig>(() => {
    return visualizationStore.getVisualizationSettings;
  });

  // Initialize scene when available
  onMounted(() => {
    if (visualizationState?.value.scene) {
      visualizationState.value.scene.add(graphGroup);
      visualizationState.value.scene.userData.graphGroup = graphGroup;
      visualizationState.value.scene.userData.nodesGroup = nodesGroup;
      visualizationState.value.scene.userData.edgesGroup = edgesGroup;
      visualizationState.value.scene.userData.gpuEnabled = isGPUEnabled.value;
    }
  });

  return {
    // Groups
    graphGroup,
    nodesGroup,
    edgesGroup,
    
    // State
    hoveredNode,
    nodeCount,
    isGPUEnabled,
    
    // Node helpers
    getNodePosition,
    getNodeVelocity,
    updateNodePosition,
    getNodeScale,
    getNodeColor,
    
    // Edge helpers
    getEdgePoints,
    getEdgeColor,
    getEdgeWidth,
    
    // Event handlers
    handleNodeClick,
    handleNodeHover,
    
    // Data management
    updateGraphData
  };
}

----
composables/useThreeScene.ts
import { ref, onBeforeUnmount } from 'vue';
import THREE, { OrbitControls } from '../utils/three';
import type { Scene, PerspectiveCamera, WebGLRenderer, Object3D, Material, Texture } from 'three';

interface ThreeResources {
  scene: Scene;
  camera: PerspectiveCamera;
  renderer: WebGLRenderer;
  controls?: OrbitControls;
  environment?: {
    ground: THREE.Mesh;
    gridHelper: THREE.GridHelper;
    dispose: () => void;
  };
}

interface MaterialWithMap extends Material {
  map?: Texture | null;
}

export function useThreeScene() {
  const resources = ref<ThreeResources | null>(null);

  const handleContextLost = (event: Event) => {
    event.preventDefault();
    console.warn('WebGL context lost. Attempting to restore...');
  };

  const handleContextRestored = () => {
    console.log('WebGL context restored');
    window.dispatchEvent(new Event('webglcontextrestored'));
  };

  const setupLighting = (scene: Scene) => {
    // Main directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    
    // Optimize shadow map settings
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.bias = -0.0001;
    
    scene.add(directionalLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    // Ambient light for overall scene brightness
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
  };

  const initScene = async () => {
    try {
      // Create scene
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      // Create camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 3);

      // Create renderer
      const canvas = document.createElement('canvas');
      const contextAttributes = {
        alpha: true,
        antialias: true,
        powerPreference: "high-performance" as WebGLPowerPreference,
        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false
      };

      // Try WebGL2 first
      let gl = canvas.getContext('webgl2', contextAttributes);
      let isWebGL2 = !!gl;

      if (!gl) {
        console.warn('WebGL2 not available, falling back to WebGL1');
        gl = canvas.getContext('webgl', contextAttributes) ||
             canvas.getContext('experimental-webgl', contextAttributes);
        isWebGL2 = false;
      }

      if (!gl) {
        throw new Error('WebGL not supported');
      }

      const renderer = new THREE.WebGLRenderer({
        canvas,
        context: gl as WebGLRenderingContext | WebGL2RenderingContext,
        antialias: true,
        alpha: true,
        powerPreference: "high-performance",
        preserveDrawingBuffer: false
      });

      // Configure renderer based on WebGL version
      if (isWebGL2) {
        console.log('Using WebGL2 renderer');
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      } else {
        console.log('Using WebGL1 renderer');
        renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
        renderer.shadowMap.type = THREE.PCFShadowMap;
      }

      // Common renderer settings
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;

      // Store WebGL version
      (renderer as any).capabilities.isWebGL2 = isWebGL2;

      // Add context loss handling
      renderer.domElement.addEventListener('webglcontextlost', handleContextLost, false);
      renderer.domElement.addEventListener('webglcontextrestored', handleContextRestored, false);

      // Set up lighting
      setupLighting(scene);

      // Append renderer to DOM
      const container = document.getElementById('scene-container');
      if (container) {
        container.appendChild(renderer.domElement);
      } else {
        document.body.appendChild(renderer.domElement);
      }

      // Create orbit controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI * 0.95;
      controls.minDistance = 1;
      controls.maxDistance = 50;
      controls.enablePan = true;
      controls.panSpeed = 0.5;
      controls.rotateSpeed = 0.5;
      controls.zoomSpeed = 0.5;

      // Disable controls in XR
      renderer.xr.addEventListener('sessionstart', () => {
        controls.enabled = false;
      });
      
      renderer.xr.addEventListener('sessionend', () => {
        controls.enabled = true;
      });

      // Create basic environment
      const environment = createBasicEnvironment(scene);

      // Store resources
      resources.value = {
        scene,
        camera,
        renderer,
        controls,
        environment
      };

      // Handle window resize
      window.addEventListener('resize', handleResize);

      return resources.value;

    } catch (error) {
      console.error('Error initializing Three.js scene:', error);
      throw error;
    }
  };

  const createBasicEnvironment = (scene: Scene) => {
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      roughness: 0.8,
      metalness: 0.2,
      transparent: true,
      opacity: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 100);
    (gridHelper.material as THREE.Material).transparent = true;
    (gridHelper.material as THREE.Material).opacity = 0.2;
    scene.add(gridHelper);

    return {
      ground,
      gridHelper,
      dispose: () => {
        groundGeometry.dispose();
        groundMaterial.dispose();
        if (gridHelper.material) {
          (gridHelper.material as THREE.Material).dispose();
        }
        if (gridHelper.geometry) {
          gridHelper.geometry.dispose();
        }
        scene.remove(ground);
        scene.remove(gridHelper);
      }
    };
  };

  const handleResize = () => {
    if (!resources.value) return;

    const { camera, renderer } = resources.value;
    if (!renderer.xr.isPresenting) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  };

  const dispose = () => {
    if (!resources.value) return;

    const { scene, renderer, controls, environment } = resources.value;

    // Dispose of scene objects
    scene.traverse((object: Object3D) => {
      if ((object as THREE.Mesh).geometry) {
        (object as THREE.Mesh).geometry.dispose();
      }
      
      if ((object as THREE.Mesh).material) {
        const material = (object as THREE.Mesh).material;
        if (Array.isArray(material)) {
          material.forEach(mat => {
            const matWithMap = mat as MaterialWithMap;
            if (matWithMap.map) matWithMap.map.dispose();
            mat.dispose();
          });
        } else {
          const matWithMap = material as MaterialWithMap;
          if (matWithMap.map) matWithMap.map.dispose();
          material.dispose();
        }
      }
    });

    // Dispose of environment
    if (environment) {
      environment.dispose();
    }

    // Dispose of renderer
    renderer.dispose();
    renderer.forceContextLoss();
    renderer.domElement.remove();

    // Remove context loss listeners
    renderer.domElement.removeEventListener('webglcontextlost', handleContextLost);
    renderer.domElement.removeEventListener('webglcontextrestored', handleContextRestored);

    // Dispose of controls
    if (controls) {
      controls.dispose();
    }

    // Remove resize listener
    window.removeEventListener('resize', handleResize);

    resources.value = null;
  };

  onBeforeUnmount(() => {
    dispose();
  });

  return {
    resources,
    initScene,
    dispose
  };
}

----
composables/usePlatform.ts
import { ref, onMounted, onBeforeUnmount } from 'vue';
import { platformManager, type PlatformState } from '../platform/platformManager';
import type { SceneConfig } from '../types/core';
import type { BrowserState, BrowserInitOptions } from '../types/platform/browser';
import type { QuestState, QuestInitOptions, XRHandedness, XRHand } from '../types/platform/quest';
import type { Camera, Group, WebGLRenderer, Scene } from 'three';

// Convert core initialization options to platform-specific options
const convertToPlatformOptions = (options: {
  canvas: HTMLCanvasElement;
  scene?: Partial<SceneConfig>;
}): BrowserInitOptions | QuestInitOptions => {
  const baseOptions = {
    canvas: options.canvas,
    scene: options.scene ? {
      antialias: options.scene.antialias ?? true,
      alpha: options.scene.alpha ?? true,
      preserveDrawingBuffer: options.scene.preserveDrawingBuffer ?? true,
      powerPreference: options.scene.powerPreference ?? 'high-performance'
    } : undefined
  };

  if (platformManager.isQuest()) {
    return {
      ...baseOptions,
      xr: {
        referenceSpaceType: 'local-floor',
        sessionMode: 'immersive-vr',
        optionalFeatures: ['hand-tracking'],
        requiredFeatures: ['local-floor']
      }
    } as QuestInitOptions;
  }

  return baseOptions as BrowserInitOptions;
};

export function usePlatform() {
  const isInitialized = ref(false);
  const isLoading = ref(false);
  const error = ref<Error | null>(null);

  const initialize = async (options: { canvas: HTMLCanvasElement; scene?: Partial<SceneConfig> }) => {
    isLoading.value = true;
    error.value = null;

    try {
      const platformOptions = convertToPlatformOptions(options);
      await platformManager.initialize(platformOptions);
      isInitialized.value = true;
    } catch (err) {
      error.value = err instanceof Error ? err : new Error('Failed to initialize platform');
      console.error('Platform initialization failed:', err);
    } finally {
      isLoading.value = false;
    }
  };

  // Alias for backward compatibility
  const initializePlatform = initialize;

  const getState = <T extends PlatformState>(): T | null => {
    return platformManager.getState() as T | null;
  };

  const getBrowserState = (): BrowserState | null => {
    if (!platformManager.isBrowser()) return null;
    return getState<BrowserState>();
  };

  const getQuestState = (): QuestState | null => {
    if (!platformManager.isQuest()) return null;
    return getState<QuestState>();
  };

  const getPlatformInfo = () => {
    return {
      platform: platformManager.getPlatform(),
      capabilities: platformManager.getCapabilities(),
      isQuest: platformManager.isQuest(),
      isBrowser: platformManager.isBrowser(),
      hasXRSupport: platformManager.hasXRSupport()
    };
  };

  // XR Session Management
  const enableVR = async () => {
    if (!platformManager.hasXRSupport()) {
      throw new Error('WebXR not supported');
    }
    return platformManager.startXRSession('immersive-vr');
  };

  const enableAR = async () => {
    if (!platformManager.hasXRSupport()) {
      throw new Error('WebXR not supported');
    }
    const capabilities = platformManager.getCapabilities();
    if (!capabilities?.ar) {
      throw new Error('AR not supported on this device');
    }
    return platformManager.startXRSession('immersive-ar');
  };

  const disableXR = async () => {
    return platformManager.endXRSession();
  };

  const isXRActive = () => platformManager.isInXRSession();
  const isVRActive = () => platformManager.getXRSessionMode() === 'immersive-vr';
  const isARActive = () => platformManager.getXRSessionMode() === 'immersive-ar';

  // Controller and Hand Access
  const getControllerGrip = (handedness: XRHandedness): Group | null => {
    const state = getQuestState();
    return state?.controllers.get(handedness)?.grip ?? null;
  };

  const getControllerRay = (handedness: XRHandedness): Group | null => {
    const state = getQuestState();
    return state?.controllers.get(handedness)?.ray ?? null;
  };

  const getHand = (handedness: XRHandedness): XRHand | null => {
    const state = getQuestState();
    return state?.hands.get(handedness) ?? null;
  };

  // Haptic Feedback
  const vibrate = (handedness: XRHandedness, intensity = 1.0, duration = 100) => {
    const state = getQuestState();
    const controller = state?.controllers.get(handedness);
    if (controller?.gamepad?.hapticActuators?.[0]) {
      controller.gamepad.hapticActuators[0].pulse(intensity, duration);
    }
  };

  // Render and Resize Callbacks
  const onResize = (callback: (width: number, height: number) => void) => {
    return platformManager.onResize(callback);
  };

  const onBeforeRender = (callback: (renderer: WebGLRenderer, scene: Scene, camera: Camera) => void) => {
    return platformManager.onBeforeRender(callback);
  };

  // Lifecycle
  onMounted(() => {
    // Platform manager handles resize internally
  });

  onBeforeUnmount(() => {
    if (isInitialized.value) {
      platformManager.dispose();
    }
  });

  return {
    // State
    isInitialized,
    isLoading,
    error,

    // Core Methods
    initialize,
    initializePlatform,
    getState,
    getBrowserState,
    getQuestState,
    getPlatformInfo,

    // Platform Checks
    isQuest: platformManager.isQuest,
    isBrowser: platformManager.isBrowser,
    hasXRSupport: platformManager.hasXRSupport,

    // XR Methods
    enableVR,
    enableAR,
    disableXR,
    isXRActive,
    isVRActive,
    isARActive,

    // Controller Methods
    getControllerGrip,
    getControllerRay,
    getHand,
    vibrate,

    // Event Callbacks
    onResize,
    onBeforeRender
  };
}

----
types/three-ext.d.ts
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { Pass } from 'three/examples/jsm/postprocessing/Pass';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Extend existing types
declare module 'three' {
  interface ColorManagement {
    enabled: boolean;
    legacyMode?: boolean;
  }

  interface WebGLRendererParameters {
    antialias?: boolean;
    alpha?: boolean;
    depth?: boolean;
    stencil?: boolean;
    premultipliedAlpha?: boolean;
    preserveDrawingBuffer?: boolean;
    powerPreference?: string;
    failIfMajorPerformanceCaveat?: boolean;
    canvas?: HTMLCanvasElement;
    context?: WebGLRenderingContext | WebGL2RenderingContext;
    xr?: {
      enabled: boolean;
    };
  }

  interface WebGLRenderer {
    capabilities: {
      isWebGL2: boolean;
      maxTextures: number;
      maxVertexTextures: number;
      maxTextureSize: number;
      maxCubemapSize: number;
      maxAttributes: number;
      maxVertexUniforms: number;
      maxVaryings: number;
      maxFragmentUniforms: number;
      vertexTextures: boolean;
      floatFragmentTextures: boolean;
      floatVertexTextures: boolean;
    };
  }
}

// Extend OrbitControls type
declare module 'three/examples/jsm/controls/OrbitControls' {
  export interface OrbitControls {
    enabled: boolean;
    enableDamping: boolean;
    dampingFactor: number;
    enableZoom: boolean;
    enableRotate: boolean;
    enablePan: boolean;
    autoRotate: boolean;
    autoRotateSpeed: number;
    minDistance: number;
    maxDistance: number;
    minPolarAngle: number;
    maxPolarAngle: number;
    target: THREE.Vector3;
    update(): void;
    dispose(): void;
  }
}

// Custom type helpers
export type SafeWebGLRenderer = Omit<THREE.WebGLRenderer, 'readRenderTargetPixelsAsync' | 'initRenderTarget' | 'outputEncoding' | 'useLegacyLights'>;

export type SafePass = Omit<Pass, 'render'> & {
  render(
    renderer: SafeWebGLRenderer,
    writeBuffer: THREE.WebGLRenderTarget | null,
    readBuffer: THREE.WebGLRenderTarget,
    deltaTime?: number,
    maskActive?: boolean
  ): void;
};

export type SafeEffectComposer = Omit<EffectComposer, 'addPass'> & {
  addPass(pass: SafePass): void;
};

// Type assertion functions
export function asSafeRenderer(renderer: THREE.WebGLRenderer): SafeWebGLRenderer {
  return renderer as unknown as SafeWebGLRenderer;
}

export function asSafePass(pass: Pass): SafePass {
  return pass as unknown as SafePass;
}

export function asSafeEffectComposer(composer: EffectComposer): SafeEffectComposer {
  return composer as unknown as SafeEffectComposer;
}

// Camera type compatibility helper
export function asCompatibleCamera(camera: THREE.Camera): THREE.Camera {
  return camera as THREE.Camera & { matrixWorldInverse: THREE.Matrix4 };
}

----
types/global.d.ts
declare global {
  interface Window {
    __VUE_PROD_DEVTOOLS__?: boolean;
    __VUE_PROD_ERROR_HANDLER__?: (err: Error, vm: any, info: string) => void;
  }
}

export {};

----
types/vue-threejs.d.ts
declare module 'vue-threejs' {
  import { Plugin, Component } from 'vue'
  import { Scene, PerspectiveCamera, WebGLRenderer, Vector3, Color } from 'three'

  interface RendererProps {
    antialias?: boolean;
    xr?: boolean;
    size: {
      w: number;
      h: number;
    };
  }

  interface SceneProps {
    ref?: string;
  }

  interface GroupProps {
    ref?: string;
    position?: { x: number; y: number; z: number };
    rotation?: { x: number; y: number; z: number };
    scale?: { x: number; y: number; z: number };
  }

  interface CameraProps {
    position?: {
      x: number;
      y: number;
      z: number;
    };
    fov?: number;
    aspect?: number;
    near?: number;
    far?: number;
  }

  interface LightProps {
    intensity?: number;
    position?: {
      x: number;
      y: number;
      z: number;
    };
    color?: number | string;
    castShadow?: boolean;
  }

  interface HemisphereLightProps extends LightProps {
    skyColor?: number | string;
    groundColor?: number | string;
  }

  interface MeshProps {
    position?: { x: number; y: number; z: number };
    rotation?: { x: number; y: number; z: number };
    scale?: { x: number; y: number; z: number } | number;
  }

  interface GeometryProps {
    args?: any[];
  }

  interface MaterialProps {
    color?: number | string;
    metalness?: number;
    roughness?: number;
    opacity?: number;
    transparent?: boolean;
  }

  interface LineProps {
    points: Vector3[];
    color?: number | string;
    linewidth?: number;
    opacity?: number;
    transparent?: boolean;
  }

  interface HtmlProps {
    position: Vector3;
    occlude?: boolean;
    center?: boolean;
    sprite?: boolean;
  }

  export const Renderer: Component<RendererProps>
  export const Scene: Component<SceneProps>
  export const Group: Component<GroupProps>
  export const Camera: Component<CameraProps>
  export const AmbientLight: Component<LightProps>
  export const DirectionalLight: Component<LightProps>
  export const HemisphereLight: Component<HemisphereLightProps>
  export const Mesh: Component<MeshProps>
  export const SphereGeometry: Component<GeometryProps>
  export const MeshStandardMaterial: Component<MaterialProps>
  export const Line: Component<LineProps>
  export const Html: Component<HtmlProps>

  const VueThreejs: Plugin
  export default VueThreejs
}

----
types/stores.ts
import type { Node, Edge } from './core';
import type { 
  BaseMessage, 
  MaterialSettings, 
  PhysicsSettings, 
  BloomSettings, 
  FisheyeSettings 
} from './websocket';

// Re-export Node and Edge types
export type { Node, Edge };

// Binary message format types (no state storage needed)
export type BinaryMessageHeader = {
  isInitialLayout: boolean;
  timeStep: number;
  nodeCount: number;
};

export type BinaryPositionUpdate = {
  nodeId: string;
  position: [number, number, number];
};

// WebSocket Store State
export interface WebSocketState {
  isConnected: boolean;
  reconnectAttempts: number;
  messageQueue: (BaseMessage | ArrayBuffer)[];
  lastError: string | null;
  graphData: {
    nodes: Node[];
    edges: Edge[];
    metadata: Record<string, any>;
  } | null;
}

// Visualization Store State
export interface VisualizationState {
  nodes: Node[];
  edges: Edge[];
  metadata: Record<string, any>;
  selectedNode: Node | null;
  hoveredNode: Node | null;
  cameraPosition: [number, number, number];
  cameraTarget: [number, number, number];
  isLoading: boolean;
  error: string | null;
  renderSettings: {
    nodeSize: number;
    nodeColor: string;
    edgeWidth: number;
    edgeColor: string;
    highlightColor: string;
    opacity: number;
    bloom: {
      enabled: boolean;
      strength: number;
      radius: number;
      threshold: number;
    };
    fisheye: {
      enabled: boolean;
      strength: number;
      focusPoint: [number, number, number];
      radius: number;
    };
  };
  physicsSettings: {
    enabled: boolean;
    gravity: number;
    springLength: number;
    springStrength: number;
    repulsion: number;
    damping: number;
    timeStep: number;
  };
}

// Settings Store State
export interface SettingsState {
  visualization: MaterialSettings;
  physics: PhysicsSettings;
  bloom: BloomSettings;
  fisheye: FisheyeSettings;
  audio: {
    enabled: boolean;
    volume: number;
    useOpenAI: boolean;
    ttsEnabled: boolean;
  };
  performance: {
    gpuAcceleration: boolean;
    maxFPS: number;
    quality: 'low' | 'medium' | 'high';
    autoAdjust: boolean;
  };
  debug: {
    showStats: boolean;
    logLevel: 'error' | 'warn' | 'info' | 'debug';
    showGrid: boolean;
    showAxes: boolean;
  };
}

// Store Actions
export interface WebSocketActions {
  connect(): Promise<void>;
  disconnect(): void;
  send(message: BaseMessage | ArrayBuffer): void;
  handleMessage(message: BaseMessage): void;
  handleBinaryMessage(data: ArrayBuffer): void;
}

export interface VisualizationActions {
  updateNodePositions(updates: Array<[string, [number, number, number]]>): void;
  setGraphData(nodes: Node[], edges: Edge[], metadata: Record<string, any>): void;
  selectNode(node: Node | null): void;
  hoverNode(node: Node | null): void;
  updateCamera(position: [number, number, number], target: [number, number, number]): void;
  updateRenderSettings(settings: Partial<VisualizationState['renderSettings']>): void;
  updatePhysicsSettings(settings: Partial<VisualizationState['physicsSettings']>): void;
  startAnimation(): void;
  stopAnimation(): void;
  updatePerformanceMetrics(): void;
}

export interface SettingsActions {
  updateVisualization(settings: Partial<MaterialSettings>): void;
  updatePhysics(settings: Partial<PhysicsSettings>): void;
  updateBloom(settings: Partial<BloomSettings>): void;
  updateFisheye(settings: Partial<FisheyeSettings>): void;
  updateAudio(settings: Partial<SettingsState['audio']>): void;
  updatePerformance(settings: Partial<SettingsState['performance']>): void;
  updateDebug(settings: Partial<SettingsState['debug']>): void;
  resetToDefaults(): void;
  applyServerSettings(settings: {
    visualization?: Partial<MaterialSettings>;
    physics?: Partial<PhysicsSettings>;
    bloom?: Partial<BloomSettings>;
    fisheye?: Partial<FisheyeSettings>;
  }): void;
}

// Store Getters
export interface WebSocketGetters {
  isConnected: boolean;
  hasError: boolean;
  queueLength: number;
  graphData: WebSocketState['graphData'];
}

export interface VisualizationGetters {
  selectedNode: Node | null;
  hoveredNode: Node | null;
  nodeCount: number;
  edgeCount: number;
  fps: number;
  isPerformant: boolean;
}

export interface SettingsGetters {
  isGPUAccelerated: boolean;
  currentQuality: SettingsState['performance']['quality'];
  debugEnabled: boolean;
  audioEnabled: boolean;
}

----
types/core.ts
import type { WebGLRenderer, Scene, PerspectiveCamera, Object3D, Vector3 } from 'three';

/**
 * Core visualization state interface
 */
export interface CoreState {
  renderer: WebGLRenderer | null;
  camera: PerspectiveCamera | null;
  scene: Scene | null;
  canvas: HTMLCanvasElement | null;
  isInitialized: boolean;
  isXRSupported: boolean;
  isWebGL2: boolean;
  isGPUMode: boolean;
  fps: number;
  lastFrameTime: number;
}

/**
 * Platform-specific core states
 */
export interface BrowserCoreState extends CoreState {
  type: 'browser';
}

export interface XRCoreState extends CoreState {
  type: 'xr';
  xrSession: any; // XRSession type from WebXR
}

/**
 * Transform interface for object positioning
 */
export interface Transform {
  position: [number, number, number];
  rotation: [number, number, number];
  scale: [number, number, number];
}

/**
 * Viewport configuration
 */
export interface Viewport {
  width: number;
  height: number;
  pixelRatio: number;
}

/**
 * Scene configuration
 */
export interface SceneConfig {
  antialias: boolean;
  alpha: boolean;
  preserveDrawingBuffer: boolean;
  powerPreference: 'high-performance' | 'low-power' | 'default';
}

/**
 * Performance configuration
 */
export interface PerformanceConfig {
  targetFPS: number;
  maxDrawCalls: number;
  enableStats: boolean;
}

/**
 * Platform capabilities
 */
export interface PlatformCapabilities {
  webgl2: boolean;
  xr: boolean;
  ar: boolean;  // Added AR support flag
  vr: boolean;  // Added VR support flag
  maxTextureSize: number;
  maxDrawCalls: number;
  gpuTier: number;
}

/**
 * Node interfaces
 */
export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  velocity?: [number, number, number];
  size?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  weight?: number;  // Added to match Rust struct
  group?: string;   // Added to match Rust struct
}

export interface GraphNode extends Node {
  edges: GraphEdge[];  // Changed from Edge[] to GraphEdge[]
  weight: number;      // Required in GraphNode
  group?: string;
}

/**
 * Edge interfaces
 */
export interface Edge {
  id: string;
  source: string;
  target: string;
  weight?: number;
  width?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  directed?: boolean;  // Added to match Rust struct
}

export interface GraphEdge extends Edge {
  sourceNode: GraphNode;
  targetNode: GraphNode;
  directed: boolean;   // Required in GraphEdge
}

/**
 * Graph data structure
 */
export interface GraphData {
  nodes: GraphNode[];
  edges: GraphEdge[];
  metadata: Record<string, any>;
}

/**
 * Fisheye effect settings
 */
export interface FisheyeSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  focus_x: number;
  focus_y: number;
  focus_z: number;

}

/**
 * Material settings
 */
export interface MaterialSettings {
  nodeSize: number;
  nodeColor: string;
  edgeWidth: number;
  edgeColor: string;
  highlightColor: string;
  opacity: number;
  metalness: number;
  roughness: number;
}

/**
 * Physics simulation settings
 */
export interface PhysicsSettings {
  enabled: boolean;
  gravity: number;
  springLength: number;
  springStrength: number;
  repulsion: number;
  damping: number;
  timeStep: number;
}

/**
 * Bloom effect settings
 */
export interface BloomSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
}

/**
 * Complete visualization settings
 */
export interface VisualizationSettings {
  material: MaterialSettings;
  physics: PhysicsSettings;
  bloom: BloomSettings;
  fisheye: FisheyeSettings;
}

/**
 * Performance metrics
 */
export interface PerformanceMetrics {
  fps: number;
  drawCalls: number;
  triangles: number;
  points: number;
}

/**
 * Camera state
 */
export interface CameraState {
  position: [number, number, number];
  target: [number, number, number];
  zoom: number;
}

/**
 * Renderer capabilities
 */
export interface RendererCapabilities {
  isWebGL2: boolean;
  maxTextures: number;
  maxAttributes: number;
  maxVertices: number;
  precision: string;
}

/**
 * Initialization options
 */
export interface InitializationOptions {
  canvas: HTMLCanvasElement;
  scene?: Partial<SceneConfig>;
  performance?: Partial<PerformanceConfig>;
}

/**
 * Object3D with additional properties
 */
export interface EnhancedObject3D extends Object3D {
  userData: {
    id?: string;
    type?: string;
    originalPosition?: Vector3;
    velocity?: Vector3;
    [key: string]: any;
  };
}

// Rest of the file remains the same...

----
types/components.ts
// Control Panel Types
export interface ControlGroup {
  label: string;
  name: string;
  controls: ControlItem[];
  collapsed: boolean;
}

export interface ControlItem {
  name: string;
  label: string;
  value: number | string | boolean;
  type: 'range' | 'color' | 'checkbox' | 'select';
  min?: number;
  max?: number;
  step?: number;
  options?: string[];
}

// Visualization Config Types
export interface VisualizationConfig {
  // Node appearance
  node_color: string;
  node_color_new: string;
  node_color_recent: string;
  node_color_medium: string;
  node_color_old: string;
  node_color_core: string;
  node_color_secondary: string;
  min_node_size: number;
  max_node_size: number;

  // Edge appearance
  edge_color: string;
  edge_opacity: number;
  edge_min_width: number;
  edge_max_width: number;

  // Material properties
  material: {
    node_material_metalness: number;
    node_material_roughness: number;
    node_material_clearcoat: number;
    node_material_clearcoat_roughness: number;
    node_material_opacity: number;
    node_emissive_min_intensity: number;
    node_emissive_max_intensity: number;
  };

  // Physics simulation
  physics: {
    force_directed_iterations: number;
    force_directed_spring: number;
    force_directed_repulsion: number;
    force_directed_attraction: number;
    force_directed_damping: number;
  };

  // Label settings
  label_font_size: number;
  label_font_family: string;
  label_padding: number;
  label_vertical_offset: number;
  label_close_offset: number;
  label_background_color: string;
  label_text_color: string;
  label_info_text_color: string;
  label_xr_font_size: number;

  // Environment settings
  fog_density: number;
  hologram_color: string;
  hologram_scale: number;
  hologram_opacity: number;
}

// Effect Settings
export interface BloomConfig {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
  node_bloom_strength: number;
  node_bloom_radius: number;
  node_bloom_threshold: number;
  edge_bloom_strength: number;
  edge_bloom_radius: number;
  edge_bloom_threshold: number;
  environment_bloom_strength: number;
  environment_bloom_radius: number;
  environment_bloom_threshold: number;
}

export interface FisheyeConfig {
  enabled: boolean;
  strength: number;
  radius: number;
  focus_x: number;
  focus_y: number;
  focus_z: number;
}

export interface ControlPanelProps {
  visualizationConfig: VisualizationConfig;
  bloomConfig: BloomConfig;
  fisheyeConfig: FisheyeConfig;
}

export interface ControlPanelEmits {
  (event: 'update:visualizationConfig', value: Partial<VisualizationConfig>): void;
  (event: 'update:bloomConfig', value: Partial<BloomConfig>): void;
  (event: 'update:fisheyeConfig', value: Partial<FisheyeConfig>): void;
  (event: 'saveSettings'): void;
}

// Default Values
export const DEFAULT_VISUALIZATION_CONFIG: VisualizationConfig = {
  // Node appearance
  node_color: '#FFA500',
  node_color_new: '#FFD700',
  node_color_recent: '#FFA500',
  node_color_medium: '#DAA520',
  node_color_old: '#CD853F',
  node_color_core: '#FFB90F',
  node_color_secondary: '#FFC125',
  min_node_size: 0.15,
  max_node_size: 0.4,

  // Edge appearance
  edge_color: '#FFD700',
  edge_opacity: 0.4,
  edge_min_width: 1.5,
  edge_max_width: 6.0,

  // Material properties
  material: {
    node_material_metalness: 0.7,
    node_material_roughness: 0.2,
    node_material_clearcoat: 0.8,
    node_material_clearcoat_roughness: 0.1,
    node_material_opacity: 0.95,
    node_emissive_min_intensity: 0.4,
    node_emissive_max_intensity: 1.0
  },

  // Physics simulation
  physics: {
    force_directed_iterations: 300,
    force_directed_spring: 0.015,
    force_directed_repulsion: 1200.0,
    force_directed_attraction: 0.012,
    force_directed_damping: 0.85
  },

  // Label settings
  label_font_size: 42,
  label_font_family: 'Arial',
  label_padding: 24,
  label_vertical_offset: 2.5,
  label_close_offset: 0.25,
  label_background_color: 'rgba(0, 0, 0, 0.85)',
  label_text_color: 'white',
  label_info_text_color: 'lightgray',
  label_xr_font_size: 28,

  // Environment settings
  fog_density: 0.001,
  hologram_color: '#FFC125',
  hologram_scale: 6.0,
  hologram_opacity: 0.15
};

export const DEFAULT_BLOOM_CONFIG: BloomConfig = {
  enabled: true,
  strength: 1.5,
  radius: 0.4,
  threshold: 0.2,
  node_bloom_strength: 1.5,
  node_bloom_radius: 0.4,
  node_bloom_threshold: 0.2,
  edge_bloom_strength: 1.2,
  edge_bloom_radius: 0.4,
  edge_bloom_threshold: 0.2,
  environment_bloom_strength: 1.0,
  environment_bloom_radius: 0.4,
  environment_bloom_threshold: 0.2
};

export const DEFAULT_FISHEYE_CONFIG: FisheyeConfig = {
  enabled: false,
  strength: 0.5,
  radius: 100.0,
  focus_x: 0.0,
  focus_y: 0.0,
  focus_z: 0.0
};

----
types/visualization.ts
import type { Scene, PerspectiveCamera, WebGLRenderer, Vector3, Quaternion } from 'three';
import type { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import type { VisualizationConfig, BloomConfig, FisheyeConfig } from './components';

export interface GraphData {
  nodes: Node[];
  edges: Edge[];
  metadata?: Record<string, any>;
}

export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  color?: string;
  size?: number;
  type?: string;
  [key: string]: any;
}

export interface Edge {
  source: string;
  target: string;
  weight?: number;
  color?: string;
  width?: number;
  [key: string]: any;
}

export interface XRSessionManager {
  session: XRSession | null;
  referenceSpace: XRReferenceSpace | null;
  init(): Promise<void>;
  update(): void;
  dispose(): void;
}

export interface NodeManagerOptions {
  minNodeSize: number;
  maxNodeSize: number;
  nodeColor: string;
  edgeColor: string;
  edgeOpacity: number;
  labelFontSize: number;
  labelFontFamily: string;
  materialMetalness: number;
  materialRoughness: number;
  materialClearcoat: number;
  materialOpacity: number;
}

export interface VisualizationSettings {
  visualization: VisualizationConfig;
  bloom: BloomConfig;
  fisheye: FisheyeConfig;
}

export interface WebXRVisualizationState {
  initialized: boolean;
  pendingInitialization: boolean;
  scene: Scene | null;
  camera: PerspectiveCamera | null;
  renderer: WebGLRenderer | null;
  controls: OrbitControls | null;
  xrSessionManager: XRSessionManager | null;
  canvas: HTMLCanvasElement | null;
}

export interface CameraState {
  position: Vector3;
  rotation: Quaternion;
  target: Vector3;
}

export interface RenderState {
  fps: number;
  lastFrameTime: number;
  frameCount: number;
}

// Constants
export const VISUALIZATION_CONSTANTS = {
  TRANSLATION_SPEED: 0.01,
  ROTATION_SPEED: 0.01,
  VR_MOVEMENT_SPEED: 0.05,
  MIN_CAMERA_DISTANCE: 50,
  MAX_CAMERA_DISTANCE: 500,
  DEFAULT_FOV: 50,
  NEAR_PLANE: 0.1,
  FAR_PLANE: 2000,
  DEFAULT_CAMERA_POSITION: [0, 75, 200] as [number, number, number],
  DEFAULT_CAMERA_TARGET: [0, 0, 0] as [number, number, number]
} as const;

// WebGL Context Attributes
export const WEBGL_CONTEXT_ATTRIBUTES: WebGLContextAttributes = {
  alpha: false,
  antialias: true,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  preserveDrawingBuffer: true,
  xrCompatible: true
} as const;

// Renderer Settings
export const RENDERER_SETTINGS = {
  clearColor: 0x000000,
  clearAlpha: 1,
  pixelRatio: Math.min(window.devicePixelRatio, 2),
  toneMapping: 'ACESFilmic',
  toneMappingExposure: 1.5,
  outputColorSpace: 'srgb'
} as const;

// Light Settings
export const LIGHT_SETTINGS = {
  ambient: {
    color: 0xffffff,
    intensity: 1.5
  },
  directional: {
    color: 0xffffff,
    intensity: 2.0,
    position: [10, 20, 10] as [number, number, number]
  },
  hemisphere: {
    skyColor: 0xffffff,
    groundColor: 0x444444,
    intensity: 1.5
  },
  points: [
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [100, 100, 100] as [number, number, number]
    },
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [-100, -100, -100] as [number, number, number]
    }
  ]
} as const;

// Controls Settings
export const CONTROLS_SETTINGS = {
  enableDamping: true,
  dampingFactor: 0.1,
  rotateSpeed: 0.4,
  panSpeed: 0.6,
  zoomSpeed: 1.2,
  minDistance: 50,
  maxDistance: 500
} as const;

----
types/shims-vue.d.ts
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

declare module 'vue-threejs' {
  import type { Plugin } from 'vue'
  const VueThreejs: Plugin
  export default VueThreejs
}

declare module 'three/*' {
  import * as THREE from 'three'
  export * from 'three'
}

----
types/d3-force-3d.d.ts
declare module 'd3-force-3d' {
  export interface SimulationNodeDatum {
    x?: number;
    y?: number;
    z?: number;
    vx?: number;
    vy?: number;
    vz?: number;
    fx?: number | null;
    fy?: number | null;
    fz?: number | null;
    index?: number;
  }

  export interface SimulationLinkDatum<NodeDatum extends SimulationNodeDatum> {
    source: string | NodeDatum;
    target: string | NodeDatum;
    index?: number;
  }

  export interface ForceLink<NodeDatum extends SimulationNodeDatum> {
    links(): SimulationLinkDatum<NodeDatum>[];
    links(links: SimulationLinkDatum<NodeDatum>[]): this;
    id(): (node: NodeDatum) => string;
    id(id: (node: NodeDatum) => string): this;
    distance(): number;
    distance(distance: number): this;
    strength(): number;
    strength(strength: number): this;
  }

  export interface ForceManyBody<NodeDatum extends SimulationNodeDatum> {
    strength(): number;
    strength(strength: number): this;
  }

  export interface ForceCenter {
    x(): number;
    x(x: number): this;
    y(): number;
    y(y: number): this;
    z(): number;
    z(z: number): this;
  }

  export interface Simulation<NodeDatum extends SimulationNodeDatum> {
    nodes(): NodeDatum[];
    nodes(nodes: NodeDatum[]): this;
    alpha(): number;
    alpha(alpha: number): this;
    alphaMin(): number;
    alphaMin(min: number): this;
    alphaDecay(): number;
    alphaDecay(decay: number): this;
    alphaTarget(): number;
    alphaTarget(target: number): this;
    velocityDecay(): number;
    velocityDecay(decay: number): this;
    force<T>(name: string): T | null;
    force<T>(name: string, force: null): this;
    force<T>(name: string, force: T): this;
    find(x: number, y: number, z: number, radius?: number): NodeDatum | undefined;
    on(typenames: string, listener: (this: any, ...args: any[]) => void): this;
    tick(): void;
    stop(): this;
    restart(): this;
  }

  export function forceSimulation<NodeDatum extends SimulationNodeDatum>(nodes?: NodeDatum[]): Simulation<NodeDatum>;
  
  export function forceLink<NodeDatum extends SimulationNodeDatum>(): ForceLink<NodeDatum>;
  
  export function forceManyBody<NodeDatum extends SimulationNodeDatum>(): ForceManyBody<NodeDatum>;
  
  export function forceCenter(): ForceCenter;
}

----
types/websocket.ts
// Message Types (matching server's ServerMessage enum)
export type MessageType = 
  | 'graphUpdate'
  | 'error'
  | 'positionUpdateComplete'
  | 'settingsUpdated'
  | 'simulationModeSet'
  | 'fisheyeSettingsUpdated'
  | 'initialData'
  | 'gpuState'
  | 'layoutState'
  | 'audioData'
  | 'updateSettings'
  | 'openaiResponse'
  | 'ragflowResponse'
  | 'completion'
  | 'ping'
  | 'pong'
  | 'updatePositions'
  | 'binaryPositionUpdate';  // Added for binary position updates

// Binary Protocol Types
export interface BinaryMessage {
  type: 'binaryPositionUpdate';
  data: ArrayBuffer;        // Raw binary data in format:
                           // [x,y,z,vx,vy,vz](24) per node
                           // Node index in array matches index in original graph data
  positions: NodePosition[];  // Processed position data
  nodeCount: number;        // Number of nodes in the update
  isInitialLayout: boolean; // Whether this is an initial layout update
}

export interface NodePosition {
  x: number;
  y: number;
  z: number;
  vx: number;
  vy: number;
  vz: number;
}

// Position update message for client-side force simulation
export interface UpdatePositionsMessage extends BaseMessage {
  type: 'updatePositions';
  nodes: Array<{
    id: string;
    position: [number, number, number];
  }>;
}

// Position update complete message from server
export interface PositionUpdateCompleteMessage extends BaseMessage {
  type: 'positionUpdateComplete';
  status: string;
}

// Graph Data (establishes node order for binary updates)
export interface GraphData {
  nodes: Node[];  // Order of nodes here determines binary update indices
  edges: Edge[];
  metadata?: Record<string, any>;
}

export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  velocity?: [number, number, number];
  size?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  weight?: number;
  group?: string;
}

export interface Edge {
  id: string;  // Added to match core Edge type
  source: string;
  target: string;
  weight?: number;
  width?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  directed?: boolean;
}

// Graph Update Message
export interface GraphUpdateMessage extends BaseMessage {
  type: 'graphUpdate';
  graphData: GraphData;
}

// Initial Data Message
export interface InitialDataMessage extends BaseMessage {
  type: 'initialData';
  graphData: GraphData;
  settings: {
    material?: MaterialSettings;
    physics?: PhysicsSettings;
    bloom?: BloomSettings;
    fisheye?: FisheyeSettings;
  };
}

// Base Message Interface
export interface BaseMessage {
  type: MessageType;
  [key: string]: any;
}

// Settings Interfaces
export interface FisheyeSettings {
  enabled: boolean;
  strength: number;
  focusPoint: [number, number, number];
  radius: number;
}

export interface MaterialSettings {
  nodeSize: number;
  nodeColor: string;
  edgeWidth: number;
  edgeColor: string;
  highlightColor: string;
  opacity: number;
}

export interface PhysicsSettings {
  gravity: number;
  springLength: number;
  springStrength: number;
  repulsion: number;
  damping: number;
  timeStep: number;
}

export interface BloomSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
}

// Message Type Interfaces (matching server's ServerMessage variants)
export interface FisheyeUpdateMessage extends BaseMessage {
  type: 'fisheyeSettingsUpdated';
  enabled: boolean;
  strength: number;
  focusPoint: [number, number, number];
  radius: number;
}

export interface ErrorMessage extends BaseMessage {
  type: 'error';
  message: string;
  details?: string;
  code?: string;
}

export interface AudioMessage extends BaseMessage {
  type: 'audioData';
  audioData: Blob;
}

export interface RagflowResponse extends BaseMessage {
  type: 'ragflowResponse';
  answer: string;
  audio?: string;
}

export interface SimulationModeMessage extends BaseMessage {
  type: 'simulationModeSet';
  mode: string;
  gpuEnabled: boolean;
}

export interface SettingsUpdateMessage extends BaseMessage {
  type: 'updateSettings';
  settings: {
    material?: Partial<MaterialSettings>;
    physics?: Partial<PhysicsSettings>;
    bloom?: Partial<BloomSettings>;
    fisheye?: Partial<FisheyeSettings>;
  };
}

export interface SettingsUpdatedMessage extends BaseMessage {
  type: 'settingsUpdated';
  settings: {
    material?: MaterialSettings;
    physics?: PhysicsSettings;
    bloom?: BloomSettings;
    fisheye?: FisheyeSettings;
  };
}

// Heartbeat Messages
export interface PingMessage extends BaseMessage {
  type: 'ping';
}

export interface PongMessage extends BaseMessage {
  type: 'pong';
}

// WebSocket Configuration
export interface WebSocketConfig {
  messageRateLimit: number;
  messageTimeWindow: number;
  maxMessageSize: number;
  maxAudioSize: number;
  maxQueueSize: number;
  maxRetries: number;
  retryDelay: number;
}

// Event System Types
export type WebSocketEventMap = {
  open: void;
  close: CloseEvent;
  error: ErrorMessage;
  message: BaseMessage;
  graphUpdate: GraphUpdateMessage;
  initialData: InitialDataMessage;  // Add initialData event type
  serverSettings: Record<string, any>;
  ragflowAnswer: string;
  openaiResponse: string;
  simulationModeSet: string;
  completion: string;
  positionUpdateComplete: string;
  gpuPositions: BinaryMessage;
  maxReconnectAttemptsReached: void;
};

export type WebSocketEventCallback<T> = (data: T) => void;

----
types/platform/quest.ts
import type { XRCoreState, Transform, Viewport, SceneConfig, PerformanceConfig } from '../core';
import type { Group, Object3D } from 'three';

// Base XR interfaces
export interface XRRigidTransform {
    position: { x: number; y: number; z: number };
    orientation: { x: number; y: number; z: number; w: number };
    matrix: Float32Array;
}

export interface XRSpace extends EventTarget {
    // Base XR space interface
}

export interface XRReferenceSpace extends XRSpace {
    getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
}

export interface XRRay {
    origin: DOMPointReadOnly;
    direction: DOMPointReadOnly;
    matrix: Float32Array;
}

export interface XRHitTestSource {
    cancel(): void;
}

export interface XRHitTestOptionsInit {
    space: XRSpace;
    offsetRay?: XRRay;
    entityTypes?: string[];
}

// Use the global XRWebGLLayer type
export type XRWebGLLayer = globalThis.XRWebGLLayer;

// Extend XRSession type with AR-specific methods
export interface XRSession extends globalThis.XRSession {
    requestHitTestSource?(options: XRHitTestOptionsInit): Promise<XRHitTestSource> | undefined;
}

export interface XRRenderStateInit {
    baseLayer?: XRWebGLLayer;
    depthFar?: number;
    depthNear?: number;
    inlineVerticalFieldOfView?: number;
}

export interface XRView {
    eye: 'left' | 'right' | 'none';
    projectionMatrix: Float32Array;
    transform: XRRigidTransform;
}

export interface XRViewport {
    x: number;
    y: number;
    width: number;
    height: number;
}

export type XRFrameRequestCallback = (time: number, frame: XRFrame) => void;
export type XRReferenceSpaceType = 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
export type XRSessionMode = 'inline' | 'immersive-vr' | 'immersive-ar';
export type XRHandedness = 'none' | 'left' | 'right';
export type XRTargetRayMode = 'gaze' | 'tracked-pointer' | 'screen';

export interface XRControllerEvent extends Event {
    data?: any;
    target: EventTarget & {
        handedness: XRHandedness;
        targetRayMode: XRTargetRayMode;
    };
}

export interface XRController {
    grip: Group;
    ray: Group;
    hand?: XRHand;
    handedness: XRHandedness;
    targetRayMode: XRTargetRayMode;
    gamepad?: Gamepad;
    controller: Object3D;
    model?: Object3D;
    visible: boolean;
    connected: boolean;
}

export interface XRHand {
    joints: Map<XRHandJoint, XRJointSpace>;
    hand: Object3D;
    model?: Object3D;
    visible: boolean;
    connected: boolean;
}

export type XRHandJoint = 
    | 'wrist'
    | 'thumb-metacarpal'
    | 'thumb-phalanx-proximal'
    | 'thumb-phalanx-distal'
    | 'thumb-tip'
    | 'index-finger-metacarpal'
    | 'index-finger-phalanx-proximal'
    | 'index-finger-phalanx-intermediate'
    | 'index-finger-phalanx-distal'
    | 'index-finger-tip';

export interface XRJointSpace extends XRSpace {
    jointRadius: number;
}

export interface QuestInitOptions {
    canvas: HTMLCanvasElement;
    scene?: SceneConfig;
    performance?: PerformanceConfig;
    xr?: {
        referenceSpaceType?: XRReferenceSpaceType;
        sessionMode?: XRSessionMode;
        optionalFeatures?: string[];
        requiredFeatures?: string[];
    };
}

export interface QuestState extends XRCoreState {
    xrSession: XRSession | null;
    xrSpace: XRReferenceSpace | null;
    xrLayer: XRWebGLLayer | null;
    hitTestSource: XRHitTestSource | null;
    controllers: Map<XRHandedness, XRController>;
    hands: Map<XRHandedness, XRHand>;
    viewport: Viewport;
    transform: Transform;
    config: {
        scene: SceneConfig;
        performance: PerformanceConfig;
        xr: {
            referenceSpaceType: XRReferenceSpaceType;
            sessionMode: XRSessionMode;
            optionalFeatures: string[];
            requiredFeatures: string[];
        };
    };
}

export interface QuestPlatform {
    state: QuestState;
    initialize(options: QuestInitOptions): Promise<void>;
    dispose(): void;
    render(): void;
    resize(width: number, height: number): void;
    setPixelRatio(ratio: number): void;
    getViewport(): Viewport;
    setTransform(transform: Partial<Transform>): void;
    getTransform(): Transform;
    enableVR(): Promise<void>;
    disableVR(): void;
    isVRSupported(): boolean;
    isVRActive(): boolean;
    getControllerGrip(handedness: XRHandedness): Group | null;
    getControllerRay(handedness: XRHandedness): Group | null;
    getHand(handedness: XRHandedness): XRHand | null;
    vibrate(handedness: XRHandedness, intensity?: number, duration?: number): void;
}

----
types/platform/browser.ts
import type { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import type { BrowserCoreState, Transform, Viewport, SceneConfig, PerformanceConfig } from '../core';
import type { Vector2 } from 'three';

export interface BrowserInitOptions {
  canvas: HTMLCanvasElement;
  scene?: SceneConfig;
  performance?: PerformanceConfig;
  controls?: {
    enableDamping?: boolean;
    dampingFactor?: number;
    enableZoom?: boolean;
    enableRotate?: boolean;
    enablePan?: boolean;
    autoRotate?: boolean;
    autoRotateSpeed?: number;
    minDistance?: number;
    maxDistance?: number;
    minPolarAngle?: number;
    maxPolarAngle?: number;
  };
}

export interface BrowserState extends BrowserCoreState {
  controls: OrbitControls | null;
  viewport: Viewport;
  transform: Transform;
  mousePosition: Vector2;
  touchActive: boolean;
  pointerLocked: boolean;
  config: {
    scene: SceneConfig;
    performance: PerformanceConfig;
  };
}

export interface BrowserPlatform {
  state: BrowserState;
  initialize(options: BrowserInitOptions): Promise<void>;
  dispose(): void;
  render(): void;
  resize(width: number, height: number): void;
  setPixelRatio(ratio: number): void;
  getViewport(): Viewport;
  setTransform(transform: Partial<Transform>): void;
  getTransform(): Transform;
  enableVR(): Promise<void>;
  disableVR(): void;
  isVRSupported(): boolean;
  isVRActive(): boolean;
}

----
services/fisheyeManager.ts
// TODO: Future client-side fisheye implementation
// This manager will handle fisheye visualization settings and shader uniforms,
// keeping the effect purely in the visualization layer.
//
// Implementation notes:
// - Fisheye should be a visualization-only effect
// - No server communication needed for fisheye updates
// - Settings affect only the rendering, not the data
// - Can be enabled/disabled without impacting graph layout
//
// Example implementation (to be integrated later):
/*
import { ref, watch } from 'vue';

export interface FisheyeSettings {
    enabled: boolean;
    strength: number;
    radius: number;
    focusPoint: [number, number, number];
}

export class FisheyeManager {
    private enabled = ref(false);
    private strength = ref(0.5);
    private radius = ref(100.0);
    private focusPoint = ref([0, 0, 0]);

    // Shader uniforms that will be updated
    private uniforms = {
        fisheyeEnabled: { value: false },
        fisheyeStrength: { value: 0.5 },
        fisheyeRadius: { value: 100.0 },
        fisheyeFocusPoint: { value: [0, 0, 0] }
    };

    constructor() {
        // Watch for changes and update uniforms
        watch(this.enabled, (value) => {
            this.uniforms.fisheyeEnabled.value = value;
        });

        watch(this.strength, (value) => {
            this.uniforms.fisheyeStrength.value = value;
        });

        watch(this.radius, (value) => {
            this.uniforms.fisheyeRadius.value = value;
        });

        watch(this.focusPoint, (value) => {
            this.uniforms.fisheyeFocusPoint.value = value;
        });
    }

    // Update settings locally (no server communication needed)
    updateSettings(settings: FisheyeSettings) {
        this.enabled.value = settings.enabled;
        this.strength.value = settings.strength;
        this.radius.value = settings.radius;
        this.focusPoint.value = settings.focusPoint;
    }

    // Get uniforms for shader
    getUniforms() {
        return this.uniforms;
    }
}

// Singleton instance (commented out until implementation)
// export const fisheyeManager = new FisheyeManager();
*/

----
services/websocketService.ts
import type {
  WebSocketConfig,
  WebSocketEventMap,
  WebSocketEventCallback,
  BaseMessage,
  ErrorMessage,
  BinaryMessage,
  GraphUpdateMessage,
  NodePosition,
  InitialDataMessage,
  Node
} from '../types/websocket'

import { processPositionUpdate } from '../utils/gpuUtils'

import {
  DEFAULT_RECONNECT_ATTEMPTS,
  DEFAULT_RECONNECT_DELAY,
  DEFAULT_MESSAGE_RATE_LIMIT,
  DEFAULT_MESSAGE_TIME_WINDOW,
  DEFAULT_MAX_MESSAGE_SIZE,
  DEFAULT_MAX_AUDIO_SIZE,
  DEFAULT_MAX_QUEUE_SIZE,
  HEARTBEAT_INTERVAL,
  HEARTBEAT_TIMEOUT,
  CONNECTION_TIMEOUT
} from '../constants/websocket'

// Enhanced debug logging with data validation
const debugLog = (message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  const logPrefix = `[WebsocketService ${timestamp}]`;
  
  console.debug(`${logPrefix} ${message}`);
  
  if (data) {
    if (data instanceof ArrayBuffer) {
      const nodeCount = data.byteLength / 24;
      console.debug(`${logPrefix} Binary Data Analysis:
        Node Count: ${nodeCount}
        Total Size: ${data.byteLength} bytes`);
    } else if (data instanceof Event) {
      const eventDetails = {
        type: data.type,
        timeStamp: data.timeStamp,
        isTrusted: data.isTrusted,
        target: data instanceof CloseEvent ? {
          code: data.code,
          reason: data.reason,
          wasClean: data.wasClean
        } : undefined,
        readyState: (data.target as WebSocket)?.readyState,
        url: (data.target as WebSocket)?.url
      };
      console.debug(`${logPrefix} Event Details:`, eventDetails);
    } else if (data instanceof Error) {
      console.debug(`${logPrefix} Error Details:`, {
        name: data.name,
        message: data.message,
        stack: data.stack,
        cause: data.cause
      });
    } else if (typeof data === 'object' && data.type === 'initialData') {
      // Special handling for initialData messages
      console.debug(`${logPrefix} Initial Data Message:`, {
        type: data.type,
        graphData: {
          nodeCount: data.graphData?.nodes?.length || 0,
          edgeCount: data.graphData?.edges?.length || 0,
          sampleNodes: data.graphData?.nodes?.slice(0, 3).map((n: { id: string; position?: [number, number, number]; label?: string }) => ({
            id: n.id,
            hasPosition: !!n.position,
            position: n.position,
            label: n.label
          })),
          sampleEdges: data.graphData?.edges?.slice(0, 3).map((e: { source: string; target: string }) => ({
            source: e.source,
            target: e.target
          }))
        },
        hasSettings: !!data.settings,
        timestamp: new Date().toISOString()
      });
    } else if (typeof data === 'object' && data.type === 'graphUpdate') {
      // Special handling for graphUpdate messages
      console.debug(`${logPrefix} Graph Update Message:`, {
        type: data.type,
        graphData: {
          nodeCount: data.graphData?.nodes?.length || 0,
          edgeCount: data.graphData?.edges?.length || 0,
          sampleNodes: data.graphData?.nodes?.slice(0, 3).map((n: { id: string; position?: [number, number, number]; label?: string }) => ({
            id: n.id,
            hasPosition: !!n.position,
            position: n.position,
            label: n.label
          })),
          sampleEdges: data.graphData?.edges?.slice(0, 3).map((e: { source: string; target: string }) => ({
            source: e.source,
            target: e.target
          }))
        },
        timestamp: new Date().toISOString()
      });
    } else if (typeof data === 'object') {
      console.debug(`${logPrefix} Data (${data?.constructor?.name || typeof data}):`, 
        JSON.stringify(data, null, 2));
    } else {
      console.debug(`${logPrefix} Data (${typeof data}):`, data);
    }
  }
};

const DEFAULT_CONFIG: WebSocketConfig = {
  messageRateLimit: DEFAULT_MESSAGE_RATE_LIMIT,
  messageTimeWindow: DEFAULT_MESSAGE_TIME_WINDOW,
  maxMessageSize: DEFAULT_MAX_MESSAGE_SIZE,
  maxAudioSize: DEFAULT_MAX_AUDIO_SIZE,
  maxQueueSize: DEFAULT_MAX_QUEUE_SIZE,
  maxRetries: DEFAULT_RECONNECT_ATTEMPTS,
  retryDelay: DEFAULT_RECONNECT_DELAY
}

export default class WebsocketService {
  private ws: WebSocket | null = null;
  private config: WebSocketConfig;
  private messageQueue: any[] = [];
  private messageCount = 0;
  private lastMessageTime = 0;
  private reconnectAttempts = 0;
  private reconnectTimeout: number | null = null;
  private heartbeatInterval: number | null = null;
  private lastPongTime: number = Date.now();
  private eventListeners: Map<keyof WebSocketEventMap, Set<WebSocketEventCallback<any>>> = new Map();
  private url: string;
  private nodeIdToIndex: Map<string, number> = new Map();
  private indexToNodeId: string[] = [];
  private isReconnecting: boolean = false;
  private forceClose: boolean = false;
  private pendingBinaryUpdate: boolean = false;
  private isInitialLayout: boolean = false;

  constructor(config: Partial<WebSocketConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    
    // Use wss:// for production
    const hostname = window.location.hostname;
    this.url = `wss://${hostname}/ws`;
    
    debugLog('WebSocket service initialized', {
      url: this.url,
      config: this.config,
      protocol: window.location.protocol,
      hostname: hostname
    });
  }

  private startHeartbeat() {
    if (this.heartbeatInterval) {
      window.clearInterval(this.heartbeatInterval);
    }

    this.heartbeatInterval = window.setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        if (Date.now() - this.lastPongTime > HEARTBEAT_TIMEOUT) {
          debugLog('Heartbeat timeout - no pong received', {
            lastPongTime: new Date(this.lastPongTime).toISOString(),
            timeout: HEARTBEAT_TIMEOUT,
            timeSinceLastPong: Date.now() - this.lastPongTime
          });
          this.reconnect();
          return;
        }

        try {
          debugLog('Sending ping');
          this.ws.send(JSON.stringify({ type: 'ping' }));
        } catch (error) {
          debugLog('Error sending heartbeat', error);
          this.reconnect();
        }
      }
    }, HEARTBEAT_INTERVAL);

    debugLog('Heartbeat started', {
      interval: HEARTBEAT_INTERVAL,
      timeout: HEARTBEAT_TIMEOUT
    });
  }

  private stopHeartbeat() {
    if (this.heartbeatInterval) {
      window.clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
      debugLog('Heartbeat stopped');
    }
  }

  private reconnect() {
    if (this.isReconnecting || this.forceClose) {
      debugLog('Reconnect skipped', {
        isReconnecting: this.isReconnecting,
        forceClose: this.forceClose
      });
      return;
    }
    
    this.isReconnecting = true;
    this.cleanup(false);
    
    if (this.reconnectAttempts < this.config.maxRetries) {
      this.reconnectAttempts++;
      const delay = this.config.retryDelay * Math.pow(2, this.reconnectAttempts - 1);
      debugLog('Scheduling reconnection', {
        attempt: this.reconnectAttempts,
        maxRetries: this.config.maxRetries,
        delay: delay
      });
      
      this.reconnectTimeout = window.setTimeout(() => {
        this.connect().catch(error => {
          debugLog('Reconnection attempt failed', error);
          this.reconnect();
        }).finally(() => {
          this.isReconnecting = false;
        });
      }, delay);
    } else {
      debugLog('Max reconnection attempts reached', {
        attempts: this.reconnectAttempts,
        maxRetries: this.config.maxRetries
      });
      this.emit('maxReconnectAttemptsReached');
      this.isReconnecting = false;
    }
  }

  public async connect(): Promise<void> {
    if (this.ws?.readyState === WebSocket.OPEN) {
      debugLog('WebSocket already connected');
      return;
    }

    return new Promise((resolve, reject) => {
      try {
        debugLog('Initiating WebSocket connection', {
          attempt: this.reconnectAttempts + 1,
          maxRetries: this.config.maxRetries,
          url: this.url
        });
        
        this.ws = new WebSocket(this.url);
        this.ws.binaryType = 'arraybuffer';

        const connectionTimeout = setTimeout(() => {
          if (this.ws?.readyState !== WebSocket.OPEN) {
            debugLog('Connection timeout', {
              readyState: this.ws?.readyState,
              timeout: CONNECTION_TIMEOUT,
              url: this.url
            });
            this.ws?.close();
            reject(new Error('WebSocket connection timeout'));
            this.reconnect();
          }
        }, CONNECTION_TIMEOUT);

        this.ws.onopen = (event) => {
          clearTimeout(connectionTimeout);
          debugLog('WebSocket connection established', {
            readyState: this.ws?.readyState,
            url: this.url,
            event
          });
          this.reconnectAttempts = 0;
          this.lastPongTime = Date.now();
          this.startHeartbeat();
          this.emit('open');
          this.processQueuedMessages();
          resolve();
        };

        this.ws.onclose = (event) => {
          clearTimeout(connectionTimeout);
          this.stopHeartbeat();
          debugLog('WebSocket connection closed', {
            code: event.code,
            reason: event.reason,
            wasClean: event.wasClean,
            readyState: this.ws?.readyState,
            event
          });
          
          if (!this.forceClose) {
            this.reconnect();
          }
          
          this.emit('close', event);
        };

        this.ws.onerror = (event) => {
          clearTimeout(connectionTimeout);
          debugLog('WebSocket error occurred', {
            readyState: this.ws?.readyState,
            url: this.url,
            event
          });

          // Try to get more error details from the event
          let errorDetails = 'Unknown error';
          if (event instanceof ErrorEvent) {
            errorDetails = event.message;
          } else if ('error' in event && event.error instanceof Error) {
            errorDetails = event.error.message;
          } else if (event instanceof Event && event.target instanceof WebSocket) {
            // Try to get information from WebSocket state
            errorDetails = `WebSocket error (readyState: ${event.target.readyState})`;
          }

          const errorMsg: ErrorMessage = {
            type: 'error',
            message: 'WebSocket connection error',
            details: errorDetails,
            code: 'CONNECTION_ERROR'
          };
          this.emit('error', errorMsg);
          
          if (this.ws?.readyState !== WebSocket.OPEN) {
            reject(new Error(`WebSocket connection failed: ${errorDetails}`));
          }
        };

        this.ws.onmessage = this.handleMessage.bind(this);

      } catch (error) {
        debugLog('Error creating WebSocket connection', {
          error,
          url: this.url
        });
        reject(error);
        this.reconnect();
      }
    });
  }

private handleMessage(event: MessageEvent): void {
  try {
    debugLog('Received WebSocket message', {
      type: event.type,
      dataType: event.data instanceof ArrayBuffer ? 'ArrayBuffer' : typeof event.data,
      dataSize: event.data?.length || 0
    });

    if (event.data instanceof ArrayBuffer) {
      if (!this.pendingBinaryUpdate) {
        debugLog('Received unexpected binary data without type information');
        return;
      }

      // Handle binary message (position updates)
      const result = processPositionUpdate(event.data);
      if (!result) {
        throw new Error('Failed to process position update');
      }

      if (result.positions.length !== this.indexToNodeId.length) {
        debugLog('Position update node count mismatch', {
          expected: this.indexToNodeId.length,
          received: result.positions.length
        });
      }

      const positions = result.positions.map((pos, index) => {
        const nodeId = this.indexToNodeId[index];
        if (!nodeId) {
          debugLog('Missing node ID mapping', { index });
          return null;
        }
        return {
          ...pos,
          id: nodeId
        };
      }).filter((pos): pos is NodePosition & { id: string } => pos !== null);

      const binaryMessage: BinaryMessage = {
        type: 'binaryPositionUpdate',
        data: event.data,
        positions,
        nodeCount: this.indexToNodeId.length,
        isInitialLayout: this.isInitialLayout
      };

      debugLog('Processed binary message', {
        nodeCount: positions.length,
        isInitialLayout: this.isInitialLayout,
        samplePositions: positions.slice(0, 3)
      });

      this.emit('gpuPositions', binaryMessage);
      this.pendingBinaryUpdate = false;

    } else {
      // Handle JSON message
      const message = JSON.parse(event.data) as BaseMessage;
      debugLog('Parsed JSON message', message);

      // Handle pong messages
      if (message.type === 'pong') {
        debugLog('Received pong');
        this.lastPongTime = Date.now();
        return;
      }

      // Handle binary position update type
      if (message.type === 'binaryPositionUpdate') {
        this.pendingBinaryUpdate = true;
        this.isInitialLayout = message.isInitialLayout;
        return;
      }
      
      // Handle graph updates and store node mappings
      if (message.type === 'graphUpdate' || message.type === 'initialData') {
        const graphMessage = message as GraphUpdateMessage | InitialDataMessage;
        debugLog(`Processing ${message.type}`, {
          hasGraphData: !!graphMessage.graphData,
          nodeCount: graphMessage.graphData?.nodes?.length || 0,
          edgeCount: graphMessage.graphData?.edges?.length || 0,
          sampleNodes: graphMessage.graphData?.nodes?.slice(0, 3).map((n: Node) => ({
            id: n.id,
            hasPosition: !!n.position,
            position: n.position,
            label: n.label
          }))
        });

        if (graphMessage.graphData?.nodes) {
          this.nodeIdToIndex.clear();
          this.indexToNodeId = [];
          
          graphMessage.graphData.nodes.forEach((node: Node, index: number) => {
            this.nodeIdToIndex.set(node.id, index);
            this.indexToNodeId[index] = node.id;
          });
          
          debugLog('Node ID mappings updated', {
            mappingCount: this.indexToNodeId.length,
            sampleMappings: this.indexToNodeId.slice(0, 3).map(id => ({
              id,
              index: this.nodeIdToIndex.get(id)
            }))
          });
        }
        
        // Emit the appropriate event based on message type
        if (message.type === 'initialData') {
          this.emit('initialData', message as InitialDataMessage);
        } else {
          this.emit('graphUpdate', message as GraphUpdateMessage);
        }
        
        // Also emit the message for any other handlers
        this.emit('message', message);
      } else {
        this.emit('message', message);
        
        if (message.type === 'error') {
          debugLog('Received error message', message);
          this.emit('error', message as ErrorMessage);
        }
      }
    }
  } catch (error) {
    debugLog('Error handling WebSocket message', {
      error,
      eventType: event.type,
      dataType: typeof event.data
    });
    const errorMsg: ErrorMessage = {
      type: 'error',
      message: 'Error processing message',
      details: error instanceof Error ? error.message : String(error)
    };
    this.emit('error', errorMsg);
  }
}

  public send(data: any): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      if (this.messageQueue.length < this.config.maxQueueSize) {
        this.messageQueue.push(data);
        debugLog('Message queued', {
          type: data.type,
          queueSize: this.messageQueue.length,
          maxQueueSize: this.config.maxQueueSize
        });
      } else {
        debugLog('Message queue full, dropping message', {
          type: data.type,
          queueSize: this.messageQueue.length
        });
      }
      return;
    }

    const now = Date.now();
    if (now - this.lastMessageTime > this.config.messageTimeWindow) {
      this.messageCount = 0;
      this.lastMessageTime = now;
    }

    if (this.messageCount >= this.config.messageRateLimit) {
      if (this.messageQueue.length < this.config.maxQueueSize) {
        this.messageQueue.push(data);
        debugLog('Rate limited, message queued', {
          type: data.type,
          queueSize: this.messageQueue.length,
          messageCount: this.messageCount,
          rateLimit: this.config.messageRateLimit
        });
      }
      return;
    }

    try {
      const message = JSON.stringify(data);
      if (message.length > this.config.maxMessageSize) {
        throw new Error('Message exceeds maximum size');
      }
      
      debugLog('Sending message', {
        type: data.type,
        size: message.length,
        maxSize: this.config.maxMessageSize
      });

      this.ws.send(message);
      this.messageCount++;
      this.lastMessageTime = now;

      this.processQueue();
    } catch (error) {
      debugLog('Error sending message', {
        error,
        data: data
      });
      const errorMsg: ErrorMessage = {
        type: 'error',
        message: 'Error sending message',
        details: error instanceof Error ? error.message : String(error)
      };
      this.emit('error', errorMsg);
    }
  }

  public sendBinary(data: ArrayBuffer): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      debugLog('Cannot send binary data: WebSocket not open', {
        readyState: this.ws?.readyState,
        dataSize: data.byteLength
      });
      return;
    }

    try {
      debugLog('Sending binary data', {
        size: data.byteLength,
        header: Array.from(new Uint8Array(data.slice(0, 16))).map(b => b.toString(16).padStart(2, '0')).join(' ')
      });
      this.ws.send(data);
    } catch (error) {
      debugLog('Error sending binary data', {
        error,
        dataSize: data.byteLength
      });
      const errorMsg: ErrorMessage = {
        type: 'error',
        message: 'Error sending binary data',
        details: error instanceof Error ? error.message : String(error)
      };
      this.emit('error', errorMsg);
    }
  }

  private processQueue(): void {
    while (
      this.messageQueue.length > 0 &&
      this.messageCount < this.config.messageRateLimit
    ) {
      const data = this.messageQueue.shift();
      if (data) {
        debugLog('Processing queued message', {
          type: data.type,
          remainingQueue: this.messageQueue.length,
          messageCount: this.messageCount
        });
        this.send(data);
      }
    }
  }

  private processQueuedMessages(): void {
    if (this.messageQueue.length > 0) {
      debugLog('Processing queued messages', {
        count: this.messageQueue.length
      });
      const messages = [...this.messageQueue];
      this.messageQueue = [];
      messages.forEach(message => this.send(message));
    }
  }

  public on<K extends keyof WebSocketEventMap>(
    event: K,
    callback: WebSocketEventCallback<WebSocketEventMap[K]>
  ): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, new Set());
    }
    this.eventListeners.get(event)!.add(callback);
    debugLog('Event listener added', { event });
  }

  public off<K extends keyof WebSocketEventMap>(
    event: K,
    callback: WebSocketEventCallback<WebSocketEventMap[K]>
  ): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.delete(callback);
      debugLog('Event listener removed', { event });
    }
  }

  private emit<K extends keyof WebSocketEventMap>(
    event: K,
    data?: WebSocketEventMap[K]
  ): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      debugLog('Emitting event', {
        event,
        listenerCount: listeners.size,
        data: data
      });
      listeners.forEach(callback => callback(data));
    }
  }

  public cleanup(force: boolean = true): void {
    debugLog('Cleaning up websocket service', {
      force,
      isReconnecting: this.isReconnecting,
      hasActiveConnection: !!this.ws
    });
    
    this.stopHeartbeat();
    
    if (this.reconnectTimeout !== null) {
      window.clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.ws) {
      this.forceClose = force;
      this.ws.onclose = null;
      this.ws.close();
      this.ws = null;
    }

    this.messageQueue = [];
    this.messageCount = 0;
    this.lastMessageTime = 0;
    if (force) {
      this.reconnectAttempts = 0;
      this.eventListeners.clear();
      this.nodeIdToIndex.clear();
      this.indexToNodeId = [];
    }
  }
}

----
services/spacemouse.js
// Spacemouse HID interface

const SPACEMOUSE_VENDOR_ID = 0x256F; // 3Dconnexion vendor ID
const SPACEMOUSE_PRODUCT_ID = 0xC635; // SpaceMouse Compact product ID (may vary for different models)

let spacemouseDevice = null;

async function requestHIDAccess() {
    try {
        const devices = await navigator.hid.requestDevice({
            filters: [{ vendorId: SPACEMOUSE_VENDOR_ID, productId: SPACEMOUSE_PRODUCT_ID }]
        });
        if (devices.length > 0) {
            spacemouseDevice = devices[0];
            await spacemouseDevice.open();
            console.log('HID device opened:', spacemouseDevice.productName);
            spacemouseDevice.addEventListener('inputreport', handleHIDInput);
        }
    } catch (error) {
        console.error('HID access denied:', error);
    }
}

function handleHIDInput(event) {
    const { data } = event;
    
    // Parse the input data
    const x = data.getInt16(1, true);
    const y = data.getInt16(3, true);
    const z = data.getInt16(5, true);

    // Normalize values (adjust as needed based on your Spacemouse model)
    const normalizedX = x / 350;
    const normalizedY = y / 350;
    const normalizedZ = z / 350;

    // Emit an event with the normalized values
    const spacemouseEvent = new CustomEvent('spacemouse-move', {
        detail: { x: normalizedX, y: normalizedY, z: normalizedZ }
    });
    window.dispatchEvent(spacemouseEvent);
}

// Function to be called when the "Enable Spacemouse" button is clicked
function enableSpacemouse() {
    if (navigator.hid) {
        requestHIDAccess();
    } else {
        console.error('WebHID is not supported in this browser');
        alert('WebHID is not supported in this browser. Please use a compatible browser like Chrome or Edge.');
    }
}

// Export the function to be used in Vue components
export { enableSpacemouse };
----
services/visualizationSettings.js
// Manages visualization settings received from the server
export class VisualizationSettings {
    constructor() {
        // Initialize empty settings structure - will be populated from server
        this.settings = null;

        // Bind the WebSocket message handler
        this.handleServerSettings = this.handleServerSettings.bind(this);
        window.addEventListener('serverSettings', this.handleServerSettings);

        console.log('Visualization settings initialized - waiting for server settings');
    }

    handleServerSettings(event) {
        console.log('Received server settings:', event.detail);
        
        // Store settings received from server
        this.settings = event.detail;

        console.log('Updated settings with server values');

        // Dispatch event to notify components of updated settings
        window.dispatchEvent(new CustomEvent('visualizationSettingsUpdated', {
            detail: this.settings
        }));
    }

    getSettings() {
        if (!this.settings) {
            console.warn('Settings not yet received from server');
            return null;
        }
        return this.settings;
    }

    getNodeSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            color: vis.node_color,
            colorNew: vis.node_color_new,
            colorRecent: vis.node_color_recent,
            colorMedium: vis.node_color_medium,
            colorOld: vis.node_color_old,
            colorCore: vis.node_color_core,
            colorSecondary: vis.node_color_secondary,
            colorDefault: vis.node_color_default,
            minNodeSize: vis.min_node_size,
            maxNodeSize: vis.max_node_size,
            material: {
                metalness: vis.node_material_metalness,
                roughness: vis.node_material_roughness,
                clearcoat: vis.node_material_clearcoat,
                clearcoatRoughness: vis.node_material_clearcoat_roughness,
                opacity: vis.node_material_opacity,
                emissiveMinIntensity: vis.node_emissive_min_intensity,
                emissiveMaxIntensity: vis.node_emissive_max_intensity
            },
            ageMaxDays: vis.node_age_max_days,
            geometryMinSegments: vis.geometry_min_segments,
            geometryMaxSegments: vis.geometry_max_segments,
            geometrySegmentPerHyperlink: vis.geometry_segment_per_hyperlink,
            clickEmissiveBoost: vis.click_emissive_boost,
            clickFeedbackDuration: vis.click_feedback_duration
        };
    }

    getEdgeSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            color: vis.edge_color,
            opacity: vis.edge_opacity,
            weightNormalization: vis.edge_weight_normalization,
            minWidth: vis.edge_min_width,
            maxWidth: vis.edge_max_width
        };
    }

    getLabelSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            fontSize: vis.label_font_size,
            fontFamily: vis.label_font_family,
            padding: vis.label_padding,
            verticalOffset: vis.label_vertical_offset,
            closeOffset: vis.label_close_offset,
            backgroundColor: vis.label_background_color,
            textColor: vis.label_text_color,
            infoTextColor: vis.label_info_text_color,
            xrFontSize: vis.label_xr_font_size
        };
    }

    getLayoutSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            iterations: vis.force_directed_iterations,
            spring_strength: vis.force_directed_spring,
            repulsion_strength: vis.force_directed_repulsion,
            attraction_strength: vis.force_directed_attraction,
            damping: vis.force_directed_damping
        };
    }

    getEnvironmentSettings() {
        if (!this.settings?.visualization) {
            console.warn('Visualization settings not yet received from server');
            return null;
        }

        const vis = this.settings.visualization;
        return {
            fogDensity: vis.fog_density
        };
    }

    getBloomSettings() {
        if (!this.settings?.bloom) {
            console.warn('Bloom settings not yet received from server');
            return null;
        }
        return this.settings.bloom;
    }

    getFisheyeSettings() {
        if (!this.settings?.fisheye) {
            console.warn('Fisheye settings not yet received from server');
            return null;
        }
        return this.settings.fisheye;
    }

    updateSettings(settings) {
        // Send settings update to server
        window.dispatchEvent(new CustomEvent('updateSettings', {
            detail: settings
        }));
    }
}

// Create and export singleton instance
export const visualizationSettings = new VisualizationSettings();

----
services/errorTracking.ts
interface ErrorInfo {
  message: string;
  context?: string;
  component?: string;
  stack?: string;
  timestamp: number;
  additional?: any;
}

class ErrorTrackingService {
  private errors: ErrorInfo[] = [];
  private maxErrors = 100;

  private constructor() {
    this.setupGlobalHandlers();
  }

  private static instance: ErrorTrackingService;

  public static getInstance(): ErrorTrackingService {
    if (!ErrorTrackingService.instance) {
      ErrorTrackingService.instance = new ErrorTrackingService();
    }
    return ErrorTrackingService.instance;
  }

  private setupGlobalHandlers() {
    window.onerror = (message, source, lineno, colno, error) => {
      this.trackError(error || new Error(String(message)), {
        context: 'Global Error Handler',
        additional: { source, lineno, colno }
      });
    };

    window.onunhandledrejection = (event) => {
      this.trackError(event.reason, {
        context: 'Unhandled Promise Rejection'
      });
    };
  }

  public trackError(error: Error | unknown, info?: {
    context?: string;
    component?: string;
    additional?: any;
  }) {
    const errorInfo: ErrorInfo = {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      context: info?.context,
      component: info?.component,
      additional: info?.additional,
      timestamp: Date.now()
    };

    this.errors.unshift(errorInfo);

    // Trim old errors
    if (this.errors.length > this.maxErrors) {
      this.errors = this.errors.slice(0, this.maxErrors);
    }

    // Emit event for any listeners
    window.dispatchEvent(new CustomEvent('error-tracked', {
      detail: errorInfo
    }));
  }

  public getErrors(): ErrorInfo[] {
    return [...this.errors];
  }

  public clearErrors(): void {
    this.errors = [];
  }
}

export const errorTracking = ErrorTrackingService.getInstance();

----
services/graphDataManager.js
// public/js/services/graphDataManager.js

/**
 * GraphDataManager handles the management and updating of graph data received from the server.
 */
export class GraphDataManager {
    constructor(websocketService) {
        this.websocketService = websocketService;
        this.graphData = null;
        
        console.log('GraphDataManager initialized');
        
        // Bind methods to preserve this context
        this.handleGraphUpdate = this.handleGraphUpdate.bind(this);
        this.handleBinaryPositionUpdate = this.handleBinaryPositionUpdate.bind(this);
        
        // Set up event listeners
        if (this.websocketService) {
            this.websocketService.on('graphUpdate', this.handleGraphUpdate);
            this.websocketService.on('gpuPositions', this.handleBinaryPositionUpdate);

            // Debug listener for websocket connection state
            this.websocketService.on('connect', () => {
                console.log('GraphDataManager detected websocket connection');
                this.requestInitialData();
            });
        } else {
            console.error('GraphDataManager initialized without websocket service');
        }
    }

    requestInitialData() {
        console.log('Requesting initial data');
        if (this.websocketService) {
            this.websocketService.send({ type: 'getInitialData' });
        }
    }

    handleBinaryPositionUpdate(update) {
        if (!this.graphData || !this.graphData.nodes) {
            console.error('Cannot apply position update: No graph data exists');
            return;
        }

        const { positions } = update;
        console.log('Received position update for', positions.length, 'nodes');
        
        // Transform position array into node objects
        const updatedNodes = this.graphData.nodes.map((node, index) => {
            if (positions[index]) {
                const pos = positions[index];
                return {
                    ...node,
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    vx: pos.vx,
                    vy: pos.vy,
                    vz: pos.vz
                };
            }
            return node;
        });

        // Update the graph data with the new nodes
        this.graphData = {
            ...this.graphData,
            nodes: updatedNodes
        };

        // Notify visualization of position updates
        this.dispatchGraphUpdate();
    }

    handleGraphUpdate(data) {
        console.log('Received graph update:', data);
        if (!data || !data.graphData) {
            console.error('Invalid graph update data received:', data);
            return;
        }
        this.updateGraphData(data.graphData);
    }

    // Helper function to generate initial positions in a sphere
    generateInitialPositions(count) {
        const positions = [];
        const radius = 100; // Increased sphere radius for better visibility
        const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle

        for (let i = 0; i < count; i++) {
            const y = 1 - (i / (count - 1)) * 2; // y goes from 1 to -1
            const radius_at_y = Math.sqrt(1 - y * y); // radius at y
            const theta = phi * i; // Golden angle increment

            const x = Math.cos(theta) * radius_at_y;
            const z = Math.sin(theta) * radius_at_y;

            // Add some random offset to prevent perfect sphere
            const randomOffset = 20; // Increased random offset
            positions.push({
                x: x * radius + (Math.random() - 0.5) * randomOffset,
                y: y * radius + (Math.random() - 0.5) * randomOffset,
                z: z * radius + (Math.random() - 0.5) * randomOffset
            });
        }

        return positions;
    }

    updateGraphData(newData) {
        console.log('Updating graph data with:', newData);
        
        if (!newData) {
            console.error('Received null or undefined graph data');
            return;
        }

        // Preserve metadata if it exists in newData
        const metadata = newData.metadata || {};
        console.log('Received metadata:', metadata);

        let nodes = [];
        let edges = [];

        // Handle the case where newData already has nodes and edges arrays
        if (Array.isArray(newData.nodes) && Array.isArray(newData.edges)) {
            console.log('Processing complete graph data with nodes and edges');
            
            // Process nodes with existing positions
            nodes = newData.nodes.map(node => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === node.id);
                const nodeMetadata = metadata[`${node.id}.md`] || {};
                
                // If no position exists, generate a random position within view range
                const randomPosition = {
                    x: (Math.random() - 0.5) * 200, // Increased range
                    y: (Math.random() - 0.5) * 200,
                    z: (Math.random() - 0.5) * 200
                };
                
                return {
                    ...node,
                    x: (typeof node.x === 'number' && !isNaN(node.x)) ? node.x : (existingNode?.x || randomPosition.x),
                    y: (typeof node.y === 'number' && !isNaN(node.y)) ? node.y : (existingNode?.y || randomPosition.y),
                    z: (typeof node.z === 'number' && !isNaN(node.z)) ? node.z : (existingNode?.z || randomPosition.z),
                    metadata: nodeMetadata
                };
            });

            edges = newData.edges;
        }
        // Handle the case where we need to construct nodes from edges
        else if (Array.isArray(newData.edges)) {
            console.log('Constructing nodes from edges');
            
            // Extract unique node IDs from edges
            const nodeSet = new Set();
            newData.edges.forEach(edge => {
                nodeSet.add(edge.source);
                nodeSet.add(edge.target);
            });

            // Generate initial positions for nodes
            const initialPositions = this.generateInitialPositions(nodeSet.size);
            
            // Create nodes with positions
            nodes = Array.from(nodeSet).map((id, index) => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === id);
                const nodeMetadata = metadata[`${id}.md`] || {};
                const position = existingNode || initialPositions[index];
                
                return {
                    id,
                    label: id,
                    x: position.x,
                    y: position.y,
                    z: position.z,
                    metadata: nodeMetadata
                };
            });

            edges = newData.edges;
        } else {
            console.error('Invalid graph data format:', newData);
            return;
        }

        // Process edges
        const processedEdges = edges.map(edge => ({
            source: edge.source,
            target: edge.target,
            weight: edge.weight || 1,
            hyperlinks: edge.hyperlinks || []
        }));

        // Update graph data
        this.graphData = {
            nodes,
            edges: processedEdges,
            metadata
        };

        console.log(`Graph data updated: ${nodes.length} nodes, ${processedEdges.length} edges`);
        
        // Log sample of node positions
        console.log('Node positions sample:', 
            nodes.slice(0, 3).map(n => 
                `Node ${n.id}: (${n.x.toFixed(2)}, ${n.y.toFixed(2)}, ${n.z.toFixed(2)})`
            )
        );

        // Dispatch update event
        this.dispatchGraphUpdate();
    }

    dispatchGraphUpdate() {
        if (!this.graphData) return;

        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
            detail: {
                nodes: this.graphData.nodes,
                edges: this.graphData.edges,
                metadata: this.graphData.metadata
            }
        }));
    }

    getGraphData() {
        if (this.graphData) {
            console.log(`Returning graph data: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
            console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
        } else {
            console.warn('Graph data is null');
        }
        return {
            nodes: this.graphData?.nodes || [],
            edges: this.graphData?.edges || [],
            metadata: this.graphData?.metadata || {}
        };
    }

    isGraphDataValid() {
        return this.graphData && 
               Array.isArray(this.graphData.nodes) && 
               Array.isArray(this.graphData.edges) &&
               this.graphData.nodes.length > 0;
    }
}

----
components/App.vue
<template>
  <ErrorBoundary>
    <div id="app">
      <div id="scene-container" ref="sceneContainer">
        <canvas ref="canvas" />
        <GraphSystem 
          v-if="visualizationState.scene" 
          :visual-settings="visualSettings" 
        />
      </div>
      <ControlPanel />
      <div class="connection-status" :class="{ connected: isConnected }">
        WebSocket: {{ isConnected ? 'Connected' : 'Disconnected' }}
      </div>
      <div v-if="error" class="error-message">
        {{ error }}
      </div>
      <div v-if="process.env.NODE_ENV === 'development'" class="debug-info">
        Scene Status: {{ visualizationState.isInitialized ? 'Ready' : 'Initializing' }}
        <br />
        Nodes: {{ visualizationStore.nodes.length }}
        <br />
        Edges: {{ visualizationStore.edges.length }}
      </div>
    </div>
  </ErrorBoundary>
</template>

<script lang="ts">
import { defineComponent, onMounted, onErrorCaptured, ref, onBeforeUnmount, ComponentPublicInstance, watch, computed, provide } from 'vue'
import { storeToRefs } from 'pinia'
import { useSettingsStore } from '../stores/settings'
import { useVisualizationStore } from '../stores/visualization'
import { useWebSocketStore } from '../stores/websocket'
import { useBinaryUpdateStore } from '../stores/binaryUpdate'
import ControlPanel from '@components/ControlPanel.vue'
import ErrorBoundary from '@components/ErrorBoundary.vue'
import GraphSystem from '@components/visualization/GraphSystem.vue'
import { errorTracking } from '../services/errorTracking'
import { useVisualization, SCENE_KEY } from '../composables/useVisualization'
import { SERVER_MESSAGE_TYPES, MESSAGE_FIELDS, ENABLE_BINARY_DEBUG } from '../constants/websocket'
import type { BaseMessage, GraphUpdateMessage, ErrorMessage, Node, Edge, BinaryMessage } from '../types/websocket'
import type { GraphNode, GraphEdge, GraphData } from '../types/core'
import type { FisheyeConfig } from '../types/components'

export default defineComponent({
  name: 'App',
  components: {
    ControlPanel,
    ErrorBoundary,
    GraphSystem
  },
  setup() {
    const settingsStore = useSettingsStore()
    const visualizationStore = useVisualizationStore()
    const websocketStore = useWebSocketStore()
    const binaryUpdateStore = useBinaryUpdateStore()

    const { connected: isConnected } = storeToRefs(websocketStore)
    
    const sceneContainer = ref<HTMLElement | null>(null)
    const canvas = ref<HTMLCanvasElement | null>(null)
    const error = ref<string | null>(null)
    const isInitialDataRequested = ref(false)

    const visualSettings = computed(() => {
      const settings = settingsStore.getVisualizationSettings;
      console.debug('Visualization settings:', {
        material: {
          metalness: settings.material.node_material_metalness,
          roughness: settings.material.node_material_roughness,
          opacity: settings.material.node_material_opacity
        },
        nodeColors: {
          base: settings.node_color,
          core: settings.node_color_core
        },
        sizes: {
          min: settings.min_node_size,
          max: settings.max_node_size
        }
      });
      return settings;
    });

    const { initialize: initVisualization, updateNodes, updatePositions, state: visualizationState } = useVisualization()

    provide('visualizationState', visualizationState)

    const setupWebSocketHandlers = () => {
      if (!websocketStore.service) {
        console.error('WebSocket service not initialized');
        return;
      }

      websocketStore.service.on('open', () => {
        console.log('WebSocket connected');
        error.value = null;
        
        if (!isInitialDataRequested.value) {
          console.debug('Requesting initial graph data');
          websocketStore.service?.send({
            type: SERVER_MESSAGE_TYPES.INITIAL_DATA
          });
          isInitialDataRequested.value = true;
        }
      });

      websocketStore.service.on('close', () => {
        console.log('WebSocket disconnected');
        binaryUpdateStore.clear();
        isInitialDataRequested.value = false;
      });

      websocketStore.service.on('error', (err: ErrorMessage) => {
        console.error('WebSocket error:', err);
        error.value = err.message;
        errorTracking.trackError(new Error(err.message), {
          context: 'WebSocket Error',
          component: 'App'
        });
      });

      websocketStore.service.on('message', (message: BaseMessage) => {
        console.debug('Received message:', message);
        switch (message.type) {
          case SERVER_MESSAGE_TYPES.GRAPH_UPDATE:
            const graphMsg = message as GraphUpdateMessage;
            if (!graphMsg.graphData) {
              console.warn('Received graph update with no data');
              return;
            }

            console.log('Received graph update:', {
              nodes: graphMsg.graphData.nodes?.length || 0,
              edges: graphMsg.graphData.edges?.length || 0,
              metadata: graphMsg.graphData.metadata ? Object.keys(graphMsg.graphData.metadata).length : 0,
              sampleNode: graphMsg.graphData.nodes?.[0] ? {
                id: graphMsg.graphData.nodes[0].id,
                position: graphMsg.graphData.nodes[0].position
              } : null
            });
            
            visualizationStore.setGraphData(
              graphMsg.graphData.nodes,
              graphMsg.graphData.edges,
              graphMsg.graphData.metadata || {}
            );

            updateNodes(graphMsg.graphData.nodes);

            console.log('Graph data state after update:', {
              storeNodes: visualizationStore.nodes.length,
              storeEdges: visualizationStore.edges.length,
              graphData: visualizationStore.graphData ? {
                nodes: visualizationStore.graphData.nodes.length,
                edges: visualizationStore.graphData.edges.length
              } : null
            });
            break;

          case SERVER_MESSAGE_TYPES.SETTINGS_UPDATED:
            settingsStore.applyServerSettings(message.settings);
            break;

          case SERVER_MESSAGE_TYPES.POSITION_UPDATE_COMPLETE:
            console.debug('Position update completed:', message[MESSAGE_FIELDS.STATUS]);
            break;
        }
      });

      websocketStore.service.on('gpuPositions', (data: BinaryMessage) => {
        if (ENABLE_BINARY_DEBUG) {
          console.debug('Received GPU positions update:', {
            bufferSize: data.data.byteLength,
            nodeCount: visualizationStore.nodes.length
          });
        }

        binaryUpdateStore.updateFromBinary(data);

        const positions = binaryUpdateStore.getAllPositions;
        const velocities = binaryUpdateStore.getAllVelocities;
        const nodeCount = visualizationStore.nodes.length;

        updatePositions(positions, velocities, nodeCount);
      });
    };

    onMounted(async () => {
      try {
        settingsStore.applyServerSettings({});
        console.info('Settings initialized', {
          context: 'App Setup',
          settings: settingsStore.$state
        });

        if (canvas.value && sceneContainer.value) {
          console.log('Initializing visualization system...');
          
          const rect = sceneContainer.value.getBoundingClientRect();
          canvas.value.width = rect.width;
          canvas.value.height = rect.height;
          
          await initVisualization({
            canvas: canvas.value,
            scene: {
              antialias: true,
              alpha: true,
              preserveDrawingBuffer: true,
              powerPreference: 'high-performance'
            }
          });
          console.log('Visualization system initialized');

          if (visualizationState.value.scene) {
            provide(SCENE_KEY, visualizationState.value.scene);
          }
        }

        await websocketStore.initialize();
        setupWebSocketHandlers();

        console.info('Application initialized', {
          context: 'App Initialization',
          environment: process.env.NODE_ENV
        });

      } catch (err) {
        console.error('Error during App setup:', err);
        error.value = err instanceof Error ? err.message : 'Unknown error during setup';
        errorTracking.trackError(err, {
          context: 'App Setup',
          component: 'App'
        });
      }
    });

    onBeforeUnmount(() => {
      websocketStore.cleanup();
      binaryUpdateStore.clear();
    });

    onErrorCaptured((err, instance: ComponentPublicInstance | null, info) => {
      error.value = err instanceof Error ? err.message : 'An error occurred';
      errorTracking.trackError(err, {
        context: 'App Root Error',
        component: (instance as any)?.$options?.name || 'Unknown',
        additional: { info }
      });
      return false;
    });

    return {
      sceneContainer,
      canvas,
      isConnected,
      error,
      visualSettings,
      visualizationState,
      visualizationStore,
      process: {
        env: {
          NODE_ENV: process.env.NODE_ENV
        }
      }
    };
  }
});
</script>

<style>
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  background: #000000;
}

#scene-container {
  width: 100%;
  height: 100%;
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  background: #000000;
  touch-action: none;
}

#scene-container canvas {
  width: 100%;
  height: 100%;
  display: block;
}

#app {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
  pointer-events: none;
}

#app > * {
  pointer-events: auto;
}

.connection-status {
  position: fixed;
  top: 10px;
  right: 10px;
  padding: 5px 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: #ff4444;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
}

.connection-status.connected {
  color: #44ff44;
}

.error-message {
  position: fixed;
  top: 50px;
  right: 10px;
  padding: 10px;
  background-color: rgba(255, 0, 0, 0.8);
  color: white;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
  max-width: 300px;
  word-wrap: break-word;
}

.debug-info {
  position: fixed;
  top: 90px;
  right: 10px;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
  max-width: 300px;
  word-wrap: break-word;
}
</style>

----
components/ErrorMessage.vue
<template>
  <Transition name="fade">
    <div 
      v-if="error"
      class="error-message"
      @click="dismiss"
    >
      {{ error }}
    </div>
  </Transition>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted, onBeforeUnmount } from 'vue';

interface Props {
  message: string;
  duration: number;
  dismissible: boolean;
}

export default defineComponent({
  name: 'ErrorMessage',
  
  props: {
    message: {
      type: String,
      required: true
    },
    duration: {
      type: Number,
      default: 5000
    },
    dismissible: {
      type: Boolean,
      default: true
    }
  },

  emits: ['dismiss'],

  setup(props: Props, { emit }: { emit: (event: 'dismiss') => void }) {
    const error = ref<string | null>(props.message);
    let timeout: number | null = null;

    const dismiss = () => {
      if (props.dismissible) {
        error.value = null;
        emit('dismiss');
      }
    };

    onMounted(() => {
      if (props.duration > 0) {
        timeout = window.setTimeout(() => {
          error.value = null;
          emit('dismiss');
        }, props.duration);
      }
    });

    onBeforeUnmount(() => {
      if (timeout) {
        clearTimeout(timeout);
      }
    });

    return {
      error,
      dismiss
    };
  }
});
</script>

<style scoped>
.error-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(255, 0, 0, 0.85);
  color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  cursor: pointer;
  max-width: 80vw;
  text-align: center;
  font-weight: 500;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>

----
components/ControlPanel.vue
<template>
  <!-- Template remains unchanged -->
  <div id="control-panel" :class="{ hidden: isHidden }">
    <button class="toggle-button" @click="togglePanel">
      {{ isHidden ? 'Show Controls' : 'Hide Controls' }}
    </button>
    
    <div class="panel-content">
      <!-- Node Appearance -->
      <div v-for="group in controlGroups" :key="group.name" class="control-group">
        <div class="group-header" @click="toggleGroup(group.name)">
          <h3>{{ group.label }}</h3>
        </div>
        <div v-if="!collapsedGroups[group.name]" class="group-content">
          <div v-for="control in group.controls" :key="control.name" class="control-item">
            <label>{{ control.label }}</label>
            
            <!-- Color Input -->
            <template v-if="control.type === 'color'">
              <input type="color"
                     :value="control.value"
                     @input="($event: Event) => handleColorInput($event, group.name, control.name)">
            </template>
            
            <!-- Range Input -->
            <template v-if="control.type === 'range'">
              <input type="range"
                     :min="control.min"
                     :max="control.max"
                     :step="control.step"
                     :value="control.value"
                     @input="($event: Event) => handleRangeInput($event, group.name, control.name)">
              <span class="range-value">{{ typeof control.value === 'number' ? control.value.toFixed(2) : control.value }}</span>
            </template>
            
            <!-- Checkbox Input -->
            <template v-if="control.type === 'checkbox'">
              <input type="checkbox"
                     :value="control.value"
                     :checked="Boolean(control.value)"
                     @change="($event: Event) => handleCheckboxChange($event, group.name, control.name)">
            </template>
          </div>
        </div>
      </div>

      <!-- Save Settings Button -->
      <button class="save-button" 
              @click="saveSettings"
              :disabled="!hasUnsavedChanges || isSaving">
        {{ getSaveButtonText() }}
      </button>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useSettingsStore } from '../stores/settings';
import { useWebSocketStore } from '../stores/websocket';
import { useControlGroups } from '../composables/useControlGroups';
import { useControlSettings } from '../composables/useControlSettings';
import { SERVER_MESSAGE_TYPES, MESSAGE_FIELDS } from '../constants/websocket';
import type { ControlGroup } from '../types/components';
import type { SettingsUpdateMessage, MaterialSettings, BloomSettings, FisheyeSettings } from '../types/websocket';

export default defineComponent({
  name: 'ControlPanel',
  
  setup() {
    const settingsStore = useSettingsStore();
    const websocketStore = useWebSocketStore();
    const { collapsedGroups, toggleGroup } = useControlGroups();
    const { 
      createAppearanceGroup,
      createMaterialGroup,
      createPhysicsGroup,
      createBloomGroup,
      createEnvironmentGroup,
      createFisheyeGroup,
      handleControlChange
    } = useControlSettings();

    const isHidden = ref(false);
    const isSaving = ref(false);
    const { visualization, bloom, fisheye, isDirty: hasUnsavedChanges } = storeToRefs(settingsStore);

    // Map visualization settings to material settings
    const getMaterialSettings = computed((): Partial<MaterialSettings> => ({
      nodeSize: (visualization.value.min_node_size + visualization.value.max_node_size) / 2,
      nodeColor: visualization.value.node_color,
      edgeWidth: (visualization.value.edge_min_width + visualization.value.edge_max_width) / 2,
      edgeColor: visualization.value.edge_color,
      highlightColor: visualization.value.node_color_core,
      opacity: visualization.value.material.node_material_opacity
    }));

    // Compute control groups based on current settings
    const controlGroups = computed<ControlGroup[]>(() => [
      createAppearanceGroup(visualization.value),
      createMaterialGroup(visualization.value),
      createPhysicsGroup(visualization.value),
      createBloomGroup(bloom.value),
      createEnvironmentGroup(visualization.value),
      createFisheyeGroup(fisheye.value)
    ]);

    const togglePanel = () => {
      isHidden.value = !isHidden.value;
    };

    // Type-safe event handlers
    const handleColorInput = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, input.value);
    };

    const handleRangeInput = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, parseFloat(input.value));
    };

    const handleCheckboxChange = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, input.checked);
    };

    const getSaveButtonText = () => {
      if (isSaving.value) return 'Saving...';
      if (!hasUnsavedChanges.value) return 'No Changes';
      return 'Save Settings';
    };

    const saveSettings = async () => {
      if (!hasUnsavedChanges.value || isSaving.value) return;
      
      try {
        isSaving.value = true;
        
        // Prepare settings update message
        const updateMessage: SettingsUpdateMessage = {
          type: SERVER_MESSAGE_TYPES.UPDATE_SETTINGS,
          settings: {
            [MESSAGE_FIELDS.MATERIAL]: getMaterialSettings.value,
            [MESSAGE_FIELDS.BLOOM]: bloom.value,
            [MESSAGE_FIELDS.FISHEYE]: fisheye.value
          }
        };

        // Send settings through WebSocket
        websocketStore.send(updateMessage);
        
        // Mark settings as saved in store
        settingsStore.markSaved();
        
        console.debug('Settings update sent:', updateMessage);
      } catch (error) {
        console.error('Failed to save settings:', error);
      } finally {
        isSaving.value = false;
      }
    };

    onMounted(() => {
      console.debug('ControlPanel mounted, initial settings:', {
        material: getMaterialSettings.value,
        bloom: bloom.value,
        fisheye: fisheye.value
      });
    });

    return {
      isHidden,
      isSaving,
      collapsedGroups,
      controlGroups,
      hasUnsavedChanges,
      togglePanel,
      toggleGroup,
      handleColorInput,
      handleRangeInput,
      handleCheckboxChange,
      saveSettings,
      getSaveButtonText
    };
  }
});
</script>

<style scoped>
/* Styles remain unchanged */
#control-panel {
  position: fixed;
  top: 20px;
  right: 0;
  width: 300px;
  max-height: 90vh;
  background-color: rgba(20, 20, 20, 0.9);
  color: #ffffff;
  border-radius: 10px 0 0 10px;
  overflow-y: auto;
  z-index: 1000;
  transition: transform 0.3s ease-in-out;
  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
}

#control-panel.hidden {
  transform: translateX(calc(100% - 40px));
}

.toggle-button {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%) rotate(-90deg);
  transform-origin: left center;
  background-color: rgba(20, 20, 20, 0.9);
  color: #ffffff;
  border: none;
  padding: 8px 16px;
  cursor: pointer;
  border-radius: 5px 5px 0 0;
  font-size: 0.9em;
  white-space: nowrap;
  z-index: 1001;
}

.panel-content {
  padding: 20px;
}

.control-group {
  margin-bottom: 16px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  overflow: hidden;
}

.group-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background-color: rgba(255, 255, 255, 0.1);
  cursor: pointer;
}

.group-header h3 {
  margin: 0;
  font-size: 1em;
  font-weight: 500;
}

.group-content {
  padding: 12px;
}

.control-item {
  margin-bottom: 12px;
}

.control-item label {
  display: block;
  margin-bottom: 4px;
  font-size: 0.9em;
  color: #cccccc;
}

.control-item input[type="range"] {
  width: 100%;
  height: 6px;
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
  -webkit-appearance: none;
}

.control-item input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background-color: #ffffff;
  border-radius: 50%;
  cursor: pointer;
}

.control-item input[type="color"] {
  width: 100%;
  height: 30px;
  border: none;
  border-radius: 4px;
  background-color: transparent;
}

.range-value {
  float: right;
  font-size: 0.8em;
  color: #999999;
}

.save-button {
  width: 100%;
  padding: 12px;
  margin-top: 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s;
}

.save-button:hover:not(:disabled) {
  background-color: #218838;
}

.save-button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  opacity: 0.65;
}
</style>

----
components/ErrorBoundary.vue
<template>
  <div>
    <div v-if="error" class="error-boundary">
      <div class="error-content">
        <h3>Component Error</h3>
        <div class="error-message">{{ error.message }}</div>
        <div class="error-info">
          <div class="error-component">Component: {{ error.component }}</div>
          <div class="error-stack">{{ error.stack }}</div>
        </div>
        <button @click="handleError" class="retry-button">
          Retry
        </button>
      </div>
    </div>
    <slot v-else></slot>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, onErrorCaptured, ComponentPublicInstance } from 'vue'

export default defineComponent({
  name: 'ErrorBoundary',
  
  setup() {
    const error = ref<{
      message: string;
      component?: string;
      stack?: string;
    } | null>(null)

    onErrorCaptured((err, instance: ComponentPublicInstance | null, info) => {
      // Get component name
      const componentName = (instance as any)?.$options?.name || 'Unknown Component'
      
      // Format error for display
      error.value = {
        message: err.message || String(err),
        component: componentName,
        stack: err.stack
      }

      // Log to debug console
      console.error('Component Error:', {
        message: err.message,
        component: componentName,
        stack: err.stack,
        context: `Vue Component: ${componentName}`
      })

      // Prevent error from propagating
      return false
    })

    const handleError = () => {
      error.value = null
    }

    return {
      error,
      handleError
    }
  }
})
</script>

<style scoped>
.error-boundary {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.85);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.error-content {
  background-color: #2c3e50;
  padding: 20px;
  border-radius: 8px;
  max-width: 80%;
  max-height: 80%;
  overflow-y: auto;
  color: white;
  font-family: monospace;
}

.error-content h3 {
  color: #e74c3c;
  margin-top: 0;
}

.error-message {
  color: #f1c40f;
  margin: 10px 0;
  font-size: 16px;
}

.error-info {
  margin: 15px 0;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

.error-component {
  color: #3498db;
  margin-bottom: 8px;
}

.error-stack {
  color: #95a5a6;
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.retry-button {
  background-color: #2ecc71;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin-top: 15px;
}

.retry-button:hover {
  background-color: #27ae60;
}
</style>

----
components/chatManager.vue
<template>
  <div class="chat-manager">
    <div class="chat-messages" ref="messagesContainer">
      <div v-for="(message, index) in messages" :key="index" class="message">
        {{ message }}
      </div>
    </div>
    <div class="chat-input">
      <input
        v-model="chatInput"
        @keyup.enter="sendMessage"
        placeholder="Type your message..."
        :disabled="!websocketService"
      />
      <div class="button-group">
        <button @click="sendMessage" :disabled="!websocketService || !chatInput.trim()">
          Send
        </button>
        <button 
          @click="toggleTTS" 
          :disabled="!websocketService"
          :class="{ active: useOpenAI }"
          :title="useOpenAI ? 'Using OpenAI for TTS' : 'Using Sonata for TTS'"
        >
          TTS: {{ useOpenAI ? 'OpenAI' : 'Sonata' }}
        </button>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, PropType, onMounted, onBeforeUnmount, nextTick } from 'vue'
import type WebsocketService from '../services/websocketService'

export default defineComponent({
  name: 'ChatManager',
  
  props: {
    websocketService: {
      type: Object as PropType<WebsocketService>,
      required: true
    }
  },

  setup(props) {
    const chatInput = ref('')
    const messages = ref<string[]>([])
    const useOpenAI = ref(false)
    const messagesContainer = ref<HTMLElement | null>(null)

    const scrollToBottom = async () => {
      await nextTick()
      if (messagesContainer.value) {
        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
      }
    }

    const handleRagflowAnswer = (answer: string) => {
      messages.value.push(`AI: ${answer}`)
      scrollToBottom()
    }

    const handleOpenAIResponse = (response: string) => {
      messages.value.push(`OpenAI: ${response}`)
      scrollToBottom()
    }

    const sendMessage = () => {
      if (chatInput.value.trim()) {
        messages.value.push(`You: ${chatInput.value}`)
        props.websocketService.send({
          type: 'chatMessage',
          message: chatInput.value,
          useOpenAI: useOpenAI.value
        })
        chatInput.value = ''
        scrollToBottom()
      }
    }

    const toggleTTS = () => {
      useOpenAI.value = !useOpenAI.value
      props.websocketService.send({
        type: 'setTTSMethod',
        useOpenAI: useOpenAI.value
      })
      console.log(`TTS method set to: ${useOpenAI.value ? 'OpenAI' : 'Sonata'}`)
    }

    onMounted(() => {
      props.websocketService.on('ragflowAnswer', handleRagflowAnswer)
      props.websocketService.on('openaiResponse', handleOpenAIResponse)
    })

    onBeforeUnmount(() => {
      props.websocketService.off('ragflowAnswer', handleRagflowAnswer)
      props.websocketService.off('openaiResponse', handleOpenAIResponse)
    })

    return {
      chatInput,
      messages,
      useOpenAI,
      messagesContainer,
      sendMessage,
      toggleTTS
    }
  }
})
</script>

<style scoped>
.chat-manager {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 300px;
  height: 400px;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  padding: 10px;
  z-index: 1000;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.chat-messages {
  flex-grow: 1;
  overflow-y: auto;
  margin-bottom: 10px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

.message {
  margin: 8px 0;
  padding: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  color: #fff;
  word-wrap: break-word;
}

.chat-input {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.chat-input input {
  width: 100%;
  padding: 8px;
  border: none;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  font-size: 14px;
}

.chat-input input::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.chat-input input:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.15);
}

.button-group {
  display: flex;
  gap: 8px;
}

button {
  flex: 1;
  padding: 8px;
  border: none;
  border-radius: 4px;
  background: #2196f3;
  color: white;
  cursor: pointer;
  transition: background-color 0.2s;
}

button:hover:not(:disabled) {
  background: #1976d2;
}

button:disabled {
  background: #ccc;
  cursor: not-allowed;
  opacity: 0.7;
}

button.active {
  background: #4caf50;
}

button.active:hover:not(:disabled) {
  background: #388e3c;
}

/* Scrollbar styling */
.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
</style>

----
components/NodeInfoPanel.vue
<template>
  <div 
    v-if="nodeData"
    class="node-info-panel"
  >
    <h3>Node Information</h3>
    <p><strong>ID:</strong> {{ nodeData.id }}</p>
    <p v-if="nodeData.label"><strong>Name:</strong> {{ nodeData.label }}</p>
    <template v-if="nodeData.metadata">
      <div v-for="(value, key) in nodeData.metadata" :key="key" class="metadata-item">
        <strong>{{ formatKey(key) }}:</strong> {{ formatValue(value) }}
      </div>
    </template>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue';
import { useVisualizationStore } from '../stores/visualization';
import type { Node } from '../types/core';

export default defineComponent({
  name: 'NodeInfoPanel',
  
  setup() {
    const store = useVisualizationStore();
    
    const nodeData = computed(() => store.selectedNode);

    const formatKey = (key: string) => {
      return key
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    };

    const formatValue = (value: any) => {
      if (typeof value === 'object') {
        return JSON.stringify(value, null, 2);
      }
      return value;
    };

    return {
      nodeData,
      formatKey,
      formatValue
    };
  }
});
</script>

<style scoped>
.node-info-panel {
  position: absolute;
  top: 20px;
  left: 20px;
  width: 300px;
  max-height: 40vh;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  overflow-y: auto;
}

.metadata-item {
  margin: 5px 0;
}

h3 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 1.2em;
}

p {
  margin: 8px 0;
}

strong {
  font-weight: 600;
}
</style>

----
components/three/index.ts
import { defineComponent, h, onMounted, onBeforeUnmount, watch, ref, inject, type Ref } from 'vue'
import * as THREE from 'three'
import { SCENE_KEY } from '../../composables/useVisualization'

// Define our supported event types
type SupportedEventType = 'click' | 'pointerenter' | 'pointerleave' | 'pointerdown' | 'pointermove' | 'pointerup';

// Event handler setup
const setupEventHandlers = (
  mesh: THREE.Mesh,
  emit: (event: SupportedEventType, data: THREE.Event) => void
) => {
  // Map Vue events to Three.js events
  const handlers: Record<string, (event: THREE.Event) => void> = {
    'click': (event) => {
      debugLog('Mesh', 'Event: click', { id: mesh.id });
      emit('click', event);
    },
    'pointermove': (event) => {
      debugLog('Mesh', 'Event: pointermove', { id: mesh.id });
      emit('pointermove', event);
    },
    'pointerdown': (event) => {
      debugLog('Mesh', 'Event: pointerdown', { id: mesh.id });
      emit('pointerdown', event);
    },
    'pointerup': (event) => {
      debugLog('Mesh', 'Event: pointerup', { id: mesh.id });
      emit('pointerup', event);
    },
    'pointerover': (event) => {
      debugLog('Mesh', 'Event: pointerenter', { id: mesh.id });
      emit('pointerenter', event);
    },
    'pointerout': (event) => {
      debugLog('Mesh', 'Event: pointerleave', { id: mesh.id });
      emit('pointerleave', event);
    }
  };

  // Add event listeners
  Object.entries(handlers).forEach(([type, handler]) => {
    mesh.addEventListener(type as keyof THREE.Object3DEventMap, handler);
  });

  return () => {
    // Remove event listeners on cleanup
    Object.entries(handlers).forEach(([type, handler]) => {
      mesh.removeEventListener(type as keyof THREE.Object3DEventMap, handler);
    });
  };
};

// Debug logging helper
const debugLog = (component: string, action: string, details: any) => {
  console.debug(`[Three.js ${component}] ${action}:`, details);
};

// Helper to safely get fog properties
const getFogDetails = (fog: THREE.Fog | THREE.FogExp2 | null) => {
  if (!fog) return null;
  if (fog instanceof THREE.Fog) {
    return {
      type: 'Fog',
      near: fog.near,
      far: fog.far
    };
  }
  if (fog instanceof THREE.FogExp2) {
    return {
      type: 'FogExp2',
      density: fog.density
    };
  }
  return null;
};

// Provide/inject keys
const PARENT_KEY = Symbol('three-parent');
const GEOMETRY_REF = Symbol('geometry-ref');
const MATERIAL_REF = Symbol('material-ref');

// Basic Three.js component wrapper
export const Group = defineComponent({
  name: 'Group',
  setup(_, { slots }) {
    const group = new THREE.Group();
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;
    const scene = inject(SCENE_KEY, null) as THREE.Scene | null;
    
    debugLog('Group', 'Created', { id: group.id });
    
    onMounted(() => {
      if (parent) {
        parent.add(group);
      } else if (scene) {
        scene.add(group);
      }
      debugLog('Group', 'Mounted', { 
        id: group.id,
        parent: parent?.type || 'Scene',
        childCount: group.children.length
      });
    });

    onBeforeUnmount(() => {
      debugLog('Group', 'Disposing', { id: group.id });
      if (parent) {
        parent.remove(group);
      } else if (scene) {
        scene.remove(group);
      }
      group.clear();
    });

    return () => h('div', { provide: { [PARENT_KEY]: group } }, slots.default?.());
  }
});

export const Scene = defineComponent({
  name: 'Scene',
  props: {
    background: {
      type: [Number, String],
      default: 0x000000
    }
  },
  setup(props, { slots }) {
    // Create scene
    const scene = new THREE.Scene();
    
    // Set initial background
    scene.background = new THREE.Color(props.background);
    
    debugLog('Scene', 'Created', { 
      id: scene.id,
      background: scene.background instanceof THREE.Color ? scene.background.getHexString() : 'none'
    });

    // Watch for background changes
    watch(() => props.background, (newColor) => {
      scene.background = new THREE.Color(newColor);
      debugLog('Scene', 'Background updated', { 
        background: scene.background instanceof THREE.Color ? scene.background.getHexString() : 'none'
      });
    });

    // Clean up
    onBeforeUnmount(() => {
      debugLog('Scene', 'Disposing', { id: scene.id });
      scene.clear();
    });

    // Provide scene to child components
    return () => h('div', { provide: { [SCENE_KEY]: scene } }, slots.default?.());
  }
});

// Mesh component that wraps Three.js mesh
export const Mesh = defineComponent({
  name: 'Mesh',
  props: {
    position: {
      type: Object as () => THREE.Vector3,
      required: true
    },
    scale: {
      type: Object as () => { x: number; y: number; z: number },
      default: () => ({ x: 1, y: 1, z: 1 })
    }
  },
  emits: ['click', 'pointerenter', 'pointerleave', 'pointerdown', 'pointermove', 'pointerup'] as const,
  setup(props, { emit, slots }) {
    const mesh = new THREE.Mesh();
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;
    const scene = inject(SCENE_KEY, null) as THREE.Scene | null;
    let cleanup: (() => void) | null = null;

    if (!parent && !scene) {
      throw new Error('Mesh must be used within a Scene or Group component');
    }

    // Wait for geometry and material from child components
    const geometryRef = ref<THREE.BufferGeometry | null>(null);
    const materialRef = ref<THREE.Material | null>(null);

    // Update mesh when geometry or material change
    watch([geometryRef, materialRef], ([geometry, material]) => {
      if (geometry && material) {
        mesh.geometry = geometry;
        mesh.material = material;
        
        // Force geometry update
        geometry.attributes.position.needsUpdate = true;
        if (geometry.index) {
          geometry.index.needsUpdate = true;
        }
        
        // Force transform update
        mesh.updateMatrix();
        mesh.updateMatrixWorld(true);
        
        // Mark for render
        if (scene?.userData) {
          scene.userData.needsRender = true;
        }

        debugLog('Mesh', 'Updated geometry and material', {
          id: mesh.id,
          geometryType: geometry.type,
          materialType: material.type,
          vertices: geometry.attributes.position?.count,
          needsUpdate: geometry.attributes.position.needsUpdate
        });
      }
    }, { immediate: true });

    onMounted(() => {
      mesh.position.copy(props.position);
      mesh.scale.set(props.scale.x, props.scale.y, props.scale.z);
      
      if (parent) {
        parent.add(mesh);
      } else if (scene) {
        scene.add(mesh);
      }

      debugLog('Mesh', 'Added to scene', {
        id: mesh.id,
        position: mesh.position.toArray(),
        scale: [mesh.scale.x, mesh.scale.y, mesh.scale.z],
        parent: parent?.type || 'Scene',
        hasGeometry: !!mesh.geometry,
        hasMaterial: !!mesh.material
      });

      // Set up event handlers
      cleanup = setupEventHandlers(mesh, emit);
    });

    // Watch for prop changes
    watch(() => props.position, (newPos) => {
      mesh.position.copy(newPos);
      debugLog('Mesh', 'Position updated', {
        id: mesh.id,
        position: mesh.position.toArray()
      });
    });

    watch(() => props.scale, (newScale) => {
      mesh.scale.set(newScale.x, newScale.y, newScale.z);
      debugLog('Mesh', 'Scale updated', {
        id: mesh.id,
        scale: [mesh.scale.x, mesh.scale.y, mesh.scale.z]
      });
    });

    onBeforeUnmount(() => {
      // Clean up event handlers
      if (cleanup) {
        cleanup();
      }

      debugLog('Mesh', 'Removing from scene', {
        id: mesh.id,
        position: mesh.position.toArray()
      });
      if (parent) {
        parent.remove(mesh);
      } else if (scene) {
        scene.remove(mesh);
      }
      mesh.geometry?.dispose();
      if (Array.isArray(mesh.material)) {
        mesh.material.forEach(m => m.dispose());
      } else if (mesh.material) {
        mesh.material.dispose();
      }
    });

    // Provide mesh to child components and handle their setup
    return () => h('div', { 
      provide: { 
        [PARENT_KEY]: mesh,
        [GEOMETRY_REF]: geometryRef,
        [MATERIAL_REF]: materialRef
      } 
    }, slots.default?.());
  }
});

// Update SphereGeometry to connect with parent mesh
export const SphereGeometry = defineComponent({
  name: 'SphereGeometry',
  props: {
    args: {
      type: Array as unknown as () => [number, number, number],
      default: () => [1, 32, 32]
    }
  },
  setup(props) {
    const geometry = new THREE.SphereGeometry(...props.args);
    const geometryRef = inject<Ref<THREE.BufferGeometry | null>>(GEOMETRY_REF);
    
    if (geometryRef) {
      geometryRef.value = geometry;
    }
    
    debugLog('SphereGeometry', 'Created', {
      radius: props.args[0],
      segments: [props.args[1], props.args[2]],
      vertices: geometry.attributes.position.count
    });

    onBeforeUnmount(() => {
      if (geometryRef) {
        geometryRef.value = null;
      }
      debugLog('SphereGeometry', 'Disposing', {
        vertices: geometry.attributes.position.count
      });
      geometry.dispose();
    });

    return { geometry };
  }
});

// Update MeshStandardMaterial to connect with parent mesh
export const MeshStandardMaterial = defineComponent({
  name: 'MeshStandardMaterial',
  props: {
    color: {
      type: String,
      default: '#ffffff'
    },
    metalness: {
      type: Number,
      default: 0.1
    },
    roughness: {
      type: Number,
      default: 0.5
    },
    opacity: {
      type: Number,
      default: 1.0
    },
    transparent: {
      type: Boolean,
      default: false
    },
    emissive: {
      type: String,
      default: '#000000'
    },
    emissiveIntensity: {
      type: Number,
      default: 1.0
    }
  },
  setup(props) {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color(props.color),
      metalness: props.metalness,
      roughness: props.roughness,
      opacity: props.opacity,
      transparent: props.transparent,
      emissive: new THREE.Color(props.emissive),
      emissiveIntensity: props.emissiveIntensity
    });

    const materialRef = inject<Ref<THREE.Material | null>>(MATERIAL_REF);
    
    if (materialRef) {
      materialRef.value = material;
    }

    debugLog('MeshStandardMaterial', 'Created', {
      color: props.color,
      metalness: props.metalness,
      roughness: props.roughness,
      opacity: props.opacity,
      emissive: props.emissive,
      emissiveIntensity: props.emissiveIntensity
    });

    watch(() => props.color, (newColor) => {
      material.color.set(newColor);
      debugLog('MeshStandardMaterial', 'Color updated', { color: newColor });
    });

    watch(() => props.emissive, (newColor) => {
      material.emissive.set(newColor);
      debugLog('MeshStandardMaterial', 'Emissive updated', { emissive: newColor });
    });

    onBeforeUnmount(() => {
      if (materialRef) {
        materialRef.value = null;
      }
      debugLog('MeshStandardMaterial', 'Disposing', {
        color: material.color.getHexString(),
        emissive: material.emissive.getHexString()
      });
      material.dispose();
    });

    return { material };
  }
});

// Line component
export const Line = defineComponent({
  name: 'Line',
  props: {
    points: {
      type: Array as unknown as () => [THREE.Vector3, THREE.Vector3],
      required: true,
      validator: (value: unknown) => {
        if (!Array.isArray(value) || value.length !== 2) return false;
        return value.every(v => v instanceof THREE.Vector3);
      }
    },
    color: {
      type: String,
      default: '#ffffff'
    },
    linewidth: {
      type: Number,
      default: 1
    },
    opacity: {
      type: Number,
      default: 1
    },
    transparent: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const scene = inject(SCENE_KEY) as THREE.Scene | null;
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;

    if (!scene && !parent) {
      throw new Error('Line must be used within a Scene or Group component');
    }

    const geometry = new THREE.BufferGeometry().setFromPoints(props.points);
    const material = new THREE.LineBasicMaterial({
      color: props.color,
      linewidth: props.linewidth,
      opacity: props.opacity,
      transparent: props.transparent
    });
    const line = new THREE.Line(geometry, material);

    onMounted(() => {
      if (parent) {
        parent.add(line);
      } else if (scene) {
        scene.add(line);
      }

      debugLog('Line', 'Added to scene', {
        points: props.points.map(p => p.toArray()),
        color: props.color,
        linewidth: props.linewidth,
        opacity: props.opacity,
        parent: parent?.type || 'Scene'
      });
    });

    watch(() => props.points, (newPoints) => {
      geometry.setFromPoints(newPoints);
      geometry.attributes.position.needsUpdate = true;
      debugLog('Line', 'Points updated', {
        points: newPoints.map(p => p.toArray())
      });
    });

    onBeforeUnmount(() => {
      debugLog('Line', 'Removing from scene', {
        points: props.points.map(p => p.toArray())
      });
      if (parent) {
        parent.remove(line);
      } else if (scene) {
        scene.remove(line);
      }
      geometry.dispose();
      material.dispose();
    });

    return { line };
  }
});

// Html component for labels
export const Html = defineComponent({
  name: 'Html',
  props: {
    position: {
      type: Object as () => THREE.Vector3,
      required: true
    },
    occlude: {
      type: Boolean,
      default: true
    },
    center: {
      type: Boolean,
      default: true
    },
    sprite: {
      type: Boolean,
      default: false
    },
    style: {
      type: Object as () => Record<string, string>,
      default: () => ({})
    }
  },
  setup(props, { slots }) {
    const container = ref<HTMLDivElement | null>(null);

    onMounted(() => {
      if (container.value) {
        const pos = props.position;
        container.value.style.transform = `translate3d(${pos.x}px, ${pos.y}px, ${pos.z}px)`;
        Object.assign(container.value.style, props.style);
        
        if (props.center) {
          container.value.style.transform += ' translate(-50%, -50%)';
        }

        debugLog('Html', 'Mounted', {
          position: [pos.x, pos.y, pos.z],
          center: props.center,
          occlude: props.occlude,
          sprite: props.sprite
        });
      }
    });

    watch(() => props.position, (newPos) => {
      if (container.value) {
        container.value.style.transform = `translate3d(${newPos.x}px, ${newPos.y}px, ${newPos.z}px)`;
        if (props.center) {
          container.value.style.transform += ' translate(-50%, -50%)';
        }
        debugLog('Html', 'Position updated', {
          position: [newPos.x, newPos.y, newPos.z]
        });
      }
    });

    return () => h('div', {
      ref: container,
      class: 'html-overlay',
      style: {
        position: 'absolute',
        pointerEvents: 'none',
        ...props.style
      }
    }, slots.default?.());
  }
});

// Export all components
export default {
  Scene,
  Mesh,
  SphereGeometry,
  MeshStandardMaterial,
  Line,
  Html
};

----
components/vr/VRControlPanel.vue
<template>
  <!-- This is a 3D component, so no template needed -->
</template>

<script lang="ts">
import { defineComponent, onMounted, onBeforeUnmount, ref } from 'vue';
import * as THREE from 'three';
import { useVisualizationStore } from '../../stores/visualization';
import { useSettingsStore } from '../../stores/settings';
import type { VisualizationConfig } from '../../types/components';

interface Props {
  scene: THREE.Scene;
  camera: THREE.Camera;
}

interface ControlChange {
  name: string;
  value: number | string;
}

interface Control {
  group: THREE.Group;
  min?: number;
  max?: number;
  value: number | string;
}

export default defineComponent({
  name: 'VRControlPanel',

  props: {
    scene: {
      type: Object as () => THREE.Scene,
      required: true
    },
    camera: {
      type: Object as () => THREE.Camera,
      required: true
    }
  },

  emits: {
    controlChange: (payload: ControlChange) => true
  },

  setup(props: Props, { emit }: { emit: (event: 'controlChange', payload: ControlChange) => void }) {
    const panel = ref<THREE.Group>(new THREE.Group());
    const controls = ref<Map<string, Control>>(new Map());
    const visualizationStore = useVisualizationStore();
    const settingsStore = useSettingsStore();

    const createTextTexture = (text: string): THREE.CanvasTexture => {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (!context) throw new Error('Could not get 2D context');

      canvas.width = 256;
      canvas.height = 64;
      context.font = '48px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 128, 32);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    };

    const mapValue = (value: number, inMin: number, inMax: number, outMin: number, outMax: number): number => {
      return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    };

    const initPanel = () => {
      // Create background panel
      const panelGeometry = new THREE.PlaneGeometry(1, 1.5);
      const panelMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x202020, 
        transparent: true, 
        opacity: 0.7 
      });
      const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
      panel.value.add(panelMesh);

      // Position panel in front of camera
      panel.value.position.set(0, 0, -2);
      panel.value.lookAt(props.camera.position);

      props.scene.add(panel.value);
    };

    const createSlider = (name: string, min: number, max: number, value: number, y: number) => {
      const sliderGroup = new THREE.Group();
      sliderGroup.name = name;

      // Create slider track
      const trackGeometry = new THREE.PlaneGeometry(0.8, 0.05);
      const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x505050 });
      const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
      sliderGroup.add(trackMesh);

      // Create slider handle
      const handleGeometry = new THREE.SphereGeometry(0.03);
      const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
      handleMesh.position.x = mapValue(value, min, max, -0.4, 0.4);
      sliderGroup.add(handleMesh);

      // Create label
      const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
      const labelMaterial = new THREE.MeshBasicMaterial({ 
        map: createTextTexture(name) 
      });
      const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
      labelMesh.position.set(-0.6, 0, 0);
      sliderGroup.add(labelMesh);

      sliderGroup.position.set(0, y, 0.01);
      panel.value.add(sliderGroup);
      controls.value.set(name, { group: sliderGroup, min, max, value });
    };

    const createColorPicker = (name: string, value: string, y: number) => {
      const pickerGroup = new THREE.Group();
      pickerGroup.name = name;

      // Create color swatch
      const swatchGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const swatchMaterial = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color(value) 
      });
      const swatchMesh = new THREE.Mesh(swatchGeometry, swatchMaterial);
      pickerGroup.add(swatchMesh);

      // Create label
      const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
      const labelMaterial = new THREE.MeshBasicMaterial({ 
        map: createTextTexture(name) 
      });
      const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
      labelMesh.position.set(-0.3, 0, 0);
      pickerGroup.add(labelMesh);

      pickerGroup.position.set(0, y, 0.01);
      panel.value.add(pickerGroup);
      controls.value.set(name, { group: pickerGroup, value });
    };

    const updateControl = (name: string, value: number | string) => {
      const control = controls.value.get(name);
      if (!control) return;

      if ('min' in control && 'max' in control && typeof value === 'number') {
        // Slider
        const handle = control.group.children[1];
        handle.position.x = mapValue(value, control.min!, control.max!, -0.4, 0.4);
      } else if (typeof value === 'string') {
        // Color picker
        const swatch = control.group.children[0] as THREE.Mesh;
        if (swatch.material instanceof THREE.MeshBasicMaterial) {
          swatch.material.color.set(value);
        }
      }
      control.value = value;
    };

    const handleInteraction = (intersection: THREE.Intersection) => {
      const controlName = intersection.object.parent?.name;
      if (!controlName) return null;

      const control = controls.value.get(controlName);
      if (!control) return null;

      if ('min' in control && 'max' in control) {
        // Slider
        const newValue = mapValue(intersection.point.x, -0.4, 0.4, control.min!, control.max!);
        updateControl(controlName, newValue);
        emit('controlChange', { name: controlName, value: newValue });
        return { name: controlName, value: newValue };
      } else {
        // Color picker
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        const currentIndex = colors.indexOf(parseInt(control.value as string));
        const newValue = colors[(currentIndex + 1) % colors.length];
        const hexValue = '#' + newValue.toString(16).padStart(6, '0');
        updateControl(controlName, hexValue);
        emit('controlChange', { name: controlName, value: hexValue });
        return { name: controlName, value: hexValue };
      }
    };

    onMounted(() => {
      initPanel();

      // Initialize controls based on current settings
      const settings = settingsStore.getVisualizationSettings;
      let yPosition = 0.6;

      // Add sliders
      createSlider('Scale', 0.1, 2.0, settings.min_node_size, yPosition);
      yPosition -= 0.2;
      createSlider('Opacity', 0, 1, settings.material.node_material_opacity, yPosition);
      yPosition -= 0.2;

      // Add color pickers
      createColorPicker('Node Color', settings.node_color, yPosition);
      yPosition -= 0.2;
      createColorPicker('Edge Color', settings.edge_color, yPosition);
    });

    onBeforeUnmount(() => {
      // Cleanup Three.js objects
      controls.value.forEach((control: Control) => {
        control.group.traverse((obj: THREE.Object3D) => {
          if (obj instanceof THREE.Mesh) {
            obj.geometry.dispose();
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => m.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
      });

      if (panel.value.parent) {
        panel.value.parent.remove(panel.value);
      }
    });

    return {
      panel,
      controls,
      handleInteraction,
      updateControl
    };
  }
});
</script>

----
components/visualization/BaseVisualization.vue
<template>
  <Renderer
    :antialias="true"
    :xr="platformInfo.hasXRSupport"
    :size="{ w: windowSize.width, h: windowSize.height }"
    ref="renderer"
  >
    <Scene ref="scene">
      <!-- Camera System -->
      <Camera
        :position="cameraPosition"
        :fov="75"
        :aspect="aspect"
        :near="0.1"
        :far="1000"
        ref="camera"
      />

      <!-- Lighting -->
      <AmbientLight :intensity="1.5" />
      <DirectionalLight
        :position="{ x: 10, y: 20, z: 10 }"
        :intensity="2.0"
        :cast-shadow="true"
      />
      <HemisphereLight
        :sky-color="0xffffff"
        :ground-color="0x444444"
        :intensity="1.5"
      />

      <!-- Graph Visualization -->
      <graph-system
        v-if="graphData"
        :nodes="graphData.nodes"
        :edges="graphData.edges"
        :settings="visualSettings"
      />

      <!-- XR Controllers and Hands -->
      <template v-if="platformInfo.isQuest">
        <xr-controllers />
        <xr-hands />
      </template>

      <!-- Effects -->
      <effects-system :settings="effectsSettings">
        <bloom v-if="effectsSettings.bloom.enabled" v-bind="effectsSettings.bloom" />
        <ssao v-if="effectsSettings.ssao.enabled" v-bind="effectsSettings.ssao" />
      </effects-system>
    </Scene>
  </Renderer>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted, onBeforeUnmount } from 'vue';
import { useSettingsStore } from '../../stores/settings';
import { usePlatform } from '../../composables/usePlatform';
import type { GraphData } from '../../types/core';
import { WebGLRenderer, Scene as ThreeScene, PerspectiveCamera } from 'three';
import {
  Renderer,
  Scene,
  Camera,
  AmbientLight,
  DirectionalLight,
  HemisphereLight
} from 'vue-threejs';

export default defineComponent({
  name: 'BaseVisualization',

  components: {
    Renderer,
    Scene,
    Camera,
    AmbientLight,
    DirectionalLight,
    HemisphereLight
  },

  setup() {
    // Refs for Three.js components
    const renderer = ref<WebGLRenderer | null>(null);
    const scene = ref<ThreeScene | null>(null);
    const camera = ref<PerspectiveCamera | null>(null);

    // Platform and settings
    const { getPlatformInfo } = usePlatform();
    const settingsStore = useSettingsStore();
    const platformInfo = computed(() => getPlatformInfo());

    // Window size reactive state
    const windowSize = ref({
      width: window.innerWidth,
      height: window.innerHeight
    });
    const aspect = computed(() => windowSize.value.width / windowSize.value.height);

    // Camera position with reactive updates
    const cameraPosition = ref({ x: 0, y: 75, z: 200 });

    // Graph data
    const graphData = ref<GraphData | null>(null);

    // Settings from store
    const visualSettings = computed(() => settingsStore.getVisualizationSettings);
    const effectsSettings = computed(() => ({
      bloom: settingsStore.getBloomSettings,
      ssao: {
        enabled: false,
        radius: 0.5,
        intensity: 1.0,
        bias: 0.5
      }
    }));

    // Window resize handler
    const handleResize = () => {
      windowSize.value = {
        width: window.innerWidth,
        height: window.innerHeight
      };
    };

    // Lifecycle hooks
    onMounted(() => {
      window.addEventListener('resize', handleResize);
      
      // Initialize platform-specific features
      if (platformInfo.value.isQuest) {
        initializeXR();
      }
    });

    onBeforeUnmount(() => {
      window.removeEventListener('resize', handleResize);
    });

    // XR initialization
    const initializeXR = async () => {
      if (!renderer.value || !platformInfo.value.hasXRSupport) return;

      try {
        const session = await navigator.xr?.requestSession('immersive-vr', {
          requiredFeatures: ['local-floor', 'bounded-floor'],
          optionalFeatures: ['hand-tracking']
        });

        if (session && renderer.value.xr) {
          await renderer.value.xr.setSession(session);
        }
      } catch (error) {
        console.error('Failed to initialize XR:', error);
      }
    };

    // Public methods
    const updateGraphData = (data: GraphData) => {
      graphData.value = data;
    };

    return {
      // Template refs
      renderer,
      scene,
      camera,

      // Computed properties
      platformInfo,
      windowSize,
      aspect,
      cameraPosition,
      graphData,
      visualSettings,
      effectsSettings,

      // Methods
      updateGraphData
    };
  }
});
</script>

<style scoped>
.renderer-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
</style>

----
components/visualization/GraphSystem.vue
<template>
  <div v-if="isReady && graphData">
    <!-- Graph Content -->
    <primitive :object="graphGroup" />
    <div v-if="process.env.NODE_ENV === 'development'" class="debug-info">
      Nodes: {{ graphData.nodes.length }} | Edges: {{ graphData.edges.length }}
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, watch, onMounted, inject } from 'vue';
import { Vector3, Vector2, Plane, Raycaster } from 'three';
import { useGraphSystem } from '../../composables/useGraphSystem';
import { useWebSocketStore } from '../../stores/websocket';
import { useBinaryUpdateStore } from '../../stores/binaryUpdate';
import { useVisualizationStore } from '../../stores/visualization';
import { useVisualization } from '../../composables/useVisualization';
import { usePlatform } from '../../composables/usePlatform';
import type { VisualizationConfig } from '../../types/components';
import type { GraphNode, GraphEdge, GraphData, CoreState } from '../../types/core';

export default defineComponent({
  name: 'GraphSystem',

  props: {
    visualSettings: {
      type: Object as () => VisualizationConfig,
      required: true
    }
  },

  setup(props) {
    // Get visualization state and composable
    const visualizationState = inject<{ value: CoreState }>('visualizationState');
    const visualization = useVisualization();
    
    const isReady = computed(() => {
      const ready = visualizationState?.value.scene != null && 
             visualizationState?.value.isInitialized === true;
      console.debug('Graph system ready state:', {
        hasScene: visualizationState?.value.scene != null,
        isInitialized: visualizationState?.value.isInitialized,
        ready,
        timestamp: new Date().toISOString()
      });
      return ready;
    });

    // Get platform info
    const { 
      getPlatformInfo, 
      enableVR, 
      enableAR, 
      disableXR,
      isXRActive,
      isVRActive,
      isARActive 
    } = usePlatform();
    
    const platformInfo = getPlatformInfo();

    // Initialize graph system
    const {
      graphGroup,
      hoveredNode,
      getNodePosition,
      getNodeScale,
      getNodeColor,
      getEdgePoints,
      getEdgeColor,
      getEdgeWidth,
      handleNodeClick,
      handleNodeHover,
      updateGraphData,
      updateNodePosition
    } = useGraphSystem();

    const websocketStore = useWebSocketStore();
    const binaryUpdateStore = useBinaryUpdateStore();
    const visualizationStore = useVisualizationStore();
    
    // Drag state
    const isDragging = ref(false);
    const draggedNode = ref<GraphNode | null>(null);
    const dragStartPosition = ref<Vector3 | null>(null);
    const dragPlane = ref<Plane | null>(null);
    const dragIntersection = new Vector3();

    // Graph data from store with enhanced debug logging
    const graphData = computed<GraphData>(() => {
      const data = visualizationStore.getGraphData || { nodes: [], edges: [], metadata: {} };
      console.debug('Graph data computed:', {
        nodes: data.nodes.length,
        edges: data.edges.length,
        hasMetadata: Object.keys(data.metadata || {}).length > 0,
        sampleNodes: data.nodes.slice(0, 3).map(n => ({
          id: n.id,
          hasPosition: !!n.position,
          edgeCount: n.edges?.length || 0
        })),
        timestamp: new Date().toISOString()
      });
      return data;
    });

    // Watch for ready state and request initial data
    watch(isReady, (ready) => {
      if (ready && !websocketStore.initialDataRequested) {
        console.debug('Graph system ready, requesting initial data');
        websocketStore.requestInitialData();
      }
    });

    // Watch for graph data changes with enhanced logging
    watch(() => graphData.value, (newData) => {
      if (newData && newData.nodes.length > 0) {
        console.debug('Graph data changed:', {
          nodes: newData.nodes.length,
          edges: newData.edges.length,
          sampleNode: newData.nodes[0] ? {
            id: newData.nodes[0].id,
            hasPosition: !!newData.nodes[0].position,
            edgeCount: newData.nodes[0].edges?.length || 0
          } : null,
          timestamp: new Date().toISOString()
        });
        
        // Use mergeGraphData to preserve client-side positions
        visualizationStore.mergeGraphData(newData);
        
        // Update graph system with merged data
        const graphDataToUpdate = visualizationStore.getGraphData || { nodes: [], edges: [], metadata: {} };
        updateGraphData(graphDataToUpdate);
        
        // Trigger layout update if needed
        visualization.updateLayoutPositions();
      }
    }, { deep: true });

    // Watch for binary updates with enhanced logging
    watch(() => binaryUpdateStore.getAllPositions, (positions) => {
      const nodeCount = positions.length / 3;
      if (nodeCount > 0 && !visualization.isInteracting.value) {
        console.debug('Processing binary position update:', {
          nodeCount,
          timestamp: new Date().toISOString()
        });
        
        // Update node positions using array indices
        graphData.value.nodes.forEach((node, index) => {
          const position = binaryUpdateStore.getNodePosition(index);
          const velocity = binaryUpdateStore.getNodeVelocity(index);
          
          if (position && velocity) {
            // Create Vector3 objects for position and velocity
            const pos = new Vector3(position[0], position[1], position[2]);
            const vel = new Vector3(velocity[0], velocity[1], velocity[2]);
            
            // Update both the graph system and the node data
            updateNodePosition(node.id, pos, vel);
            node.position = position;
            node.velocity = velocity;
          }
        });

        // Trigger graph update
        if (visualizationState?.value.scene) {
          visualizationState.value.scene.userData.needsRender = true;
        }
      }
    }, { deep: true });

    // Drag handlers with enhanced logging
    const onDragStart = (event: PointerEvent, node: GraphNode) => {
      console.debug('Starting node drag:', {
        nodeId: node.id,
        initialPosition: getNodePosition(node),
        timestamp: new Date().toISOString()
      });

      isDragging.value = true;
      draggedNode.value = node;

      const camera = visualizationState?.value.camera;
      if (!camera) return;

      const normal = new Vector3(0, 0, 1);
      normal.applyQuaternion(camera.quaternion);
      dragPlane.value = new Plane(normal, 0);
      dragStartPosition.value = getNodePosition(node).clone();

      // Start local force simulation
      visualization.startInteraction();

      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
      }
    };

    const onDragMove = (event: PointerEvent) => {
      if (!isDragging.value || !draggedNode.value || !dragPlane.value) return;

      const camera = visualizationState?.value.camera;
      if (!camera) return;

      const target = event.currentTarget as HTMLElement;
      const rect = target.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      const raycaster = new Raycaster();
      const pointer = new Vector2(x, y);
      raycaster.setFromCamera(pointer, camera);

      if (raycaster.ray.intersectPlane(dragPlane.value, dragIntersection)) {
        const node = draggedNode.value;
        const position = getNodePosition(node);
        position.copy(dragIntersection);

        // Update node position in visualization store
        visualizationStore.updateNode(node.id, {
          position: [position.x, position.y, position.z]
        });

        // Trigger layout update
        visualization.updateLayoutPositions();

        if (visualizationState?.value.scene) {
          visualizationState.value.scene.userData.needsRender = true;
        }
      }
    };

    const onDragEnd = () => {
      if (!isDragging.value || !draggedNode.value || !dragStartPosition.value) return;

      const finalPosition = getNodePosition(draggedNode.value);

      console.debug('Node drag ended:', {
        nodeId: draggedNode.value.id,
        startPosition: dragStartPosition.value.toArray(),
        finalPosition: finalPosition.toArray(),
        timestamp: new Date().toISOString()
      });

      // End local force simulation
      visualization.endInteraction();

      isDragging.value = false;
      draggedNode.value = null;
      dragStartPosition.value = null;
      dragPlane.value = null;

      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
      }
    };

    // XR handlers
    const handleEnableAR = async () => {
      try {
        if (isARActive()) {
          await disableXR();
        } else {
          await enableAR();
        }
      } catch (err) {
        console.error('Failed to toggle AR:', err);
      }
    };

    const handleEnableVR = async () => {
      try {
        if (isVRActive()) {
          await disableXR();
        } else {
          await enableVR();
        }
      } catch (err) {
        console.error('Failed to toggle VR:', err);
      }
    };

    // Update graph data when component mounts
    onMounted(() => {
      console.debug('GraphSystem mounted, initialization state:', {
        isReady: isReady.value,
        hasGraphData: !!graphData.value,
        initialDataRequested: websocketStore.initialDataRequested,
        timestamp: new Date().toISOString()
      });
      
      if (graphData.value) {
        console.debug('Initial graph data update:', {
          nodes: graphData.value.nodes.length,
          edges: graphData.value.edges.length,
          timestamp: new Date().toISOString()
        });
        updateGraphData(graphData.value);
      }
    });

    return {
      isReady,
      platformInfo,
      isXRActive,
      isVRActive,
      isARActive,
      enableAR: handleEnableAR,
      enableVR: handleEnableVR,
      graphGroup,
      hoveredNode,
      isDragging,
      graphData,
      onDragStart,
      onDragMove,
      onDragEnd,
      process: {
        env: {
          NODE_ENV: process.env.NODE_ENV
        }
      }
    };
  }
});
</script>

<style scoped>
.debug-info {
  position: fixed;
  top: 40px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 5px 10px;
  border-radius: 4px;
  font-family: monospace;
  font-size: 12px;
  z-index: 1000;
}

.xr-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 10px;
  z-index: 1000;
}

.ar-button,
.vr-button {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.2s;
}

.ar-button {
  background: #4CAF50;
  color: white;
}

.ar-button:hover:not(:disabled) {
  background: #45a049;
}

.vr-button {
  background: #2196F3;
  color: white;
}

.vr-button:hover:not(:disabled) {
  background: #1976D2;
}

.ar-button:disabled,
.vr-button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  opacity: 0.65;
}
</style>

----
visualization/effects.js
import * as THREE from 'three';
import { BloomEffect } from './effects/BloomEffect.js';
import { CompositionEffect } from './effects/CompositionEffect.js';
import { LAYERS } from './layerManager.js';
import { visualizationSettings } from '../services/visualizationSettings.js';

export class EffectsManager {
    constructor(scene, camera, renderer) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to EffectsManager');
        }
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Store original renderer settings
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();
        this.originalAutoClear = this.renderer.autoClear;
        
        // Configure renderer for optimal performance
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        // Initialize effects
        this.bloomEffect = null;
        this.compositionEffect = null;
        this.initialized = false;
        this.pendingInitialization = true;
        
        // XR properties
        this.isXRActive = false;
        
        // Bind methods
        this.render = this.render.bind(this);
        this.handleResize = this.handleResize.bind(this);
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.dispose = this.dispose.bind(this);
        
        // Add event listeners
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }
    
    async initPostProcessing(isXR = false) {
        try {
            console.log('Starting post-processing initialization');
            if (!this.renderer || !this.renderer.domElement) {
                throw new Error('Renderer not ready for post-processing initialization');
            }

            // Wait for settings if needed
            if (this.pendingInitialization) {
                console.log('Waiting for settings before initializing effects...');
                return false;
            }

            // Clean up existing effects if reinitializing
            if (this.initialized) {
                this.dispose();
            }

            // Configure renderer
            this.renderer.autoClear = true;
            this.isXRActive = isXR;

            // Get settings from server
            const settings = visualizationSettings.getSettings();
            if (!settings?.bloom) {
                console.error('Bloom settings not available from server');
                return false;
            }

            // Initialize bloom effect with server settings
            this.bloomEffect = new BloomEffect(this.renderer, this.scene, this.camera);
            await this.bloomEffect.init(settings.bloom);

            // Initialize composition effect
            this.compositionEffect = new CompositionEffect(this.renderer);
            await this.compositionEffect.init(this.bloomEffect.getRenderTargets());
            
            this.initialized = true;
            console.log('Post-processing initialization complete with server settings');
            return true;
        } catch (error) {
            console.error('Error in post-processing initialization:', error);
            this.dispose();
            return false;
        }
    }

    handleXRSessionStart() {
        console.log('XR session started');
        this.isXRActive = true;
        if (this.initialized) {
            // Reinitialize effects for XR
            this.initPostProcessing(true);
        }
    }

    handleXRSessionEnd() {
        console.log('XR session ended');
        this.isXRActive = false;
        if (this.initialized) {
            // Reinitialize effects for non-XR
            this.initPostProcessing(false);
        }
    }
    
    render() {
        if (!this.initialized) {
            // Fallback to direct rendering if effects aren't initialized
            this.renderer.render(this.scene, this.camera);
            return;
        }

        try {
            const currentCamera = this.isXRActive ? this.renderer.xr.getCamera() : this.camera;
            
            // Render bloom passes
            if (this.bloomEffect) {
                this.bloomEffect.render(currentCamera);
            }

            // Render final composition
            if (this.compositionEffect) {
                const baseTexture = this.bloomEffect.getRenderTargets().get('base').texture;
                this.compositionEffect.render(baseTexture);
            }
        } catch (error) {
            console.error('Error during rendering:', error);
            // Fallback to direct rendering on error
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    handleResize(width = window.innerWidth, height = window.innerHeight) {
        if (!this.initialized) return;

        try {
            // Update renderer size
            this.renderer.setSize(width, height);

            // Update effect sizes
            if (this.bloomEffect) {
                this.bloomEffect.resize(width, height);
            }
            if (this.compositionEffect) {
                this.compositionEffect.resize(width, height);
            }
        } catch (error) {
            console.error('Error handling resize:', error);
        }
    }
    
    handleSettingsUpdate(event) {
        console.log('Received settings update:', event.detail);

        // If waiting for initial settings, initialize
        if (this.pendingInitialization) {
            this.pendingInitialization = false;
            this.initPostProcessing(this.isXRActive);
            return;
        }

        // Update existing effects with new settings
        if (!this.initialized) return;

        try {
            const settings = event.detail;
            
            if (settings.bloom && this.bloomEffect) {
                this.bloomEffect.updateSettings(settings.bloom);
                if (this.compositionEffect) {
                    this.compositionEffect.updateSettings(this.bloomEffect.getRenderTargets());
                }
            }

            if (settings.visualization?.material && this.bloomEffect) {
                this.bloomEffect.updateMaterialSettings(settings.visualization.material);
            }
        } catch (error) {
            console.error('Error handling settings update:', error);
        }
    }
    
    dispose() {
        // Remove event listeners
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);
        
        // Dispose effects
        if (this.bloomEffect) {
            this.bloomEffect.dispose();
            this.bloomEffect = null;
        }
        
        if (this.compositionEffect) {
            this.compositionEffect.dispose();
            this.compositionEffect = null;
        }
        
        // Restore renderer settings
        if (this.renderer) {
            this.renderer.autoClear = this.originalAutoClear;
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        this.initialized = false;
        this.isXRActive = false;
    }

    isInitialized() {
        return this.initialized;
    }

    isXREnabled() {
        return this.isXRActive;
    }
}

----
visualization/layout.js
export class LayoutManager {
    constructor(settings = {}) {
        // Configuration
        this.initialIterations = settings.iterations || 250;
        this.updateIterations = 1;       // Single iteration for smooth continuous updates
        this.targetRadius = 200;
        this.naturalLength = 100;
        this.attraction = settings.attraction_strength || 0.01;
        this.repulsion = settings.repulsion_strength || 1000;
        this.spring = settings.spring_strength || 0.1;
        this.damping = settings.damping || 0.8;
        
        // State
        this.isInitialized = false;
        this.isSimulating = false;
        this.animationFrameId = null;
        this.lastPositions = null;       // Store previous positions for change detection
        this.updateThreshold = 0.001;    // Minimum position change to trigger update
        this.lastUpdateTime = 0;         // Last time positions were sent to server
        this.updateInterval = 16.67;     // Exactly 60fps
        this.positionBuffer = null;
        this.edges = [];                 // Store computed edges
        this.nodeCount = 0;              // Track number of nodes
        this.waitingForInitialData = true; // Wait for initial data before sending updates
    }

    initializePositions(nodes) {
        console.log('Initializing positions for nodes:', nodes);
        this.nodeCount = nodes.length;
        nodes.forEach(node => {
            // Initialize only if positions are invalid
            if (isNaN(node.x) || isNaN(node.y) || isNaN(node.z)) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = this.targetRadius * Math.cbrt(Math.random());
                
                node.x = r * Math.sin(phi) * Math.cos(theta);
                node.y = r * Math.sin(phi) * Math.sin(theta);
                node.z = r * Math.cos(phi);
            }
            // Always ensure velocities are initialized
            if (!node.vx) node.vx = 0;
            if (!node.vy) node.vy = 0;
            if (!node.vz) node.vz = 0;
        });

        // Initialize last positions with velocities
        this.lastPositions = nodes.map(node => ({
            x: node.x,
            y: node.y,
            z: node.z,
            vx: node.vx,
            vy: node.vy,
            vz: node.vz
        }));

        this.isInitialized = true;
        this.waitingForInitialData = false; // Initial data received
        console.log('Position initialization complete');

        // Send initial positions to server
        this.sendPositionUpdates(nodes, true);
    }

    applyForceDirectedLayout(nodes, edges) {
        if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
            console.warn('Invalid nodes array provided to force-directed layout');
            return;
        }

        if (!this.isInitialized || this.waitingForInitialData) {
            console.warn('Layout manager not initialized or waiting for initial data');
            return;
        }

        console.log('Applying force-directed layout to', nodes.length, 'nodes');
        const dt = 0.1;

        // Apply forces based on edges (topic counts)
        edges.forEach(edge => {
            const sourceNode = nodes.find(n => n.id === edge.source);
            const targetNode = nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                // Calculate spring force based on topic counts
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dz = targetNode.z - sourceNode.z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) return;

                // Use edge weight (from topic counts) to scale the force
                const force = (distance - this.naturalLength) * this.spring * (edge.weight || 1);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                // Apply forces to both nodes
                sourceNode.vx += fx * this.attraction;
                sourceNode.vy += fy * this.attraction;
                sourceNode.vz += fz * this.attraction;
                targetNode.vx -= fx * this.attraction;
                targetNode.vy -= fy * this.attraction;
                targetNode.vz -= fz * this.attraction;
            }
        });

        // Apply repulsion between all nodes
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dz = nodes[j].z - nodes[i].z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) continue;

                const force = this.repulsion / (distance * distance);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                nodes[i].vx -= fx;
                nodes[i].vy -= fy;
                nodes[i].vz -= fz;
                nodes[j].vx += fx;
                nodes[j].vy += fy;
                nodes[j].vz += fz;
            }
        }

        // Update positions and apply damping
        nodes.forEach(node => {
            // Apply current velocity
            node.x += node.vx * dt;
            node.y += node.vy * dt;
            node.z += node.vz * dt;

            // Apply damping
            node.vx *= this.damping;
            node.vy *= this.damping;
            node.vz *= this.damping;

            // Bound checking
            const bound = 500;
            if (Math.abs(node.x) > bound) node.vx *= -0.5;
            if (Math.abs(node.y) > bound) node.vy *= -0.5;
            if (Math.abs(node.z) > bound) node.vz *= -0.5;
        });
    }

    updateFeature(control, value) {
        console.log(`Updating layout feature: ${control} = ${value}`);
        
        // Convert from forceDirected prefixed names to internal parameter names
        const paramMap = {
            'forceDirectedIterations': 'iterations',
            'forceDirectedSpring': 'spring_strength',
            'forceDirectedRepulsion': 'repulsion_strength',
            'forceDirectedAttraction': 'attraction_strength',
            'forceDirectedDamping': 'damping'
        };

        const paramName = paramMap[control] || control;
        switch(paramName) {
            case 'iterations':
                this.initialIterations = value;
                break;
            case 'spring_strength':
                this.spring = value;
                break;
            case 'repulsion_strength':
                this.repulsion = value;
                break;
            case 'attraction_strength':
                this.attraction = value;
                break;
            case 'damping':
                this.damping = value;
                break;
            default:
                console.warn(`Unknown layout parameter: ${control}`);
        }
    }

    updatePhysics(settings) {
        console.log('Updating physics settings:', settings);
        
        // Update all physics parameters at once
        if (settings.iterations !== undefined) {
            this.initialIterations = settings.iterations;
        }
        if (settings.spring_strength !== undefined) {
            this.spring = settings.spring_strength;
        }
        if (settings.repulsion_strength !== undefined) {
            this.repulsion = settings.repulsion_strength;
        }
        if (settings.attraction_strength !== undefined) {
            this.attraction = settings.attraction_strength;
        }
        if (settings.damping !== undefined) {
            this.damping = settings.damping;
        }

        // If simulation is running, apply new settings immediately
        if (this.isSimulating) {
            console.log('Applying new physics settings to running simulation');
        }
    }

    performLayout(graphData) {
        if (!this.isInitialized || !graphData || this.waitingForInitialData) {
            console.warn('Cannot perform layout: not initialized, no graph data, or waiting for initial data');
            return;
        }

        const now = Date.now();
        if (now - this.lastUpdateTime >= this.updateInterval) {
            // Apply force-directed layout
            this.applyForceDirectedLayout(graphData.nodes, graphData.edges);
            
            // Send position updates
            this.sendPositionUpdates(graphData.nodes, false);
            this.lastUpdateTime = now;
        }
    }

    sendPositionUpdates(nodes, isInitialLayout = false) {
        if (!this.lastPositions || !this.isInitialized || nodes.length !== this.nodeCount || this.waitingForInitialData) {
            console.warn('Cannot send position updates: not initialized, node count mismatch, or waiting for initial data');
            return;
        }

        // Create binary buffer for all node positions and velocities (24 bytes per node)
        const buffer = new ArrayBuffer(nodes.length * 24 + 4); // Extra 4 bytes for is_initial_layout flag
        const dataView = new Float32Array(buffer);
        let hasChanges = false;

        // Set is_initial_layout flag (1.0 for true, 0.0 for false)
        dataView[0] = isInitialLayout ? 1.0 : 0.0;

        nodes.forEach((node, index) => {
            const offset = index * 6 + 1; // +1 to account for is_initial_layout flag
            const lastPos = this.lastPositions[index];

            if (!lastPos || 
                Math.abs(node.x - lastPos.x) > this.updateThreshold ||
                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
                Math.abs(node.z - lastPos.z) > this.updateThreshold ||
                Math.abs(node.vx - lastPos.vx) > this.updateThreshold ||
                Math.abs(node.vy - lastPos.vy) > this.updateThreshold ||
                Math.abs(node.vz - lastPos.vz) > this.updateThreshold) {
                
                hasChanges = true;
                
                // Update last position and velocity
                if (lastPos) {
                    lastPos.x = node.x;
                    lastPos.y = node.y;
                    lastPos.z = node.z;
                    lastPos.vx = node.vx;
                    lastPos.vy = node.vy;
                    lastPos.vz = node.vz;
                }

                // Position (vec3<f32>)
                dataView[offset] = node.x;
                dataView[offset + 1] = node.y;
                dataView[offset + 2] = node.z;

                // Velocity (vec3<f32>)
                dataView[offset + 3] = node.vx || 0;
                dataView[offset + 4] = node.vy || 0;
                dataView[offset + 5] = node.vz || 0;
            }
        });

        if (hasChanges || isInitialLayout) {
            // Log the buffer size before sending
            console.log(`Sending position update buffer of size: ${buffer.byteLength} bytes for ${nodes.length} nodes (isInitialLayout: ${isInitialLayout})`);
            
            // Dispatch binary data event
            window.dispatchEvent(new CustomEvent('positionUpdate', {
                detail: buffer
            }));
        }
    }

    startContinuousSimulation(graphData) {
        if (this.isSimulating) return;
        
        console.log('Starting continuous simulation');
        this.isSimulating = true;
        const animate = () => {
            if (!this.isSimulating) return;
            
            // Send position updates at regular intervals
            this.performLayout(graphData);
            this.animationFrameId = requestAnimationFrame(animate);
        };
        
        animate();
    }

    stopSimulation() {
        console.log('Stopping simulation');
        this.isSimulating = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
}

----
visualization/nodes.js
import * as THREE from 'three';
import { visualizationSettings } from '../services/visualizationSettings.js';
import { LAYERS, LAYER_GROUPS, LayerManager } from './layerManager.js';
import { TextRenderer } from './textRenderer.js';

/**
 * NodeManager handles the efficient rendering and updating of nodes and edges in the graph visualization.
 * It uses THREE.js InstancedMesh for performance and supports both regular updates and binary position updates.
 */
export class NodeManager {
    constructor(scene, camera, settings = {}) {
        // Core references
        this.scene = scene;
        this.camera = camera;
        
        // Data structures
        this.nodeData = new Map();          // Stores node data
        this.labelPool = new Map();         // Reusable label sprites
        this.instanceIds = new Map();       // Maps positions to node IDs
        
        // Rendering structures
        this.nodeInstancedMeshes = null;    // Different LOD meshes for nodes
        this.edgeInstancedMesh = null;      // Single mesh for all edges
        this.instancedContainer = null;      // Container for all instanced meshes
        
        // Binary update optimization
        this.instancePositions = new Float32Array(30000);  // Pre-allocated for position updates
        this.instanceSizes = new Float32Array(10000);      // Pre-allocated for size updates
        this._labelUpdateTimeout = null;                   // For throttling label updates
        
        // Reusable objects for matrix operations
        this.matrix = new THREE.Matrix4();
        this.quaternion = new THREE.Quaternion();
        this.position = new THREE.Vector3();
        this.scale = new THREE.Vector3();
        this.color = new THREE.Color();

        // Text renderer for labels
        this.textRenderer = new TextRenderer();
        
        // Initialize settings
        this.initializeSettings(settings);
        
        // Create container and initialize meshes
        this.instancedContainer = new THREE.Group();
        this.instancedContainer.name = 'instancedContainer';
        this.scene.add(this.instancedContainer);
        
        // Initialize instanced meshes
        this.initInstancedMeshes();
        
        // Set up label rendering
        this.initializeLabelRenderer();
        
        // Bind methods
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.updateNodePositions = this.updateNodePositions.bind(this);
        
        // Add event listeners
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
    }

    /**
     * Creates or updates a label for a node
     */
    createNodeLabel(nodeId, node) {
        let label = this.labelPool.get(nodeId);
        
        // Create label text with metadata
        let labelText = node.label || nodeId;
        if (node.metadata && Object.keys(node.metadata).length > 0) {
            labelText += '\n' + Object.entries(node.metadata)
                .map(([key, value]) => `${key}: ${value}`)
                .join('\n');
        }

        // Create or update label sprite
        if (!label) {
            label = this.textRenderer.createTextSprite(labelText, {
                fontSize: this.labelFontSize,
                color: 0xffffff,
                backgroundColor: 0x000000,
                backgroundOpacity: 0.85
            });
            
            // Make label always face camera
            label.material.depthWrite = false;
            label.material.depthTest = false;
            label.renderOrder = 1;
            
            this.labelPool.set(nodeId, label);
            this.scene.add(label);
        } else {
            // Update existing label
            const newSprite = this.textRenderer.createTextSprite(labelText, {
                fontSize: this.labelFontSize,
                color: 0xffffff,
                backgroundColor: 0x000000,
                backgroundOpacity: 0.85
            });
            
            // Update material and texture
            if (label.material) {
                if (label.material.map) label.material.map.dispose();
                label.material.dispose();
            }
            label.material = newSprite.material;
            label.scale.copy(newSprite.scale);
        }

        // Position label above node
        const nodeSize = this.getNodeSize(node.metadata || {});
        const pos = new THREE.Vector3(node.x, node.y, node.z);
        label.position.copy(pos).add(new THREE.Vector3(0, nodeSize * 1.5, 0));
        
        // Make label face camera
        label.quaternion.copy(this.camera.quaternion);
        
        return label;
    }

    /**
     * Updates labels for all nodes
     */
    updateLabels() {
        this.nodeData.forEach((node, nodeId) => {
            this.createNodeLabel(nodeId, node);
        });
    }

    /**
     * Handles binary position updates from WebSocket
     */
    updateNodePositions(positions, isInitialLayout = false) {
        if (!this.nodeInstancedMeshes) return;

        const matrix = this.matrix;
        const position = this.position;
        const quaternion = this.quaternion;
        const updatedNodes = new Set();

        // Update positions in batches
        for (let i = 0; i < positions.length; i++) {
            const nodeId = Array.from(this.nodeData.keys())[i];
            if (!nodeId) continue;

            const pos = positions[i];
            const node = this.nodeData.get(nodeId);
            
            // Update node data
            node.x = pos[0];
            node.y = pos[1];
            node.z = pos[2];
            node.vx = pos[3];
            node.vy = pos[4];
            node.vz = pos[5];

            // Update instance matrix
            position.set(pos[0], pos[1], pos[2]);
            const size = this.getNodeSize(node.metadata || {});
            this.scale.set(size, size, size);
            matrix.compose(position, quaternion, this.scale);

            // Update appropriate LOD mesh
            const distance = this.camera.position.distanceTo(position);
            let targetMesh;
            if (distance < 50) targetMesh = this.nodeInstancedMeshes.high;
            else if (distance < 100) targetMesh = this.nodeInstancedMeshes.medium;
            else targetMesh = this.nodeInstancedMeshes.low;

            targetMesh.setMatrixAt(i, matrix);

            // Track updates
            updatedNodes.add(nodeId);

            // Update instance lookup data
            const posIndex = i * 3;
            this.instancePositions[posIndex] = pos[0];
            this.instancePositions[posIndex + 1] = pos[1];
            this.instancePositions[posIndex + 2] = pos[2];
            this.instanceIds.set(`${[pos[0], pos[1], pos[2]]}`, nodeId);

            // Update label position
            const label = this.labelPool.get(nodeId);
            if (label) {
                label.position.copy(position).add(new THREE.Vector3(0, size * 1.5, 0));
                label.quaternion.copy(this.camera.quaternion);
            }
        }

        // Update instance matrices
        Object.values(this.nodeInstancedMeshes).forEach(mesh => {
            mesh.instanceMatrix.needsUpdate = true;
        });

        // Update edges and labels
        if (updatedNodes.size > 0) {
            this.updateEdgesForNodes(updatedNodes);
            this.throttledLabelUpdate(updatedNodes);
        }

        // Center camera on initial layout
        if (isInitialLayout) {
            this.centerCamera();
        }
    }

    /**
     * Updates edges connected to moved nodes
     * @param {Set<string>} updatedNodes - Set of node IDs that moved
     */
    updateEdgesForNodes(updatedNodes) {
        if (!this.edgeInstancedMesh) return;

        const matrix = this.matrix;
        const position = this.position;
        const quaternion = this.quaternion;
        const scale = this.scale;
        let edgeIndex = 0;

        // Update only affected edges
        this.nodeData.forEach((sourceNode, sourceId) => {
            this.nodeData.forEach((targetNode, targetId) => {
                if (sourceId === targetId) return;
                if (!updatedNodes.has(sourceId) && !updatedNodes.has(targetId)) return;

                const start = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
                const end = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);
                const direction = end.clone().sub(start);
                const length = direction.length();

                if (length === 0) return;

                // Update edge transform
                const center = start.clone().add(end).multiplyScalar(0.5);
                position.copy(center);
                direction.normalize();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                scale.set(0.15, length, 0.15);

                matrix.compose(position, quaternion, scale);
                this.edgeInstancedMesh.setMatrixAt(edgeIndex++, matrix);
            });
        });

        this.edgeInstancedMesh.count = edgeIndex;
        this.edgeInstancedMesh.instanceMatrix.needsUpdate = true;
    }

    /**
     * Throttled label update to improve performance
     * @param {Set<string>} updatedNodes - Set of node IDs that need label updates
     */
    throttledLabelUpdate(updatedNodes) {
        if (this._labelUpdateTimeout) return;

        this._labelUpdateTimeout = setTimeout(() => {
            updatedNodes.forEach(nodeId => {
                const node = this.nodeData.get(nodeId);
                if (!node) return;

                const label = this.labelPool.get(nodeId);
                if (label) {
                    const size = this.getNodeSize(node.metadata || {});
                    label.position.set(node.x, node.y + size * 1.5, node.z);
                    label.visible = true;
                }
            });
            this._labelUpdateTimeout = null;
        }, 100);
    }

    dispose() {
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.removeEventListener('xrsessionstart', () => this.handleXRStateChange(true));
        window.removeEventListener('xrsessionend', () => this.handleXRStateChange(false));
        
        if (this.xrController) {
            this.xrController.removeEventListener('select', this.handleXRSelect);
            this.scene.remove(this.xrController);
        }

        Object.values(this.nodeInstancedMeshes).forEach(mesh => {
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
            this.instancedContainer.remove(mesh);
        });

        if (this.edgeInstancedMesh) {
            if (this.edgeInstancedMesh.geometry) this.edgeInstancedMesh.geometry.dispose();
            if (this.edgeInstancedMesh.material) this.edgeInstancedMesh.material.dispose();
            this.instancedContainer.remove(this.edgeInstancedMesh);
        }

        this.labelPool.forEach(label => {
            if (label.material) {
                if (label.material.map) label.material.map.dispose();
                label.material.dispose();
            }
            this.scene.remove(label);
        });

        this.scene.remove(this.instancedContainer);
        
        this.nodeData.clear();
        this.labelPool.clear();
        this.instanceIds.clear();
    }
}

----
visualization/core.js
// Previous imports unchanged...
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { NodeManager } from './nodes.js';
import { EffectsManager } from './effects.js';
import { visualizationSettings } from '../services/visualizationSettings.js';
import { initXRSession, addXRButton, handleXRSession } from '../xr/xrSetup.js';
import { initXRInteraction } from '../xr/xrInteraction.js';

// Constants for input sensitivity
const TRANSLATION_SPEED = 0.01;
const ROTATION_SPEED = 0.01;
const VR_MOVEMENT_SPEED = 0.05;

export class WebXRVisualization {
    constructor(graphDataManager) {
        console.log('WebXRVisualization constructor called with graphDataManager:', !!graphDataManager);
        if (!graphDataManager) {
            throw new Error('GraphDataManager is required for WebXRVisualization');
        }
        this.graphDataManager = graphDataManager;

        // Wait for settings before initializing
        this.initialized = false;
        this.pendingInitialization = true;

        // Store references that will be initialized once settings are received
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.nodeManager = null;
        this.controls = null;
        this.xrSessionManager = null;
        this.canvas = null;

        // Position tracking
        this.nodePositions = new Map();
        this.positionBuffer = null;

        // Bind methods
        this.onWindowResize = this.onWindowResize.bind(this);
        this.animate = this.animate.bind(this);
        this.updateVisualization = this.updateVisualization.bind(this);
        this.handleSpacemouseInput = this.handleSpacemouseInput.bind(this);
        this.renderFrame = this.renderFrame.bind(this);
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.handleBinaryUpdate = this.handleBinaryUpdate.bind(this);

        // Add event listeners
        window.addEventListener('binaryPositionUpdate', this.handleBinaryUpdate);
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
    }

    handleBinaryUpdate(event) {
        if (!this.initialized || !this.nodeManager) return;

        const { positions, isInitialLayout } = event.detail;
        
        // Update position cache
        this.nodeManager.nodes.forEach((node, index) => {
            if (positions[index]) {
                const pos = positions[index];
                // Update node position directly
                node.position.set(pos[0], pos[1], pos[2]);
                // Cache position for quick access
                this.nodePositions.set(node.id, {
                    position: [pos[0], pos[1], pos[2]],
                    velocity: [pos[3], pos[4], pos[5]]
                });
            }
        });

        // Update edges if needed (they might need to follow node positions)
        if (this.nodeManager.updateEdgePositions) {
            this.nodeManager.updateEdgePositions();
        }

        // If this is an initial layout, center the camera
        if (isInitialLayout) {
            this.centerCamera();
        }
    }

    centerCamera() {
        if (!this.nodeManager || !this.camera || this.nodeManager.nodes.length === 0) return;

        // Calculate bounding box
        const bbox = new THREE.Box3();
        this.nodeManager.nodes.forEach(node => {
            bbox.expandByPoint(node.position);
        });

        // Get center and size
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        const size = new THREE.Vector3();
        bbox.getSize(size);

        // Calculate optimal camera position
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = this.camera.fov * (Math.PI / 180);
        const cameraZ = Math.abs(maxDim / Math.sin(fov / 2));

        // Update camera and controls
        this.camera.position.set(center.x, center.y, center.z + cameraZ);
        if (this.controls) {
            this.controls.target.copy(center);
            this.controls.update();
        }
    }

    updateVisualization(data) {
        if (!this.nodeManager || !data) {
            console.warn('Cannot update visualization: missing manager or data');
            return;
        }

        console.log(`Updating visualization with ${data.nodes?.length || 0} nodes and ${data.edges?.length || 0} edges`);

        // Handle full graph updates (structure changes)
        if (data.nodes || data.edges) {
            if (Array.isArray(data.nodes)) {
                console.log('Updating nodes');
                this.nodeManager.updateNodes(data.nodes);
                // Update position cache
                data.nodes.forEach(node => {
                    this.nodePositions.set(node.id, {
                        position: [node.x, node.y, node.z],
                        velocity: [node.vx || 0, node.vy || 0, node.vz || 0]
                    });
                });
            }
            
            if (Array.isArray(data.edges)) {
                console.log('Updating edges');
                this.nodeManager.updateEdges(data.edges);
            }
        }
    }

    async initializeXR() {
        try {
            // Enable XR on renderer
            this.renderer.xr.enabled = true;

            // Initialize XR session manager
            this.xrSessionManager = await initXRSession(this.renderer, this.scene, this.camera);
            
            if (this.xrSessionManager) {
                // Add XR button to the scene
                await addXRButton(this.xrSessionManager);
                console.log('XR initialization complete');
            } else {
                console.warn('XR not supported or initialization failed');
            }
        } catch (error) {
            console.error('Error initializing XR:', error);
        }
    }

    renderFrame() {
        // Update controls if not in XR mode
        if (this.controls && (!this.xrSessionManager || !this.renderer.xr.isPresenting)) {
            this.controls.update();
        }

        // Update XR session if active
        if (this.xrSessionManager && this.renderer.xr.isPresenting) {
            this.xrSessionManager.update();
        }

        // Update node labels using cached positions
        if (this.nodeManager) {
            this.nodeManager.updateLabelOrientations(this.camera);
        }

        // Render scene
        this.renderer.render(this.scene, this.camera);
    }

    animate() {
        // Use requestAnimationFrame for non-XR rendering
        if (!this.renderer.xr.isPresenting) {
            requestAnimationFrame(this.animate);
            this.renderFrame();
        }
    }

    initializeSettings() {
        console.log('Initializing settings');
        
        const settings = visualizationSettings.getSettings();
        if (!settings?.visualization) {
            console.warn('No visualization settings available');
            return;
        }

        const vis = settings.visualization;
        
        // Add strong ambient light for better visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        this.scene.add(ambientLight);

        // Add directional light for shadows and highlights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
        directionalLight.position.set(10, 20, 10);
        this.scene.add(directionalLight);

        // Add hemisphere light for better ambient illumination
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        this.scene.add(hemisphereLight);

        // Add point lights for better illumination
        const pointLight1 = new THREE.PointLight(0xffffff, 1.0, 300);
        pointLight1.position.set(100, 100, 100);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1.0, 300);
        pointLight2.position.set(-100, -100, -100);
        this.scene.add(pointLight2);

        // Set fog from settings
        this.scene.fog = new THREE.FogExp2(0x000000, vis.fog_density);

        console.log('Scene settings initialized with settings from server');
    }

    onWindowResize() {
        if (this.camera && this.renderer && this.canvas) {
            // Update canvas size
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            
            // Update camera
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            
            // Update renderer
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    setupEventListeners() {
        console.log('Setting up event listeners');
        
        window.addEventListener('graphDataUpdated', (event) => {
            console.log('Received graphDataUpdated event:', event.detail);
            if (event.detail && Array.isArray(event.detail.nodes)) {
                this.updateVisualization(event.detail);
            } else {
                console.warn('Invalid graph data in event:', event.detail);
            }
        });

        window.addEventListener('resize', this.onWindowResize);
    }

    handleSpacemouseInput(x, y, z) {
        if (!this.camera) return;

        this.camera.position.x += x * TRANSLATION_SPEED;
        this.camera.position.y += y * TRANSLATION_SPEED;
        this.camera.position.z += z * TRANSLATION_SPEED;

        if (this.controls) {
            this.controls.target.copy(this.camera.position).add(
                new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion)
            );
            this.controls.update();
        }
    }

    dispose() {
        console.log('Disposing WebXRVisualization');
        
        // Remove event listeners
        window.removeEventListener('binaryPositionUpdate', this.handleBinaryUpdate);
        window.removeEventListener('resize', this.onWindowResize);
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);

        // Clear position cache
        this.nodePositions.clear();
        this.positionBuffer = null;

        // Clean up renderer
        this.renderer.setAnimationLoop(null);

        // Clean up managers
        if (this.nodeManager) {
            this.nodeManager.dispose();
        }

        // Clean up DOM elements
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }

        // Dispose of Three.js resources
        if (this.renderer) {
            this.renderer.dispose();
        }

        if (this.controls) {
            this.controls.dispose();
        }

        console.log('WebXRVisualization disposed');
    }
}

----
visualization/textRenderer.js
import * as THREE from 'three';

// SDF font atlas generation
function generateSDFData(text, fontSize, padding) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size to power of 2 for better texture performance
    const size = Math.pow(2, Math.ceil(Math.log2(fontSize * 2 + padding * 2)));
    canvas.width = size;
    canvas.height = size;
    
    // Setup font
    ctx.font = `${fontSize}px Arial`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    
    // Draw text
    ctx.fillStyle = 'white';
    ctx.fillText(text, size/2, size/2);
    
    // Generate SDF
    const imageData = ctx.getImageData(0, 0, size, size);
    const sdf = new Float32Array(size * size);
    
    // Calculate SDF values
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            const alpha = imageData.data[idx + 3] / 255;
            
            // Calculate distance field
            let minDist = Number.MAX_VALUE;
            const maxSearchDist = fontSize / 2;
            
            for (let sy = -maxSearchDist; sy <= maxSearchDist; sy++) {
                for (let sx = -maxSearchDist; sx <= maxSearchDist; sx++) {
                    const sampX = x + sx;
                    const sampY = y + sy;
                    
                    if (sampX >= 0 && sampX < size && sampY >= 0 && sampY < size) {
                        const sampIdx = (sampY * size + sampX) * 4;
                        const sampAlpha = imageData.data[sampIdx + 3] / 255;
                        
                        if (sampAlpha !== alpha) {
                            const dist = Math.sqrt(sx*sx + sy*sy);
                            minDist = Math.min(minDist, dist);
                        }
                    }
                }
            }
            
            // Normalize and store SDF value
            sdf[y * size + x] = alpha === 1 ? minDist / maxSearchDist : -minDist / maxSearchDist;
        }
    }
    
    return {
        data: sdf,
        size: size,
        texture: new THREE.DataTexture(
            sdf,
            size,
            size,
            THREE.RedFormat,
            THREE.FloatType
        )
    };
}

export class TextRenderer {
    constructor() {
        // SDF shader for high-quality text rendering
        this.material = new THREE.ShaderMaterial({
            uniforms: {
                sdfTexture: { value: null },
                color: { value: new THREE.Color(0xffffff) },
                smoothing: { value: 0.25 },
                threshold: { value: 0.5 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D sdfTexture;
                uniform vec3 color;
                uniform float smoothing;
                uniform float threshold;
                varying vec2 vUv;
                
                void main() {
                    float sdf = texture2D(sdfTexture, vUv).r;
                    float alpha = smoothstep(threshold - smoothing, threshold + smoothing, sdf);
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });
    }
    
    createTextSprite(text, options = {}) {
        const {
            fontSize = 32,
            padding = 8,
            color = 0xffffff,
            backgroundColor = 0x000000,
            backgroundOpacity = 0.85
        } = options;
        
        // Generate SDF data
        const sdfData = generateSDFData(text, fontSize, padding);
        
        // Create geometry
        const geometry = new THREE.PlaneGeometry(1, 1);
        
        // Update material with new texture
        const material = this.material.clone();
        material.uniforms.sdfTexture.value = sdfData.texture;
        material.uniforms.color.value = new THREE.Color(color);
        
        // Create mesh
        const mesh = new THREE.Mesh(geometry, material);
        
        // Add background plane if needed
        if (backgroundOpacity > 0) {
            const bgGeometry = new THREE.PlaneGeometry(1.1, 1.1);
            const bgMaterial = new THREE.MeshBasicMaterial({
                color: backgroundColor,
                transparent: true,
                opacity: backgroundOpacity,
                depthWrite: false
            });
            const background = new THREE.Mesh(bgGeometry, bgMaterial);
            background.position.z = -0.001;
            mesh.add(background);
        }
        
        // Scale mesh based on texture size
        const scale = fontSize / sdfData.size;
        mesh.scale.set(sdfData.size * scale, sdfData.size * scale, 1);
        
        return mesh;
    }
    
    dispose() {
        this.material.dispose();
    }
}

----
visualization/layerManager.js
import * as THREE from 'three';

// Layer constants for rendering pipeline
export const LAYERS = {
    NORMAL_LAYER: 0,  // Base layer for regular rendering
    BLOOM: 1,        // Layer for node bloom effects
    HOLOGRAM: 2,     // Layer for hologram effects
    EDGE: 3,         // Layer for edge bloom effects
    LABEL: 4         // Layer for labels
};

// Simplified layer groups - everything visible on normal layer
export const LAYER_GROUPS = {
    // Base scene elements
    BASE: [LAYERS.NORMAL_LAYER],
    
    // Nodes
    BLOOM: [LAYERS.NORMAL_LAYER],
    
    // Hologram elements
    HOLOGRAM: [LAYERS.NORMAL_LAYER],
    
    // Edge elements
    EDGE: [LAYERS.NORMAL_LAYER],
    
    // Label elements
    LABEL: [LAYERS.NORMAL_LAYER]
};

// Simplified material presets for basic rendering
const MATERIAL_PRESETS = {
    BLOOM: {
        transparent: true,
        opacity: 1.0,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    },
    HOLOGRAM: {
        transparent: true,
        opacity: 0.8,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    },
    EDGE: {
        transparent: true,
        opacity: 0.8,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    }
};

// Enhanced LayerManager with simplified rendering
export const LayerManager = {
    // Enable multiple layers for an object
    enableLayers(object, layers) {
        if (!object || !object.layers) {
            console.error('Invalid object provided to enableLayers');
            return;
        }

        // Always enable normal layer
        object.layers.set(LAYERS.NORMAL_LAYER);
    },

    // Set object to specific layer group with basic material settings
    setLayerGroup(object, groupName) {
        if (!object || !object.layers) {
            console.error('Invalid object provided to setLayerGroup');
            return;
        }

        // Always set to normal layer for visibility
        object.layers.set(LAYERS.NORMAL_LAYER);

        // Apply basic material presets if object has material
        if (object.material && MATERIAL_PRESETS[groupName]) {
            // Clone material to avoid affecting other objects
            if (!object.material._isCloned) {
                object.material = object.material.clone();
                object.material._isCloned = true;
            }
            
            // Apply basic preset properties
            Object.assign(object.material, MATERIAL_PRESETS[groupName]);
            
            // Ensure material is visible and properly rendered
            object.material.needsUpdate = true;
        }
    },

    // Check if object is in layer
    isInLayer(object, layer) {
        if (!object || !object.layers || typeof layer !== 'number') {
            return false;
        }
        return object.layers.test(new THREE.Layers().set(layer));
    },

    // Get all objects in a specific layer
    getObjectsInLayer(scene, layer, options = {}) {
        if (!scene || typeof layer !== 'number') {
            console.error('Invalid parameters provided to getObjectsInLayer');
            return [];
        }

        const objects = [];
        const {
            includeInvisible = false,
            includeHelpers = false
        } = options;

        scene.traverse(object => {
            if (this.isInLayer(object, layer)) {
                if (!includeInvisible && !object.visible) return;
                if (!includeHelpers && object.isHelper) return;
                objects.push(object);
            }
        });
        return objects;
    },

    // Reset object to base layer with standard material
    resetToBaseLayer(object) {
        if (!object || !object.layers) return;
        
        object.layers.set(LAYERS.NORMAL_LAYER);
        
        if (object.material && object.material._isCloned) {
            object.material.dispose();
            object.material = new THREE.MeshStandardMaterial({
                color: object.material.color,
                transparent: true,
                opacity: 1.0,
                toneMapped: true
            });
            object.material._isCloned = false;
        }
    },

    // Create a standard material
    createStandardMaterial(color) {
        return new THREE.MeshStandardMaterial({
            color: color,
            transparent: true,
            opacity: 1.0,
            toneMapped: true,
            depthWrite: true,
            blending: THREE.NormalBlending
        });
    }
};

----
visualization/effects/BloomEffect.js
import * as THREE from 'three';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { LAYERS } from '../layerManager.js';

export class BloomEffect {
    constructor(renderer, scene, camera) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to BloomEffect');
        }
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.composers = new Map();
        this.renderTargets = new Map();
        this.xrRenderTargets = new Map();
        this.initialized = false;
        this.isXRActive = false;

        // Store original renderer state
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();

        // Bind XR session change handlers
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);

        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }

    handleXRSessionStart() {
        this.isXRActive = true;
        // Create XR-specific render targets if needed
        if (this.initialized) {
            this.createXRRenderTargets();
        }
    }

    handleXRSessionEnd() {
        this.isXRActive = false;
        // Clean up XR render targets
        this.xrRenderTargets.forEach(target => {
            if (target && target.dispose) {
                target.dispose();
            }
        });
        this.xrRenderTargets.clear();
    }

    createRenderTarget(isXR = false) {
        let width, height;
        
        if (isXR && this.renderer.xr.getSession()) {
            const glProperties = this.renderer.properties.get(this.renderer.xr.getSession());
            const renderWidth = glProperties?.renderWidth || window.innerWidth * 2;
            const renderHeight = glProperties?.renderHeight || window.innerHeight;
            width = renderWidth;
            height = renderHeight;
        } else {
            const pixelRatio = this.renderer.getPixelRatio();
            width = Math.floor(window.innerWidth * pixelRatio);
            height = Math.floor(window.innerHeight * pixelRatio);
        }

        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        return new THREE.WebGLRenderTarget(
            width,
            height,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType,
                colorSpace: isWebGL2 ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace,
                stencilBuffer: false,
                depthBuffer: true,
                samples: isWebGL2 ? 4 : 0
            }
        );
    }

    createXRRenderTargets() {
        const layers = [LAYERS.BLOOM, LAYERS.HOLOGRAM, LAYERS.EDGE];
        
        // Create base XR render target
        const baseTarget = this.createRenderTarget(true);
        this.xrRenderTargets.set('base', baseTarget);

        // Create XR render targets for each layer
        layers.forEach(layer => {
            const renderTarget = this.createRenderTarget(true);
            this.xrRenderTargets.set(layer, renderTarget);
        });
    }

    init(settings) {
        if (!settings) {
            console.error('No bloom settings provided');
            return;
        }

        if (this.initialized) {
            this.dispose();
        }

        if (!this.renderer || !this.renderer.domElement) {
            console.error('Renderer not ready for bloom effect initialization');
            return;
        }

        // Create base render target for scene
        const baseTarget = this.createRenderTarget();
        this.renderTargets.set('base', baseTarget);

        // Create XR render targets if in XR mode
        if (this.isXRActive) {
            this.createXRRenderTargets();
        }

        // Adjust settings based on WebGL version and XR state
        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        let adjustedSettings = { ...settings };

        if (!isWebGL2) {
            // Reduce quality for WebGL1
            adjustedSettings = {
                ...adjustedSettings,
                node_bloom_strength: settings.node_bloom_strength * 0.8,
                node_bloom_radius: settings.node_bloom_radius * 0.7,
                edge_bloom_strength: settings.edge_bloom_strength * 0.8,
                edge_bloom_radius: settings.edge_bloom_radius * 0.7,
                environment_bloom_strength: settings.environment_bloom_strength * 0.8,
                environment_bloom_radius: settings.environment_bloom_radius * 0.7
            };
        }

        if (this.isXRActive) {
            // Adjust bloom for XR
            adjustedSettings = {
                ...adjustedSettings,
                node_bloom_strength: adjustedSettings.node_bloom_strength * 1.2,
                node_bloom_radius: adjustedSettings.node_bloom_radius * 0.8,
                edge_bloom_strength: adjustedSettings.edge_bloom_strength * 1.2,
                edge_bloom_radius: adjustedSettings.edge_bloom_radius * 0.8
            };
        }

        const layers = [
            {
                layer: LAYERS.BLOOM,
                settings: {
                    strength: adjustedSettings.node_bloom_strength,
                    radius: adjustedSettings.node_bloom_radius,
                    threshold: adjustedSettings.node_bloom_threshold
                }
            },
            {
                layer: LAYERS.HOLOGRAM,
                settings: {
                    strength: adjustedSettings.environment_bloom_strength,
                    radius: adjustedSettings.environment_bloom_radius,
                    threshold: adjustedSettings.environment_bloom_threshold
                }
            },
            {
                layer: LAYERS.EDGE,
                settings: {
                    strength: adjustedSettings.edge_bloom_strength,
                    radius: adjustedSettings.edge_bloom_radius,
                    threshold: adjustedSettings.edge_bloom_threshold
                }
            }
        ];

        try {
            // Set renderer color space based on WebGL version
            this.renderer.outputColorSpace = isWebGL2 ? 
                THREE.LinearSRGBColorSpace : 
                THREE.SRGBColorSpace;

            // Create composers for both regular and XR rendering
            this.createComposers(layers, false); // Regular composers
            if (this.isXRActive) {
                this.createComposers(layers, true); // XR composers
            }

            this.initialized = true;
        } catch (error) {
            console.error('Error initializing bloom effect:', error);
            this.dispose();
        }
    }

    updateSettings(settings) {
        if (!this.initialized || !settings) return;

        try {
            const layers = [
                {
                    layer: LAYERS.BLOOM,
                    settings: {
                        strength: settings.node_bloom_strength,
                        radius: settings.node_bloom_radius,
                        threshold: settings.node_bloom_threshold
                    }
                },
                {
                    layer: LAYERS.HOLOGRAM,
                    settings: {
                        strength: settings.environment_bloom_strength,
                        radius: settings.environment_bloom_radius,
                        threshold: settings.environment_bloom_threshold
                    }
                },
                {
                    layer: LAYERS.EDGE,
                    settings: {
                        strength: settings.edge_bloom_strength,
                        radius: settings.edge_bloom_radius,
                        threshold: settings.edge_bloom_threshold
                    }
                }
            ];

            // Update bloom passes in composers
            layers.forEach(({ layer, settings }) => {
                const composer = this.composers.get(layer.toString());
                if (composer) {
                    const bloomPass = composer.passes.find(pass => pass instanceof UnrealBloomPass);
                    if (bloomPass) {
                        bloomPass.strength = settings.strength;
                        bloomPass.radius = settings.radius;
                        bloomPass.threshold = settings.threshold;
                    }
                }

                // Update XR composers if active
                if (this.isXRActive) {
                    const xrComposer = this.composers.get(`xr_${layer}`);
                    if (xrComposer) {
                        const bloomPass = xrComposer.passes.find(pass => pass instanceof UnrealBloomPass);
                        if (bloomPass) {
                            bloomPass.strength = settings.strength * 1.2; // Adjust for XR
                            bloomPass.radius = settings.radius * 0.8; // Adjust for XR
                            bloomPass.threshold = settings.threshold;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error updating bloom settings:', error);
        }
    }

    createComposers(layers, isXR) {
        const targets = isXR ? this.xrRenderTargets : this.renderTargets;
        const composerPrefix = isXR ? 'xr_' : '';

        // Create base composer
        const baseComposer = new EffectComposer(this.renderer, targets.get('base'));
        const baseRenderPass = new RenderPass(this.scene, this.camera);
        baseRenderPass.clear = true;
        baseComposer.addPass(baseRenderPass);
        this.composers.set(`${composerPrefix}base`, baseComposer);

        // Create bloom composers for each layer
        layers.forEach(({ layer, settings }) => {
            const composer = new EffectComposer(this.renderer, targets.get(layer));
            composer.renderToScreen = false;
            
            const renderPass = new RenderPass(this.scene, this.camera);
            renderPass.clear = true;
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(
                    targets.get(layer).width,
                    targets.get(layer).height
                ),
                settings.strength,
                settings.radius,
                settings.threshold
            );
            
            bloomPass.highQualityBloom = this.renderer.capabilities.isWebGL2;
            bloomPass.gammaCorrectionInShader = this.renderer.capabilities.isWebGL2;
            
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            
            this.composers.set(`${composerPrefix}${layer}`, composer);
        });
    }

    render(currentCamera) {
        if (!this.initialized || !currentCamera) return;

        try {
            const isXRFrame = this.renderer.xr.isPresenting;
            const composerPrefix = isXRFrame ? 'xr_' : '';
            
            // Store original camera layers
            const originalLayerMask = currentCamera.layers.mask;

            // Render base scene first
            currentCamera.layers.set(LAYERS.NORMAL_LAYER);
            this.composers.get(`${composerPrefix}base`).render();

            // Render bloom layers
            this.composers.forEach((composer, key) => {
                if (key.startsWith(composerPrefix) && !key.endsWith('base')) {
                    const layer = parseInt(key.split('_').pop());
                    currentCamera.layers.set(layer);
                    composer.render();
                }
            });

            // Restore camera layers
            currentCamera.layers.mask = originalLayerMask;
        } catch (error) {
            console.error('Error rendering bloom effect:', error);
        }
    }

    resize(width, height) {
        if (!this.initialized) return;

        const pixelRatio = this.renderer.getPixelRatio();
        const actualWidth = Math.floor(width * pixelRatio);
        const actualHeight = Math.floor(height * pixelRatio);

        // Resize regular render targets and composers
        this.renderTargets.forEach(target => {
            if (target && target.setSize) {
                target.setSize(actualWidth, actualHeight);
            }
        });
        
        this.composers.forEach((composer, key) => {
            if (!key.startsWith('xr_') && composer && composer.setSize) {
                composer.setSize(actualWidth, actualHeight);
            }
        });

        // Don't resize XR targets - they're managed by the XR system
    }

    dispose() {
        // Remove event listeners
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);

        // Dispose render targets
        this.renderTargets.forEach(target => {
            if (target && target.dispose) target.dispose();
        });
        
        this.xrRenderTargets.forEach(target => {
            if (target && target.dispose) target.dispose();
        });
        
        // Dispose composers
        this.composers.forEach(composer => {
            if (composer && composer.dispose) composer.dispose();
        });
        
        // Reset renderer state
        if (this.renderer) {
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        // Clear collections
        this.renderTargets.clear();
        this.xrRenderTargets.clear();
        this.composers.clear();
        this.initialized = false;
        this.isXRActive = false;
    }

    getRenderTargets() {
        if (!this.initialized) return null;
        return this.isXRActive ? this.xrRenderTargets : this.renderTargets;
    }
}

----
visualization/effects/CompositionEffect.js
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { LAYERS } from '../layerManager.js';
import { visualizationSettings } from '../../services/visualizationSettings.js';

export class CompositionEffect {
    constructor(renderer) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to CompositionEffect');
        }
        this.renderer = renderer;
        this.composer = null;
        this.xrComposer = null;
        this.initialized = false;
        this.isXRActive = false;

        // Store original renderer state
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();

        // Bind XR session handlers
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);

        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }

    handleXRSessionStart() {
        this.isXRActive = true;
        if (this.initialized) {
            // Create XR-specific composer if needed
            this.createXRComposer();
        }
    }

    handleXRSessionEnd() {
        this.isXRActive = false;
        if (this.xrComposer) {
            this.xrComposer.dispose();
            this.xrComposer = null;
        }
    }

    createRenderTarget(isXR = false) {
        let width, height;
        
        if (isXR && this.renderer.xr.getSession()) {
            const glProperties = this.renderer.properties.get(this.renderer.xr.getSession());
            const renderWidth = glProperties?.renderWidth || window.innerWidth * 2;
            const renderHeight = glProperties?.renderHeight || window.innerHeight;
            width = renderWidth;
            height = renderHeight;
        } else {
            const pixelRatio = this.renderer.getPixelRatio();
            width = Math.floor(window.innerWidth * pixelRatio);
            height = Math.floor(window.innerHeight * pixelRatio);
        }

        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        return new THREE.WebGLRenderTarget(
            width,
            height,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType,
                colorSpace: isWebGL2 ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace,
                stencilBuffer: false,
                depthBuffer: true,
                samples: isWebGL2 ? 4 : 0
            }
        );
    }

    createCompositionShader(isXR = false) {
        // Get bloom settings from server
        const settings = visualizationSettings.getBloomSettings();
        if (!settings) {
            console.warn('No bloom settings available, using defaults');
        }

        return {
            uniforms: {
                baseTexture: { value: null },
                bloomTexture0: { value: null },
                bloomTexture1: { value: null },
                bloomTexture2: { value: null },
                bloomStrength0: { value: settings?.node_bloom_strength || 1.5 },
                bloomStrength1: { value: settings?.environment_bloom_strength || 1.2 },
                bloomStrength2: { value: settings?.edge_bloom_strength || 0.8 },
                exposure: { value: isXR ? 1.0 : 1.2 },
                gamma: { value: 2.2 },
                saturation: { value: isXR ? 1.1 : 1.2 },
                isXR: { value: isXR ? 1.0 : 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D baseTexture;
                uniform sampler2D bloomTexture0;
                uniform sampler2D bloomTexture1;
                uniform sampler2D bloomTexture2;
                uniform float bloomStrength0;
                uniform float bloomStrength1;
                uniform float bloomStrength2;
                uniform float exposure;
                uniform float gamma;
                uniform float saturation;
                uniform float isXR;
                
                varying vec2 vUv;

                vec3 adjustSaturation(vec3 color, float saturation) {
                    float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
                    return mix(vec3(luminance), color, saturation);
                }

                vec3 toneMap(vec3 color) {
                    // ACES filmic tone mapping
                    float a = 2.51;
                    float b = 0.03;
                    float c = 2.43;
                    float d = 0.59;
                    float e = 0.14;
                    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
                }

                void main() {
                    // Adjust UV for XR if needed
                    vec2 adjustedUV = vUv;
                    if (isXR > 0.5) {
                        // Handle stereo rendering
                        adjustedUV.x = adjustedUV.x * 0.5;
                        if (gl_FragCoord.x > gl_FragCoord.w) {
                            adjustedUV.x += 0.5;
                        }
                    }
                    
                    // Sample all textures in linear space
                    vec3 baseColor = texture2D(baseTexture, adjustedUV).rgb;
                    vec3 bloom0 = texture2D(bloomTexture0, adjustedUV).rgb * bloomStrength0;
                    vec3 bloom1 = texture2D(bloomTexture1, adjustedUV).rgb * bloomStrength1;
                    vec3 bloom2 = texture2D(bloomTexture2, adjustedUV).rgb * bloomStrength2;
                    
                    // Combine bloom layers
                    vec3 bloomSum = bloom0 + bloom1 + bloom2;
                    
                    // Add bloom to base color
                    vec3 hdrColor = baseColor + bloomSum;
                    
                    // Apply exposure
                    hdrColor *= exposure;
                    
                    // Tone mapping
                    vec3 color = toneMap(hdrColor);
                    
                    // Adjust saturation
                    color = adjustSaturation(color, saturation);
                    
                    // Gamma correction
                    color = pow(color, vec3(1.0 / gamma));
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };
    }

    createComposer(bloomRenderTargets, isXR = false) {
        const renderTarget = this.createRenderTarget(isXR);
        const composer = new EffectComposer(this.renderer, renderTarget);

        const shader = this.createCompositionShader(isXR);
        shader.uniforms.baseTexture.value = bloomRenderTargets.get('base').texture;
        shader.uniforms.bloomTexture0.value = bloomRenderTargets.get(LAYERS.BLOOM).texture;
        shader.uniforms.bloomTexture1.value = bloomRenderTargets.get(LAYERS.HOLOGRAM).texture;
        shader.uniforms.bloomTexture2.value = bloomRenderTargets.get(LAYERS.EDGE).texture;

        const finalPass = new ShaderPass(new THREE.ShaderMaterial(shader));
        finalPass.renderToScreen = true;
        finalPass.clear = false;
        composer.addPass(finalPass);

        return composer;
    }

    init(bloomRenderTargets) {
        try {
            if (this.initialized) {
                this.dispose();
            }

            if (!bloomRenderTargets) {
                throw new Error('No bloom render targets provided');
            }

            // Verify all required textures are available
            const requiredLayers = [LAYERS.BLOOM, LAYERS.HOLOGRAM, LAYERS.EDGE];
            requiredLayers.forEach(layer => {
                const target = bloomRenderTargets.get(layer);
                if (!target || !target.texture) {
                    throw new Error(`Missing bloom render target for layer ${layer}`);
                }
            });

            // Create regular composer
            this.composer = this.createComposer(bloomRenderTargets, false);

            // Create XR composer if in XR mode
            if (this.isXRActive) {
                this.createXRComposer(bloomRenderTargets);
            }

            this.initialized = true;
        } catch (error) {
            console.error('Error initializing composition effect:', error);
            this.dispose();
        }
    }

    updateSettings(bloomRenderTargets) {
        if (!this.initialized) return;

        try {
            const settings = visualizationSettings.getBloomSettings();
            if (!settings) return;

            // Update regular composer
            if (this.composer) {
                const finalPass = this.composer.passes[0];
                if (finalPass && finalPass.uniforms) {
                    finalPass.uniforms.bloomStrength0.value = settings.node_bloom_strength;
                    finalPass.uniforms.bloomStrength1.value = settings.environment_bloom_strength;
                    finalPass.uniforms.bloomStrength2.value = settings.edge_bloom_strength;
                }
            }

            // Update XR composer
            if (this.xrComposer) {
                const finalPass = this.xrComposer.passes[0];
                if (finalPass && finalPass.uniforms) {
                    finalPass.uniforms.bloomStrength0.value = settings.node_bloom_strength * 1.2;
                    finalPass.uniforms.bloomStrength1.value = settings.environment_bloom_strength * 1.2;
                    finalPass.uniforms.bloomStrength2.value = settings.edge_bloom_strength * 1.2;
                }
            }
        } catch (error) {
            console.error('Error updating composition settings:', error);
        }
    }

    createXRComposer(bloomRenderTargets) {
        if (!this.renderer.xr.getSession()) return;
        this.xrComposer = this.createComposer(bloomRenderTargets, true);
    }

    render(baseTexture) {
        if (!this.initialized) return;

        try {
            const activeComposer = this.isXRActive ? this.xrComposer : this.composer;
            if (!activeComposer) return;

            const finalPass = activeComposer.passes[0];
            if (finalPass && finalPass.uniforms) {
                finalPass.uniforms.baseTexture.value = baseTexture;
                activeComposer.render();
            }
        } catch (error) {
            console.error('Error rendering composition effect:', error);
        }
    }

    resize(width, height) {
        if (!this.initialized) return;

        try {
            const pixelRatio = this.renderer.getPixelRatio();
            const actualWidth = Math.floor(width * pixelRatio);
            const actualHeight = Math.floor(height * pixelRatio);
            
            // Only resize non-XR composer
            if (this.composer) {
                this.composer.setSize(actualWidth, actualHeight);
            }
        } catch (error) {
            console.error('Error resizing composition effect:', error);
        }
    }

    dispose() {
        // Remove event listeners
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);

        // Dispose composers
        if (this.composer) {
            this.composer.dispose();
            this.composer = null;
        }
        
        if (this.xrComposer) {
            this.xrComposer.dispose();
            this.xrComposer = null;
        }
        
        if (this.renderer) {
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        this.initialized = false;
        this.isXRActive = false;
    }
}

----
stores/binaryUpdate.ts
import { defineStore } from 'pinia'
import type { BinaryMessage } from '../types/websocket'
import {
  BINARY_UPDATE_NODE_SIZE,
  FLOAT32_SIZE,
  MAX_VALID_POSITION,
  MIN_VALID_POSITION,
  MAX_VALID_VELOCITY,
  MIN_VALID_VELOCITY,
  ENABLE_BINARY_DEBUG,
  ENABLE_POSITION_VALIDATION
} from '../constants/websocket'

interface BinaryUpdateState {
  // Use TypedArrays for better performance with binary data
  positions: Float32Array  // [x,y,z] for each node
  velocities: Float32Array // [vx,vy,vz] for each node
  nodeCount: number
  firstUpdateTime: number  // Track when updates started
  lastUpdateTime: number   // Track most recent update
  invalidUpdates: number   // Track number of invalid updates for monitoring
}

/**
 * Store for handling binary position/velocity updates
 * Optimized for high-frequency updates in force-directed graph
 */
export const useBinaryUpdateStore = defineStore('binaryUpdate', {
  state: (): BinaryUpdateState => ({
    positions: new Float32Array(0),
    velocities: new Float32Array(0),
    nodeCount: 0,
    firstUpdateTime: 0,
    lastUpdateTime: 0,
    invalidUpdates: 0
  }),

  getters: {
    /**
     * Get position for node by index
     */
    getNodePosition: (state) => (index: number): [number, number, number] | undefined => {
      if (index >= 0 && index < state.nodeCount) {
        const baseIndex = index * 3;
        return [
          state.positions[baseIndex],
          state.positions[baseIndex + 1],
          state.positions[baseIndex + 2]
        ];
      }
      return undefined;
    },

    /**
     * Get velocity for node by index
     */
    getNodeVelocity: (state) => (index: number): [number, number, number] | undefined => {
      if (index >= 0 && index < state.nodeCount) {
        const baseIndex = index * 3;
        return [
          state.velocities[baseIndex],
          state.velocities[baseIndex + 1],
          state.velocities[baseIndex + 2]
        ];
      }
      return undefined;
    },

    /**
     * Get all positions as Float32Array
     */
    getAllPositions: (state): Float32Array => state.positions,

    /**
     * Get all velocities as Float32Array
     */
    getAllVelocities: (state): Float32Array => state.velocities,

    /**
     * Get percentage of invalid updates
     */
    invalidUpdateRate: (state): number => {
      if (state.firstUpdateTime === 0) return 0;
      const timeSpan = (state.lastUpdateTime - state.firstUpdateTime) / 1000; // seconds
      const totalUpdates = Math.max(1, state.nodeCount * timeSpan);
      return (state.invalidUpdates / totalUpdates) * 100;
    },

    /**
     * Get update frequency in updates per second
     */
    updateFrequency: (state): number => {
      if (state.firstUpdateTime === 0) return 0;
      const timeSpan = (state.lastUpdateTime - state.firstUpdateTime) / 1000; // seconds
      return timeSpan > 0 ? state.nodeCount / timeSpan : 0;
    }
  },

  actions: {
    /**
     * Internal: Validate a position value
     */
    _validatePosition(value: number): boolean {
      return value >= MIN_VALID_POSITION && value <= MAX_VALID_POSITION;
    },

    /**
     * Internal: Validate a velocity value
     */
    _validateVelocity(value: number): boolean {
      return value >= MIN_VALID_VELOCITY && value <= MAX_VALID_VELOCITY;
    },

    /**
     * Internal: Clamp a position value to valid range
     */
    _clampPosition(value: number): number {
      return Math.max(MIN_VALID_POSITION, Math.min(MAX_VALID_POSITION, value));
    },

    /**
     * Internal: Clamp a velocity value to valid range
     */
    _clampVelocity(value: number): number {
      return Math.max(MIN_VALID_VELOCITY, Math.min(MAX_VALID_VELOCITY, value));
    },

    /**
     * Update position for a single node
     */
    updateNodePosition(
      index: number,
      x: number, y: number, z: number,
      vx: number, vy: number, vz: number
    ): void {
      if (index >= 0 && index < this.nodeCount) {
        const posIndex = index * 3;
        const velIndex = index * 3;

        if (ENABLE_POSITION_VALIDATION) {
          // Validate position values
          const positionsValid = [x, y, z].every(v => this._validatePosition(v));
          const velocitiesValid = [vx, vy, vz].every(v => this._validateVelocity(v));

          if (!positionsValid || !velocitiesValid) {
            this.invalidUpdates++;
            console.warn('Invalid position/velocity values detected:', {
              index,
              position: [x, y, z],
              velocity: [vx, vy, vz]
            });

            // Clamp values to valid ranges
            x = this._clampPosition(x);
            y = this._clampPosition(y);
            z = this._clampPosition(z);
            vx = this._clampVelocity(vx);
            vy = this._clampVelocity(vy);
            vz = this._clampVelocity(vz);
          }
        }

        // Update position
        this.positions[posIndex] = x;
        this.positions[posIndex + 1] = y;
        this.positions[posIndex + 2] = z;

        // Update velocity
        this.velocities[velIndex] = vx;
        this.velocities[velIndex + 1] = vy;
        this.velocities[velIndex + 2] = vz;

        // Update timing
        const now = Date.now();
        if (this.firstUpdateTime === 0) {
          this.firstUpdateTime = now;
        }
        this.lastUpdateTime = now;
      }
    },

    /**
     * Update from binary data
     */
    updateFromBinary(message: BinaryMessage): void {
      const dataView = new Float32Array(message.data);
      const nodeCount = dataView.length / 6; // 6 floats per node (x,y,z,vx,vy,vz)

      // Validate buffer size
      const expectedSize = nodeCount * BINARY_UPDATE_NODE_SIZE;
      if (message.data.byteLength !== expectedSize) {
        console.error('Invalid binary message size:', {
          received: message.data.byteLength,
          expected: expectedSize,
          nodeCount,
          timestamp: new Date().toISOString()
        });
        return;
      }

      // Resize arrays if needed
      if (this.nodeCount !== nodeCount) {
        this.positions = new Float32Array(nodeCount * 3);
        this.velocities = new Float32Array(nodeCount * 3);
        this.nodeCount = nodeCount;
      }

      // Process position and velocity data directly from binary
      for (let i = 0; i < nodeCount; i++) {
        const srcOffset = i * 6;
        const posOffset = i * 3;
        const velOffset = i * 3;

        let x = dataView[srcOffset];
        let y = dataView[srcOffset + 1];
        let z = dataView[srcOffset + 2];
        let vx = dataView[srcOffset + 3];
        let vy = dataView[srcOffset + 4];
        let vz = dataView[srcOffset + 5];

        if (ENABLE_POSITION_VALIDATION) {
          // Validate and clamp values
          const positionsValid = [x, y, z].every(v => this._validatePosition(v));
          const velocitiesValid = [vx, vy, vz].every(v => this._validateVelocity(v));

          if (!positionsValid || !velocitiesValid) {
            this.invalidUpdates++;
            if (ENABLE_BINARY_DEBUG) {
              console.warn('Invalid values in binary update:', {
                index: i,
                position: [x, y, z],
                velocity: [vx, vy, vz],
                timestamp: new Date().toISOString()
              });
            }

            // Clamp values
            x = this._clampPosition(x);
            y = this._clampPosition(y);
            z = this._clampPosition(z);
            vx = this._clampVelocity(vx);
            vy = this._clampVelocity(vy);
            vz = this._clampVelocity(vz);
          }
        }

        // Copy positions
        this.positions[posOffset] = x;
        this.positions[posOffset + 1] = y;
        this.positions[posOffset + 2] = z;

        // Copy velocities
        this.velocities[velOffset] = vx;
        this.velocities[velOffset + 1] = vy;
        this.velocities[velOffset + 2] = vz;
      }
      
      // Update timing
      const now = Date.now();
      if (this.firstUpdateTime === 0) {
        this.firstUpdateTime = now;
      }
      this.lastUpdateTime = now;

      // Debug logging
      if (ENABLE_BINARY_DEBUG && nodeCount > 0) {
        console.debug('Binary update processed:', {
          nodeCount,
          invalidRate: this.invalidUpdateRate,
          updateFrequency: this.updateFrequency,
          sample: {
            position: [
              this.positions[0],
              this.positions[1],
              this.positions[2]
            ],
            velocity: [
              this.velocities[0],
              this.velocities[1],
              this.velocities[2]
            ]
          },
          timestamp: new Date().toISOString()
        });
      }
    },

    /**
     * Clear all position data
     */
    clear(): void {
      this.positions = new Float32Array(0);
      this.velocities = new Float32Array(0);
      this.nodeCount = 0;
      this.firstUpdateTime = 0;
      this.lastUpdateTime = 0;
      this.invalidUpdates = 0;
    }
  }
})

----
stores/visualization.ts
import { defineStore } from 'pinia'
import type { 
  Node, 
  Edge, 
  GraphNode,
  GraphEdge,
  GraphData,
  FisheyeSettings as CoreFisheyeSettings, 
  PhysicsSettings as CorePhysicsSettings,
  MaterialSettings as CoreMaterialSettings,
  BloomSettings as CoreBloomSettings
} from '../types/core'
import type {
  VisualizationConfig,
  BloomConfig,
  FisheyeConfig
} from '../types/components'
import {
  DEFAULT_VISUALIZATION_CONFIG,
  DEFAULT_BLOOM_CONFIG,
  DEFAULT_FISHEYE_CONFIG
} from '../types/components'

interface VisualizationState {
  nodes: Node[]
  edges: Edge[]
  graphData: GraphData | null
  selectedNode: null | Node
  metadata: Record<string, any>
  visualConfig: VisualizationConfig
  bloomConfig: BloomConfig
  fisheyeConfig: FisheyeConfig
  initialized: boolean
}

export const useVisualizationStore = defineStore('visualization', {
  state: (): VisualizationState => ({
    nodes: [],
    edges: [],
    graphData: null,
    selectedNode: null,
    metadata: {},
    visualConfig: { ...DEFAULT_VISUALIZATION_CONFIG },
    bloomConfig: { ...DEFAULT_BLOOM_CONFIG },
    fisheyeConfig: { ...DEFAULT_FISHEYE_CONFIG },
    initialized: false
  }),

  getters: {
    getNodeById: (state) => (id: string) => {
      return state.nodes.find(node => node.id === id)
    },

    getEdgesByNodeId: (state) => (nodeId: string) => {
      return state.edges.filter(edge => 
        edge.source === nodeId || edge.target === nodeId
      )
    },

    getGraphData: (state): GraphData | null => state.graphData,
    getVisualizationSettings: (state): VisualizationConfig => state.visualConfig,
    getBloomSettings: (state): BloomConfig => state.bloomConfig,
    getFisheyeSettings: (state): FisheyeConfig => state.fisheyeConfig,
    isInitialized: (state): boolean => state.initialized
  },

  actions: {
    mergeGraphData(serverData: GraphData) {
      console.debug('[VisualizationStore] Merging server graph data:', {
        serverNodes: serverData.nodes.length,
        serverEdges: serverData.edges.length,
        localNodes: this.nodes.length,
        localEdges: this.edges.length,
        timestamp: new Date().toISOString()
      });

      // Create maps for quick lookups
      const localNodeMap = new Map(this.nodes.map(node => [node.id, node]));
      const serverNodeMap = new Map(serverData.nodes.map(node => [node.id, node]));

      // Merge nodes, preserving local positions for existing nodes
      const mergedNodes = serverData.nodes.map(serverNode => {
        const localNode = localNodeMap.get(serverNode.id);
        if (localNode) {
          // Preserve local position and velocity if they exist
          return {
            ...serverNode,
            position: localNode.position || serverNode.position,
            velocity: localNode.velocity || serverNode.velocity
          };
        }
        return serverNode;
      });

      // Convert edges and update with merged nodes
      const mergedEdges = serverData.edges.map(edge => ({
        ...edge,
        id: `${edge.source}-${edge.target}`
      }));

      // Update store with merged data
      this.setGraphData(mergedNodes, mergedEdges, serverData.metadata);

      console.debug('[VisualizationStore] Graph data merge complete:', {
        mergedNodes: mergedNodes.length,
        mergedEdges: mergedEdges.length,
        timestamp: new Date().toISOString()
      });
    },

    setGraphData(nodes: Node[], edges: Edge[], metadata: Record<string, any> = {}) {
      console.debug('[VisualizationStore] Setting graph data:', {
        nodeCount: nodes.length,
        edgeCount: edges.length,
        metadataKeys: Object.keys(metadata),
        timestamp: new Date().toISOString(),
        initialized: this.initialized,
        sampleNodes: nodes.slice(0, 3).map(n => ({
          id: n.id,
          position: n.position,
          hasPosition: !!n.position,
          velocity: n.velocity,
          hasVelocity: !!n.velocity
        }))
      })

      // Validate node positions
      const nodesWithoutPosition = nodes.filter(n => !n.position)
      if (nodesWithoutPosition.length > 0) {
        console.warn('[VisualizationStore] Nodes missing position data:', {
          count: nodesWithoutPosition.length,
          sampleIds: nodesWithoutPosition.slice(0, 3).map(n => n.id),
          timestamp: new Date().toISOString()
        })
      }

      // Convert to graph data structure
      const graphNodes = nodes.map(node => ({
        ...node,
        edges: [],
        weight: node.weight || 1
      })) as GraphNode[]

      // Create node lookup for edge processing
      const nodeLookup = new Map<string, GraphNode>()
      graphNodes.forEach(node => nodeLookup.set(node.id, node))

      console.debug('[VisualizationStore] Node lookup created:', {
        lookupSize: nodeLookup.size,
        sampleEntries: Array.from(nodeLookup.entries()).slice(0, 3).map(([id, node]) => ({
          id,
          position: node.position,
          hasPosition: !!node.position,
          velocity: node.velocity,
          hasVelocity: !!node.velocity
        }))
      })

      // Track edge connection stats
      let missingSourceCount = 0
      let missingTargetCount = 0
      let validEdgeCount = 0

      // Convert edges and link to nodes
      const graphEdges = edges.map(edge => {
        const sourceNode = nodeLookup.get(edge.source)
        const targetNode = nodeLookup.get(edge.target)
        
        if (!sourceNode || !targetNode) {
          if (!sourceNode) missingSourceCount++
          if (!targetNode) missingTargetCount++
          
          console.warn('[VisualizationStore] Edge references missing node:', {
            edge: `${edge.source}-${edge.target}`,
            hasSource: !!sourceNode,
            hasTarget: !!targetNode,
            timestamp: new Date().toISOString()
          })
          return null
        }

        validEdgeCount++
        const graphEdge: GraphEdge = {
          ...edge,
          sourceNode,
          targetNode,
          directed: edge.directed || false
        }
        sourceNode.edges.push(graphEdge)
        targetNode.edges.push(graphEdge)
        return graphEdge
      }).filter((edge): edge is GraphEdge => edge !== null)

      console.debug('[VisualizationStore] Edge processing complete:', {
        totalEdges: edges.length,
        validEdges: validEdgeCount,
        missingSourceNodes: missingSourceCount,
        missingTargetNodes: missingTargetCount,
        timestamp: new Date().toISOString()
      })

      console.debug('[VisualizationStore] Graph data transformation complete:', {
        originalNodes: nodes.length,
        originalEdges: edges.length,
        transformedNodes: graphNodes.length,
        transformedEdges: graphEdges.length,
        nodesWithoutPosition: nodesWithoutPosition.length,
        sampleGraphNode: graphNodes[0] ? {
          id: graphNodes[0].id,
          edgeCount: graphNodes[0].edges.length,
          position: graphNodes[0].position,
          hasPosition: !!graphNodes[0].position,
          velocity: graphNodes[0].velocity,
          hasVelocity: !!graphNodes[0].velocity
        } : null,
        timestamp: new Date().toISOString()
      })

      // Store the data
      this.nodes = nodes
      this.edges = edges
      this.metadata = metadata
      this.graphData = {
        nodes: graphNodes,
        edges: graphEdges,
        metadata
      }
      this.initialized = true

      // Log final state
      console.debug('[VisualizationStore] Graph data state after update:', {
        storeNodes: this.nodes.length,
        storeEdges: this.edges.length,
        graphDataNodes: this.graphData.nodes.length,
        graphDataEdges: this.graphData.edges.length,
        initialized: this.initialized,
        timestamp: new Date().toISOString()
      })
    },

    updateNode(nodeId: string, updates: Partial<Node>) {
      console.debug('[VisualizationStore] Updating node:', {
        nodeId,
        updates,
        hasPosition: !!updates.position,
        hasVelocity: !!updates.velocity,
        timestamp: new Date().toISOString()
      })

      const index = this.nodes.findIndex(n => n.id === nodeId)
      if (index !== -1) {
        this.nodes[index] = { ...this.nodes[index], ...updates }
        
        // Update graph data if it exists
        if (this.graphData) {
          const graphNodeIndex = this.graphData.nodes.findIndex(n => n.id === nodeId)
          if (graphNodeIndex !== -1) {
            const graphNode = this.graphData.nodes[graphNodeIndex]
            this.graphData.nodes[graphNodeIndex] = {
              ...graphNode,
              ...updates,
              edges: graphNode.edges // Preserve edges array
            } as GraphNode

            console.debug('[VisualizationStore] Graph node updated:', {
              nodeId,
              position: updates.position,
              hasPosition: !!updates.position,
              velocity: updates.velocity,
              hasVelocity: !!updates.velocity,
              edgeCount: graphNode.edges.length,
              timestamp: new Date().toISOString()
            })
          }
        }
      } else {
        console.warn('[VisualizationStore] Node not found for update:', {
          nodeId,
          timestamp: new Date().toISOString()
        })
      }
    },

    updateNodePositions(updates: { id: string; position: [number, number, number]; velocity?: [number, number, number] }[]) {
      console.debug('[VisualizationStore] Batch updating node positions:', {
        updateCount: updates.length,
        timestamp: new Date().toISOString(),
        sampleUpdates: updates.slice(0, 3).map(u => ({
          id: u.id,
          position: u.position,
          hasVelocity: !!u.velocity
        }))
      })

      let updatedCount = 0
      let skippedCount = 0
      let missingPositionCount = 0

      updates.forEach(update => {
        if (!update.position) {
          missingPositionCount++
          return
        }

        const node = this.nodes.find(n => n.id === update.id)
        if (node) {
          // Update position and velocity directly (already scaled)
          node.position = update.position
          if (update.velocity) {
            node.velocity = update.velocity
          }

          // Update graph data if it exists
          if (this.graphData) {
            const graphNode = this.graphData.nodes.find(n => n.id === update.id)
            if (graphNode) {
              graphNode.position = node.position
              if (update.velocity) {
                graphNode.velocity = node.velocity
              }
              updatedCount++
            }
          }
        } else {
          skippedCount++
        }
      })

      console.debug('[VisualizationStore] Node position updates complete:', {
        totalUpdates: updates.length,
        successfulUpdates: updatedCount,
        skippedUpdates: skippedCount,
        missingPositions: missingPositionCount,
        timestamp: new Date().toISOString()
      })
    },

    updateVisualizationSettings(settings: Partial<VisualizationConfig>) {
      console.debug('[VisualizationStore] Updating visualization settings:', {
        oldSettings: this.visualConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      })
      this.visualConfig = {
        ...this.visualConfig,
        ...settings
      }
    },

    updateBloomSettings(settings: Partial<BloomConfig>) {
      console.debug('[VisualizationStore] Updating bloom settings:', {
        oldSettings: this.bloomConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      })
      this.bloomConfig = {
        ...this.bloomConfig,
        ...settings
      }
    },

    updateFisheyeSettings(settings: Partial<FisheyeConfig>) {
      console.debug('[VisualizationStore] Updating fisheye settings:', {
        oldSettings: this.fisheyeConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      })
      
      if ('focusPoint' in settings) {
        const [focus_x, focus_y, focus_z] = settings.focusPoint as [number, number, number]
        this.fisheyeConfig = {
          ...this.fisheyeConfig,
          ...settings,
          focus_x,
          focus_y,
          focus_z
        }
      } else {
        this.fisheyeConfig = {
          ...this.fisheyeConfig,
          ...settings
        }
      }
    },

    clear() {
      console.debug('[VisualizationStore] Clearing visualization store:', {
        nodeCount: this.nodes.length,
        edgeCount: this.edges.length,
        hasGraphData: !!this.graphData,
        wasInitialized: this.initialized,
        timestamp: new Date().toISOString()
      })
      
      this.nodes = []
      this.edges = []
      this.graphData = null
      this.selectedNode = null
      this.metadata = {}
      this.initialized = false
      
      // Reset settings to defaults
      this.visualConfig = { ...DEFAULT_VISUALIZATION_CONFIG }
      this.bloomConfig = { ...DEFAULT_BLOOM_CONFIG }
      this.fisheyeConfig = { ...DEFAULT_FISHEYE_CONFIG }
    }
  }
})

----
stores/settings.ts
import { defineStore } from 'pinia';
import type { 
  VisualizationConfig, 
  BloomConfig, 
  FisheyeConfig 
} from '../types/components';
import { 
  DEFAULT_VISUALIZATION_CONFIG,
  DEFAULT_BLOOM_CONFIG,
  DEFAULT_FISHEYE_CONFIG
} from '../types/components';

interface SettingsState {
  visualization: VisualizationConfig;
  bloom: BloomConfig;
  fisheye: FisheyeConfig;
  isDirty: boolean;
}

export const useSettingsStore = defineStore('settings', {
  state: (): SettingsState => ({
    visualization: { ...DEFAULT_VISUALIZATION_CONFIG },
    bloom: { ...DEFAULT_BLOOM_CONFIG },
    fisheye: { ...DEFAULT_FISHEYE_CONFIG },
    isDirty: false
  }),

  getters: {
    getVisualizationSettings: (state) => state.visualization,
    getBloomSettings: (state) => state.bloom,
    getFisheyeSettings: (state) => state.fisheye,
    hasUnsavedChanges: (state) => state.isDirty
  },

  actions: {
    updateVisualizationSettings(settings: Partial<VisualizationConfig>) {
      this.visualization = {
        ...this.visualization,
        ...settings
      };
      this.isDirty = true;
    },

    updateBloomSettings(settings: Partial<BloomConfig>) {
      this.bloom = {
        ...this.bloom,
        ...settings
      };
      this.isDirty = true;
    },

    updateFisheyeSettings(settings: Partial<FisheyeConfig>) {
      this.fisheye = {
        ...this.fisheye,
        ...settings
      };
      this.isDirty = true;
    },

    applyServerSettings(settings: {
      visualization?: Partial<VisualizationConfig>;
      bloom?: Partial<BloomConfig>;
      fisheye?: Partial<FisheyeConfig>;
    }) {
      if (settings.visualization) {
        this.visualization = {
          ...this.visualization,
          ...settings.visualization
        };
      }
      if (settings.bloom) {
        this.bloom = {
          ...this.bloom,
          ...settings.bloom
        };
      }
      if (settings.fisheye) {
        this.fisheye = {
          ...this.fisheye,
          ...settings.fisheye
        };
      }
      this.isDirty = false;
    },

    resetToDefaults() {
      this.visualization = { ...DEFAULT_VISUALIZATION_CONFIG };
      this.bloom = { ...DEFAULT_BLOOM_CONFIG };
      this.fisheye = { ...DEFAULT_FISHEYE_CONFIG };
      this.isDirty = true;
    },

    markSaved() {
      this.isDirty = false;
    }
  }
});

----
stores/websocket.ts
import { defineStore } from 'pinia'
import WebsocketService from '../services/websocketService'
import { useVisualizationStore } from './visualization'
import { useBinaryUpdateStore } from './binaryUpdate'
import type { BaseMessage, ErrorMessage, GraphUpdateMessage, BinaryMessage, Edge as WsEdge, SimulationModeMessage, InitialDataMessage } from '../types/websocket'
import type { Node, Edge } from '../types/core'

interface WebSocketState {
  connected: boolean
  error: string | null
  service: WebsocketService | null
  lastMessageTime: number
  messageCount: number
  queueSize: number
  connectionAttempts: number
  lastReconnectTime: number
  gpuEnabled: boolean
  initialDataRequested: boolean
  performanceMetrics: {
    avgMessageProcessingTime: number
    messageProcessingSamples: number[]
    avgPositionUpdateTime: number
    positionUpdateSamples: number[]
    lastPerformanceReset: number
  }
}

const MAX_PERFORMANCE_SAMPLES = 100;
const PERFORMANCE_RESET_INTERVAL = 60000; // Reset metrics every minute

export const useWebSocketStore = defineStore('websocket', {
  state: (): WebSocketState => ({
    connected: false,
    error: null,
    service: null,
    lastMessageTime: 0,
    messageCount: 0,
    queueSize: 0,
    connectionAttempts: 0,
    lastReconnectTime: 0,
    gpuEnabled: false,
    initialDataRequested: false,
    performanceMetrics: {
      avgMessageProcessingTime: 0,
      messageProcessingSamples: [],
      avgPositionUpdateTime: 0,
      positionUpdateSamples: [],
      lastPerformanceReset: Date.now()
    }
  }),

  getters: {
    isConnected: (state) => state.connected,
    hasError: (state) => state.error !== null,
    connectionHealth: (state) => {
      if (!state.connected) return 'disconnected'
      if (state.error) return 'error'
      if (state.connectionAttempts > 0) return 'unstable'
      return 'healthy'
    },
    performanceStatus: (state) => {
      const { avgMessageProcessingTime, avgPositionUpdateTime } = state.performanceMetrics
      if (avgMessageProcessingTime > 100 || avgPositionUpdateTime > 16) return 'poor'
      if (avgMessageProcessingTime > 50 || avgPositionUpdateTime > 8) return 'fair'
      return 'good'
    },
    isGPUEnabled: (state) => state.gpuEnabled
  },

  actions: {
    async initialize() {
      console.debug('[WebSocketStore] Initializing websocket store')
      if (this.service) {
        console.log('[WebSocketStore] WebSocket service already initialized')
        return
      }

      const visualizationStore = useVisualizationStore()
      const binaryUpdateStore = useBinaryUpdateStore()

      this.service = new WebsocketService()
      
      this._setupEventHandlers(visualizationStore, binaryUpdateStore)
      
      try {
        console.debug('[WebSocketStore] Attempting to connect websocket')
        await this.service.connect()
      } catch (error) {
        this._handleConnectionError(error)
        throw error
      }
    },

    _setupEventHandlers(visualizationStore: any, binaryUpdateStore: any) {
      if (!this.service) return

      this.service.on('open', () => {
        console.debug('[WebSocketStore] WebSocket connected, connection state:', {
          connected: this.connected,
          initialDataRequested: this.initialDataRequested,
          connectionAttempts: this.connectionAttempts
        })
        this.connected = true
        this.error = null
        this.connectionAttempts = 0
        if (!this.initialDataRequested) {
          this.requestInitialData()
        }
      })

      this.service.on('close', () => {
        console.debug('[WebSocketStore] WebSocket closed')
        this.connected = false
        this._handleDisconnect()
      })

      this.service.on('error', (error: ErrorMessage) => {
        this._handleError(error)
      })

      this.service.on('maxReconnectAttemptsReached', () => {
        this._handleMaxReconnectAttempts()
      })

      this.service.on('initialData', (message: InitialDataMessage) => {
        const startTime = performance.now()
        console.debug('[WebSocketStore] Received initial data message:', {
          type: message.type,
          hasGraphData: !!message.graphData,
          hasSettings: !!message.settings,
          timestamp: new Date().toISOString()
        })
        
        try {
          this._handleGraphUpdate(message, visualizationStore)
          if (message.settings) {
            visualizationStore.updateVisualizationSettings(message.settings)
          }
        } catch (error) {
          console.error('[WebSocketStore] Error processing initial data:', error)
        }

        this._updateMessageProcessingMetrics(performance.now() - startTime)
      })

      this.service.on('graphUpdate', (message: GraphUpdateMessage) => {
        const startTime = performance.now()
        console.debug('[WebSocketStore] Received graph update message:', {
          type: message.type,
          hasGraphData: !!message.graphData,
          timestamp: new Date().toISOString()
        })
        
        try {
          this._handleGraphUpdate(message, visualizationStore)
        } catch (error) {
          console.error('[WebSocketStore] Error processing graph update:', error)
        }

        this._updateMessageProcessingMetrics(performance.now() - startTime)
      })

      this.service.on('gpuPositions', (message: BinaryMessage) => {
        const startTime = performance.now()
        
        try {
          console.debug('[WebSocketStore] Processing GPU positions update:', {
            dataSize: message.data.byteLength,
            nodeCount: message.nodeCount,
            timestamp: new Date().toISOString()
          })
          binaryUpdateStore.updateFromBinary(message)
        } catch (error) {
          console.error('[WebSocketStore] Error processing position update:', error)
        }

        this._updatePositionUpdateMetrics(performance.now() - startTime)
      })

      // Handle simulation mode changes
      this.service.on('simulationModeSet', (mode: string) => {
        console.debug('[WebSocketStore] Setting simulation mode:', mode)
        visualizationStore.setSimulationMode(mode)
      })

      // Handle all messages to catch GPU state updates
      this.service.on('message', (message: BaseMessage) => {
        console.debug('[WebSocketStore] Received message:', {
          type: message.type,
          timestamp: new Date().toISOString()
        })
        
        if (message.type === 'gpuState' && 'enabled' in message) {
          this.gpuEnabled = message.enabled
          console.debug(`[WebSocketStore] GPU acceleration ${message.enabled ? 'enabled' : 'disabled'}`)
        }
      })
    },

    _handleGraphUpdate(message: GraphUpdateMessage | InitialDataMessage, visualizationStore: any) {
      console.debug('[WebSocketStore] Processing graph update:', {
        nodeCount: message.graphData?.nodes?.length || 0,
        edgeCount: message.graphData?.edges?.length || 0,
        hasMetadata: !!message.graphData?.metadata,
        timestamp: new Date().toISOString()
      })

      if (!message.graphData) {
        console.warn('[WebSocketStore] No graph data found in message')
        return
      }

      console.debug('[WebSocketStore] Graph data details:', {
        nodes: message.graphData.nodes?.map(n => ({ id: n.id, hasPosition: !!n.position })) || [],
        edges: message.graphData.edges?.map(e => ({ source: e.source, target: e.target })) || [],
        metadata: message.graphData.metadata
      })

      const edges: Edge[] = message.graphData.edges.map((edge: WsEdge) => ({
        ...edge,
        id: `${edge.source}-${edge.target}`
      }))

      visualizationStore.setGraphData(
        message.graphData.nodes as Node[],
        edges,
        message.graphData.metadata
      )
    },

    _handleConnectionError(error: unknown) {
      console.error('[WebSocketStore] Connection error:', error)
      this.error = error instanceof Error ? error.message : 'Unknown connection error'
      this.connectionAttempts++
      this.lastReconnectTime = Date.now()
    },

    _handleError(error: ErrorMessage) {
      this.error = error.message || 'Unknown error'
      if (error.code) {
        console.error(`[WebSocketStore] WebSocket error [${error.code}]:`, this.error)
      } else {
        console.error('[WebSocketStore] WebSocket error:', this.error)
      }
      if (error.details) {
        console.debug('[WebSocketStore] Error details:', error.details)
      }
    },

    _handleDisconnect() {
      const timeSinceLastReconnect = Date.now() - this.lastReconnectTime
      
      if (timeSinceLastReconnect > 60000) { // Reset counter if more than 1 minute since last reconnect
        this.connectionAttempts = 0
      }
      
      this.connectionAttempts++
      console.debug('[WebSocketStore] Handling disconnect:', {
        connectionAttempts: this.connectionAttempts,
        timeSinceLastReconnect,
        timestamp: new Date().toISOString()
      })
    },

    _handleMaxReconnectAttempts() {
      this.error = 'Maximum reconnection attempts reached. Please refresh the page.'
      console.error('[WebSocketStore] Max reconnection attempts reached')
    },

    _updateMessageProcessingMetrics(processingTime: number) {
      this._updateMetrics('message', processingTime)
    },

    _updatePositionUpdateMetrics(processingTime: number) {
      this._updateMetrics('position', processingTime)
    },

    _updateMetrics(type: 'message' | 'position', processingTime: number) {
      const metrics = this.performanceMetrics
      const now = Date.now()

      // Reset metrics if needed
      if (now - metrics.lastPerformanceReset > PERFORMANCE_RESET_INTERVAL) {
        metrics.messageProcessingSamples = []
        metrics.positionUpdateSamples = []
        metrics.lastPerformanceReset = now
      }

      if (type === 'message') {
        metrics.messageProcessingSamples.push(processingTime)
        if (metrics.messageProcessingSamples.length > MAX_PERFORMANCE_SAMPLES) {
          metrics.messageProcessingSamples.shift()
        }
        metrics.avgMessageProcessingTime = 
          metrics.messageProcessingSamples.reduce((a, b) => a + b, 0) / 
          metrics.messageProcessingSamples.length
      } else {
        metrics.positionUpdateSamples.push(processingTime)
        if (metrics.positionUpdateSamples.length > MAX_PERFORMANCE_SAMPLES) {
          metrics.positionUpdateSamples.shift()
        }
        metrics.avgPositionUpdateTime = 
          metrics.positionUpdateSamples.reduce((a, b) => a + b, 0) / 
          metrics.positionUpdateSamples.length
      }
    },

    send(data: any) {
      if (!this.service) {
        console.error('[WebSocketStore] Cannot send message: WebSocket service not initialized')
        return
      }
      console.debug('[WebSocketStore] Sending message:', {
        type: data.type,
        timestamp: new Date().toISOString()
      })
      this.messageCount++
      this.lastMessageTime = Date.now()
      this.service.send(data)
    },

    sendBinary(data: ArrayBuffer) {
      if (!this.service) {
        console.error('[WebSocketStore] Cannot send binary data: WebSocket service not initialized')
        return
      }
      console.debug('[WebSocketStore] Sending binary data:', {
        size: data.byteLength,
        timestamp: new Date().toISOString()
      })
      this.messageCount++
      this.lastMessageTime = Date.now()
      this.service.sendBinary(data)
    },

    requestInitialData() {
      console.debug('[WebSocketStore] Requesting initial graph data')
      this.initialDataRequested = true
      this.send({ type: 'initialData' })
    },

    async reconnect() {
      console.debug('[WebSocketStore] Attempting reconnection')
      // Reset initialDataRequested before cleanup
      this.initialDataRequested = false
      if (this.service) {
        this.service.cleanup()
        this.service = null
      }
      await this.initialize()
    },

    cleanup() {
      console.debug('[WebSocketStore] Cleaning up websocket store')
      if (this.service) {
        this.service.cleanup()
        this.service = null
      }
      this.connected = false
      this.error = null
      this.lastMessageTime = 0
      this.messageCount = 0
      this.queueSize = 0
      this.connectionAttempts = 0
      this.lastReconnectTime = 0
      this.gpuEnabled = false
      // Reset initialDataRequested to ensure we request data on reconnect
      this.initialDataRequested = false
      this.performanceMetrics = {
        avgMessageProcessingTime: 0,
        messageProcessingSamples: [],
        avgPositionUpdateTime: 0,
        positionUpdateSamples: [],
        lastPerformanceReset: Date.now()
      }
    }
  }
})

--END--