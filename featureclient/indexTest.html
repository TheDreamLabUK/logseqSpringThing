<!DOCTYPE html>
<html>
<head>
    <title>Graph Data Test Client</title>
    <style>
        #output {
            white-space: pre-wrap;
            font-family: monospace;
            margin: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            max-height: 500px;
            overflow: auto;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .received { color: blue; }
        .sent { color: green; }
        .error { color: red; }
        #stats {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #fff;
            padding: 10px;
            border: 1px solid #ccc;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: #fff;
            padding: 10px;
            border: 1px solid #ccc;
        }
        #rawData {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: #000;
            color: #0f0;
            padding: 10px;
            border: 1px solid #0f0;
            font-family: monospace;
            width: 300px;
            height: 200px;
            overflow: auto;
        }
        .coordinate {
            margin: 2px 0;
            font-size: 12px;
        }
        .node-id { color: #ff0; }
        .coord-x { color: #f00; }
        .coord-y { color: #0f0; }
        .coord-z { color: #00f; }
        .velocity {
            color: #888;
            font-size: 10px;
        }
        #debugInfo {
            position: fixed;
            top: 80px;
            right: 10px;
            background: #fff;
            padding: 10px;
            border: 1px solid #ccc;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <select id="endpoint">
            <option value="wss://www.visionflow.info/wss">Production</option>
            <option value="ws://192.168.0.51:4000/wss">Dev (192.168.0.51:4000)</option>
            <option value="ws://localhost:4000/wss">Local (localhost:4000)</option>
        </select>
        <button onclick="connect()">Connect</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>
    <div id="stats">
        FPS: <span id="fpsCounter">0</span><br>
        Updates: <span id="updateCounter">0</span><br>
        Status: <span id="connectionStatus">Disconnected</span>
    </div>
    <div id="debugInfo">
        Ready State: <span id="readyState">CLOSED</span><br>
        Last Error: <span id="lastError">None</span>
    </div>
    <div id="rawData">
        <div style="border-bottom: 1px solid #0f0; margin-bottom: 5px;">Raw Node Coordinates</div>
        <div id="coordinates"></div>
    </div>
    <div id="output"></div>

    <script>
        // DOM Elements
        const output = document.getElementById('output');
        const fpsCounter = document.getElementById('fpsCounter');
        const updateCounter = document.getElementById('updateCounter');
        const connectionStatus = document.getElementById('connectionStatus');
        const endpointSelect = document.getElementById('endpoint');
        const coordinates = document.getElementById('coordinates');
        const readyStateSpan = document.getElementById('readyState');
        const lastErrorSpan = document.getElementById('lastError');
        
        // State variables
        let ws = null;
        let updateInterval = null;
        let currentNodes = [];
        let animationStartTime = null;
        let animationRadius = 2.0;
        let animationSpeed = 0.5;
        let reconnectAttempts = 0;
        let lastUpdateTime = performance.now();
        let updateCount = 0;
        let totalUpdates = 0;
        
        // Constants
        const MAX_RECONNECT_ATTEMPTS = 3;
        const TARGET_FPS = 5;
        const FPS_WINDOW_SIZE = 10;
        const fpsWindow = [];
        const READY_STATE_NAMES = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];

        // Utility Functions
        function log(message, type = 'received') {
            const div = document.createElement('div');
            div.className = `message ${type}`;
            const timestamp = new Date().toISOString();
            div.textContent = `${timestamp} - ${message}`;
            output.appendChild(div);
            
            while (output.children.length > 100) {
                output.removeChild(output.firstChild);
            }
            
            output.scrollTop = output.scrollHeight;
        }

        function updateReadyState() {
            if (ws) {
                readyStateSpan.textContent = READY_STATE_NAMES[ws.readyState];
            } else {
                readyStateSpan.textContent = 'NO CONNECTION';
            }
        }

        function setError(error) {
            lastErrorSpan.textContent = error;
            console.error(error);
        }

        function safeSend(data) {
            try {
                if (!ws) {
                    throw new Error('No WebSocket connection');
                }
                if (ws.readyState !== WebSocket.OPEN) {
                    throw new Error(`WebSocket not open (state: ${READY_STATE_NAMES[ws.readyState]})`);
                }
                
                const message = typeof data === 'string' ? data : JSON.stringify(data);
                ws.send(message);
                return true;
            } catch (error) {
                setError(`Send failed: ${error.message}`);
                return false;
            }
        }

        function updateFPS() {
            const now = performance.now();
            const timeDiff = now - lastUpdateTime;
            const fps = 1000 / timeDiff;
            
            fpsWindow.push(fps);
            if (fpsWindow.length > FPS_WINDOW_SIZE) {
                fpsWindow.shift();
            }
            
            const avgFps = fpsWindow.reduce((a, b) => a + b, 0) / fpsWindow.length;
            fpsCounter.textContent = avgFps.toFixed(2);
            updateCounter.textContent = totalUpdates;
            
            lastUpdateTime = now;
        }

        function updateRawCoordinates(floatArray) {
            const nodeCount = (floatArray.length - 1) / 6; // Subtract 1 for version header
            let html = '';
            
            for (let i = 0; i < nodeCount; i++) {
                const baseIndex = 1 + i * 6; // Skip version header
                const x = floatArray[baseIndex];
                const y = floatArray[baseIndex + 1];
                const z = floatArray[baseIndex + 2];
                const vx = floatArray[baseIndex + 3];
                const vy = floatArray[baseIndex + 4];
                const vz = floatArray[baseIndex + 5];
                
                html += `
                    <div class="coordinate">
                        <span class="node-id">Node ${i}:</span> 
                        (<span class="coord-x">${x.toFixed(3)}</span>, 
                         <span class="coord-y">${y.toFixed(3)}</span>, 
                         <span class="coord-z">${z.toFixed(3)}</span>)
                        <div class="velocity">v: (${vx.toFixed(3)}, ${vy.toFixed(3)}, ${vz.toFixed(3)})</div>
                    </div>`;
            }
            
            coordinates.innerHTML = html;
        }

        function updateNodePosition() {
            if (!animationStartTime) {
                animationStartTime = performance.now();
            }

            const elapsedTime = (performance.now() - animationStartTime) / 1000;
            const angle = elapsedTime * Math.PI * 2 * animationSpeed;

            if (currentNodes.length > 0) {
                const node = currentNodes[0];
                node.position = [
                    Math.cos(angle) * animationRadius,
                    Math.sin(angle) * animationRadius,
                    0
                ];
                
                if (Math.floor(elapsedTime) > Math.floor((elapsedTime - 0.2))) {
                    log(`Node position: (${node.position.map(p => p.toFixed(2)).join(', ')})`, 'sent');
                }
            }
        }

        function startUpdateInterval() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }

            setTimeout(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    log('Starting position animation', 'sent');
                    animationStartTime = performance.now();
                }
            }, 3000);

            updateInterval = setInterval(() => {
                updateReadyState();
                
                if (ws && ws.readyState === WebSocket.OPEN && animationStartTime) {
                    updateNodePosition();

                    const updateMsg = {
                        type: 'updatePositions',
                        nodes: currentNodes.map(node => ({
                            id: node.id,
                            position: node.position || [0, 0, 0]
                        }))
                    };
                    safeSend(updateMsg);
                }
            }, 200);
        }

        function disconnect() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
            connectionStatus.textContent = 'Disconnected';
            log('Manually disconnected', 'sent');
            animationStartTime = null;
            coordinates.innerHTML = '';
            updateReadyState();
            reconnectAttempts = 0;
        }

        function connect() {
            disconnect();

            const wsUrl = endpointSelect.value;
            log(`Connecting to ${wsUrl}`, 'sent');
            connectionStatus.textContent = 'Connecting...';
            
            try {
                ws = new WebSocket(wsUrl);
                updateReadyState();

                ws.onopen = () => {
                    connectionStatus.textContent = 'Connected';
                    log('Connected to server', 'sent');
                    updateReadyState();
                    reconnectAttempts = 0;
                    
                    if (!safeSend({ type: 'initialData' })) {
                        disconnect();
                        return;
                    }
                    log('Requested initial data', 'sent');
                };

                ws.onmessage = (event) => {
                    if (event.data instanceof Blob) {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const buffer = reader.result;
                            const floatArray = new Float32Array(buffer);
                            const nodeCount = (floatArray.length - 1) / 6;
                            
                            totalUpdates++;
                            updateFPS();
                            updateRawCoordinates(floatArray);
                            
                            if (totalUpdates % 5 === 0) {
                                const currentFps = fpsCounter.textContent;
                                log(`Position update #${totalUpdates}: ${nodeCount} nodes, Current FPS: ${currentFps}`);
                            }
                        };
                        reader.readAsArrayBuffer(event.data);
                    } else {
                        try {
                            const message = JSON.parse(event.data);
                            log(`Received message type: ${message.type}`);
                            
                            if (message.type === 'initialData') {
                                currentNodes = message.graphData.nodes;
                                log(`Graph data: ${message.graphData.nodes.length} nodes, ${message.graphData.edges.length} edges`);
                                
                                if (!safeSend({ type: 'enableBinaryUpdates' })) {
                                    disconnect();
                                    return;
                                }
                                log('Enabled binary updates', 'sent');
                                startUpdateInterval();
                            } else if (message.type === 'binaryPositionUpdate') {
                                log('Binary position update incoming');
                            }
                        } catch (error) {
                            setError(`Failed to parse message: ${error.message}`);
                        }
                    }
                };

                ws.onerror = (error) => {
                    connectionStatus.textContent = 'Error';
                    setError(`WebSocket error: ${error.message || 'Unknown error'}`);
                    updateReadyState();
                };

                ws.onclose = (event) => {
                    connectionStatus.textContent = 'Disconnected';
                    log(`Disconnected from server (code: ${event.code}, reason: ${event.reason || 'none'})`, 'error');
                    
                    if (updateInterval) {
                        clearInterval(updateInterval);
                        updateInterval = null;
                    }
                    
                    ws = null;
                    animationStartTime = null;
                    coordinates.innerHTML = '';
                    updateReadyState();

                    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        log(`Reconnecting (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'sent');
                        setTimeout(connect, 2000);
                    } else {
                        setError('Max reconnection attempts reached');
                    }
                };
            } catch (error) {
                setError(`Failed to create WebSocket: ${error.message}`);
                connectionStatus.textContent = 'Error';
                updateReadyState();
            }
        }

        // Initialize
        updateReadyState();
    </script>
</body>
</html>
