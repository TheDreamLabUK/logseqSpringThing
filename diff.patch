diff --git a/Dockerfile b/Dockerfile
index 416cb6b6..dcb25ddd 100755
--- a/Dockerfile
+++ b/Dockerfile
@@ -55,6 +55,12 @@ RUN mkdir src && \
 
 # Now copy the real source code and build
 COPY src ./src
+
+# Compile CUDA kernel to PTX
+RUN nvcc -ptx src/utils/compute_forces.cu -o compute_forces.ptx && \
+    mv compute_forces.ptx src/utils/compute_forces.ptx
+
+# Build Rust application
 RUN cargo build --release --jobs $(nproc) || \
     (sleep 2 && cargo build --release --jobs $(nproc)) || \
     (sleep 5 && cargo build --release --jobs 1)
@@ -174,7 +180,7 @@ RUN chown -R webxr:webxr /app/venv
 # Copy built artifacts
 COPY --from=rust-deps-builder /usr/src/app/target/release/webxr /app/
 COPY settings.toml /app/
-COPY src/utils/compute_forces.ptx /app/compute_forces.ptx
+COPY --from=rust-deps-builder /usr/src/app/src/utils/compute_forces.ptx /app/compute_forces.ptx
 COPY --from=frontend-builder /app/data/public/dist /app/data/public/dist
 
 # Copy configuration and scripts
diff --git a/README.md b/README.md
index 21e58373..013da3cc 100755
--- a/README.md
+++ b/README.md
@@ -11,6 +11,8 @@ https://github.com/trebornipsa
 
 This project visualizes a Logseq knowledge graph in 3D using WebXR, enhancing it with Perplexity AI and RAGFlow for AI-powered question answering. Changes are automatically submitted back to the source GitHub repository as pull requests. This allows for a dynamic and interactive exploration of your Logseq knowledge base in an immersive environment, leveraging the power of AI to provide context and insights.
 
+> **Note**: Settings are currently managed locally in the client for improved development and testing. Server-side settings synchronization is temporarily disabled and will be re-enabled in a future update.
+
 ## Key Features
 
 - **WebXR 3D Visualization:** Immersive exploration of the knowledge graph in AR/VR environments with support for:
@@ -22,11 +24,9 @@ This project visualizes a Logseq knowledge graph in 3D using WebXR, enhancing it
 - **Real-time Updates:**
   - **WebSocket-Based Communication:** Ensures instant synchronization between the server and client.
   - **Optimized Binary Protocol:** 
-    - Efficient quantized position updates (millimeter precision)
-    - Quantized velocity updates (0.0001 unit precision)
-    - Compact 28-byte format per node (4-byte header + 24 bytes position/velocity)
-  - **Automatic Graph Layout Recalculation:** Maintains an optimal layout as the graph evolves.
-  - **Live Preview of Changes:** Immediate reflection of updates from the knowledge base.
+    - Efficient position updates 
+    - velocity updates
+    - The binary protocol sends 6 floats per node (position + velocity).
 
 - **GPU Acceleration:**
   - **WebGPU Compute Shaders for Layout Calculation:** Utilizes GPU for high-performance graph computations.
@@ -71,24 +71,19 @@ This project visualizes a Logseq knowledge graph in 3D using WebXR, enhancing it
 The WebSocket binary protocol has been optimized for efficient position updates:
 
 ```
-[4 bytes] is_initial_layout flag (float32)
-For each node:
-  [12 bytes] Position (3 × int32, quantized to millimeter precision)
-  [12 bytes] Velocity (3 × int32, quantized to 0.0001 units)
+
 ```
 
 This format provides:
-- Minimal bandwidth usage through quantization
-- High precision where needed (millimeter-level positioning)
+- Minimal bandwidth usage 
+- High precision where needed 
 - Efficient parsing on both client and server
 - Clear distinction between initial and update messages
 
-[Previous architecture diagrams and sections remain unchanged...]
-
 ### Performance Optimizations
 
 - **Network Efficiency:**
-  - Quantized position and velocity values
+  - position and velocity values
   - Compact binary message format
   - Minimal protocol overhead
   - Efficient WebSocket streaming
@@ -135,8 +130,6 @@ graph TB
         SpeechS[Speech Service]
         WSManager[WebSocket Manager]
         GPUCompute[GPU Compute]
-        Compression[Compression Utils]
-        AudioProc[Audio Processor]
         Node[Node Model]
         Edge[Edge Model]
         Graph[Graph Model]
@@ -160,6 +153,7 @@ graph TB
     VR --> ThreeJS
     WS --> WSService
     WSService --> Server
+    SpaceMouse --> SceneManager
 
     Server --> FileH
     Server --> GraphH
@@ -173,11 +167,13 @@ graph TB
     WSH --> WSManager
     PerplexityH --> PerplexityS
     RagFlowH --> RagFlowS
+    WSH --> Compression[Compression Utils]
 
     FileS --> GitHub
     PerplexityS --> Perplexity
     RagFlowS --> RagFlow
     SpeechS --> OpenAI
+    SpeechS --> AudioProc[Audio Processor]
 
     style Frontend fill:#f9f,stroke:#333,stroke-width:2px
     style Backend fill:#bbf,stroke:#333,stroke-width:2px
@@ -188,358 +184,559 @@ graph TB
 
 ```mermaid
 classDiagram
-class App {
-    +websocketService: WebsocketService
-    +graphDataManager: GraphDataManager
-    +visualization: WebXRVisualization
-    +chatManager: ChatManager
-    +interface: Interface
-    +ragflowService: RAGFlowService
-    +start()
-    +initializeEventListeners()
-    +toggleFullscreen()
-}
-class WebsocketService {
-    +socket: WebSocket
-    +listeners: Object
-    +reconnectAttempts: number
-    +maxReconnectAttempts: number
-    +reconnectInterval: number
-    +connect()
-    +on(event: string, callback: function)
-    +emit(event: string, data: any)
-    +send(data: object)
-    +reconnect()
-}
-class GraphDataManager {
-    +websocketService: WebsocketService
-    +graphData: GraphData
-    +requestInitialData()
-    +updateGraphData(newData: GraphData)
-    +getGraphData(): GraphData
-    +recalculateLayout()
-    +updateForceDirectedParams(name: string, value: any)
-}
-class WebXRVisualization {
-    +graphDataManager: GraphDataManager
-    +scene: Scene
-    +camera: Camera
-    +renderer: Renderer
-    +controls: Controls
-    +composer: Composer
-    +gpu: GPUUtilities
-    +nodeMeshes: Map<string, Mesh>
-    +edgeMeshes: Map<string, Line>
-    +hologramGroup: Group
-    +initialize()
-    +updateVisualization()
-    +initThreeJS()
-    +setupGPU()
-    +initPostProcessing()
-    +addLights()
-    +createHologramStructure()
-    +handleSpacemouseInput(x: number, y: number, z: number)
-    +handleBinaryPositionUpdate(buffer: ArrayBuffer)
-    +animate()
-    +updateVisualFeatures(control: string, value: any)
-    +onWindowResize()
-    +handleNodeDrag(nodeId: string, position: Vector3)
-    +getNodePositions(): PositionUpdate[]
-    +showError(message: string)
-}
-class ChatManager {
-    +websocketService: WebsocketService
-    +ragflowService: RAGFlowService
-    +sendMessage(message: string)
-    +receiveMessage()
-    +handleIncomingMessage(message: string)
-}
-class Interface {
-    +chatManager: ChatManager
-    +visualization: WebXRVisualization
-    +handleUserInput(input: string)
-    +displayChatMessage(message: string)
-    +setupEventListeners()
-    +renderUI()
-    +updateNodeInfoPanel(node: object)
-    +displayErrorMessage(message: string)
-}
-class RAGFlowService {
-    +settings: Settings
-    +apiClient: ApiClient
-    +createConversation(userId: string): Promise<string>
-    +sendMessage(conversationId: string, message: string): Promise<string>
-    +getConversationHistory(conversationId: string): Promise<object>
-}
-class GraphService {
-    +build_graph(app_state: AppState): Result<GraphData, Error>
-    +calculate_layout(gpu_compute: GPUCompute, graph: GraphData, params: SimulationParams): Result<void, Error>
-    +initialize_random_positions(graph: GraphData)
-}
-class PerplexityService {
-    +process_file(file: ProcessedFile, settings: Settings, api_client: ApiClient): Result<ProcessedFile, Error>
-}
-class FileService {
-    +fetch_and_process_files(github_service: GitHubService, settings: Settings, metadata_map: Map<String, Metadata>): Result<Vec<ProcessedFile>, Error>
-    +load_or_create_metadata(): Result<Map<String, Metadata>, Error>
-    +save_metadata(metadata: Map<String, Metadata>): Result<void, Error>
-    +calculate_node_size(file_size: number): number
-    +extract_references(content: string, valid_nodes: String[]): Map<String, ReferenceInfo>
-    +convert_references_to_topic_counts(references: Map<String, ReferenceInfo>): Map<String, number>
-    +initialize_local_storage(github_service: GitHubService, settings: Settings): Result<void, Error>
-    +count_hyperlinks(content: string): number
-}
-class GitHubService {
-    +fetch_file_metadata(): Result<Vec<GithubFileMetadata>, Error>
-    +get_download_url(file_name: string): Result<string, Error>
-    +fetch_file_content(download_url: string): Result<string, Error>
-    +get_file_last_modified(file_path: string): Result<Date, Error>
-}
-class GitHubPRService {
-    +create_pull_request(file_name: string, content: string, original_sha: string): Result<string, Error>
-}
-class ApiClient {
-    +post_json(url: string, body: PerplexityRequest, perplexity_api_key: string): Result<string, Error>
-}
-class SpeechService {
-    +websocketManager: WebSocketManager
-    +settings: Settings
-    +start(receiver: Receiver<SpeechCommand>)
-    +initialize(): Result<void, Error>
-    +send_message(message: string): Result<void, Error>
-    +close(): Result<void, Error>
-    +set_tts_provider(use_openai: boolean): Result<void, Error>
-}
-class SpeechWs {
-    +websocketManager: WebSocketManager
-    +settings: Settings
-    +hb(ctx: Context)
-    +check_heartbeat(ctx: Context)
-    +started(ctx: Context)
-    +handle(msg: Message, ctx: Context)
-}
-
-App --> WebsocketService
-App --> GraphDataManager
-App --> WebXRVisualization
-App --> ChatManager
-App --> Interface
-App --> RAGFlowService
-App --> GraphService
-App --> PerplexityService
-App --> FileService
-App --> GitHubService
-App --> GitHubPRService
-App --> SpeechService
-WebsocketService --> GraphDataManager
-GraphDataManager --> WebXRVisualization
-ChatManager --> RAGFlowService
-Interface --> ChatManager
-Interface --> WebXRVisualization
-GraphService --> GPUCompute
-PerplexityService --> ApiClient
-FileService --> GitHubService
-GitHubPRService --> GitHubService
-SpeechService --> WebSocketManager
+    class App {
+        -platformManager: PlatformManager
+        -settingsManager: SettingsManager
+        -graphDataManager: GraphDataManager
+        -webSocketService: WebSocketService
+        -sceneManager: SceneManager
+        -nodeManager: NodeManager
+        -textRenderer: TextRenderer
+        -xrSessionManager: XRSessionManager
+        -xrInteraction: XRInteraction
+        -controlPanel: ControlPanel
+        +start()
+        +initializeEventListeners()
+        +toggleFullscreen()
+    }
+
+    class PlatformManager {
+        +getPlatform(): Platform
+        +isMobile(): boolean
+        +isDesktop(): boolean
+        +isQuest(): boolean
+        +supportsXR(): boolean
+        +supportsWebXR(): boolean
+        +supportsWebGPU(): boolean
+        +getWebXRFeatures(): string[]
+    }
+
+    class SettingsManager {
+        -settings: Settings
+        -defaultSettings: Settings
+        -subscribers: Map<string, Function[]>
+        +getCurrentSettings(): Settings
+        +getDefaultSettings(): Settings
+        +updateSetting(category: string, setting: string, value: any)
+        +subscribe(category: string, setting: string, callback: Function)
+        +dispose()
+    }
+
+    class GraphDataManager {
+        -nodes: Map<string, Node>
+        -edges: Map<string, Edge>
+        -listeners: Function[]
+        +updateGraphData(data: GraphData)
+        +updateNodePositions(positions: Float32Array)
+        +fetchGraphData(page: number, pageSize: number)
+        +fetchMoreNodes()
+        +enableBinaryUpdates()
+        +disableBinaryUpdates()
+        +dispose()
+    }
+
+    class WebSocketService {
+        -ws: WebSocket
+        -settings: WebSocketSettings
+        -reconnectTimeout: NodeJS.Timeout
+        -heartbeatTimer: NodeJS.Timeout
+        -lastPongTime: number
+        -reconnectAttempts: number
+        -binaryUpdateHandler: BinaryUpdateHandler
+        -isReconnecting: boolean
+        -messageHandlers: Map<MessageType, MessageHandler[]>
+        +connect()
+        +disconnect()
+        -handleOpen()
+        -handleClose()
+        -handleError()
+        -handleMessage(event: MessageEvent)
+        -sendHeartbeat()
+        -stopHeartbeat()
+        -cleanup()
+        -attemptReconnect()
+        +onMessage(type: MessageType, handler: MessageHandler)
+        +send(data: string)
+        +onBinaryUpdate(handler: BinaryUpdateHandler)
+        +dispose()
+    }
+
+    class SceneManager {
+        -scene: THREE.Scene
+        -camera: THREE.PerspectiveCamera
+        -renderer: THREE.WebGLRenderer
+        -controls: OrbitControls
+        -composer: EffectComposer
+        -bloomPass: UnrealBloomPass
+        -animationId: number
+        +start()
+        +stop()
+        +render()
+        +add(object: THREE.Object3D)
+        +remove(object: THREE.Object3D)
+        +dispose()
+    }
+
+    class NodeManager {
+        -nodeGeometry: THREE.SphereGeometry
+        -nodeMaterial: THREE.MeshBasicMaterial
+        -edgeGeometry: THREE.CylinderGeometry
+        -edgeMaterial: THREE.MeshBasicMaterial
+        -nodes: Map<string, NodeInstance>
+        -edges: Map<string, EdgeInstance>
+        +updateNodes(nodes: Node[])
+        +updateEdges(edges: Edge[])
+        +updateNodePositions(positions: Float32Array)
+        +dispose()
+    }
+
+    class NodeInstance {
+        -id: string
+        -mesh: THREE.Mesh
+        -color: THREE.Color
+        -position: THREE.Vector3
+        +setColor(color: THREE.Color)
+        +setPosition(position: THREE.Vector3)
+    }
+
+    class EdgeInstance {
+        -id: string
+        -line: THREE.Line
+        -startNode: NodeInstance
+        -endNode: NodeInstance
+        +updatePosition()
+    }
+
+    class TextRenderer {
+        -labels: Map<string, HTMLDivElement>
+        +addLabel(id: string, text: string, position: THREE.Vector3)
+        +removeLabel(id: string)
+        +update()
+        +dispose()
+    }
+
+    class XRSessionManager {
+        -renderer: THREE.WebGLRenderer
+        -session: XRSession
+        -referenceSpace: XRReferenceSpace
+        -inputSources: XRInputSource[]
+        +initialize(renderer: THREE.WebGLRenderer)
+        +startSession(sessionType: XRSessionType)
+        +endSession()
+        +requestReferenceSpace(referenceSpaceType: XRReferenceSpaceType)
+        +onSessionStarted(session: XRSession)
+        +onSessionEnded()
+        +onInputsChanged(event: XRInputSourceChangeEvent)
+        +onSelectStart(event: XRInputSourceEvent)
+        +onSelectEnd(event: XRInputSourceEvent)
+        +onSqueezeStart(event: XRInputSourceEvent)
+        +onSqueezeEnd(event: XRInputSourceEvent)
+        +update()
+    }
+
+    class XRInteraction {
+        -raycaster: THREE.Raycaster
+        -tempMatrix: THREE.Matrix4
+        -controller1: THREE.Group
+        -controller2: THREE.Group
+        -controllerGrip1: THREE.Group
+        -controllerGrip2: THREE.Group
+        -intersected: THREE.Object3D[]
+        +initialize(renderer: THREE.WebGLRenderer, scene: THREE.Scene, xrSessionManager: XRSessionManager)
+        +createController(controllerIndex: number)
+        +handleController(controller: THREE.Group)
+        +intersectObjects(controller: THREE.Group)
+        +cleanIntersected()
+        +dispose()
+    }
+
+    class ControlPanel {
+        -settingsManager: SettingsManager
+        +initialize()
+        +createControls()
+        +addSettingControl(category: string, setting: string, value: any)
+        +updateSetting(category: string, setting: string, value: any)
+        +saveSettings()
+        +resetSettings()
+    }
+
+    class AppState {
+        +graph_service: GraphService
+        +gpu_compute: Option<GPUCompute>
+        +settings: Arc<RwLock<Settings>>
+        +metadata_store: Arc<RwLock<MetadataStore>>
+        +github_service: RealGitHubService
+        +perplexity_service: Option<PerplexityService>
+        +rag_flow_service: Option<RAGFlowService>
+        +github_pr_service: RealGitHubPRService
+        +active_connections: AtomicUsize
+        +increment_connection_count()
+        +decrement_connection_count()
+    }
+
+    class GraphService {
+        +build_graph_from_metadata(metadata_store: &MetadataStore): Result<GraphData, Error>
+        +get_graph_data(): Result<GraphData, Error>
+        +get_paginated_graph_data(pagination: PaginationParams): Result<PaginatedGraphData, Error>
+        +get_node_positions(): Result<Vec<PositionUpdate>, Error>
+    }
+
+    class GPUCompute {
+        +device: wgpu::Device
+        +queue: wgpu::Queue
+        +compute_pipeline: wgpu::ComputePipeline
+        +position_buffer: wgpu::Buffer
+        +velocity_buffer: wgpu::Buffer
+        +force_buffer: wgpu::Buffer
+        +node_buffer: wgpu::Buffer
+        +edge_buffer: wgpu::Buffer
+        +params_buffer: wgpu::Buffer
+        +bind_group: wgpu::BindGroup
+        +set_graph_data(graph_data: &GraphData, simulation_params: &GPUSimulationParams): Result<(), Error>
+        +compute_forces(): Result<(), Error>
+        +get_updated_positions(): Result<Vec<PositionUpdate>, Error>
+    }
+
+    class Settings {
+        +github: GitHubSettings
+        +graph: GraphSettings
+        +visualization: VisualizationSettings
+        +perplexity: PerplexitySettings
+        +rag_flow: RAGFlowSettings
+        +audio: AudioSettings
+    }
+
+    class MetadataStore {
+        +metadata: HashMap<String, Metadata>
+        +add_metadata(metadata: Metadata)
+        +get_metadata(file_name: &str): Option<&Metadata>
+        +update_metadata(file_name: &str, metadata: Metadata)
+        +remove_metadata(file_name: &str)
+    }
+
+    class RealGitHubService {
+        +client: reqwest::Client
+        +headers: HeaderMap
+        +fetch_files(settings: &GitHubSettings): Result<Vec<GitHubFile>, Error>
+        +fetch_file_content(settings: &GitHubSettings, file: &GitHubFile): Result<String, Error>
+    }
+
+    class PerplexityService {
+        +client: reqwest::Client
+        +send_request(settings: &PerplexitySettings, request: &PerplexityRequest): Result<PerplexityResponse, Error>
+    }
+
+    class RAGFlowService {
+        +client: reqwest::Client
+        +init_chat(settings: &RAGFlowSettings): Result<String, Error>
+        +send_message(settings: &RAGFlowSettings, chat_id: &str, message: &str): Result<String, Error>
+        +get_chat_history(settings: &RAGFlowSettings, chat_id: &str): Result<Vec<RAGFlowMessage>, Error>
+    }
+
+    class RealGitHubPRService {
+        +client: reqwest::Client
+        +headers: HeaderMap
+        +create_or_update_file(settings: &GitHubSettings, file_name: &str, content: &str, sha: Option<&str>): Result<String, Error>
+        +create_pull_request(settings: &GitHubSettings, title: &str, body: &str, head_branch: &str, base_branch: &str): Result<String, Error>
+    }
+
+    class FileService {
+        +fetch_and_process_files(github_service: &RealGitHubService, settings: Arc<RwLock<Settings>>, metadata_store: &mut MetadataStore): Result<(), Error>
+        +load_or_create_metadata(settings: &Settings): Result<MetadataStore, Error>
+        +get_file_content(file_name: &str): Result<String, Error>
+        +refresh_graph(github_service: &RealGitHubService, settings: Arc<RwLock<Settings>>, metadata_store: &mut MetadataStore, graph_service: &GraphService): Result<(), Error>
+        +update_graph(github_service: &RealGitHubService, settings: Arc<RwLock<Settings>>, metadata_store: &mut MetadataStore, graph_service: &GraphService): Result<(), Error>
+        +save_metadata(metadata: &MetadataStore, settings: &Settings): Result<(), Error>
+    }
+
+    class SocketFlowServer {
+        -app_state: AppState
+        +new(app_state: AppState)
+        +handle_ping(ctx: &mut ws::WebsocketContext<Self>, message: &str)
+        +send_position_updates(ctx: &mut ws::WebsocketContext<Self>)
+        +actor_started(ctx: &mut ws::WebsocketContext<Self>)
+        +actor_stopped(ctx: &mut ws::WebsocketContext<Self>)
+        +handle_message(ctx: &mut ws::WebsocketContext<Self>, msg: Result<ws::Message, ws::ProtocolError>)
+    }
+
+    App --> PlatformManager
+    App --> SettingsManager
+    App --> GraphDataManager
+    App --> WebSocketService
+    App --> SceneManager
+    App --> NodeManager
+    App --> TextRenderer
+    App --> "0..1" XRSessionManager
+    App --> "0..1" XRInteraction
+    App --> ControlPanel
+    SettingsManager --> Settings
+    GraphDataManager --> Node
+    GraphDataManager --> Edge
+    WebSocketService --> GraphDataManager
+    SceneManager --> NodeManager
+    SceneManager --> TextRenderer
+    NodeManager --> NodeInstance
+    NodeManager --> EdgeInstance
+    EdgeInstance --> NodeInstance
+    XRSessionManager --> XRInteraction
+    ControlPanel --> SettingsManager
+    AppState --> GraphService
+    AppState --> "0..1" GPUCompute
+    AppState --> Settings
+    AppState --> MetadataStore
+    AppState --> RealGitHubService
+    AppState --> "0..1" PerplexityService
+    AppState --> "0..1" RAGFlowService
+    AppState --> RealGitHubPRService
+    GraphService --> GraphData
+    GraphService --> Node
+    GraphService --> Edge
+    GPUCompute --> GraphData
+    GPUCompute --> GPUSimulationParams
+    MetadataStore --> Metadata
+    RealGitHubService --> GitHubFile
+    PerplexityService --> PerplexityRequest
+    PerplexityService --> PerplexityResponse
+    RAGFlowService --> RAGFlowMessage
+    FileService --> MetadataStore
+    FileService --> GraphService
+    SocketFlowServer --> AppState
 ```
 
 ### Sequence Diagram
 
 ```mermaid
 sequenceDiagram
+    participant Client
+    participant App
+    participant PlatformManager
+    participant SettingsManager
+    participant GraphDataManager
+    participant WebSocketService
+    participant SceneManager
+    participant NodeManager
+    participant TextRenderer
+    participant ControlPanel
     participant Server
     participant FileService
-    participant GitHub
     participant GraphService
     participant GPUCompute
-    participant WebSocketManager
-    participant Client
-    participant WebXRVisualization
-    participant GraphDataManager
-    participant Interface
-    participant ChatManager
+    participant MetadataStore
+    participant GitHubService
+    participant PerplexityService
     participant RAGFlowService
-    participant PerplexityAPI
-    participant WebsocketService
-    participant SpeechService
-    participant SpeechWs
-
+    participant GitHubPRService
+    participant SocketFlowServer
+
+    Client->>App: start()
+    activate App
+    App->>PlatformManager: getPlatform()
+    activate PlatformManager
+    PlatformManager-->>App: Platform
+    deactivate PlatformManager
+    App->>SettingsManager: new()
+    activate SettingsManager
+    SettingsManager->>Server: GET /api/visualization/settings
     activate Server
-    Server->>Server: Load env vars & settings (config.rs)
-    alt Settings Load Error
-        note right of Server: Error handling in main.rs
-        Server-->>Client: Error Response (500)
-        deactivate Server
-    else Settings Loaded
-        Server->>Server: Initialize AppState (app_state.rs)
-        Server->>Server: Initialize GPUCompute (utils/gpu_compute.rs)
-        alt GPU Initialization Error
-            note right of Server: Fallback to CPU calculation
-        end
-        Server->>Server: initialize_graph_data (main.rs)
-        Server->>FileService: fetch_and_process_files (services/file_service.rs)
-        activate FileService
-            FileService->>GitHub: fetch_files("RealGitHubService::fetch_files")
-            activate GitHub
-                GitHub-->>FileService: Files or Error
-            deactivate GitHub
-            alt GitHub Error
-                FileService-->>Server: Error
-            else Files Fetched
-                loop For each file
-                    FileService->>FileService: should_process_file
-                    alt File needs processing
-                        FileService->>PerplexityAPI: process_file (services/perplexity_service.rs)
-                        activate PerplexityAPI
-                            PerplexityAPI->>PerplexityAPI: process_markdown
-                            PerplexityAPI->>PerplexityAPI: call_perplexity_api
-                            PerplexityAPI-->>FileService: Processed content or Error
-                        deactivate PerplexityAPI
-                        alt Perplexity Error
-                            FileService-->>Server: Error
-                        else Content Processed
-                            FileService->>FileService: save_file_metadata
-                        end
-                    end
-                end
-                FileService-->>Server: Processed files or Error
-            end
-        deactivate FileService
-        alt File Processing Error
-            Server-->>Server: Error
-        else Files Processed Successfully
-            Server->>GraphService: build_graph
-            activate GraphService
-                GraphService->>GraphService: Create nodes and edges
-                GraphService->>GPUCompute: calculate_layout
-                activate GPUCompute
-                    GPUCompute->>GPUCompute: set_graph_data
-                    GPUCompute->>GPUCompute: compute_forces
-                    GPUCompute->>GPUCompute: get_updated_positions
-                    GPUCompute-->>GraphService: Updated node positions
-                deactivate GPUCompute
-                GraphService-->>Server: GraphData
-            deactivate GraphService
-            Server->>WebSocketManager: broadcast_graph_update
-            activate WebSocketManager
-                WebSocketManager-->>Client: graph_update_message
-            deactivate WebSocketManager
-            Server-->>Client: Success Response
-        end
-    end
-
-    note right of Client: Initial load
-
-    Client->>WebXRVisualization: initialize()
-    activate WebXRVisualization
-        WebXRVisualization->>GraphDataManager: requestInitialData()
-        activate GraphDataManager
-            GraphDataManager->>WebsocketService: subscribe()
-            WebsocketService-->>GraphDataManager: Initial GraphData
-            GraphDataManager-->>WebXRVisualization: Provide GraphData
-        deactivate GraphDataManager
-        WebXRVisualization->>WebXRVisualization: setupThreeJS()
-        WebXRVisualization->>WebXRVisualization: renderScene()
-    deactivate WebXRVisualization
-    WebXRVisualization-->>Client: Render 3D Graph
-
-    note right of Client: User interactions
-
-    Client->>Interface: handleUserInput(input)
-    Interface->>ChatManager: sendMessage(input)
-    ChatManager->>RAGFlowService: sendQuery(input)
-    RAGFlowService-->>ChatManager: AI Response
-    ChatManager-->>Interface: Display AI Response
-    Interface->>WebXRVisualization: updateGraphData(newData)
-    WebXRVisualization-->>Client: Update Visualization
-
-    note right of Client: User requests layout recalculation
-
-    Client->>GraphDataManager: requestRecalculateLayout()
+    Server->>SettingsManager: load_all_settings()
+    activate SettingsManager
+    SettingsManager-->>Server: Settings
+    deactivate SettingsManager
+    Server-->>SettingsManager: Settings
+    deactivate Server
+    SettingsManager-->>App: SettingsManager
+    deactivate SettingsManager
+    App->>GraphDataManager: new()
     activate GraphDataManager
-        GraphDataManager->>WebsocketService: send("recalculateLayout", params)
+    GraphDataManager-->>App: GraphDataManager
     deactivate GraphDataManager
-    WebsocketService->>Server: emit("recalculateLayout", params)
+    App->>WebSocketService: new(url)
+    activate WebSocketService
+    WebSocketService->>WebSocketService: connect()
+    WebSocketService->>Server: Establish WebSocket Connection
     activate Server
-        Server->>GraphService: calculate_layout
-        activate GraphService
-            GraphService->>GPUCompute: calculate_layout
-            activate GPUCompute
-                GPUCompute->>GPUCompute: set_graph_data
-                GPUCompute->>GPUCompute: compute_forces
-                GPUCompute->>GPUCompute: get_updated_positions
-                GPUCompute-->>GraphService: Updated node positions
-            deactivate GPUCompute
-            GraphService-->>Server: GraphData
-        deactivate GraphService
-        Server->>WebSocketManager: broadcast_graph_update
-        activate WebSocketManager
-            WebSocketManager-->>Client: graph_update_message
-        deactivate WebSocketManager
+    Server->>SocketFlowServer: new(AppState)
+    activate SocketFlowServer
+    SocketFlowServer-->>Server: SocketFlowServer
+    deactivate SocketFlowServer
+    Server-->>WebSocketService: WebSocket Connection Established
     deactivate Server
-    Client->>WebXRVisualization: updateVisualization()
-    WebXRVisualization-->>Client: Render Updated 3D Graph
+    WebSocketService-->>App: WebSocketService
+    deactivate WebSocketService
+    App->>SceneManager: new(canvas)
+    activate SceneManager
+    SceneManager-->>App: SceneManager
+    deactivate SceneManager
+    App->>NodeManager: new()
+    activate NodeManager
+    NodeManager-->>App: NodeManager
+    deactivate NodeManager
+    App->>TextRenderer: new()
+    activate TextRenderer
+    TextRenderer-->>App: TextRenderer
+    deactivate TextRenderer
+    App->>ControlPanel: new(SettingsManager)
+    activate ControlPanel
+    ControlPanel-->>App: ControlPanel
+    deactivate ControlPanel
+    App->>SceneManager: start()
+    activate SceneManager
+    SceneManager->>SceneManager: render()
+    deactivate SceneManager
+    App->>WebSocketService: send(MessageType::InitialGraphRequest)
+    activate WebSocketService
+    WebSocketService->>Server: MessageType::InitialGraphRequest
+    deactivate WebSocketService
+    activate Server
+    Server->>GraphService: get_graph_data()
+    activate GraphService
+    GraphService->>MetadataStore: get_metadata()
+    activate MetadataStore
+    MetadataStore-->>GraphService: Metadata
+    deactivate MetadataStore
+    alt GPUCompute available
+        GraphService->>GPUCompute: set_graph_data()
+        activate GPUCompute
+        GPUCompute-->>GraphService: Result
+        deactivate GPUCompute
+        GraphService->>GPUCompute: compute_forces()
+        activate GPUCompute
+        GPUCompute-->>GraphService: Result
+        deactivate GPUCompute
+        GraphService->>GPUCompute: get_updated_positions()
+        activate GPUCompute
+        GPUCompute-->>GraphService: Vec<PositionUpdate>
+        deactivate GPUCompute
+    else CPU computation
+        GraphService->>GraphService: compute_forces_cpu()
+    end
+    GraphService-->>Server: GraphData
+    deactivate GraphService
+    Server->>WebSocketService: send(MessageType::GraphData, GraphData)
+    activate WebSocketService
+    WebSocketService->>GraphDataManager: updateGraphData(GraphData)
+    deactivate WebSocketService
+    activate GraphDataManager
+    GraphDataManager->>NodeManager: updateNodes(nodes)
+    activate NodeManager
+    NodeManager-->>GraphDataManager: Result
+    deactivate NodeManager
+    GraphDataManager->>NodeManager: updateEdges(edges)
+    activate NodeManager
+    NodeManager-->>GraphDataManager: Result
+    deactivate NodeManager
+    GraphDataManager-->>App: Result
+    deactivate GraphDataManager
 
-    note right of Client: User clicks "Refresh Graph"
+    loop Heartbeat
+        WebSocketService->>Server: MessageType::Ping
+        Server->>WebSocketService: MessageType::Pong
+    end
+    
+    loop User Interaction
+        Client->>ControlPanel: updateSetting(category, setting, value)
+        activate ControlPanel
+        ControlPanel->>SettingsManager: updateSetting(category, setting, value)
+        activate SettingsManager
+        SettingsManager->>Server: POST /api/visualization/settings/{category}/{setting}
+        activate Server
+        Server->>SettingsManager: update_setting(category, setting, value)
+        activate SettingsManager
+        SettingsManager-->>Server: Result
+        deactivate SettingsManager
+        Server-->>SettingsManager: Result
+        deactivate Server
+        SettingsManager-->>ControlPanel: Result
+        deactivate SettingsManager
+        ControlPanel-->>Client: Setting Updated
+        deactivate ControlPanel
+    end
 
-    Client->>Server: POST /api/files/fetch
-    activate Server
-        Server->>FileService: fetch_and_process_files
+    loop User Interaction
+        Client->>Server: POST /api/files/fetch
+        activate Server
+        Server->>FileService: fetch_and_process_files()
         activate FileService
-            FileService->>GitHub: fetch_files
-            activate GitHub
-                GitHub-->>FileService: Files or Error
-            deactivate GitHub
-            alt GitHub Error
-                FileService-->>Server: Error
-            else Files Fetched
-                loop For each file
-                    FileService->>FileService: should_process_file
-                    alt File needs processing
-                        FileService->>PerplexityAPI: process_file
-                        activate PerplexityAPI
-                            PerplexityAPI->>PerplexityAPI: process_markdown
-                            PerplexityAPI->>PerplexityAPI: call_perplexity_api
-                            PerplexityAPI-->>FileService: Processed content or Error
-                        deactivate PerplexityAPI
-                        alt Perplexity Error
-                            FileService-->>Server: Error
-                        else Content Processed
-                            FileService->>FileService: save_file_metadata
-                        end
-                    end
-                end
-                FileService-->>Server: Processed files or Error
-            end
+        FileService->>GitHubService: fetch_files()
+        activate GitHubService
+        GitHubService-->>FileService: Vec<GitHubFile>
+        deactivate GitHubService
+        FileService->>FileService: process_files()
+        loop for each file
+            FileService->>PerplexityService: send_request()
+            activate PerplexityService
+            PerplexityService-->>FileService: PerplexityResponse
+            deactivate PerplexityService
+        end
+        FileService->>MetadataStore: add_metadata()
+        activate MetadataStore
+        MetadataStore-->>FileService: Result
+        deactivate MetadataStore
+        FileService-->>Server: Result
         deactivate FileService
-        alt File Processing Error
-            Server->>WebSocketManager: broadcast_error_message
-            activate WebSocketManager
-                WebSocketManager-->>Client: error_message
-            deactivate WebSocketManager
-            Server-->>Client: Error Response
-        else Files Processed Successfully
-            Server->>GraphService: build_graph
-            activate GraphService
-                GraphService->>GraphService: Create nodes and edges
-                GraphService->>GPUCompute: calculate_layout
-                activate GPUCompute
-                    GPUCompute->>GPUCompute: set_graph_data
-                    GPUCompute->>GPUCompute: compute_forces
-                    GPUCompute->>GPUCompute: get_updated_positions
-                    GPUCompute-->>GraphService: Updated node positions
-                deactivate GPUCompute
-                GraphService-->>Server: GraphData
-            deactivate GraphService
-            Server->>WebSocketManager: broadcast_graph_update
-            activate WebSocketManager
-                WebSocketManager-->>Client: graph_update_message
-            deactivate WebSocketManager
-            Server-->>Client: Success Response
+        Server->>GraphService: build_graph_from_metadata()
+        activate GraphService
+        alt GPUCompute available
+            GraphService->>GPUCompute: set_graph_data()
+            activate GPUCompute
+            GPUCompute-->>GraphService: Result
+            deactivate GPUCompute
+            GraphService->>GPUCompute: compute_forces()
+            activate GPUCompute
+            GPUCompute-->>GraphService: Result
+            deactivate GPUCompute
+            GraphService->>GPUCompute: get_updated_positions()
+            activate GPUCompute
+            GPUCompute-->>GraphService: Vec<PositionUpdate>
+            deactivate GPUCompute
+        else CPU computation
+            GraphService->>GraphService: compute_forces_cpu()
         end
-    deactivate Server
+        GraphService-->>Server: GraphData
+        deactivate GraphService
+        Server->>WebSocketService: send(MessageType::GraphData, GraphData)
+        activate WebSocketService
+        WebSocketService->>GraphDataManager: updateGraphData(GraphData)
+        deactivate WebSocketService
+        activate GraphDataManager
+        GraphDataManager->>NodeManager: updateNodes(nodes)
+        activate NodeManager
+        NodeManager-->>GraphDataManager: Result
+        deactivate NodeManager
+        GraphDataManager->>NodeManager: updateEdges(edges)
+        activate NodeManager
+        NodeManager-->>GraphDataManager: Result
+        deactivate NodeManager
+        GraphDataManager-->>App: Result
+        deactivate GraphDataManager
+        Server-->>Client: Files Fetched and Processed
+        deactivate Server
+    end
+
+    loop User Interaction
+        Client->>Server: POST /api/ragflow/init
+        activate Server
+        Server->>RAGFlowService: init_chat()
+        activate RAGFlowService
+        RAGFlowService-->>Server: chat_id
+        deactivate RAGFlowService
+        Server-->>Client: chat_id
+        deactivate Server
 
+        Client->>Server: POST /api/ragflow/message
+        activate Server
+        Server->>RAGFlowService: send_message()
+        activate RAGFlowService
+        RAGFlowService-->>Server: response
+        deactivate RAGFlowService
+        Server-->>Client: response
+        deactivate Server
+    end
 
+    loop Position Updates
+        Server->>WebSocketService: send(MessageType::PositionUpdate, positions)
+        WebSocketService->>GraphDataManager: updateNodePositions(positions)
+    end
 ```
 
 ### WebGPU Compute Pipeline
@@ -598,7 +795,50 @@ graph TB
     class NewPositions,VisualizationData outputBufferStyle
 ```
 
+## Development
+
+### Development Scripts
+
+The project includes a comprehensive development script (`scripts/dev.sh`) that provides various commands for managing the Docker containers and testing the application:
+
+```bash
+# Start the application
+./scripts/dev.sh start
+
+# Stop all containers
+./scripts/dev.sh stop
+
+# Rebuild and restart containers
+./scripts/dev.sh rebuild
 
+# Run tests
+./scripts/dev.sh test
+
+# View container logs
+./scripts/dev.sh logs
+
+# Show available endpoints
+./scripts/dev.sh endpoints
+
+# Rebuild and test in one command
+./scripts/dev.sh rebuild-test
+```
+
+The script provides the following features:
+- **Environment Setup**: Automatically loads environment variables from `.env`
+- **Container Management**: Start, stop, rebuild, and monitor Docker containers
+- **Health Checks**: Verifies container health and endpoint availability
+- **Error Handling**: Robust error handling and cleanup procedures
+- **Logging**: Detailed logging with timestamps and color-coding
+- **Endpoint Testing**: Automated testing of backend endpoints
+
+### Environment Variables
+
+The following environment variables can be set in `.env`:
+- `PORT`: The port to run the server on (default: 3000)
+- `DEBUG`: Enable debug logging (1 for enabled, 0 for disabled)
+- `RAGFLOW_URL`: URL for the RAGFlow service
+- Other service-specific variables (see `.env.example`)
 
 ## Contributing
 
@@ -704,4 +944,3 @@ If you encounter any bugs or have feature requests, please open an issue in the
 ## License
 
 This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
-
diff --git a/client/components/settings/FPSControl.tsx b/client/components/settings/FPSControl.tsx
new file mode 100644
index 00000000..65cb4870
--- /dev/null
+++ b/client/components/settings/FPSControl.tsx
@@ -0,0 +1,39 @@
+import React from 'react';
+import { Select, FormControl, InputLabel, MenuItem } from '@mui/material';
+import { useSettings } from '../../state/settings';
+
+const FPS_OPTIONS = [1, 30, 60, 90];
+
+export const FPSControl: React.FC = () => {
+  const { settings, updateSettings } = useSettings();
+
+  const handleChange = async (event: any) => {
+    const newRate = event.target.value;
+    try {
+      await updateSettings('websocket', {
+        updateRate: newRate
+      });
+    } catch (error) {
+      console.error('Failed to update FPS:', error);
+    }
+  };
+
+  return (
+    <FormControl fullWidth>
+      <InputLabel id="fps-select-label">Frame Rate</InputLabel>
+      <Select
+        labelId="fps-select-label"
+        id="fps-select"
+        value={settings.websocket.updateRate}
+        label="Frame Rate"
+        onChange={handleChange}
+      >
+        {FPS_OPTIONS.map((fps) => (
+          <MenuItem key={fps} value={fps}>
+            {fps} FPS
+          </MenuItem>
+        ))}
+      </Select>
+    </FormControl>
+  );
+};
diff --git a/client/core/api.ts b/client/core/api.ts
new file mode 100644
index 00000000..d7a4cb9c
--- /dev/null
+++ b/client/core/api.ts
@@ -0,0 +1,65 @@
+import { API_BASE, API_ENDPOINTS, API_PATHS } from './constants';
+
+// Helper function to build API URLs
+export function buildApiUrl(path: string): string {
+    // Handle API paths
+    const apiPaths = ['/api', '/api/settings'];
+    for (const apiPath of apiPaths) {
+        if (path.startsWith(apiPath)) {
+            return `${API_BASE}${path}`;
+        }
+    }
+    return `${API_BASE}/api/${path}`;
+}
+
+// Helper function to build settings URL
+export function buildSettingsUrl(category: string): string {
+    return `${API_ENDPOINTS.SETTINGS}/${category}`;
+}
+
+// Helper function to build graph URL
+export function buildGraphUrl(type: 'data' | 'update' | 'paginated'): string {
+    switch (type) {
+        case 'paginated':
+            return API_ENDPOINTS.GRAPH_PAGINATED;
+        case 'update':
+            return API_ENDPOINTS.GRAPH_UPDATE;
+        default:
+            return API_ENDPOINTS.GRAPH_DATA;
+    }
+}
+
+// Helper function to build files URL
+export function buildFilesUrl(path: string): string {
+    return `${API_ENDPOINTS.FILES}/${path}`;
+}
+
+// Helper function to build WebSocket URL
+export function buildWsUrl(): string {
+    const isProduction = ['www.visionflow.info', 'visionflow.info'].includes(window.location.hostname);
+    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
+    const host = window.location.host;
+    
+    if (isProduction) {
+        // In production, always use wss:// with the domain
+        return `wss://www.visionflow.info/${API_PATHS.WEBSOCKET}`;
+    } else {
+        // In development, use the current host with ws:// or wss://
+        return `${protocol}//${host}/${API_PATHS.WEBSOCKET}`;
+    }
+}
+
+// Helper function to build settings item URL
+export function buildSettingsItemUrl(category: string, setting: string): string {
+    return API_ENDPOINTS.SETTINGS_ITEM(category, setting);
+}
+
+// Helper function to build visualization settings URL
+export function buildVisualizationSettingsUrl(): string {
+    return API_ENDPOINTS.VISUALIZATION_SETTINGS;
+}
+
+// Helper function to build WebSocket control URL
+export function buildWebSocketControlUrl(): string {
+    return API_ENDPOINTS.WEBSOCKET_CONTROL;
+}
diff --git a/client/core/constants.ts b/client/core/constants.ts
index b44570a9..6b7d9d8b 100644
--- a/client/core/constants.ts
+++ b/client/core/constants.ts
@@ -3,21 +3,68 @@
  */
 
 // Environment detection
-export const IS_PRODUCTION = window.location.hostname === 'www.visionflow.info';
+export const IS_PRODUCTION = ['www.visionflow.info', 'visionflow.info'].includes(window.location.hostname);
 export const IS_DEVELOPMENT = !IS_PRODUCTION;
 
-// WebSocket URLs
-export const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/wss`;
+// API configuration
+export const API_BASE = '';  // Empty string means use relative URLs
+
+// API paths
+export const API_PATHS = {
+    SETTINGS: 'settings',
+    WEBSOCKET: 'wss',
+    GRAPH: 'graph',
+    FILES: 'files'
+};
+
+// API endpoints
+export const API_ENDPOINTS = {
+    GRAPH_DATA: '/api/graph/data',
+    GRAPH_UPDATE: '/api/graph/update',
+    GRAPH_PAGINATED: '/api/graph/paginated',
+    SETTINGS: '/api/settings',
+    SETTINGS_UPDATE: '/api/settings/update',
+    SETTINGS_CATEGORY: (category: string) => `/api/settings/${category}`,
+    SETTINGS_ITEM: (category: string, setting: string) => `/api/settings/${category}/${setting}`,
+    VISUALIZATION_SETTINGS: '/api/settings/visualization',
+    WEBSOCKET_CONTROL: '/api/settings/websocket',
+    FILES: '/api/files'
+} as const;
+
+export type ApiEndpoints = typeof API_ENDPOINTS[keyof typeof API_ENDPOINTS];
+
+// Settings categories matching server's snake_case
+export const SETTINGS_CATEGORIES = {
+    // System settings
+    NETWORK: 'system.network',
+    WEBSOCKET: 'system.websocket',
+    SECURITY: 'system.security',
+    DEBUG: 'system.debug',
+    
+    // Visualization settings
+    ANIMATIONS: 'visualization.animations',
+    AR: 'visualization.ar',
+    AUDIO: 'visualization.audio',
+    BLOOM: 'visualization.bloom',
+    EDGES: 'visualization.edges',
+    HOLOGRAM: 'visualization.hologram',
+    LABELS: 'visualization.labels',
+    NODES: 'visualization.nodes',
+    PHYSICS: 'visualization.physics',
+    RENDERING: 'visualization.rendering',
+    
+    // Default settings
+    DEFAULT: 'default'
+};
 
 // WebSocket configuration
-export const WS_RECONNECT_INTERVAL = 30000; // Match server's HEARTBEAT_INTERVAL
 export const WS_MESSAGE_QUEUE_SIZE = 1000;
 
 // Binary protocol configuration
-export const BINARY_VERSION = 1;
 export const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
-export const VERSION_OFFSET = 1;    // Skip version float
+export const VERSION_OFFSET = 0;    // No version header
 export const BINARY_CHUNK_SIZE = 1000; // Number of nodes to process in one chunk
+export const NODE_POSITION_SIZE = 24;  // 6 floats * 4 bytes (position + velocity)
 
 // Performance configuration
 export const THROTTLE_INTERVAL = 16; // ~60fps
@@ -39,50 +86,10 @@ export const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300
 export const BACKGROUND_COLOR = 0x212121;  // Material Design Grey 900
 export const LABEL_COLOR = 0xFFFFFF;  // White
 
-// Default settings
-export const DEFAULT_VISUALIZATION_SETTINGS = {
-  // Node appearance
-  nodeSize: NODE_SIZE,
-  nodeColor: '#4CAF50',
-  nodeOpacity: 0.7,
-  nodeHighlightColor: '#ff4444',
-  
-  // Edge appearance
-  edgeWidth: EDGE_RADIUS * 2,
-  edgeColor: '#E0E0E0',
-  edgeOpacity: 0.7,
-  
-  // Visual effects
-  enableBloom: true,
-  bloomIntensity: 1.5,
-  bloomThreshold: 0.3,
-  bloomRadius: 0.75,
-  
-  // Performance
-  maxFps: 60,
-  updateThrottle: THROTTLE_INTERVAL,
-
-  // Labels
-  showLabels: true,
-  labelSize: 1.0,
-  labelColor: '#FFFFFF',
-
-  // XR specific
-  xrControllerVibration: true,
-  xrControllerHapticIntensity: 1.0
-};
-
-// Default bloom settings
-export const DEFAULT_BLOOM_SETTINGS = {
-  threshold: DEFAULT_VISUALIZATION_SETTINGS.bloomThreshold,
-  strength: DEFAULT_VISUALIZATION_SETTINGS.bloomIntensity,
-  radius: DEFAULT_VISUALIZATION_SETTINGS.bloomRadius,
-};
-
 // Debug configuration
 export const DEBUG = {
-  NETWORK_PANEL: {
-    MAX_MESSAGES: 50,
-    ENABLED: IS_DEVELOPMENT
-  }
+    NETWORK_PANEL: {
+        MAX_MESSAGES: 50,
+        ENABLED: IS_DEVELOPMENT
+    }
 };
diff --git a/client/core/logger.ts b/client/core/logger.ts
index bfa40358..1e9544c3 100644
--- a/client/core/logger.ts
+++ b/client/core/logger.ts
@@ -1,6 +1,51 @@
-export const logger = {
-    info: (message: string, ...args: any[]) => console.log(message, ...args),
-    error: (message: string, ...args: any[]) => console.error(message, ...args),
-    warn: (message: string, ...args: any[]) => console.warn(message, ...args),
-    debug: (message: string, ...args: any[]) => console.debug(message, ...args),
-};
+let debugEnabled = false;
+let logFullJson = false;
+
+export interface Logger {
+    debug: (...args: any[]) => void;
+    log: (...args: any[]) => void;
+    info: (...args: any[]) => void;
+    warn: (...args: any[]) => void;
+    error: (...args: any[]) => void;
+}
+
+export function setDebugEnabled(enabled: boolean, fullJson: boolean = false): void {
+    debugEnabled = enabled;
+    logFullJson = fullJson;
+}
+
+export function createLogger(context: string): Logger {
+    const prefix = `[${context}]`;
+    
+    const formatArgs = (args: any[]): any[] => {
+        if (logFullJson) {
+            return args.map(arg => 
+                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
+            );
+        }
+        return args;
+    };
+    
+    return {
+        debug: (...args: any[]): void => {
+            if (debugEnabled) {
+                console.debug(prefix, ...formatArgs(args));
+            }
+        },
+        log: (...args: any[]): void => {
+            console.log(prefix, ...formatArgs(args));
+        },
+        info: (...args: any[]): void => {
+            console.info(prefix, ...formatArgs(args));
+        },
+        warn: (...args: any[]): void => {
+            console.warn(prefix, ...formatArgs(args));
+        },
+        error: (...args: any[]): void => {
+            console.error(prefix, ...formatArgs(args));
+        }
+    };
+}
+
+// Create core logger instance
+export const logger = createLogger('core');
diff --git a/client/core/types.ts b/client/core/types.ts
index a953af69..f0006b1b 100644
--- a/client/core/types.ts
+++ b/client/core/types.ts
@@ -6,9 +6,17 @@ export interface Vector3 {
   z: number;
 }
 
+export interface NodeMetadata {
+  name?: string;
+  lastModified?: number;
+  links?: string[];
+  references?: string[];
+}
+
 export interface NodeData {
   position: Vector3;
   velocity: Vector3;
+  metadata?: NodeMetadata;
 }
 
 export interface Node {
@@ -24,6 +32,13 @@ export interface Edge {
   weight?: number;
 }
 
+export interface PaginatedGraphData extends GraphData {
+  totalPages: number;
+  currentPage: number;
+  totalItems: number;
+  pageSize: number;
+}
+
 export interface GraphData {
   nodes: Node[];
   edges: Edge[];
@@ -84,6 +99,7 @@ export interface ARSettings {
   rotationThreshold: number;
   showPlaneOverlay: boolean;
   snapToFloor: boolean;
+  interactionRadius: number;
 }
 
 export interface AudioSettings {
@@ -118,10 +134,47 @@ export interface EdgeSettings {
   widthRange: [number, number];
 }
 
+export interface HologramSettings {
+  xrQuality: 'low' | 'medium' | 'high';
+  desktopQuality: 'low' | 'medium' | 'high';
+  ringCount: number;
+  ringColor: string;
+  ringOpacity: number;
+  ringSizes: number[];
+  ringRotationSpeed: number;
+  enableBuckminster: boolean;
+  buckminsterScale: number;
+  buckminsterOpacity: number;
+  enableGeodesic: boolean;
+  geodesicScale: number;
+  geodesicOpacity: number;
+  enableTriangleSphere: boolean;
+  triangleSphereScale: number;
+  triangleSphereOpacity: number;
+  globalRotationSpeed: number;
+}
+
 export interface LabelSettings {
   desktopFontSize: number;
   enableLabels: boolean;
   textColor: string;
+  textOutlineColor: string;
+  textOutlineWidth: number;
+  textResolution: number;
+  textPadding: number;
+  billboardMode: 'camera' | 'up';
+}
+
+export interface NodeSettings {
+  baseColor: string;
+  baseSize: number;
+  sizeRange: [number, number];
+  enableMetadataShape: boolean;
+  colorRangeAge: [string, string];
+  colorRangeLinks: [string, string];
+  metalness: number;
+  roughness: number;
+  opacity: number;
 }
 
 export interface NetworkSettings {
@@ -171,23 +224,6 @@ export interface ServerDebugSettings {
   logFullJson: boolean;
 }
 
-export interface NodeSettings {
-  baseColor: string;
-  baseSize: number;
-  clearcoat: number;
-  enableHoverEffect: boolean;
-  enableInstancing: boolean;
-  highlightColor: string;
-  highlightDuration: number;
-  hoverScale: number;
-  materialType: string;
-  metalness: number;
-  opacity: number;
-  roughness: number;
-  sizeByConnections: boolean;
-  sizeRange: [number, number];
-}
-
 export interface PhysicsSettings {
   attractionStrength: number;
   boundsSize: number;
@@ -211,6 +247,20 @@ export interface RenderingSettings {
   environmentIntensity: number;
 }
 
+export interface WebSocketSettings {
+  url: string;                   // WebSocket server URL
+  heartbeatInterval: number;     // Ping interval in seconds (default: 30)
+  heartbeatTimeout: number;      // Connection timeout in seconds (default: 60)
+  reconnectAttempts: number;     // Max reconnection attempts (default: 3)
+  reconnectDelay: number;        // Delay between reconnects in ms (default: 5000)
+  binaryChunkSize: number;       // Size of binary chunks
+  compressionEnabled: boolean;   // Enable/disable compression
+  compressionThreshold: number;  // Compression threshold
+  maxConnections: number;        // Maximum connections
+  maxMessageSize: number;        // Maximum message size
+  updateRate: number;           // Update rate in Hz
+}
+
 export interface Settings {
   animations: AnimationSettings;
   ar: ARSettings;
@@ -219,6 +269,7 @@ export interface Settings {
   clientDebug: ClientDebugSettings;
   default: DefaultSettings;
   edges: EdgeSettings;
+  hologram: HologramSettings;
   labels: LabelSettings;
   network: NetworkSettings;
   nodes: NodeSettings;
@@ -226,6 +277,7 @@ export interface Settings {
   rendering: RenderingSettings;
   security: SecuritySettings;
   serverDebug: ServerDebugSettings;
+  websocket: WebSocketSettings;
 }
 
 export type SettingCategory = keyof Settings;
@@ -248,7 +300,14 @@ export interface BaseWebSocketMessage {
 // Binary position update message (server -> client)
 export interface BinaryPositionUpdateMessage extends BaseWebSocketMessage {
   type: 'binaryPositionUpdate';
-  data: ArrayBuffer;  // Raw binary data (24 bytes per node: 6 floats x 4 bytes)
+  data: {
+    nodes: Array<{
+      data: {
+        position: Vector3;
+        velocity: Vector3;
+      }
+    }>
+  };
 }
 
 // Connection health messages
@@ -267,21 +326,6 @@ export type WebSocketMessage =
   | PingMessage
   | PongMessage;
 
-// WebSocket settings
-export interface WebSocketSettings {
-  url: string;                   // WebSocket server URL
-  heartbeatInterval: number;     // Ping interval in seconds (default: 30)
-  heartbeatTimeout: number;      // Connection timeout in seconds (default: 60)
-  reconnectAttempts: number;     // Max reconnection attempts (default: 3)
-  reconnectDelay: number;        // Delay between reconnects in ms (default: 5000)
-  binaryChunkSize: number;       // Size of binary chunks
-  compressionEnabled: boolean;   // Enable/disable compression
-  compressionThreshold: number;  // Compression threshold
-  maxConnections: number;        // Maximum connections
-  maxMessageSize: number;        // Maximum message size
-  updateRate: number;           // Update rate in Hz
-}
-
 // WebSocket error types
 export enum WebSocketErrorType {
   CONNECTION_ERROR = 'CONNECTION_ERROR',       // Failed to establish connection
diff --git a/client/index.ts b/client/index.ts
index 4f633dbf..9252aa70 100644
--- a/client/index.ts
+++ b/client/index.ts
@@ -1,25 +1,23 @@
-/**
- * LogseqXR Application Entry Point
- */
-
 import { platformManager } from './platform/platformManager';
-import { Settings, SettingCategory, SettingKey, SettingValueType } from './types/settings';
 import { settingsManager } from './state/settings';
-import { graphDataManager } from './state/graphData';
-import { WebSocketService } from './websocket/websocketService';
+import { setDebugEnabled } from './core/logger';
+import { createLogger } from './core/logger';
 import { SceneManager } from './rendering/scene';
-import { NodeManager } from './rendering/nodes';
+import { WebSocketService } from './websocket/websocketService';
+import { graphDataManager } from './state/graphData';
 import { XRSessionManager } from './xr/xrSessionManager';
-import { createLogger, setDebugEnabled } from './utils/logger';
 import { ControlPanel } from './ui/ControlPanel';
+import { TextRenderer } from './rendering/textRenderer';
+import { EnhancedNodeManager } from './rendering/EnhancedNodeManager';
 
 const logger = createLogger('Application');
 
 class Application {
-    private webSocket!: WebSocketService;
-    private sceneManager!: SceneManager;
-    private nodeManager!: NodeManager;
+    private sceneManager: SceneManager | null = null;
+    private nodeManager: EnhancedNodeManager | null = null;
     private xrManager: XRSessionManager | null = null;
+    private textRenderer: TextRenderer | null = null;
+    private controlPanel: ControlPanel | null = null;
 
     constructor() {
         this.initializeApplication();
@@ -27,377 +25,142 @@ class Application {
 
     private async initializeApplication(): Promise<void> {
         try {
-            // Initialize platform manager
             await platformManager.initialize();
-
-            // Initialize settings
             await settingsManager.initialize();
-            
-            // Update logger debug state from settings
-            const settings = settingsManager.getCurrentSettings();
-            setDebugEnabled(settings.clientDebug.enabled);
-            logger.info('Debug logging ' + (settings.clientDebug.enabled ? 'enabled' : 'disabled'));
-
-            // Initialize scene first so we can render nodes when data arrives
-            this.initializeScene();
-
-            // Track initialization state
-            let graphDataLoaded = false;
-            let websocketConnected = false;
-            let binaryUpdatesEnabled = false;
 
-            // Function to check if we can hide loading overlay
-            const checkInitComplete = () => {
-                if (graphDataLoaded && websocketConnected && binaryUpdatesEnabled) {
-                    this.hideLoadingOverlay();
-                    logger.info('All initialization checks passed, application ready');
-                }
-            };
+            const settings = settingsManager.getCurrentSettings();
+            setDebugEnabled(settings.system.debug.enabled);
+            logger.info(`Debug logging ${settings.system.debug.enabled ? 'enabled' : 'disabled'}`);
 
-            try {
-                // Load initial graph data from REST endpoint
-                await graphDataManager.loadInitialGraphData();
-                graphDataLoaded = true;
-                checkInitComplete();
-            } catch (graphError) {
-                logger.error('Failed to load graph data:', graphError);
-                // Continue initialization even if graph data fails
+            const canvas = document.getElementById('main-canvas') as HTMLCanvasElement;
+            if (!canvas) {
+                throw new Error('Canvas element not found');
             }
+            this.sceneManager = SceneManager.getInstance(canvas);
 
-            try {
-                // Initialize WebSocket for real-time updates
-                this.webSocket = new WebSocketService();
-
-                // Setup WebSocket event handlers
-                this.webSocket.onMessage('connectionStatus', (data: { status: string, details?: any }) => {
-                    logger.info('WebSocket connection status:', data);
-                    if (data.status === 'CONNECTED') {
-                        websocketConnected = true;
-                        checkInitComplete();
-                    }
-                });
-
-                this.webSocket.onMessage('enableBinaryUpdates', (data: { enabled: boolean }) => {
-                    logger.info('Binary updates status:', data);
-                    // Update graph data manager binary state
-                    graphDataManager.setBinaryUpdatesEnabled(data.enabled);
-                    if (data.enabled) {
-                        binaryUpdatesEnabled = true;
-                        checkInitComplete();
-                        // Request initial data after binary updates are enabled
-                        this.webSocket.send(JSON.stringify({
-                            type: 'requestInitialData'
-                        }));
-                    }
-                });
-
-                // Setup WebSocket event handler for binary position updates
-                this.webSocket.onMessage('binaryPositionUpdate', (data: any['data']) => {
-                    if (data && data.nodes) {
-                        // Convert nodes data to ArrayBuffer for position updates
-                        const buffer = new ArrayBuffer(data.nodes.length * 24); // 6 floats per node
-                        const floatArray = new Float32Array(buffer);
-                        
-                        data.nodes.forEach((node: { data: { position: any; velocity: any } }, index: number) => {
-                            const baseIndex = index * 6;
-                            const pos = node.data.position;
-                            const vel = node.data.velocity;
-                            
-                            // Position
-                            floatArray[baseIndex] = pos.x;
-                            floatArray[baseIndex + 1] = pos.y;
-                            floatArray[baseIndex + 2] = pos.z;
-                            // Velocity
-                            floatArray[baseIndex + 3] = vel.x;
-                            floatArray[baseIndex + 4] = vel.y;
-                            floatArray[baseIndex + 5] = vel.z;
-                        });
-
-                        // Update graph data and visual representation
-                        graphDataManager.updatePositions(buffer);
-                        this.nodeManager.updatePositions(floatArray);
-                    }
-                });
-            } catch (wsError) {
-                logger.error('Failed to initialize WebSocket:', wsError);
-                // Continue initialization even if WebSocket fails
+            if (!this.sceneManager) {
+                throw new Error('SceneManager not initialized');
             }
+            this.textRenderer = new TextRenderer(this.sceneManager.getCamera());
+            this.sceneManager.add(this.textRenderer.getGroup());
 
-            try {
-                // Initialize XR if supported
-                await this.initializeXR();
-            } catch (xrError) {
-                logger.error('Failed to initialize XR:', xrError);
-                // Continue initialization even if XR fails
-            }
+            this.nodeManager = new EnhancedNodeManager(this.sceneManager.getScene(), settings);
 
-            // Initialize UI components
             const controlPanelContainer = document.getElementById('control-panel');
             if (!controlPanelContainer) {
-                logger.warn('Control panel container not found, skipping UI initialization');
-            } else {
-                new ControlPanel(controlPanelContainer);
-                // Setup UI event listeners
-                this.setupUIEventListeners();
+                throw new Error('Control panel container not found');
             }
+            this.controlPanel = new ControlPanel(controlPanelContainer);
 
-            // Subscribe to graph data updates
-            graphDataManager.subscribe(() => {
-                // Hide loading overlay after initial data is loaded
-                this.hideLoadingOverlay();
-            });
-
-            logger.log('Application initialized successfully');
-            // Always hide loading overlay after initialization
-            this.hideLoadingOverlay();
-        } catch (error) {
-            logger.error('Failed to initialize application:', error);
-            this.showError('Failed to initialize application');
-            // Still try to hide loading overlay
-            this.hideLoadingOverlay();
-        }
-    }
-
-    private initializeScene(): void {
-        // Get canvas element
-        const container = document.getElementById('scene-container');
-        if (!container) {
-            throw new Error('Scene container not found');
-        }
-
-        // Create canvas
-        const canvas = document.createElement('canvas');
-        container.appendChild(canvas);
-
-        // Initialize scene manager
-        this.sceneManager = SceneManager.getInstance(canvas);
-
-        // Initialize node manager
-        this.nodeManager = NodeManager.getInstance();
-
-        // Add node meshes to scene
-        const nodeMeshes = this.nodeManager.getAllNodeMeshes();
-        nodeMeshes.forEach(mesh => this.sceneManager.add(mesh));
-
-        // Start rendering
-        this.sceneManager.start();
-        logger.log('Scene initialized with node meshes');
-    }
-
-    private async initializeXR(): Promise<void> {
-        if (platformManager.getCapabilities().xrSupported) {
-            // Initialize XR manager
+            // Initialize XR manager with scene manager
             this.xrManager = XRSessionManager.getInstance(this.sceneManager);
 
-            // Setup XR button
-            const xrButton = document.getElementById('xr-button');
-            if (xrButton) {
-                xrButton.style.display = 'block';
-                xrButton.addEventListener('click', () => this.toggleXRSession());
-            }
-        }
-    }
-
-    private setupUIEventListeners(): void {
-        // Settings panel save button
-        const saveButton = document.getElementById('save-settings');
-        if (saveButton) {
-            saveButton.addEventListener('click', () => this.saveSettings());
-        }
-
-        // Settings inputs
-        this.setupSettingsInputListeners();
-    }
-
-    private setupSettingsInputListeners(): void {
-        // Node appearance settings
-        this.setupSettingInput<'nodes', 'baseSize'>('nodes', 'baseSize');
-        this.setupSettingInput<'nodes', 'baseColor'>('nodes', 'baseColor');
-        this.setupSettingInput<'nodes', 'opacity'>('nodes', 'opacity');
-
-        // Edge appearance settings
-        this.setupSettingInput<'edges', 'color'>('edges', 'color');
-        this.setupSettingInput<'edges', 'opacity'>('edges', 'opacity');
-        this.setupSettingInput<'edges', 'enableArrows'>('edges', 'enableArrows');
-
-        // Visual effects settings
-        this.setupSettingInput<'bloom', 'edgeBloomStrength'>('bloom', 'edgeBloomStrength');
+            await graphDataManager.loadInitialGraphData();
 
-        // Physics settings
-        this.setupSettingInput<'physics', 'enabled'>('physics', 'enabled');
-        this.setupSettingInput<'physics', 'springStrength'>('physics', 'springStrength');
-    }
-
-    private setupSettingInput<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K
-    ): void {
-        const input = document.getElementById(`${String(category)}-${String(setting)}`) as HTMLInputElement;
-        if (input) {
-            input.addEventListener('change', async (event) => {
-                const currentValue = (event.target as HTMLInputElement).value;
-
-                try {
-                    const response = await fetch(`/api/visualization/settings/${String(category)}/${String(setting)}`, {
-                        method: 'PUT',
-                        headers: {
-                            'Content-Type': 'application/json',
-                        },
-                        body: JSON.stringify({ value: currentValue }),
-                    });
-
-                    if (!response.ok) {
-                        throw new Error(`HTTP error! status: ${response.status}`);
-                    }
-
-                    await settingsManager.updateSetting(
-                        category,
-                        setting,
-                        this.parseSettingValue<T, K>(currentValue, category, setting)
-                    );
-                } catch (error) {
-                    logger.error(`Failed to update setting ${String(category)}.${String(setting)}:`, error);
-                    this.showError(`Failed to update ${String(category)} ${String(setting)}`);
+            const webSocket = WebSocketService.getInstance();
+            webSocket.onBinaryMessage((nodes: { position: [number, number, number]; velocity: [number, number, number] }[]) => {
+                if (this.nodeManager) {
+                    this.nodeManager.updateNodePositionsAndVelocities(nodes);
                 }
             });
-        }
-    }
-
-    private parseSettingValue<T extends SettingCategory, K extends SettingKey<T>>(
-        value: string,
-        category: T,
-        setting: K
-    ): SettingValueType<T, K> {
-        const currentSettings = settingsManager.getCurrentSettings();
-        const currentValue = currentSettings[category][setting];
-        
-        switch (typeof currentValue) {
-            case 'number':
-                return Number(value) as SettingValueType<T, K>;
-            case 'boolean':
-                return (value === 'true') as SettingValueType<T, K>;
-            default:
-                return value as SettingValueType<T, K>;
-        }
-    }
-
-    private async saveSettings(): Promise<void> {
-        try {
-            const currentSettings = settingsManager.getCurrentSettings();
-            const categories = ['nodes', 'edges', 'rendering', 'physics', 'labels', 'bloom', 'clientDebug'] as const;
-            
-            for (const category of categories) {
-                const categorySettings = currentSettings[category];
-                for (const [setting, value] of Object.entries(categorySettings)) {
-                    try {
-                        const response = await fetch(`/api/visualization/settings/${String(category)}/${String(setting)}`, {
-                            method: 'PUT',
-                            headers: {
-                                'Content-Type': 'application/json'
-                            },
-                            body: JSON.stringify({ value })
-                        });
-
-                        if (!response.ok) {
-                            throw new Error(`Failed to update setting: ${response.statusText}`);
-                        }
+            webSocket.onSettingsUpdate((settings: any) => {
+                settingsManager.batchUpdate(settings);
+            });
+            webSocket.onConnectionStatusChange((status: boolean) => {
+                this.updateConnectionStatus(status);
+            });
+            webSocket.connect();
 
-                        await settingsManager.updateSetting(
-                            category,
-                            setting as keyof Settings[typeof category],
-                            value as SettingValueType<typeof category, keyof Settings[typeof category]>
-                        );
-                    } catch (error) {
-                        logger.error(`Failed to update setting ${String(category)}.${String(setting)}:`, error);
-                    }
+            settingsManager.onSettingChange('visualization', () => {
+                if (this.nodeManager) {
+                    this.nodeManager.handleSettingsUpdate(settingsManager.getCurrentSettings());
                 }
-            }
-        } catch (error) {
-            logger.error('Failed to save settings:', error);
-            throw error;
-        }
-    }
+                if (this.sceneManager) {
+                    this.sceneManager.handleSettingsUpdate(settingsManager.getCurrentSettings());
+                }
+            });
+            settingsManager.onSettingChange('labels', () => {
+                if (this.textRenderer) {
+                    this.textRenderer.handleSettingsUpdate(settingsManager.getCurrentSettings().labels);
+                }
+            });
 
-    private async toggleXRSession(): Promise<void> {
-        if (!this.xrManager) return;
+            this.sceneManager.startRendering();
 
-        try {
-            if (this.xrManager.isXRPresenting()) {
-                await this.xrManager.endXRSession();
-            } else {
-                await this.xrManager.initXRSession();
-            }
+            this.hideLoadingOverlay();
         } catch (error) {
-            logger.error('Failed to toggle XR session:', error);
-            this.showError('Failed to start XR session');
+            logger.error('Failed to initialize application:', error);
+            this.showError('Failed to initialize application. Check console for details.');
         }
     }
 
     private hideLoadingOverlay(): void {
         const overlay = document.querySelector('.loading-overlay');
-        if (overlay && overlay instanceof HTMLElement) {
+        if (overlay instanceof HTMLElement) {
             overlay.style.opacity = '0';
             setTimeout(() => {
                 overlay.style.display = 'none';
-            }, 500); // Match this with CSS transition duration
+            }, 500);
         }
     }
 
     private showError(message: string): void {
         const overlay = document.querySelector('.loading-overlay');
-        if (overlay && overlay instanceof HTMLElement) {
+        if (overlay instanceof HTMLElement) {
             const spinner = overlay.querySelector('.spinner');
             if (spinner) {
                 spinner.remove();
             }
-            
+
             const error = document.createElement('div');
             error.className = 'error-message';
             error.textContent = message;
             overlay.appendChild(error);
-            
-            // Keep the overlay visible
+
             overlay.style.display = 'flex';
             overlay.style.opacity = '1';
         }
     }
 
-    dispose(): void {
-        // Stop rendering
+    public dispose(): void {
+        if (this.controlPanel) {
+            this.controlPanel.dispose();
+        }
         if (this.sceneManager) {
-            SceneManager.cleanup();
+            this.sceneManager.dispose();
         }
-
-        // Dispose of WebSocket
-        if (this.webSocket) {
-            this.webSocket.dispose();
+        
+        const webSocket = WebSocketService.getInstance();
+        if (webSocket) {
+            webSocket.dispose();
         }
-
-        // Clear graph data
+        
         graphDataManager.clear();
-
-        // Dispose of XR
+        
         if (this.xrManager) {
             this.xrManager.dispose();
         }
-
-        // Remove canvas
+        
         const container = document.getElementById('scene-container');
         if (container) {
             container.innerHTML = '';
         }
-
+        
         logger.log('Application disposed');
     }
+
+    private updateConnectionStatus(status: boolean): void {
+        const statusElement = document.getElementById('connection-status');
+        if (statusElement) {
+            statusElement.textContent = status ? 'Connected' : 'Disconnected';
+        }
+    }
 }
 
-// Create application instance
 const app = new Application();
 
-// Handle window unload
 window.addEventListener('unload', () => {
     app.dispose();
 });
 
-// Log application start
 console.info('LogseqXR application starting...');
diff --git a/client/rendering/EnhancedNodeManager.ts b/client/rendering/EnhancedNodeManager.ts
new file mode 100644
index 00000000..9127717d
--- /dev/null
+++ b/client/rendering/EnhancedNodeManager.ts
@@ -0,0 +1,275 @@
+import {
+    Scene,
+    InstancedMesh,
+    Matrix4,
+    Vector3,
+    Mesh,
+    Object3D,
+    Quaternion,
+    BufferGeometry,
+    Material,
+    PerspectiveCamera
+} from 'three';
+import { Node, NodeData } from '../core/types';
+import { Settings } from '../types/settings';
+import { MetadataVisualizer } from './MetadataVisualizer';
+import { XRHandWithHaptics } from '../types/xr';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { HologramShaderMaterial } from './materials/HologramShaderMaterial';
+
+export class EnhancedNodeManager {
+    private scene: Scene;
+    private settings: Settings;
+    private nodes: Map<string, Mesh> = new Map();
+    private nodeGeometry: BufferGeometry;
+    private nodeMaterial: Material;
+    private instancedMesh: InstancedMesh | null = null;
+    private dummy = new Object3D();
+    private geometryFactory: GeometryFactory;
+    private materialFactory: MaterialFactory;
+    private isInstanced: boolean = false;
+    private isHologram: boolean = false;
+    private hologramMaterial: HologramShaderMaterial | null = null;
+    private metadataMaterial: Material | null = null;
+    private metadataVisualizer: MetadataVisualizer;
+    private quaternion = new Quaternion();
+    private camera: PerspectiveCamera;
+
+    constructor(scene: Scene, settings: Settings) {
+        this.scene = scene;
+        this.settings = settings;
+
+        // Find the camera in the scene
+        let camera: PerspectiveCamera | null = null;
+        scene.traverse((object) => {
+            if (object instanceof PerspectiveCamera) {
+                camera = object;
+            }
+        });
+        if (!camera) {
+            camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+            camera.position.set(0, 5, 20);
+            camera.lookAt(0, 0, 0);
+            scene.add(camera);
+        }
+        this.camera = camera;
+
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.materialFactory = MaterialFactory.getInstance();
+        this.nodeGeometry = this.geometryFactory.getNodeGeometry(settings.visualization.nodes.quality);
+        this.nodeMaterial = this.materialFactory.getNodeMaterial(settings);
+
+        if (this.settings.visualization.nodes.enableHologram) {
+            this.hologramMaterial = this.materialFactory.getHologramMaterial(settings);
+        }
+
+        this.metadataMaterial = this.materialFactory.getMetadataMaterial();
+
+        // Initialize MetadataVisualizer with both camera and scene
+        this.metadataVisualizer = new MetadataVisualizer(this.camera, this.scene, settings);
+        this.setupInstancedMesh();
+    }
+
+    private setupInstancedMesh() {
+        if (this.isInstanced) {
+            this.instancedMesh = new InstancedMesh(this.nodeGeometry, this.nodeMaterial, 1000);
+            this.instancedMesh.count = 0;
+            this.scene.add(this.instancedMesh);
+        }
+    }
+
+    public updateNodePositionsAndVelocities(nodes: { position: [number, number, number]; velocity: [number, number, number] }[]): void {
+        if (!this.instancedMesh) return;
+    
+        nodes.forEach((node, i) => {
+            this.dummy.position.set(node.position[0], node.position[1], node.position[2]);
+    
+            const velocityMagnitude = Math.sqrt(
+                node.velocity[0] * node.velocity[0] +
+                node.velocity[1] * node.velocity[1] +
+                node.velocity[2] * node.velocity[2]
+            );
+            const scaleFactor = 1 + velocityMagnitude * 0.5;
+            this.dummy.scale.set(scaleFactor, scaleFactor, scaleFactor);
+    
+            this.dummy.updateMatrix();
+            this.instancedMesh?.setMatrixAt(i, this.dummy.matrix);
+        });
+    
+        if (this.instancedMesh) {
+            this.instancedMesh.instanceMatrix.needsUpdate = true;
+        }
+    }
+
+    public handleSettingsUpdate(settings: Settings): void {
+        this.settings = settings;
+        const newGeometry = this.geometryFactory.getNodeGeometry(settings.visualization.nodes.quality);
+        if (this.nodeGeometry !== newGeometry) {
+            this.nodeGeometry = newGeometry;
+            if (this.instancedMesh) {
+                this.instancedMesh.geometry = this.nodeGeometry;
+            }
+        }
+
+        this.materialFactory.updateMaterial('node-basic', settings);
+        this.materialFactory.updateMaterial('node-phong', settings);
+        this.materialFactory.updateMaterial('edge', settings);
+        if (this.isHologram) {
+            this.materialFactory.updateMaterial('hologram', settings);
+        }
+
+        const newIsInstanced = settings.visualization.nodes.enableInstancing;
+        const newIsHologram = settings.visualization.nodes.enableHologram;
+
+        if (newIsInstanced !== this.isInstanced || newIsHologram !== this.isHologram) {
+            this.isInstanced = newIsInstanced;
+            this.isHologram = newIsHologram;
+            this.rebuildInstancedMesh();
+        }
+
+        if (settings.visualization.nodes.enableMetadataVisualization && this.metadataMaterial) {
+            const serverSupportsMetadata = true;
+            if (serverSupportsMetadata) {
+                // Apply metadata material and update visualization
+            } else {
+                // Disable metadata visualization
+            }
+        }
+    }
+
+    private rebuildInstancedMesh() {
+        if (this.isInstanced) {
+            this.instancedMesh = new InstancedMesh(this.nodeGeometry, this.nodeMaterial, 1000);
+            this.instancedMesh.count = 0;
+            this.scene.add(this.instancedMesh);
+        }
+    }
+
+    updateNodes(nodes: Node[]) {
+        const mesh = this.instancedMesh;
+        if (!mesh) return;
+        
+        mesh.count = nodes.length;
+
+        nodes.forEach((node, index) => {
+            const metadata = {
+                id: node.id,
+                name: node.data.metadata?.name || '',
+                commitAge: this.calculateCommitAge(node.data.metadata?.lastModified || Date.now()),
+                hyperlinkCount: node.data.metadata?.links?.length || 0,
+                importance: this.calculateImportance(node),
+                position: {
+                    x: node.data.position.x,
+                    y: node.data.position.y,
+                    z: node.data.position.z
+                }
+            };
+
+            const matrix = new Matrix4();
+
+            if (this.settings.visualization.nodes.enableMetadataShape) {
+                const nodeMesh = this.metadataVisualizer.createNodeMesh(metadata);
+                nodeMesh.position.set(metadata.position.x, metadata.position.y, metadata.position.z);
+                this.scene.add(nodeMesh);
+            } else {
+                const scale = this.calculateNodeScale(metadata.importance);
+                const position = new Vector3(metadata.position.x, metadata.position.y, metadata.position.z);
+                matrix.compose(position, this.quaternion, new Vector3(scale, scale, scale));
+                mesh.setMatrixAt(index, matrix);
+            }
+
+            const child = mesh.children[index];
+            if (child instanceof Mesh) {
+                this.nodes.set(node.id, child);
+            }
+        });
+
+        mesh.instanceMatrix.needsUpdate = true;
+    }
+
+    private calculateCommitAge(timestamp: number): number {
+        const now = Date.now();
+        return (now - timestamp) / (1000 * 60 * 60 * 24); // Convert to days
+    }
+
+    private calculateImportance(node: Node): number {
+        const linkFactor = node.data.metadata?.links ? node.data.metadata.links.length / 20 : 0;
+        const referenceFactor = node.data.metadata?.references ? node.data.metadata.references.length / 10 : 0;
+        return Math.min(linkFactor + referenceFactor, 1);
+    }
+
+    private calculateNodeScale(importance: number): number {
+        const [min, max] = this.settings.visualization.nodes.sizeRange;
+        return min + (max - min) * importance;
+    }
+
+    update(deltaTime: number) {
+        if (this.isHologram && this.hologramMaterial) {
+            this.hologramMaterial.update(deltaTime);
+        }
+
+        if (this.settings.visualization.animations.enableNodeAnimations) {
+            if (this.instancedMesh) {
+                this.instancedMesh.instanceMatrix.needsUpdate = true;
+            }
+            this.scene.traverse(child => {
+                if (child instanceof Mesh) {
+                    child.rotateY(0.001 * deltaTime);
+                }
+            });
+        }
+    }
+
+    handleHandInteraction(hand: XRHandWithHaptics) {
+        const position = new Vector3();
+        const indexTip = hand.hand.joints['index-finger-tip'] as Object3D | undefined;
+        if (indexTip) {
+            position.setFromMatrixPosition(indexTip.matrixWorld);
+            if (this.isHologram && this.hologramMaterial) {
+                this.hologramMaterial.handleInteraction(position);
+            }
+        }
+    }
+
+    dispose() {
+        if (this.instancedMesh) {
+            this.instancedMesh.geometry.dispose();
+            this.instancedMesh.material.dispose();
+            this.scene.remove(this.instancedMesh);
+        }
+        if (this.isHologram && this.hologramMaterial) {
+            this.hologramMaterial.dispose();
+        }
+        if (this.metadataMaterial) {
+            this.metadataMaterial.dispose();
+        }
+    }
+
+    public createNode(id: string, data: NodeData, metadata: any): void {
+        const position = new Vector3(data.position.x, data.position.y, data.position.z);
+        const scale = this.calculateNodeScale(this.calculateImportance({ id, data, metadata }));
+        
+        if (this.settings.visualization.nodes.enableMetadataShape) {
+            const nodeMesh = this.metadataVisualizer.createNodeMesh({
+                id,
+                name: metadata?.name || '',
+                commitAge: this.calculateCommitAge(metadata?.lastModified || Date.now()),
+                hyperlinkCount: metadata?.links?.length || 0,
+                importance: this.calculateImportance({ id, data, metadata }),
+                position: data.position
+            });
+            this.nodes.set(id, nodeMesh);
+            this.scene.add(nodeMesh);
+        } else if (this.instancedMesh) {
+            const matrix = new Matrix4();
+            matrix.compose(position, this.quaternion, new Vector3(scale, scale, scale));
+            const index = this.nodes.size;
+            this.instancedMesh.setMatrixAt(index, matrix);
+            this.instancedMesh.count = index + 1;
+            this.instancedMesh.instanceMatrix.needsUpdate = true;
+            // Store a reference to the instanced mesh for this node
+            this.nodes.set(id, this.instancedMesh);
+        }
+    }
+}
diff --git a/client/rendering/HologramManager.ts b/client/rendering/HologramManager.ts
new file mode 100644
index 00000000..f192fb97
--- /dev/null
+++ b/client/rendering/HologramManager.ts
@@ -0,0 +1,142 @@
+import {
+    Scene,
+    Group,
+    Mesh,
+    Vector3,
+    WebGLRenderer
+} from 'three';
+import { Settings } from '../types/settings';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { HologramShaderMaterial } from './materials/HologramShaderMaterial';
+
+export class HologramManager {
+    private readonly group = new Group();
+    private isXRMode = false;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly materialFactory: MaterialFactory;
+
+    constructor(
+        private readonly scene: Scene,
+        _renderer: WebGLRenderer,  // Used by subclasses
+        private settings: Settings
+    ) {
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.materialFactory = MaterialFactory.getInstance();
+        this.createHolograms();
+        this.scene.add(this.group);
+    }
+
+    private createHolograms() {
+        while (this.group.children.length > 0) {
+            const child = this.group.children[0];
+            this.group.remove(child);
+            if (child instanceof Mesh) {
+                child.geometry.dispose();
+                child.material.dispose();
+            }
+        }
+
+        const quality = this.isXRMode ? 'high' : this.settings.xr.quality;
+        const material = this.materialFactory.getHologramMaterial(this.settings);
+
+        for (let i = 0; i < this.settings.visualization.hologram.ringCount; i++) {
+            const ring = new Mesh(
+                this.geometryFactory.getHologramGeometry('ring', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.ringSizes[i] || 20;
+            ring.scale.set(scale, scale, scale);
+            ring.rotateX(Math.PI / 2 * i);
+            ring.rotateY(Math.PI / 4 * i);
+            ring.userData.rotationSpeed = this.settings.visualization.hologram.ringRotationSpeed * (i + 1);
+            this.group.add(ring);
+        }
+
+        if (this.settings.visualization.hologram.enableBuckminster) {
+            const mesh = new Mesh(
+                this.geometryFactory.getHologramGeometry('buckminster', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.buckminsterScale;
+            mesh.scale.set(scale, scale, scale);
+            (mesh.material as HologramShaderMaterial).uniforms.opacity.value = this.settings.visualization.hologram.buckminsterOpacity;
+            this.group.add(mesh);
+        }
+
+        if (this.settings.visualization.hologram.enableGeodesic) {
+            const mesh = new Mesh(
+                this.geometryFactory.getHologramGeometry('geodesic', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.geodesicScale;
+            mesh.scale.set(scale, scale, scale);
+            (mesh.material as HologramShaderMaterial).uniforms.opacity.value = this.settings.visualization.hologram.geodesicOpacity;
+            this.group.add(mesh);
+        }
+
+        if (this.settings.visualization.hologram.enableTriangleSphere) {
+            const mesh = new Mesh(
+                this.geometryFactory.getHologramGeometry('triangleSphere', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.triangleSphereScale;
+            mesh.scale.set(scale, scale, scale);
+            (mesh.material as HologramShaderMaterial).uniforms.opacity.value = this.settings.visualization.hologram.triangleSphereOpacity;
+            this.group.add(mesh);
+        }
+    }
+
+    setXRMode(enabled: boolean) {
+        this.isXRMode = enabled;
+        this.group.traverse(child => {
+            if (child instanceof Mesh && child.material instanceof HologramShaderMaterial) {
+                child.material.defines = { USE_AR: '' };
+                child.material.needsUpdate = true;
+            }
+        });
+        this.createHolograms();
+    }
+
+    handleInteraction(position: Vector3) {
+        this.group.traverse(child => {
+            if (child instanceof Mesh && child.material instanceof HologramShaderMaterial) {
+                const distance = position.distanceTo(child.position);
+                if (distance < 0.5) {
+                    child.material.uniforms.pulseIntensity.value = 0.4;
+                    setTimeout(() => {
+                        if (child.material instanceof HologramShaderMaterial) {
+                            child.material.uniforms.pulseIntensity.value = 0.2;
+                        }
+                    }, 500);
+                }
+            }
+        });
+    }
+
+    update(deltaTime: number) {
+        this.group.traverse(child => {
+            if (child instanceof Mesh) {
+                child.rotateY((child.userData.rotationSpeed || this.settings.visualization.hologram.globalRotationSpeed) * deltaTime);
+                if (child.material instanceof HologramShaderMaterial) {
+                    child.material.uniforms.time.value += deltaTime;
+                }
+            }
+        });
+    }
+
+    updateSettings(newSettings: Settings) {
+        this.settings = newSettings;
+        this.materialFactory.updateMaterial('hologram', this.settings);
+        this.createHolograms();
+    }
+
+    getGroup() {
+        return this.group;
+    }
+
+    dispose() {
+        // Geometries and materials are managed by the factories
+        this.scene.remove(this.group);
+    }
+}
diff --git a/client/rendering/MetadataVisualizer.ts b/client/rendering/MetadataVisualizer.ts
new file mode 100644
index 00000000..7d63881b
--- /dev/null
+++ b/client/rendering/MetadataVisualizer.ts
@@ -0,0 +1,154 @@
+import { 
+    Color, 
+    Matrix4, 
+    Mesh, 
+    PerspectiveCamera, 
+    Scene, 
+    Vector3, 
+    Material,
+    MeshBasicMaterial,
+    Quaternion
+} from 'three';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { Metadata } from '../types/metadata';
+import { Settings } from '../types/settings';
+import { defaultSettings } from '../state/defaultSettings';
+
+export class MetadataVisualizer {
+    private readonly camera: PerspectiveCamera;
+    private readonly scene: Scene;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly materialFactory: MaterialFactory;
+    private settings: Settings;
+    private nodes: Map<string, Mesh> = new Map();
+
+    constructor(camera: PerspectiveCamera, scene: Scene, settings: Settings = defaultSettings) {
+        this.camera = camera;
+        this.scene = scene;
+        this.settings = settings;
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.materialFactory = MaterialFactory.getInstance();
+    }
+
+    public createNodeMesh(metadata: Metadata): Mesh {
+        const geometry = this.geometryFactory.getNodeGeometry(this.settings.xr.quality);
+        const material = this.materialFactory.getMetadataMaterial();
+        
+        const mesh = new Mesh(geometry, material);
+        mesh.position.set(
+            metadata.position?.x || 0,
+            metadata.position?.y || 0,
+            metadata.position?.z || 0
+        );
+        
+        this.nodes.set(metadata.id, mesh);
+        this.scene.add(mesh);
+        
+        return mesh;
+    }
+
+    public dispose(): void {
+        this.nodes.forEach(mesh => {
+            this.scene.remove(mesh);
+            mesh.geometry.dispose();
+            if (Array.isArray(mesh.material)) {
+                mesh.material.forEach(m => m.dispose());
+            } else {
+                mesh.material.dispose();
+            }
+        });
+        this.nodes.clear();
+    }
+
+    public updateNodeMetadata(
+        mesh: Mesh,
+        _age: number,
+        linkCount: number,
+        material: Material
+    ): void {
+        // Calculate color based on link count
+        if (material instanceof MeshBasicMaterial) {
+            // Simple color interpolation based on link count
+            const intensity = Math.min(linkCount / 10, 1); // Cap at 10 links
+            
+            // Convert RGB values to hex
+            const red = Math.floor(intensity * 255);
+            const green = Math.floor((1 - intensity) * 255);
+            const blue = 0;
+            const hexColor = (red << 16) | (green << 8) | blue;
+            
+            // Create and assign color
+            const newColor = new Color(hexColor);
+            material.color = newColor;
+        }
+
+        // Update mesh orientation to face camera
+        const meshPosition = mesh.position;
+        const cameraPosition = this.camera.position;
+
+        // Calculate direction from mesh to camera
+        const direction = new Vector3()
+            .subVectors(cameraPosition, meshPosition)
+            .normalize();
+
+        // Calculate up vector (world up)
+        const up = new Vector3(0, 1, 0);
+
+        // Calculate right vector
+        const right = new Vector3()
+            .crossVectors(up, direction)
+            .normalize();
+
+        // Recalculate up vector to ensure orthogonality
+        up.crossVectors(direction, right).normalize();
+
+        // Create rotation matrix
+        const rotationMatrix = new Matrix4();
+        rotationMatrix.elements = [
+            right.x, up.x, direction.x, 0,
+            right.y, up.y, direction.y, 0,
+            right.z, up.z, direction.z, 0,
+            0, 0, 0, 1
+        ];
+
+        // Create quaternion from direction
+        const quaternion = new Quaternion();
+        const m = rotationMatrix.elements;
+        const trace = m[0] + m[5] + m[10];
+
+        if (trace > 0) {
+            const s = 0.5 / Math.sqrt(trace + 1.0);
+            quaternion.w = 0.25 / s;
+            quaternion.x = (m[6] - m[9]) * s;
+            quaternion.y = (m[8] - m[2]) * s;
+            quaternion.z = (m[1] - m[4]) * s;
+        } else {
+            if (m[0] > m[5] && m[0] > m[10]) {
+                const s = 2.0 * Math.sqrt(1.0 + m[0] - m[5] - m[10]);
+                quaternion.w = (m[6] - m[9]) / s;
+                quaternion.x = 0.25 * s;
+                quaternion.y = (m[1] + m[4]) / s;
+                quaternion.z = (m[8] + m[2]) / s;
+            } else if (m[5] > m[10]) {
+                const s = 2.0 * Math.sqrt(1.0 + m[5] - m[0] - m[10]);
+                quaternion.w = (m[8] - m[2]) / s;
+                quaternion.x = (m[1] + m[4]) / s;
+                quaternion.y = 0.25 * s;
+                quaternion.z = (m[6] + m[9]) / s;
+            } else {
+                const s = 2.0 * Math.sqrt(1.0 + m[10] - m[0] - m[5]);
+                quaternion.w = (m[1] - m[4]) / s;
+                quaternion.x = (m[8] + m[2]) / s;
+                quaternion.y = (m[6] + m[9]) / s;
+                quaternion.z = 0.25 * s;
+            }
+        }
+
+        // Apply rotation
+        mesh.quaternion.x = quaternion.x;
+        mesh.quaternion.y = quaternion.y;
+        mesh.quaternion.z = quaternion.z;
+        mesh.quaternion.w = quaternion.w;
+    }
+}
diff --git a/client/rendering/factories/GeometryFactory.ts b/client/rendering/factories/GeometryFactory.ts
new file mode 100644
index 00000000..8b3a2b52
--- /dev/null
+++ b/client/rendering/factories/GeometryFactory.ts
@@ -0,0 +1,84 @@
+import { BufferGeometry, SphereGeometry, CylinderGeometry } from 'three';
+
+export class GeometryFactory {
+    private static instance: GeometryFactory;
+    private geometryCache = new Map<string, BufferGeometry>();
+
+    private constructor() {}
+
+    static getInstance(): GeometryFactory {
+        if (!GeometryFactory.instance) {
+            GeometryFactory.instance = new GeometryFactory();
+        }
+        return GeometryFactory.instance;
+    }
+
+    getNodeGeometry(quality: 'low' | 'medium' | 'high'): BufferGeometry {
+        const cacheKey = `node-${quality}`;
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        const segments = {
+            low: 8,
+            medium: 16,
+            high: 32
+        }[quality] || 16;
+
+        const geometry = new SphereGeometry(1, segments, segments);
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    getHologramGeometry(type: string, quality: string): BufferGeometry {
+        const cacheKey = `hologram-${type}-${quality}`;
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        const segments = {
+            low: { ring: 32, sphere: 8 },
+            medium: { ring: 64, sphere: 16 },
+            high: { ring: 128, sphere: 32 }
+        }[quality] || { ring: 64, sphere: 16 };
+
+        let geometry: BufferGeometry;
+        switch (type) {
+            case 'ring':
+                geometry = new SphereGeometry(1, segments.ring, segments.ring);
+                break;
+            case 'buckminster':
+                geometry = new SphereGeometry(1, 20, 20);
+                break;
+            case 'geodesic':
+                geometry = new SphereGeometry(1, 16, 16);
+                break;
+            case 'triangleSphere':
+                geometry = new SphereGeometry(1, segments.sphere, segments.sphere);
+                break;
+            default:
+                geometry = new SphereGeometry(1, segments.sphere, segments.sphere);
+        }
+
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    getEdgeGeometry(): BufferGeometry {
+        const cacheKey = 'edge';
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        // CylinderGeometry parameters:
+        // radiusTop, radiusBottom, height, radialSegments
+        const geometry = new CylinderGeometry(0.05, 0.05, 1, 8);
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    dispose(): void {
+        this.geometryCache.forEach(geometry => geometry.dispose());
+        this.geometryCache.clear();
+    }
+}
diff --git a/client/rendering/factories/MaterialFactory.ts b/client/rendering/factories/MaterialFactory.ts
new file mode 100644
index 00000000..47d2d325
--- /dev/null
+++ b/client/rendering/factories/MaterialFactory.ts
@@ -0,0 +1,129 @@
+import { Color, DoubleSide, Material, MeshBasicMaterial, MeshPhongMaterial } from 'three';
+import { Settings } from '../../types/settings';
+import { HologramShaderMaterial } from '../materials/HologramShaderMaterial';
+
+type CachedMaterial = Material | HologramShaderMaterial;
+
+export class MaterialFactory {
+    private static instance: MaterialFactory;
+    private materialCache = new Map<string, CachedMaterial>();
+
+    private constructor() {}
+
+    static getInstance(): MaterialFactory {
+        if (!MaterialFactory.instance) {
+            MaterialFactory.instance = new MaterialFactory();
+        }
+        return MaterialFactory.instance;
+    }
+
+    getNodeMaterial(settings: Settings): Material {
+        const cacheKey = 'node-basic';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshBasicMaterial({
+            color: settings.visualization.nodes.baseColor,
+            transparent: true,
+            opacity: settings.visualization.nodes.opacity
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    getPhongNodeMaterial(): Material {
+        const cacheKey = 'node-phong';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshPhongMaterial({
+            color: 0x4fc3f7,
+            shininess: 30,
+            specular: 0x004ba0,
+            transparent: true,
+            opacity: 0.9,
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    getMetadataMaterial(): Material {
+        const cacheKey = 'metadata';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshBasicMaterial({
+            color: new Color('#00ff00'),
+            transparent: true,
+            opacity: 0.8,
+            side: DoubleSide
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    getHologramMaterial(settings: Settings): HologramShaderMaterial {
+        const cacheKey = 'hologram';
+        const cached = this.materialCache.get(cacheKey);
+        if (cached && cached instanceof HologramShaderMaterial) {
+            return cached;
+        }
+
+        const material = new HologramShaderMaterial(settings);
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    updateMaterial(type: string, settings: Settings): void {
+        const material = this.materialCache.get(type);
+        if (!material) return;
+
+        switch (type) {
+            case 'node-basic':
+            case 'node-phong':
+                if (material instanceof MeshBasicMaterial || material instanceof MeshPhongMaterial) {
+                    material.color.set(settings.visualization.nodes.baseColor);
+                    material.opacity = settings.visualization.nodes.opacity;
+                }
+                break;
+            case 'hologram':
+                if (material instanceof HologramShaderMaterial) {
+                    const hexColor = settings.visualization.hologram.ringColor;
+                    const hex = hexColor.replace('#', '');
+                    const r = parseInt(hex.substring(0, 2), 16) / 255;
+                    const g = parseInt(hex.substring(2, 4), 16) / 255;
+                    const b = parseInt(hex.substring(4, 6), 16) / 255;
+                    material.uniforms.color.value.set(r, g, b);
+                    material.uniforms.opacity.value = settings.visualization.hologram.ringOpacity;
+                }
+                break;
+        }
+    }
+
+    dispose(): void {
+        this.materialCache.forEach(material => material.dispose());
+        this.materialCache.clear();
+    }
+
+    getEdgeMaterial(settings: Settings): Material {
+        const cacheKey = 'edge';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshBasicMaterial({
+            color: new Color(settings.visualization.edges.color),
+            opacity: settings.visualization.edges.opacity,
+            transparent: true
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+}
diff --git a/client/rendering/materials/HologramShaderMaterial.ts b/client/rendering/materials/HologramShaderMaterial.ts
new file mode 100644
index 00000000..c1422ca5
--- /dev/null
+++ b/client/rendering/materials/HologramShaderMaterial.ts
@@ -0,0 +1,152 @@
+import { Vector2, Vector3, Color, Texture, Material, DoubleSide, Side } from 'three';
+import { Settings } from '../../types/settings';
+
+interface HologramUniforms {
+    time: { value: number };
+    color: { value: Vector3 };
+    texture: { value: Texture | null };
+    resolution: { value: Vector2 };
+    interactionPoint: { value: Vector3 };
+    interactionStrength: { value: number };
+    opacity: { value: number };
+    pulseIntensity: { value: number };
+}
+
+export class HologramShaderMaterial extends Material {
+    uniforms: HologramUniforms;
+    vertexShader: string;
+    fragmentShader: string;
+    color: Color = new Color();
+    type = 'HologramShaderMaterial';
+    defines: { [key: string]: string | number | boolean } = {};
+
+    // Declare required Material properties
+    declare transparent: boolean;
+    declare opacity: number;
+    declare depthTest: boolean;
+    declare depthWrite: boolean;
+    declare blending: number;
+    declare side: Side;
+    declare needsUpdate: boolean;
+    declare vertexColors: boolean;
+    declare visible: boolean;
+    declare toneMapped: boolean;
+    declare fog: boolean;
+    declare lights: boolean;
+
+    constructor(settings: Settings) {
+        super();
+
+        this.uniforms = {
+            time: { value: 0 },
+            color: { value: new Vector3() },
+            texture: { value: null },
+            resolution: { value: new Vector2(window.innerWidth, window.innerHeight) },
+            interactionPoint: { value: new Vector3() },
+            interactionStrength: { value: 0.0 },
+            opacity: { value: settings.visualization.hologram.ringOpacity },
+            pulseIntensity: { value: 0.2 }
+        };
+
+        this.vertexShader = `
+            varying vec2 vUv;
+            varying vec3 vPosition;
+            void main() {
+                vUv = uv;
+                vPosition = position;
+                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+            }
+        `;
+
+        this.fragmentShader = `
+            uniform float time;
+            uniform vec3 color;
+            uniform sampler2D texture;
+            uniform vec2 resolution;
+            uniform vec3 interactionPoint;
+            uniform float interactionStrength;
+            uniform float opacity;
+            uniform float pulseIntensity;
+            varying vec2 vUv;
+            varying vec3 vPosition;
+
+            void main() {
+                vec2 uv = vUv;
+                
+                // Base distortion
+                float distortion = sin(time * 2.0 + uv.x * 10.0) * 0.02;
+                
+                // Interaction distortion
+                float dist = length(vPosition - interactionPoint);
+                float interactionDistortion = interactionStrength * (1.0 - smoothstep(0.0, 2.0, dist));
+                distortion += interactionDistortion;
+                
+                uv.y += distortion;
+                vec4 texColor = texture2D(texture, uv);
+                
+                // Hologram effect
+                float scanline = sin(uv.y * 100.0 + time * 5.0) * 0.1 + 0.9;
+                float flicker = sin(time * 20.0) * 0.05 + 0.95;
+                
+                // Pulse effect
+                float pulse = sin(time * 3.0) * pulseIntensity;
+                
+                // Alpha calculation
+                float alpha = opacity * scanline * flicker * (1.0 + pulse);
+                if (interactionStrength > 0.0) {
+                    alpha *= (1.0 + interactionDistortion);
+                }
+                
+                gl_FragColor = vec4(color, alpha) * texColor;
+            }
+        `;
+
+        // Set material properties
+        this.transparent = true;
+        this.depthWrite = true;
+        this.depthTest = true;
+        this.side = DoubleSide;
+        this.blending = 1; // NormalBlending = 1
+        this.vertexColors = false;
+        this.visible = true;
+        this.toneMapped = true;
+        this.fog = false;
+        this.lights = false;
+
+        // Set initial color from settings
+        const hexColor = settings.visualization.hologram.ringColor;
+        const hex = hexColor.replace('#', '');
+        const r = parseInt(hex.substring(0, 2), 16) / 255;
+        const g = parseInt(hex.substring(2, 4), 16) / 255;
+        const b = parseInt(hex.substring(4, 6), 16) / 255;
+        this.uniforms.color.value.set(r, g, b);
+        this.color.set(hexColor);
+
+        this.opacity = settings.visualization.hologram.ringOpacity;
+        this.uniforms.opacity.value = this.opacity;
+        this.needsUpdate = true;
+    }
+
+    update(deltaTime: number): void {
+        this.uniforms.time.value += deltaTime;
+        this.uniforms.interactionStrength.value *= 0.95; // Gradual decay
+    }
+
+    handleInteraction(position: Vector3): void {
+        this.uniforms.interactionPoint.value.copy(position);
+        this.uniforms.interactionStrength.value = 1.0; // Full strength on interaction
+    }
+
+    dispose(): void {
+        super.dispose();
+        
+        // Dispose of any textures
+        if (this.uniforms.texture.value) {
+            this.uniforms.texture.value.dispose();
+        }
+    }
+
+    clone(): this {
+        return new HologramShaderMaterial(this.uniforms as any) as this;
+    }
+}
diff --git a/client/rendering/nodes.ts b/client/rendering/nodes.ts
index 9629a8c5..5ef277ae 100644
--- a/client/rendering/nodes.ts
+++ b/client/rendering/nodes.ts
@@ -1,9 +1,11 @@
 import * as THREE from 'three';
 import { Node } from '../core/types';
-import { createLogger } from '../utils/logger';
+import { createLogger } from '../core/logger';
 import { settingsManager } from '../state/settings';
 import type { Settings } from '../types/settings';
-import type { NodeSettings, PhysicsSettings } from '../core/types';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { SettingsObserver } from '../state/SettingsObserver';
 
 const logger = createLogger('NodeManager');
 
@@ -19,33 +21,31 @@ export class NodeRenderer {
     public readonly material: THREE.Material;
     protected currentSettings: Settings;
     public mesh: THREE.Mesh;
+    private readonly materialFactory: MaterialFactory;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly settingsObserver: SettingsObserver;
 
     constructor() {
         this.currentSettings = settingsManager.getCurrentSettings();
-        this.material = new THREE.MeshPhongMaterial({
-            color: 0x4fc3f7,
-            shininess: 30,
-            specular: 0x004ba0,
-            transparent: true,
-            opacity: 0.9,
-        });
+        this.materialFactory = MaterialFactory.getInstance();
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.settingsObserver = SettingsObserver.getInstance();
 
+        this.material = this.materialFactory.getPhongNodeMaterial();
         this.mesh = new THREE.Mesh(
-            new THREE.SphereGeometry(1, 32, 32),
+            this.geometryFactory.getNodeGeometry(this.currentSettings.xr.quality),
             this.material
         );
 
         this.setupSettingsSubscriptions();
     }
 
-    public handleSettingChange(setting: keyof NodeSettings, value: any): void {
+    public handleSettingChange(setting: keyof Settings['visualization']['nodes'], value: any): void {
         try {
             switch (setting) {
                 case 'baseColor':
-                    this.material.color.set(value as string);
-                    break;
                 case 'opacity':
-                    this.material.opacity = value as number;
+                    this.materialFactory.updateMaterial('node-phong', this.currentSettings);
                     break;
                 case 'baseSize':
                     this.mesh.scale.set(value, value, value);
@@ -54,27 +54,30 @@ export class NodeRenderer {
                     // Other settings handled elsewhere
                     break;
             }
-            (this.material as any).needsUpdate = true;
         } catch (error) {
             logger.error(`Error applying node setting change for ${String(setting)}:`, error);
         }
     }
 
-    public handlePhysicsSettingChange(setting: keyof PhysicsSettings, value: any): void {
+    public handlePhysicsSettingChange(setting: keyof Settings['visualization']['physics'], value: any): void {
         // Dummy implementation for now
         logger.debug(`Physics setting change: ${String(setting)} = ${value}`);
     }
 
     private setupSettingsSubscriptions(): void {
-        Object.keys(this.currentSettings.nodes).forEach(setting => {
-            settingsManager.subscribe('nodes', setting as keyof NodeSettings, (value) => {
-                this.handleSettingChange(setting as keyof NodeSettings, value);
+        this.settingsObserver.subscribe('NodeRenderer', (settings) => {
+            this.currentSettings = settings;
+            Object.keys(settings.visualization.nodes).forEach(setting => {
+                this.handleSettingChange(
+                    setting as keyof Settings['visualization']['nodes'],
+                    settings.visualization.nodes[setting as keyof Settings['visualization']['nodes']]
+                );
             });
-        });
-
-        Object.keys(this.currentSettings.physics).forEach(setting => {
-            settingsManager.subscribe('physics', setting as keyof PhysicsSettings, (value) => {
-                this.handlePhysicsSettingChange(setting as keyof PhysicsSettings, value);
+            Object.keys(settings.visualization.physics).forEach(setting => {
+                this.handlePhysicsSettingChange(
+                    setting as keyof Settings['visualization']['physics'],
+                    settings.visualization.physics[setting as keyof Settings['visualization']['physics']]
+                );
             });
         });
     }
@@ -85,42 +88,49 @@ export class NodeManager {
     private currentSettings: Settings;
     private nodeInstances: THREE.InstancedMesh;
     private edgeInstances: THREE.InstancedMesh;
-    private unsubscribers: Array<() => void> = [];
     private nodeRenderer: NodeRenderer;
     private currentNodes: Node[] = [];
     private nodeIndices: Map<string, number> = new Map();
+    private readonly materialFactory: MaterialFactory;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly settingsObserver: SettingsObserver;
 
     private constructor() {
         this.currentSettings = settingsManager.getCurrentSettings();
+        this.materialFactory = MaterialFactory.getInstance();
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.settingsObserver = SettingsObserver.getInstance();
         this.nodeRenderer = new NodeRenderer();
 
-        const nodeGeometry = new THREE.SphereGeometry(1, 32, 32);
-        const edgeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
-        edgeGeometry.rotateX(Math.PI / 2);
-
         this.nodeInstances = new THREE.InstancedMesh(
-            nodeGeometry,
+            this.geometryFactory.getNodeGeometry(this.currentSettings.xr.quality),
             this.nodeRenderer.material,
             10000
         );
 
         this.edgeInstances = new THREE.InstancedMesh(
-            edgeGeometry,
-            this.createEdgeMaterial(),
+            this.geometryFactory.getHologramGeometry('ring', this.currentSettings.xr.quality),
+            this.materialFactory.getMetadataMaterial(),
             30000
         );
 
         this.setupSettingsSubscriptions();
     }
 
-    private createEdgeMaterial(): THREE.Material {
-        return new THREE.MeshBasicMaterial({
-            transparent: true,
-            opacity: this.currentSettings.edges.opacity,
-            color: this.currentSettings.nodes.baseColor,
+    private setupSettingsSubscriptions(): void {
+        this.settingsObserver.subscribe('NodeManager', (settings) => {
+            this.currentSettings = settings;
+            this.materialFactory.updateMaterial('metadata', settings);
         });
     }
 
+    public static getInstance(): NodeManager {
+        if (!NodeManager.instance) {
+            NodeManager.instance = new NodeManager();
+        }
+        return NodeManager.instance;
+    }
+
     public updatePositions(positions: Float32Array): void {
         if (!this.nodeInstances) return;
 
@@ -129,15 +139,23 @@ export class NodeManager {
         for (let i = 0; i < count; i++) {
             const baseIndex = i * FLOATS_PER_NODE;
             
+            // Get position values
+            const x = positions[baseIndex];
+            const y = positions[baseIndex + 1];
+            const z = positions[baseIndex + 2];
+            
+            // Skip invalid positions
+            if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z) ||
+                Math.abs(x) > 1000 || Math.abs(y) > 1000 || Math.abs(z) > 1000) {
+                logger.warn(`Skipping invalid position for node ${i}: (${x}, ${y}, ${z})`);
+                continue;
+            }
+            
             // Update position
-            position.set(
-                positions[baseIndex],
-                positions[baseIndex + 1],
-                positions[baseIndex + 2]
-            );
+            position.set(x, y, z);
             
             // Set initial scale based on settings
-            const baseSize = this.currentSettings.nodes.baseSize || 1;
+            const baseSize = this.currentSettings.visualization.nodes.baseSize || 1;
             scale.set(baseSize, baseSize, baseSize);
             
             // Update instance matrix
@@ -148,7 +166,7 @@ export class NodeManager {
         this.nodeInstances.instanceMatrix.needsUpdate = true;
         
         // Force a render update
-        if (this.currentSettings.animations.enableNodeAnimations) {
+        if (this.currentSettings.visualization.animations.enableNodeAnimations) {
             requestAnimationFrame(() => {
                 this.nodeInstances.instanceMatrix.needsUpdate = true;
             });
@@ -179,57 +197,50 @@ export class NodeManager {
 
         const node = this.currentNodes[index];
         if (node) {
-            node.data.position = { x: newPosition.x, y: newPosition.y, z: newPosition.z };
+            node.data.position = {
+                x: newPosition.x,
+                y: newPosition.y,
+                z: newPosition.z
+            };
+
+            matrix.compose(newPosition, quaternion, scale);
+            this.nodeInstances.setMatrixAt(index, matrix);
+            this.nodeInstances.instanceMatrix.needsUpdate = true;
         }
-
-        matrix.compose(newPosition, quaternion, scale);
-        this.nodeInstances.setMatrixAt(index, matrix);
-        this.nodeInstances.instanceMatrix.needsUpdate = true;
     }
 
-    private setupSettingsSubscriptions(): void {
-        Object.keys(this.currentSettings.nodes).forEach(setting => {
-            const unsubscribe = settingsManager.subscribe('nodes', setting as keyof NodeSettings, (value) => {
-                this.nodeRenderer.handleSettingChange(setting as keyof NodeSettings, value);
-            });
-            this.unsubscribers.push(unsubscribe);
-        });
-
-        Object.keys(this.currentSettings.physics).forEach(setting => {
-            const unsubscribe = settingsManager.subscribe('physics', setting as keyof PhysicsSettings, (value) => {
-                this.nodeRenderer.handlePhysicsSettingChange(setting as keyof PhysicsSettings, value);
-            });
-            this.unsubscribers.push(unsubscribe);
-        });
+    public getCurrentNodes(): Node[] {
+        return [...this.currentNodes];
     }
 
-    public static getInstance(): NodeManager {
-        if (!NodeManager.instance) {
-            NodeManager.instance = new NodeManager();
-        }
-        return NodeManager.instance;
+    public updateNodes(nodes: Node[]): void {
+        this.currentNodes = nodes;
+        const positions = new Float32Array(nodes.length * FLOATS_PER_NODE);
+        
+        nodes.forEach((node, index) => {
+            const baseIndex = index * FLOATS_PER_NODE;
+            positions[baseIndex] = node.data.position.x;
+            positions[baseIndex + 1] = node.data.position.y;
+            positions[baseIndex + 2] = node.data.position.z;
+            // Velocity components (if needed)
+            positions[baseIndex + 3] = 0;
+            positions[baseIndex + 4] = 0;
+            positions[baseIndex + 5] = 0;
+            
+            this.nodeIndices.set(node.id, index);
+        });
+        
+        this.updatePositions(positions);
     }
 
     public dispose(): void {
         if (this.nodeInstances) {
-            if (this.nodeInstances.geometry) {
-                this.nodeInstances.geometry.dispose();
-            }
-            if (this.nodeInstances.material instanceof THREE.Material) {
-                this.nodeInstances.material.dispose();
-            }
-            this.nodeInstances.dispose();
+            this.nodeInstances.geometry.dispose();
+            this.nodeInstances.material.dispose();
         }
         if (this.edgeInstances) {
-            if (this.edgeInstances.geometry) {
-                this.edgeInstances.geometry.dispose();
-            }
-            if (this.edgeInstances.material instanceof THREE.Material) {
-                this.edgeInstances.material.dispose();
-            }
-            this.edgeInstances.dispose();
+            this.edgeInstances.geometry.dispose();
+            this.edgeInstances.material.dispose();
         }
-        this.unsubscribers.forEach(unsubscribe => unsubscribe());
-        this.unsubscribers = [];
     }
 }
diff --git a/client/rendering/renderManager.ts b/client/rendering/renderManager.ts
new file mode 100644
index 00000000..0519ecba
--- /dev/null
+++ b/client/rendering/renderManager.ts
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff --git a/client/rendering/scene.ts b/client/rendering/scene.ts
index 29d34cd8..ce478499 100644
--- a/client/rendering/scene.ts
+++ b/client/rendering/scene.ts
@@ -2,12 +2,13 @@
  * Three.js scene management with simplified setup
  */
 
-import * as THREE from 'three';
+import { Scene, PerspectiveCamera, WebGLRenderer, Color, AmbientLight, DirectionalLight, GridHelper, Vector2, Material, Mesh, Object3D } from 'three';
 import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
 import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
 import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
 import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
 import { createLogger } from '../core/utils';
+import { Settings } from '../types/settings';
 
 const logger = createLogger('SceneManager');
 
@@ -18,9 +19,9 @@ export class SceneManager {
   private static instance: SceneManager;
   
   // Three.js core components
-  private scene: THREE.Scene;
-  private camera: THREE.PerspectiveCamera;
-  private renderer: THREE.WebGLRenderer;
+  private scene: Scene;
+  private camera: PerspectiveCamera;
+  private renderer: WebGLRenderer;
   private controls: OrbitControls;
   
   // Post-processing
@@ -35,12 +36,12 @@ export class SceneManager {
     logger.log('Initializing SceneManager');
     
     // Create scene
-    this.scene = new THREE.Scene();
-    this.scene.background = new THREE.Color(BACKGROUND_COLOR);
+    this.scene = new Scene();
+    this.scene.background = new Color(BACKGROUND_COLOR);
     // Removed fog to ensure graph visibility
 
     // Create camera
-    this.camera = new THREE.PerspectiveCamera(
+    this.camera = new PerspectiveCamera(
       75,
       window.innerWidth / window.innerHeight,
       0.1,
@@ -50,7 +51,7 @@ export class SceneManager {
     this.camera.lookAt(0, 0, 0);
 
     // Create renderer
-    this.renderer = new THREE.WebGLRenderer({
+    this.renderer = new WebGLRenderer({
       canvas,
       antialias: true,
       alpha: true,
@@ -73,7 +74,7 @@ export class SceneManager {
     this.composer.addPass(renderPass);
 
     this.bloomPass = new UnrealBloomPass(
-      new THREE.Vector2(window.innerWidth, window.innerHeight),
+      new Vector2(window.innerWidth, window.innerHeight),
       1.5,  // Strength
       0.75, // Radius
       0.3   // Threshold
@@ -104,16 +105,16 @@ export class SceneManager {
   }
 
   private setupLighting(): void {
-    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
+    const ambientLight = new AmbientLight(0xffffff, 0.6);
     this.scene.add(ambientLight);
 
-    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
+    const directionalLight = new DirectionalLight(0xffffff, 0.8);
     directionalLight.position.set(1, 1, 1).normalize();
     this.scene.add(directionalLight);
 
     // Add smaller grid helper
-    const gridHelper = new THREE.GridHelper(50, 50); // Reduced grid size
-    if (gridHelper.material instanceof THREE.Material) {
+    const gridHelper = new GridHelper(50, 50); // Reduced grid size
+    if (gridHelper.material instanceof Material) {
       gridHelper.material.transparent = true;
       gridHelper.material.opacity = 0.1;
     }
@@ -138,6 +139,11 @@ export class SceneManager {
     logger.log('Scene rendering started');
   }
 
+  // Alias for start() to maintain compatibility with new client code
+  startRendering(): void {
+    this.start();
+  }
+
   stop(): void {
     this.isRunning = false;
     if (this.animationFrameId !== null) {
@@ -156,15 +162,15 @@ export class SceneManager {
   }
 
   // Public getters
-  getScene(): THREE.Scene {
+  getScene(): Scene {
     return this.scene;
   }
 
-  getCamera(): THREE.PerspectiveCamera {
+  getCamera(): PerspectiveCamera {
     return this.camera;
   }
 
-  getRenderer(): THREE.WebGLRenderer {
+  getRenderer(): WebGLRenderer {
     return this.renderer;
   }
 
@@ -173,11 +179,11 @@ export class SceneManager {
   }
 
   // Scene management methods
-  add(object: THREE.Object3D): void {
+  add(object: Object3D): void {
     this.scene.add(object);
   }
 
-  remove(object: THREE.Object3D): void {
+  remove(object: Object3D): void {
     this.scene.remove(object);
   }
 
@@ -235,7 +241,7 @@ export class SceneManager {
     // Dispose of scene objects
     if (this.scene) {
       this.scene.traverse((object) => {
-        if (object instanceof THREE.Mesh) {
+        if (object instanceof Mesh) {
           if (object.geometry) object.geometry.dispose();
           if (object.material) {
             if (Array.isArray(object.material)) {
@@ -250,4 +256,44 @@ export class SceneManager {
 
     logger.log('Scene manager disposed');
   }
+
+  public handleSettingsUpdate(settings: Settings): void {
+    if (!settings.visualization?.rendering) {
+      logger.warn('Received settings update without visualization.rendering section');
+      return;
+    }
+
+    const { rendering } = settings.visualization;
+
+    // Update background color
+    if (rendering.backgroundColor) {
+      this.scene.background = new Color(rendering.backgroundColor);
+    }
+
+    // Update lighting
+    const lights = this.scene.children.filter(child => 
+      child instanceof AmbientLight || child instanceof DirectionalLight
+    );
+    
+    lights.forEach(light => {
+      if (light instanceof AmbientLight) {
+        light.intensity = rendering.ambientLightIntensity;
+      } else if (light instanceof DirectionalLight) {
+        light.intensity = rendering.directionalLightIntensity;
+      }
+    });
+
+    // Update renderer settings
+    if (this.renderer) {
+      // Note: Some settings can only be changed at renderer creation
+      if (rendering.enableAntialiasing) {
+        logger.warn('Antialiasing setting change requires renderer recreation');
+      }
+      if (rendering.enableShadows) {
+        logger.warn('Shadow settings change requires renderer recreation');
+      }
+    }
+
+    logger.debug('Scene settings updated:', rendering);
+  }
 }
diff --git a/client/rendering/textRenderer.ts b/client/rendering/textRenderer.ts
index db7df964..13ef8a05 100644
--- a/client/rendering/textRenderer.ts
+++ b/client/rendering/textRenderer.ts
@@ -1,6 +1,6 @@
-import type { LabelSettings } from '../core/types';
+import type { Settings, LabelSettings } from '../types/settings';
 import { settingsManager } from '../state/settings';
-import { createLogger } from '../utils/logger';
+import { createLogger } from '../core/logger';
 import * as THREE from 'three';
 
 const logger = createLogger('TextRenderer');
@@ -19,7 +19,9 @@ export class TextRenderer {
     private unsubscribers: Array<() => void> = [];
     private projMatrix: THREE.Matrix4;
     private viewMatrix: THREE.Matrix4;
-    private currentSettings: LabelSettings;
+    private currentSettings: Settings;
+    private settings: LabelSettings;
+    private group: THREE.Group;
 
     constructor(camera: THREE.Camera) {
         this.camera = camera;
@@ -27,13 +29,16 @@ export class TextRenderer {
         this.labelStates = new Map();
         this.projMatrix = new THREE.Matrix4();
         this.viewMatrix = new THREE.Matrix4();
-        this.currentSettings = settingsManager.getCurrentSettings().labels;
+        this.currentSettings = settingsManager.getCurrentSettings();
+        this.settings = this.currentSettings.visualization.labels;
+        this.group = new THREE.Group();
         this.setupSettingsSubscriptions();
     }
 
     private setupSettingsSubscriptions(): void {
-        Object.keys(this.currentSettings).forEach(setting => {
-            const unsubscribe = settingsManager.subscribe('labels', setting as keyof LabelSettings, (value) => {
+        Object.keys(this.currentSettings.visualization.labels).forEach(setting => {
+            const path = `visualization.labels.${setting}`;
+            const unsubscribe = settingsManager.subscribe(path, (value) => {
                 this.handleSettingChange(setting as keyof LabelSettings, value);
             });
             this.unsubscribers.push(unsubscribe);
@@ -157,6 +162,7 @@ export class TextRenderer {
             if (!labelGroup) {
                 labelGroup = new THREE.Group();
                 this.labels.set(id, labelGroup);
+                this.group.add(labelGroup);
             }
 
             const state: LabelState = {
@@ -183,7 +189,7 @@ export class TextRenderer {
             // (e.g., using HTML elements, sprites, or geometry)
 
             // Update visibility
-            labelGroup.visible = this.currentSettings.enableLabels && state.visible;
+            labelGroup.visible = this.settings.enableLabels && state.visible;
 
             // Update bounding box for culling
             state.boundingBox = labelGroup;
@@ -196,6 +202,7 @@ export class TextRenderer {
         try {
             const labelGroup = this.labels.get(id);
             if (labelGroup) {
+                this.group.remove(labelGroup);
                 // Clean up THREE.js objects
                 this.clearLabels();
                 this.labels.delete(id);
@@ -253,8 +260,24 @@ export class TextRenderer {
             // Clean up subscribers
             this.unsubscribers.forEach(unsubscribe => unsubscribe());
             this.unsubscribers = [];
+
+            // Clean up group
+            if (this.group.parent) {
+                this.group.parent.remove(this.group);
+            }
         } catch (error) {
             logger.error('Error disposing TextRenderer:', error);
         }
     }
+
+    public handleSettingsUpdate(settings: LabelSettings): void {
+        this.settings = settings;
+        this.updateLabelVisibility(settings.enableLabels);
+        this.updateFontSize(settings.desktopFontSize);
+        this.updateTextColor(settings.textColor);
+    }
+
+    public getGroup(): THREE.Group {
+        return this.group;
+    }
 }
diff --git a/client/state/SettingsObserver.ts b/client/state/SettingsObserver.ts
new file mode 100644
index 00000000..bd18ab55
--- /dev/null
+++ b/client/state/SettingsObserver.ts
@@ -0,0 +1,42 @@
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+
+const logger = createLogger('SettingsObserver');
+
+export type SettingsChangeCallback = (settings: Settings) => void;
+
+export class SettingsObserver {
+    private static instance: SettingsObserver;
+    private observers = new Map<string, SettingsChangeCallback>();
+
+    private constructor() {}
+
+    static getInstance(): SettingsObserver {
+        if (!SettingsObserver.instance) {
+            SettingsObserver.instance = new SettingsObserver();
+        }
+        return SettingsObserver.instance;
+    }
+
+    subscribe(id: string, callback: SettingsChangeCallback): () => void {
+        logger.debug(`Subscribing observer: ${id}`);
+        this.observers.set(id, callback);
+        return () => this.unsubscribe(id);
+    }
+
+    unsubscribe(id: string): void {
+        logger.debug(`Unsubscribing observer: ${id}`);
+        this.observers.delete(id);
+    }
+
+    notifyAll(settings: Settings): void {
+        logger.debug(`Notifying ${this.observers.size} observers of settings change`);
+        this.observers.forEach((callback, id) => {
+            try {
+                callback(settings);
+            } catch (error) {
+                logger.error(`Error in settings observer ${id}:`, error);
+            }
+        });
+    }
+}
diff --git a/client/state/SettingsStore.ts b/client/state/SettingsStore.ts
new file mode 100644
index 00000000..a4c9bb8c
--- /dev/null
+++ b/client/state/SettingsStore.ts
@@ -0,0 +1,165 @@
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+import { defaultSettings } from './defaultSettings';
+
+const logger = createLogger('SettingsStore');
+
+export type SettingsChangeCallback = (path: string, value: unknown) => void;
+
+export class SettingsStore {
+    private static instance: SettingsStore | null = null;
+    private settings: Settings;
+    private initialized: boolean = false;
+    private initializationPromise: Promise<void> | null = null;
+    private pendingChanges: Set<string> = new Set();
+    private subscribers: Map<string, Set<SettingsChangeCallback>> = new Map();
+    private syncTimer: number | null = null;
+
+    private constructor() {
+        // Initialize with default settings
+        this.settings = { ...defaultSettings };
+    }
+
+    public static getInstance(): SettingsStore {
+        if (!SettingsStore.instance) {
+            SettingsStore.instance = new SettingsStore();
+        }
+        return SettingsStore.instance;
+    }
+
+    public async initialize(): Promise<void> {
+        // If already initialized or initializing, return existing promise
+        if (this.initialized) {
+            return Promise.resolve();
+        }
+        if (this.initializationPromise) {
+            return this.initializationPromise;
+        }
+
+        this.initializationPromise = (async () => {
+            try {
+                // Using default settings while server sync is disabled
+                this.settings = { ...defaultSettings };
+                logger.info('Using default settings (server sync disabled)');
+
+                this.initialized = true;
+                logger.info('SettingsStore initialized');
+            } catch (error) {
+                logger.error('Failed to initialize settings:', error);
+                // Use defaults on error
+                this.settings = { ...defaultSettings };
+                this.initialized = true;
+            }
+        })();
+
+        return this.initializationPromise;
+    }
+
+    public isInitialized(): boolean {
+        return this.initialized;
+    }
+
+    public async subscribe(path: string, callback: SettingsChangeCallback): Promise<() => void> {
+        // Wait for initialization if not already initialized
+        if (!this.initialized) {
+            await this.initialize();
+        }
+
+        if (!this.subscribers.has(path)) {
+            this.subscribers.set(path, new Set());
+        }
+        this.subscribers.get(path)?.add(callback);
+
+        // Immediately call callback with current value
+        const value = this.get(path);
+        if (value !== undefined) {
+            callback(path, value);
+        }
+
+        // Return unsubscribe function
+        return () => {
+            const pathSubscribers = this.subscribers.get(path);
+            if (pathSubscribers) {
+                pathSubscribers.delete(callback);
+                if (pathSubscribers.size === 0) {
+                    this.subscribers.delete(path);
+                }
+            }
+        };
+    }
+
+    public get(path: string): unknown {
+        if (!this.initialized) {
+            logger.warn('Attempting to access settings before initialization');
+            return undefined;
+        }
+        
+        if (!path) {
+            return this.settings;
+        }
+        
+        try {
+            return path.split('.').reduce((obj: any, key) => {
+                if (obj === null || obj === undefined) {
+                    throw new Error(`Invalid path: ${path}`);
+                }
+                return obj[key];
+            }, this.settings);
+        } catch (error) {
+            logger.error(`Error accessing setting at path ${path}:`, error);
+            return undefined;
+        }
+    }
+
+    public set(path: string, value: unknown): void {
+        if (!this.initialized) {
+            logger.error('Attempting to set settings before initialization');
+            throw new Error('SettingsStore not initialized');
+        }
+
+        try {
+            const parts = path.split('.');
+            const lastKey = parts.pop()!;
+            const target = parts.reduce((obj: any, key) => {
+                if (!(key in obj)) {
+                    obj[key] = {};
+                }
+                return obj[key];
+            }, this.settings);
+
+            if (!target || typeof target !== 'object') {
+                throw new Error(`Invalid settings path: ${path}`);
+            }
+
+            target[lastKey] = value;
+            this.pendingChanges.add(path);
+            this.notifySubscribers(path, value);
+        } catch (error) {
+            logger.error(`Error setting value at path ${path}:`, error);
+            throw error;
+        }
+    }
+
+    private notifySubscribers(path: string, value: unknown): void {
+        const subscribers = this.subscribers.get(path);
+        if (subscribers) {
+            subscribers.forEach(callback => {
+                try {
+                    callback(path, value);
+                } catch (error) {
+                    logger.error(`Error in settings subscriber for ${path}:`, error);
+                }
+            });
+        }
+    }
+
+    public dispose(): void {
+        if (this.syncTimer !== null) {
+            window.clearInterval(this.syncTimer);
+            this.syncTimer = null;
+        }
+        this.subscribers.clear();
+        this.pendingChanges.clear();
+        this.initialized = false;
+    }
+}
diff --git a/client/state/defaultSettings.ts b/client/state/defaultSettings.ts
index a91deae0..4a64f602 100644
--- a/client/state/defaultSettings.ts
+++ b/client/state/defaultSettings.ts
@@ -1,158 +1,188 @@
-import type { Settings } from '../types/settings';
+import { Settings, VisualizationSettings } from '../types/settings';
+import { NODE_COLOR, NODE_SIZE, EDGE_RADIUS, LABEL_COLOR } from '../core/constants';
 
-export const defaultSettings: Settings = {
+// Export visualization defaults separately for reuse
+export const defaultVisualizationSettings: VisualizationSettings = {
     animations: {
         enableMotionBlur: false,
         enableNodeAnimations: true,
-        motionBlurStrength: 0.4,
+        motionBlurStrength: 0.5,
         selectionWaveEnabled: false,
         pulseEnabled: false,
         rippleEnabled: false,
         edgeAnimationEnabled: false,
         flowParticlesEnabled: false
     },
-    ar: {
-        dragThreshold: 0.04,
-        enableHandTracking: true,
-        enableHaptics: true,
-        enableLightEstimation: true,
-        enablePassthroughPortal: false,
-        enablePlaneDetection: true,
-        enableSceneUnderstanding: true,
-        gestureSsmoothing: 0.5,
-        handMeshColor: "#FFD700",
-        handMeshEnabled: true,
-        handMeshOpacity: 0.3,
-        handPointSize: 0.01,
-        handRayColor: "#FFD700",
-        handRayEnabled: true,
-        handRayWidth: 0.002,
-        hapticIntensity: 0.7,
-        passthroughBrightness: 1.0,
-        passthroughContrast: 1.0,
-        passthroughOpacity: 0.8,
-        pinchThreshold: 0.015,
-        planeColor: "#808080",
-        planeOpacity: 0.5,
-        portalEdgeColor: "#00FF00",
-        portalEdgeWidth: 0.02,
-        portalSize: 2.0,
-        roomScale: true,
-        rotationThreshold: 0.08,
-        showPlaneOverlay: true,
-        snapToFloor: true
-    },
-    audio: {
-        enableSpatialAudio: false,
-        enableInteractionSounds: false,
-        enableAmbientSounds: false
-    },
     bloom: {
-        edgeBloomStrength: 0.3,
-        enabled: false,
-        environmentBloomStrength: 0.5,
-        nodeBloomStrength: 0.2,
-        radius: 0.5,
-        strength: 1.8
-    },
-    clientDebug: {
-        enableDataDebug: false,
-        enableWebsocketDebug: false,
-        enabled: false,
-        logBinaryHeaders: false,
-        logFullJson: false
+        enabled: true,
+        strength: 0.5,
+        radius: 1,
+        edgeBloomStrength: 0.5,
+        nodeBloomStrength: 0.5,
+        environmentBloomStrength: 0.5
     },
     edges: {
-        arrowSize: 0.2,
-        baseWidth: 2,
-        color: "#917f18",
-        enableArrows: false,
-        opacity: 0.6,
-        widthRange: [1, 3]
+        arrowSize: 3,
+        baseWidth: EDGE_RADIUS * 2,
+        color: '#ffffff',
+        enableArrows: true,
+        opacity: 0.8,
+        widthRange: [1, 5]
+    },
+    hologram: {
+        ringCount: 3,
+        ringColor: '#00FFFF',
+        ringOpacity: 0.5,
+        ringSizes: [1.0, 1.5, 2.0],
+        ringRotationSpeed: 0.1,
+        enableBuckminster: true,
+        buckminsterScale: 1.0,
+        buckminsterOpacity: 0.3,
+        enableGeodesic: true,
+        geodesicScale: 1.2,
+        geodesicOpacity: 0.4,
+        enableTriangleSphere: true,
+        triangleSphereScale: 1.1,
+        triangleSphereOpacity: 0.35,
+        globalRotationSpeed: 0.05
     },
     labels: {
-        desktopFontSize: 48,
         enableLabels: true,
-        textColor: "#FFFFFF"
-    },
-    network: {
-        bindAddress: "0.0.0.0",
-        domain: "localhost",
-        enableHttp2: false,
-        enableRateLimiting: true,
-        enableTls: false,
-        maxRequestSize: 10485760,
-        minTlsVersion: "",
-        port: 3001,
-        rateLimitRequests: 100,
-        rateLimitWindow: 60,
-        tunnelId: "dummy"
-    },
-    default: {
-        apiClientTimeout: 30,
-        enableMetrics: true,
-        enableRequestLogging: true,
-        logFormat: "json",
-        logLevel: "debug",
-        maxConcurrentRequests: 5,
-        maxPayloadSize: 5242880,
-        maxRetries: 3,
-        metricsPort: 9090,
-        retryDelay: 5
-    },
-    security: {
-        allowedOrigins: [],
-        auditLogPath: "/app/logs/audit.log",
-        cookieHttponly: true,
-        cookieSamesite: "Strict",
-        cookieSecure: true,
-        csrfTokenTimeout: 3600,
-        enableAuditLogging: true,
-        enableRequestValidation: true,
-        sessionTimeout: 3600
-    },
-    serverDebug: {
-        enabled: false,
-        enableDataDebug: false,
-        enableWebsocketDebug: false,
-        logBinaryHeaders: false,
-        logFullJson: false
+        textColor: LABEL_COLOR.toString(16),
+        textOutlineColor: '#000000',
+        textOutlineWidth: 0.1,
+        textResolution: 512,
+        textPadding: 16,
+        desktopFontSize: 48,
+        billboardMode: 'camera'
     },
     nodes: {
-        baseColor: "#c3ab6f",
-        baseSize: 1,
-        clearcoat: 0.5,
-        enableHoverEffect: false,
-        enableInstancing: false,
-        highlightColor: "#822626",
-        highlightDuration: 300,
-        hoverScale: 1.2,
-        materialType: "basic",
-        metalness: 0.3,
-        opacity: 0.4,
-        roughness: 0.35,
-        sizeByConnections: true,
-        sizeRange: [1, 10]
+        baseColor: NODE_COLOR.toString(16),
+        baseSize: NODE_SIZE,
+        sizeRange: [0.5, 2.0],
+        enableMetadataShape: true,
+        colorRangeAge: ['#ff0000', '#00ff00'],
+        colorRangeLinks: ['#0000ff', '#ff00ff'],
+        metalness: 0.5,
+        roughness: 0.2,
+        opacity: 0.8,
+        enableMetadataVisualization: true,
+        enableHologram: true,
+        enableInstancing: true,
+        quality: 'medium'
     },
     physics: {
-        attractionStrength: 0.015,
-        boundsSize: 12,
-        collisionRadius: 0.25,
-        damping: 0.88,
+        enabled: true,
+        attractionStrength: 0.1,
+        repulsionStrength: 0.1,
+        springStrength: 0.1,
+        damping: 0.5,
+        iterations: 1,
+        maxVelocity: 10,
+        collisionRadius: 1,
         enableBounds: true,
-        enabled: false,
-        iterations: 500,
-        maxVelocity: 2.5,
-        repulsionStrength: 1500,
-        springStrength: 0.018
+        boundsSize: 100
     },
     rendering: {
-        ambientLightIntensity: 0.7,
-        backgroundColor: "#000000",
-        directionalLightIntensity: 1,
-        enableAmbientOcclusion: false,
+        ambientLightIntensity: 0.5,
+        directionalLightIntensity: 0.8,
+        environmentIntensity: 1,
+        backgroundColor: '#000000',
+        enableAmbientOcclusion: true,
         enableAntialiasing: true,
-        enableShadows: false,
-        environmentIntensity: 1.2
+        enableShadows: true
+    }
+};
+
+// Main settings object with all defaults
+export const defaultSettings: Settings = {
+    visualization: defaultVisualizationSettings,
+    labels: defaultVisualizationSettings.labels, // Add top-level labels property
+    xr: {
+        mode: 'immersive-ar',
+        roomScale: true,
+        spaceType: 'local-floor',
+        quality: 'medium',
+        input: {
+            enableHandTracking: true,
+            enableHaptics: true,
+            hapticIntensity: 0.5,
+            dragThreshold: 0.02,
+            pinchThreshold: 0.7,
+            rotationThreshold: 0.1,
+            interactionRadius: 0.5
+        },
+        visuals: {
+            handMeshEnabled: true,
+            handMeshColor: '#ffffff',
+            handMeshOpacity: 0.5,
+            handPointSize: 5,
+            handRayEnabled: true,
+            handRayColor: '#00ff00',
+            handRayWidth: 2,
+            gestureSsmoothing: 0.5
+        },
+        environment: {
+            enableLightEstimation: true,
+            enablePlaneDetection: true,
+            enableSceneUnderstanding: true,
+            planeColor: '#808080',
+            planeOpacity: 0.5,
+            showPlaneOverlay: true,
+            snapToFloor: true
+        },
+        passthrough: {
+            enabled: false,
+            opacity: 1,
+            brightness: 1,
+            contrast: 1,
+            portalSize: 2,
+            portalEdgeColor: '#ffffff',
+            portalEdgeWidth: 2
+        }
+    },
+    system: {
+        network: {
+            bindAddress: '127.0.0.1',
+            domain: 'localhost',
+            port: 3000,
+            enableHttp2: true,
+            enableTls: false,
+            minTlsVersion: 'TLS1.2',
+            maxRequestSize: 10485760,
+            enableRateLimiting: true,
+            rateLimitRequests: 100,
+            rateLimitWindow: 60,
+            tunnelId: ''
+        },
+        websocket: {
+            url: '',
+            reconnectAttempts: 5,
+            reconnectDelay: 5000,
+            binaryChunkSize: 65536,
+            compressionEnabled: true,
+            compressionThreshold: 1024,
+            maxConnections: 100,
+            maxMessageSize: 32 * 1024 * 1024,
+            updateRate: 60
+        },
+        security: {
+            allowedOrigins: ['http://localhost:3000'],
+            auditLogPath: './audit.log',
+            cookieHttponly: true,
+            cookieSamesite: 'Lax',
+            cookieSecure: false,
+            csrfTokenTimeout: 3600,
+            enableAuditLogging: true,
+            enableRequestValidation: true,
+            sessionTimeout: 86400
+        },
+        debug: {
+            enabled: false,
+            enableDataDebug: false,
+            enableWebsocketDebug: false,
+            logBinaryHeaders: false,
+            logFullJson: false
+        }
     }
 };
diff --git a/client/state/graphData.ts b/client/state/graphData.ts
index e4df3940..f90399d3 100644
--- a/client/state/graphData.ts
+++ b/client/state/graphData.ts
@@ -1,31 +1,33 @@
-/**
- * Graph data management with simplified binary updates
- */
-
-import { GraphData, Node, Edge } from '../core/types';
+import { transformGraphData, Node, Edge, GraphData } from '../core/types';
 import { createLogger } from '../core/utils';
+import { API_ENDPOINTS } from '../core/constants';
 
 const logger = createLogger('GraphDataManager');
 
 // Constants
 const THROTTLE_INTERVAL = 16;  // ~60fps max
-const BINARY_VERSION = 1.0;
 const NODE_POSITION_SIZE = 24;  // 6 floats * 4 bytes
-const BINARY_HEADER_SIZE = 4;   // 1 float * 4 bytes
+const FLOATS_PER_NODE = 6;     // x, y, z, vx, vy, vz
+
+interface WebSocketService {
+  send(data: ArrayBuffer): void;
+}
+
+// Extend Edge interface to include id
+interface EdgeWithId extends Edge {
+  id: string;
+}
 
 export class GraphDataManager {
   private static instance: GraphDataManager;
   private nodes: Map<string, Node>;
-  private edges: Map<string, Edge>;
+  private edges: Map<string, EdgeWithId>;
+  private wsService: WebSocketService;
   private metadata: Record<string, any>;
   private updateListeners: Set<(data: GraphData) => void>;
   private positionUpdateListeners: Set<(positions: Float32Array) => void>;
   private lastUpdateTime: number;
   private binaryUpdatesEnabled: boolean = false;
-  private loadingNodes: boolean = false;
-  private currentPage: number = 0;
-  private hasMorePages: boolean = true;
-  private pageSize: number = 100;
 
   private constructor() {
     this.nodes = new Map();
@@ -34,6 +36,18 @@ export class GraphDataManager {
     this.updateListeners = new Set();
     this.positionUpdateListeners = new Set();
     this.lastUpdateTime = performance.now();
+    // Initialize with a no-op websocket service
+    this.wsService = {
+      send: () => logger.warn('WebSocket service not configured')
+    };
+  }
+
+  /**
+   * Configure the WebSocket service for binary updates
+   */
+  public setWebSocketService(service: WebSocketService): void {
+    this.wsService = service;
+    logger.info('WebSocket service configured');
   }
 
   static getInstance(): GraphDataManager {
@@ -43,95 +57,192 @@ export class GraphDataManager {
     return GraphDataManager.instance;
   }
 
-  async loadInitialGraphData(): Promise<void> {
+  public async fetchInitialData(): Promise<void> {
     try {
-      // Reset state
-      this.nodes.clear();
-      this.edges.clear();
-      this.currentPage = 0;
-      this.hasMorePages = true;
-      this.loadingNodes = false;
-
-      // First, update the graph data from the backend
-      try {
-        const updateResponse = await fetch('/api/graph/update', {
-          method: 'POST',
-        });
+      const response = await fetch(API_ENDPOINTS.GRAPH_DATA);
+      if (!response.ok) {
+        throw new Error(`Failed to fetch graph data: ${response.statusText}`);
+      }
 
-        if (!updateResponse.ok) {
-          logger.warn(`Graph update returned ${updateResponse.status}, continuing with initial load`);
-        } else {
-          const updateResult = await updateResponse.json();
-          logger.log('Graph update result:', updateResult);
+      const data = await response.json();
+      this.updateGraphData(data);
+      logger.info('Initial graph data loaded');
+    } catch (error) {
+      logger.error('Failed to fetch initial graph data:', error);
+      throw error;
+    }
+  }
+
+  public async fetchPaginatedData(page: number = 1, pageSize: number = 100): Promise<void> {
+    try {
+      const response = await fetch(`${API_ENDPOINTS.GRAPH_PAGINATED}?page=${page}&pageSize=${pageSize}`);
+      if (!response.ok) {
+        throw new Error(`Failed to fetch paginated data: ${response.statusText}`);
+      }
+
+      const data = await response.json();
+      this.updateGraphData(data);
+      logger.info(`Paginated data loaded for page ${page}`);
+    } catch (error) {
+      logger.error('Failed to fetch paginated data:', error);
+      throw error;
+    }
+  }
+
+  async loadInitialGraphData(): Promise<void> {
+    try {
+      // Try both endpoints
+      const endpoints = [
+        '/api/graph/paginated',
+        '/api/graph/data/paginated'
+      ];
+
+      let response = null;
+      for (const endpoint of endpoints) {
+        try {
+          response = await fetch(`${endpoint}?page=1&pageSize=100`);
+          if (response.ok) break;
+        } catch (e) {
+          continue;
         }
-      } catch (updateError) {
-        logger.warn('Graph update failed, continuing with initial load:', updateError);
       }
 
-      // Then load the first page
-      await this.loadNextPage();
+      if (!response || !response.ok) {
+        throw new Error('Failed to fetch graph data from any endpoint');
+      }
+
+      const data = await response.json();
+      const transformedData = transformGraphData(data);
       
-      // Notify listeners of initial data
-      this.notifyUpdateListeners();
+      // Update nodes with positions
+      this.nodes = new Map(transformedData.nodes.map((node: Node) => [node.id, node]));
+      
+      // Update edges with IDs
+      const edgesWithIds = transformedData.edges.map((edge: Edge) => ({
+        ...edge,
+        id: this.createEdgeId(edge.source, edge.target)
+      }));
+      this.edges = new Map(edgesWithIds.map(edge => [edge.id, edge]));
+      
+      // Update metadata
+      this.metadata = {
+        ...transformedData.metadata || {},
+        pagination: {
+          totalPages: data.totalPages,
+          currentPage: data.currentPage,
+          totalItems: data.totalItems,
+          pageSize: data.pageSize
+        }
+      };
 
-      logger.log('Initial graph data loaded:', {
-        nodes: this.nodes.size,
-        edges: this.edges.size
-      });
-    } catch (error) {
-      logger.error('Failed to load initial graph data:', error);
-      // Don't throw here, allow app to continue with empty graph
+      // Initialize positions and notify listeners
+      this.initializeNodePositions();
       this.notifyUpdateListeners();
+      
+      // Load remaining pages if any
+      if (data.totalPages > 1) {
+        await this.loadRemainingPages(data.totalPages, data.pageSize);
+      }
+      
+      logger.log('Initial graph data loaded successfully');
+    } catch (error) {
+      logger.error('Failed to fetch graph data:', error);
+      throw new Error('Failed to fetch graph data: ' + error);
     }
   }
 
-  private async loadNextPage(): Promise<void> {
-    if (this.loadingNodes || !this.hasMorePages) return;
+  private async loadRemainingPages(totalPages: number, pageSize: number): Promise<void> {
+    try {
+      // Load remaining pages in parallel with a reasonable chunk size
+      const chunkSize = 5;
+      for (let i = 2; i <= totalPages; i += chunkSize) {
+        const pagePromises = [];
+        for (let j = i; j < Math.min(i + chunkSize, totalPages + 1); j++) {
+          pagePromises.push(this.loadPage(j, pageSize));
+        }
+        await Promise.all(pagePromises);
+        // Update listeners after each chunk
+        this.notifyUpdateListeners();
+      }
+    } catch (error) {
+      logger.error('Error loading remaining pages:', error);
+      throw error;
+    }
+  }
 
+  private async loadPage(page: number, pageSize: number): Promise<void> {
     try {
-      this.loadingNodes = true;
-      const response = await fetch(`/api/graph/data/paginated?page=${this.currentPage}&pageSize=${this.pageSize}`);
-      
+      const response = await fetch(`${API_ENDPOINTS.GRAPH_PAGINATED}?page=${page}&pageSize=${pageSize}`);
       if (!response.ok) {
-        throw new Error(`Failed to fetch graph data: ${response.status} ${response.statusText}`);
+        throw new Error(`Failed to fetch page ${page}: ${response.statusText}`);
       }
 
       const data = await response.json();
-      logger.debug('Received graph data:', {
-        nodesCount: data.nodes?.length || 0,
-        edgesCount: data.edges?.length || 0,
-        totalPages: data.totalPages,
-        currentPage: data.currentPage,
-        metadata: data.metadata
+      const transformedData = transformGraphData(data);
+      
+      // Add new nodes
+      transformedData.nodes.forEach((node: Node) => {
+        if (!this.nodes.has(node.id)) {
+          this.nodes.set(node.id, node);
+        }
       });
       
-      if (!data.nodes || !Array.isArray(data.nodes)) {
-        throw new Error('Invalid graph data: nodes array is missing or invalid');
+      // Add new edges
+      transformedData.edges.forEach((edge: Edge) => {
+        const edgeId = this.createEdgeId(edge.source, edge.target);
+        if (!this.edges.has(edgeId)) {
+          this.edges.set(edgeId, { ...edge, id: edgeId });
+        }
+      });
+
+      logger.debug(`Loaded page ${page} with ${transformedData.nodes.length} nodes`);
+    } catch (error) {
+      logger.error(`Error loading page ${page}:`, error);
+      throw error;
+    }
+  }
+
+  private initializeNodePositions(): void {
+    // Initialize node positions if they don't have positions yet
+    this.nodes.forEach(node => {
+      if (!node.data.position || (Array.isArray(node.data.position) && node.data.position.every(p => p === null))) {
+        // Initialize positions in a larger sphere to match spring_length scale
+        const radius = 100; // Match default spring_length
+        const theta = Math.random() * Math.PI * 2;
+        const phi = Math.acos(2 * Math.random() - 1);
+        const r = radius * Math.cbrt(Math.random()); // Cube root for uniform distribution
+        
+        node.data.position = {
+          x: r * Math.sin(phi) * Math.cos(theta),
+          y: r * Math.sin(phi) * Math.sin(theta),
+          z: r * Math.cos(phi)
+        };
       }
-      
-      // Update graph with new nodes and edges
-      data.nodes.forEach((node: Node) => this.nodes.set(node.id, node));
-      if (data.edges && Array.isArray(data.edges)) {
-        data.edges.forEach((edge: Edge) => {
-          const edgeId = this.createEdgeId(edge.source, edge.target);
-          this.edges.set(edgeId, edge);
-        });
+      if (!node.data.velocity) {
+        node.data.velocity = { x: 0, y: 0, z: 0 };
       }
+    });
 
-      // Update pagination state
-      this.currentPage = data.currentPage;
-      this.hasMorePages = data.currentPage < data.totalPages;
-
-      // Notify listeners of updated data
-      this.notifyUpdateListeners();
+    // Create initial position buffer
+    const buffer = new ArrayBuffer(this.nodes.size * NODE_POSITION_SIZE);
+    const positions = new Float32Array(buffer);
+    
+    let index = 0;
+    this.nodes.forEach(node => {
+      const pos = node.data.position;
+      positions[index * 6] = typeof pos.x === 'number' ? pos.x : 0;
+      positions[index * 6 + 1] = typeof pos.y === 'number' ? pos.y : 0;
+      positions[index * 6 + 2] = typeof pos.z === 'number' ? pos.z : 0;
+      positions[index * 6 + 3] = node.data.velocity.x;
+      positions[index * 6 + 4] = node.data.velocity.y;
+      positions[index * 6 + 5] = node.data.velocity.z;
+      index++;
+    });
 
-      logger.log(`Loaded page ${this.currentPage} of graph data: ${this.nodes.size} nodes, ${this.edges.size} edges`);
-    } catch (error) {
-      logger.error('Failed to load graph data:', error);
-      this.hasMorePages = false;  // Stop trying to load more pages on error
-    } finally {
-      this.loadingNodes = false;
-    }
+    // Notify listeners of initial positions
+    this.positionUpdateListeners.forEach(listener => {
+      listener(positions);
+    });
   }
 
   /**
@@ -140,82 +251,105 @@ export class GraphDataManager {
   updateGraphData(data: any): void {
     // Update nodes
     if (data.nodes && Array.isArray(data.nodes)) {
-      data.nodes.forEach((node: Node) => {
-        // Preserve existing position if available, otherwise use server position or generate random
-        const existingNode = this.nodes.get(node.id);
-        if (!existingNode) {
-          // If server didn't provide position, generate random position
-          if (!node.data?.position) {
-            node.data = node.data || {};
-            node.data.position = {
-              x: (Math.random() - 0.5) * 100,  // Increased spread
-              y: (Math.random() - 0.5) * 100,
-              z: (Math.random() - 0.5) * 100
-            };
-          }
-          // Initialize velocity if not present
-          if (!node.data.velocity) {
-            node.data.velocity = { x: 0, y: 0, z: 0 };
-          }
+      data.nodes.forEach((node: any) => {
+        // Convert position array to object if needed
+        let position;
+        if (Array.isArray(node.data.position)) {
+          position = {
+            x: node.data.position[0],
+            y: node.data.position[1], 
+            z: node.data.position[2]
+          };
+        } else {
+          position = node.data.position || null;
         }
-        this.nodes.set(node.id, node);
-      });
-    }
 
-    // Update edges
-    if (data.edges && Array.isArray(data.edges)) {
-      data.edges.forEach((edge: Edge) => {
-        const edgeId = this.createEdgeId(edge.source, edge.target);
-        this.edges.set(edgeId, edge);
+        this.nodes.set(node.id, {
+          ...node,
+          data: {
+            ...node.data,
+            position
+          }
+        });
       });
-    }
 
-    // Update metadata
-    if (data.metadata) {
-      this.metadata = { ...this.metadata, ...data.metadata };
-    }
+      // Store edges in Map with generated IDs
+      if (Array.isArray(data.edges)) {
+        data.edges.forEach((edge: Edge) => {
+          const edgeId = this.createEdgeId(edge.source, edge.target);
+          const edgeWithId: EdgeWithId = {
+            ...edge,
+            id: edgeId
+          };
+          this.edges.set(edgeId, edgeWithId);
+        });
+      }
 
-    // Enable binary updates if we have nodes and it's not already enabled
-    if (this.nodes.size > 0 && !this.binaryUpdatesEnabled) {
-      this.setupBinaryUpdates();
-    }
+      // Update metadata
+      this.metadata = data.metadata || {};
 
-    // Notify listeners of updates
-    this.notifyUpdateListeners();
+      // Initialize positions for new nodes
+      this.initializeNodePositions();
+
+      // Notify listeners
+      this.notifyUpdateListeners();
+      logger.log(`Updated graph data: ${this.nodes.size} nodes, ${this.edges.size} edges`);
+
+      // Enable binary updates after initial data is received
+      if (!this.binaryUpdatesEnabled) {
+        this.enableBinaryUpdates();
+      }
+    } else {
+      logger.warn('Invalid graph data format received');
+    }
   }
 
   /**
    * Setup binary position updates
    */
-  private setupBinaryUpdates(): void {
-    this.binaryUpdatesEnabled = true;
-    // Initialize positions for existing nodes if needed
-    this.nodes.forEach(node => {
-      if (!node.data?.position) {
-        node.data = node.data || {};
-        node.data.position = {
-          x: (Math.random() - 0.5) * 100,
-          y: (Math.random() - 0.5) * 100,
-          z: (Math.random() - 0.5) * 100
-        };
-      }
-      if (!node.data.velocity) {
-        node.data.velocity = { x: 0, y: 0, z: 0 };
-      }
-    });
-    logger.log('Binary updates enabled');
+  private enableBinaryUpdates(): void {
+    // Send message to server to enable binary updates
+    if (window.ws && window.ws.readyState === WebSocket.OPEN) {
+      window.ws.send(JSON.stringify({ type: 'enableBinaryUpdates' }));
+      this.binaryUpdatesEnabled = true;
+      
+      // Send current positions to server to initialize GPU layout
+      this.sendPositionsToServer();
+      
+      logger.log('Enabled binary updates and sent initial positions');
+    } else {
+      logger.warn('WebSocket not ready, cannot enable binary updates');
+    }
   }
 
-  public async loadMoreIfNeeded(): Promise<void> {
-    if (this.hasMorePages && !this.loadingNodes) {
-      await this.loadNextPage();
+  private sendPositionsToServer(): void {
+    if (!this.nodes || this.nodes.size === 0) return;
+
+    // Allocate buffer for node positions (no header)
+    const buffer = new ArrayBuffer(this.nodes.size * NODE_POSITION_SIZE);
+    const positions = new Float32Array(buffer);
+
+    // Pack positions into binary format
+    let i = 0;
+    for (const node of this.nodes.values()) {
+      const pos = node.data.position;
+      positions[i * 6] = typeof pos.x === 'number' ? pos.x : 0;
+      positions[i * 6 + 1] = typeof pos.y === 'number' ? pos.y : 0;
+      positions[i * 6 + 2] = typeof pos.z === 'number' ? pos.z : 0;
+      positions[i * 6 + 3] = node.data.velocity.x;
+      positions[i * 6 + 4] = node.data.velocity.y;
+      positions[i * 6 + 5] = node.data.velocity.z;
+      i++;
     }
+
+    // Send binary data (no header)
+    this.wsService.send(positions.buffer);
   }
 
   /**
    * Handle binary position updates with throttling
    */
-  updatePositions(buffer: ArrayBuffer): void {
+  updatePositions(positions: Float32Array): void {
     const now = performance.now();
     const timeSinceLastUpdate = now - this.lastUpdateTime;
 
@@ -224,22 +358,48 @@ export class GraphDataManager {
     }
 
     try {
-      const floatArray = new Float32Array(buffer);
-      
-      // Check binary version
-      const version = floatArray[0];
-      if (version !== BINARY_VERSION) {
-        logger.warn(`Received binary data version ${version}, expected ${BINARY_VERSION}`);
+      // Verify data size (no header)
+      const expectedSize = Math.floor(positions.length / FLOATS_PER_NODE) * NODE_POSITION_SIZE;
+      if (positions.length * 4 !== expectedSize) {
+        logger.error(`Invalid binary data length: ${positions.length * 4} bytes (expected ${expectedSize})`);
+        return;
       }
 
-      // Verify data size
-      const expectedSize = BINARY_HEADER_SIZE + Math.floor((buffer.byteLength - BINARY_HEADER_SIZE) / NODE_POSITION_SIZE) * NODE_POSITION_SIZE;
-      if (buffer.byteLength !== expectedSize) {
-        logger.error(`Invalid binary data length: ${buffer.byteLength} bytes (expected ${expectedSize})`);
+      // Check for invalid values
+      let hasInvalidValues = false;
+      for (let i = 0; i < positions.length; i++) {
+        const val = positions[i];
+        if (!Number.isFinite(val) || Math.abs(val) > 1000) {
+          logger.warn(`Invalid position value at index ${i}: ${val}`);
+          hasInvalidValues = true;
+          // Replace invalid value with 0
+          positions[i] = 0;
+        }
+      }
+
+      if (hasInvalidValues) {
+        logger.error('Received invalid position values from GPU, using fallback positions');
+        // Re-initialize positions
+        this.initializeNodePositions();
         return;
       }
 
-      this.notifyPositionUpdateListeners(floatArray);
+      // Log a sample of positions for debugging
+      const nodeCount = Math.floor(positions.length / 6);
+      logger.debug(`Received positions for ${nodeCount} nodes`);
+      if (nodeCount > 0) {
+        const firstNode = {
+          x: positions[0],
+          y: positions[1],
+          z: positions[2],
+          vx: positions[3],
+          vy: positions[4],
+          vz: positions[5]
+        };
+        logger.debug('First node position:', firstNode);
+      }
+
+      this.notifyPositionUpdateListeners(positions);
       this.lastUpdateTime = now;
     } catch (error) {
       logger.error('Error processing binary position update:', error);
@@ -252,7 +412,7 @@ export class GraphDataManager {
   getGraphData(): GraphData {
     return {
       nodes: Array.from(this.nodes.values()),
-      edges: Array.from(this.edges.values()),
+      edges: Array.from(this.edges.values()) as Edge[],
       metadata: this.metadata
     };
   }
@@ -329,11 +489,33 @@ export class GraphDataManager {
     this.updateListeners.forEach(listener => {
       listener({
         nodes: Array.from(this.nodes.values()),
-        edges: Array.from(this.edges.values()),
+        edges: Array.from(this.edges.values()) as Edge[],
         metadata: { ...this.metadata, binaryUpdatesEnabled: enabled }
       });
     });
   }
+
+  public updateNodePositions(positions: Float32Array): void {
+    if (!this.binaryUpdatesEnabled) {
+      return;
+    }
+  
+    // Log for debugging
+    logger.debug('Received binary position update:', positions);
+  
+    if (positions.length % FLOATS_PER_NODE !== 0) {
+      logger.error('Invalid position array length:', positions.length);
+      return;
+    }
+  
+    this.positionUpdateListeners.forEach(listener => {
+      try {
+        listener(positions);
+      } catch (error) {
+        logger.error('Error in position update listener:', error);
+      }
+    });
+  }
 }
 
 // Export a singleton instance
diff --git a/client/state/settings.ts b/client/state/settings.ts
index 1cacff92..313f6614 100644
--- a/client/state/settings.ts
+++ b/client/state/settings.ts
@@ -1,330 +1,154 @@
-import { Settings, SettingsManager as ISettingsManager, SettingCategory, SettingKey, SettingValueType } from '../types/settings';
-import { createLogger } from '../utils/logger';
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+import { SettingsStore } from './SettingsStore';
+import { defaultSettings } from './defaultSettings';
+import {
+    SettingsCategory,
+    SettingsPath,
+    SettingValue,
+    getSettingValue,
+    setSettingValue,
+    isValidSettingPath
+} from '../types/settings/utils';
 
 const logger = createLogger('SettingsManager');
 
-type Subscriber<T extends SettingCategory, K extends SettingKey<T>> = {
-    callback: (value: SettingValueType<T, K>) => void;
-};
-
-class SettingsManager implements ISettingsManager {
-    private settings: Settings;
-    private subscribers: Map<string, Array<Subscriber<any, any>>> = new Map();
+export class SettingsManager {
+    private store: SettingsStore;
     private initialized: boolean = false;
+    private settings: Settings = { ...defaultSettings };
+
+    constructor() {
+        this.store = SettingsStore.getInstance();
+    }
 
-    constructor(defaultSettings: Settings) {
+    private useDefaultSettings(): void {
+        // Reset to default settings
         this.settings = { ...defaultSettings };
+        this.initialized = true;
     }
 
     public async initialize(): Promise<void> {
-        if (this.initialized) {
-            return;
-        }
-
-        const maxRetries = 3;
-        const retryDelay = 1000; // 1 second
+        if (this.initialized) return;
 
-        try {
-            const categories = Object.keys(this.settings) as SettingCategory[];
-            
-            for (const category of categories) {
-                let retries = 0;
-                while (retries < maxRetries) {
-                    try {
-                        const response = await fetch(`/api/visualization/settings/${category}`);
-                        
-                        if (response.ok) {
-                            const data = await response.json();
-                            if (this.settings[category]) {
-                                this.settings[category] = { ...this.settings[category], ...data };
-                                logger.info(`Loaded settings for category ${category}`);
-                                break; // Success, exit retry loop
-                            }
-                        } else if (response.status === 404) {
-                            logger.info(`Settings endpoint for ${category} not found, using defaults`);
-                            break; // 404 is expected for some categories, exit retry loop
-                        } else {
-                            throw new Error(`Failed to fetch ${category} settings: ${response.statusText}`);
-                        }
-                    } catch (error) {
-                        retries++;
-                        if (retries === maxRetries) {
-                            logger.error(`Failed to load ${category} settings after ${maxRetries} attempts:`, error);
-                            logger.info(`Using default values for ${category} settings`);
-                        } else {
-                            logger.warn(`Retry ${retries}/${maxRetries} for ${category} settings`);
-                            await new Promise(resolve => setTimeout(resolve, retryDelay));
-                        }
-                    }
-                }
-            }
-            
-            this.initialized = true;
-            logger.info('Settings initialization complete');
-        } catch (error) {
-            logger.error('Failed to initialize settings:', error);
-            throw error;
-        }
+        // Using default settings while server sync is disabled
+        this.useDefaultSettings();
+        logger.info('Using default settings (server sync disabled)');
     }
 
     public getCurrentSettings(): Settings {
+        // Always return settings, which will be defaults if initialization failed
         return this.settings;
     }
 
-    public getDefaultSettings(): Settings {
-        return this.settings;
-    }
+    public async updateSetting(path: SettingsPath, value: SettingValue): Promise<void> {
+        if (!isValidSettingPath(path)) {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
 
-    public async updateSetting<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValueType<T, K>
-    ): Promise<void> {
         try {
-            if (!(category in this.settings)) {
-                throw new Error(`Invalid category: ${category}`);
-            }
-
-            const categorySettings = this.settings[category];
-            if (!(String(setting) in categorySettings)) {
-                throw new Error(`Invalid setting: ${String(setting)} in category ${category}`);
+            setSettingValue(this.settings, path, value);
+            if (this.initialized) {
+                await this.store.set(path, value);
+            } else {
+                logger.warn(`Setting ${path} updated in memory only - store not initialized`);
             }
-
-            // Update the setting
-            (this.settings[category] as any)[setting] = value;
-
-            // Notify subscribers
-            const key = `${category}.${String(setting)}`;
-            const subscribers = this.subscribers.get(key) || [];
-            subscribers.forEach(sub => {
-                try {
-                    sub.callback(value);
-                } catch (error) {
-                    logger.error(`Error in subscriber callback for ${key}:`, error);
-                }
-            });
-
-            // Save settings to backend
-            await this.saveSettings(category, setting, value);
-
+            logger.debug(`Updated setting ${path} to ${value}`);
         } catch (error) {
-            logger.error(`Error updating setting ${category}.${String(setting)}:`, error);
+            logger.error(`Failed to update setting ${path}:`, error);
             throw error;
         }
     }
 
-    private async saveSettings<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValueType<T, K>
-    ): Promise<void> {
+    public get(path: SettingsPath): SettingValue {
+        if (!isValidSettingPath(path)) {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
+        
         try {
-            const response = await fetch(`/api/visualization/settings/${category}/${String(setting)}`, {
-                method: 'PUT',
-                headers: {
-                    'Content-Type': 'application/json',
-                },
-                body: JSON.stringify({ value }),
-            });
-
-            if (!response.ok) {
-                throw new Error(`Failed to save setting: ${response.statusText}`);
-            }
+            return getSettingValue(this.settings, path);
         } catch (error) {
-            logger.error(`Error saving setting ${category}.${String(setting)}:`, error);
-            throw error;
+            logger.error(`Error getting setting at path ${path}:`, error);
+            // Return default value for this path if available
+            return getSettingValue(defaultSettings, path);
         }
     }
 
-    public subscribe<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        callback: (value: SettingValueType<T, K>) => void
-    ): () => void {
-        const key = `${category}.${String(setting)}`;
-        if (!this.subscribers.has(key)) {
-            this.subscribers.set(key, []);
+    public getCategory(category: SettingsCategory): Settings[typeof category] {
+        if (!(category in this.settings)) {
+            logger.warn(`Category ${category} not found, using defaults`);
+            return defaultSettings[category];
         }
+        return this.settings[category];
+    }
 
-        const subscriber = { callback };
-        this.subscribers.get(key)!.push(subscriber);
+    public subscribe(path: string, callback: (value: unknown) => void): () => void {
+        const store = SettingsStore.getInstance();
+        let unsubscriber: (() => void) | undefined;
+        
+        store.subscribe(path, (_, value) => {
+            callback(value);
+        }).then(unsub => {
+            unsubscriber = unsub;
+        });
 
         return () => {
-            const subscribers = this.subscribers.get(key);
-            if (subscribers) {
-                const index = subscribers.indexOf(subscriber);
-                if (index !== -1) {
-                    subscribers.splice(index, 1);
-                }
+            if (unsubscriber) {
+                unsubscriber();
             }
         };
     }
 
-    public dispose(): void {
-        this.subscribers.clear();
+    public onSettingChange(path: SettingsPath, callback: (value: SettingValue) => void): () => void {
+        const store = SettingsStore.getInstance();
+        let unsubscriber: (() => void) | undefined;
+        
+        store.subscribe(path, (_, value) => {
+            callback(value as SettingValue);
+        }).then(unsub => {
+            unsubscriber = unsub;
+        });
+
+        return () => {
+            if (unsubscriber) {
+                unsubscriber();
+            }
+        };
     }
-}
 
-// Default settings that match settings.toml structure
-export const defaultSettings: Settings = {
-  animations: {
-    enableMotionBlur: false,
-    enableNodeAnimations: false,
-    motionBlurStrength: 0.4,
-    selectionWaveEnabled: false,
-    pulseEnabled: false,
-    rippleEnabled: false,
-    edgeAnimationEnabled: false,
-    flowParticlesEnabled: false
-  },
-  ar: {
-    dragThreshold: 0.04,
-    enableHandTracking: true,
-    enableHaptics: true,
-    enableLightEstimation: true,
-    enablePassthroughPortal: false,
-    enablePlaneDetection: true,
-    enableSceneUnderstanding: true,
-    gestureSsmoothing: 0.9,
-    handMeshColor: '#FFD700',
-    handMeshEnabled: true,
-    handMeshOpacity: 0.3,
-    handPointSize: 0.01,
-    handRayColor: '#FFD700',
-    handRayEnabled: true,
-    handRayWidth: 0.002,
-    hapticIntensity: 0.7,
-    passthroughBrightness: 1,
-    passthroughContrast: 1,
-    passthroughOpacity: 1,
-    pinchThreshold: 0.015,
-    planeColor: '#4A90E2',
-    planeOpacity: 0.3,
-    portalEdgeColor: '#FFD700',
-    portalEdgeWidth: 0.02,
-    portalSize: 1,
-    roomScale: true,
-    rotationThreshold: 0.08,
-    showPlaneOverlay: true,
-    snapToFloor: true
-  },
-  audio: {
-    enableAmbientSounds: false,
-    enableInteractionSounds: false,
-    enableSpatialAudio: false
-  },
-  bloom: {
-    edgeBloomStrength: 0.3,
-    enabled: false,
-    environmentBloomStrength: 0.5,
-    nodeBloomStrength: 0.2,
-    radius: 0.5,
-    strength: 1.8
-  },
-  clientDebug: {
-    enabled: true,
-    enableWebsocketDebug: true,
-    enableDataDebug: true,
-    logBinaryHeaders: true,
-    logFullJson: true
-  },
-  default: {
-    apiClientTimeout: 30,
-    enableMetrics: true,
-    enableRequestLogging: true,
-    logFormat: 'json',
-    logLevel: 'debug',
-    maxConcurrentRequests: 5,
-    maxPayloadSize: 5242880,
-    maxRetries: 3,
-    metricsPort: 9090,
-    retryDelay: 5
-  },
-  edges: {
-    arrowSize: 0.15,
-    baseWidth: 2,
-    color: '#917f18',
-    enableArrows: false,
-    opacity: 0.6,
-    widthRange: [1, 3]
-  },
-  labels: {
-    desktopFontSize: 48,
-    enableLabels: true,
-    textColor: '#FFFFFF'
-  },
-  network: {
-    bindAddress: '0.0.0.0',
-    domain: 'localhost',
-    enableHttp2: false,
-    enableRateLimiting: true,
-    enableTls: false,
-    maxRequestSize: 10485760,
-    minTlsVersion: '',
-    port: 3001,
-    rateLimitRequests: 100,
-    rateLimitWindow: 60,
-    tunnelId: 'dummy'
-  },
-  nodes: {
-    baseColor: '#4CAF50',
-    baseSize: 2.5,
-    clearcoat: 1,
-    enableHoverEffect: true,
-    enableInstancing: true,
-    highlightColor: '#ff4444',
-    highlightDuration: 500,
-    hoverScale: 1.2,
-    materialType: 'phong',
-    metalness: 0.5,
-    opacity: 0.7,
-    roughness: 0.5,
-    sizeByConnections: true,
-    sizeRange: [0.15, 0.4]
-  },
-  physics: {
-    attractionStrength: 0.1,
-    boundsSize: 100,
-    collisionRadius: 1,
-    damping: 0.8,
-    enableBounds: true,
-    enabled: true,
-    iterations: 1,
-    maxVelocity: 10,
-    repulsionStrength: 0.2,
-    springStrength: 0.1
-  },
-  rendering: {
-    ambientLightIntensity: 0.5,
-    backgroundColor: '#212121',
-    directionalLightIntensity: 0.8,
-    enableAmbientOcclusion: true,
-    enableAntialiasing: true,
-    enableShadows: true,
-    environmentIntensity: 1
-  },
-  security: {
-    allowedOrigins: ['*'],
-    auditLogPath: '',
-    cookieHttponly: true,
-    cookieSamesite: 'Strict',
-    cookieSecure: true,
-    csrfTokenTimeout: 3600,
-    enableAuditLogging: true,
-    enableRequestValidation: true,
-    sessionTimeout: 86400
-  },
-  serverDebug: {
-    enabled: false,
-    enableDataDebug: false,
-    enableWebsocketDebug: false,
-    logBinaryHeaders: false,
-    logFullJson: false
-  }
-};
+    public async batchUpdate(updates: Array<{ path: SettingsPath; value: SettingValue }>): Promise<void> {
+        try {
+            // Validate all paths first
+            for (const { path } of updates) {
+                if (!isValidSettingPath(path)) {
+                    throw new Error(`Invalid settings path: ${path}`);
+                }
+            }
 
-// Re-export Settings interface
-export type { Settings } from '../types/settings';
+            // Apply updates to local settings first
+            for (const { path, value } of updates) {
+                setSettingValue(this.settings, path, value);
+            }
+
+            // Then sync with store if initialized
+            if (this.initialized) {
+                await Promise.all(
+                    updates.map(({ path, value }) => this.store.set(path, value))
+                );
+            } else {
+                logger.warn('Settings updated in memory only - store not initialized');
+            }
+        } catch (error) {
+            logger.error('Failed to apply batch updates:', error);
+            throw error;
+        }
+    }
+
+    public dispose(): void {
+        this.store.dispose();
+        this.initialized = false;
+    }
+}
 
-// Initialize settings from settings.toml
-export const settingsManager = new SettingsManager(defaultSettings);
+// Export singleton instance
+export const settingsManager = new SettingsManager();
diff --git a/client/types/gestures.ts b/client/types/gestures.ts
new file mode 100644
index 00000000..0d4d166a
--- /dev/null
+++ b/client/types/gestures.ts
@@ -0,0 +1,7 @@
+export enum HandGestureType {
+    None = 'none',
+    Pinch = 'pinch',
+    Grab = 'grab',
+    Point = 'point',
+    Wave = 'wave'
+}
diff --git a/client/types/metadata.ts b/client/types/metadata.ts
new file mode 100644
index 00000000..af6e3e78
--- /dev/null
+++ b/client/types/metadata.ts
@@ -0,0 +1,15 @@
+export interface NodeMetadata {
+    id: string;              // Unique identifier
+    name: string;
+    commitAge: number;        // Age in days
+    hyperlinkCount: number;   // Number of hyperlinks
+    importance: number;       // Normalized importance (0-1)
+    position: {
+        x: number;
+        y: number;
+        z: number;
+    };
+}
+
+// Alias for backward compatibility and clarity
+export type Metadata = NodeMetadata;
diff --git a/client/types/settings.ts b/client/types/settings.ts
index 3943bda9..4cfd8753 100644
--- a/client/types/settings.ts
+++ b/client/types/settings.ts
@@ -1,22 +1,230 @@
-import { Settings, SettingCategory, SettingKey } from '../core/types';
-export type { Settings, SettingCategory, SettingKey };
-
-// Helper type to get the value type for a specific setting
-export type SettingValueType<T extends SettingCategory, K extends SettingKey<T>> = Settings[T][K];
-
-export interface SettingsManager {
-    getCurrentSettings(): Settings;
-    getDefaultSettings(): Settings;
-    initialize(): Promise<void>;
-    updateSetting<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValueType<T, K>
-    ): Promise<void>;
-    subscribe<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        callback: (value: SettingValueType<T, K>) => void
-    ): () => void;
-    dispose(): void;
+import { XRSessionMode } from './xr';
+
+// Core visualization settings
+export interface VisualizationSettings {
+    animations: AnimationSettings;
+    bloom: BloomSettings;
+    edges: EdgeSettings;
+    hologram: HologramSettings;
+    labels: LabelSettings;
+    nodes: NodeSettings;
+    physics: PhysicsSettings;
+    rendering: RenderingSettings;
+}
+
+// XR-specific settings
+export interface XRSettings {
+    // Session settings
+    mode: XRSessionMode;
+    roomScale: boolean;
+    spaceType: XRReferenceSpaceType;
+    quality: 'low' | 'medium' | 'high';
+
+    // Input and interaction
+    input: {
+        enableHandTracking: boolean;
+        enableHaptics: boolean;
+        hapticIntensity: number;
+        dragThreshold: number;
+        pinchThreshold: number;
+        rotationThreshold: number;
+        interactionRadius: number;
+    };
+
+    // Visual settings
+    visuals: {
+        handMeshEnabled: boolean;
+        handMeshColor: string;
+        handMeshOpacity: number;
+        handPointSize: number;
+        handRayEnabled: boolean;
+        handRayColor: string;
+        handRayWidth: number;
+        gestureSsmoothing: number;
+    };
+
+    // Environment settings
+    environment: {
+        enableLightEstimation: boolean;
+        enablePlaneDetection: boolean;
+        enableSceneUnderstanding: boolean;
+        planeColor: string;
+        planeOpacity: number;
+        showPlaneOverlay: boolean;
+        snapToFloor: boolean;
+    };
+
+    // Passthrough settings
+    passthrough: {
+        enabled: boolean;
+        opacity: number;
+        brightness: number;
+        contrast: number;
+        portalSize: number;
+        portalEdgeColor: string;
+        portalEdgeWidth: number;
+    };
+}
+
+// System settings
+export interface SystemSettings {
+    network: NetworkSettings;
+    websocket: WebSocketSettings;
+    security: SecuritySettings;
+    debug: DebugSettings;
+}
+
+// Component settings interfaces
+export interface AnimationSettings {
+    enableMotionBlur: boolean;
+    enableNodeAnimations: boolean;
+    motionBlurStrength: number;
+    selectionWaveEnabled: boolean;
+    pulseEnabled: boolean;
+    rippleEnabled: boolean;
+    edgeAnimationEnabled: boolean;
+    flowParticlesEnabled: boolean;
+}
+
+export interface BloomSettings {
+    enabled: boolean;
+    strength: number;
+    radius: number;
+    edgeBloomStrength: number;
+    nodeBloomStrength: number;
+    environmentBloomStrength: number;
+}
+
+export interface EdgeSettings {
+    arrowSize: number;
+    baseWidth: number;
+    color: string;
+    enableArrows: boolean;
+    opacity: number;
+    widthRange: [number, number];
+}
+
+export interface HologramSettings {
+    ringCount: number;
+    ringColor: string;
+    ringOpacity: number;
+    ringSizes: number[];
+    ringRotationSpeed: number;
+    enableBuckminster: boolean;
+    buckminsterScale: number;
+    buckminsterOpacity: number;
+    enableGeodesic: boolean;
+    geodesicScale: number;
+    geodesicOpacity: number;
+    enableTriangleSphere: boolean;
+    triangleSphereScale: number;
+    triangleSphereOpacity: number;
+    globalRotationSpeed: number;
+}
+
+export interface LabelSettings {
+    enableLabels: boolean;
+    textColor: string;
+    textOutlineColor: string;
+    textOutlineWidth: number;
+    textResolution: number;
+    textPadding: number;
+    desktopFontSize: number;
+    billboardMode: 'camera' | 'up';
+}
+
+export interface NodeSettings {
+    baseColor: string;
+    baseSize: number;
+    sizeRange: [number, number];
+    enableMetadataShape: boolean;
+    colorRangeAge: [string, string];
+    colorRangeLinks: [string, string];
+    metalness: number;
+    roughness: number;
+    opacity: number;
+    enableMetadataVisualization: boolean;
+    enableHologram: boolean;
+    enableInstancing: boolean;
+    quality: 'low' | 'medium' | 'high';
+}
+
+export interface PhysicsSettings {
+    enabled: boolean;
+    attractionStrength: number;
+    repulsionStrength: number;
+    springStrength: number;
+    damping: number;
+    iterations: number;
+    maxVelocity: number;
+    collisionRadius: number;
+    enableBounds: boolean;
+    boundsSize: number;
+}
+
+export interface RenderingSettings {
+    ambientLightIntensity: number;
+    directionalLightIntensity: number;
+    environmentIntensity: number;
+    backgroundColor: string;
+    enableAmbientOcclusion: boolean;
+    enableAntialiasing: boolean;
+    enableShadows: boolean;
+}
+
+export interface NetworkSettings {
+    bindAddress: string;
+    domain: string;
+    port: number;
+    enableHttp2: boolean;
+    enableTls: boolean;
+    minTlsVersion: string;
+    maxRequestSize: number;
+    enableRateLimiting: boolean;
+    rateLimitRequests: number;
+    rateLimitWindow: number;
+    tunnelId: string;
 }
+
+export interface WebSocketSettings {
+    url: string;
+    reconnectAttempts: number;
+    reconnectDelay: number;
+    binaryChunkSize: number;
+    compressionEnabled: boolean;
+    compressionThreshold: number;
+    maxConnections: number;
+    maxMessageSize: number;
+    updateRate: number;
+}
+
+export interface SecuritySettings {
+    allowedOrigins: string[];
+    auditLogPath: string;
+    cookieHttponly: boolean;
+    cookieSamesite: string;
+    cookieSecure: boolean;
+    csrfTokenTimeout: number;
+    enableAuditLogging: boolean;
+    enableRequestValidation: boolean;
+    sessionTimeout: number;
+}
+
+export interface DebugSettings {
+    enabled: boolean;
+    enableDataDebug: boolean;
+    enableWebsocketDebug: boolean;
+    logBinaryHeaders: boolean;
+    logFullJson: boolean;
+}
+
+// Main settings interface
+export interface Settings {
+    visualization: VisualizationSettings;
+    xr: XRSettings;
+    system: SystemSettings;
+    labels: LabelSettings;
+}
+
+export * from './settings/base';
+export * from './settings/utils';
diff --git a/client/types/settings/base.ts b/client/types/settings/base.ts
new file mode 100644
index 00000000..11379a15
--- /dev/null
+++ b/client/types/settings/base.ts
@@ -0,0 +1,151 @@
+// Base types for settings
+export interface BaseSettings {
+    visualization: {
+        animations: {
+            enableMotionBlur: boolean;
+            enableNodeAnimations: boolean;
+            motionBlurStrength: number;
+            selectionWaveEnabled: boolean;
+            pulseEnabled: boolean;
+            rippleEnabled: boolean;
+            edgeAnimationEnabled: boolean;
+            flowParticlesEnabled: boolean;
+        };
+        bloom: {
+            enabled: boolean;
+            strength: number;
+            radius: number;
+            edgeBloomStrength: number;
+            nodeBloomStrength: number;
+            environmentBloomStrength: number;
+        };
+        edges: {
+            arrowSize: number;
+            baseWidth: number;
+            color: string;
+            enableArrows: boolean;
+            opacity: number;
+            widthRange: [number, number];
+        };
+        hologram: {
+            ringCount: number;
+            ringColor: string;
+            ringOpacity: number;
+            ringSizes: [number, number, number];
+            ringRotationSpeed: number;
+            enableBuckminster: boolean;
+            buckminsterScale: number;
+            buckminsterOpacity: number;
+            enableGeodesic: boolean;
+            geodesicScale: number;
+            geodesicOpacity: number;
+            enableTriangleSphere: boolean;
+            triangleSphereScale: number;
+            triangleSphereOpacity: number;
+            globalRotationSpeed: number;
+        };
+        labels: {
+            enableLabels: boolean;
+            textColor: string;
+            fontSize: number;
+            fontFamily: string;
+            strokeWidth: number;
+            strokeColor: string;
+            backgroundColor: string;
+            backgroundOpacity: number;
+            maxLength: number;
+            minDistance: number;
+            maxDistance: number;
+        };
+        nodes: {
+            baseSize: number;
+            sizeRange: [number, number];
+            color: string;
+            opacity: number;
+            outlineWidth: number;
+            outlineColor: string;
+            enableGlow: boolean;
+            glowStrength: number;
+            glowColor: string;
+            enablePulse: boolean;
+            pulseSpeed: number;
+            pulseStrength: number;
+        };
+        physics: {
+            enabled: boolean;
+            gravity: number;
+            springLength: number;
+            springStrength: number;
+            damping: number;
+            repulsion: number;
+            timeStep: number;
+            maxVelocity: number;
+            minVelocity: number;
+            maxIterations: number;
+        };
+    };
+    xr: {
+        mode: 'immersive-ar' | 'immersive-vr';
+        roomScale: boolean;
+        quality: 'low' | 'medium' | 'high';
+        input: {
+            handTracking: boolean;
+            controllerModel: string;
+            hapticFeedback: boolean;
+            gestureThreshold: number;
+            pinchThreshold: number;
+            grabThreshold: number;
+        };
+        visuals: {
+            shadowQuality: 'none' | 'low' | 'medium' | 'high';
+            antiAliasing: boolean;
+            foveatedRendering: boolean;
+            foveationLevel: number;
+            resolution: number;
+        };
+        environment: {
+            skybox: boolean;
+            skyboxColor: string;
+            groundPlane: boolean;
+            groundColor: string;
+            fog: boolean;
+            fogColor: string;
+            fogDensity: number;
+        };
+        passthrough: {
+            enabled: boolean;
+            opacity: number;
+            brightness: number;
+            contrast: number;
+            saturation: number;
+            blendMode: 'alpha-blend' | 'additive' | 'multiply';
+        };
+    };
+    system: {
+        debug: {
+            enabled: boolean;
+            logLevel: 'error' | 'warn' | 'info' | 'debug' | 'trace';
+            showStats: boolean;
+            showFPS: boolean;
+            showMemory: boolean;
+            logFullJson: boolean;
+        };
+        network: {
+            websocketUrl: string;
+            reconnectInterval: number;
+            maxReconnectAttempts: number;
+            heartbeatInterval: number;
+            compressionEnabled: boolean;
+            batchUpdates: boolean;
+            batchInterval: number;
+        };
+        security: {
+            enableEncryption: boolean;
+            encryptionAlgorithm: string;
+            encryptionKeySize: number;
+            enableAuthentication: boolean;
+            authenticationMethod: string;
+            tokenExpiration: number;
+        };
+    };
+}
diff --git a/client/types/settings/utils.ts b/client/types/settings/utils.ts
new file mode 100644
index 00000000..f168a033
--- /dev/null
+++ b/client/types/settings/utils.ts
@@ -0,0 +1,171 @@
+import { Settings } from '../settings';
+import { defaultSettings } from '../../state/defaultSettings';
+
+// Type for top-level settings categories
+export type SettingsCategory = keyof Settings;
+
+// Type for all possible paths in settings
+export type SettingsPath = string;
+
+// Type guard to check if a string is a valid settings category
+export function isSettingsCategory(key: string): key is SettingsCategory {
+    return key in defaultSettings;
+}
+
+// Type guard to check if a path exists in settings
+export function isValidSettingPath(path: string): boolean {
+    if (!path) {
+        return false;
+    }
+
+    try {
+        const parts = path.split('.');
+        if (parts.length === 0) {
+            return false;
+        }
+
+        let current: any = defaultSettings;
+        for (const part of parts) {
+            if (!part || typeof part !== 'string' || !(part in current)) {
+                return false;
+            }
+            current = current[part];
+        }
+        
+        return true;
+    } catch (error: unknown) {
+        return false;
+    }
+}
+
+// Get value from settings using path
+export function getSettingValue(settings: Settings, path: string): any {
+    if (!settings || typeof settings !== 'object') {
+        throw new Error('Invalid settings object');
+    }
+    if (!path) {
+        throw new Error('Path cannot be empty');
+    }
+    
+    try {
+        return path.split('.').reduce((obj: any, key) => {
+            if (obj === null || obj === undefined) {
+                throw new Error(`Invalid path: ${path}`);
+            }
+            return obj[key];
+        }, settings);
+    } catch (error: unknown) {
+        const message = error instanceof Error ? error.message : 'Unknown error';
+        throw new Error(`Failed to get setting value at path ${path}: ${message}`);
+    }
+}
+
+// Set value in settings using path
+export function setSettingValue(settings: Settings, path: string, value: any): void {
+    if (!settings || typeof settings !== 'object') {
+        throw new Error('Invalid settings object');
+    }
+    if (!path) {
+        throw new Error('Path cannot be empty');
+    }
+    
+    try {
+        const parts = path.split('.');
+        const lastKey = parts.pop();
+        if (!lastKey) {
+            throw new Error('Invalid path format');
+        }
+        
+        const target = parts.reduce((obj: any, key) => {
+            if (!(key in obj)) {
+                obj[key] = {};
+            }
+            return obj[key];
+        }, settings);
+
+        if (!target || typeof target !== 'object') {
+            throw new Error(`Invalid path: ${path}`);
+        }
+
+        target[lastKey] = value;
+    } catch (error: unknown) {
+        const message = error instanceof Error ? error.message : 'Unknown error';
+        throw new Error(`Failed to set setting value at path ${path}: ${message}`);
+    }
+}
+
+// Get the parent category of a setting path
+export function getSettingCategory(path: string): SettingsCategory | undefined {
+    if (!path) {
+        return undefined;
+    }
+    const category = path.split('.')[0];
+    return isSettingsCategory(category) ? category : undefined;
+}
+
+// Get subcategory path (everything after the main category)
+export function getSettingSubPath(path: string): string | undefined {
+    if (!path) {
+        return undefined;
+    }
+    const parts = path.split('.');
+    return parts.length > 1 ? parts.slice(1).join('.') : undefined;
+}
+
+// Helper to check if a value is a nested settings object
+export function isSettingsObject(value: any): boolean {
+    return value !== null && typeof value === 'object' && !Array.isArray(value);
+}
+
+// Helper to get all paths in a settings object
+export function getAllSettingPaths(
+    obj: any,
+    parentPath: string = '',
+    paths: string[] = []
+): string[] {
+    if (!isSettingsObject(obj)) {
+        return paths;
+    }
+
+    for (const key in obj) {
+        const currentPath = parentPath ? `${parentPath}.${key}` : key;
+        if (isSettingsObject(obj[key])) {
+            getAllSettingPaths(obj[key], currentPath, paths);
+        } else {
+            paths.push(currentPath);
+        }
+    }
+    return paths;
+}
+
+// Type helper for settings values
+export type SettingValue = string | number | boolean | string[] | number[];
+
+// Helper to get the appropriate input type for a setting
+export function getSettingInputType(value: SettingValue): string {
+    if (value === null || value === undefined) {
+        return 'text';
+    }
+    if (typeof value === 'boolean') return 'checkbox';
+    if (typeof value === 'number') return 'number';
+    if (typeof value === 'string' && value.startsWith('#')) return 'color';
+    if (Array.isArray(value)) return 'select';
+    return 'text';
+}
+
+// Helper to format setting names for display
+export function formatSettingName(setting: string): string {
+    if (!setting) return '';
+    return setting
+        .split(/(?=[A-Z])|_/)
+        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
+        .join(' ');
+}
+
+// Helper to get step value for number inputs
+export function getStepValue(key: string): string {
+    if (!key) return '1';
+    return key.toLowerCase().match(/strength|opacity|intensity|threshold|scale/)
+        ? '0.1'
+        : '1';
+}
diff --git a/client/types/settings/xr.ts b/client/types/settings/xr.ts
new file mode 100644
index 00000000..fa89f8de
--- /dev/null
+++ b/client/types/settings/xr.ts
@@ -0,0 +1,103 @@
+import { XRSessionMode } from '../xr';
+
+export interface XRSettings {
+    // Session Settings
+    mode: XRSessionMode;
+    roomScale: boolean;
+    spaceType: XRReferenceSpaceType;
+    
+    // Hand Tracking
+    enableHandTracking: boolean;
+    handMeshEnabled: boolean;
+    handMeshColor: string;
+    handMeshOpacity: number;
+    handPointSize: number;
+    handRayEnabled: boolean;
+    handRayColor: string;
+    handRayWidth: number;
+    gestureSsmoothing: number;
+    
+    // Interaction
+    enableHaptics: boolean;
+    hapticIntensity: number;
+    dragThreshold: number;
+    pinchThreshold: number;
+    rotationThreshold: number;
+    interactionRadius: number;
+    
+    // Scene Understanding
+    enableLightEstimation: boolean;
+    enablePlaneDetection: boolean;
+    enableSceneUnderstanding: boolean;
+    planeColor: string;
+    planeOpacity: number;
+    showPlaneOverlay: boolean;
+    snapToFloor: boolean;
+    
+    // Passthrough
+    enablePassthroughPortal: boolean;
+    passthroughOpacity: number;
+    passthroughBrightness: number;
+    passthroughContrast: number;
+    portalSize: number;
+    portalEdgeColor: string;
+    portalEdgeWidth: number;
+    
+    // Quality Settings
+    quality: 'low' | 'medium' | 'high';
+}
+
+// Platform-specific XR settings
+export interface QuestXRSettings extends XRSettings {
+    enableHandMeshes: boolean;
+    enableControllerModel: boolean;
+    controllerProfile: string;
+}
+
+export interface WebXRSettings extends XRSettings {
+    fallbackToInline: boolean;
+    requireFeatures: string[];
+    optionalFeatures: string[];
+}
+
+// Default XR settings
+export const defaultXRSettings: XRSettings = {
+    mode: 'immersive-ar',
+    roomScale: true,
+    spaceType: 'local-floor',
+    
+    enableHandTracking: true,
+    handMeshEnabled: true,
+    handMeshColor: '#ffffff',
+    handMeshOpacity: 0.5,
+    handPointSize: 5,
+    handRayEnabled: true,
+    handRayColor: '#00ff00',
+    handRayWidth: 2,
+    gestureSsmoothing: 0.5,
+    
+    enableHaptics: true,
+    hapticIntensity: 0.5,
+    dragThreshold: 0.02,
+    pinchThreshold: 0.7,
+    rotationThreshold: 0.1,
+    interactionRadius: 0.5,
+    
+    enableLightEstimation: true,
+    enablePlaneDetection: true,
+    enableSceneUnderstanding: true,
+    planeColor: '#808080',
+    planeOpacity: 0.5,
+    showPlaneOverlay: true,
+    snapToFloor: true,
+    
+    enablePassthroughPortal: false,
+    passthroughOpacity: 1,
+    passthroughBrightness: 1,
+    passthroughContrast: 1,
+    portalSize: 2,
+    portalEdgeColor: '#ffffff',
+    portalEdgeWidth: 2,
+    
+    quality: 'medium'
+};
diff --git a/client/types/websocket.ts b/client/types/websocket.ts
new file mode 100644
index 00000000..8ad79aae
--- /dev/null
+++ b/client/types/websocket.ts
@@ -0,0 +1,34 @@
+// WebSocket types for graph synchronization
+
+export enum ConnectionState {
+    DISCONNECTED = 'DISCONNECTED',
+    CONNECTING = 'CONNECTING',
+    CONNECTED = 'CONNECTED',
+    RECONNECTING = 'RECONNECTING'
+}
+
+export enum MessageType {
+    PING = 'ping',                          // Connection health check
+    PONG = 'pong'                           // Connection health response
+}
+
+// Connection health messages
+export interface PingMessage {
+    type: MessageType.PING;
+    timestamp: number;
+}
+
+export interface PongMessage {
+    type: MessageType.PONG;
+    timestamp: number;
+}
+
+export type WebSocketMessage = PingMessage | PongMessage;
+
+// WebSocket settings loaded via REST API
+export interface WebSocketSettings {
+    url: string;                  // WebSocket URL
+    reconnectAttempts: number;     // Max reconnection attempts (default: 3)
+    reconnectDelay: number;        // Delay between reconnects in ms (default: 5000)
+    updateRate: number;            // Update rate in Hz
+}
diff --git a/client/types/xr.ts b/client/types/xr.ts
new file mode 100644
index 00000000..c398b021
--- /dev/null
+++ b/client/types/xr.ts
@@ -0,0 +1,99 @@
+import * as THREE from 'three';
+import { Platform } from '../core/types';
+
+// Core XR Types
+export type XRSessionMode = 'inline' | 'immersive-vr' | 'immersive-ar';
+
+export interface XRSessionConfig {
+    mode: XRSessionMode;
+    features: {
+        required?: string[];
+        optional?: string[];
+    };
+    spaceType: XRReferenceSpaceType;
+}
+
+// Input and Interaction Types
+export interface HapticActuator {
+    pulse: (intensity: number, duration: number) => Promise<boolean>;
+}
+
+export interface WorldObject3D extends THREE.Object3D {
+    getWorldPosition(target: THREE.Vector3): THREE.Vector3;
+}
+
+export interface XRControllerState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    hapticActuator?: HapticActuator;
+    platform: Platform;
+}
+
+export interface XRHandJointState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    radius?: number;
+}
+
+export interface XRHandState {
+    position: THREE.Vector3;
+    joints: Map<XRHandJoint, XRHandJointState>;
+    pinchStrength: number;
+    gripStrength: number;
+    platform: Platform;
+}
+
+export interface XRHandWithHaptics extends THREE.Group {
+    hapticActuators?: HapticActuator[];
+    hand: {
+        joints: {
+            [key in XRHandJoint]?: WorldObject3D;
+        };
+    };
+    pinchStrength: number;
+    gripStrength: number;
+    userData: {
+        hapticActuator?: HapticActuator;
+        platform: Platform;
+    };
+}
+
+// Input Configuration
+export interface XRInputConfig {
+    controllers: boolean;
+    hands: boolean;
+    haptics: boolean;
+}
+
+// Event Types
+export interface XRControllerEvent {
+    controller: XRSpace;
+    inputSource: XRInputSource;
+    hapticActuator?: HapticActuator;
+}
+
+export interface XRHandEvent {
+    hand: XRHandWithHaptics;
+    inputSource: XRInputSource;
+}
+
+export interface XRInteractionState {
+    pinching: boolean;
+    pinchStrength: number;
+    gripping: boolean;
+    gripStrength: number;
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+}
+
+// Platform-specific Types
+export interface QuestHandTracking extends XRHandState {
+    confidence: number;
+    gestureId?: number;
+}
+
+export interface QuestControllerTracking extends XRControllerState {
+    thumbstick: THREE.Vector2;
+    trigger: number;
+    grip: number;
+}
diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
index 72e7bc09..a65b7747 100644
--- a/client/ui/ControlPanel.css
+++ b/client/ui/ControlPanel.css
@@ -121,6 +121,32 @@
     border-color: rgba(231, 76, 60, 0.6);
 }
 
+.randomize-button-container {
+    padding: 16px;
+    margin-bottom: 16px;
+    border-bottom: 1px solid #ccc;
+}
+
+.randomize-button {
+    width: 100%;
+    padding: 12px;
+    font-size: 16px;
+    color: white;
+    background-color: #2196f3;
+    border: none;
+    border-radius: 4px;
+    cursor: pointer;
+    transition: background-color 0.3s ease;
+}
+
+.randomize-button:hover {
+    background-color: #1976d2;
+}
+
+.randomize-button:active {
+    background-color: #0d47a1;
+}
+
 /* Scrollbar styles */
 .control-panel::-webkit-scrollbar {
     width: 8px;
diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
index 2352fa56..f065385a 100644
--- a/client/ui/ControlPanel.ts
+++ b/client/ui/ControlPanel.ts
@@ -1,273 +1,295 @@
-import { Settings } from '../core/types';
-import { settingsManager } from '../state/settings';
-import { defaultSettings } from '../state/defaultSettings';
-import { createLogger } from '../utils/logger';
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+import { SettingsStore } from '../state/SettingsStore';
+import './ControlPanel.css';
 
 const logger = createLogger('ControlPanel');
 
-type SettingsKey<T extends keyof Settings> = keyof Settings[T];
-type SettingValue<T extends keyof Settings, K extends SettingsKey<T>> = Settings[T][K];
-
 export class ControlPanel {
     private container: HTMLElement;
-    private currentSettings: Settings;
+    private settings: Settings;
     private unsubscribers: Array<() => void> = [];
+    private settingsStore: SettingsStore;
 
     constructor(container: HTMLElement) {
         this.container = container;
-        // Start with default settings
-        this.currentSettings = { ...defaultSettings };
-        this.setupUI();
-        this.setupWebSocketStatus();
-        this.initializeSettings();
+        this.settingsStore = SettingsStore.getInstance();
+        this.settings = {} as Settings;
+        this.initializePanel();
     }
 
-    private async initializeSettings(): Promise<void> {
+    private async initializePanel(): Promise<void> {
         try {
-            // Subscribe to settings changes
-            Object.keys(this.currentSettings).forEach(category => {
-                const categoryKey = category as keyof Settings;
-                const settings = this.currentSettings[categoryKey];
-                Object.keys(settings).forEach(setting => {
-                    const settingKey = setting as SettingsKey<typeof categoryKey>;
-                    const unsubscribe = settingsManager.subscribe(
-                        categoryKey,
-                        settingKey,
-                        (value: SettingValue<typeof categoryKey, typeof settingKey>) => {
-                            this.updateSettingUI(categoryKey, settingKey, value);
-                        }
-                    );
-                    this.unsubscribers.push(unsubscribe);
-                });
-            });
-
-            // Initialize settings manager
-            await settingsManager.initialize();
-            // Update UI with current settings
-            this.currentSettings = settingsManager.getCurrentSettings();
-            this.updateAllSettings();
+            await this.settingsStore.initialize();
+            this.settings = this.settingsStore.get('') as Settings;
+            this.createPanelElements();
+            await this.setupSettingsSubscriptions();
         } catch (error) {
-            logger.error('Error initializing settings:', error);
+            logger.error('Failed to initialize control panel:', error);
         }
     }
 
-    private updateSettingUI<T extends keyof Settings, K extends SettingsKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValue<T, K>
-    ): void {
-        const categoryEl = this.container.querySelector(`.settings-group[data-category="${category}"]`);
-        if (!categoryEl) return;
+    private createPanelElements(): void {
+        // Clear existing content
+        this.container.innerHTML = '';
 
-        const settingEl = categoryEl.querySelector(`.setting-item[data-setting="${String(setting)}"]`);
-        if (!settingEl) return;
+        // Create settings sections
+        const flatSettings = this.flattenSettings(this.settings);
+        const groupedSettings = this.groupSettingsByCategory(flatSettings);
 
-        const input = settingEl.querySelector('input');
-        if (!input) return;
-
-        if (input.type === 'checkbox' && typeof value === 'boolean') {
-            (input as HTMLInputElement).checked = value;
-        } else {
-            input.value = String(value);
+        for (const [category, settings] of Object.entries(groupedSettings)) {
+            const section = this.createSection(category);
+            
+            for (const [path, value] of Object.entries(settings)) {
+                const control = this.createSettingControl(path, value);
+                if (control) {
+                    section.appendChild(control);
+                }
+            }
+            
+            this.container.appendChild(section);
         }
     }
 
-    private updateAllSettings(): void {
-        Object.entries(this.currentSettings).forEach(([category, settings]) => {
-            const categoryKey = category as keyof Settings;
-            Object.entries(settings).forEach(([setting, value]) => {
-                const settingKey = setting as SettingsKey<typeof categoryKey>;
-                this.updateSettingUI(
-                    categoryKey,
-                    settingKey,
-                    value as SettingValue<typeof categoryKey, typeof settingKey>
-                );
-            });
-        });
+    private flattenSettings(obj: unknown, prefix: string = ''): Record<string, unknown> {
+        const result: Record<string, unknown> = {};
+        
+        if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
+            for (const [key, value] of Object.entries(obj)) {
+                const newKey = prefix ? `${prefix}.${key}` : key;
+                
+                if (value && typeof value === 'object' && !Array.isArray(value)) {
+                    Object.assign(result, this.flattenSettings(value, newKey));
+                } else {
+                    result[newKey] = value;
+                }
+            }
+        }
+        
+        return result;
     }
 
-    private async setupUI(): Promise<void> {
-        try {
-            // Clear any existing content
-            this.container.innerHTML = '';
-            
-            // Add control panel container
-            this.container.classList.add('control-panel');
-
-            // Add header
-            const header = document.createElement('div');
-            header.classList.add('control-panel-header');
-            header.innerHTML = `
-                <h3>Settings</h3>
-                <div class="connection-status disconnected">
-                    <span id="connection-status">Disconnected</span>
-                </div>
-            `;
-            this.container.appendChild(header);
+    private groupSettingsByCategory(flatSettings: Record<string, unknown>): Record<string, Record<string, unknown>> {
+        const result: Record<string, Record<string, unknown>> = {};
+        
+        for (const [path, value] of Object.entries(flatSettings)) {
+            const category = path.split('.')[0];
+            if (!result[category]) {
+                result[category] = {};
+            }
+            result[category][path] = value;
+        }
+        
+        return result;
+    }
 
-            // Add content container
-            const content = document.createElement('div');
-            content.classList.add('control-panel-content');
-            this.container.appendChild(content);
+    private createSection(category: string): HTMLElement {
+        const section = document.createElement('div');
+        section.className = 'settings-section';
+        
+        const header = document.createElement('h2');
+        header.textContent = this.formatCategoryName(category);
+        section.appendChild(header);
+        
+        return section;
+    }
 
-            // Add settings categories
-            (Object.keys(this.currentSettings) as Array<keyof Settings>).forEach(category => {
-                const categorySettings = this.currentSettings[category];
-                const categoryElement = this.createCategoryElement(category, categorySettings);
-                content.appendChild(categoryElement);
-            });
-        } catch (error) {
-            logger.error('Error setting up UI:', error);
+    private createSettingControl(path: string, value: unknown): HTMLElement | null {
+        const container = document.createElement('div');
+        container.className = 'setting-control';
+        
+        const label = document.createElement('label');
+        label.textContent = this.formatSettingName(path.split('.').pop()!);
+        container.appendChild(label);
+        
+        const control = this.createInputElement(path, value);
+        if (!control) {
+            return null;
         }
+        
+        container.appendChild(control);
+        return container;
     }
 
-    private createCategoryElement<T extends keyof Settings>(
-        category: T,
-        settings: Settings[T]
-    ): HTMLElement {
-        const element = document.createElement('div');
-        element.classList.add('settings-group');
-        element.dataset.category = category;
+    private createInputElement(path: string, value: unknown): HTMLElement | null {
+        const type = this.getInputType(value);
+        if (!type) {
+            return null;
+        }
+
+        let input: HTMLElement;
         
-        const title = this.formatTitle(category);
-        element.innerHTML = `<h4>${title}</h4>`;
+        switch (type) {
+            case 'checkbox':
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'checkbox';
+                (input as HTMLInputElement).checked = value as boolean;
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, target.checked);
+                };
+                break;
 
-        Object.entries(settings).forEach(([key, value]) => {
-            const settingKey = key as SettingsKey<T>;
-            const control = this.createSettingControl(category, settingKey, value);
-            element.appendChild(control);
-        });
+            case 'number':
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'number';
+                (input as HTMLInputElement).value = String(value);
+                (input as HTMLInputElement).step = this.getStepValue(path);
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, parseFloat(target.value));
+                };
+                break;
+
+            case 'color':
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'color';
+                (input as HTMLInputElement).value = value as string;
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, target.value);
+                };
+                break;
 
-        return element;
+            case 'select':
+                input = document.createElement('select');
+                if (Array.isArray(value)) {
+                    value.forEach(option => {
+                        const opt = document.createElement('option');
+                        opt.value = String(option);
+                        opt.textContent = String(option);
+                        input.appendChild(opt);
+                    });
+                }
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLSelectElement;
+                    this.settingsStore.set(path, target.value);
+                };
+                break;
+
+            default:
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'text';
+                (input as HTMLInputElement).value = String(value);
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, target.value);
+                };
+        }
+
+        input.id = `setting-${path}`;
+        return input;
     }
 
-    private formatTitle(str: string): string {
-        return str.replace(/([A-Z])/g, ' $1').trim();
+    private getInputType(value: unknown): string | null {
+        switch (typeof value) {
+            case 'boolean':
+                return 'checkbox';
+            case 'number':
+                return 'number';
+            case 'string':
+                if (value.match(/^#[0-9a-f]{6}$/i)) {
+                    return 'color';
+                }
+                return 'text';
+            case 'object':
+                if (Array.isArray(value)) {
+                    return 'select';
+                }
+                return null;
+            default:
+                return null;
+        }
     }
 
-    private createSettingControl<T extends keyof Settings, K extends SettingsKey<T>>(
-        category: T,
-        key: K,
-        value: SettingValue<T, K>
-    ): HTMLElement {
-        const control = document.createElement('div');
-        control.classList.add('setting-item');
-        control.dataset.setting = String(key);
+    private getStepValue(path: string): string {
+        if (path.includes('opacity') || path.includes('strength')) {
+            return '0.1';
+        }
+        return '1';
+    }
 
-        const label = document.createElement('label');
-        label.textContent = this.formatTitle(String(key));
-        control.appendChild(label);
+    private formatCategoryName(category: string): string {
+        return category
+            .split(/(?=[A-Z])/)
+            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
+            .join(' ');
+    }
 
-        if (Array.isArray(value)) {
-            const arrayControl = document.createElement('div');
-            arrayControl.classList.add('array-inputs');
-            value.forEach((item, index) => {
-                const input = document.createElement('input');
-                input.type = typeof item === 'number' ? 'number' : 'text';
-                input.value = String(item);
-                input.dataset.index = index.toString();
+    private formatSettingName(setting: string): string {
+        return setting
+            .split(/(?=[A-Z])/)
+            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
+            .join(' ');
+    }
 
-                // Update settings on input change
-                input.addEventListener('input', async () => {
-                    const newValue = input.type === 'number' ? parseFloat(input.value) : input.value;
-                    const newArray = [...value];
-                    newArray[index] = newValue;
-                    await this.updateSetting(category, key, newArray as SettingValue<T, K>);
-                });
+    private setupSettingsSubscriptions(): void {
+        // Clear existing subscriptions
+        this.unsubscribers.forEach(unsub => unsub());
+        this.unsubscribers = [];
 
-                arrayControl.appendChild(input);
-            });
-            control.appendChild(arrayControl);
-        } else {
-            const input = document.createElement('input');
-            switch (typeof value) {
-                case 'boolean':
-                    input.type = 'checkbox';
-                    input.checked = value;
-                    break;
-                case 'number':
-                    input.type = 'number';
-                    input.value = String(value);
-                    break;
-                default:
-                    input.type = 'text';
-                    input.value = String(value);
+        const settings = this.settingsStore;
+        let unsubscriber: (() => void) | undefined;
+
+        // Subscribe to settings changes
+        settings.subscribe('visualization.labels.enableLabels', (value) => {
+            this.updateLabelVisibility(typeof value === 'boolean' ? value : value === 'true');
+        }).then(unsub => {
+            unsubscriber = unsub;
+            if (unsubscriber) {
+                this.unsubscribers.push(unsubscriber);
             }
-            control.appendChild(input);
+        });
 
-            // Update settings on input change
-            input.addEventListener('input', async () => {
-                let newValue: SettingValue<T, K>;
-                if (input.type === 'checkbox') {
-                    newValue = input.checked as SettingValue<T, K>;
-                } else if (input.type === 'number') {
-                    newValue = parseFloat(input.value) as SettingValue<T, K>;
-                } else {
-                    newValue = input.value as SettingValue<T, K>;
+        const flatSettings = this.flattenSettings(this.settings);
+        for (const path of Object.keys(flatSettings)) {
+            settings.subscribe(path, (value) => {
+                this.updateSettingValue(path, value);
+            }).then(unsub => {
+                if (unsub) {
+                    this.unsubscribers.push(unsub);
                 }
-                await this.updateSetting(category, key, newValue);
             });
         }
+    }
 
-        return control;
+    private updateLabelVisibility(value: boolean): void {
+        // Update label visibility in the UI
+        const labelElements = document.querySelectorAll('.node-label');
+        labelElements.forEach(el => {
+            (el as HTMLElement).style.display = value ? 'block' : 'none';
+        });
     }
 
-    private async updateSetting<T extends keyof Settings, K extends SettingsKey<T>>(
-        category: T,
-        key: K,
-        value: SettingValue<T, K>
-    ): Promise<void> {
-        try {
-            // Update local settings
-            if (this.currentSettings[category]) {
-                (this.currentSettings[category] as any)[key] = value;
-            }
-            // Update server settings
-            await settingsManager.updateSetting(
-                category,
-                key,
-                value
-            );
-        } catch (error) {
-            logger.error('Error updating setting:', error);
-            // Revert UI to current setting value
-            this.updateSettingUI(category, key, (this.currentSettings[category] as any)[key]);
+    private updateSettingValue(path: string, value: unknown): void {
+        const element = document.getElementById(`setting-${path}`);
+        if (!element) {
+            logger.warn(`No element found for setting: ${path}`);
+            return;
         }
-    }
 
-    private setupWebSocketStatus(): void {
-        const statusIndicator = this.container.querySelector('.connection-status');
-        const statusText = this.container.querySelector('#connection-status');
-        
-        if (statusIndicator && statusText) {
-            try {
-                // Use the default WebSocket URL
-                const wsUrl = new URL('/wss', window.location.href);
-                wsUrl.protocol = wsUrl.protocol.replace('http', 'ws');
-                const ws = new WebSocket(wsUrl.toString());
-                
-                ws.onopen = () => {
-                    statusIndicator.classList.remove('disconnected');
-                    statusText.textContent = 'Connected';
-                };
-                
-                ws.onclose = () => {
-                    statusIndicator.classList.add('disconnected');
-                    statusText.textContent = 'Disconnected';
-                };
-                
-                ws.onerror = () => {
-                    statusIndicator.classList.add('disconnected');
-                    statusText.textContent = 'Error';
-                };
-            } catch (error) {
-                logger.error('Error setting up WebSocket:', error);
+        if (element instanceof HTMLInputElement) {
+            switch (element.type) {
+                case 'checkbox':
+                    element.checked = value as boolean;
+                    break;
+                case 'number':
+                    element.value = String(value);
+                    break;
+                case 'color':
+                    element.value = value as string;
+                    break;
+                default:
+                    element.value = String(value);
             }
+        } else if (element instanceof HTMLSelectElement) {
+            element.value = String(value);
         }
     }
 
     public dispose(): void {
-        this.unsubscribers.forEach(unsubscribe => unsubscribe());
+        this.unsubscribers.forEach(unsub => unsub());
         this.unsubscribers = [];
+        this.container.innerHTML = '';
     }
 }
diff --git a/client/utils/logger.ts b/client/utils/logger.ts
deleted file mode 100644
index 6200007d..00000000
--- a/client/utils/logger.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-export interface Logger {
-    log: (message: string, ...args: any[]) => void;
-    error: (message: string, ...args: any[]) => void;
-    warn: (message: string, ...args: any[]) => void;
-    info: (message: string, ...args: any[]) => void;
-    debug: (message: string, ...args: any[]) => void;
-}
-
-// Track debug state
-let debugEnabled = true; // Start with debug enabled
-
-export function setDebugEnabled(enabled: boolean): void {
-    debugEnabled = enabled;
-}
-
-export function createLogger(context: string): Logger {
-    const prefix = `[${context}]`;
-
-    return {
-        // Always log errors and warnings
-        log: (message: string, ...args: any[]) => console.log(`${prefix} ${message}`, ...args),
-        error: (message: string, ...args: any[]) => console.error(`${prefix} ${message}`, ...args),
-        warn: (message: string, ...args: any[]) => console.warn(`${prefix} ${message}`, ...args),
-        
-        // Debug and info respect debug state
-        info: (message: string, ...args: any[]) => {
-            if (debugEnabled) {
-                console.info(`${prefix} ${message}`, ...args);
-            }
-        },
-        debug: (message: string, ...args: any[]) => {
-            if (debugEnabled) {
-                console.debug(`${prefix} ${message}`, ...args);
-            }
-        }
-    };
-}
diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
index f7f17fc6..7366064c 100644
--- a/client/websocket/websocketService.ts
+++ b/client/websocket/websocketService.ts
@@ -1,254 +1,428 @@
-import {
-  MessageType,
-  WebSocketMessage,
-  WebSocketSettings,
-} from '../core/types';
-import { createLogger } from '../utils/logger';
+import { createLogger } from '../core/logger';
+import { buildWsUrl, buildApiUrl } from '../core/api';
+import { API_ENDPOINTS } from '../core/constants';
+import { convertObjectKeysToCamelCase } from '../core/utils';
 
 const logger = createLogger('WebSocketService');
 
-const DEFAULT_SETTINGS: WebSocketSettings = {
-  url: '/wss',
-  heartbeatInterval: 30,
-  heartbeatTimeout: 60,
-  reconnectAttempts: 3,
-  reconnectDelay: 5000,
-  binaryChunkSize: 65536,
-  compressionEnabled: true,
-  compressionThreshold: 1024,
-  maxConnections: 1000,
-  maxMessageSize: 100485760,
-  updateRate: 90
-};
-
-interface Node {
-  data: {
-    position: { x: number; y: number; z: number };
-    velocity: { x: number; y: number; z: number };
-  };
+enum ConnectionState {
+    DISCONNECTED = 'disconnected',
+    CONNECTING = 'connecting',
+    CONNECTED = 'connected',
+    RECONNECTING = 'reconnecting',
+    FAILED = 'failed'
 }
 
-type BinaryUpdateHandler = (data: ArrayBuffer) => void;
-type MessageHandler = (data: any) => void;
+// Simple interface matching server's binary format
+interface NodeData {
+    position: [number, number, number];
+    velocity: [number, number, number];
+}
+
+interface NodeUpdate {
+    id: string;
+    position: {
+        x: number;
+        y: number;
+        z: number;
+    };
+}
+
+interface SettingsUpdateMessage {
+    category: string;
+    setting: string;
+    value: any;
+}
+
+type BinaryMessageCallback = (nodes: NodeData[]) => void;
 
 export class WebSocketService {
-  private ws: WebSocket | null = null;
-  private settings: WebSocketSettings;
-  private reconnectTimeout: NodeJS.Timeout | null = null;
-  private heartbeatTimer: NodeJS.Timeout | null = null;
-  private lastPongTime: number = 0;
-  private reconnectAttempts = 0;
-  private binaryUpdateHandler: BinaryUpdateHandler | null = null;
-  private isReconnecting = false;
-  private messageHandlers: Map<MessageType, MessageHandler[]> = new Map();
-
-  constructor(settings: Partial<WebSocketSettings> = {}) {
-    this.settings = { ...DEFAULT_SETTINGS, ...settings };
-    this.connect();
-  }
-
-  private connect() {
-    if (this.ws?.readyState === WebSocket.CONNECTING || this.isReconnecting) {
-      return;
-    }
-
-    try {
-      // Get WebSocket URL from settings
-      const wsUrl = new URL(this.settings.url, window.location.href);
-      wsUrl.protocol = wsUrl.protocol.replace('http', 'ws');
-      const fullUrl = wsUrl.toString();
-
-      this.ws = new WebSocket(fullUrl);
-      this.ws.binaryType = 'arraybuffer';
-
-      this.ws.onopen = this.handleOpen.bind(this);
-      this.ws.onclose = this.handleClose.bind(this);
-      this.ws.onerror = this.handleError.bind(this);
-      this.ws.onmessage = this.handleMessage.bind(this);
-
-      this.startHeartbeat();
-    } catch (error) {
-      this.handleError(error as Event);
-    }
-  }
-
-  private handleOpen() {
-    logger.info('WebSocket connected');
-    this.reconnectAttempts = 0;
-    this.isReconnecting = false;
-    this.lastPongTime = Date.now();
-  }
-
-  private handleClose(event: CloseEvent) {
-    this.cleanup();
-    if (!event.wasClean) {
-      this.attemptReconnect();
-    }
-  }
-
-  private handleError(event: Event) {
-    logger.error('WebSocket error:', event);
-    this.cleanup();
-    this.attemptReconnect();
-  }
-
-  private handleMessage(event: MessageEvent) {
-    this.lastPongTime = Date.now();
-
-    if (event.data instanceof ArrayBuffer) {
-      if (this.binaryUpdateHandler) {
-        this.binaryUpdateHandler(event.data);
-      }
-      // Also notify through the traditional handler
-      const handlers = this.messageHandlers.get('binaryPositionUpdate');
-      if (handlers) {
-        const view = new Float32Array(event.data);
-        const nodes: Node[] = [];
-        for (let i = 0; i < view.length; i += 6) {
-          nodes.push({
-            data: {
-              position: { x: view[i], y: view[i+1], z: view[i+2] },
-              velocity: { x: view[i+3], y: view[i+4], z: view[i+5] }
+    private static instance: WebSocketService | null = null;
+    private ws: WebSocket | null = null;
+    private binaryMessageCallback: BinaryMessageCallback | null = null;
+    private reconnectTimeout: number | null = null;
+    private connectionState: ConnectionState = ConnectionState.DISCONNECTED;
+    private reconnectAttempts: number = 0;
+    private readonly _maxReconnectAttempts: number = 5;
+    private readonly initialReconnectDelay: number = 5000; // 5 seconds
+    private readonly maxReconnectDelay: number = 60000; // 60 seconds
+    private url: string = '';
+    private settingsStore: Map<string, any> = new Map();
+    private connectionStatusHandler: ((status: boolean) => void) | null = null;
+    private settingsUpdateHandler: ((settings: any) => void) | null = null;
+
+    private constructor() {
+        // Don't automatically connect - wait for explicit connect() call
+    }
+
+    public connect(): void {
+        if (this.connectionState !== ConnectionState.DISCONNECTED) {
+            logger.warn('WebSocket already connected or connecting');
+            return;
+        }
+        this.initializeWebSocket();
+    }
+
+    private async initializeWebSocket(): Promise<void> {
+        if (this.connectionState !== ConnectionState.DISCONNECTED) {
+            return;
+        }
+
+        try {
+            const settings = await this.loadWebSocketSettings();
+            this.url = settings.url || buildWsUrl();
+            
+            if (!this.url) {
+                throw new Error('No WebSocket URL available');
+            }
+
+            this.connectionState = ConnectionState.CONNECTING;
+            this.ws = new WebSocket(this.url);
+            this.setupWebSocketHandlers();
+        } catch (error) {
+            logger.error('Failed to initialize WebSocket:', error);
+            this.handleReconnect();
+        }
+    }
+
+    private getReconnectDelay(): number {
+        // Exponential backoff with max delay
+        const delay = Math.min(
+            this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts),
+            this.maxReconnectDelay
+        );
+        // Add some jitter
+        return delay + (Math.random() * 1000);
+    }
+
+    private setupWebSocketHandlers(): void {
+        if (!this.ws) return;
+        
+        this.ws.binaryType = 'arraybuffer';
+
+        this.ws.onopen = (): void => {
+            logger.info(`WebSocket connected successfully to ${this.url}`);
+            this.connectionState = ConnectionState.CONNECTED;
+            this.reconnectAttempts = 0;
+
+            // Notify connection status change
+            if (this.connectionStatusHandler) {
+                this.connectionStatusHandler(true);
+            }
+
+            // Send initial protocol messages
+            this.sendMessage({ type: 'requestInitialData' });
+            this.sendMessage({ type: 'enableBinaryUpdates' });
+        };
+
+        this.ws.onerror = (event: Event): void => {
+            logger.error('WebSocket error:', event);
+            if (this.ws) {
+                logger.debug('WebSocket readyState:', this.ws.readyState);
+            }
+        };
+
+        this.ws.onclose = (event: CloseEvent): void => {
+            logger.warn(`WebSocket closed with code ${event.code}: ${event.reason}`);
+            
+            // Notify connection status change
+            if (this.connectionStatusHandler) {
+                this.connectionStatusHandler(false);
+            }
+            
+            this.handleReconnect();
+        };
+
+        this.ws.onmessage = async (event: MessageEvent): Promise<void> => {
+            try {
+                if (this.connectionState !== ConnectionState.CONNECTED || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
+                    logger.warn('WebSocket not connected, ignoring message');
+                    return;
+                }
+
+                // Handle text messages
+                if (typeof event.data === 'string') {
+                    try {
+                        const message = JSON.parse(event.data);
+                        if (message.error) {
+                            logger.error('[Server Error]', message.error);
+                            return;
+                        }
+                        // Handle settings update
+                        if (message.type === 'settings_update') {
+                            this.handleSettingsUpdate(message);
+                            return;
+                        }
+                    } catch (e) {
+                        logger.warn('Received non-JSON text message:', event.data);
+                        return;
+                    }
+                }
+
+                // Handle binary position/velocity updates
+                if (event.data instanceof ArrayBuffer && this.binaryMessageCallback) {
+                    // Validate data length (24 bytes per node - 6 floats * 4 bytes)
+                    if (event.data.byteLength % 24 !== 0) {
+                        logger.error('Invalid binary message length:', event.data.byteLength);
+                        return;
+                    }
+
+                    const float32Array = new Float32Array(event.data);
+                    const nodeCount = float32Array.length / 6;
+                    const nodes: NodeData[] = [];
+
+                    for (let i = 0; i < nodeCount; i++) {
+                        const baseIndex = i * 6;
+                        
+                        // Validate float values
+                        const values = float32Array.slice(baseIndex, baseIndex + 6);
+                        if (!values.every(v => Number.isFinite(v))) {
+                            logger.error('Invalid float values in node data at index:', i);
+                            continue;
+                        }
+
+                        nodes.push({
+                            position: [
+                                values[0],
+                                values[1],
+                                values[2]
+                            ],
+                            velocity: [
+                                values[3],
+                                values[4],
+                                values[5]
+                            ]
+                        });
+                    }
+
+                    if (nodes.length > 0) {
+                        await Promise.resolve().then(() => {
+                            if (this.binaryMessageCallback) {
+                                this.binaryMessageCallback(nodes);
+                            }
+                        });
+                    }
+                }
+            } catch (error) {
+                logger.error('Error processing WebSocket message:', error);
+            }
+        };
+    }
+
+    private handleReconnect(): void {
+        const wasConnected = this.connectionState === ConnectionState.CONNECTED;
+        this.connectionState = ConnectionState.DISCONNECTED;
+        this.binaryMessageCallback = null;
+        
+        if (this.reconnectTimeout !== null) {
+            window.clearTimeout(this.reconnectTimeout);
+        }
+        
+        if (this.reconnectAttempts < this._maxReconnectAttempts &&
+            (wasConnected || this.reconnectAttempts === 0)) {
+            
+            this.reconnectAttempts++;
+            const delay = this.getReconnectDelay();
+            
+            logger.info(
+                `WebSocket connection closed, attempt ${this.reconnectAttempts}/${this._maxReconnectAttempts} in ${delay}ms`
+            );
+            
+            this.connectionState = ConnectionState.RECONNECTING;
+            
+            this.reconnectTimeout = window.setTimeout(() => {
+                this.reconnectTimeout = null;
+                this.connect();
+            }, delay);
+        } else if (this.reconnectAttempts >= this._maxReconnectAttempts) {
+            logger.warn('Maximum reconnection attempts reached, WebSocket disabled');
+            this.connectionState = ConnectionState.FAILED;
+            if (this.connectionStatusHandler) {
+                this.connectionStatusHandler(false);
+            }
+        } else {
+            logger.info('WebSocket connection closed');
+        }
+    }
+
+    private handleSettingsUpdate(message: SettingsUpdateMessage): void {
+        const { category, setting, value } = message;
+        
+        // Use existing utilities for case conversion
+        const convertedValue = convertObjectKeysToCamelCase({
+            [category]: {
+                [setting]: value
+            }
+        }) as Record<string, Record<string, unknown>>;
+        
+        // Extract the converted category, setting and value
+        const entries = Object.entries(convertedValue);
+        if (entries.length > 0) {
+            const [camelCategory, settingsObj] = entries[0];
+            const settingEntries = Object.entries(settingsObj);
+            if (settingEntries.length > 0) {
+                const [camelSetting, camelValue] = settingEntries[0];
+                // Update settings store
+                this.settingsStore.set(`${camelCategory}.${camelSetting}`, camelValue);
+                
+                // Notify settings update handler
+                if (this.settingsUpdateHandler) {
+                    this.settingsUpdateHandler({
+                        [camelCategory]: {
+                            [camelSetting]: camelValue
+                        }
+                    });
+                }
+            }
+        }
+    }
+
+    public static getInstance(): WebSocketService {
+        if (!WebSocketService.instance) {
+            WebSocketService.instance = new WebSocketService();
+        }
+        return WebSocketService.instance;
+    }
+
+    public onBinaryMessage(callback: BinaryMessageCallback): void {
+        this.binaryMessageCallback = callback;
+    }
+
+    public getConnectionStatus(): ConnectionState {
+        return this.connectionState;
+    }
+
+    private sendMessage(message: any): void {
+        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
+            try {
+                this.ws.send(JSON.stringify(message));
+            } catch (error) {
+                logger.error('Error sending message:', error);
             }
-          });
         }
-        handlers.forEach(h => h({ type: 'binaryPositionUpdate', data: { nodes } }));
-      }
-      return;
-    }
-
-    try {
-      const message = JSON.parse(event.data) as WebSocketMessage;
-      
-      // Handle message based on type
-      const handlers = this.messageHandlers.get(message.type);
-      if (handlers) {
-        handlers.forEach(h => h(message));
-      }
-
-      if (message.type === 'ping') {
-        this.handlePing(message);
-      }
-    } catch (error) {
-      logger.error('Failed to parse message:', error);
-    }
-  }
-
-  private handlePing(message: { type: 'ping', timestamp: number }) {
-    if (this.ws?.readyState === WebSocket.OPEN) {
-      const pong = {
-        type: 'pong' as const,
-        timestamp: message.timestamp
-      };
-      this.ws.send(JSON.stringify(pong));
-    }
-  }
-
-  private startHeartbeat() {
-    this.stopHeartbeat();
-    
-    this.heartbeatTimer = setInterval(() => {
-      if (this.ws?.readyState !== WebSocket.OPEN) {
-        return;
-      }
-
-      // Check if we've received a pong recently
-      const timeSinceLastPong = Date.now() - this.lastPongTime;
-      if (timeSinceLastPong > this.settings.heartbeatTimeout * 1000) {
-        logger.warn('Connection timeout, reconnecting...');
-        this.cleanup();
-        this.attemptReconnect();
-        return;
-      }
-
-      // Send ping
-      const ping = {
-        type: 'ping' as const,
-        timestamp: Date.now()
-      };
-      this.ws.send(JSON.stringify(ping));
-    }, this.settings.heartbeatInterval * 1000);
-  }
-
-  private stopHeartbeat() {
-    if (this.heartbeatTimer) {
-      clearInterval(this.heartbeatTimer);
-      this.heartbeatTimer = null;
-    }
-  }
-
-  private cleanup() {
-    this.stopHeartbeat();
-    
-    if (this.ws) {
-      this.ws.onopen = null;
-      this.ws.onclose = null;
-      this.ws.onerror = null;
-      this.ws.onmessage = null;
-      
-      if (this.ws.readyState === WebSocket.OPEN) {
-        this.ws.close();
-      }
-      this.ws = null;
-    }
-  }
-
-  private attemptReconnect() {
-    if (this.isReconnecting || this.reconnectAttempts >= this.settings.reconnectAttempts) {
-      logger.error('Max reconnection attempts reached');
-      return;
-    }
-
-    this.isReconnecting = true;
-    this.reconnectAttempts++;
-
-    if (this.reconnectTimeout) {
-      clearTimeout(this.reconnectTimeout);
-    }
-
-    this.reconnectTimeout = setTimeout(() => {
-      logger.info(`Reconnecting... Attempt ${this.reconnectAttempts}`);
-      this.connect();
-    }, this.settings.reconnectDelay);
-  }
-
-  // Compatibility methods for existing code
-  public onMessage(type: MessageType, handler: MessageHandler) {
-    const handlers = this.messageHandlers.get(type) || [];
-    handlers.push(handler);
-    this.messageHandlers.set(type, handlers);
-  }
-
-  public send(data: string) {
-    if (this.ws?.readyState === WebSocket.OPEN) {
-      this.ws.send(data);
-    }
-  }
-
-  public onBinaryUpdate(handler: BinaryUpdateHandler) {
-    this.binaryUpdateHandler = handler;
-  }
-
-  public dispose(): void {
-    this.close();
-    this.messageHandlers.clear();
-    this.binaryUpdateHandler = null;
-  }
-
-  public close(): void {
-    if (this.ws) {
-      this.ws.close();
-      this.ws = null;
-    }
-    
-    if (this.heartbeatTimer) {
-      clearInterval(this.heartbeatTimer);
-      this.heartbeatTimer = null;
-    }
-
-    if (this.reconnectTimeout) {
-      clearTimeout(this.reconnectTimeout);
-      this.reconnectTimeout = null;
-    }
-  }
+    }
+
+    public sendNodeUpdates(updates: NodeUpdate[]): void {
+        if (this.connectionState !== ConnectionState.CONNECTED || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
+            logger.warn('WebSocket not connected, cannot send node updates');
+            return;
+        }
+
+        try {
+            // Validate updates
+            if (!Array.isArray(updates) || updates.length === 0) {
+                logger.warn('Invalid node updates: empty or not an array');
+                return;
+            }
+
+            // Validate each update
+            const validUpdates = updates.filter(update => {
+                if (!update.position || typeof update.position !== 'object') {
+                    logger.warn('Invalid node update: missing or invalid position', update);
+                    return false;
+                }
+
+                const { x, y, z } = update.position;
+                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
+                    logger.warn('Invalid node update: non-finite position values', update);
+                    return false;
+                }
+
+                return true;
+            });
+
+            if (validUpdates.length === 0) {
+                logger.warn('No valid updates to send');
+                return;
+            }
+
+            // Create binary message (24 bytes per node - 6 floats * 4 bytes)
+            const float32Array = new Float32Array(validUpdates.length * 6);
+            
+            validUpdates.forEach((update, index) => {
+                const baseIndex = index * 6;
+                float32Array[baseIndex] = update.position.x;
+                float32Array[baseIndex + 1] = update.position.y;
+                float32Array[baseIndex + 2] = update.position.z;
+                // Set velocity components to 0 as they're not provided in updates
+                float32Array[baseIndex + 3] = 0;
+                float32Array[baseIndex + 4] = 0;
+                float32Array[baseIndex + 5] = 0;
+            });
+
+            this.ws.send(float32Array.buffer);
+            logger.debug(`Sent ${validUpdates.length} node updates`);
+        } catch (error) {
+            logger.error('Error sending node updates:', error);
+            if (error instanceof Error) {
+                logger.error('Error details:', {
+                    name: error.name,
+                    message: error.message,
+                    stack: error.stack
+                });
+            }
+        }
+    }
+
+    public onConnectionStatusChange(handler: (status: boolean) => void): void {
+        this.connectionStatusHandler = handler;
+        // Immediately call handler with current status if connected
+        if (this.connectionState === ConnectionState.CONNECTED && handler) {
+            handler(true);
+        }
+    }
+
+    public onSettingsUpdate(handler: (settings: any) => void): void {
+        this.settingsUpdateHandler = handler;
+    }
+
+    public dispose(): void {
+        if (this.reconnectTimeout !== null) {
+            window.clearTimeout(this.reconnectTimeout);
+            this.reconnectTimeout = null;
+        }
+        
+        if (this.ws) {
+            this.ws.close();
+            this.ws = null;
+        }
+        
+        this.binaryMessageCallback = null;
+        this.connectionStatusHandler = null;
+        this.settingsUpdateHandler = null;
+        this.connectionState = ConnectionState.DISCONNECTED;
+        WebSocketService.instance = null;
+    }
+
+    private async loadWebSocketSettings(): Promise<any> {
+        try {
+            // Try both endpoints
+            const endpoints = [
+                API_ENDPOINTS.WEBSOCKET_CONTROL,
+                buildApiUrl('settings/websocket')
+            ];
+
+            let response = null;
+            for (const endpoint of endpoints) {
+                try {
+                    response = await fetch(endpoint);
+                    if (response.ok) break;
+                } catch (e) {
+                    continue;
+                }
+            }
+
+            if (!response || !response.ok) {
+                throw new Error('Failed to load WebSocket settings');
+            }
+
+            return await response.json();
+        } catch (error) {
+            logger.error('Failed to load WebSocket settings:', error);
+            // Return defaults
+            return {
+                url: buildWsUrl()
+            };
+        }
+    }
 }
diff --git a/client/xr/xrInteraction.ts b/client/xr/xrInteraction.ts
index 9eaa4f21..9399c7cd 100644
--- a/client/xr/xrInteraction.ts
+++ b/client/xr/xrInteraction.ts
@@ -1,181 +1,33 @@
-import * as THREE from 'three';
-import { XRHandWithHaptics } from './xrTypes';
-import { NodeManager } from '../rendering/nodes';
 import { XRSessionManager } from './xrSessionManager';
-import { Settings } from '../core/types';
+import { NodeManager } from '../rendering/nodes';
+import { SettingsStore } from '../state/SettingsStore';
+import { createLogger } from '../core/logger';
+import { WebSocketService } from '../websocket/websocketService';
+import * as THREE from 'three';
+
+const logger = createLogger('XRInteraction');
 
 export class XRInteraction {
     private static instance: XRInteraction | null = null;
-    private xrManager: XRSessionManager;
-    private nodeManager: NodeManager;
-    private controllers: THREE.Group[] = [];
-    private lastInteractorPosition = new THREE.Vector3();
-    private hands: XRHandWithHaptics[] = [];
-    private settings: Settings;
+    private readonly settingsStore: SettingsStore;
+    private updateBatch: Map<string, THREE.Vector3> = new Map();
+    private batchUpdateTimeout: NodeJS.Timeout | null = null;
+    private settingsUnsubscribers: Array<() => void> = [];
+    private interactionEnabled: boolean = false;
+    private websocketService: WebSocketService;
+
+    private constructor(_: XRSessionManager, __: NodeManager) {
+        this.settingsStore = SettingsStore.getInstance();
+        this.websocketService = WebSocketService.getInstance();
+        this.initializeSettings();
+    }
 
-    private constructor(xrManager: XRSessionManager, nodeManager: NodeManager) {
-        this.xrManager = xrManager;
-        this.nodeManager = nodeManager;
-        
-        this.settings = {
-            animations: { 
-                enableMotionBlur: false, 
-                enableNodeAnimations: false, 
-                motionBlurStrength: 0.4, 
-                selectionWaveEnabled: false, 
-                pulseEnabled: false, 
-                rippleEnabled: false, 
-                edgeAnimationEnabled: false, 
-                flowParticlesEnabled: false 
-            },
-            ar: {
-                dragThreshold: 0.04,
-                enableHandTracking: true,
-                enableHaptics: true,
-                enableLightEstimation: true,
-                enablePassthroughPortal: false,
-                enablePlaneDetection: true,
-                enableSceneUnderstanding: true,
-                gestureSsmoothing: 0.9,
-                handMeshColor: '#FFD700',
-                handMeshEnabled: true,
-                handMeshOpacity: 0.3,
-                handPointSize: 0.01,
-                handRayColor: '#FFD700',
-                handRayEnabled: true,
-                handRayWidth: 0.002,
-                hapticIntensity: 0.7,
-                passthroughBrightness: 1,
-                passthroughContrast: 1,
-                passthroughOpacity: 1,
-                pinchThreshold: 0.015,
-                planeColor: '#4A90E2',
-                planeOpacity: 0.3,
-                portalEdgeColor: '#FFD700',
-                portalEdgeWidth: 0.02,
-                portalSize: 1,
-                roomScale: true,
-                rotationThreshold: 0.08,
-                showPlaneOverlay: true,
-                snapToFloor: true
-            },
-            audio: { 
-                enableAmbientSounds: false, 
-                enableInteractionSounds: false, 
-                enableSpatialAudio: false 
-            },
-            bloom: { 
-                edgeBloomStrength: 0.3, 
-                enabled: false, 
-                environmentBloomStrength: 0.5, 
-                nodeBloomStrength: 0.2, 
-                radius: 0.5, 
-                strength: 1.8 
-            },
-            clientDebug: { 
-                enableDataDebug: false, 
-                enableWebsocketDebug: false, 
-                enabled: false, 
-                logBinaryHeaders: false, 
-                logFullJson: false 
-            },
-            edges: {
-                arrowSize: 0.15, 
-                baseWidth: 2, 
-                color: '#917f18', 
-                enableArrows: false, 
-                opacity: 1, 
-                widthRange: [1, 4] 
-            },
-            labels: {
-                desktopFontSize: 12, 
-                enableLabels: true, 
-                textColor: '#FFFFFF' 
-            },
-            network: {
-                bindAddress: '0.0.0.0',
-                domain: 'localhost',
-                enableHttp2: false,
-                enableRateLimiting: true,
-                enableTls: false,
-                maxRequestSize: 10485760,
-                minTlsVersion: '',
-                port: 3001,
-                rateLimitRequests: 100,
-                rateLimitWindow: 60,
-                tunnelId: 'dummy'
-            },
-            nodes: { 
-                baseColor: '#4A90E2', 
-                baseSize: 1, 
-                clearcoat: 0.5, 
-                enableHoverEffect: true, 
-                enableInstancing: true, 
-                highlightColor: '#FFD700', 
-                highlightDuration: 500, 
-                hoverScale: 1.2, 
-                materialType: 'standard', 
-                metalness: 0.5, 
-                opacity: 1, 
-                roughness: 0.5, 
-                sizeByConnections: false, 
-                sizeRange: [0.5, 2] 
-            },
-            physics: { 
-                attractionStrength: 0.1, 
-                boundsSize: 100, 
-                collisionRadius: 1, 
-                damping: 0.5, 
-                enableBounds: true, 
-                enabled: true, 
-                iterations: 1, 
-                maxVelocity: 10, 
-                repulsionStrength: 0.2, 
-                springStrength: 0.1 
-            },
-            rendering: { 
-                ambientLightIntensity: 0.5, 
-                backgroundColor: '#000000', 
-                directionalLightIntensity: 1, 
-                enableAmbientOcclusion: true, 
-                enableAntialiasing: true, 
-                enableShadows: true, 
-                environmentIntensity: 1 
-            },
-            default: {
-                apiClientTimeout: 30,
-                enableMetrics: true,
-                enableRequestLogging: true,
-                logFormat: "json",
-                logLevel: "debug",
-                maxConcurrentRequests: 5,
-                maxPayloadSize: 5242880,
-                maxRetries: 3,
-                metricsPort: 9090,
-                retryDelay: 5
-            },
-            security: {
-                allowedOrigins: [],
-                auditLogPath: "/app/logs/audit.log",
-                cookieHttponly: true,
-                cookieSamesite: "Strict",
-                cookieSecure: true,
-                csrfTokenTimeout: 3600,
-                enableAuditLogging: true,
-                enableRequestValidation: true,
-                sessionTimeout: 3600
-            },
-            serverDebug: {
-                enabled: false,
-                enableDataDebug: false,
-                enableWebsocketDebug: false,
-                logBinaryHeaders: false,
-                logFullJson: false
-            }
-        };
-        
-        this.setupXRControllers();
-        this.setupHandTracking();
+    private initializeSettings(): void {
+        try {
+            this.setupSettingsSubscription();
+        } catch (error) {
+            logger.error('Failed to setup settings subscription:', error);
+        }
     }
 
     public static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
@@ -185,113 +37,63 @@ export class XRInteraction {
         return XRInteraction.instance;
     }
 
-    private setupXRControllers(): void {
-        this.xrManager.onControllerAdded((controller: THREE.Group) => {
-            this.controllers.push(controller);
-            if (controller.userData.hapticActuator) {
-                this.triggerHapticFeedback(controller, 0.5, 50);
+    private setupSettingsSubscription(): void {
+        // Clear any existing subscriptions
+        this.settingsUnsubscribers.forEach(unsub => unsub());
+        this.settingsUnsubscribers = [];
+
+        // Subscribe to XR interaction enabled state
+        let unsubscriber: (() => void) | undefined;
+        this.settingsStore.subscribe('xr.interaction.enabled', (value) => {
+            this.interactionEnabled = typeof value === 'boolean' ? value : value === 'true';
+            if (!this.interactionEnabled) {
+                this.clearHandState();
             }
-        });
-
-        this.xrManager.onControllerRemoved((controller: THREE.Group) => {
-            const index = this.controllers.indexOf(controller);
-            if (index !== -1) {
-                this.controllers.splice(index, 1);
+        }).then(unsub => {
+            unsubscriber = unsub;
+            if (unsubscriber) {
+                this.settingsUnsubscribers.push(unsubscriber);
             }
         });
     }
 
-    private setupHandTracking(): void {
-        if (!this.settings.ar.enableHandTracking) return;
-
-        // Hand tracking is handled by the XRSessionManager directly
-        this.hands = [];
-    }
-
-    public update(): void {
-        if (!this.settings.ar.enableHandTracking) return;
-
-        // Update hand interactions
-        this.hands.forEach(hand => {
-            if (hand.pinchStrength > this.settings.ar.pinchThreshold) {
-                this.handlePinchGesture(hand);
-            }
-        });
-
-        // Update controller interactions
-        this.controllers.forEach(controller => {
-            this.handleControllerInteraction(controller);
-        });
-    }
-
-    private handlePinchGesture(hand: XRHandWithHaptics): void {
-        const indexTip = hand.hand.joints['index-finger-tip'];
-        if (!indexTip) return;
-
-        const position = new THREE.Vector3();
-        position.setFromMatrixPosition(indexTip.matrixWorld);
-
-        // Calculate movement delta
-        const delta = position.clone().sub(this.lastInteractorPosition);
-        
-        // Update node position based on hand movement
-        if (delta.length() > this.settings.ar.dragThreshold) {
-            // Get all nodes and update their positions
-            const nodes = this.nodeManager.getAllNodeMeshes();
-            nodes.forEach(nodeMesh => {
-                const currentPos = this.nodeManager.getNodePosition(nodeMesh.userData.nodeId);
-                const newPos = currentPos.add(delta);
-                this.nodeManager.updateNodePosition(nodeMesh.userData.nodeId, newPos);
-            });
-
-            if (this.settings.ar.enableHaptics) {
-                this.triggerHapticFeedback(hand, this.settings.ar.hapticIntensity, 50);
-            }
+    private clearHandState(): void {
+        this.updateBatch.clear();
+        if (this.batchUpdateTimeout) {
+            clearTimeout(this.batchUpdateTimeout);
+            this.batchUpdateTimeout = null;
         }
-
-        this.lastInteractorPosition.copy(position);
     }
 
-    private handleControllerInteraction(controller: THREE.Group): void {
-        const position = new THREE.Vector3();
-        position.setFromMatrixPosition(controller.matrixWorld);
-
-        // Calculate movement delta
-        const delta = position.clone().sub(this.lastInteractorPosition);
-        
-        // Update node position based on controller movement
-        if (delta.length() > this.settings.ar.dragThreshold) {
-            // Get all nodes and update their positions
-            const nodes = this.nodeManager.getAllNodeMeshes();
-            nodes.forEach(nodeMesh => {
-                const currentPos = this.nodeManager.getNodePosition(nodeMesh.userData.nodeId);
-                const newPos = currentPos.add(delta);
-                this.nodeManager.updateNodePosition(nodeMesh.userData.nodeId, newPos);
-            });
+    private flushPositionUpdates(): void {
+        if (this.updateBatch.size === 0) return;
 
-            if (this.settings.ar.enableHaptics && controller.userData.hapticActuator) {
-                this.triggerHapticFeedback(controller, this.settings.ar.hapticIntensity, 50);
+        const updates = Array.from(this.updateBatch.entries()).map(([id, position]) => ({
+            id,
+            position: {
+                x: position.x,
+                y: position.y,
+                z: position.z
             }
-        }
+        }));
 
-        this.lastInteractorPosition.copy(position);
+        this.websocketService.sendNodeUpdates(updates);
+        this.updateBatch.clear();
     }
 
-    private triggerHapticFeedback(device: THREE.Group | XRHandWithHaptics, intensity: number, duration: number): void {
-        if (!this.settings.ar.enableHaptics) return;
-
-        if ('hapticActuators' in device) {
-            device.hapticActuators.forEach(actuator => {
-                actuator.pulse(intensity, duration);
-            });
-        } else if (device.userData.hapticActuator) {
-            device.userData.hapticActuator.pulse(intensity, duration);
-        }
+    public update(): void {
+        if (!this.interactionEnabled) return;
+        this.flushPositionUpdates();
     }
 
     public dispose(): void {
-        this.controllers = [];
-        this.hands = [];
+        // Clear subscriptions
+        this.settingsUnsubscribers.forEach(unsub => unsub());
+        this.settingsUnsubscribers = [];
+
+        // Flush any pending updates
+        this.flushPositionUpdates();
+
         XRInteraction.instance = null;
     }
 }
diff --git a/client/xr/xrSessionManager.ts b/client/xr/xrSessionManager.ts
index e234201e..b9c75028 100644
--- a/client/xr/xrSessionManager.ts
+++ b/client/xr/xrSessionManager.ts
@@ -2,7 +2,19 @@
  * XR session management and rendering
  */
 
-import * as THREE from 'three';
+import {
+    Group,
+    GridHelper,
+    PlaneGeometry,
+    MeshPhongMaterial,
+    Mesh,
+    RingGeometry,
+    MeshBasicMaterial,
+    DirectionalLight,
+    SphereGeometry,
+    Color,
+    DoubleSide
+} from 'three';
 import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory';
 import { createLogger } from '../core/utils';
 import { platformManager } from '../platform/platformManager';
@@ -21,478 +33,451 @@ function hasHitTest(session: XRSession): session is XRSession & { requestHitTest
 }
 
 export class XRSessionManager {
-  private static instance: XRSessionManager;
-  private sceneManager: SceneManager;
-  private session: XRSession | null = null;
-  private referenceSpace: XRReferenceSpace | null = null;
-  private isPresenting: boolean = false;
-
-  // XR specific objects
-  private cameraRig: THREE.Group;
-  private arGroup: THREE.Group; // New group for AR elements
-  private controllers: THREE.Group[];
-  private controllerGrips: THREE.Group[];
-  private controllerModelFactory: XRControllerModelFactory;
-
-  // AR specific objects
-  private gridHelper: THREE.GridHelper;
-  private groundPlane: THREE.Mesh;
-  private hitTestMarker: THREE.Mesh;
-  private arLight: THREE.DirectionalLight;
-  private hitTestSource: XRHitTestSource | null = null;
-  private hitTestSourceRequested = false;
-
-  // Event handlers
-  private xrSessionStartCallback: (() => void) | null = null;
-  private xrSessionEndCallback: (() => void) | null = null;
-  private xrAnimationFrameCallback: ((frame: XRFrame) => void) | null = null;
-  private controllerAddedCallback: ((controller: THREE.Group) => void) | null = null;
-  private controllerRemovedCallback: ((controller: THREE.Group) => void) | null = null;
-
-  private constructor(sceneManager: SceneManager) {
-    this.sceneManager = sceneManager;
-    
-    // Initialize XR objects
-    this.cameraRig = new THREE.Group();
-    this.arGroup = new THREE.Group(); // Initialize AR group
-    this.controllers = [new THREE.Group(), new THREE.Group()];
-    this.controllerGrips = [new THREE.Group(), new THREE.Group()];
-    this.controllerModelFactory = new XRControllerModelFactory();
-
-    // Initialize AR objects
-    this.gridHelper = this.createGridHelper();
-    this.groundPlane = this.createGroundPlane();
-    this.hitTestMarker = this.createHitTestMarker();
-    this.arLight = this.createARLight();
-
-    this.setupXRObjects();
-  }
-
-  static getInstance(sceneManager: SceneManager): XRSessionManager {
-    if (!XRSessionManager.instance) {
-      XRSessionManager.instance = new XRSessionManager(sceneManager);
+    private static instance: XRSessionManager;
+    private sceneManager: SceneManager;
+    private session: XRSession | null = null;
+    private referenceSpace: XRReferenceSpace | null = null;
+    private isPresenting: boolean = false;
+
+    // XR specific objects
+    private cameraRig: Group;
+    private arGroup: Group; // New group for AR elements
+    private controllers: Group[];
+    private controllerGrips: Group[];
+    private controllerModelFactory: XRControllerModelFactory;
+
+    // AR specific objects
+    private gridHelper: GridHelper;
+    private groundPlane: Mesh;
+    private hitTestMarker: Mesh;
+    private arLight: DirectionalLight;
+    private hitTestSource: XRHitTestSource | null = null;
+    private hitTestSourceRequested = false;
+
+    // Event handlers
+    private xrSessionStartCallback: (() => void) | null = null;
+    private xrSessionEndCallback: (() => void) | null = null;
+    private xrAnimationFrameCallback: ((frame: XRFrame) => void) | null = null;
+    private controllerAddedCallback: ((controller: Group) => void) | null = null;
+    private controllerRemovedCallback: ((controller: Group) => void) | null = null;
+
+    constructor(sceneManager: SceneManager) {
+        this.sceneManager = sceneManager;
+        
+        // Initialize XR objects
+        this.cameraRig = new Group();
+        this.arGroup = new Group(); // Initialize AR group
+        this.controllers = [new Group(), new Group()];
+        this.controllerGrips = [new Group(), new Group()];
+        this.controllerModelFactory = new XRControllerModelFactory();
+
+        // Initialize AR objects
+        this.gridHelper = this.createGridHelper();
+        this.groundPlane = this.createGroundPlane();
+        this.hitTestMarker = this.createHitTestMarker();
+        this.arLight = this.createARLight();
+
+        this.setupXRObjects();
     }
-    return XRSessionManager.instance;
-  }
-
-  private createGridHelper(): THREE.GridHelper {
-    const grid = new THREE.GridHelper(10, 10, 0x808080, 0x808080);
-    grid.material.transparent = true;
-    grid.material.opacity = 0.5;
-    grid.position.y = -0.01; // Slightly below ground to avoid z-fighting
-    grid.visible = false; // Start hidden until AR session begins
-    grid.layers.set(1); // Set to AR layer
-    return grid;
-  }
-
-  private createGroundPlane(): THREE.Mesh {
-    const geometry = new THREE.PlaneGeometry(10, 10);
-    const material = new THREE.MeshPhongMaterial({
-      color: 0x999999,
-      transparent: true,
-      opacity: 0.3,
-      side: THREE.DoubleSide
-    });
-    const plane = new THREE.Mesh(geometry, material);
-    plane.rotateX(-Math.PI / 2);
-    plane.position.y = -0.02; // Below grid
-    plane.visible = false; // Start hidden until AR session begins
-    plane.layers.set(1); // Set to AR layer
-    return plane;
-  }
-
-  private createHitTestMarker(): THREE.Mesh {
-    const geometry = new THREE.RingGeometry(0.15, 0.2, 32);
-    const material = new THREE.MeshBasicMaterial({
-      color: 0xffffff,
-      transparent: true,
-      opacity: 0.8,
-      side: THREE.DoubleSide
-    });
-    const marker = new THREE.Mesh(geometry, material);
-    marker.rotateX(-Math.PI / 2);
-    marker.visible = false;
-    marker.layers.set(1); // Set to AR layer
-    return marker;
-  }
-
-  private createARLight(): THREE.DirectionalLight {
-    const light = new THREE.DirectionalLight(0xffffff, 1);
-    light.position.set(1, 1, 1);
-    light.layers.set(1); // Set to AR layer
-    return light;
-  }
-
-  private setupXRObjects(): void {
-    const scene = this.sceneManager.getScene();
-    
-    // Add camera rig to scene
-    scene.add(this.cameraRig);
-
-    // Add AR group to camera rig
-    this.cameraRig.add(this.arGroup);
-
-    // Add AR objects to AR group
-    this.arGroup.add(this.gridHelper);
-    this.arGroup.add(this.groundPlane);
-    this.arGroup.add(this.hitTestMarker);
-    this.arGroup.add(this.arLight);
-
-    // Setup controllers
-    this.controllers.forEach((_controller, index) => {
-      this.setupController(index);
-    });
-
-    // Setup controller grips
-    this.controllerGrips.forEach(grip => {
-      this.setupControllerGrip(grip);
-    });
-  }
-
-  private setupController(index: number): void {
-    const controller = this.controllers[index];
-    const controllerGrip = this.controllerGrips[index];
-
-    controller.addEventListener('connected', (event: any) => {
-      const controllerModel = this.buildController(event.data);
-      controller.add(controllerModel);
-      this.notifyControllerAdded(controller);
-    });
-
-    controller.addEventListener('disconnected', () => {
-      controller.remove(...controller.children);
-      this.notifyControllerRemoved(controller);
-    });
-
-    this.cameraRig.add(controller);
-    this.cameraRig.add(controllerGrip);
-  }
-
-  private setupControllerGrip(grip: THREE.Group): void {
-    const controllerModel = this.controllerModelFactory.createControllerModel(grip);
-    grip.add(controllerModel);
-  }
-
-  private buildController(_inputSource: XRInputSource): THREE.Group {
-    const controller = new THREE.Group();
-    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
-    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
-    const sphere = new THREE.Mesh(geometry, material);
-    controller.add(sphere);
-    return controller;
-  }
-
-  /**
-   * Initialize XR session
-   */
-  async initXRSession(): Promise<void> {
-    if (this.isPresenting) {
-      _logger.warn('XR session already active');
-      return;
+
+    static getInstance(sceneManager: SceneManager): XRSessionManager {
+        if (!XRSessionManager.instance) {
+            XRSessionManager.instance = new XRSessionManager(sceneManager);
+        }
+        return XRSessionManager.instance;
+    }
+
+    private createGridHelper(): GridHelper {
+        const grid = new GridHelper(10, 10, 0x808080, 0x808080);
+        grid.material.transparent = true;
+        grid.material.opacity = 0.5;
+        grid.position.y = -0.01; // Slightly below ground to avoid z-fighting
+        grid.visible = false; // Start hidden until AR session begins
+        grid.layers.set(1); // Set to AR layer
+        return grid;
+    }
+
+    private createGroundPlane(): Mesh {
+        const geometry = new PlaneGeometry(10, 10);
+        const material = new MeshPhongMaterial({
+            color: 0x999999,
+            transparent: true,
+            opacity: 0.3,
+            side: DoubleSide
+        });
+        const plane = new Mesh(geometry, material);
+        plane.rotateX(-Math.PI / 2);
+        plane.position.y = -0.02; // Below grid
+        plane.visible = false; // Start hidden until AR session begins
+        plane.layers.set(1); // Set to AR layer
+        return plane;
     }
 
-    if (!platformManager.getCapabilities().xrSupported || !navigator.xr) {
-      throw new Error('XR not supported on this platform');
+    private createHitTestMarker(): Mesh {
+        const geometry = new RingGeometry(0.15, 0.2, 32);
+        const material = new MeshBasicMaterial({
+            color: 0xffffff,
+            transparent: true,
+            opacity: 0.8,
+            side: DoubleSide
+        });
+        const marker = new Mesh(geometry, material);
+        marker.rotateX(-Math.PI / 2);
+        marker.visible = false;
+        marker.layers.set(1); // Set to AR layer
+        return marker;
     }
 
-    try {
-      const session = await navigator.xr.requestSession('immersive-ar', {
-        requiredFeatures: ['local-floor', 'hit-test'],
-        optionalFeatures: ['hand-tracking', 'layers', 'light-estimation']
-      });
-
-      if (!session) {
-        throw new Error('Failed to create XR session');
-      }
-
-      this.session = session;
-
-      // Setup XR rendering
-      const renderer = this.sceneManager.getRenderer();
-      await renderer.xr.setSession(this.session);
-      
-      // Configure renderer for AR
-      renderer.xr.enabled = true;
-      
-      // Clear background for AR passthrough
-      const scene = this.sceneManager.getScene();
-      scene.background = null;
-      
-      // Get reference space
-      this.referenceSpace = await this.session.requestReferenceSpace('local-floor');
-      
-      // Setup session event handlers
-      this.session.addEventListener('end', this.onXRSessionEnd);
-
-      // Enable AR layer for camera
-      const camera = this.sceneManager.getCamera();
-      camera.layers.enable(1);
-
-      // Reset camera rig position
-      this.cameraRig.position.set(0, 0, 0);
-      this.cameraRig.quaternion.identity();
-
-      // Show AR visualization elements after a short delay to ensure proper placement
-      setTimeout(() => {
-        this.gridHelper.visible = true;
-        this.groundPlane.visible = true;
-        this.arLight.visible = true;
-      }, 1000);
-      
-      this.isPresenting = true;
-      _logger.log('XR session initialized');
-
-      // Notify session start
-      if (this.xrSessionStartCallback) {
-        this.xrSessionStartCallback();
-      }
-    } catch (error) {
-      _logger.error('Failed to initialize XR session:', error);
-      throw error;
+    private createARLight(): DirectionalLight {
+        const light = new DirectionalLight(0xffffff, 1);
+        light.position.set(1, 1, 1);
+        light.layers.set(1); // Set to AR layer
+        return light;
     }
-  }
-
-  /**
-   * End XR session
-   */
-  async endXRSession(): Promise<void> {
-    if (this.session) {
-      await this.session.end();
+
+    private setupXRObjects(): void {
+        const scene = this.sceneManager.getScene();
+        
+        // Add camera rig to scene
+        scene.add(this.cameraRig);
+
+        // Add AR group to camera rig
+        this.cameraRig.add(this.arGroup);
+
+        // Add AR objects to AR group
+        this.arGroup.add(this.gridHelper);
+        this.arGroup.add(this.groundPlane);
+        this.arGroup.add(this.hitTestMarker);
+        this.arGroup.add(this.arLight);
+
+        // Setup controllers
+        this.controllers.forEach((_controller, index) => {
+            this.setupController(index);
+        });
+
+        // Setup controller grips
+        this.controllerGrips.forEach(grip => {
+            this.setupControllerGrip(grip);
+        });
+    }
+
+    private setupController(index: number): void {
+        const controller = this.controllers[index];
+        const controllerGrip = this.controllerGrips[index];
+
+        controller.addEventListener('connected', (event: any) => {
+            const controllerModel = this.buildController(event.data);
+            controller.add(controllerModel);
+            this.notifyControllerAdded(controller);
+        });
+
+        controller.addEventListener('disconnected', () => {
+            controller.remove(...controller.children);
+            this.notifyControllerRemoved(controller);
+        });
+
+        this.cameraRig.add(controller);
+        this.cameraRig.add(controllerGrip);
     }
-  }
 
-  private onXRSessionEnd = (): void => {
-    if (this.hitTestSource) {
-      this.hitTestSource.cancel();
-      this.hitTestSource = null;
+    private setupControllerGrip(grip: Group): void {
+        const controllerModel = this.controllerModelFactory.createControllerModel(grip);
+        grip.add(controllerModel);
     }
-    
-    this.session = null;
-    this.referenceSpace = null;
-    this.hitTestSourceRequested = false;
-    this.isPresenting = false;
-
-    // Hide AR visualization elements
-    this.gridHelper.visible = false;
-    this.groundPlane.visible = false;
-    this.hitTestMarker.visible = false;
-    this.arLight.visible = false;
-
-    // Reset camera rig
-    this.cameraRig.position.set(0, 0, 0);
-    this.cameraRig.quaternion.identity();
-
-    // Reset scene background
-    const scene = this.sceneManager.getScene();
-    scene.background = new THREE.Color(BACKGROUND_COLOR);
-
-    // Disable AR layer for camera
-    const camera = this.sceneManager.getCamera();
-    camera.layers.disable(1);
-
-    // Reset renderer settings
-    const renderer = this.sceneManager.getRenderer();
-    renderer.xr.enabled = false;
-
-    _logger.log('XR session ended');
-
-    // Notify session end
-    if (this.xrSessionEndCallback) {
-      this.xrSessionEndCallback();
+
+    private buildController(_inputSource: XRInputSource): Group {
+        const controller = new Group();
+        const geometry = new SphereGeometry(0.1, 16, 16);
+        const material = new MeshBasicMaterial({ color: 0xffffff });
+        const sphere = new Mesh(geometry, material);
+        controller.add(sphere);
+        return controller;
     }
-  }
-
-  /**
-   * XR animation frame
-   */
-  onXRFrame(frame: XRFrame): void {
-    if (!this.session || !this.referenceSpace) return;
-
-    // Get pose
-    const pose = frame.getViewerPose(this.referenceSpace);
-    if (!pose) return;
-
-    // Let Three.js handle camera updates through WebXRManager
-    // Handle hit testing
-    this.handleHitTest(frame);
-
-    // Update controller poses
-    this.controllers.forEach((controller) => {
-      const inputSource = controller.userData.inputSource as XRInputSource;
-      if (inputSource) {
-        const targetRayPose = frame.getPose(inputSource.targetRaySpace, this.referenceSpace!);
-        if (targetRayPose) {
-          controller.matrix.fromArray(targetRayPose.transform.matrix);
-          controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
+
+    async initXRSession(): Promise<void> {
+        if (this.isPresenting) {
+            _logger.warn('XR session already active');
+            return;
+        }
+
+        if (!platformManager.getCapabilities().xrSupported || !navigator.xr) {
+            throw new Error('XR not supported on this platform');
+        }
+
+        try {
+            const session = await navigator.xr.requestSession('immersive-ar', {
+                requiredFeatures: ['local-floor', 'hit-test'],
+                optionalFeatures: ['hand-tracking', 'layers', 'light-estimation']
+            });
+
+            if (!session) {
+                throw new Error('Failed to create XR session');
+            }
+
+            this.session = session;
+
+            // Setup XR rendering
+            const renderer = this.sceneManager.getRenderer();
+            await renderer.xr.setSession(this.session);
+            
+            // Configure renderer for AR
+            renderer.xr.enabled = true;
+            
+            // Clear background for AR passthrough
+            const scene = this.sceneManager.getScene();
+            scene.background = null;
+            
+            // Get reference space
+            this.referenceSpace = await this.session.requestReferenceSpace('local-floor');
+            
+            // Setup session event handlers
+            this.session.addEventListener('end', this.onXRSessionEnd);
+
+            // Enable AR layer for camera
+            const camera = this.sceneManager.getCamera();
+            camera.layers.enable(1);
+
+            // Reset camera rig position
+            this.cameraRig.position.set(0, 0, 0);
+            this.cameraRig.quaternion.identity();
+
+            // Show AR visualization elements after a short delay to ensure proper placement
+            setTimeout(() => {
+                this.gridHelper.visible = true;
+                this.groundPlane.visible = true;
+                this.arLight.visible = true;
+            }, 1000);
+            
+            this.isPresenting = true;
+            _logger.log('XR session initialized');
+
+            // Notify session start
+            if (this.xrSessionStartCallback) {
+                this.xrSessionStartCallback();
+            }
+        } catch (error) {
+            _logger.error('Failed to initialize XR session:', error);
+            throw error;
         }
-      }
-    });
-
-    // Update lighting if available
-    if (hasLightEstimate(frame)) {
-      const lightEstimate = frame.getLightEstimate();
-      if (lightEstimate) {
-        this.updateARLighting(lightEstimate);
-      }
     }
 
-    // Call animation frame callback
-    if (this.xrAnimationFrameCallback) {
-      this.xrAnimationFrameCallback(frame);
+    async endXRSession(): Promise<void> {
+        if (this.session) {
+            await this.session.end();
+        }
     }
-  }
-
-  private async handleHitTest(frame: XRFrame): Promise<void> {
-    if (!this.hitTestSourceRequested && this.session && hasHitTest(this.session)) {
-      try {
-        const viewerSpace = await this.session.requestReferenceSpace('viewer');
-        if (!viewerSpace) {
-          throw new Error('Failed to get viewer reference space');
+
+    private onXRSessionEnd = (): void => {
+        if (this.hitTestSource) {
+            this.hitTestSource.cancel();
+            this.hitTestSource = null;
         }
+        
+        this.session = null;
+        this.referenceSpace = null;
+        this.hitTestSourceRequested = false;
+        this.isPresenting = false;
+
+        // Hide AR visualization elements
+        this.gridHelper.visible = false;
+        this.groundPlane.visible = false;
+        this.hitTestMarker.visible = false;
+        this.arLight.visible = false;
+
+        // Reset camera rig
+        this.cameraRig.position.set(0, 0, 0);
+        this.cameraRig.quaternion.identity();
+
+        // Reset scene background
+        const scene = this.sceneManager.getScene();
+        scene.background = new Color(BACKGROUND_COLOR);
+
+        // Disable AR layer for camera
+        const camera = this.sceneManager.getCamera();
+        camera.layers.disable(1);
 
-        const hitTestSource = await this.session.requestHitTestSource({
-          space: viewerSpace
+        // Reset renderer settings
+        const renderer = this.sceneManager.getRenderer();
+        renderer.xr.enabled = false;
+
+        _logger.log('XR session ended');
+
+        // Notify session end
+        if (this.xrSessionEndCallback) {
+            this.xrSessionEndCallback();
+        }
+    }
+
+    onXRFrame(frame: XRFrame): void {
+        if (!this.session || !this.referenceSpace) return;
+
+        // Get pose
+        const pose = frame.getViewerPose(this.referenceSpace);
+        if (!pose) return;
+
+        // Let Three.js handle camera updates through WebXRManager
+        // Handle hit testing
+        this.handleHitTest(frame);
+
+        // Update controller poses
+        this.controllers.forEach((controller) => {
+            const inputSource = controller.userData.inputSource as XRInputSource;
+            if (inputSource) {
+                const targetRayPose = frame.getPose(inputSource.targetRaySpace, this.referenceSpace!);
+                if (targetRayPose) {
+                    controller.matrix.fromArray(targetRayPose.transform.matrix);
+                    controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
+                }
+            }
         });
 
-        if (hitTestSource) {
-          this.hitTestSource = hitTestSource;
-          this.hitTestSourceRequested = true;
+        // Update lighting if available
+        if (hasLightEstimate(frame)) {
+            const lightEstimate = frame.getLightEstimate();
+            if (lightEstimate) {
+                this.updateARLighting(lightEstimate);
+            }
+        }
+
+        // Call animation frame callback
+        if (this.xrAnimationFrameCallback) {
+            this.xrAnimationFrameCallback(frame);
         }
-      } catch (error) {
-        _logger.error('Failed to initialize hit test source:', error);
-        this.hitTestSourceRequested = true; // Prevent further attempts
-      }
     }
 
-    if (this.hitTestSource && this.referenceSpace) {
-      const hitTestResults = frame.getHitTestResults(this.hitTestSource);
-      if (hitTestResults.length > 0) {
-        const hit = hitTestResults[0];
-        const pose = hit.getPose(this.referenceSpace);
-        if (pose) {
-          this.hitTestMarker.visible = true;
-          this.hitTestMarker.position.set(
-            pose.transform.position.x,
-            pose.transform.position.y,
-            pose.transform.position.z
-          );
-
-          // Update grid and ground plane position to match hit test
-          this.gridHelper.position.y = pose.transform.position.y;
-          this.groundPlane.position.y = pose.transform.position.y - 0.01;
+    private async handleHitTest(frame: XRFrame): Promise<void> {
+        if (!this.hitTestSourceRequested && this.session && hasHitTest(this.session)) {
+            try {
+                const viewerSpace = await this.session.requestReferenceSpace('viewer');
+                if (!viewerSpace) {
+                    throw new Error('Failed to get viewer reference space');
+                }
+
+                const hitTestSource = await this.session.requestHitTestSource({
+                    space: viewerSpace
+                });
+
+                if (hitTestSource) {
+                    this.hitTestSource = hitTestSource;
+                    this.hitTestSourceRequested = true;
+                }
+            } catch (error) {
+                _logger.error('Failed to initialize hit test source:', error);
+                this.hitTestSourceRequested = true; // Prevent further attempts
+            }
+        }
+
+        if (this.hitTestSource && this.referenceSpace) {
+            const hitTestResults = frame.getHitTestResults(this.hitTestSource);
+            if (hitTestResults.length > 0) {
+                const hit = hitTestResults[0];
+                const pose = hit.getPose(this.referenceSpace);
+                if (pose) {
+                    this.hitTestMarker.visible = true;
+                    this.hitTestMarker.position.set(
+                        pose.transform.position.x,
+                        pose.transform.position.y,
+                        pose.transform.position.z
+                    );
+
+                    // Update grid and ground plane position to match hit test
+                    this.gridHelper.position.y = pose.transform.position.y;
+                    this.groundPlane.position.y = pose.transform.position.y - 0.01;
+                }
+            } else {
+                this.hitTestMarker.visible = false;
+            }
         }
-      } else {
-        this.hitTestMarker.visible = false;
-      }
     }
-  }
-
-  private updateARLighting(lightEstimate: XRLightEstimate): void {
-    const intensity = lightEstimate.primaryLightIntensity?.value || 1;
-    const direction = lightEstimate.primaryLightDirection;
-    
-    if (direction) {
-      this.arLight.position.set(direction.x, direction.y, direction.z);
+
+    private updateARLighting(lightEstimate: XRLightEstimate): void {
+        const intensity = lightEstimate.primaryLightIntensity?.value || 1;
+        const direction = lightEstimate.primaryLightDirection;
+        
+        if (direction) {
+            this.arLight.position.set(direction.x, direction.y, direction.z);
+        }
+        this.arLight.intensity = intensity;
+    }
+
+    setSessionCallbacks(
+        onStart: () => void,
+        onEnd: () => void,
+        onFrame: (frame: XRFrame) => void
+    ): void {
+        this.xrSessionStartCallback = onStart;
+        this.xrSessionEndCallback = onEnd;
+        this.xrAnimationFrameCallback = onFrame;
     }
-    this.arLight.intensity = intensity;
-  }
-
-  /**
-   * Set session event callbacks
-   */
-  setSessionCallbacks(
-    onStart: () => void,
-    onEnd: () => void,
-    onFrame: (frame: XRFrame) => void
-  ): void {
-    this.xrSessionStartCallback = onStart;
-    this.xrSessionEndCallback = onEnd;
-    this.xrAnimationFrameCallback = onFrame;
-  }
-
-  public onControllerAdded(callback: (controller: THREE.Group) => void): void {
-    this.controllerAddedCallback = callback;
-  }
-
-  public onControllerRemoved(callback: (controller: THREE.Group) => void): void {
-    this.controllerRemovedCallback = callback;
-  }
-
-  private notifyControllerAdded(controller: THREE.Group): void {
-    this.controllerAddedCallback?.(controller);
-  }
-
-  private notifyControllerRemoved(controller: THREE.Group): void {
-    this.controllerRemovedCallback?.(controller);
-  }
-
-  /**
-   * Get XR objects
-   */
-  getCameraRig(): THREE.Group {
-    return this.cameraRig;
-  }
-
-  getControllers(): THREE.Group[] {
-    return this.controllers;
-  }
-
-  getControllerGrips(): THREE.Group[] {
-    return this.controllerGrips;
-  }
-
-  /**
-   * Check if currently in XR session
-   */
-  isXRPresenting(): boolean {
-    return this.isPresenting;
-  }
-
-  /**
-   * Get current XR session
-   */
-  getSession(): XRSession | null {
-    return this.session;
-  }
-
-  /**
-   * Get reference space
-   */
-  getReferenceSpace(): XRReferenceSpace | null {
-    return this.referenceSpace;
-  }
-
-  /**
-   * Clean up resources
-   */
-  dispose(): void {
-    if (this.session) {
-      this.session.end().catch(console.error);
+
+    onControllerAdded(callback: (controller: Group) => void): void {
+        this.controllerAddedCallback = callback;
+    }
+
+    onControllerRemoved(callback: (controller: Group) => void): void {
+        this.controllerRemovedCallback = callback;
+    }
+
+    private notifyControllerAdded(controller: Group): void {
+        this.controllerAddedCallback?.(controller);
+    }
+
+    private notifyControllerRemoved(controller: Group): void {
+        this.controllerRemovedCallback?.(controller);
+    }
+
+    getCameraRig(): Group {
+        return this.cameraRig;
     }
 
-    this.controllers.forEach(controller => {
-      controller.removeEventListener('connected', (event: any) => {
-        const controllerModel = this.buildController(event.data);
-        controller.add(controllerModel);
-        this.notifyControllerAdded(controller);
-      });
-
-      controller.removeEventListener('disconnected', () => {
-        controller.remove(...controller.children);
-        this.notifyControllerRemoved(controller);
-      });
-    });
-
-    this.controllerGrips.forEach(grip => {
-      grip.remove(...grip.children);
-    });
-
-    this.hitTestSource?.cancel();
-    this.hitTestSource = null;
-    this.hitTestSourceRequested = false;
-
-    this.session = null;
-    this.referenceSpace = null;
-    this.isPresenting = false;
-  }
+    getControllers(): Group[] {
+        return this.controllers;
+    }
+
+    getControllerGrips(): Group[] {
+        return this.controllerGrips;
+    }
+
+    isXRPresenting(): boolean {
+        return this.isPresenting;
+    }
+
+    getSession(): XRSession | null {
+        return this.session;
+    }
+
+    getReferenceSpace(): XRReferenceSpace | null {
+        return this.referenceSpace;
+    }
+
+    dispose(): void {
+        if (this.session) {
+            this.session.end().catch(console.error);
+        }
+
+        this.controllers.forEach(controller => {
+            controller.removeEventListener('connected', (event: any) => {
+                const controllerModel = this.buildController(event.data);
+                controller.add(controllerModel);
+                this.notifyControllerAdded(controller);
+            });
+
+            controller.removeEventListener('disconnected', () => {
+                controller.remove(...controller.children);
+                this.notifyControllerRemoved(controller);
+            });
+        });
+
+        this.controllerGrips.forEach(grip => {
+            grip.remove(...grip.children);
+        });
+
+        this.hitTestSource?.cancel();
+        this.hitTestSource = null;
+        this.hitTestSourceRequested = false;
+
+        this.session = null;
+        this.referenceSpace = null;
+        this.isPresenting = false;
+    }
 }
diff --git a/client/xr/xrTypes.ts b/client/xr/xrTypes.ts
deleted file mode 100644
index 556eb0af..00000000
--- a/client/xr/xrTypes.ts
+++ /dev/null
@@ -1,25 +0,0 @@
-import * as THREE from 'three';
-
-export interface XRHandWithHaptics {
-    hand: {
-        joints: {
-            [key: string]: THREE.Object3D;
-        };
-    };
-    hapticActuators: any[];
-    pinchStrength: number;
-    gripStrength: number;
-}
-
-export interface XRControllerState {
-    position: THREE.Vector3;
-    rotation: THREE.Quaternion;
-    hapticActuator?: any;
-}
-
-export interface XRHandState {
-    position: THREE.Vector3;
-    joints: Map<string, THREE.Object3D>;
-    pinchStrength: number;
-    gripStrength: number;
-}
diff --git a/config.yml b/config.yml
index 075b76f3..d02cd396 100644
--- a/config.yml
+++ b/config.yml
@@ -10,6 +10,11 @@ ingress:
       keepAliveTimeout: 2m
       keepAliveConnections: 100
       httpHostHeader: www.visionflow.info
+      # WebSocket settings
+      enableWebsocket: true
+      websocketCompression: true
+      websocketKeepAliveTimeout: 60s
+      websocketKeepAliveInterval: 30s
   - service: http_status:404
 
 # Connection settings
diff --git a/docker-compose.yml b/docker-compose.yml
index f325a58b..616575b9 100755
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,4 +1,4 @@
-name: logseq-xr
+x-name: logseq-xr
 
 services:
   webxr:
@@ -55,7 +55,7 @@ services:
         max-size: "1g"
         max-file: "5"
     healthcheck:
-      test: ["CMD-SHELL", "curl -f http://localhost:4000/ || exit 1; curl -f http://localhost:4000/wss || exit 1"]
+      test: ["CMD-SHELL", "curl -f http://localhost:4000/api/graph/data || exit 1"]
       interval: 10s
       timeout: 5s
       retries: 5
diff --git a/docs/network.md b/docs/network.md
index 46079c68..822f6885 100644
--- a/docs/network.md
+++ b/docs/network.md
@@ -1,5 +1,5 @@
 LogseqXR Networking and Data Flow Briefing
-This document outlines the networking architecture and data flow for the LogseqXR application, clarifying the roles of REST, WebSockets, and RAGFlow integration.
+This document outlines the networking architecture and data flow for the LogseqXR application, clarifying the roles of REST, WebSockets.
 
 1. Overall Architecture
 
@@ -7,170 +7,102 @@ The application follows a client-server model, with the server responsible for d
 
 2. Server-Side (Rust)
 
-Data Storage: Graph data (nodes, edges, metadata) is stored on the server, in a file system. Settings are stored in settings.toml and are updated in real-time in groups of settings only when those settings are updated.
+Data Storage: Graph data (nodes, edges, metadata) is stored on the server, in a file system. Settings are stored in settings.toml and are updated in real-time in groups of settings only when those settings are updated. Settings can also be overridden by environment variables.
 
 REST API (actix-web): The server exposes a REST API for:
 
-Graph Data: /api/graph/data (full graph) and /api/graph/data/paginated (paginated graph).
-
-Settings: 
-- GET /api/visualization/settings/{category} (get all settings for a category)
-- GET /api/visualization/settings/{category}/{setting} (get individual setting)
-- PUT /api/visualization/settings/{category}/{setting} (update individual setting)
-
-Other API endpoints: /api/files/fetch, /api/chat/*, /api/perplexity.
+Graph Data: 
+- GET /api/graph/data (full graph)
+- GET /api/graph/paginated?page={page}&pageSize={pageSize} (paginated graph)
+- POST /api/graph/update (update graph data)
+
+Settings: (Temporarily Disabled)
+The following settings endpoints are currently disabled as settings are managed locally on the client:
+- GET /api/settings (get all settings)
+- GET /api/settings/{category} (get all settings for a category)
+- GET /api/settings/{category}/{setting} (get individual setting)
+- PUT /api/settings/{category}/{setting} (update individual setting)
+
+Note: Settings are currently managed locally in the client's SettingsStore using default values. Server synchronization will be re-enabled in a future update.
+
+Categories include:
+- system.network
+- system.websocket
+- system.security
+- system.debug
+- visualization.animations
+- visualization.ar
+- visualization.audio
+- visualization.bloom
+- visualization.edges
+- visualization.hologram
+- visualization.labels
+- visualization.nodes
+- visualization.physics
+- visualization.rendering
+
+Other API endpoints: 
+- /api/files/fetch: Fetch file contents from the repository
+- /api/chat/*: AI chat endpoints for RAGFlow integration
+- /api/perplexity: Perplexity AI integration endpoints
 
 WebSocket Handling (actix-web-actors): 
 - Binary Protocol (/wss endpoint): 
   - Uses a binary protocol for efficient real-time position and velocity updates
   - Optimized format with 6 floats per node (position + velocity)
-- WebSocket Control API (/api/visualization/settings/):
-  - REST-based control plane for WebSocket configuration
-  - Manages settings, heartbeat intervals
-  - Allows runtime updates to WebSocket behavior without connection disruption
-  - Separates control logic from high-frequency data updates
-- Connection Management:
-  - Message queuing with configurable queue size
-  - Configurable update rate (framerate)
-  - Robust reconnection logic with configurable attempts and delays
-  - Connection status tracking and notifications
-- Heartbeat:
-  - Configurable ping/pong intervals
-  - Timestamp-based health monitoring
-  - Automatic reconnection on timeout
-- Error Handling:
-  - Comprehensive error types and status codes
-  - Detailed error reporting and logging
-  - Graceful failure recovery
-
-RAGFlow Integration:
-- Network Integration: Joins the RAGFlow Docker network (docker_ragflow)
-- Service Discovery: Uses Docker network aliases for service communication
-- Optional Connectivity: Gracefully handles RAGFlow availability
-- Health Checks: Monitors RAGFlow service health without direct dependencies
-
-Security:
-- Handled by cloudflared tunnel and docker
-
-Port Configuration:
-- Nginx Frontend: Listens on port 4000 for external connections
-- Rust Backend: Runs on port 3001 internally (configurable via PORT env var)
-- Nginx Proxy Configuration:
-  - WebSocket Binary Protocol (/wss):
-    - Disabled buffering and caching for real-time communication
-    - Extended timeouts: 3600s read/send, 75s connect
-    - Proper connection upgrade handling
-    - Optimized for binary data streaming
-  - WebSocket Control API (/api/visualization/settings):
-    - Standard API timeouts: 60s read/send/connect
-    - Enabled buffering for REST responses
-    - Handles WebSocket configuration updates
-  - API Endpoints (/api):
-    - Enabled buffering with 128k buffer size
-    - 60s timeouts for read/send/connect
-    - Enhanced proxy buffers (4 x 256k)
-  - Graph Endpoints (/graph):
-    - 30s connect timeout matching heartbeat interval
-    - No-store cache control
-- Health Checks: 
-  - Regular HTTP and WebSocket endpoint monitoring
-  - 10-second interval checks with 5-second timeout
-  - 5 retries with 10-second start period
-
-3. Client-Side (TypeScript)
-
-Initialization:
-- The client loads initial graph data from /api/graph/data/paginated using pagination
-- The client loads all visualization settings from /api/visualization/settings/{category}
-- WebSocket initialization follows a two-step process:
-  1. Control Setup (/api/visualization/settings/websocket):
-     - Load WebSocket configuration settings
-     - Set up error handling and reconnection policies
-  2. Binary Connection (/wss):
-     - Establish WebSocket connection for real-time updates
-     - Use binary protocol for position/velocity data
-     - Handle heartbeat and connection lifecycle
-
-REST API Interaction:
+  - Supports compression for large graph updates
+  - Includes heartbeat mechanism for connection health monitoring
+
+3. Client-Side (TypeScript/Three.js)
+
+The client maintains several key connections:
+
+REST API Communication:
 - Initial Graph Data: Retrieving the initial graph data using pagination
 - Settings: Loading category settings, getting/updating individual settings
-
-WebSocket Connection and it's REST management system: 
-- Establishes compressed WebSocket connection for real-time updates
-- Implements reconnection logic with configurable attempts (default: 3)
-- Configurable settings for:
-  - Heartbeat interval (default: 15s)
-  - Heartbeat timeout (default: 60s)
-  - Reconnect delay (default: 5s)
-- Message queuing with size limits
-- Binary message handling with version verification
-- Comprehensive error handling and status notifications
-
-4. Docker Networking
-
-The application uses Docker networking for service communication:
-
-RAGFlow Integration:
-```yaml
-networks:
-  ragflow:
-    external: true
-    name: docker_ragflow  # RAGFlow's network from docker network ls
-```
-
-Service Configuration:
-```yaml
-services:
-  webxr:
-    networks:
-      ragflow:
-        aliases:
-          - logseq-xr-webxr
-          - webxr-client
-    deploy:
-      resources:
-        limits:
-          cpus: '16.0'
-          memory: 64G
-        reservations:
-          devices:
-            - driver: nvidia
-              device_ids: ['0']
-              capabilities: [gpu]
-```
-
-Cloudflare Tunnel:
-The application uses Cloudflare's tunnel service for secure external access:
-- Runs as a separate container (cloudflared-tunnel)
-- Environment Configuration:
-  - TUNNEL_METRICS: Exposed on 0.0.0.0:2000
-  - TUNNEL_DNS_UPSTREAM: Uses 1.1.1.1 and 1.0.0.1
-  - TUNNEL_TRANSPORT_PROTOCOL: Uses HTTP/2
-  - TUNNEL_WEBSOCKET_ENABLE: Enabled for WebSocket support
-  - TUNNEL_WEBSOCKET_HEARTBEAT_INTERVAL: 30s
-  - TUNNEL_WEBSOCKET_TIMEOUT: 3600s
-  - TUNNEL_RETRIES: 5 attempts
-  - TUNNEL_GRACE_PERIOD: 30s
-- Provides secure tunneling without exposing ports directly
-- Configuration managed through config.yml with ingress rules
-
-Health Check System:
-- Container Health: Docker healthcheck monitors service availability
-- Backend Health: Rust service monitors internal state and dependencies
-- Frontend Health: Nginx monitors backend connectivity
-- RAGFlow Health: Periodic checks for RAGFlow service availability
-- Metrics: Health status exposed through container metrics
-
-Clear Protocol Definition:
-Binary format details (24 bytes per node)
-Exact message types (binary updates, ping/pong)
-Simplified Configuration:
-Clear separation between REST and WebSocket responsibilities
-Performance Focus:
-Direct binary transmission
-No JSON overhead
-Efficient TypedArray usage
-Clear Client Flow:
-Step-by-step initialization process
-Explicit data flow patterns
-Error handling and performance considerations
\ No newline at end of file
+- File Content: Fetching markdown and other file contents as needed
+- AI Integration: Communicating with RAGFlow and Perplexity services
+
+WebSocket Connection:
+- Establishes WebSocket connection for real-time updates
+- Handles binary protocol for position/velocity updates
+- Implements reconnection logic with exponential backoff
+- Processes compressed data for large graph updates
+
+4. Development and Testing
+
+The application includes several scripts for testing network functionality:
+- `scripts/dev.sh`: Main development script with commands for:
+  - Starting/stopping containers
+  - Testing endpoints
+  - Viewing logs
+  - Rebuilding services
+- `scripts/test-api.sh`: Tests individual API endpoints
+- `scripts/test_all_endpoints.sh`: Comprehensive API endpoint testing
+
+5. Security Considerations
+
+- All WebSocket connections use WSS (WebSocket Secure)
+- API endpoints require proper authentication headers
+- Rate limiting is implemented on sensitive endpoints
+- Environment variables are used for sensitive configuration
+- CORS is properly configured for development and production
+
+6. Performance Optimizations
+
+Network optimizations include:
+- Binary protocol for WebSocket updates
+- Compression for large data transfers
+- Pagination for initial graph loading
+- Efficient settings updates (only changed values)
+- Connection pooling for database operations
+- Caching of frequently accessed data
+
+7. Error Handling
+
+The system implements robust error handling:
+- Automatic WebSocket reconnection
+- Graceful degradation on connection loss
+- Clear error messages for API failures
+- Logging of network-related issues
+- Recovery mechanisms for interrupted operations
\ No newline at end of file
diff --git a/nginx.conf b/nginx.conf
index 2a2ac9d8..31181a1a 100755
--- a/nginx.conf
+++ b/nginx.conf
@@ -70,10 +70,10 @@ http {
         add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline' 'unsafe-eval'; connect-src 'self' ws: wss: http: https: www.visionflow.info;" always;
         add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
 
-        # WebSocket endpoint
+        # WebSocket endpoints
         location /wss {
             # Use plain WS internally since Cloudflared handles SSL
-            proxy_pass http://backend;
+            proxy_pass http://backend/wss;  # Updated to match backend path
             proxy_http_version 1.1;
             proxy_set_header Upgrade $http_upgrade;
             proxy_set_header Connection $connection_upgrade;
@@ -90,9 +90,9 @@ http {
             proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
             
             # WebSocket specific settings
-            proxy_read_timeout 3600s;  # Match Cloudflared timeout
-            proxy_send_timeout 3600s;
-            proxy_connect_timeout 75s;
+            proxy_read_timeout 60s;     # Match MAX_CLIENT_TIMEOUT
+            proxy_send_timeout 60s;     # Match MAX_CLIENT_TIMEOUT
+            proxy_connect_timeout 30s;  # Match HEARTBEAT_INTERVAL
             proxy_buffering off;
             proxy_cache off;
             
@@ -101,7 +101,34 @@ http {
             error_log /var/log/nginx/websocket-error.log debug;
         }
 
-        # API endpoints
+        # Settings endpoints
+        location /api/settings {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $scheme;
+            
+            # Settings specific configuration
+            proxy_read_timeout 30s;
+            proxy_send_timeout 30s;
+            proxy_connect_timeout 10s;
+            proxy_buffering on;
+            proxy_buffer_size 64k;
+            proxy_buffers 4 128k;
+            proxy_busy_buffers_size 128k;
+            
+            # Cache control
+            add_header Cache-Control "no-store" always;
+            expires -1;
+            
+            # CORS headers for settings API
+            add_header 'Access-Control-Allow-Methods' 'GET, PUT, OPTIONS' always;
+            add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type' always;
+        }
+
+        # General API endpoints
         location /api {
             proxy_pass http://backend;
             proxy_http_version 1.1;
diff --git a/package.json b/package.json
index 1d57ab46..2b8e369c 100755
--- a/package.json
+++ b/package.json
@@ -16,14 +16,16 @@
     "@react-three/drei": "^9.120.4",
     "@react-three/fiber": "^8.17.10",
     "d3-force-3d": "^3.0.5",
+    "lodash": "^4.17.21",
     "pako": "^2.1.0",
-    "three": "0.170.0",
+    "three": "0.171.0",
     "troika-three-text": "^0.52.2"
   },
   "devDependencies": {
     "@types/d3-force": "^3.0.10",
+    "@types/lodash": "^4.17.13",
     "@types/node": "^22.10.0",
-    "@types/three": "0.170.0",
+    "@types/three": "0.171.0",
     "@typescript-eslint/eslint-plugin": "^8.16.0",
     "@typescript-eslint/parser": "^8.16.0",
     "eslint": "^8.57.0",
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 27b656ec..4d12aa91 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -10,32 +10,38 @@ importers:
     dependencies:
       '@react-three/drei':
         specifier: ^9.120.4
-        version: 9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(@types/react@19.0.1)(@types/three@0.170.0)(react@18.3.1)(three@0.170.0)(use-sync-external-store@1.2.2(react@18.3.1))
+        version: 9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(@types/react@19.0.1)(@types/three@0.171.0)(react@18.3.1)(three@0.171.0)(use-sync-external-store@1.2.2(react@18.3.1))
       '@react-three/fiber':
         specifier: ^8.17.10
-        version: 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)
+        version: 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)
       d3-force-3d:
         specifier: ^3.0.5
         version: 3.0.5
+      lodash:
+        specifier: ^4.17.21
+        version: 4.17.21
       pako:
         specifier: ^2.1.0
         version: 2.1.0
       three:
-        specifier: 0.170.0
-        version: 0.170.0
+        specifier: 0.171.0
+        version: 0.171.0
       troika-three-text:
         specifier: ^0.52.2
-        version: 0.52.2(three@0.170.0)
+        version: 0.52.2(three@0.171.0)
     devDependencies:
       '@types/d3-force':
         specifier: ^3.0.10
         version: 3.0.10
+      '@types/lodash':
+        specifier: ^4.17.13
+        version: 4.17.13
       '@types/node':
         specifier: ^22.10.0
         version: 22.10.2
       '@types/three':
-        specifier: 0.170.0
-        version: 0.170.0
+        specifier: 0.171.0
+        version: 0.171.0
       '@typescript-eslint/eslint-plugin':
         specifier: ^8.16.0
         version: 8.18.0(@typescript-eslint/parser@8.18.0(eslint@8.57.1)(typescript@5.4.5))(eslint@8.57.1)(typescript@5.4.5)
@@ -448,6 +454,9 @@ packages:
   '@types/estree@1.0.6':
     resolution: {integrity: sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==}
 
+  '@types/lodash@4.17.13':
+    resolution: {integrity: sha512-lfx+dftrEZcdBPczf9d0Qv0x+j/rfNCMuC6OcfXmO8gkfeNAY88PgKUbvG56whcN23gc27yenwF6oJZXGFpYxg==}
+
   '@types/node@22.10.2':
     resolution: {integrity: sha512-Xxr6BBRCAOQixvonOye19wnzyDiUtTeqldOOmj3CkeblonbccA12PFwlufvRdrpjXxqnmUaeiU5EOA+7s5diUQ==}
 
@@ -468,8 +477,8 @@ packages:
   '@types/stats.js@0.17.3':
     resolution: {integrity: sha512-pXNfAD3KHOdif9EQXZ9deK82HVNaXP5ZIF5RP2QG6OQFNTaY2YIetfrE9t528vEreGQvEPRDDc8muaoYeK0SxQ==}
 
-  '@types/three@0.170.0':
-    resolution: {integrity: sha512-CUm2uckq+zkCY7ZbFpviRttY+6f9fvwm6YqSqPfA5K22s9w7R4VnA3rzJse8kHVvuzLcTx+CjNCs2NYe0QFAyg==}
+  '@types/three@0.171.0':
+    resolution: {integrity: sha512-oLuT1SAsT+CUg/wxUTFHo0K3NtJLnx9sJhZWQJp/0uXqFpzSk1hRHmvWvpaAWSfvx2db0lVKZ5/wV0I0isD2mQ==}
 
   '@types/webxr@0.5.20':
     resolution: {integrity: sha512-JGpU6qiIJQKUuVSKx1GtQnHJGxRjtfGIhzO2ilq43VZZS//f1h1Sgexbdk+Lq+7569a6EYhOWrUpIruR/1Enmg==}
@@ -879,6 +888,9 @@ packages:
   lodash.merge@4.6.2:
     resolution: {integrity: sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==}
 
+  lodash@4.17.21:
+    resolution: {integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==}
+
   loose-envify@1.4.0:
     resolution: {integrity: sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==}
     hasBin: true
@@ -1115,8 +1127,8 @@ packages:
     peerDependencies:
       three: '>=0.128.0'
 
-  three@0.170.0:
-    resolution: {integrity: sha512-FQK+LEpYc0fBD+J8g6oSEyyNzjp+Q7Ks1C568WWaoMRLW+TkNNWmenWeGgJjV105Gd+p/2ql1ZcjYvNiPZBhuQ==}
+  three@0.171.0:
+    resolution: {integrity: sha512-Y/lAXPaKZPcEdkKjh0JOAHVv8OOnv/NDJqm0wjfCzyQmfKxV7zvkwsnBgPBKTzJHToSOhRGQAGbPJObT59B/PQ==}
 
   to-regex-range@5.0.1:
     resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
@@ -1405,10 +1417,10 @@ snapshots:
 
   '@mediapipe/tasks-vision@0.10.17': {}
 
-  '@monogrid/gainmap-js@3.1.0(three@0.170.0)':
+  '@monogrid/gainmap-js@3.1.0(three@0.171.0)':
     dependencies:
       promise-worker-transferable: 1.0.4
-      three: 0.170.0
+      three: 0.171.0
 
   '@nodelib/fs.scandir@2.1.5':
     dependencies:
@@ -1443,42 +1455,42 @@ snapshots:
       '@react-spring/types': 9.7.5
       react: 18.3.1
 
-  '@react-spring/three@9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(react@18.3.1)(three@0.170.0)':
+  '@react-spring/three@9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(react@18.3.1)(three@0.171.0)':
     dependencies:
       '@react-spring/animated': 9.7.5(react@18.3.1)
       '@react-spring/core': 9.7.5(react@18.3.1)
       '@react-spring/shared': 9.7.5(react@18.3.1)
       '@react-spring/types': 9.7.5
-      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)
+      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)
       react: 18.3.1
-      three: 0.170.0
+      three: 0.171.0
 
   '@react-spring/types@9.7.5': {}
 
-  '@react-three/drei@9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(@types/react@19.0.1)(@types/three@0.170.0)(react@18.3.1)(three@0.170.0)(use-sync-external-store@1.2.2(react@18.3.1))':
+  '@react-three/drei@9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(@types/react@19.0.1)(@types/three@0.171.0)(react@18.3.1)(three@0.171.0)(use-sync-external-store@1.2.2(react@18.3.1))':
     dependencies:
       '@babel/runtime': 7.26.0
       '@mediapipe/tasks-vision': 0.10.17
-      '@monogrid/gainmap-js': 3.1.0(three@0.170.0)
-      '@react-spring/three': 9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(react@18.3.1)(three@0.170.0)
-      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)
+      '@monogrid/gainmap-js': 3.1.0(three@0.171.0)
+      '@react-spring/three': 9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(react@18.3.1)(three@0.171.0)
+      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)
       '@use-gesture/react': 10.3.1(react@18.3.1)
-      camera-controls: 2.9.0(three@0.170.0)
+      camera-controls: 2.9.0(three@0.171.0)
       cross-env: 7.0.3
       detect-gpu: 5.0.61
       glsl-noise: 0.0.0
       hls.js: 1.5.17
-      maath: 0.10.8(@types/three@0.170.0)(three@0.170.0)
-      meshline: 3.3.1(three@0.170.0)
+      maath: 0.10.8(@types/three@0.171.0)(three@0.171.0)
+      meshline: 3.3.1(three@0.171.0)
       react: 18.3.1
       react-composer: 5.0.3(react@18.3.1)
-      stats-gl: 2.4.2(@types/three@0.170.0)(three@0.170.0)
+      stats-gl: 2.4.2(@types/three@0.171.0)(three@0.171.0)
       stats.js: 0.17.0
       suspend-react: 0.1.3(react@18.3.1)
-      three: 0.170.0
-      three-mesh-bvh: 0.7.8(three@0.170.0)
-      three-stdlib: 2.35.2(three@0.170.0)
-      troika-three-text: 0.52.2(three@0.170.0)
+      three: 0.171.0
+      three-mesh-bvh: 0.7.8(three@0.171.0)
+      three-stdlib: 2.35.2(three@0.171.0)
+      troika-three-text: 0.52.2(three@0.171.0)
       tunnel-rat: 0.1.2(@types/react@19.0.1)(react@18.3.1)
       utility-types: 3.11.0
       uuid: 9.0.1
@@ -1489,7 +1501,7 @@ snapshots:
       - immer
       - use-sync-external-store
 
-  '@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)':
+  '@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)':
     dependencies:
       '@babel/runtime': 7.26.0
       '@types/debounce': 1.2.4
@@ -1503,7 +1515,7 @@ snapshots:
       react-reconciler: 0.27.0(react@18.3.1)
       scheduler: 0.21.0
       suspend-react: 0.1.3(react@18.3.1)
-      three: 0.170.0
+      three: 0.171.0
       zustand: 3.7.2(react@18.3.1)
     transitivePeerDependencies:
       - '@types/react'
@@ -1575,6 +1587,8 @@ snapshots:
 
   '@types/estree@1.0.6': {}
 
+  '@types/lodash@4.17.13': {}
+
   '@types/node@22.10.2':
     dependencies:
       undici-types: 6.20.0
@@ -1595,7 +1609,7 @@ snapshots:
 
   '@types/stats.js@0.17.3': {}
 
-  '@types/three@0.170.0':
+  '@types/three@0.171.0':
     dependencies:
       '@tweenjs/tween.js': 23.1.3
       '@types/stats.js': 0.17.3
@@ -1745,9 +1759,9 @@ snapshots:
 
   callsites@3.1.0: {}
 
-  camera-controls@2.9.0(three@0.170.0):
+  camera-controls@2.9.0(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
   chalk@4.1.2:
     dependencies:
@@ -2059,20 +2073,22 @@ snapshots:
 
   lodash.merge@4.6.2: {}
 
+  lodash@4.17.21: {}
+
   loose-envify@1.4.0:
     dependencies:
       js-tokens: 4.0.0
 
-  maath@0.10.8(@types/three@0.170.0)(three@0.170.0):
+  maath@0.10.8(@types/three@0.171.0)(three@0.171.0):
     dependencies:
-      '@types/three': 0.170.0
-      three: 0.170.0
+      '@types/three': 0.171.0
+      three: 0.171.0
 
   merge2@1.4.1: {}
 
-  meshline@3.3.1(three@0.170.0):
+  meshline@3.3.1(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
   meshoptimizer@0.18.1: {}
 
@@ -2240,10 +2256,10 @@ snapshots:
 
   source-map@0.6.1: {}
 
-  stats-gl@2.4.2(@types/three@0.170.0)(three@0.170.0):
+  stats-gl@2.4.2(@types/three@0.171.0)(three@0.171.0):
     dependencies:
-      '@types/three': 0.170.0
-      three: 0.170.0
+      '@types/three': 0.171.0
+      three: 0.171.0
 
   stats.js@0.17.0: {}
 
@@ -2270,11 +2286,11 @@ snapshots:
 
   text-table@0.2.0: {}
 
-  three-mesh-bvh@0.7.8(three@0.170.0):
+  three-mesh-bvh@0.7.8(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
-  three-stdlib@2.35.2(three@0.170.0):
+  three-stdlib@2.35.2(three@0.171.0):
     dependencies:
       '@types/draco3d': 1.4.10
       '@types/offscreencanvas': 2019.7.3
@@ -2282,25 +2298,25 @@ snapshots:
       draco3d: 1.5.7
       fflate: 0.6.10
       potpack: 1.0.2
-      three: 0.170.0
+      three: 0.171.0
 
-  three@0.170.0: {}
+  three@0.171.0: {}
 
   to-regex-range@5.0.1:
     dependencies:
       is-number: 7.0.0
 
-  troika-three-text@0.52.2(three@0.170.0):
+  troika-three-text@0.52.2(three@0.171.0):
     dependencies:
       bidi-js: 1.0.3
-      three: 0.170.0
-      troika-three-utils: 0.52.0(three@0.170.0)
+      three: 0.171.0
+      troika-three-utils: 0.52.0(three@0.171.0)
       troika-worker-utils: 0.52.0
       webgl-sdf-generator: 1.1.1
 
-  troika-three-utils@0.52.0(three@0.170.0):
+  troika-three-utils@0.52.0(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
   troika-worker-utils@0.52.0: {}
 
diff --git a/scripts/launch-docker.sh b/scripts/launch-docker.sh
index 783c0b89..c202fff2 100755
--- a/scripts/launch-docker.sh
+++ b/scripts/launch-docker.sh
@@ -1,5 +1,6 @@
 #!/bin/bash
 
+# Exit on error, but allow specific commands to fail
 set -e
 
 # Determine script location and project root
@@ -10,376 +11,341 @@ PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"
 RED='\033[0;31m'
 GREEN='\033[0;32m'
 YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+GRAY='\033[0;90m'
+BOLD='\033[1m'
 NC='\033[0m'
 
-# Function to log messages with timestamps
+# Docker compose command with version check
+if command -v docker-compose &> /dev/null; then
+    DOCKER_COMPOSE="docker-compose"
+else
+    DOCKER_COMPOSE="docker compose"
+fi
+
+# Container names
+WEBXR_CONTAINER="logseq-xr-webxr"
+CLOUDFLARED_CONTAINER="cloudflared-tunnel"
+WEBXR_SERVICE="webxr"
+CLOUDFLARED_SERVICE="cloudflared"
+
+# Function to log messages with timestamps and optional color
 log() {
-    echo -e "[$(date "+%Y-%m-%d %H:%M:%S")] $1"
+    local color="${2:-$NC}"
+    echo -e "[$(date "+%Y-%m-%d %H:%M:%S")] ${color}$1${NC}"
 }
 
-# Function to check pnpm security
-check_pnpm_security() {
-    log "${YELLOW}Running pnpm security audit...${NC}"
-    
-    # Run pnpm audit and capture the output
-    local audit_output=$(pnpm audit 2>&1)
-    local audit_exit=$?
-    
-    # Count critical vulnerabilities, ensuring we have a valid integer
-    local critical_count
-    critical_count=$(echo "$audit_output" | grep -i "critical" | grep -o '[0-9]\+ vulnerabilities' | awk '{print $1}')
-    critical_count=${critical_count:-0}  # Default to 0 if empty
-    
-    echo "$audit_output"
-    
-    if [ "$critical_count" -gt 0 ]; then
-        log "${RED}Found $critical_count critical vulnerabilities!${NC}"
-        return 1
-    elif [ "$audit_exit" -ne 0 ]; then
-        log "${YELLOW}Found non-critical vulnerabilities${NC}"
-    else
-        log "${GREEN}No critical vulnerabilities found${NC}"
+# Function to log debug messages
+debug() {
+    if [ "${DEBUG:-0}" = "1" ]; then
+        log "$1" "$GRAY"
     fi
-    return 0
 }
 
-# Function to check TypeScript compilation
-check_typescript() {
-    log "${YELLOW}Running TypeScript type check...${NC}"
-    if ! pnpm run type-check; then
-        log "${RED}TypeScript check failed${NC}"
-        return 1
-    fi
-    log "${GREEN}TypeScript check passed${NC}"
-    return 0
+# Function to log error messages
+error() {
+    log "ERROR: $1" "$RED"
 }
 
-# Function to check Rust security
-check_rust_security() {
-    log "${YELLOW}Running cargo audit...${NC}"
-    
-    # Run cargo audit and capture the output
-    local audit_output=$(cargo audit 2>&1)
-    local audit_exit=$?
-    
-    # Count critical vulnerabilities, ensuring we have a valid integer
-    local critical_count
-    critical_count=$(echo "$audit_output" | grep -i "critical" | wc -l)
-    critical_count=${critical_count:-0}  # Default to 0 if empty
-    
-    echo "$audit_output"
-    
-    if [ "$critical_count" -gt 0 ]; then
-        log "${RED}Found $critical_count critical vulnerabilities!${NC}"
-        return 1
-    elif [ "$audit_exit" -ne 0 ]; then
-        log "${YELLOW}Found non-critical vulnerabilities${NC}"
-    else
-        log "${GREEN}No critical vulnerabilities found${NC}"
-    fi
-    return 0
+# Function to log warning messages
+warn() {
+    log "WARNING: $1" "$YELLOW"
 }
 
-# Function to read settings from TOML file
-read_settings() {
-    local settings_file="$PROJECT_ROOT/settings.toml"
-    # Extract domain and port from settings.toml
-    export DOMAIN=$(grep "domain = " "$settings_file" | cut -d'"' -f2)
-    export PORT=$(grep "port = " "$settings_file" | awk '{print $3}')
-    
-    if [ -z "$DOMAIN" ] || [ -z "$PORT" ]; then
-        log "${RED}Error: DOMAIN or PORT not set in settings.toml. Please check your configuration.${NC}"
-        exit 1
-    fi
+# Function to log success messages
+success() {
+    log "SUCCESS: $1" "$GREEN"
 }
 
-# Function to check system resources
-check_system_resources() {
-    log "${YELLOW}Checking GPU availability...${NC}"
-    if ! command -v nvidia-smi &> /dev/null; then
-        log "${RED}Error: nvidia-smi not found${NC}"
-        exit 1
-    fi
-    
-    # Check GPU memory
-    local gpu_info=$(nvidia-smi --query-gpu=memory.used,memory.total --format=csv,noheader)
-    echo "$gpu_info"
-    
-    # Check if any GPU has enough memory (at least 4GB free)
-    local has_enough_memory=false
-    while IFS=, read -r used total; do
-        used=$(echo "$used" | tr -d ' MiB')
-        total=$(echo "$total" | tr -d ' MiB')
-        free=$((total - used))
-        if [ "$free" -gt 4096 ]; then
-            has_enough_memory=true
-            break
-        fi
-    done <<< "$gpu_info"
-    
-    if [ "$has_enough_memory" = false ]; then
-        log "${RED}Error: No GPU with sufficient free memory (need at least 4GB)${NC}"
-        exit 1
-    fi
+# Function to log info messages
+info() {
+    log "INFO: $1" "$BLUE"
+}
+
+# Function to check if container exists
+container_exists() {
+    local container_name="$1"
+    docker ps -a -q -f name="^/${container_name}$" > /dev/null 2>&1
 }
 
-# Function to check Docker setup
-check_docker() {
-    if ! command -v docker &> /dev/null; then
-        log "${RED}Error: Docker is not installed${NC}"
+# Function to check if container is running
+container_is_running() {
+    local container_name="$1"
+    docker ps -q -f name="^/${container_name}$" > /dev/null 2>&1
+}
+
+# Function to setup environment
+setup_env() {
+    # Change to project root
+    cd "$PROJECT_ROOT" || {
+        error "Failed to change to project root directory"
         exit 1
-    fi
+    }
 
-    if docker compose version &> /dev/null; then
-        DOCKER_COMPOSE="docker compose"
-    elif docker-compose version &> /dev/null; then
-        DOCKER_COMPOSE="docker-compose"
+    # Check environment
+    if [ ! -f .env ]; then
+        warn ".env file not found in $PROJECT_ROOT"
     else
-        log "${RED}Error: Docker Compose not found${NC}"
-        exit 1
+        debug "Loading .env file..."
+        set -a
+        source .env || warn "Error sourcing .env file"
+        set +a
     fi
 }
 
-# Function to verify client directory structure
-verify_client_structure() {
-    log "${YELLOW}Verifying client directory structure...${NC}"
+# Function to wait for container to be ready
+wait_for_container() {
+    local container_name="$1"
+    local max_attempts=30
+    local attempt=1
+    local delay=2
     
-    local required_files=(
-        "$PROJECT_ROOT/client/index.html"
-        "$PROJECT_ROOT/client/index.ts"
-        "$PROJECT_ROOT/client/core/types.ts"
-        "$PROJECT_ROOT/client/core/constants.ts"
-        "$PROJECT_ROOT/client/core/utils.ts"
-        "$PROJECT_ROOT/client/core/logger.ts"
-        "$PROJECT_ROOT/client/websocket/websocketService.ts"
-        "$PROJECT_ROOT/client/rendering/scene.ts"
-        "$PROJECT_ROOT/client/rendering/nodes.ts"
-        "$PROJECT_ROOT/client/rendering/textRenderer.ts"
-        "$PROJECT_ROOT/client/state/settings.ts"
-        "$PROJECT_ROOT/client/state/graphData.ts"
-        "$PROJECT_ROOT/client/state/defaultSettings.ts"
-        "$PROJECT_ROOT/client/xr/xrSessionManager.ts"
-        "$PROJECT_ROOT/client/xr/xrInteraction.ts"
-        "$PROJECT_ROOT/client/xr/xrTypes.ts"
-        "$PROJECT_ROOT/client/platform/platformManager.ts"
-        "$PROJECT_ROOT/client/tsconfig.json"
-    )
+    info "Waiting for $container_name to be ready..."
     
-    for file in "${required_files[@]}"; do
-        if [ ! -f "$file" ]; then
-            log "${RED}Error: Required file $file not found${NC}"
+    while [ $attempt -le $max_attempts ]; do
+        # Check if container exists
+        if ! container_exists "$container_name"; then
+            error "Container $container_name does not exist"
             return 1
         fi
+        
+        # Check if container is running
+        if ! container_is_running "$container_name"; then
+            warn "Container $container_name is not running (attempt $attempt/$max_attempts)"
+            sleep $delay
+            ((attempt++))
+            continue
+        fi
+        
+        # Check health status
+        local health
+        health=$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$container_name" 2>/dev/null)
+        
+        case "$health" in
+            "healthy")
+                if docker logs "$container_name" 2>&1 | grep -q "Frontend is healthy"; then
+                    success "Container $container_name is ready"
+                    return 0
+                fi
+                ;;
+            "none")
+                if docker logs "$container_name" 2>&1 | grep -q "Frontend is healthy"; then
+                    success "Container $container_name is ready"
+                    return 0
+                fi
+                ;;
+        esac
+        
+        info "Attempt $attempt/$max_attempts: Waiting for container to be healthy..."
+        sleep $delay
+        ((attempt++))
     done
     
-    log "${GREEN}Client directory structure verified${NC}"
-    return 0
+    error "Timed out waiting for $container_name to be ready"
+    docker logs "$container_name" 2>&1 | tail -n 50
+    return 1
 }
 
-# Function to clean up existing processes
-cleanup_existing_processes() {
-    log "${YELLOW}Cleaning up...${NC}"
-    
-    # Save logs before cleanup if there was a failure
-    if [ -n "${SAVE_LOGS:-}" ]; then
-        local log_dir="$PROJECT_ROOT/logs/$(date +%Y%m%d_%H%M%S)"
-        mkdir -p "$log_dir"
-        $DOCKER_COMPOSE logs --no-color > "$log_dir/docker-compose.log"
-        log "${YELLOW}Logs saved to $log_dir${NC}"
-    fi
-    
-    # Stop and remove all containers from the compose project
-    $DOCKER_COMPOSE down --remove-orphans --timeout 30
-    
-    # Clean up any orphaned containers
-    for container in "logseq-xr-webxr" "cloudflared-tunnel"; do
-        if docker ps -a | grep -q "$container"; then
-            log "Removing container $container..."
-            docker rm -f "$container" || true
-        fi
-    done
+# Function to start containers
+start_containers() {
+    info "Starting containers..."
+    $DOCKER_COMPOSE up -d || {
+        error "Failed to start containers"
+        return 1
+    }
+    success "Containers started successfully"
+}
 
-    # Clean up ports
-    for port in $PORT 4000 3001; do
-        if netstat -tuln | grep -q ":$port "; then
-            local pid=$(lsof -ti ":$port")
-            if [ ! -z "$pid" ]; then
-                log "Killing process using port $port (PID: $pid)"
-                kill -15 $pid 2>/dev/null || kill -9 $pid
-            fi
-        fi
-    done
-    
-    # Clean up old volumes and images
-    log "Cleaning up Docker resources..."
-    docker volume ls -q | grep "logseqXR" | xargs -r docker volume rm
-    docker image prune -f
-    
-    sleep 2
+# Function to stop containers
+stop_containers() {
+    info "Stopping and removing containers..."
+    $DOCKER_COMPOSE down || true
 }
 
-# Function to check RAGFlow network availability
-check_ragflow_network() {
-    log "${YELLOW}Checking RAGFlow network availability...${NC}"
-    if ! docker network ls | grep -q "docker_ragflow"; then
-        log "${RED}Error: RAGFlow network (docker_ragflow) not found${NC}"
-        log "${YELLOW}Please ensure RAGFlow is running in ../ragflow/docker${NC}"
-        log "${YELLOW}You can check the network with: docker network ls${NC}"
+# Function to rebuild containers
+rebuild_container() {
+    info "Rebuilding $WEBXR_CONTAINER..."
+    
+    # Stop and remove containers
+    stop_containers
+
+    # Build and start containers
+    info "Starting $WEBXR_CONTAINER..."
+    if ! $DOCKER_COMPOSE up -d --build; then
+        error "Failed to start containers"
         return 1
     fi
-    log "${GREEN}RAGFlow network is available${NC}"
-    return 0
+
+    # Wait for container to be ready
+    if ! wait_for_container "$WEBXR_CONTAINER"; then
+        error "Container failed to become ready"
+        return 1
+    fi
+
+    success "Successfully rebuilt and restarted $WEBXR_CONTAINER"
 }
 
-# Function to check application readiness
-check_application_readiness() {
-    local max_attempts=60
-    local attempt=1
-    local wait=2
+# Function to test backend endpoints
+test_backend() {
+    info "Testing backend endpoints..."
 
-    log "${YELLOW}Checking application readiness...${NC}"
-    
-    # Install websocat if not available
-    if ! command -v websocat &> /dev/null; then
-        log "${YELLOW}Installing websocat for WebSocket testing...${NC}"
-        if command -v cargo &> /dev/null; then
-            cargo install websocat
-        else
-            log "${RED}Error: Neither websocat nor cargo found. Cannot test WebSocket connection.${NC}"
-            return 1
-        fi
+    # Test graph data endpoint
+    local response=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:4000/api/graph/data")
+    if [ "$response" = "200" ]; then
+        success "Backend graph data endpoint successful (HTTP 200)"
+    else
+        error "Backend graph data endpoint failed (HTTP $response)"
+        return 1
     fi
 
-    while [ $attempt -le $max_attempts ]; do
-        local ready=true
-        local status_msg=""
+    # Test settings endpoint
+    info "Testing /api/settings..."
+    response=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:4000/api/settings")
+    if [ "$response" = "200" ]; then
+        success "Backend /api/settings successful (HTTP 200)"
+    else
+        error "Backend /api/settings failed (HTTP $response)"
+    fi
 
-        # Check HTTP endpoint
-        if ! timeout 5 curl -s http://localhost:4000/ >/dev/null; then
-            ready=false
-            status_msg="HTTP endpoint not ready"
-        fi
+    # Test Cloudflare tunnel
+    test_cloudflare_tunnel
+}
 
-        # Check WebSocket endpoint
-        if [ "$ready" = true ]; then
-            log "${YELLOW}Testing WebSocket connection...${NC}"
-            if ! timeout 5 websocat "ws://localhost:4000/wss" > /dev/null 2>&1 <<< '{"type":"ping"}'; then
-                ready=false
-                status_msg="WebSocket endpoint not ready"
-            fi
+# Function to test Cloudflare tunnel
+test_cloudflare_tunnel() {
+    info "Testing Cloudflare tunnel..."
+    
+    # Wait for cloudflared container to start
+    local max_attempts=30
+    local attempt=1
+    local delay=2
+    
+    info "Waiting for Cloudflare tunnel to be ready..."
+    while [ $attempt -le $max_attempts ]; do
+        info "Attempt $attempt/$max_attempts: Checking tunnel status..."
+        
+        # Check if container is running
+        if ! docker ps -q -f name="^/$CLOUDFLARED_CONTAINER$" > /dev/null 2>&1; then
+            warn "Cloudflared tunnel container is not running"
+            sleep $delay
+            ((attempt++))
+            continue
         fi
 
-        # Optional RAGFlow connectivity check
-        if [ "$ready" = true ]; then
-            if timeout 5 curl -s http://ragflow-server/v1/health >/dev/null; then
-                log "${GREEN}RAGFlow service is accessible${NC}"
+        # Check if tunnel is registered
+        if docker logs $CLOUDFLARED_CONTAINER 2>&1 | grep -q "Registered tunnel connection"; then
+            success "Cloudflare tunnel is registered and ready"
+            
+            # Get tunnel hostname from config
+            local tunnel_hostname=$(grep -o 'hostname: .*' config.yml | cut -d' ' -f2)
+            if [ -n "$tunnel_hostname" ]; then
+                success "Using tunnel hostname: $tunnel_hostname"
+                
+                # Test tunnel endpoint
+                local response=$(curl -s -o /dev/null -w "%{http_code}" "https://$tunnel_hostname" || echo "000")
+                if [ "$response" = "200" ]; then
+                    success "Tunnel endpoint is accessible"
+                    return 0
+                else
+                    error "Tunnel endpoint returned HTTP $response"
+                    return 1
+                fi
             else
-                log "${YELLOW}Note: RAGFlow service is not accessible - some features will be limited${NC}"
+                error "Could not find tunnel hostname in config.yml"
+                return 1
             fi
         fi
 
-        if [ "$ready" = true ]; then
-            log "${GREEN}All services are ready${NC}"
-            return 0
-        fi
-
-        log "${YELLOW}Attempt $attempt/$max_attempts: $status_msg${NC}"
-        
-        if [ $attempt -eq $((max_attempts/2)) ]; then
-            log "${YELLOW}Still waiting for services. Recent logs:${NC}"
-            $DOCKER_COMPOSE logs --tail=20
-        fi
-
-        sleep $wait
-        attempt=$((attempt + 1))
+        sleep $delay
+        ((attempt++))
     done
 
-    log "${RED}Application failed to become ready. Dumping logs...${NC}"
-    SAVE_LOGS=1
-    $DOCKER_COMPOSE logs
+    error "Could not establish Cloudflare tunnel after $max_attempts attempts"
+    docker logs $CLOUDFLARED_CONTAINER | tail -n 50
     return 1
 }
 
-# Function to handle exit
-handle_exit() {
-    log "\n${YELLOW}Exiting to shell. Containers will continue running.${NC}"
-    exit 0
+# Function to show endpoints
+show_endpoints() {
+    echo
+    info "Services are running!"
+    echo "HTTP:      http://localhost:4000"
+    echo "WebSocket: ws://localhost:4000/wss"
+    echo
+    info "Available commands:"
+    echo "logs:    $DOCKER_COMPOSE logs -f"
+    echo "stop:    $DOCKER_COMPOSE down"
+    echo "restart: $DOCKER_COMPOSE restart"
+    echo
 }
 
-# Set up trap for clean exit
-trap handle_exit INT TERM
-
-# Change to project root directory
-cd "$PROJECT_ROOT"
-
-# Check environment
-if [ ! -f .env ]; then
-    log "${RED}Error: .env file not found in $PROJECT_ROOT${NC}"
-    exit 1
-fi
-
-# Source .env file
-set -a
-source .env
-set +a
-
-# Read settings from TOML
-read_settings
-
-# Initial setup
-check_docker
-check_system_resources
-
-# Verify client structure
-if ! verify_client_structure; then
-    log "${RED}Client structure verification failed${NC}"
-    exit 1
-fi
-
-# Run security checks
-log "\n${YELLOW}Running security checks...${NC}"
-check_pnpm_security || true
-check_typescript || exit 1
-check_rust_security || true
-
-cleanup_existing_processes
-
-# Check RAGFlow network before starting
-if ! check_ragflow_network; then
-    log "${RED}Cannot proceed without RAGFlow network${NC}"
-    exit 1
-fi
-
-# Build and start services
-log "${YELLOW}Building and starting services...${NC}"
-$DOCKER_COMPOSE build --pull --no-cache
-$DOCKER_COMPOSE up -d
-
-# Check application readiness
-if ! check_application_readiness; then
-    log "${RED}Application failed to start properly${NC}"
-    cleanup_existing_processes
-    exit 1
-fi
-
-# Print final status
-log "\n${GREEN}🚀 Services are running!${NC}"
-
-log "\nResource Usage:"
-docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
-
-log "\nEndpoints:"
-echo "HTTP:      http://localhost:4000"
-echo "WebSocket: ws://localhost:4000/wss"
+# Function to handle cleanup on exit
+cleanup() {
+    info "Cleaning up..."
+    if [ "${DEBUG:-0}" = "1" ]; then
+        $DOCKER_COMPOSE logs
+    fi
+}
 
-log "\nCommands:"
-echo "logs:    $DOCKER_COMPOSE logs -f"
-echo "stop:    $DOCKER_COMPOSE down"
-echo "restart: $DOCKER_COMPOSE restart"
+# Set up trap for cleanup
+trap cleanup EXIT
 
-# Keep script running to show logs
-log "\n${YELLOW}Showing logs (Ctrl+C to exit)...${NC}"
-$DOCKER_COMPOSE logs -f &
+# Main function
+main() {
+    local command="${1:-start}"
+    
+    # Setup environment first
+    setup_env
+    
+    case "$command" in
+        "start")
+            info "Starting containers..."
+            start_containers
+            if wait_for_container "$WEBXR_CONTAINER"; then
+                show_endpoints
+                info "Showing logs (Ctrl+C to exit)..."
+                $DOCKER_COMPOSE logs -f
+            fi
+            ;;
+        "stop")
+            info "Stopping containers..."
+            stop_containers
+            ;;
+        "restart")
+            info "Restarting containers..."
+            start_containers
+            if wait_for_container "$WEBXR_CONTAINER"; then
+                show_endpoints
+            fi
+            ;;
+        "rebuild")
+            if rebuild_container "$WEBXR_CONTAINER"; then
+                show_endpoints
+            fi
+            ;;
+        "test")
+            if ! wait_for_container "$WEBXR_CONTAINER"; then
+                exit 1
+            fi
+            test_backend
+            ;;
+        "rebuild-test")
+            if ! rebuild_container "$WEBXR_CONTAINER"; then
+                exit 1
+            fi
+            test_backend
+            ;;
+        "logs")
+            info "Showing logs (Ctrl+C to exit)..."
+            $DOCKER_COMPOSE logs -f
+            ;;
+        *)
+            error "Unknown command: $command"
+            echo "Usage: $0 [start|stop|restart|rebuild|test|rebuild-test|logs]"
+            exit 1
+            ;;
+    esac
+}
 
-# Wait for signal
-wait
+# Run main function with all arguments
+main "$@"
diff --git a/scripts/start.sh b/scripts/start.sh
index 7b16871c..5959c699 100755
--- a/scripts/start.sh
+++ b/scripts/start.sh
@@ -6,79 +6,66 @@ log() {
     echo "[$(date "+%Y-%m-%d %H:%M:%S")] $1"
 }
 
-# Function to check if a service is healthy
+# Function to check if a port is available
+check_port_available() {
+    local port=$1
+    local max_retries=10
+    local wait=1
+
+    log "Checking if port $port is available..."
+    
+    for ((i=1; i<=max_retries; i++)); do
+        if timeout 1 bash -c "cat < /dev/null > /dev/tcp/0.0.0.0/$port" 2>/dev/null; then
+            log "Port $port is available"
+            return 0
+        fi
+        if [ $i -lt $max_retries ]; then
+            log "Port $port not ready, attempt $i of $max_retries..."
+            sleep $wait
+        fi
+    done
+
+    log "Error: Port $port is not available after $max_retries attempts"
+    return 1
+}
+
+# Function to check service health
 check_service_health() {
     local port=$1
     local endpoint=${2:-"/"}
-    local websocket=${3:-false}
     local retries=30
     local wait=2
 
     log "Checking health for service on port $port..."
     
     while [ $retries -gt 0 ]; do
-        # Check if port is open
-        if ! timeout 1 bash -c "cat < /dev/null > /dev/tcp/0.0.0.0/$port" 2>/dev/null; then
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Error: Port $port is not available"
-                return 1
-            fi
-            log "Port $port not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-            continue
-        fi
-
-        # Check HTTP endpoint
-        if ! curl -s -f --max-time 5 "http://localhost:$port$endpoint" > /dev/null; then
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Error: Service health check failed on port $port"
-                return 1
-            fi
-            log "Service not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-            continue
+        if curl -s -f --max-time 5 "http://localhost:$port$endpoint" > /dev/null; then
+            log "Service on port $port is healthy"
+            return 0
         fi
-
-        # Check WebSocket endpoint if required
-        if [ "$websocket" = true ] && ! curl -s -f --max-time 5 -N -H "Connection: Upgrade" -H "Upgrade: websocket" "http://localhost:$port/wss" > /dev/null; then
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Error: WebSocket health check failed on port $port"
-                return 1
-            fi
-            log "WebSocket not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-            continue
+        
+        retries=$((retries-1))
+        if [ $retries -eq 0 ]; then
+            log "Error: Service health check failed on port $port"
+            return 1
         fi
-
-        log "Service on port $port is healthy"
-        return 0
+        log "Service not ready, retrying in $wait seconds... ($retries attempts left)"
+        sleep $wait
     done
 
     return 1
 }
 
-# Function to check RAGFlow connectivity with retries
+# Function to check RAGFlow connectivity
 check_ragflow() {
     log "Checking RAGFlow connectivity..."
-    local retries=5
-    local wait=10
-    while [ $retries -gt 0 ]; do
-        if curl -s -f --max-time 5 "http://ragflow-server/v1/" > /dev/null; then
-            log "RAGFlow server is reachable"
-            return 0
-        else
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Warning: Cannot reach RAGFlow server after multiple attempts"
-                return 1
-            fi
-            log "RAGFlow not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-        fi
-    done
+    if curl -s -f --max-time 5 "http://ragflow-server/v1/" > /dev/null; then
+        log "RAGFlow server is reachable"
+        return 0
+    else
+        log "Warning: RAGFlow server not available - some features may be limited"
+        return 1
+    fi
 }
 
 # Function to verify production build
@@ -91,33 +78,9 @@ verify_build() {
         return 1
     fi
     
-    if [ ! -r "/app/data/public/dist" ]; then
-        log "Error: Production build directory is not readable"
-        return 1
-    fi
-    
-    # Check required files exist
-    local required_files=(
-        "index.html"
-        "assets"
-    )
-    
-    for file in "${required_files[@]}"; do
-        if [ ! -e "/app/data/public/dist/$file" ]; then
-            log "Error: Required file/directory '$file' not found in build directory"
-            return 1
-        fi
-    done
-    
-    # Check directory is not empty
-    if [ -z "$(ls -A /app/data/public/dist)" ]; then
-        log "Error: Production build directory is empty"
-        return 1
-    fi
-    
-    # Check permissions
+    # Check index.html exists and is readable
     if [ ! -r "/app/data/public/dist/index.html" ]; then
-        log "Error: index.html is not readable"
+        log "Error: index.html not found or not readable"
         return 1
     fi
     
@@ -162,14 +125,12 @@ setup_runtime() {
 
     # Verify GPU is available
     if ! command -v nvidia-smi &> /dev/null; then
-        log "Error: nvidia-smi not found. GPU support is required."
-        return 1
-    fi
-
-    # Check GPU is accessible
-    if ! nvidia-smi &> /dev/null; then
-        log "Error: Cannot access NVIDIA GPU. Check device is properly passed to container."
-        return 1
+        log "Warning: nvidia-smi not found. GPU support may be limited."
+    else
+        # Check GPU is accessible
+        if ! nvidia-smi &> /dev/null; then
+            log "Warning: Cannot access NVIDIA GPU. Some features may be limited."
+        fi
     fi
 
     log "Runtime environment configured successfully"
@@ -218,10 +179,8 @@ main() {
         exit 1
     fi
 
-    # Check RAGFlow availability (optional)
-    if ! check_ragflow; then
-        log "Warning: RAGFlow server not available - some features may be limited"
-    fi
+    # Check RAGFlow connectivity
+    check_ragflow
 
     # Verify production build
     if ! verify_build; then
@@ -229,24 +188,52 @@ main() {
         exit 1
     fi
 
-    # Start nginx (it needs to bind to port 4000)
-    log "Starting nginx..."
-    nginx -t && nginx
-    if [ $? -ne 0 ]; then
-        log "Failed to start nginx"
+    # Check if backend port is available
+    # Start webxr binary with output logging
+    log "Starting webxr..."
+    /app/webxr > /tmp/webxr.log 2>&1 &
+    RUST_PID=$!
+
+    # Give webxr time to initialize
+    sleep 5
+
+    # Check if process is still running
+    if ! kill -0 $RUST_PID 2>/dev/null; then
+        log "Error: webxr process failed to start"
+        cat /tmp/webxr.log
         exit 1
     fi
 
-    # Basic nginx HTTP check (not WebSocket since that requires webxr to be running)
-    if ! curl -s -f --max-time 5 "http://localhost:4000/" > /dev/null; then
-        log "Failed to verify nginx is running"
+    # Give the backend time to start
+    log "Waiting for backend to initialize..."
+    sleep 10
+    
+    # Check if process is still running
+    if ! kill -0 $RUST_PID 2>/dev/null; then
+        log "Error: Backend process died during startup"
+        cat /tmp/webxr.log
         exit 1
     fi
+    log "Backend process is running"
+
+    # Start nginx
+    log "Starting nginx..."
+    nginx -t || { log "nginx config test failed"; kill $RUST_PID; exit 1; }
+    nginx || { log "Failed to start nginx"; kill $RUST_PID; exit 1; }
     log "nginx started successfully"
 
-    # Execute the webxr binary as the main process (which will enable WebSocket endpoints)
-    log "Executing webxr..."
-    exec /app/webxr
+    # Check frontend health
+    if ! check_service_health 4000 "/"; then
+        log "Error: Frontend health check failed"
+        cat /tmp/webxr.log
+        kill $RUST_PID
+        nginx -s quit
+        exit 1
+    fi
+    log "Frontend is healthy"
+
+    # Wait for webxr process
+    wait $RUST_PID
 }
 
 # Execute main function
diff --git a/scripts/test_all_endpoints.sh b/scripts/test_all_endpoints.sh
new file mode 100755
index 00000000..167c9a34
--- /dev/null
+++ b/scripts/test_all_endpoints.sh
@@ -0,0 +1,485 @@
+#!/bin/bash
+
+# Enable error reporting and strict mode
+set -euo pipefail
+IFS=$'\n\t'
+
+# Color setup using tput
+if [ -t 1 ]; then
+    RED=$(tput setaf 1)
+    GREEN=$(tput setaf 2)
+    YELLOW=$(tput setaf 3)
+    BLUE=$(tput setaf 4)
+    BOLD=$(tput bold)
+    NC=$(tput sgr0)
+else
+    RED=""
+    GREEN=""
+    YELLOW=""
+    BLUE=""
+    BOLD=""
+    NC=""
+fi
+
+# Configuration
+CONTAINER_NAME="logseq-xr-webxr"
+BACKEND_PORT=3001
+NGINX_PORT=4000
+PUBLIC_DOMAIN="www.visionflow.info"
+TIMEOUT=5
+WEBSOCKET_TIMEOUT=10
+
+# Test environments
+declare -A ENDPOINTS=(
+    ["internal"]="http://localhost:$NGINX_PORT"
+    ["container"]="http://127.0.0.1:$BACKEND_PORT"
+    ["ragflow"]="http://logseq-xr-webxr:$BACKEND_PORT"
+    ["external"]="https://$PUBLIC_DOMAIN"
+)
+
+# Function to log messages with timestamp
+log() {
+    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
+    printf "%s[%s]%s %s\n" "${BOLD}" "${timestamp}" "${NC}" "$1"
+}
+
+# Function to log success
+log_success() {
+    log "${GREEN}✓ $1${NC}"
+}
+
+# Function to log error
+log_error() {
+    log "${RED}✗ $1${NC}"
+}
+
+# Function to log info
+log_info() {
+    log "${BLUE}$1${NC}"
+}
+
+# Function to log header
+log_header() {
+    printf "\n%s%s===%s %s %s===%s\n" "${BOLD}" "${YELLOW}" "${NC}" "$1" "${YELLOW}" "${NC}"
+}
+
+# Function to pretty print JSON
+pretty_json() {
+    if command -v jq >/dev/null 2>&1; then
+        echo "$1" | jq '.'
+    else
+        echo "$1"
+    fi
+}
+
+# Function to test endpoint and show response
+test_endpoint() {
+    local url="$1"
+    local description="$2"
+    local method="${3:-GET}"
+    local data="${4:-}"
+    local extra_opts="${5:-}"
+    
+    log_info "Testing $method $description..."
+    log_info "URL: $url"
+    
+    # Only capture status code, discard response body
+    local http_code
+    if [[ -n "$data" ]]; then
+        http_code=$(curl -X $method -m $TIMEOUT -s -o /dev/null -w "%{http_code}" \
+            -H "Accept: application/json" -H "Content-Type: application/json" \
+            -d "$data" $extra_opts "$url")
+    else
+        http_code=$(curl -X $method -m $TIMEOUT -s -o /dev/null -w "%{http_code}" \
+            -H "Accept: application/json" $extra_opts "$url")
+    fi
+    
+    if [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
+        log_success "$description successful (HTTP $http_code)"
+        return 0
+    else
+        log_error "$description failed (HTTP $http_code)"
+        return 1
+    fi
+}
+
+# Function to test WebSocket connection
+test_websocket() {
+    local url="$1"
+    local description="$2"
+    
+    log_info "Testing WebSocket: $description"
+    log_info "URL: $url"
+    
+    # Use websocat to test WebSocket connection if available
+    if command -v websocat >/dev/null 2>&1; then
+        timeout $WEBSOCKET_TIMEOUT websocat --no-close "$url" 2>&1 || {
+            log_error "WebSocket connection failed"
+            return 1
+        }
+        log_success "WebSocket connection successful"
+        return 0
+    else
+        # Fallback to curl for basic connection test
+        if curl --include \
+            --no-buffer \
+            --header "Connection: Upgrade" \
+            --header "Upgrade: websocket" \
+            --header "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" \
+            --header "Sec-WebSocket-Version: 13" \
+            -s "$url" 2>&1 | grep -q "101 Switching Protocols"; then
+            log_success "WebSocket handshake successful"
+            return 0
+        else
+            log_error "WebSocket handshake failed"
+            return 1
+        fi
+    fi
+}
+
+# Function to test environment
+test_environment() {
+    local env="$1"
+    local base_url="${ENDPOINTS[$env]}"
+    local failed=0
+    
+    log_header "Testing $env environment ($base_url)"
+    
+    # Test graph endpoints
+    test_endpoint "$base_url/api/graph/data" "$env full graph data" || ((failed++))
+    test_endpoint "$base_url/api/graph/paginated?page=0&pageSize=10" "$env paginated graph data" || ((failed++))
+    test_endpoint "$base_url/api/graph/update" "$env graph update" "POST" '{"nodes": [], "edges": []}' || ((failed++))
+    
+    # Test settings endpoints
+    test_endpoint "$base_url/api/settings" "$env all settings" || ((failed++))
+    test_endpoint "$base_url/api/settings/visualization" "$env visualization settings" || ((failed++))
+    test_endpoint "$base_url/api/settings/websocket" "$env WebSocket control API" || ((failed++))
+    
+    # Test settings endpoints for each category
+    local categories=(
+        "system.network"
+        "system.websocket"
+        "system.security"
+        "system.debug"
+        "visualization.animations"
+        "visualization.ar"
+        "visualization.audio"
+        "visualization.bloom"
+        "visualization.edges"
+        "visualization.hologram"
+        "visualization.labels"
+        "visualization.nodes"
+        "visualization.physics"
+        "visualization.rendering"
+    )
+    
+    for category in "${categories[@]}"; do
+        # Test category endpoint
+        test_endpoint "$base_url/api/settings/$category" "$env $category settings" || ((failed++))
+        
+        # Test individual setting update
+        local setting="enabled"
+        test_endpoint "$base_url/api/settings/$category/$setting" "$env get $category.$setting" || ((failed++))
+        test_endpoint "$base_url/api/settings/$category/$setting" "$env update $category.$setting" "PUT" '{"value": true}' || ((failed++))
+    done
+    
+    # Test WebSocket endpoints
+    local ws_protocol="ws"
+    [[ "$base_url" == https://* ]] && ws_protocol="wss"
+    local ws_base_url="${base_url/http:/$ws_protocol:}"
+    local ws_base_url="${ws_base_url/https:/$ws_protocol:}"
+    
+    test_websocket "$ws_base_url/wss" "$env Binary Protocol" || ((failed++))
+    test_endpoint "$base_url/api/visualization/settings/websocket" "$env WebSocket Settings" || ((failed++))
+    
+    return $failed
+}
+
+# Function to test container internal endpoints
+test_container_endpoints() {
+    local failed=0
+    log_header "Testing container internal endpoints"
+    
+    # Test graph data endpoint
+    log_info "Testing graph data endpoint..."
+    local status=$(docker exec $CONTAINER_NAME curl -s -o /dev/null -w "%{http_code}" \
+        -H "Accept: application/json" "http://localhost:4000/api/graph/data")
+    if [[ "$status" =~ ^2[0-9][0-9]$ ]]; then
+        log_success "Container internal graph data endpoint successful (HTTP $status)"
+    else
+        log_error "Container internal graph data endpoint failed (HTTP $status)"
+        ((failed++))
+    fi
+    
+    # Test settings endpoint
+    log_info "Testing settings endpoint..."
+    status=$(docker exec $CONTAINER_NAME curl -s -o /dev/null -w "%{http_code}" \
+        -H "Accept: application/json" "http://localhost:4000/api/settings")
+    if [[ "$status" =~ ^2[0-9][0-9]$ ]]; then
+        log_success "Container internal settings endpoint successful (HTTP $status)"
+    else
+        log_error "Container internal settings endpoint failed (HTTP $status)"
+        ((failed++))
+    fi
+    
+    # Test WebSocket inside container
+    log_info "Testing WebSocket endpoint..."
+    status=$(docker exec $CONTAINER_NAME curl -v -i \
+        --no-buffer \
+        -H "Accept: application/json" \
+        -H "Connection: Upgrade" \
+        -H "Upgrade: websocket" \
+        -H "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" \
+        -H "Sec-WebSocket-Version: 13" \
+        "http://localhost:4000/wss" 2>&1 | grep -oP '(?<=HTTP/1.1 )\d{3}')
+    if [[ "$status" =~ ^2[0-9][0-9]$ ]]; then
+        log_success "Container internal WebSocket endpoint successful (HTTP $status)"
+    else
+        log_error "Container internal WebSocket endpoint failed (HTTP $status)"
+        ((failed++))
+    fi
+    
+    if [ $failed -eq 0 ]; then
+        log_success "All container internal endpoints passed"
+    else
+        log_error "$failed container internal endpoint tests failed"
+    fi
+    
+    return $failed
+}
+
+# Function to test backend directly
+test_backend_directly() {
+    local failed=0
+    log_header "Testing backend directly"
+    
+    # Test backend on port 3001
+    log_info "Testing backend endpoints on port 3001..."
+    
+    # Test graph data endpoint
+    local status=$(docker exec $CONTAINER_NAME curl -s -o /dev/null -w "%{http_code}" \
+        -H "Accept: application/json" "http://localhost:3001/api/graph/data")
+    if [[ "$status" =~ ^2[0-9][0-9]$ ]]; then
+        log_success "Backend graph data endpoint successful (HTTP $status)"
+    else
+        log_error "Backend graph data endpoint failed (HTTP $status)"
+        ((failed++))
+    fi
+    
+    # Test settings endpoints with and without trailing slash
+    local settings_endpoints=(
+        "/api/settings"
+        "/api/settings/"
+        "/api/settings/visualization"
+        "/api/settings/websocket"
+        "/api/settings/system"
+        "/api/settings/all"
+    )
+    
+    for endpoint in "${settings_endpoints[@]}"; do
+        log_info "Testing $endpoint..."
+        status=$(docker exec $CONTAINER_NAME curl -s -o /dev/null -w "%{http_code}" \
+            -H "Accept: application/json" "http://localhost:3001$endpoint")
+        if [[ "$status" =~ ^2[0-9][0-9]$ ]]; then
+            log_success "Backend $endpoint successful (HTTP $status)"
+        else
+            log_error "Backend $endpoint failed (HTTP $status)"
+            ((failed++))
+        fi
+    done
+    
+    if [ $failed -eq 0 ]; then
+        log_success "All backend tests passed"
+    else
+        log_error "$failed backend tests failed"
+    fi
+    
+    return $failed
+}
+
+# Function to test RAGFlow network connectivity
+test_ragflow_connectivity() {
+    local failed=0
+    log_header "Testing RAGFlow network connectivity"
+    
+    # Test RAGFlow server connectivity
+    docker exec $CONTAINER_NAME curl -s -f -H "Accept: application/json" "http://ragflow-server/v1/" > /dev/null || {
+        log_error "RAGFlow server connectivity failed"
+        ((failed++))
+    }
+    
+    # Test Redis connectivity
+    docker exec $CONTAINER_NAME curl -s -H "Accept: application/json" "http://ragflow-redis:6379/ping" > /dev/null || {
+        log_error "RAGFlow Redis connectivity failed"
+        ((failed++))
+    }
+    
+    # Test MySQL connectivity (just check if port is open)
+    docker exec $CONTAINER_NAME timeout 1 bash -c "cat < /dev/null > /dev/tcp/ragflow-mysql/3306" 2>/dev/null || {
+        log_error "RAGFlow MySQL connectivity failed"
+        ((failed++))
+    }
+    
+    # Test Elasticsearch connectivity
+    docker exec $CONTAINER_NAME curl -s -f -H "Accept: application/json" "http://ragflow-es-01:9200/_cluster/health" > /dev/null || {
+        log_error "RAGFlow Elasticsearch connectivity failed"
+        ((failed++))
+    }
+    
+    if [ $failed -eq 0 ]; then
+        log_success "All RAGFlow network connectivity tests passed"
+    else
+        log_error "$failed RAGFlow network connectivity tests failed"
+    fi
+    
+    return $failed
+}
+
+# Function to check container logs
+check_container_logs() {
+    local container_name="$1"
+    local lines="${2:-50}"
+    
+    log_header "Container Logs ($container_name)"
+    
+    # Show container status
+    local status=$(docker inspect -f '{{.State.Status}}' "$container_name" 2>/dev/null)
+    local health=$(docker inspect -f '{{.State.Health.Status}}' "$container_name" 2>/dev/null)
+    local started=$(docker inspect -f '{{.State.StartedAt}}' "$container_name" 2>/dev/null)
+    local networks=$(docker inspect -f '{{range $net, $conf := .NetworkSettings.Networks}}{{$net}} {{end}}' "$container_name" 2>/dev/null)
+    
+    log_info "Status: $status"
+    log_info "Health: $health"
+    log_info "Started At: $started"
+    log_info "Networks: $networks"
+    
+    # Show recent health check logs, filtering out large JSON responses
+    log_info "Recent health check logs:"
+    docker logs "$container_name" 2>&1 | grep -v '{"nodes":\[{' | grep -v '"edges":\[{' | tail -n "$lines"
+    
+    # Show recent container logs
+    log_info "Last $lines lines of container logs:"
+    docker logs "$container_name" 2>&1 | grep -v '{"nodes":\[{' | grep -v '"edges":\[{' | grep "\[" | tail -n "$lines"
+}
+
+# Function to check nginx config
+check_nginx_config() {
+    log_header "Nginx Configuration"
+    
+    # Check nginx config inside container
+    docker exec $CONTAINER_NAME nginx -T 2>/dev/null | grep -A 10 "location /api" || {
+        log_error "Failed to get nginx configuration"
+        return 1
+    }
+    
+    # Check nginx process
+    docker exec $CONTAINER_NAME ps aux | grep "[n]ginx" || {
+        log_error "Nginx process not running"
+        return 1
+    }
+    
+    return 0
+}
+
+# Function to wait for webxr to be ready
+wait_for_webxr() {
+    local max_attempts=30
+    local attempt=1
+    local delay=2
+    
+    log_info "Waiting for webxr container to be ready..."
+    
+    while [ $attempt -le $max_attempts ]; do
+        if docker logs $CONTAINER_NAME 2>&1 | grep -q "Frontend is healthy"; then
+            log_success "webxr container is ready"
+            return 0
+        fi
+        log_info "Attempt $attempt/$max_attempts: webxr not ready yet, waiting ${delay}s..."
+        sleep $delay
+        ((attempt++))
+    done
+    
+    log_error "Timed out waiting for webxr container to be ready"
+    docker logs $CONTAINER_NAME
+    return 1
+}
+
+# Function to test Cloudflare tunnel
+test_cloudflare_tunnel() {
+    log_header "Testing Cloudflare Tunnel"
+    
+    # Check if cloudflared container is running
+    if ! docker ps -q -f name="^/cloudflared-tunnel$" > /dev/null 2>&1; then
+        log_error "Cloudflared tunnel container is not running"
+        return 1
+    }
+    log_success "Cloudflared tunnel container is running"
+
+    # Get tunnel URL from cloudflared logs
+    local tunnel_url=$(docker logs cloudflared-tunnel 2>&1 | grep -o 'https://[^ ]*\.trycloudflare\.com' | tail -n1)
+    if [ -z "$tunnel_url" ]; then
+        log_error "Could not find tunnel URL in cloudflared logs"
+        return 1
+    }
+    log_success "Found tunnel URL: $tunnel_url"
+
+    # Test tunnel endpoint
+    local response=$(curl -s -o /dev/null -w "%{http_code}" "$tunnel_url" || echo "000")
+    if [ "$response" = "200" ]; then
+        log_success "Tunnel endpoint is accessible"
+    else
+        log_error "Tunnel endpoint returned HTTP $response"
+        return 1
+    }
+}
+
+# Main execution
+main() {
+    local start_time=$(date +%s)
+    log_header "Starting endpoint tests"
+
+    # Wait for WebXR to be ready
+    wait_for_webxr || {
+        log_error "WebXR container is not ready"
+        exit 1
+    }
+
+    # Test Cloudflare tunnel first
+    test_cloudflare_tunnel || warn "Cloudflare tunnel test failed"
+
+    # Test each environment
+    for env in "${!ENDPOINTS[@]}"; do
+        test_environment "$env" || warn "Tests for $env environment failed"
+    done
+
+    # Test backend directly
+    test_backend_directly || warn "Backend tests failed"
+
+    # Test container internal endpoints
+    test_container_endpoints || warn "Container internal endpoint tests failed"
+
+    # Test RAGFlow network connectivity
+    test_ragflow_connectivity || warn "RAGFlow network connectivity tests failed"
+
+    # If any tests failed, show logs again
+    if [ $? -ne 0 ]; then
+        log_header "Test Failed - Showing Recent Logs"
+        check_container_logs "$CONTAINER_NAME" 100
+    fi
+
+    # Final summary
+    log_header "Test Summary"
+    if [ $? -eq 0 ]; then
+        log_success "All tests passed!"
+        exit 0
+    else
+        log_error "Some tests failed"
+        exit 1
+    fi
+}
+
+# Make script executable
+chmod +x "$0"
+
+# Run main function
+main
diff --git a/scripts/test_endpoints.sh b/scripts/test_endpoints.sh
deleted file mode 100755
index 9d48f2fb..00000000
--- a/scripts/test_endpoints.sh
+++ /dev/null
@@ -1,252 +0,0 @@
-#!/bin/bash
-
-# Enable error reporting
-set -e
-
-# Color codes for output
-RED='\033[0;31m'
-GREEN='\033[0;32m'
-YELLOW='\033[1;33m'
-BLUE='\033[0;34m'
-NC='\033[0m'
-
-# Configuration
-CONTAINER_NAME="logseq-xr-webxr"
-BACKEND_PORT=3001
-NGINX_PORT=4000
-PUBLIC_DOMAIN="www.visionflow.info"
-RAGFLOW_NETWORK="docker_ragflow"
-TIMEOUT=5
-
-# Function to log messages
-log() {
-    printf "[%s] %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$1"
-}
-
-# Function to safely execute docker commands with timeout
-docker_exec() {
-    timeout $TIMEOUT docker exec "$CONTAINER_NAME" $@ 2>&1 || echo "Command timed out after ${TIMEOUT}s"
-}
-
-# Function to check if port is open
-check_port() {
-    local host="$1"
-    local port="$2"
-    timeout $TIMEOUT bash -c "echo > /dev/tcp/$host/$port" 2>/dev/null
-    return $?
-}
-
-# Function to test endpoint and show response
-test_endpoint() {
-    local url="$1"
-    local description="$2"
-    local extra_opts="${3:-}"
-    local expected_content="${4:-}"
-    
-    log "${BLUE}Testing $description...${NC}"
-    log "URL: $url"
-    
-    # First check if port is open
-    local port=$(echo "$url" | sed -n 's/.*:\([0-9]\+\).*/\1/p')
-    local host=$(echo "$url" | sed -n 's/.*\/\/\([^:\/]*\).*/\1/p')
-    
-    if [ -n "$port" ] && ! check_port "$host" "$port"; then
-        log "${RED}✗ Port $port is not open on $host${NC}"
-        return 1
-    fi
-    
-    # Then try the request
-    local response
-    if [[ -n "$extra_opts" ]]; then
-        response=$(curl -v -m $TIMEOUT -s $extra_opts "$url" 2>&1)
-    else
-        response=$(curl -v -m $TIMEOUT -s "$url" 2>&1)
-    fi
-    local status=$?
-    
-    if [ $status -eq 0 ]; then
-        log "${GREEN}✓ $description successful${NC}"
-        log "Response: $response"
-        
-        # Check for expected content if provided
-        if [ -n "$expected_content" ] && ! echo "$response" | grep -q "$expected_content"; then
-            log "${RED}✗ Expected content not found: $expected_content${NC}"
-            return 1
-        fi
-        
-        return 0
-    else
-        log "${RED}✗ $description failed (status: $status)${NC}"
-        log "Response: $response"
-        return 1
-    fi
-}
-
-# Function to check Nginx logs
-check_nginx_logs() {
-    log "${BLUE}Checking Nginx logs...${NC}"
-    docker_exec tail -n 50 /var/log/nginx/error.log || true
-    docker_exec tail -n 50 /var/log/nginx/access.log || true
-}
-
-# Function to check static files
-check_static_files() {
-    log "${BLUE}Checking static files in container...${NC}"
-    docker_exec ls -la /app/client || true
-    docker_exec cat /app/client/index.html || true
-}
-
-# Function to test backend health
-test_backend() {
-    log "\n${BLUE}=== Testing Internal Backend (Port $BACKEND_PORT) ===${NC}"
-    local failed=0
-    
-    # Check if container is running
-    if ! docker ps | grep -q "$CONTAINER_NAME"; then
-        log "${RED}Container $CONTAINER_NAME is not running${NC}"
-        docker ps
-        return 1
-    fi
-    
-    # Test internal endpoints
-    local response=$(docker_exec curl -s "http://localhost:$BACKEND_PORT/api/graph/data")
-    if [ $? -eq 0 ] && [ -n "$response" ]; then
-        log "${GREEN}✓ Backend /api/graph/data accessible${NC}"
-        log "Response: $response"
-    else
-        log "${RED}✗ Backend /api/graph/data failed${NC}"
-        ((failed++))
-    fi
-    
-    response=$(docker_exec curl -s "http://localhost:$BACKEND_PORT/api/graph/data/paginated?page=0&page_size=10")
-    if [ $? -eq 0 ] && [ -n "$response" ]; then
-        log "${GREEN}✓ Backend /api/graph/data/paginated accessible${NC}"
-        log "Response: $response"
-    else
-        log "${RED}✗ Backend /api/graph/data/paginated failed${NC}"
-        ((failed++))
-    fi
-    
-    return $failed
-}
-
-# Function to test nginx
-test_nginx() {
-    log "\n${BLUE}=== Testing Nginx Proxy (Port $NGINX_PORT) ===${NC}"
-    local failed=0
-    
-    # Check if nginx is running
-    if ! docker_exec pgrep nginx > /dev/null; then
-        log "${RED}Nginx is not running in container${NC}"
-        return 1
-    fi
-    
-    # Check nginx config
-    log "Checking Nginx configuration..."
-    docker_exec nginx -t || true
-    
-    # Check static files
-    check_static_files
-    
-    # Test static file serving
-    test_endpoint "http://localhost:$NGINX_PORT/" "Nginx static files" "" "<!DOCTYPE html>" || ((failed++))
-    test_endpoint "http://localhost:$NGINX_PORT/index.html" "Nginx index.html" "" "<!DOCTYPE html>" || ((failed++))
-    
-    # Test API endpoint
-    test_endpoint "http://localhost:$NGINX_PORT/api/graph/data" "Nginx API proxy" || ((failed++))
-    
-    # Check logs if there were failures
-    if [ $failed -gt 0 ]; then
-        check_nginx_logs
-    fi
-    
-    return $failed
-}
-
-# Function to test network
-test_network() {
-    log "\n${BLUE}=== Testing RAGFlow Network ===${NC}"
-    local failed=0
-    
-    # Get container IP
-    local ip=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$CONTAINER_NAME")
-    if [ -z "$ip" ]; then
-        log "${RED}Failed to get container IP${NC}"
-        return 1
-    fi
-    log "Container IP: $ip"
-    
-    # Test network connectivity
-    test_endpoint "http://$ip:$NGINX_PORT/api/graph/data" "Network API connectivity" || ((failed++))
-    test_endpoint "http://$ip:$NGINX_PORT/" "Network static files" "" "<!DOCTYPE html>" || ((failed++))
-    
-    # Test DNS resolution
-    local dns_response=$(docker run --rm --network "$RAGFLOW_NETWORK" alpine nslookup webxr-client)
-    if [ $? -eq 0 ]; then
-        log "${GREEN}✓ DNS resolution working${NC}"
-        log "DNS Response: $dns_response"
-    else
-        log "${RED}✗ DNS resolution failed${NC}"
-        log "DNS Response: $dns_response"
-        ((failed++))
-    fi
-    
-    return $failed
-}
-
-# Function to test public URL
-test_public() {
-    log "\n${BLUE}=== Testing Public URL ===${NC}"
-    local failed=0
-    
-    # Test HTTPS endpoint
-    test_endpoint "https://$PUBLIC_DOMAIN/api/graph/data" "Public API" "-k" || ((failed++))
-    
-    # Test static files
-    test_endpoint "https://$PUBLIC_DOMAIN/" "Public static files" "-k" "<!DOCTYPE html>" || ((failed++))
-    test_endpoint "https://$PUBLIC_DOMAIN/index.html" "Public index.html" "-k" "<!DOCTYPE html>" || ((failed++))
-    
-    return $failed
-}
-
-# Main execution
-main() {
-    log "${YELLOW}Starting comprehensive endpoint tests...${NC}"
-    local total_failed=0
-    
-    # Run tests in order
-    test_backend
-    local backend_failed=$?
-    ((total_failed += backend_failed))
-    
-    test_nginx
-    local nginx_failed=$?
-    ((total_failed += nginx_failed))
-    
-    test_network
-    local network_failed=$?
-    ((total_failed += network_failed))
-    
-    test_public
-    local public_failed=$?
-    ((total_failed += public_failed))
-    
-    # Print summary
-    echo
-    log "${YELLOW}Test Summary:${NC}"
-    echo "Backend Tests: $([ $backend_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($backend_failed failed)${NC}")"
-    echo "Nginx Tests: $([ $nginx_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($nginx_failed failed)${NC}")"
-    echo "Network Tests: $([ $network_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($network_failed failed)${NC}")"
-    echo "Public URL Tests: $([ $public_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($public_failed failed)${NC}")"
-    
-    if [ $total_failed -eq 0 ]; then
-        log "${GREEN}All tests passed successfully!${NC}"
-        exit 0
-    else
-        log "${RED}${total_failed} tests failed${NC}"
-        exit 1
-    fi
-}
-
-# Run main function
-main
diff --git a/settings.toml b/settings.toml
index b203e685..4f83838b 100644
--- a/settings.toml
+++ b/settings.toml
@@ -1,4 +1,4 @@
-[animations]
+[visualization.animations]
 enable_motion_blur = false
 enable_node_animations = false
 motion_blur_strength = 0.4
@@ -8,43 +8,7 @@ ripple_enabled = false
 edge_animation_enabled = false
 flow_particles_enabled = false
 
-[ar]
-drag_threshold = 0.04
-enable_hand_tracking = true
-enable_haptics = true
-enable_light_estimation = true
-enable_passthrough_portal = false
-enable_plane_detection = true
-enable_scene_understanding = true
-gesture_smoothing = 0.9
-hand_mesh_color = "#FFD700"
-hand_mesh_enabled = true
-hand_mesh_opacity = 0.3
-hand_point_size = 0.01
-hand_ray_color = "#FFD700"
-hand_ray_enabled = true
-hand_ray_width = 0.002
-haptic_intensity = 0.7
-passthrough_brightness = 1
-passthrough_contrast = 1
-passthrough_opacity = 1
-pinch_threshold = 0.015
-plane_color = "#4A90E2"
-plane_opacity = 0.3
-portal_edge_color = "#FFD700"
-portal_edge_width = 0.02
-portal_size = 1
-room_scale = true
-rotation_threshold = 0.08
-show_plane_overlay = true
-snap_to_floor = true
-
-[audio]
-enable_ambient_sounds = false
-enable_interaction_sounds = false
-enable_spatial_audio = false
-
-[bloom]
+[visualization.bloom]
 edge_bloom_strength = 0.3
 enabled = false
 environment_bloom_strength = 0.5
@@ -77,30 +41,39 @@ base_width = 2
 color = "#917f18"
 enable_arrows = false
 opacity = 0.6
-width_range = [
-    1,
-    3,
-]
+width_range = [1, 3]
 
-[labels]
+[visualization.hologram]
+xr_quality = "medium"
+desktop_quality = "high"
+ring_count = 3
+ring_color = "#00FFFF"
+ring_opacity = 0.5
+ring_sizes = [1.0, 1.5, 2.0]
+ring_rotation_speed = 0.1
+enable_buckminster = true
+buckminster_scale = 1.0
+buckminster_opacity = 0.3
+enable_geodesic = true
+geodesic_scale = 1.2
+geodesic_opacity = 0.4
+enable_triangle_sphere = true
+triangle_sphere_scale = 1.1
+triangle_sphere_opacity = 0.35
+global_rotation_speed = 0.05
+
+[visualization.labels]
 desktop_font_size = 48
 enable_labels = true
 text_color = "#FFFFFF"
+text_rendering_mode = "sdf"
+text_resolution = 64
+text_padding = 4
+text_outline_width = 0.4
+text_outline_color = "#000000"
+billboard_mode = "camera"
 
-[network]
-bind_address = "0.0.0.0"
-domain = "localhost"
-enable_http2 = false
-enable_rate_limiting = true
-enable_tls = false
-max_request_size = 10485760
-min_tls_version = ""
-port = 3001
-rate_limit_requests = 100
-rate_limit_window = 60
-tunnel_id = "dummy"
-
-[nodes]
+[visualization.nodes]
 base_color = "#c3ab6f"
 base_size = 1
 clearcoat = 1
@@ -114,12 +87,15 @@ metalness = 0.3
 opacity = 0.4
 roughness = 0.35
 size_by_connections = true
-size_range = [
-    1,
-    5,
-]
+size_range = [1, 5]
+use_metadata_size = true
+use_metadata_shape = true
+use_metadata_color = true
+shape_age_ranges = [7, 30, 90, 365]
+hyperlink_color_min = "#c3ab6f"
+hyperlink_color_max = "#822626"
 
-[physics]
+[visualization.physics]
 attraction_strength = 0.015
 bounds_size = 12
 collision_radius = 0.25
@@ -131,7 +107,7 @@ max_velocity = 2.5
 repulsion_strength = 1500
 spring_strength = 0.018
 
-[rendering]
+[visualization.rendering]
 ambient_light_intensity = 0.7
 background_color = "#000000"
 directional_light_intensity = 1
@@ -140,8 +116,76 @@ enable_antialiasing = true
 enable_shadows = false
 environment_intensity = 1.2
 
-[security]
-allowed_origins = []
+[xr]
+mode = "immersive-ar"
+room_scale = true
+space_type = "local-floor"
+quality = "medium"
+
+[xr.input]
+enable_hand_tracking = true
+enable_haptics = true
+haptic_intensity = 0.7
+drag_threshold = 0.04
+pinch_threshold = 0.015
+rotation_threshold = 0.08
+interaction_radius = 0.5
+
+[xr.visuals]
+hand_mesh_enabled = true
+hand_mesh_color = "#FFD700"
+hand_mesh_opacity = 0.3
+hand_point_size = 0.01
+hand_ray_enabled = true
+hand_ray_color = "#FFD700"
+hand_ray_width = 0.002
+gesture_smoothing = 0.9
+
+[xr.environment]
+enable_light_estimation = true
+enable_plane_detection = true
+enable_scene_understanding = true
+plane_color = "#4A90E2"
+plane_opacity = 0.3
+show_plane_overlay = true
+snap_to_floor = true
+
+[xr.passthrough]
+enabled = false
+opacity = 1.0
+brightness = 1.0
+contrast = 1.0
+portal_size = 1.0
+portal_edge_color = "#FFD700"
+portal_edge_width = 0.02
+
+[system.network]
+bind_address = "0.0.0.0"
+domain = "localhost"
+enable_http2 = false
+enable_rate_limiting = true
+enable_tls = false
+max_request_size = 10485760
+min_tls_version = ""
+port = 3001
+rate_limit_requests = 100
+rate_limit_window = 60
+tunnel_id = "dummy"
+
+[system.websocket]
+binary_chunk_size = 65536
+compression_enabled = false
+compression_threshold = 1024
+heartbeat_interval = 15000
+heartbeat_timeout = 60000
+max_connections = 100
+max_message_size = 100485760
+reconnect_attempts = 3
+reconnect_delay = 5000
+update_rate = 1
+
+[system.security]
+allowed_origins = ["*"]
 audit_log_path = "/app/logs/audit.log"
 cookie_httponly = true
 cookie_samesite = "Strict"
diff --git a/src/app_state.rs b/src/app_state.rs
index 713c8493..20a0e38f 100755
--- a/src/app_state.rs
+++ b/src/app_state.rs
@@ -1,10 +1,11 @@
 use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
 use tokio::sync::RwLock;
+use log::{info, warn};
 
 use crate::config::Settings;
 use crate::models::metadata::MetadataStore;
 use crate::services::graph_service::GraphService;
-use crate::services::file_service::RealGitHubService;
+use crate::services::file_service::{FileService, RealGitHubService};
 use crate::services::github_service::RealGitHubPRService;
 use crate::services::perplexity_service::PerplexityService;
 use crate::services::ragflow_service::RAGFlowService;
@@ -12,7 +13,7 @@ use crate::utils::gpu_compute::GPUCompute;
 
 #[derive(Clone)]
 pub struct AppState {
-    pub graph_service: GraphService,
+    pub graph_service: Arc<GraphService>,
     pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
     pub settings: Arc<RwLock<Settings>>,
     pub metadata: Arc<RwLock<MetadataStore>>,
@@ -25,7 +26,7 @@ pub struct AppState {
 }
 
 impl AppState {
-    pub fn new(
+    pub async fn new(
         settings: Arc<RwLock<Settings>>,
         github_service: Arc<RealGitHubService>,
         perplexity_service: Option<Arc<PerplexityService>>,
@@ -34,11 +35,26 @@ impl AppState {
         ragflow_conversation_id: String,
         github_pr_service: Arc<RealGitHubPRService>,
     ) -> Self {
+        // Load metadata first
+        let metadata_store = match FileService::load_or_create_metadata() {
+            Ok(metadata) => {
+                info!("Loaded metadata with {} entries", metadata.len());
+                metadata
+            },
+            Err(e) => {
+                warn!("Failed to load metadata: {}, starting with empty store", e);
+                MetadataStore::new()
+            }
+        };
+
+        // Initialize graph service with metadata
+        let graph_service = Arc::new(GraphService::new_with_metadata(&metadata_store).await);
+
         Self {
-            graph_service: GraphService::new(),
+            graph_service,
             gpu_compute,
             settings,
-            metadata: Arc::new(RwLock::new(MetadataStore::new())),
+            metadata: Arc::new(RwLock::new(metadata_store)),
             github_service,
             perplexity_service,
             ragflow_service,
diff --git a/src/config.rs b/src/config.rs
index 0bbb9530..caea0c69 100755
--- a/src/config.rs
+++ b/src/config.rs
@@ -6,7 +6,32 @@ use std::path::PathBuf;
 #[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "snake_case")]
 pub struct Settings {
-    // UI/Rendering settings from settings.toml
+    // Core visualization settings
+    #[serde(default)]
+    pub visualization: VisualizationSettings,
+
+    // XR-specific settings
+    #[serde(default)]
+    pub xr: XRSettings,
+
+    // System settings
+    #[serde(default)]
+    pub system: SystemSettings,
+
+    // Service settings from .env (server-side only)
+    #[serde(default)]
+    pub github: GitHubSettings,
+    #[serde(default)]
+    pub ragflow: RagFlowSettings,
+    #[serde(default)]
+    pub perplexity: PerplexitySettings,
+    #[serde(default)]
+    pub openai: OpenAISettings,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+pub struct VisualizationSettings {
     #[serde(default)]
     pub animations: AnimationSettings,
     #[serde(default)]
@@ -16,37 +41,100 @@ pub struct Settings {
     #[serde(default)]
     pub bloom: BloomSettings,
     #[serde(default)]
-    pub client_debug: DebugSettings,
-    #[serde(default)]
-    pub default: DefaultSettings,
-    #[serde(default)]
     pub edges: EdgeSettings,
     #[serde(default)]
-    pub labels: LabelSettings,
+    pub hologram: HologramSettings,
     #[serde(default)]
-    pub network: NetworkSettings,
+    pub labels: LabelSettings,
     #[serde(default)]
     pub nodes: NodeSettings,
     #[serde(default)]
     pub physics: PhysicsSettings,
     #[serde(default)]
     pub rendering: RenderingSettings,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+pub struct XRSettings {
     #[serde(default)]
-    pub security: SecuritySettings,
+    pub mode: String,
     #[serde(default)]
-    pub server_debug: DebugSettings,
+    pub room_scale: bool,
     #[serde(default)]
-    pub websocket: WebSocketSettings,
-    
-    // Service settings from .env (server-side only)
+    pub space_type: String,
     #[serde(default)]
-    pub github: GitHubSettings,
+    pub quality: String,
     #[serde(default)]
-    pub ragflow: RagFlowSettings,
+    pub input: XRInputSettings,
     #[serde(default)]
-    pub perplexity: PerplexitySettings,
+    pub visuals: XRVisualSettings,
     #[serde(default)]
-    pub openai: OpenAISettings,
+    pub environment: XREnvironmentSettings,
+    #[serde(default)]
+    pub passthrough: XRPassthroughSettings,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XRInputSettings {
+    pub enable_hand_tracking: bool,
+    pub enable_haptics: bool,
+    pub haptic_intensity: f32,
+    pub drag_threshold: f32,
+    pub pinch_threshold: f32,
+    pub rotation_threshold: f32,
+    pub interaction_radius: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XRVisualSettings {
+    pub hand_mesh_enabled: bool,
+    pub hand_mesh_color: String,
+    pub hand_mesh_opacity: f32,
+    pub hand_point_size: f32,
+    pub hand_ray_enabled: bool,
+    pub hand_ray_color: String,
+    pub hand_ray_width: f32,
+    pub gesture_smoothing: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XREnvironmentSettings {
+    pub enable_light_estimation: bool,
+    pub enable_plane_detection: bool,
+    pub enable_scene_understanding: bool,
+    pub plane_color: String,
+    pub plane_opacity: f32,
+    pub show_plane_overlay: bool,
+    pub snap_to_floor: bool,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XRPassthroughSettings {
+    pub enabled: bool,
+    pub opacity: f32,
+    pub brightness: f32,
+    pub contrast: f32,
+    pub portal_size: f32,
+    pub portal_edge_color: String,
+    pub portal_edge_width: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+pub struct SystemSettings {
+    #[serde(default)]
+    pub network: NetworkSettings,
+    #[serde(default)]
+    pub websocket: WebSocketSettings,
+    #[serde(default)]
+    pub security: SecuritySettings,
+    #[serde(default)]
+    pub debug: DebugSettings,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
@@ -283,6 +371,7 @@ pub struct ARSettings {
     pub hand_ray_enabled: bool,
     pub hand_ray_width: f32,
     pub haptic_intensity: f32,
+    pub interaction_radius: f32,
     pub passthrough_brightness: f32,
     pub passthrough_contrast: f32,
     pub passthrough_opacity: f32,
@@ -308,7 +397,7 @@ impl Default for ARSettings {
             enable_passthrough_portal: false,
             enable_plane_detection: true,
             enable_scene_understanding: true,
-            gesture_smoothing: 0.5,
+            gesture_smoothing: 0.9,
             hand_mesh_color: "#FFD700".to_string(),
             hand_mesh_enabled: true,
             hand_mesh_opacity: 0.3,
@@ -317,15 +406,16 @@ impl Default for ARSettings {
             hand_ray_enabled: true,
             hand_ray_width: 0.002,
             haptic_intensity: 0.7,
+            interaction_radius: 0.5,
             passthrough_brightness: 1.0,
             passthrough_contrast: 1.0,
-            passthrough_opacity: 0.8,
+            passthrough_opacity: 1.0,
             pinch_threshold: 0.015,
-            plane_color: "#808080".to_string(),
-            plane_opacity: 0.5,
-            portal_edge_color: "#00FF00".to_string(),
+            plane_color: "#4A90E2".to_string(),
+            plane_opacity: 0.3,
+            portal_edge_color: "#FFD700".to_string(),
             portal_edge_width: 0.02,
-            portal_size: 2.0,
+            portal_size: 1.0,
             room_scale: true,
             rotation_threshold: 0.08,
             show_plane_overlay: true,
@@ -382,6 +472,8 @@ impl Default for BloomSettings {
 #[serde(rename_all = "snake_case")]
 #[serde(default)]
 pub struct EdgeSettings {
+    pub arrow_size: f32,
+    pub base_width: f32,
     pub color: String,
     pub enable_arrows: bool,
     pub opacity: f32,
@@ -391,6 +483,8 @@ pub struct EdgeSettings {
 impl Default for EdgeSettings {
     fn default() -> Self {
         Self {
+            arrow_size: 0.2,
+            base_width: 2.0,
             color: "#917f18".to_string(),
             enable_arrows: false,
             opacity: 0.6,
@@ -406,6 +500,12 @@ pub struct LabelSettings {
     pub desktop_font_size: u32,
     pub enable_labels: bool,
     pub text_color: String,
+    pub text_rendering_mode: String,
+    pub text_resolution: u32,
+    pub text_padding: u32,
+    pub text_outline_width: f32,
+    pub text_outline_color: String,
+    pub billboard_mode: String,
 }
 
 impl Default for LabelSettings {
@@ -414,6 +514,12 @@ impl Default for LabelSettings {
             desktop_font_size: 48,
             enable_labels: true,
             text_color: "#FFFFFF".to_string(),
+            text_rendering_mode: "sdf".to_string(),
+            text_resolution: 64,
+            text_padding: 4,
+            text_outline_width: 0.4,
+            text_outline_color: "#000000".to_string(),
+            billboard_mode: "camera".to_string(),
         }
     }
 }
@@ -424,6 +530,7 @@ impl Default for LabelSettings {
 pub struct NodeSettings {
     pub base_color: String,
     pub base_size: f32,
+    pub clearcoat: f32,
     pub enable_hover_effect: bool,
     pub enable_instancing: bool,
     pub highlight_color: String,
@@ -435,6 +542,12 @@ pub struct NodeSettings {
     pub roughness: f32,
     pub size_by_connections: bool,
     pub size_range: Vec<f32>,
+    pub use_metadata_size: bool,
+    pub use_metadata_shape: bool,
+    pub use_metadata_color: bool,
+    pub shape_age_ranges: Vec<u32>,
+    pub hyperlink_color_min: String,
+    pub hyperlink_color_max: String,
 }
 
 impl Default for NodeSettings {
@@ -442,6 +555,7 @@ impl Default for NodeSettings {
         Self {
             base_color: "#c3ab6f".to_string(),
             base_size: 1.0,
+            clearcoat: 0.5,
             enable_hover_effect: false,
             enable_instancing: false,
             highlight_color: "#822626".to_string(),
@@ -452,7 +566,13 @@ impl Default for NodeSettings {
             opacity: 0.4,
             roughness: 0.35,
             size_by_connections: true,
-            size_range: vec![1.0, 10.0],
+            size_range: vec![1.0, 5.0],
+            use_metadata_size: true,
+            use_metadata_shape: true,
+            use_metadata_color: true,
+            shape_age_ranges: vec![7, 30, 90, 365],
+            hyperlink_color_min: "#c3ab6f".to_string(),
+            hyperlink_color_max: "#822626".to_string(),
         }
     }
 }
@@ -548,6 +668,56 @@ impl Default for SecuritySettings {
     }
 }
 
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+#[serde(default)]
+pub struct HologramSettings {
+    pub xr_quality: String,
+    pub desktop_quality: String,
+    pub ring_count: u32,
+    pub ring_color: String,
+    pub ring_opacity: f32,
+    pub ring_sizes: Vec<f32>,
+    pub ring_rotation_speed: f32,
+    pub enable_buckminster: bool,
+    pub buckminster_scale: f32,
+    pub buckminster_opacity: f32,
+    pub enable_geodesic: bool,
+    pub geodesic_scale: f32,
+    pub geodesic_opacity: f32,
+    pub enable_triangle_sphere: bool,
+    pub triangle_sphere_scale: f32,
+    pub triangle_sphere_opacity: f32,
+    pub global_rotation_speed: f32,
+}
+
+impl Default for HologramSettings {
+    fn default() -> Self {
+        Self {
+            xr_quality: "medium".to_string(),
+            desktop_quality: "high".to_string(),
+            ring_count: 3,
+            ring_color: "#00FFFF".to_string(),
+            ring_opacity: 0.5,
+            ring_sizes: vec![1.0, 1.5, 2.0],
+            ring_rotation_speed: 0.1,
+            enable_buckminster: true,
+            buckminster_scale: 1.0,
+            buckminster_opacity: 0.3,
+            enable_geodesic: true,
+            geodesic_scale: 1.2,
+            geodesic_opacity: 0.4,
+            enable_triangle_sphere: true,
+            triangle_sphere_scale: 1.1,
+            triangle_sphere_opacity: 0.35,
+            global_rotation_speed: 0.05,
+        }
+    }
+}
+
+// Note: Connection keep-alive is handled by WebSocket protocol-level ping/pong frames
+// automatically by the actix-web-actors framework on the server and browser WebSocket API
+// on the client. No custom heartbeat implementation is needed.
 #[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "snake_case")]
 #[serde(default)]
@@ -555,8 +725,6 @@ pub struct WebSocketSettings {
     pub binary_chunk_size: usize,
     pub compression_enabled: bool,
     pub compression_threshold: usize,
-    pub heartbeat_interval: u64,
-    pub heartbeat_timeout: u64,
     pub max_connections: usize,
     pub max_message_size: usize,
     pub reconnect_attempts: u32,
@@ -570,8 +738,6 @@ impl Default for WebSocketSettings {
             binary_chunk_size: 65536,
             compression_enabled: true,
             compression_threshold: 1024,
-            heartbeat_interval: 15000,
-            heartbeat_timeout: 60000,
             max_connections: 1000,
             max_message_size: 100485760,
             reconnect_attempts: 3,
@@ -584,17 +750,25 @@ impl Default for WebSocketSettings {
 impl Settings {
     pub fn new() -> Result<Self, ConfigError> {
         debug!("Initializing settings");
-        
+
         // Load .env file first
         dotenvy::dotenv().ok();
-        
-        // Use environment variable or default to /app/settings.toml
+
+        // Use environment variable or try multiple paths
         let settings_path = std::env::var("SETTINGS_FILE_PATH")
             .map(PathBuf::from)
-            .unwrap_or_else(|_| PathBuf::from("/app/settings.toml"));
-        
+            .unwrap_or_else(|_| {
+                // Try current directory first, then /app/settings.toml
+                let current_dir_path = PathBuf::from("settings.toml");
+                if current_dir_path.exists() {
+                    current_dir_path
+                } else {
+                    PathBuf::from("/app/settings.toml")
+                }
+            });
+
         debug!("Loading settings from: {:?}", settings_path);
-        
+
         let builder = ConfigBuilder::<config::builder::DefaultState>::default();
         let config = builder
             .add_source(File::from(settings_path))
@@ -616,25 +790,25 @@ impl Settings {
                 return Err(e);
             }
         };
-        
+
         debug!("Checking for environment variables");
-        
+
         // Network settings from environment variables
-        if let Ok(domain) = std::env::var("DOMAIN") {
-            settings.network.domain = domain;
-        }
-        if let Ok(port) = std::env::var("PORT") {
-            settings.network.port = port.parse().unwrap_or(4000);
-        }
-        if let Ok(bind_address) = std::env::var("BIND_ADDRESS") {
-            settings.network.bind_address = bind_address;
-        }
-        if let Ok(tunnel_id) = std::env::var("TUNNEL_ID") {
-            settings.network.tunnel_id = tunnel_id;
-        }
-        if let Ok(enable_http2) = std::env::var("HTTP2_ENABLED") {
-            settings.network.enable_http2 = enable_http2.parse().unwrap_or(true);
-        }
+            if let Ok(domain) = std::env::var("DOMAIN") {
+                settings.system.network.domain = domain;
+            }
+            if let Ok(port) = std::env::var("PORT") {
+                settings.system.network.port = port.parse().unwrap_or(4000);
+            }
+            if let Ok(bind_address) = std::env::var("BIND_ADDRESS") {
+                settings.system.network.bind_address = bind_address;
+            }
+            if let Ok(tunnel_id) = std::env::var("TUNNEL_ID") {
+                settings.system.network.tunnel_id = tunnel_id;
+            }
+            if let Ok(enable_http2) = std::env::var("HTTP2_ENABLED") {
+                settings.system.network.enable_http2 = enable_http2.parse().unwrap_or(true);
+            }
 
         // GitHub settings from environment variables
         if let Ok(token) = std::env::var("GITHUB_TOKEN") {
@@ -738,27 +912,149 @@ impl Settings {
 }
 
 impl Default for Settings {
+    fn default() -> Self {
+        Self {
+            visualization: VisualizationSettings {
+                animations: AnimationSettings::default(),
+                ar: ARSettings::default(),
+                audio: AudioSettings::default(),
+                bloom: BloomSettings::default(),
+                edges: EdgeSettings::default(),
+                hologram: HologramSettings::default(),
+                labels: LabelSettings::default(),
+                nodes: NodeSettings::default(),
+                physics: PhysicsSettings::default(),
+                rendering: RenderingSettings::default(),
+            },
+            xr: XRSettings {
+                mode: "immersive-ar".to_string(),
+                room_scale: true,
+                space_type: "local-floor".to_string(),
+                quality: "medium".to_string(),
+                input: XRInputSettings {
+                    enable_hand_tracking: true,
+                    enable_haptics: true,
+                    haptic_intensity: 0.7,
+                    drag_threshold: 0.04,
+                    pinch_threshold: 0.015,
+                    rotation_threshold: 0.08,
+                    interaction_radius: 0.5,
+                },
+                visuals: XRVisualSettings {
+                    hand_mesh_enabled: true,
+                    hand_mesh_color: "#FFD700".to_string(),
+                    hand_mesh_opacity: 0.3,
+                    hand_point_size: 0.01,
+                    hand_ray_enabled: true,
+                    hand_ray_color: "#FFD700".to_string(),
+                    hand_ray_width: 0.002,
+                    gesture_smoothing: 0.9,
+                },
+                environment: XREnvironmentSettings {
+                    enable_light_estimation: true,
+                    enable_plane_detection: true,
+                    enable_scene_understanding: true,
+                    plane_color: "#4A90E2".to_string(),
+                    plane_opacity: 0.3,
+                    show_plane_overlay: true,
+                    snap_to_floor: true,
+                },
+                passthrough: XRPassthroughSettings {
+                    enabled: false,
+                    opacity: 1.0,
+                    brightness: 1.0,
+                    contrast: 1.0,
+                    portal_size: 1.0,
+                    portal_edge_color: "#FFD700".to_string(),
+                    portal_edge_width: 0.02,
+                },
+            },
+            system: SystemSettings {
+                network: NetworkSettings::default(),
+                websocket: WebSocketSettings::default(),
+                security: SecuritySettings::default(),
+                debug: DebugSettings::default(),
+            },
+            github: GitHubSettings::default(),
+            ragflow: RagFlowSettings::default(),
+            perplexity: PerplexitySettings::default(),
+            openai: OpenAISettings::default(),
+        }
+    }
+}
+
+impl Default for VisualizationSettings {
     fn default() -> Self {
         Self {
             animations: AnimationSettings::default(),
             ar: ARSettings::default(),
             audio: AudioSettings::default(),
             bloom: BloomSettings::default(),
-            client_debug: DebugSettings::default(),
-            default: DefaultSettings::default(),
             edges: EdgeSettings::default(),
+            hologram: HologramSettings::default(),
             labels: LabelSettings::default(),
             nodes: NodeSettings::default(),
             physics: PhysicsSettings::default(),
             rendering: RenderingSettings::default(),
-            security: SecuritySettings::default(),
-            server_debug: DebugSettings::default(),
-            websocket: WebSocketSettings::default(),
+        }
+    }
+}
+
+impl Default for XRSettings {
+    fn default() -> Self {
+        Self {
+            mode: "immersive-ar".to_string(),
+            room_scale: true,
+            space_type: "local-floor".to_string(),
+            quality: "medium".to_string(),
+            input: XRInputSettings {
+                enable_hand_tracking: true,
+                enable_haptics: true,
+                haptic_intensity: 0.7,
+                drag_threshold: 0.04,
+                pinch_threshold: 0.015,
+                rotation_threshold: 0.08,
+                interaction_radius: 0.5,
+            },
+            visuals: XRVisualSettings {
+                hand_mesh_enabled: true,
+                hand_mesh_color: "#FFD700".to_string(),
+                hand_mesh_opacity: 0.3,
+                hand_point_size: 0.01,
+                hand_ray_enabled: true,
+                hand_ray_color: "#FFD700".to_string(),
+                hand_ray_width: 0.002,
+                gesture_smoothing: 0.9,
+            },
+            environment: XREnvironmentSettings {
+                enable_light_estimation: true,
+                enable_plane_detection: true,
+                enable_scene_understanding: true,
+                plane_color: "#4A90E2".to_string(),
+                plane_opacity: 0.3,
+                show_plane_overlay: true,
+                snap_to_floor: true,
+            },
+            passthrough: XRPassthroughSettings {
+                enabled: false,
+                opacity: 1.0,
+                brightness: 1.0,
+                contrast: 1.0,
+                portal_size: 1.0,
+                portal_edge_color: "#FFD700".to_string(),
+                portal_edge_width: 0.02,
+            },
+        }
+    }
+}
+
+impl Default for SystemSettings {
+    fn default() -> Self {
+        Self {
             network: NetworkSettings::default(),
-            github: GitHubSettings::default(),
-            ragflow: RagFlowSettings::default(),
-            perplexity: PerplexitySettings::default(),
-            openai: OpenAISettings::default(),
+            websocket: WebSocketSettings::default(),
+            security: SecuritySettings::default(),
+            debug: DebugSettings::default(),
         }
     }
 }
diff --git a/src/handlers/file_handler.rs b/src/handlers/file_handler.rs
index 586fd2aa..d8878895 100755
--- a/src/handlers/file_handler.rs
+++ b/src/handlers/file_handler.rs
@@ -1,4 +1,4 @@
-use actix_web::{web, Error as ActixError, HttpResponse};
+use actix_web::{web::{self, ServiceConfig}, Error as ActixError, HttpResponse};
 use serde_json::json;
 use log::{info, debug, error};
 
@@ -93,7 +93,7 @@ pub async fn fetch_and_process_files(state: web::Data<AppState>) -> HttpResponse
 pub async fn get_file_content(_state: web::Data<AppState>, file_name: web::Path<String>) -> HttpResponse {
     // Read file directly from disk
     let file_path = format!("{}/{}", MARKDOWN_DIR, file_name);
-    match std::fs::read_to_string(&file_path) {
+    match tokio::fs::read_to_string(&file_path).await {
         Ok(content) => HttpResponse::Ok().body(content),
         Err(e) => {
             error!("Failed to read file {}: {}", file_name, e);
@@ -152,6 +152,13 @@ pub async fn refresh_graph(state: web::Data<AppState>) -> HttpResponse {
     }
 }
 
+pub fn config(cfg: &mut ServiceConfig) {
+    cfg.service(web::resource("/fetch").to(fetch_and_process_files))
+       .service(web::resource("/content/{file_name}").to(get_file_content))
+       .service(web::resource("/refresh").to(refresh_graph))
+       .service(web::resource("/update").to(update_graph));
+}
+
 pub async fn update_graph(state: web::Data<AppState>) -> Result<HttpResponse, ActixError> {
     // Load metadata from file
     let metadata_store = match FileService::load_or_create_metadata() {
diff --git a/src/handlers/graph_handler.rs b/src/handlers/graph_handler.rs
index 7ab98ccd..258501fa 100755
--- a/src/handlers/graph_handler.rs
+++ b/src/handlers/graph_handler.rs
@@ -1,4 +1,4 @@
-use actix_web::{web, HttpResponse, Responder};
+use actix_web::{web::{self, ServiceConfig}, HttpResponse, Responder};
 use crate::AppState;
 use serde::{Serialize, Deserialize};
 use log::{info, debug, error, warn};
@@ -177,6 +177,15 @@ pub async fn refresh_graph(state: web::Data<AppState>) -> impl Responder {
 }
 
 // Fetch new metadata and rebuild graph
+pub fn config(cfg: &mut ServiceConfig) {
+    cfg.service(web::resource("/data").to(get_graph_data))
+       .service(web::resource("/data/paginated").to(get_paginated_graph_data))
+       .service(
+           web::resource("/update")
+               .route(web::post().to(update_graph))
+       );
+}
+
 pub async fn update_graph(state: web::Data<AppState>) -> impl Responder {
     info!("Received request to update graph");
     
diff --git a/src/handlers/mod.rs b/src/handlers/mod.rs
index 1316eebf..d47d5a95 100755
--- a/src/handlers/mod.rs
+++ b/src/handlers/mod.rs
@@ -2,5 +2,5 @@ pub mod file_handler;
 pub mod graph_handler;
 pub mod perplexity_handler;
 pub mod ragflow_handler;
+pub mod settings;
 pub mod socket_flow_handler;
-pub mod visualization_handler;
diff --git a/src/handlers/settings/common.rs b/src/handlers/settings/common.rs
new file mode 100644
index 00000000..16fb26f1
--- /dev/null
+++ b/src/handlers/settings/common.rs
@@ -0,0 +1,154 @@
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use std::collections::HashMap;
+use log::{error, debug};
+use crate::config::Settings;
+use convert_case::{Case, Casing};
+
+// Convert kebab-case from API to snake_case for internal use
+pub fn to_snake_case(s: &str) -> String {
+    s.to_case(Case::Snake)
+}
+
+// Convert snake_case to kebab-case for API responses
+pub fn to_kebab_case(s: &str) -> String {
+    s.to_case(Case::Kebab)
+}
+
+// Convert nested object keys from snake_case to kebab-case
+pub fn convert_to_kebab_case(value: Value) -> Value {
+    match value {
+        Value::Object(obj) => {
+            let mut new_obj = serde_json::Map::new();
+            for (k, v) in obj {
+                let kebab_key = to_kebab_case(&k);
+                new_obj.insert(kebab_key, convert_to_kebab_case(v));
+            }
+            Value::Object(new_obj)
+        }
+        Value::Array(arr) => Value::Array(
+            arr.into_iter()
+               .map(convert_to_kebab_case)
+               .collect()
+        ),
+        v => v,
+    }
+}
+
+// Convert nested object keys from kebab-case to snake_case
+pub fn convert_to_snake_case(value: Value) -> Value {
+    match value {
+        Value::Object(obj) => {
+            let mut new_obj = serde_json::Map::new();
+            for (k, v) in obj {
+                let snake_key = to_snake_case(&k);
+                new_obj.insert(snake_key, convert_to_snake_case(v));
+            }
+            Value::Object(new_obj)
+        }
+        Value::Array(arr) => Value::Array(
+            arr.into_iter()
+               .map(convert_to_snake_case)
+               .collect()
+        ),
+        v => v,
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SettingResponse {
+    pub category: String,
+    pub setting: String,
+    pub value: Value,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CategorySettingsResponse {
+    pub category: String,
+    pub settings: HashMap<String, Value>,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CategorySettingsUpdate {
+    pub settings: HashMap<String, Value>,
+}
+
+pub fn get_category_settings_value(settings: &Settings, category: &str) -> Result<Value, String> {
+    debug!("Getting settings for category: {}", category);
+    let category_snake = to_snake_case(category);
+    
+    let settings_value = serde_json::to_value(settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    let category_value = settings_value.get(&category_snake)
+        .ok_or_else(|| format!("Category '{}' not found", category))?;
+    
+    // Convert response to kebab-case
+    Ok(convert_to_kebab_case(category_value.clone()))
+}
+
+pub fn get_setting_value(settings: &Settings, category: &str, setting: &str) -> Result<Value, String> {
+    debug!("Getting setting value for {}.{}", category, setting);
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    let category_value = get_category_settings_value(settings, &category_snake)?;
+    
+    let setting_value = category_value.get(&setting_snake)
+        .ok_or_else(|| format!("Setting '{}' not found", setting))?;
+    
+    // Convert response to kebab-case
+    Ok(convert_to_kebab_case(setting_value.clone()))
+}
+
+pub fn update_setting_value(settings: &mut Settings, category: &str, setting: &str, value: &Value) -> Result<(), String> {
+    debug!("Updating setting {}.{}", category, setting);
+    
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    // Convert incoming value's keys to snake_case
+    let snake_value = convert_to_snake_case(value.clone());
+    
+    let mut settings_value = serde_json::to_value(&*settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    if let Some(obj) = settings_value.get_mut(&category_snake)
+        .and_then(|v| v.as_object_mut())
+    {
+        obj.insert(setting_snake.clone(), snake_value);
+        *settings = serde_json::from_value(settings_value)
+            .map_err(|e| format!("Failed to deserialize settings: {}", e))?;
+        Ok(())
+    } else {
+        Err(format!("Category '{}' not found or invalid", category))
+    }
+}
+
+pub fn set_field_value<T>(obj: &mut T, field: &str, value: Value) -> Result<(), String> 
+where
+    T: serde::Serialize + serde::de::DeserializeOwned,
+{
+    let map = serde_json::to_value(&*obj)
+        .map_err(|e| format!("Failed to serialize object: {}", e))?
+        .as_object()
+        .ok_or_else(|| "Failed to convert object to map".to_string())?
+        .clone();
+
+    let mut updated_map = map.clone();
+    updated_map.insert(field.to_string(), value);
+
+    *obj = serde_json::from_value(Value::Object(updated_map))
+        .map_err(|e| format!("Failed to deserialize updated object: {}", e))?;
+
+    Ok(())
+}
diff --git a/src/handlers/settings/mod.rs b/src/handlers/settings/mod.rs
new file mode 100644
index 00000000..e5cd65dc
--- /dev/null
+++ b/src/handlers/settings/mod.rs
@@ -0,0 +1,207 @@
+use actix_web::{web, get, put, HttpResponse};
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use log::debug;
+use serde::{Serialize, Deserialize};
+use serde_json::Value;
+use std::collections::HashMap;
+use crate::config::Settings;
+use crate::utils::case_conversion::to_snake_case;
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SettingResponse {
+    pub category: String,
+    pub setting: String,
+    pub value: Value,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CategorySettingsResponse {
+    pub category: String,
+    pub settings: HashMap<String, Value>,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+// Helper function to get all settings
+fn get_all_settings(settings: &Settings) -> Value {
+    debug!("Getting all settings");
+    serde_json::to_value(settings).unwrap_or_default()
+}
+
+// Helper function to get setting value from settings object
+fn get_setting_value(settings: &Settings, category: &str, setting: &str) -> Result<Value, String> {
+    debug!("Getting setting value for {}.{}", category, setting);
+    
+    // Convert kebab-case to snake_case
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    // Convert settings to Value for easier access
+    let settings_value = serde_json::to_value(&settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    // Get category object
+    let category_value = settings_value.get(&category_snake)
+        .ok_or_else(|| format!("Category '{}' not found", category))?;
+    
+    // Get setting value
+    let setting_value = category_value.get(&setting_snake)
+        .ok_or_else(|| format!("Setting '{}' not found in category '{}'", setting, category))?;
+    
+    Ok(setting_value.clone())
+}
+
+// Helper function to update setting value in settings object
+fn update_setting_value(settings: &mut Settings, category: &str, setting: &str, value: &Value) -> Result<(), String> {
+    debug!("Updating setting value for {}.{}", category, setting);
+    
+    // Convert kebab-case to snake_case
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    // Convert settings to Value for manipulation
+    let mut settings_value = serde_json::to_value(&*settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    // Get category object
+    let category_value = settings_value.get_mut(&category_snake)
+        .ok_or_else(|| format!("Category '{}' not found", category))?;
+    
+    // Update setting value
+    if let Some(obj) = category_value.as_object_mut() {
+        obj.insert(setting_snake.clone(), value.clone());
+        
+        // Convert back to Settings
+        *settings = serde_json::from_value(settings_value)
+            .map_err(|e| format!("Failed to deserialize settings: {}", e))?;
+        Ok(())
+    } else {
+        Err(format!("Category '{}' is not an object", category))
+    }
+}
+
+// Helper function to get all settings for a category
+fn get_category_settings(settings: &Settings, category: &str) -> Result<Value, String> {
+    debug!("Getting settings for category: {}", category);
+    
+    // Convert kebab-case to snake_case
+    let category_snake = to_snake_case(category);
+    
+    // Convert settings to Value
+    let settings_value = serde_json::to_value(&settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    // Get category object
+    settings_value.get(&category_snake)
+        .ok_or_else(|| format!("Category '{}' not found", category))
+        .map(|v| v.clone())
+}
+
+// GET /api/settings
+#[get("")]
+async fn get_all_settings_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+) -> HttpResponse {
+    let settings_guard = settings.read().await;
+    let settings_value = get_all_settings(&settings_guard);
+    HttpResponse::Ok().json(settings_value)
+}
+
+// GET /api/settings/{category}/{setting}
+#[get("/{category}/{setting}")]
+async fn get_setting_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    let settings_guard = settings.read().await;
+    
+    match get_setting_value(&settings_guard, &category, &setting) {
+        Ok(value) => HttpResponse::Ok().json(SettingResponse {
+            category,
+            setting,
+            value,
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category,
+            setting,
+            value: Value::Null,
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+// PUT /api/settings/{category}/{setting}
+#[put("/{category}/{setting}")]
+async fn update_setting_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+    value: web::Json<Value>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    let mut settings_guard = settings.write().await;
+    
+    match update_setting_value(&mut settings_guard, &category, &setting, &value) {
+        Ok(_) => HttpResponse::Ok().json(SettingResponse {
+            category,
+            setting,
+            value: value.into_inner(),
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category,
+            setting,
+            value: Value::Null,
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+// GET /api/settings/{category}
+#[get("/{category}")]
+async fn get_category_settings_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<String>,
+) -> HttpResponse {
+    let category = path.into_inner();
+    let settings_guard = settings.read().await;
+    
+    match get_category_settings(&settings_guard, &category) {
+        Ok(settings) => HttpResponse::Ok().json(CategorySettingsResponse {
+            category,
+            settings: settings.as_object()
+                .map(|obj| obj.iter()
+                    .map(|(k, v)| (k.clone(), v.clone()))
+                    .collect::<HashMap<String, Value>>())
+                .unwrap_or_default(),
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(CategorySettingsResponse {
+            category,
+            settings: HashMap::new(),
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+// Register all settings handlers
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(get_all_settings_handler)
+       .service(get_setting_handler)
+       .service(update_setting_handler)
+       .service(get_category_settings_handler);
+}
diff --git a/src/handlers/settings/visualization.rs b/src/handlers/settings/visualization.rs
new file mode 100644
index 00000000..a6977d5e
--- /dev/null
+++ b/src/handlers/settings/visualization.rs
@@ -0,0 +1,216 @@
+use actix_web::{get, put, web, HttpResponse};
+use serde_json::Value;
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use std::collections::HashMap;
+use log::{error, debug};
+
+use crate::config::Settings;
+use super::common::{SettingResponse, CategorySettingsResponse, CategorySettingsUpdate, get_setting_value, update_setting_value};
+
+// List of categories that make up visualization settings
+const VISUALIZATION_CATEGORIES: [&str; 10] = [
+    "animations",
+    "ar",
+    "audio",
+    "bloom",
+    "edges",
+    "hologram",
+    "labels",
+    "nodes",
+    "physics",
+    "rendering"
+];
+
+#[get("/visualization")]
+async fn get_visualization_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+) -> HttpResponse {
+    debug!("Getting all visualization settings");
+    
+    let settings_guard = settings.read().await;
+    let mut combined_settings = HashMap::new();
+    
+    // Process each category from root level settings
+    for category in VISUALIZATION_CATEGORIES.iter() {
+        debug!("Processing category: {}", category);
+        let category_value = match *category {
+            "animations" => serde_json::to_value(&settings_guard.visualization.animations),
+            "ar" => serde_json::to_value(&settings_guard.visualization.ar),
+            "audio" => serde_json::to_value(&settings_guard.visualization.audio),
+            "bloom" => serde_json::to_value(&settings_guard.visualization.bloom),
+            "edges" => serde_json::to_value(&settings_guard.visualization.edges),
+            "hologram" => serde_json::to_value(&settings_guard.visualization.hologram),
+            "labels" => serde_json::to_value(&settings_guard.visualization.labels),
+            "nodes" => serde_json::to_value(&settings_guard.visualization.nodes),
+            "physics" => serde_json::to_value(&settings_guard.visualization.physics),
+            "rendering" => serde_json::to_value(&settings_guard.visualization.rendering),
+            _ => continue,
+        };
+
+        if let Ok(value) = category_value {
+            if let Some(map) = value.as_object() {
+                for (key, value) in map {
+                    let combined_key = format!("{}_{}", category, key);
+                    debug!("Adding setting: {}", combined_key);
+                    combined_settings.insert(combined_key, value.clone());
+                }
+            }
+        } else {
+            error!("Failed to serialize {} settings", category);
+        }
+    }
+
+    debug!("Returning {} combined settings", combined_settings.len());
+    HttpResponse::Ok().json(CategorySettingsResponse {
+        category: "visualization".to_string(),
+        settings: combined_settings,
+        success: true,
+        error: None,
+    })
+}
+
+#[put("/visualization")]
+async fn update_visualization_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    update: web::Json<CategorySettingsUpdate>,
+) -> HttpResponse {
+    debug!("Updating visualization settings");
+    let mut settings_guard = settings.write().await;
+    let mut success = true;
+    let mut error_msg = None;
+
+    for (key, value) in update.settings.iter() {
+        // Split the key into category and setting
+        let parts: Vec<&str> = key.split('_').collect();
+        if parts.len() < 2 {
+            error!("Invalid setting key format: {}", key);
+            success = false;
+            error_msg = Some(format!("Invalid setting key format: {}", key));
+            break;
+        }
+
+        let category = parts[0];
+        let setting = parts[1..].join("_");
+
+        if !VISUALIZATION_CATEGORIES.contains(&category) {
+            error!("Invalid category: {}", category);
+            success = false;
+            error_msg = Some(format!("Invalid category: {}", category));
+            break;
+        }
+
+        debug!("Updating setting {}.{}", category, setting);
+        if let Err(e) = update_setting_value(&mut settings_guard, category, &setting, value) {
+            error!("Failed to update setting {}.{}: {}", category, setting, e);
+            success = false;
+            error_msg = Some(e);
+            break;
+        }
+    }
+
+    HttpResponse::Ok().json(CategorySettingsResponse {
+        category: "visualization".to_string(),
+        settings: update.settings.clone(),
+        success,
+        error: error_msg,
+    })
+}
+
+#[get("/visualization/{category}/{setting}")]
+async fn get_visualization_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    debug!("Getting visualization setting: {}.{}", category, setting);
+
+    if !VISUALIZATION_CATEGORIES.contains(&category.as_str()) {
+        error!("Invalid category: {}", category);
+        return HttpResponse::BadRequest().json(SettingResponse {
+            category: "visualization".to_string(),
+            setting: format!("{}.{}", category, setting),
+            value: Value::Null,
+            success: false,
+            error: Some(format!("Invalid category: {}", category)),
+        });
+    }
+
+    let settings_guard = settings.read().await;
+
+    match get_setting_value(&settings_guard, &category, &setting) {
+        Ok(value) => {
+            debug!("Successfully retrieved setting value");
+            HttpResponse::Ok().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value,
+                success: true,
+                error: None,
+            })
+        },
+        Err(e) => {
+            error!("Failed to get setting value: {}", e);
+            HttpResponse::BadRequest().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value: Value::Null,
+                success: false,
+                error: Some(e),
+            })
+        }
+    }
+}
+
+#[put("/visualization/{category}/{setting}")]
+async fn update_visualization_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+    value: web::Json<Value>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    debug!("Updating visualization setting: {}.{}", category, setting);
+
+    if !VISUALIZATION_CATEGORIES.contains(&category.as_str()) {
+        error!("Invalid category: {}", category);
+        return HttpResponse::BadRequest().json(SettingResponse {
+            category: "visualization".to_string(),
+            setting: format!("{}.{}", category, setting),
+            value: value.into_inner(),
+            success: false,
+            error: Some(format!("Invalid category: {}", category)),
+        });
+    }
+
+    let mut settings_guard = settings.write().await;
+
+    match update_setting_value(&mut settings_guard, &category, &setting, &value) {
+        Ok(_) => {
+            debug!("Successfully updated setting value");
+            HttpResponse::Ok().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value: value.into_inner(),
+                success: true,
+                error: None,
+            })
+        },
+        Err(e) => {
+            error!("Failed to update setting value: {}", e);
+            HttpResponse::BadRequest().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value: value.into_inner(),
+                success: false,
+                error: Some(e),
+            })
+        }
+    }
+}
+
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(get_visualization_settings)
+       .service(update_visualization_settings)
+       .service(get_visualization_setting)
+       .service(update_visualization_setting);
+}
diff --git a/src/handlers/settings/websocket.rs b/src/handlers/settings/websocket.rs
new file mode 100644
index 00000000..ffafab2f
--- /dev/null
+++ b/src/handlers/settings/websocket.rs
@@ -0,0 +1,76 @@
+use actix_web::{get, put, web, HttpResponse};
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use std::sync::Arc;
+use tokio::sync::RwLock;
+
+use crate::config::Settings;
+use super::common::{SettingResponse, get_setting_value, update_setting_value};
+
+// Note: Connection keep-alive is handled by WebSocket protocol-level ping/pong frames
+// automatically by the actix-web-actors framework on the server and browser WebSocket API
+// on the client. No custom heartbeat implementation is needed.
+#[derive(Debug, Serialize, Deserialize)]
+pub struct WebSocketSettings {
+    pub reconnect_attempts: u32,
+    pub reconnect_delay: u64,
+    pub update_rate: u32,
+}
+
+#[get("/{setting}")]
+async fn get_websocket_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<String>,
+) -> HttpResponse {
+    let setting = path.into_inner();
+    let settings = settings.read().await;
+    
+    match get_setting_value(&settings, "websocket", &setting) {
+        Ok(value) => HttpResponse::Ok().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting: setting.clone(),
+            value,
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting,
+            value: Value::Null,
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+#[put("/{setting}")]
+async fn update_websocket_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<String>,
+    value: web::Json<Value>,
+) -> HttpResponse {
+    let setting = path.into_inner();
+    let mut settings = settings.write().await;
+    
+    match update_setting_value(&mut settings, "websocket", &setting, &value) {
+        Ok(_) => HttpResponse::Ok().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting: setting.clone(),
+            value: value.into_inner(),
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting,
+            value: value.into_inner(),
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(get_websocket_setting)
+       .service(update_websocket_setting);
+}
diff --git a/src/handlers/socket_flow_handler.rs b/src/handlers/socket_flow_handler.rs
index 81a9dc51..cba5df33 100644
--- a/src/handlers/socket_flow_handler.rs
+++ b/src/handlers/socket_flow_handler.rs
@@ -3,47 +3,88 @@ use actix::prelude::*;
 use actix_web::{web, Error, HttpRequest, HttpResponse};
 use actix_web_actors::ws;
 use tokio::sync::RwLock;
-use log::{info, warn};
+use log::{info, debug, error, warn};
+use serde::{Deserialize, Serialize};
+use serde_json::json;
+use std::time::{Duration, Instant};
 
 use crate::app_state::AppState;
-use crate::utils::socket_flow_messages::{PingMessage, PongMessage};
+use crate::config::Settings;
+
+// Constants matching client/state/graphData.ts
+const NODE_POSITION_SIZE: usize = 24;  // 6 floats * 4 bytes
+const FLOATS_PER_NODE: usize = 6;      // x, y, z, vx, vy, vz
+const VERSION_HEADER_SIZE: usize = 4;
+const NODE_DATA_SIZE: usize = 24;
+const BINARY_PROTOCOL_VERSION: i32 = 1;
+const MAX_MESSAGE_SIZE: usize = 1024 * 1024; // 1MB
+const MAX_CONNECTIONS: usize = 100;
+const HEARTBEAT_INTERVAL: u64 = 30;
+const MAX_CLIENT_TIMEOUT: u64 = 60;
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct WebSocketSettings {
+    update_rate: u32,
+}
 
 pub struct SocketFlowServer {
     app_state: Arc<AppState>,
-    settings: Arc<RwLock<crate::config::Settings>>,
-    last_ping: Option<u64>,
+    settings: Arc<RwLock<Settings>>,
+    connection_alive: bool,
+    update_handle: Option<SpawnHandle>,
+    heartbeat_handle: Option<SpawnHandle>,
+    last_heartbeat: Instant,
 }
 
 impl SocketFlowServer {
-    const POSITION_UPDATE_INTERVAL: std::time::Duration = std::time::Duration::from_millis(16);
+    const POSITION_UPDATE_INTERVAL: Duration = Duration::from_millis(16);
 
-    pub fn new(app_state: Arc<AppState>, settings: Arc<RwLock<crate::config::Settings>>) -> Self {
+    pub fn new(app_state: Arc<AppState>, settings: Arc<RwLock<Settings>>) -> Self {
         Self {
             app_state,
             settings,
-            last_ping: None,
+            connection_alive: true,
+            update_handle: None,
+            heartbeat_handle: None,
+            last_heartbeat: Instant::now(),
         }
     }
 
-    fn handle_ping(&mut self, msg: PingMessage) -> PongMessage {
-        self.last_ping = Some(msg.timestamp);
-        PongMessage {
-            type_: "pong".to_string(),
-            timestamp: msg.timestamp,
+    fn start_heartbeat(&mut self, ctx: &mut <Self as Actor>::Context) {
+        // Cancel existing heartbeat if any
+        if let Some(handle) = self.heartbeat_handle.take() {
+            ctx.cancel_future(handle);
         }
+
+        // Start heartbeat interval
+        let handle = ctx.run_interval(Duration::from_secs(HEARTBEAT_INTERVAL), |actor, ctx| {
+            if Instant::now().duration_since(actor.last_heartbeat) > Duration::from_secs(MAX_CLIENT_TIMEOUT) {
+                warn!("[WebSocket] Client heartbeat timeout - last heartbeat: {:?} ago", 
+                    Instant::now().duration_since(actor.last_heartbeat));
+                actor.connection_alive = false;
+                ctx.stop();
+                return;
+            }
+
+            // Send ping with timestamp for latency tracking
+            let timestamp = Instant::now().elapsed().as_millis().to_string();
+            debug!("[WebSocket] Sending ping with timestamp: {}", timestamp);
+            ctx.ping(timestamp.as_bytes());
+        });
+
+        self.heartbeat_handle = Some(handle);
     }
-}
 
-impl Actor for SocketFlowServer {
-    type Context = ws::WebsocketContext<Self>;
+    fn start_position_updates(&mut self, ctx: &mut <Self as Actor>::Context) {
+        // Cancel existing interval if any
+        if let Some(handle) = self.update_handle.take() {
+            ctx.cancel_future(handle);
+        }
 
-    fn started(&mut self, ctx: &mut Self::Context) {
-        info!("[WebSocket] Client connected");
-        
         // Clone Arc references for the interval closure
         let app_state = self.app_state.clone();
         
-        ctx.run_interval(Self::POSITION_UPDATE_INTERVAL, move |_actor, ctx| {
+        let handle = ctx.run_interval(Self::POSITION_UPDATE_INTERVAL, move |_actor, ctx| {
             // Get current node positions and velocities
             let app_state_clone = app_state.clone();
             
@@ -51,8 +92,8 @@ impl Actor for SocketFlowServer {
             let fut = async move {
                 let nodes = app_state_clone.graph_service.get_node_positions().await;
                 
-                // Create binary data: 24 bytes per node (6 f32s)
-                let mut binary_data = Vec::with_capacity(nodes.len() * 24);
+                // Create binary data: 24 bytes per node (no header)
+                let mut binary_data = Vec::with_capacity(nodes.len() * NODE_POSITION_SIZE);
                 
                 for node in nodes {
                     // Position (x, y, z)
@@ -75,36 +116,146 @@ impl Actor for SocketFlowServer {
                 ctx.binary(binary_data);
             }));
         });
+
+        self.update_handle = Some(handle);
     }
+}
 
-    fn stopped(&mut self, _: &mut Self::Context) {
+impl Actor for SocketFlowServer {
+    type Context = ws::WebsocketContext<Self>;
+
+    fn started(&mut self, ctx: &mut Self::Context) {
+        info!("[WebSocket] Client connected");
+        
+        // Initialize connection
+        self.app_state.increment_connections();
+        let current = self.app_state.active_connections.load(std::sync::atomic::Ordering::Relaxed);
+        info!("[WebSocket] Active connections: {}", current);
+        
+        // Start heartbeat and position updates
+        self.start_heartbeat(ctx);
+        self.start_position_updates(ctx);
+    }
+
+    fn stopped(&mut self, ctx: &mut Self::Context) {
         info!("[WebSocket] Client disconnected");
+        
+        // Cancel heartbeat
+        if let Some(handle) = self.heartbeat_handle.take() {
+            ctx.cancel_future(handle);
+        }
+        
+        // Cancel position updates
+        if let Some(handle) = self.update_handle.take() {
+            ctx.cancel_future(handle);
+        }
+        
+        // Decrement connection count
+        self.app_state.decrement_connections();
+        let current = self.app_state.active_connections.load(std::sync::atomic::Ordering::Relaxed);
+        info!("[WebSocket] Remaining active connections: {}", current);
     }
 }
 
 impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer {
-    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
+    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut <Self as Actor>::Context) {
+        if !self.connection_alive {
+            ctx.stop();
+            return;
+        }
+
         match msg {
-            Ok(ws::Message::Ping(msg)) => {
-                ctx.pong(&msg);
-            }
-            Ok(ws::Message::Text(text)) => {
-                if let Ok(ping_msg) = serde_json::from_str::<PingMessage>(&text) {
-                    let pong = self.handle_ping(ping_msg);
-                    if let Ok(response) = serde_json::to_string(&pong) {
-                        ctx.text(response);
+            Ok(ws::Message::Binary(bin)) => {
+                // Validate message size
+                if bin.len() > MAX_MESSAGE_SIZE {
+                    error!("[WebSocket] Message too large: {} bytes", bin.len());
+                    ctx.text(json!({
+                        "error": format!("Message exceeds maximum size of {} bytes", MAX_MESSAGE_SIZE)
+                    }).to_string());
+                    return;
+                }
+
+                // Validate binary message structure
+                if bin.len() < VERSION_HEADER_SIZE || 
+                   (bin.len() - VERSION_HEADER_SIZE) % NODE_DATA_SIZE != 0 {
+                    error!("[WebSocket] Malformed binary message: length {} is invalid", bin.len());
+                    ctx.text(json!({
+                        "error": "Malformed binary message: invalid length"
+                    }).to_string());
+                    return;
+                }
+
+                // Read version header
+                let version = i32::from_le_bytes(bin[..VERSION_HEADER_SIZE].try_into().unwrap());
+                if version != BINARY_PROTOCOL_VERSION {
+                    error!("[WebSocket] Invalid protocol version: {}", version);
+                    ctx.text(json!({
+                        "error": format!("Invalid protocol version: {}", version)
+                    }).to_string());
+                    return;
+                }
+
+                // Process node data
+                let node_count = (bin.len() - VERSION_HEADER_SIZE) / NODE_DATA_SIZE;
+                let mut positions = Vec::with_capacity(node_count);
+                
+                for i in 0..node_count {
+                    let offset = VERSION_HEADER_SIZE + i * NODE_DATA_SIZE;
+                    let mut position = [0.0f32; 3];
+                    
+                    for j in 0..3 {
+                        let start = offset + j * std::mem::size_of::<f32>();
+                        let end = start + std::mem::size_of::<f32>();
+                        
+                        match bin[start..end].try_into() {
+                            Ok(bytes) => {
+                                position[j] = f32::from_le_bytes(bytes);
+                                if !position[j].is_finite() {
+                                    error!("[WebSocket] Invalid float value at position {}, component {}: {}", 
+                                        i, j, position[j]);
+                                    ctx.text(json!({
+                                        "error": format!("Invalid float value at position {}, component {}", i, j)
+                                    }).to_string());
+                                    return;
+                                }
+                            },
+                            Err(e) => {
+                                error!("[WebSocket] Failed to convert bytes to float at position {}, component {}: {}", 
+                                    i, j, e);
+                                ctx.text(json!({
+                                    "error": format!("Failed to convert bytes to float at position {}, component {}", i, j)
+                                }).to_string());
+                                return;
+                            }
+                        }
                     }
+
+                    positions.push(position);
                 }
-            }
-            Ok(ws::Message::Binary(_)) => {
-                warn!("[WebSocket] Unexpected binary message");
+
+                debug!("[WebSocket] Successfully processed {} node position updates", positions.len());
             }
             Ok(ws::Message::Close(reason)) => {
                 info!("[WebSocket] Client disconnected: {:?}", reason);
+                self.connection_alive = false;
                 ctx.close(reason);
                 ctx.stop();
             }
-            _ => {}
+            Ok(ws::Message::Ping(msg)) => {
+                debug!("[WebSocket] Received ping");
+                self.last_heartbeat = Instant::now();
+                ctx.pong(&msg);
+            },
+            Ok(ws::Message::Pong(_)) => {
+                debug!("[WebSocket] Received pong");
+                self.last_heartbeat = Instant::now();
+            },
+            Err(e) => {
+                error!("[WebSocket] Protocol error: {}", e);
+                self.connection_alive = false;
+                ctx.stop();
+            }
+            _ => ()
         }
     }
 }
@@ -113,8 +264,77 @@ pub async fn socket_flow_handler(
     req: HttpRequest,
     stream: web::Payload,
     app_state: web::Data<AppState>,
-    settings: web::Data<Arc<RwLock<crate::config::Settings>>>,
+    settings: web::Data<Arc<RwLock<Settings>>>,
 ) -> Result<HttpResponse, Error> {
-    let server = SocketFlowServer::new(app_state.into_inner(), settings.get_ref().clone());
-    ws::start(server, &req, stream)
+    // Enhanced connection debugging
+    info!("[WebSocket] New connection request from {:?}", req.peer_addr());
+    debug!("[WebSocket] Headers: {:?}", req.headers());
+    debug!("[WebSocket] URI: {:?}", req.uri());
+    
+    // Check connection limits
+    let current_connections = app_state.active_connections.load(std::sync::atomic::Ordering::Relaxed);
+    if current_connections >= MAX_CONNECTIONS {
+        error!("[WebSocket] Connection limit reached: {}/{}", current_connections, MAX_CONNECTIONS);
+        return Ok(HttpResponse::ServiceUnavailable().json(json!({
+            "error": "Connection limit reached"
+        })));
+    }
+
+    // Create server instance
+    let server = SocketFlowServer::new(
+        app_state.into_inner(),
+        settings.get_ref().clone()
+    );
+
+    // Start WebSocket connection
+    info!("[WebSocket] Starting WebSocket connection");
+    match ws::start(server, &req, stream) {
+        Ok(response) => {
+            info!("[WebSocket] WebSocket connection established successfully");
+            Ok(response)
+        }
+        Err(e) => {
+            error!("[WebSocket] Failed to start WebSocket connection: {:?}", e);
+            Ok(HttpResponse::InternalServerError().json(json!({
+                "error": format!("Failed to start WebSocket connection: {}", e)
+            })))
+        }
+    }
+}
+
+pub async fn get_websocket_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>
+) -> Result<HttpResponse, Error> {
+    let settings = settings.read().await;
+    let ws_settings = WebSocketSettings {
+        update_rate: settings.system.websocket.update_rate,
+    };
+    
+    Ok(HttpResponse::Ok().json(ws_settings))
+}
+
+const MAX_UPDATE_RATE: u32 = 120; // Maximum updates per second
+
+pub async fn update_websocket_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    new_settings: web::Json<WebSocketSettings>
+) -> Result<HttpResponse, Error> {
+    // Validate update rate
+    if new_settings.update_rate == 0 {
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": "Update rate must be greater than 0"
+        })));
+    }
+
+    if new_settings.update_rate > MAX_UPDATE_RATE {
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": format!("Update rate cannot exceed {} updates per second", MAX_UPDATE_RATE)
+        })));
+    }
+
+    let mut settings = settings.write().await;
+    settings.system.websocket.update_rate = new_settings.update_rate;
+    debug!("[WebSocket] Updated update rate to: {}", new_settings.update_rate);
+    
+    Ok(HttpResponse::Ok().json(new_settings.0))
 }
diff --git a/src/handlers/visualization_handler.rs b/src/handlers/visualization_handler.rs
deleted file mode 100755
index 892b4304..00000000
--- a/src/handlers/visualization_handler.rs
+++ /dev/null
@@ -1,387 +0,0 @@
-use crate::config::Settings;
-use actix_web::{web, HttpResponse};
-use log::{error, info, debug};
-use serde::{Deserialize, Serialize};
-use serde_json::Value;
-use std::collections::HashMap;
-use std::fs;
-use std::path::PathBuf;
-use std::sync::Arc;
-use tokio::sync::RwLock;
-use crate::utils::case_conversion::to_snake_case;
-
-#[derive(Debug, Serialize, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct SettingResponse {
-    pub category: String,
-    pub setting: String,
-    pub value: Value,
-    pub success: bool,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    pub error: Option<String>,
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct CategorySettingsResponse {
-    pub category: String,
-    pub settings: HashMap<String, Value>,
-    pub success: bool,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    pub error: Option<String>,
-}
-
-// Request/Response structures for individual settings
-#[derive(Debug, Serialize, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct SettingValue {
-    pub value: Value,
-}
-
-// Helper function to get setting value from settings object
-fn get_setting_value(settings: &Settings, category: &str, setting: &str) -> Result<Value, String> {
-    debug!("Attempting to get setting value for category: {}, setting: {}", category, setting);
-    
-    // Convert kebab-case URL parameters to appropriate cases
-    let category_snake = to_snake_case(category);
-    let setting_snake = to_snake_case(setting);
-    debug!("Converted category '{}' to snake_case: '{}'", category, category_snake);
-    debug!("Converted setting '{}' to snake_case: '{}'", setting, setting_snake);
-    
-    // Convert settings to Value for easier access
-    let settings_value = match serde_json::to_value(&settings) {
-        Ok(v) => {
-            debug!("Successfully serialized settings to JSON");
-            v
-        },
-        Err(e) => {
-            error!("Failed to serialize settings to JSON: {}", e);
-            return Err(format!("Failed to serialize settings: {}", e));
-        }
-    };
-    
-    debug!("Settings JSON structure: {}", settings_value);
-    
-    // Get category object using snake_case for internal lookup
-    let category_value = match settings_value.get(&category_snake) {
-        Some(v) => {
-            debug!("Found category '{}' in settings", category_snake);
-            v
-        },
-        None => {
-            error!("Category '{}' not found in settings", category_snake);
-            return Err(format!("Category '{}' not found", category));
-        }
-    };
-    
-    // Get setting value using snake_case for internal lookup
-    let setting_value = match category_value.get(&setting_snake) {
-        Some(v) => {
-            debug!("Found setting '{}' in category '{}'", setting_snake, category_snake);
-            v
-        },
-        None => {
-            error!("Setting '{}' not found in category '{}'", setting_snake, category_snake);
-            return Err(format!("Setting '{}' not found in category '{}'", setting, category));
-        }
-    };
-    
-    debug!("Found setting value: {:?}", setting_value);
-    Ok(setting_value.clone())
-}
-
-// Helper function to update setting value in settings object
-fn update_setting_value(settings: &mut Settings, category: &str, setting: &str, value: &Value) -> Result<(), String> {
-    debug!("Attempting to update setting value for category: {}, setting: {}", category, setting);
-    
-    // Convert kebab-case URL parameters to snake_case for internal lookup
-    let category_snake = to_snake_case(category);
-    let setting_snake = to_snake_case(setting);
-    debug!("Converted category '{}' to snake_case: '{}'", category, category_snake);
-    debug!("Converted setting '{}' to snake_case: '{}'", setting, setting_snake);
-    
-    // Convert settings to Value for manipulation, using a reference to avoid moving
-    let mut settings_value = match serde_json::to_value(&*settings) {
-        Ok(v) => {
-            debug!("Successfully serialized settings to JSON");
-            v
-        },
-        Err(e) => {
-            error!("Failed to serialize settings to JSON: {}", e);
-            return Err(format!("Failed to serialize settings: {}", e));
-        }
-    };
-    
-    debug!("Settings JSON structure: {}", settings_value);
-    
-    // Get category object
-    let category_value = match settings_value.get_mut(&category_snake) {
-        Some(v) => {
-            debug!("Found category '{}' in settings", category_snake);
-            v
-        },
-        None => {
-            error!("Category '{}' not found in settings", category_snake);
-            return Err(format!("Category '{}' not found", category));
-        }
-    };
-    
-    // Update setting value
-    if let Some(obj) = category_value.as_object_mut() {
-        obj.insert(setting_snake.to_string(), value.clone());
-        debug!("Updated setting value successfully");
-        
-        // Convert back to Settings
-        match serde_json::from_value(settings_value) {
-            Ok(new_settings) => {
-                debug!("Successfully converted updated JSON back to Settings");
-                *settings = new_settings;
-                Ok(())
-            },
-            Err(e) => {
-                error!("Failed to convert JSON back to Settings: {}", e);
-                Err(format!("Failed to deserialize settings: {}", e))
-            }
-        }
-    } else {
-        error!("Category '{}' is not an object", category_snake);
-        Err(format!("Category '{}' is not an object", category))
-    }
-}
-
-// Helper function to get all settings for a category
-fn get_category_settings_value(settings: &Settings, category: &str) -> Result<Value, String> {
-    debug!("Getting settings for category: {}", category);
-    let value = match category {
-        "nodes" => serde_json::to_value(&settings.nodes)
-            .map_err(|e| format!("Failed to serialize node settings: {}", e))?,
-        "edges" => serde_json::to_value(&settings.edges)
-            .map_err(|e| format!("Failed to serialize edge settings: {}", e))?,
-        "rendering" => serde_json::to_value(&settings.rendering)
-            .map_err(|e| format!("Failed to serialize rendering settings: {}", e))?,
-        "labels" => serde_json::to_value(&settings.labels)
-            .map_err(|e| format!("Failed to serialize labels settings: {}", e))?,
-        "bloom" => serde_json::to_value(&settings.bloom)
-            .map_err(|e| format!("Failed to serialize bloom settings: {}", e))?,
-        "animations" => serde_json::to_value(&settings.animations)
-            .map_err(|e| format!("Failed to serialize animations settings: {}", e))?,
-        "ar" => serde_json::to_value(&settings.ar)
-            .map_err(|e| format!("Failed to serialize ar settings: {}", e))?,
-        "audio" => serde_json::to_value(&settings.audio)
-            .map_err(|e| format!("Failed to serialize audio settings: {}", e))?,
-        "physics" => serde_json::to_value(&settings.physics)
-            .map_err(|e| format!("Failed to serialize physics settings: {}", e))?,
-        "clientDebug" => serde_json::to_value(&settings.client_debug)
-            .map_err(|e| format!("Failed to serialize client debug settings: {}", e))?,
-        "serverDebug" => serde_json::to_value(&settings.server_debug)
-            .map_err(|e| format!("Failed to serialize server debug settings: {}", e))?,
-        "security" => serde_json::to_value(&settings.security)
-            .map_err(|e| format!("Failed to serialize security settings: {}", e))?,
-        "websocket" => serde_json::to_value(&settings.websocket)
-            .map_err(|e| format!("Failed to serialize websocket settings: {}", e))?,
-        "network" => serde_json::to_value(&settings.network)
-            .map_err(|e| format!("Failed to serialize network settings: {}", e))?,
-        "default" => serde_json::to_value(&settings.default)
-            .map_err(|e| format!("Failed to serialize default settings: {}", e))?,
-        "github" => serde_json::to_value(&settings.github)
-            .map_err(|e| format!("Failed to serialize github settings: {}", e))?,
-        _ => return Err(format!("Invalid category: {}", category)),
-    };
-    debug!("Successfully retrieved settings for category: {}", category);
-    Ok(value)
-}
-
-// GET /api/visualization/settings/{category}/{setting}
-pub async fn get_setting(
-    settings: web::Data<Arc<RwLock<Settings>>>,
-    path: web::Path<(String, String)>,
-) -> HttpResponse {
-    let (category, setting) = path.into_inner();
-    info!("Getting setting for category: {}, setting: {}", category, setting);
-    
-    let settings_guard = match settings.read().await {
-        guard => {
-            debug!("Successfully acquired settings read lock");
-            guard
-        }
-    };
-
-    match get_setting_value(&*settings_guard, &category, &setting) {
-        Ok(value) => {
-            debug!("Successfully retrieved setting value: {:?}", value);
-            HttpResponse::Ok().json(SettingResponse {
-                category,
-                setting,
-                value,
-                success: true,
-                error: None,
-            })
-        },
-        Err(e) => {
-            error!("Failed to get setting value: {}", e);
-            HttpResponse::BadRequest().json(SettingResponse {
-                category,
-                setting,
-                value: Value::Null,
-                success: false,
-                error: Some(e),
-            })
-        }
-    }
-}
-
-// PUT /api/visualization/settings/{category}/{setting}
-pub async fn update_setting(
-    settings: web::Data<Arc<RwLock<Settings>>>,
-    path: web::Path<(String, String)>,
-    value: web::Json<Value>,
-) -> HttpResponse {
-    let (category, setting) = path.into_inner();
-    info!("Updating setting for category: {}, setting: {}", category, setting);
-    
-    let mut settings_guard = match settings.write().await {
-        guard => {
-            debug!("Successfully acquired settings write lock");
-            guard
-        }
-    };
-
-    match update_setting_value(&mut *settings_guard, &category, &setting, &value) {
-        Ok(_) => {
-            if let Err(e) = save_settings_to_file(&*settings_guard) {
-                error!("Failed to save settings to file: {}", e);
-                return HttpResponse::InternalServerError().json(SettingResponse {
-                    category,
-                    setting,
-                    value: value.into_inner(),
-                    success: false,
-                    error: Some("Failed to persist settings".to_string()),
-                });
-            }
-            HttpResponse::Ok().json(SettingResponse {
-                category,
-                setting,
-                value: value.into_inner(),
-                success: true,
-                error: None,
-            })
-        },
-        Err(e) => {
-            error!("Failed to update setting value: {}", e);
-            HttpResponse::BadRequest().json(SettingResponse {
-                category,
-                setting,
-                value: value.into_inner(),
-                success: false,
-                error: Some(e),
-            })
-        }
-    }
-}
-
-// GET /api/visualization/settings/{category}
-pub async fn get_category_settings(
-    settings: web::Data<Arc<RwLock<Settings>>>,
-    path: web::Path<String>,
-) -> HttpResponse {
-    let settings_read = settings.read().await;
-    let debug_enabled = settings_read.server_debug.enabled;
-    let log_json = debug_enabled && settings_read.server_debug.log_full_json;
-    
-    let category = path.into_inner();
-    match get_category_settings_value(&settings_read, &category) {
-        Ok(value) => {
-            if log_json {
-                debug!("Category '{}' settings: {}", category, serde_json::to_string_pretty(&value).unwrap_or_default());
-            }
-            let settings_map: HashMap<String, Value> = value.as_object()
-                .map(|m| m.iter().map(|(k, v)| (k.clone(), v.clone())).collect())
-                .unwrap_or_default();
-            
-            HttpResponse::Ok().json(CategorySettingsResponse {
-                category: category.clone(),
-                settings: settings_map,
-                success: true,
-                error: None,
-            })
-        },
-        Err(e) => {
-            error!("Failed to get category settings for '{}': {}", category, e);
-            HttpResponse::NotFound().json(CategorySettingsResponse {
-                category: category.clone(),
-                settings: HashMap::new(),
-                success: false,
-                error: Some(e),
-            })
-        }
-    }
-}
-
-// Register the handlers with the Actix web app
-pub fn config(cfg: &mut web::ServiceConfig) {
-    cfg.route("/settings/{category}/{setting}", web::get().to(get_setting))
-       .route("/settings/{category}/{setting}", web::put().to(update_setting))
-       .route("/settings/{category}", web::get().to(get_category_settings));
-}
-
-fn save_settings_to_file(settings: &Settings) -> std::io::Result<()> {
-    debug!("Attempting to save settings to file");
-    
-    // Use absolute path from environment or default to /app/settings.toml
-    let settings_path = std::env::var("SETTINGS_FILE_PATH")
-        .map(PathBuf::from)
-        .unwrap_or_else(|_| PathBuf::from("/app/settings.toml"));
-    
-    info!("Attempting to save settings to: {:?}", settings_path);
-    
-    // Ensure parent directory exists and is writable
-    if let Some(parent) = settings_path.parent() {
-        match fs::create_dir_all(parent) {
-            Ok(_) => debug!("Created parent directories: {:?}", parent),
-            Err(e) => {
-                error!("Failed to create parent directories: {}", e);
-                return Err(e);
-            }
-        }
-    }
-    
-    // Check if file exists and is writable
-    if settings_path.exists() {
-        match fs::metadata(&settings_path) {
-            Ok(metadata) => {
-                if metadata.permissions().readonly() {
-                    error!("Settings file is read-only: {:?}", settings_path);
-                    return Err(std::io::Error::new(
-                        std::io::ErrorKind::PermissionDenied,
-                        "Settings file is read-only"
-                    ));
-                }
-            }
-            Err(e) => {
-                error!("Failed to check settings file permissions: {}", e);
-                return Err(e);
-            }
-        }
-    }
-    
-    // Convert settings to TOML
-    let toml_string = match toml::to_string_pretty(&settings) {
-        Ok(s) => s,
-        Err(e) => {
-            error!("Failed to serialize settings to TOML: {}", e);
-            return Err(std::io::Error::new(std::io::ErrorKind::Other, e));
-        }
-    };
-    
-    // Write to settings.toml
-    match fs::write(&settings_path, toml_string) {
-        Ok(_) => {
-            info!("Settings saved successfully to: {:?}", settings_path);
-            Ok(())
-        }
-        Err(e) => {
-            error!("Failed to write settings file: {}", e);
-            Err(e)
-        }
-    }
-}
diff --git a/src/lib.rs b/src/lib.rs
index 020dd641..4f93a713 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -38,4 +38,4 @@ pub use handlers::file_handler;
 pub use handlers::graph_handler;
 pub use handlers::perplexity_handler;
 pub use handlers::ragflow_handler;
-pub use handlers::visualization_handler;
+pub use handlers::settings;
diff --git a/src/main.rs b/src/main.rs
index ea0b3fa1..de7062cf 100755
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,15 +1,11 @@
-#[macro_use]
-extern crate log;
+use log::{error, info};
+use env_logger;
 
 use webxr::{
-    AppState, Settings,
-    init_debug_settings,
-    file_handler, graph_handler, visualization_handler,
-    handlers::socket_flow_handler,
+    AppState,
+    Settings,
     RealGitHubService,
-    RealGitHubPRService, GPUCompute, GraphData,
-    log_data, log_warn,
-    services::file_service::FileService,
+    RealGitHubPRService,
     socket_flow_handler,
 };
 
@@ -20,151 +16,96 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use dotenvy::dotenv;
 
-// Handler configuration functions
-fn configure_file_handler(cfg: &mut web::ServiceConfig) {
-    cfg.service(web::resource("/fetch").to(file_handler::fetch_and_process_files))
-       .service(web::resource("/content/{file_name}").to(file_handler::get_file_content))
-       .service(web::resource("/refresh").to(file_handler::refresh_graph))
-       .service(web::resource("/update").to(file_handler::update_graph));
-}
-
-fn configure_graph_handler(cfg: &mut web::ServiceConfig) {
-    cfg.service(web::resource("/data").to(graph_handler::get_graph_data))
-       .service(web::resource("/data/paginated").to(graph_handler::get_paginated_graph_data))
-       .service(web::resource("/update").to(graph_handler::update_graph));
-}
-
 #[actix_web::main]
 async fn main() -> std::io::Result<()> {
     dotenv().ok();
+    env_logger::init();
+    info!("Starting WebXR server");
 
     // Load settings first to get the log level
     let settings = match Settings::new() {
-        Ok(s) => {
-            debug!("Successfully loaded settings: {:?}", s);
-            Arc::new(RwLock::new(s))
-        },
+        Ok(s) => s,
         Err(e) => {
-            eprintln!("Failed to load settings: {:?}", e);
-            return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize settings: {:?}", e)));
+            error!("Failed to load settings: {}", e);
+            return Err(std::io::Error::new(std::io::ErrorKind::Other, e));
         }
     };
 
-    // Create web::Data instances first
-    let settings_data = web::Data::new(settings.clone());
+    // Create settings Arc
+    let settings = Arc::new(RwLock::new(settings));
 
     // Initialize services
-    let settings_read = settings.read().await;
-    let github_service: Arc<RealGitHubService> = match RealGitHubService::new(
-        (*settings_read).github.token.clone(),
-        (*settings_read).github.owner.clone(),
-        (*settings_read).github.repo.clone(),
-        (*settings_read).github.base_path.clone(),
-        settings.clone(),
-    ) {
-        Ok(service) => Arc::new(service),
-        Err(e) => return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
-    };
-
-    let github_pr_service: Arc<RealGitHubPRService> = match RealGitHubPRService::new(
-        (*settings_read).github.token.clone(),
-        (*settings_read).github.owner.clone(),
-        (*settings_read).github.repo.clone(),
-        (*settings_read).github.base_path.clone()
-    ) {
-        Ok(service) => Arc::new(service),
-        Err(e) => return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
-    };
-    drop(settings_read);
-
-    // Initialize GPU compute
-    log_data!("Initializing GPU compute...");
-    let gpu_compute = match GPUCompute::new(&GraphData::default()).await {
-        Ok(gpu) => {
-            log_data!("GPU initialization successful");
-            Some(gpu)
-        }
-        Err(e) => {
-            log_warn!("Failed to initialize GPU: {}. Falling back to CPU computations.", e);
-            None
-        }
-    };
+    let github_service = Arc::new(RealGitHubService::new(
+        settings.read().await.github.token.clone(),
+        settings.read().await.github.owner.clone(),
+        settings.read().await.github.repo.clone(),
+        settings.read().await.github.base_path.clone(),
+        Arc::clone(&settings),
+    ).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?);
+
+    let github_pr_service = Arc::new(RealGitHubPRService::new(
+        settings.read().await.github.token.clone(),
+        settings.read().await.github.owner.clone(),
+        settings.read().await.github.repo.clone(),
+        settings.read().await.github.base_path.clone(),
+    ).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?);
 
     // Initialize app state
-    let app_state = web::Data::new(AppState::new(
-        settings.clone(),
-        github_service.clone(),
-        None,
-        None,
-        gpu_compute,
-        "default_conversation".to_string(),
-        github_pr_service.clone(),
-    ));
-
-    // Initialize debug settings
-    let (debug_enabled, websocket_debug, data_debug) = {
-        let settings_read = settings.read().await;
-        let debug_settings = (
-            (*settings_read).server_debug.enabled,
-            (*settings_read).server_debug.enable_websocket_debug,
-            (*settings_read).server_debug.enable_data_debug,
-        );
-        debug_settings
+    let app_state = {
+        let state = AppState::new(
+            Arc::clone(&settings),
+            Arc::clone(&github_service),
+            None, // perplexity_service
+            None, // ragflow_service
+            None, // gpu_compute
+            String::new(), // ragflow_conversation_id
+            Arc::clone(&github_pr_service),
+        ).await;
+        info!("Successfully initialized app state");
+        web::Data::new(state)
     };
 
-    // Initialize our debug logging system
-    init_debug_settings(debug_enabled, websocket_debug, data_debug);
+    // Get port from environment variable or use default
+    let port = std::env::var("PORT")
+        .unwrap_or_else(|_| "3000".to_string())
+        .parse::<u16>()
+        .unwrap_or(3000);
 
-    // Initialize local storage and fetch files from GitHub
-    info!("Initializing local storage and fetching files from GitHub...");
-    if let Err(e) = FileService::initialize_local_storage(&*github_service, settings.clone()).await {
-        error!("Failed to initialize local storage: {}", e);
-        return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize local storage: {}", e)));
-    }
-    info!("Local storage initialization complete");
+    let bind_addr = format!("0.0.0.0:{}", port);
+    info!("Binding to {}", bind_addr);
 
-    // Start the server
-    let bind_address = {
-        let settings_read = settings.read().await;
-        format!("{}:{}", (*settings_read).network.bind_address, (*settings_read).network.port)
+    // Serve static files from the correct directory
+    let static_files_path = if cfg!(debug_assertions) {
+        "../data/public/dist"
+    } else {
+        "data/public/dist"
     };
 
-    log_data!("Starting HTTP server on {}", bind_address);
-
+    // Configure app with services
     HttpServer::new(move || {
-        // Configure CORS
-        let cors = Cors::default()
-            .allow_any_origin()
-            .allow_any_method()
-            .allow_any_header()
-            .max_age(3600)
-            .supports_credentials();
-
         App::new()
+            .wrap(
+                Cors::default()
+                    .allow_any_origin()
+                    .allow_any_method()
+                    .allow_any_header()
+                    .max_age(3600)
+            )
             .wrap(middleware::Logger::default())
-            .wrap(cors)
-            .wrap(middleware::Compress::default())
-            .app_data(settings_data.clone())
             .app_data(app_state.clone())
-            .app_data(web::Data::new(github_service.clone()))
-            .app_data(web::Data::new(github_pr_service.clone()))
             .service(
                 web::scope("/api")
-                    .service(web::scope("/files").configure(configure_file_handler))
-                    .service(web::scope("/graph").configure(configure_graph_handler))
-                    .service(web::scope("/visualization").configure(visualization_handler::config))
+                    .service(web::scope("/settings").configure(webxr::settings::config))
+                    .service(web::scope("/graph").configure(webxr::graph_handler::config))
             )
             .service(
                 web::resource("/wss")
                     .app_data(web::PayloadConfig::new(1 << 25))  // 32MB max payload
                     .route(web::get().to(socket_flow_handler))
             )
-            .service(Files::new("/", "/app/client").index_file("index.html"))
+            .service(Files::new("/", static_files_path).index_file("index.html"))
     })
-    .bind(&bind_address)?
+    .bind(bind_addr)?
     .run()
-    .await?;
-
-    log_data!("HTTP server stopped");
-    Ok(())
+    .await
 }
diff --git a/src/models/simulation_params.rs b/src/models/simulation_params.rs
index 14756c34..cc2403d0 100755
--- a/src/models/simulation_params.rs
+++ b/src/models/simulation_params.rs
@@ -110,6 +110,44 @@ impl SimulationParams {
         }
     }
 
+    pub fn default_for_phase(phase: SimulationPhase) -> Self {
+        match phase {
+            SimulationPhase::Initial => Self {
+                iterations: 500,
+                spring_length: 150.0,
+                spring_strength: 0.05,
+                repulsion: 2500.0,
+                attraction: 0.5,
+                damping: 0.85,
+                time_step: 0.1,
+                phase,
+                mode: SimulationMode::Remote,
+            },
+            SimulationPhase::Dynamic => Self {
+                iterations: 50,
+                spring_length: 100.0,
+                spring_strength: 0.5,
+                repulsion: 100.0,
+                attraction: 1.0,
+                damping: 0.5,
+                time_step: 0.2,
+                phase,
+                mode: SimulationMode::Remote,
+            },
+            SimulationPhase::Finalize => Self {
+                iterations: 200,
+                spring_length: 100.0,
+                spring_strength: 0.1,
+                repulsion: 50.0,
+                attraction: 0.5,
+                damping: 0.95,
+                time_step: 0.2,
+                phase,
+                mode: SimulationMode::Remote,
+            },
+        }
+    }
+
     // Convert to GPU-compatible parameters
     pub fn to_gpu_params(&self) -> GPUSimulationParams {
         GPUSimulationParams {
diff --git a/src/services/file_service.rs b/src/services/file_service.rs
index 9127c3f0..69130c46 100755
--- a/src/services/file_service.rs
+++ b/src/services/file_service.rs
@@ -62,7 +62,7 @@ struct ReferenceInfo {
 
 #[async_trait]
 pub trait GitHubService: Send + Sync {
-    async fn fetch_file_metadata(&self) -> Result<Vec<GithubFileMetadata>, Box<dyn StdError + Send + Sync>>;
+    async fn fetch_file_metadata(&self, skip_debug_filter: bool) -> Result<Vec<GithubFileMetadata>, Box<dyn StdError + Send + Sync>>;
     async fn get_download_url(&self, file_name: &str) -> Result<Option<String>, Box<dyn StdError + Send + Sync>>;
     async fn fetch_file_content(&self, download_url: &str) -> Result<String, Box<dyn StdError + Send + Sync>>;
     async fn get_file_last_modified(&self, file_path: &str) -> Result<DateTime<Utc>, Box<dyn StdError + Send + Sync>>;
@@ -108,7 +108,7 @@ impl RealGitHubService {
 
 #[async_trait]
 impl GitHubService for RealGitHubService {
-    async fn fetch_file_metadata(&self) -> Result<Vec<GithubFileMetadata>, Box<dyn StdError + Send + Sync>> {
+    async fn fetch_file_metadata(&self, skip_debug_filter: bool) -> Result<Vec<GithubFileMetadata>, Box<dyn StdError + Send + Sync>> {
         let url = if self.base_path.is_empty() {
             format!(
                 "https://api.github.com/repos/{}/{}/contents",
@@ -167,7 +167,7 @@ impl GitHubService for RealGitHubService {
         };
 
         let settings = self.settings.read().await;
-        let debug_enabled = settings.server_debug.enabled;
+        let debug_enabled = settings.system.debug.enabled;
         
         let mut markdown_files = Vec::new();
         
@@ -176,11 +176,11 @@ impl GitHubService for RealGitHubService {
                item["name"].as_str().unwrap_or("").ends_with(".md") {
                 let name = item["name"].as_str().unwrap_or("").to_string();
                 
-                // In debug mode, only process Debug Test Page.md and debug linked node.md
-                if debug_enabled && !name.contains("Debug Test Page") && !name.contains("debug linked node") {
+                // In debug mode and not skipping filter, only process Debug Test Page.md and debug linked node.md
+                if !skip_debug_filter && debug_enabled && !name.contains("Debug Test Page") && !name.contains("debug linked node") {
                     continue;
                 }
-                
+
                 debug!("Processing markdown file: {}", name);
                 
                 let last_modified = match self.get_file_last_modified(&format!("{}/{}", self.base_path, name)).await {
@@ -469,7 +469,7 @@ impl FileService {
         info!("Initializing local storage with files from GitHub");
 
         // Step 1: Get all markdown files from GitHub
-        let github_files = github_service.fetch_file_metadata().await?;
+        let github_files = github_service.fetch_file_metadata(false).await?;
         info!("Found {} markdown files in GitHub", github_files.len());
 
         let mut file_sizes = HashMap::new();
@@ -635,7 +635,7 @@ impl FileService {
         Self::ensure_directories()?;
 
         // Get metadata for markdown files in target directory
-        let github_files_metadata = github_service.fetch_file_metadata().await?;
+        let github_files_metadata = github_service.fetch_file_metadata(true).await?;
         debug!("Fetched metadata for {} markdown files", github_files_metadata.len());
 
         let mut processed_files = Vec::new();
diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
index e6c7ea7b..0322fa01 100755
--- a/src/services/graph_service.rs
+++ b/src/services/graph_service.rs
@@ -2,7 +2,7 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use std::collections::{HashMap, HashSet};
 use actix_web::web;
-use log::{info, warn};
+use log::{info, warn, error};
 use rand::Rng;
 use serde_json;
 
@@ -12,8 +12,9 @@ use crate::models::edge::Edge;
 use crate::models::metadata::MetadataStore;
 use crate::app_state::AppState;
 use crate::utils::gpu_compute::GPUCompute;
-use crate::models::simulation_params::{SimulationParams, SimulationPhase, SimulationMode};
+use crate::models::simulation_params::SimulationParams;
 use crate::models::pagination::PaginatedGraphData;
+use crate::services::file_service::FileService;
 
 #[derive(Clone)]
 pub struct GraphService {
@@ -22,53 +23,33 @@ pub struct GraphService {
 
 impl GraphService {
     pub fn new() -> Self {
-        let graph_service = Self {
+        Self {
             graph_data: Arc::new(RwLock::new(GraphData::default())),
-        };
-
-        // Start simulation loop
-        let graph_data = graph_service.graph_data.clone();
-        tokio::spawn(async move {
-            let mut params = SimulationParams {
-                iterations: 1,  // One iteration per frame
-                spring_length: 100.0,  // Default spring length
-                spring_strength: 0.1,  // Gentler forces for continuous updates
-                repulsion: 50.0,  // Reduced repulsion
-                attraction: 0.5,  // Reduced attraction
-                damping: 0.8,  // More damping for stability
-                time_step: 0.016,  // 60fps
-                phase: SimulationPhase::Dynamic,
-                mode: SimulationMode::Local,  // Use CPU for continuous updates
-            };
-
-            loop {
-                // Update positions
-                let mut graph = graph_data.write().await;
-                if let Err(e) = Self::calculate_layout_cpu(
-                    &mut graph,
-                    params.iterations,
-                    params.spring_strength,
-                    params.damping
-                ) {
-                    warn!("[Graph] Error updating positions: {}", e);
-                }
-                drop(graph); // Release lock
-
-                // Sleep for ~16ms (60fps)
-                tokio::time::sleep(tokio::time::Duration::from_millis(16)).await;
-            }
-        });
+        }
+    }
 
-        graph_service
+    pub async fn new_with_metadata(metadata_store: &MetadataStore) -> Self {
+        let graph_data = Self::build_graph_from_metadata(metadata_store)
+            .await
+            .unwrap_or_else(|e| {
+                error!("Failed to build graph from metadata: {}", e);
+                GraphData::default()
+            });
+        
+        Self {
+            graph_data: Arc::new(RwLock::new(graph_data)),
+        }
     }
 
-    pub async fn build_graph_from_metadata(metadata: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
+    pub async fn build_graph_from_metadata(metadata_store: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error>> {
         let mut graph = GraphData::new();
         let mut edge_map = HashMap::new();
 
+        info!("Building graph from {} metadata entries", metadata_store.len());
+
         // First pass: Create nodes from files in metadata
         let mut valid_nodes = HashSet::new();
-        for file_name in metadata.keys() {
+        for file_name in metadata_store.keys() {
             let node_id = file_name.trim_end_matches(".md").to_string();
             valid_nodes.insert(node_id);
         }
@@ -78,7 +59,7 @@ impl GraphService {
             let mut node = Node::new(node_id.clone());
             
             // Get metadata for this node
-            if let Some(metadata) = metadata.get(&format!("{}.md", node_id)) {
+            if let Some(metadata) = metadata_store.get(&format!("{}.md", node_id)) {
                 node.size = Some(metadata.node_size as f32);
                 node.file_size = metadata.file_size as u64;
                 node.label = node_id.clone(); // Set label to node ID (filename without .md)
@@ -89,14 +70,15 @@ impl GraphService {
                 node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
             }
             
+            // Add node to graph
             graph.nodes.push(node);
         }
 
         // Store metadata in graph
-        graph.metadata = metadata.clone();
+        graph.metadata = metadata_store.clone();
 
         // Second pass: Create edges from topic counts
-        for (source_file, metadata) in metadata.iter() {
+        for (source_file, metadata) in metadata_store.iter() {
             let source_id = source_file.trim_end_matches(".md").to_string();
             
             for (target_file, count) in &metadata.topic_counts {
@@ -124,7 +106,7 @@ impl GraphService {
             })
             .collect();
 
-        // Initialize random positions
+        // Initialize random positions using the same method everywhere
         Self::initialize_random_positions(&mut graph);
 
         info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
@@ -206,13 +188,15 @@ impl GraphService {
 
     fn initialize_random_positions(graph: &mut GraphData) {
         let mut rng = rand::thread_rng();
-        let initial_radius = 30.0;
+        let initial_radius = 100.0; // Match default spring length
         
         for node in &mut graph.nodes {
+            // Use spherical coordinates for uniform distribution
             let theta = rng.gen_range(0.0..std::f32::consts::PI * 2.0);
             let phi = rng.gen_range(0.0..std::f32::consts::PI);
-            let r = rng.gen_range(0.0..initial_radius);
+            let r = initial_radius * rng.gen::<f32>().cbrt(); // Cube root for uniform volume distribution
             
+            // Convert to Cartesian coordinates
             node.set_x(r * theta.cos() * phi.sin());
             node.set_y(r * theta.sin() * phi.sin());
             node.set_z(r * phi.cos());
@@ -227,124 +211,31 @@ impl GraphService {
         graph: &mut GraphData,
         params: &SimulationParams,
     ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
-        match gpu_compute {
-            Some(gpu) => {
-                info!("Using GPU for layout calculation");
-                let mut gpu_compute = gpu.write().await;
-                
-                // Only initialize positions for new graphs
-                if graph.nodes.iter().all(|n| n.x() == 0.0 && n.y() == 0.0 && n.z() == 0.0) {
-                    Self::initialize_random_positions(graph);
-                }
-                
-                gpu_compute.update_graph_data(graph)?;
-                gpu_compute.update_simulation_params(params)?;
-                
-                // Run iterations with more frequent updates
-                for _ in 0..params.iterations {
-                    gpu_compute.step()?;
-                    
-                    // Update positions every iteration for smoother motion
-                    let updated_nodes = gpu_compute.get_node_data()?;
-                    for (i, node) in graph.nodes.iter_mut().enumerate() {
-                        node.update_from_gpu_node(&updated_nodes[i]);
-                    }
-                }
-                Ok(())
-            },
-            None => {
-                warn!("GPU not available. Falling back to CPU-based layout calculation.");
-                Self::calculate_layout_cpu(graph, params.iterations, params.spring_strength, params.damping)?;
-                Ok(())
-            }
+        // Initialize positions if needed, regardless of GPU availability
+        if graph.nodes.iter().all(|n| n.x() == 0.0 && n.y() == 0.0 && n.z() == 0.0) {
+            Self::initialize_random_positions(graph);
         }
-    }
 
-    fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
-        let repulsion_strength = spring_strength * 10000.0;
-        
-        for _ in 0..iterations {
-            // Calculate forces between nodes
-            let mut forces = vec![(0.0, 0.0, 0.0); graph.nodes.len()];
+        // Only proceed with force-directed layout if GPU is available
+        if let Some(gpu) = gpu_compute {
+            info!("Using GPU for layout calculation");
+            let mut gpu_compute = gpu.write().await;
             
-            // Calculate repulsion forces
-            for i in 0..graph.nodes.len() {
-                for j in i+1..graph.nodes.len() {
-                    let dx = graph.nodes[j].x() - graph.nodes[i].x();
-                    let dy = graph.nodes[j].y() - graph.nodes[i].y();
-                    let dz = graph.nodes[j].z() - graph.nodes[i].z();
-                    
-                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
-                    if distance > 0.0 {
-                        let force = repulsion_strength / (distance * distance);
-                        
-                        let fx = dx * force / distance;
-                        let fy = dy * force / distance;
-                        let fz = dz * force / distance;
-                        
-                        forces[i].0 -= fx;
-                        forces[i].1 -= fy;
-                        forces[i].2 -= fz;
-                        
-                        forces[j].0 += fx;
-                        forces[j].1 += fy;
-                        forces[j].2 += fz;
-                    }
-                }
-            }
-
-            // Calculate spring forces along edges
-            for edge in &graph.edges {
-                // Find indices of source and target nodes
-                let source_idx = graph.nodes.iter().position(|n| n.id == edge.source);
-                let target_idx = graph.nodes.iter().position(|n| n.id == edge.target);
-                
-                if let (Some(si), Some(ti)) = (source_idx, target_idx) {
-                    let source = &graph.nodes[si];
-                    let target = &graph.nodes[ti];
-                    
-                    let dx = target.x() - source.x();
-                    let dy = target.y() - source.y();
-                    let dz = target.z() - source.z();
-                    
-                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
-                    if distance > 0.0 {
-                        // Scale force by edge weight
-                        let force = spring_strength * (distance - 30.0) * edge.weight;
-                        
-                        let fx = dx * force / distance;
-                        let fy = dy * force / distance;
-                        let fz = dz * force / distance;
-                        
-                        forces[si].0 += fx;
-                        forces[si].1 += fy;
-                        forces[si].2 += fz;
-                        
-                        forces[ti].0 -= fx;
-                        forces[ti].1 -= fy;
-                        forces[ti].2 -= fz;
-                    }
-                }
-            }
+            gpu_compute.update_graph_data(graph)?;
+            gpu_compute.update_simulation_params(params)?;
             
-            // Apply forces and update positions
-            for (i, node) in graph.nodes.iter_mut().enumerate() {
-                let vx = node.vx() + forces[i].0;
-                let vy = node.vy() + forces[i].1;
-                let vz = node.vz() + forces[i].2;
+            // Run iterations with more frequent updates
+            for _ in 0..params.iterations {
+                gpu_compute.step()?;
                 
-                let x = node.x() + vx;
-                let y = node.y() + vy;
-                let z = node.z() + vz;
-                
-                node.set_vx(vx * damping);
-                node.set_vy(vy * damping);
-                node.set_vz(vz * damping);
-                
-                node.set_x(x);
-                node.set_y(y);
-                node.set_z(z);
+                // Update positions every iteration for smoother motion
+                let updated_nodes = gpu_compute.get_node_data()?;
+                for (i, node) in graph.nodes.iter_mut().enumerate() {
+                    node.update_from_gpu_node(&updated_nodes[i]);
+                }
             }
+        } else {
+            warn!("GPU not available. Using static random positions.");
         }
         Ok(())
     }
@@ -397,4 +288,30 @@ impl GraphService {
         let graph = self.graph_data.read().await;
         graph.nodes.clone()
     }
+
+    pub async fn update_graph(&self) -> Result<GraphData, String> {
+        info!("Updating graph data");
+
+        // Load or create metadata
+        let metadata_store = match FileService::load_or_create_metadata() {
+            Ok(store) => store,
+            Err(e) => {
+                error!("Failed to load metadata: {}", e);
+                return Err(format!("Failed to load metadata: {}", e));
+            }
+        };
+
+        info!("Loaded metadata with {} entries", metadata_store.len());
+
+        // Build graph from metadata
+        let graph = match Self::build_graph_from_metadata(&metadata_store).await {
+            Ok(g) => g,
+            Err(e) => {
+                error!("Failed to build graph: {}", e);
+                return Err(format!("Failed to build graph: {}", e));
+            }
+        };
+
+        Ok(graph)
+    }
 }
diff --git a/src/types/metadata.ts b/src/types/metadata.ts
new file mode 100644
index 00000000..3564f050
--- /dev/null
+++ b/src/types/metadata.ts
@@ -0,0 +1,45 @@
+export interface NodeMetadata {
+    name: string;
+    commitAge: number;        // Age in days
+    hyperlinkCount: number;   // Number of hyperlinks
+    importance: number;       // Normalized importance (0-1)
+    position: {
+        x: number;
+        y: number;
+        z: number;
+    };
+}
+
+export interface HologramSettings {
+    enabled: boolean;
+    desktopQuality: 'low' | 'medium' | 'high';
+    xrQuality: 'low' | 'medium';
+    ringCount: number;
+    ringSizes: number[];
+    ringOpacity: number;
+    ringColor: string;
+    ringRotationSpeed: number;
+    enableBuckminster: boolean;
+    buckminsterScale: number;
+    buckminsterOpacity: number;
+    enableGeodesic: boolean;
+    geodesicScale: number;
+    geodesicOpacity: number;
+    enableTriangleSphere: boolean;
+    triangleSphereScale: number;
+    triangleSphereOpacity: number;
+    globalRotationSpeed: number;
+    wireframeThickness: number;
+}
+
+export interface LabelSettings {
+    textRenderingMode: 'sdf' | 'bitmap';
+    textResolution: number;
+    textPadding: number;
+    textOutlineWidth: number;
+    textOutlineColor: string;
+    billboardMode: 'camera' | 'vertical';
+    desktopFontSize: number;
+    enableLabels: boolean;
+    textColor: string;
+}
diff --git a/src/types/xr.ts b/src/types/xr.ts
new file mode 100644
index 00000000..5942600a
--- /dev/null
+++ b/src/types/xr.ts
@@ -0,0 +1,25 @@
+export type XRHandedness = 'left' | 'right' | 'none';
+
+export interface XRHandJoint {
+    position: THREE.BufferAttribute;
+    orientation: THREE.BufferAttribute;
+    radius: number;
+}
+
+export interface XRHand extends THREE.Object3D {
+    joints: {
+        [key: string]: XRHandJoint;
+    };
+}
+
+export interface XRInteractionState {
+    isHolding: boolean;
+    selectedObject: THREE.Object3D | null;
+    interactionDistance: number;
+    lastPinchTime: number;
+}
+
+export interface XRControllerState {
+    left: XRInteractionState;
+    right: XRInteractionState;
+}
diff --git a/src/utils/compute_forces.cu b/src/utils/compute_forces.cu
index 8a55587c..371a9691 100644
--- a/src/utils/compute_forces.cu
+++ b/src/utils/compute_forces.cu
@@ -1,17 +1,27 @@
 // Node data structure matching Rust's NodeData
 struct NodeData {
     float position[3];    // 12 bytes
-    float velocity[3];    // 12 bytes
     unsigned char mass;   // 1 byte
     unsigned char flags;  // 1 byte
     unsigned char padding[2]; // 2 bytes padding
 };
 
+// Velocity data structure matching Rust's VelocityData
+struct VelocityData {
+    float x;
+    float y;
+    float z;
+};
+
 extern "C" __global__ void compute_forces(
     NodeData* nodes,
-    int num_nodes,
+    VelocityData* velocities,
+    unsigned long long unused,
+    unsigned int num_nodes,
     float spring_strength,
+    float spring_length,
     float repulsion,
+    float attraction,
     float damping
 ) {
     int idx = blockIdx.x * blockDim.x + threadIdx.x;
@@ -57,55 +67,84 @@ extern "C" __global__ void compute_forces(
             float3 pos_j = shared_positions[j];
             float mass_j = shared_masses[j];
             
-            // Calculate displacement vector
+            // Calculate displacement vector from j to i for repulsion
             float3 diff = make_float3(
                 pos_i.x - pos_j.x,
                 pos_i.y - pos_j.y,
                 pos_i.z - pos_j.z
             );
 
-            // Calculate force magnitude with minimum distance clamp
-            float dist = fmaxf(sqrtf(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z), 0.0001f);
-            float force_mag = repulsion * mass_i * mass_j / (dist * dist);
+            // Calculate distance with minimum clamp
+            float dist2 = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;
+            float dist = fmaxf(sqrtf(dist2), 0.1f); // Smaller min distance for more dynamic movement
+            
+            // Normalize direction vector
+            float inv_dist = 1.0f / dist;
+            float3 dir = make_float3(
+                diff.x * inv_dist,
+                diff.y * inv_dist,
+                diff.z * inv_dist
+            );
+
+            // Calculate repulsion force (inverse square law)
+            float mass_factor = sqrtf(mass_i * mass_j);
+            float repulsion_mag = repulsion * mass_factor / dist2;
+            
+            // Add repulsion force
+            force.x += dir.x * repulsion_mag;
+            force.y += dir.y * repulsion_mag;
+            force.z += dir.z * repulsion_mag;
 
-            // Add spring force if nodes are connected (check flags)
+            // Add spring force if nodes are connected
             if ((node_i.flags & 0x2) && (nodes[tile * blockDim.x + j].flags & 0x2)) {
-                float spring_force = spring_strength * (dist - 1.0f); // Natural length = 1.0
-                force_mag += spring_force;
+                // Spring force points opposite to displacement if too far, along it if too close
+                float spring_displacement = dist - spring_length;
+                float spring_mag = spring_strength * spring_displacement * attraction;
+                
+                // Spring force opposes displacement
+                force.x -= dir.x * spring_mag;
+                force.y -= dir.y * spring_mag;
+                force.z -= dir.z * spring_mag;
             }
-
-            // Accumulate force
-            force.x += force_mag * diff.x / dist;
-            force.y += force_mag * diff.y / dist;
-            force.z += force_mag * diff.z / dist;
         }
         __syncthreads();
     }
 
+    // Clamp maximum force magnitude
+    float force_mag = sqrtf(force.x * force.x + force.y * force.y + force.z * force.z);
+    if (force_mag > 1000.0f) {
+        float scale = 1000.0f / force_mag;
+        force.x *= scale;
+        force.y *= scale;
+        force.z *= scale;
+    }
+
     // Load current velocity
     float3 vel = make_float3(
-        node_i.velocity[0],
-        node_i.velocity[1],
-        node_i.velocity[2]
+        velocities[idx].x,
+        velocities[idx].y,
+        velocities[idx].z
     );
 
-    // Update velocity with damping
-    vel.x = (vel.x + force.x) * damping;
-    vel.y = (vel.y + force.y) * damping;
-    vel.z = (vel.z + force.z) * damping;
+    // Time step for integration (adjust this to control simulation speed)
+    const float dt = 0.016f; // 60 fps
 
-    // Update position
-    pos_i.x += vel.x;
-    pos_i.y += vel.y;
-    pos_i.z += vel.z;
+    // Semi-implicit Euler integration
+    // First update velocity (v = v + a*dt)
+    vel.x = (vel.x + force.x * dt) * damping;
+    vel.y = (vel.y + force.y * dt) * damping;
+    vel.z = (vel.z + force.z * dt) * damping;
+
+    // Then update position (p = p + v*dt)
+    pos_i.x += vel.x * dt;
+    pos_i.y += vel.y * dt;
+    pos_i.z += vel.z * dt;
 
     // Store updated position and velocity
     nodes[idx].position[0] = pos_i.x;
     nodes[idx].position[1] = pos_i.y;
     nodes[idx].position[2] = pos_i.z;
-    nodes[idx].velocity[0] = vel.x;
-    nodes[idx].velocity[1] = vel.y;
-    nodes[idx].velocity[2] = vel.z;
-
-    // Flags and mass remain unchanged
+    velocities[idx].x = vel.x;
+    velocities[idx].y = vel.y;
+    velocities[idx].z = vel.z;
 }
diff --git a/src/utils/compute_forces.ptx b/src/utils/compute_forces.ptx
index 97614a0f..7a88b5a7 100644
--- a/src/utils/compute_forces.ptx
+++ b/src/utils/compute_forces.ptx
@@ -7,7 +7,7 @@
 //
 
 .version 8.4
-.target sm_86
+.target sm_75
 .address_size 64
 
 	// .globl	compute_forces
@@ -21,657 +21,997 @@
 	.param .u32 compute_forces_param_3,
 	.param .f32 compute_forces_param_4,
 	.param .f32 compute_forces_param_5,
-	.param .f32 compute_forces_param_6
+	.param .f32 compute_forces_param_6,
+	.param .f32 compute_forces_param_7,
+	.param .f32 compute_forces_param_8
 )
 {
-	.reg .pred 	%p<31>;
-	.reg .b16 	%rs<3>;
-	.reg .f32 	%f<528>;
-	.reg .b32 	%r<106>;
-	.reg .b64 	%rd<20>;
+	.reg .pred 	%p<109>;
+	.reg .b16 	%rs<64>;
+	.reg .f32 	%f<664>;
+	.reg .b32 	%r<82>;
+	.reg .b64 	%rd<46>;
 	// demoted variable
 	.shared .align 4 .b8 _ZZ14compute_forcesE16shared_positions[3072];
 	// demoted variable
 	.shared .align 4 .b8 _ZZ14compute_forcesE13shared_masses[1024];
 
-	ld.param.u64 	%rd6, [compute_forces_param_0];
-	ld.param.u64 	%rd7, [compute_forces_param_2];
-	ld.param.u32 	%r26, [compute_forces_param_3];
-	cvta.to.global.u64 	%rd1, %rd7;
-	cvta.to.global.u64 	%rd2, %rd6;
-	mov.u32 	%r27, %ntid.x;
-	mov.u32 	%r28, %ctaid.x;
-	mov.u32 	%r1, %tid.x;
-	mad.lo.s32 	%r2, %r28, %r27, %r1;
-	setp.ge.s32 	%p1, %r2, %r26;
-	@%p1 bra 	$L__BB0_47;
-
-	mul.lo.s32 	%r29, %r2, 3;
-	mul.wide.s32 	%rd8, %r29, 4;
-	add.s64 	%rd4, %rd2, %rd8;
-	ld.global.f32 	%f1, [%rd4];
-	ld.global.f32 	%f2, [%rd4+4];
-	ld.global.f32 	%f3, [%rd4+8];
-	setp.lt.s32 	%p2, %r26, 1;
-	mov.f32 	%f474, 0f00000000;
-	mov.f32 	%f475, %f474;
-	mov.f32 	%f476, %f474;
-	@%p2 bra 	$L__BB0_46;
-
-	ld.param.f32 	%f467, [compute_forces_param_5];
-	cvt.s64.s32 	%rd9, %r2;
-	add.s64 	%rd10, %rd1, %rd9;
-	ld.global.u8 	%rs1, [%rd10];
-	cvt.rn.f32.u16 	%f118, %rs1;
-	mov.u32 	%r31, _ZZ14compute_forcesE16shared_positions;
-	mad.lo.s32 	%r3, %r1, 12, %r31;
-	shl.b32 	%r32, %r1, 2;
-	mov.u32 	%r33, _ZZ14compute_forcesE13shared_masses;
-	add.s32 	%r4, %r33, %r32;
-	mul.f32 	%f4, %f118, %f467;
-	add.s32 	%r34, %r26, 255;
-	shr.s32 	%r35, %r34, 31;
-	shr.u32 	%r36, %r35, 24;
-	add.s32 	%r37, %r34, %r36;
-	shr.s32 	%r5, %r37, 8;
-	mov.f32 	%f476, 0f00000000;
-	mov.u32 	%r100, 0;
-	mov.f32 	%f475, %f476;
-	mov.f32 	%f474, %f476;
+	ld.param.u64 	%rd5, [compute_forces_param_0];
+	ld.param.u32 	%r42, [compute_forces_param_3];
+	ld.param.f32 	%f222, [compute_forces_param_4];
+	ld.param.f32 	%f223, [compute_forces_param_5];
+	ld.param.f32 	%f224, [compute_forces_param_6];
+	ld.param.f32 	%f225, [compute_forces_param_7];
+	cvta.to.global.u64 	%rd1, %rd5;
+	mov.u32 	%r1, %ntid.x;
+	mov.u32 	%r43, %ctaid.x;
+	mov.u32 	%r2, %tid.x;
+	mad.lo.s32 	%r3, %r43, %r1, %r2;
+	setp.ge.u32 	%p1, %r3, %r42;
+	@%p1 bra 	$L__BB0_79;
+
+	mul.wide.s32 	%rd6, %r3, 16;
+	add.s64 	%rd3, %rd1, %rd6;
+	ld.global.f32 	%f1, [%rd3];
+	ld.global.f32 	%f2, [%rd3+4];
+	ld.global.f32 	%f3, [%rd3+8];
+	ld.global.u8 	%rs17, [%rd3+12];
+	cvt.rn.f32.u16 	%f4, %rs17;
+	add.s32 	%r44, %r1, %r42;
+	add.s32 	%r4, %r44, -1;
+	setp.gt.u32 	%p2, %r1, %r4;
+	mov.f32 	%f655, 0f00000000;
+	mov.f32 	%f656, %f655;
+	mov.f32 	%f657, %f655;
+	@%p2 bra 	$L__BB0_76;
+
+	ld.global.u8 	%rs1, [%rd3+13];
+	mov.u32 	%r46, _ZZ14compute_forcesE16shared_positions;
+	mad.lo.s32 	%r5, %r2, 12, %r46;
+	shl.b32 	%r47, %r2, 2;
+	mov.u32 	%r48, _ZZ14compute_forcesE13shared_masses;
+	add.s32 	%r6, %r48, %r47;
+	mov.u32 	%r76, 0;
+	div.u32 	%r8, %r4, %r1;
+	mov.f32 	%f657, 0f00000000;
+	mov.f32 	%f656, %f657;
+	mov.f32 	%f655, %f657;
 
 $L__BB0_3:
-	shl.b32 	%r7, %r100, 8;
-	sub.s32 	%r38, %r7, %r26;
-	add.s32 	%r10, %r7, %r1;
-	setp.ge.s32 	%p3, %r10, %r26;
+	neg.s32 	%r71, %r1;
+	mul.lo.s32 	%r10, %r1, %r76;
+	sub.s32 	%r49, %r10, %r42;
+	max.u32 	%r11, %r49, %r71;
+	neg.s32 	%r12, %r11;
+	add.s32 	%r13, %r10, %r2;
+	setp.ge.u32 	%p3, %r13, %r42;
 	@%p3 bra 	$L__BB0_5;
 
-	mul.lo.s32 	%r39, %r10, 3;
-	mul.wide.s32 	%rd11, %r39, 4;
-	add.s64 	%rd12, %rd2, %rd11;
-	ld.global.f32 	%f119, [%rd12];
-	ld.global.f32 	%f120, [%rd12+4];
-	ld.global.f32 	%f121, [%rd12+8];
-	st.shared.f32 	[%r3], %f119;
-	st.shared.f32 	[%r3+4], %f120;
-	st.shared.f32 	[%r3+8], %f121;
-	cvt.s64.s32 	%rd13, %r10;
-	add.s64 	%rd14, %rd1, %rd13;
-	ld.global.u8 	%rs2, [%rd14];
-	cvt.rn.f32.u16 	%f122, %rs2;
-	st.shared.f32 	[%r4], %f122;
+	mul.wide.s32 	%rd7, %r13, 16;
+	add.s64 	%rd8, %rd1, %rd7;
+	ld.global.f32 	%f233, [%rd8];
+	ld.global.f32 	%f234, [%rd8+4];
+	ld.global.f32 	%f235, [%rd8+8];
+	ld.global.u8 	%rs18, [%rd8+12];
+	st.shared.f32 	[%r5], %f233;
+	st.shared.f32 	[%r5+4], %f234;
+	st.shared.f32 	[%r5+8], %f235;
+	cvt.rn.f32.u16 	%f236, %rs18;
+	st.shared.f32 	[%r6], %f236;
 
 $L__BB0_5:
-	shl.b32 	%r78, %r100, 8;
+	setp.eq.s32 	%p4, %r1, 0;
 	bar.sync 	0;
-	setp.ge.s32 	%p4, %r78, %r26;
-	@%p4 bra 	$L__BB0_45;
-
-	max.u32 	%r85, %r38, -256;
-	shl.b32 	%r84, %r100, 8;
-	sub.s32 	%r83, %r84, %r26;
-	max.u32 	%r82, %r83, -256;
-	neg.s32 	%r81, %r82;
-	shl.b32 	%r104, %r100, 8;
-	and.b32  	%r11, %r81, 7;
-	setp.gt.u32 	%p5, %r82, -8;
-	mov.u32 	%r105, 0;
-	@%p5 bra 	$L__BB0_25;
-
-	shl.b32 	%r89, %r100, 8;
-	sub.s32 	%r88, %r89, %r26;
-	max.u32 	%r87, %r88, -256;
-	neg.s32 	%r86, %r87;
-	shl.b32 	%r104, %r100, 8;
-	sub.s32 	%r103, %r86, %r11;
-	mov.u32 	%r105, 0;
+	setp.ge.u32 	%p5, %r10, %r42;
+	or.pred  	%p6, %p4, %p5;
+	@%p6 bra 	$L__BB0_75;
+
+	mul.lo.s32 	%r80, %r1, %r76;
+	neg.s32 	%r74, %r1;
+	sub.s32 	%r73, %r80, %r42;
+	max.u32 	%r72, %r73, %r74;
+	and.b32  	%r14, %r12, 7;
+	setp.gt.u32 	%p7, %r72, -8;
+	mov.u32 	%r81, 0;
+	@%p7 bra 	$L__BB0_41;
+
+	sub.s32 	%r79, %r12, %r14;
+	mov.u32 	%r81, 0;
+	mov.u32 	%r80, %r10;
 
 $L__BB0_8:
 	.pragma "nounroll";
-	mad.lo.s32 	%r16, %r105, 12, %r31;
-	shl.b32 	%r43, %r105, 2;
-	add.s32 	%r17, %r33, %r43;
-	setp.eq.s32 	%p6, %r104, %r2;
-	@%p6 bra 	$L__BB0_10;
-
-	ld.shared.f32 	%f124, [%r16];
-	sub.f32 	%f125, %f1, %f124;
-	ld.shared.f32 	%f126, [%r16+4];
-	sub.f32 	%f127, %f2, %f126;
-	ld.shared.f32 	%f128, [%r16+8];
-	sub.f32 	%f129, %f3, %f128;
-	mul.f32 	%f130, %f127, %f127;
-	fma.rn.f32 	%f131, %f125, %f125, %f130;
-	fma.rn.f32 	%f132, %f129, %f129, %f131;
-	sqrt.rn.f32 	%f133, %f132;
-	mov.f32 	%f134, 0f38D1B717;
-	max.f32 	%f135, %f133, %f134;
-	ld.shared.f32 	%f136, [%r17];
-	mul.f32 	%f137, %f4, %f136;
-	mul.f32 	%f138, %f135, %f135;
-	div.rn.f32 	%f139, %f137, %f138;
-	mul.f32 	%f140, %f125, %f139;
-	div.rn.f32 	%f141, %f140, %f135;
-	add.f32 	%f474, %f474, %f141;
-	mul.f32 	%f142, %f127, %f139;
-	div.rn.f32 	%f143, %f142, %f135;
-	add.f32 	%f475, %f475, %f143;
-	mul.f32 	%f144, %f129, %f139;
-	div.rn.f32 	%f145, %f144, %f135;
-	add.f32 	%f476, %f476, %f145;
-
-$L__BB0_10:
-	shl.b32 	%r75, %r100, 8;
-	add.s32 	%r45, %r105, %r75;
-	add.s32 	%r46, %r45, 1;
-	setp.eq.s32 	%p7, %r46, %r2;
-	@%p7 bra 	$L__BB0_12;
-
-	ld.shared.f32 	%f146, [%r16+12];
-	sub.f32 	%f147, %f1, %f146;
-	ld.shared.f32 	%f148, [%r16+16];
-	sub.f32 	%f149, %f2, %f148;
-	ld.shared.f32 	%f150, [%r16+20];
-	sub.f32 	%f151, %f3, %f150;
-	mul.f32 	%f152, %f149, %f149;
-	fma.rn.f32 	%f153, %f147, %f147, %f152;
-	fma.rn.f32 	%f154, %f151, %f151, %f153;
-	sqrt.rn.f32 	%f155, %f154;
-	mov.f32 	%f156, 0f38D1B717;
-	max.f32 	%f157, %f155, %f156;
-	ld.shared.f32 	%f158, [%r17+4];
-	mul.f32 	%f159, %f4, %f158;
-	mul.f32 	%f160, %f157, %f157;
-	div.rn.f32 	%f161, %f159, %f160;
-	mul.f32 	%f162, %f147, %f161;
-	div.rn.f32 	%f163, %f162, %f157;
-	add.f32 	%f474, %f474, %f163;
-	mul.f32 	%f164, %f149, %f161;
-	div.rn.f32 	%f165, %f164, %f157;
-	add.f32 	%f475, %f475, %f165;
-	mul.f32 	%f166, %f151, %f161;
-	div.rn.f32 	%f167, %f166, %f157;
-	add.f32 	%f476, %f476, %f167;
+	mad.lo.s32 	%r19, %r81, 12, %r46;
+	shl.b32 	%r53, %r81, 2;
+	add.s32 	%r20, %r48, %r53;
+	setp.eq.s32 	%p8, %r80, %r3;
+	@%p8 bra 	$L__BB0_12;
+
+	mul.wide.u32 	%rd9, %r80, 16;
+	add.s64 	%rd10, %rd1, %rd9;
+	ld.global.u8 	%rs2, [%rd10+13];
+	and.b16  	%rs19, %rs2, 1;
+	setp.eq.b16 	%p9, %rs19, 1;
+	mov.pred 	%p10, 0;
+	xor.pred  	%p11, %p9, %p10;
+	not.pred 	%p12, %p11;
+	@%p12 bra 	$L__BB0_12;
+
+	ld.shared.f32 	%f238, [%r19];
+	sub.f32 	%f239, %f1, %f238;
+	ld.shared.f32 	%f240, [%r19+4];
+	sub.f32 	%f241, %f2, %f240;
+	ld.shared.f32 	%f242, [%r19+8];
+	sub.f32 	%f243, %f3, %f242;
+	mul.f32 	%f244, %f241, %f241;
+	fma.rn.f32 	%f245, %f239, %f239, %f244;
+	fma.rn.f32 	%f246, %f243, %f243, %f245;
+	sqrt.rn.f32 	%f247, %f246;
+	mov.f32 	%f248, 0f3DCCCCCD;
+	max.f32 	%f11, %f247, %f248;
+	rcp.rn.f32 	%f249, %f11;
+	mul.f32 	%f12, %f239, %f249;
+	mul.f32 	%f13, %f241, %f249;
+	mul.f32 	%f14, %f243, %f249;
+	ld.shared.f32 	%f250, [%r20];
+	mul.f32 	%f251, %f250, %f4;
+	sqrt.rn.f32 	%f252, %f251;
+	mul.f32 	%f253, %f252, %f224;
+	div.rn.f32 	%f254, %f253, %f246;
+	fma.rn.f32 	%f655, %f254, %f12, %f655;
+	fma.rn.f32 	%f656, %f254, %f13, %f656;
+	fma.rn.f32 	%f657, %f254, %f14, %f657;
+	and.b16  	%rs20, %rs1, %rs2;
+	and.b16  	%rs21, %rs20, 2;
+	setp.eq.s16 	%p13, %rs21, 0;
+	@%p13 bra 	$L__BB0_12;
+
+	sub.f32 	%f255, %f11, %f223;
+	mul.f32 	%f256, %f255, %f222;
+	mul.f32 	%f257, %f256, %f225;
+	mul.f32 	%f258, %f257, %f12;
+	sub.f32 	%f655, %f655, %f258;
+	mul.f32 	%f259, %f257, %f13;
+	sub.f32 	%f656, %f656, %f259;
+	mul.f32 	%f260, %f257, %f14;
+	sub.f32 	%f657, %f657, %f260;
 
 $L__BB0_12:
-	add.s32 	%r48, %r45, 2;
-	setp.eq.s32 	%p8, %r48, %r2;
-	@%p8 bra 	$L__BB0_14;
-
-	ld.shared.f32 	%f168, [%r16+24];
-	sub.f32 	%f169, %f1, %f168;
-	ld.shared.f32 	%f170, [%r16+28];
-	sub.f32 	%f171, %f2, %f170;
-	ld.shared.f32 	%f172, [%r16+32];
-	sub.f32 	%f173, %f3, %f172;
-	mul.f32 	%f174, %f171, %f171;
-	fma.rn.f32 	%f175, %f169, %f169, %f174;
-	fma.rn.f32 	%f176, %f173, %f173, %f175;
-	sqrt.rn.f32 	%f177, %f176;
-	mov.f32 	%f178, 0f38D1B717;
-	max.f32 	%f179, %f177, %f178;
-	ld.shared.f32 	%f180, [%r17+8];
-	mul.f32 	%f181, %f4, %f180;
-	mul.f32 	%f182, %f179, %f179;
-	div.rn.f32 	%f183, %f181, %f182;
-	mul.f32 	%f184, %f169, %f183;
-	div.rn.f32 	%f185, %f184, %f179;
-	add.f32 	%f474, %f474, %f185;
-	mul.f32 	%f186, %f171, %f183;
-	div.rn.f32 	%f187, %f186, %f179;
-	add.f32 	%f475, %f475, %f187;
-	mul.f32 	%f188, %f173, %f183;
-	div.rn.f32 	%f189, %f188, %f179;
-	add.f32 	%f476, %f476, %f189;
-
-$L__BB0_14:
-	add.s32 	%r50, %r45, 3;
-	setp.eq.s32 	%p9, %r50, %r2;
-	@%p9 bra 	$L__BB0_16;
-
-	ld.shared.f32 	%f190, [%r16+36];
-	sub.f32 	%f191, %f1, %f190;
-	ld.shared.f32 	%f192, [%r16+40];
-	sub.f32 	%f193, %f2, %f192;
-	ld.shared.f32 	%f194, [%r16+44];
-	sub.f32 	%f195, %f3, %f194;
-	mul.f32 	%f196, %f193, %f193;
-	fma.rn.f32 	%f197, %f191, %f191, %f196;
-	fma.rn.f32 	%f198, %f195, %f195, %f197;
-	sqrt.rn.f32 	%f199, %f198;
-	mov.f32 	%f200, 0f38D1B717;
-	max.f32 	%f201, %f199, %f200;
-	ld.shared.f32 	%f202, [%r17+12];
-	mul.f32 	%f203, %f4, %f202;
-	mul.f32 	%f204, %f201, %f201;
-	div.rn.f32 	%f205, %f203, %f204;
-	mul.f32 	%f206, %f191, %f205;
-	div.rn.f32 	%f207, %f206, %f201;
-	add.f32 	%f474, %f474, %f207;
-	mul.f32 	%f208, %f193, %f205;
-	div.rn.f32 	%f209, %f208, %f201;
-	add.f32 	%f475, %f475, %f209;
-	mul.f32 	%f210, %f195, %f205;
-	div.rn.f32 	%f211, %f210, %f201;
-	add.f32 	%f476, %f476, %f211;
+	add.s32 	%r55, %r81, %r10;
+	add.s32 	%r21, %r55, 1;
+	setp.eq.s32 	%p14, %r21, %r3;
+	@%p14 bra 	$L__BB0_16;
+
+	mul.wide.u32 	%rd11, %r21, 16;
+	add.s64 	%rd12, %rd1, %rd11;
+	ld.global.u8 	%rs3, [%rd12+13];
+	and.b16  	%rs22, %rs3, 1;
+	setp.eq.b16 	%p15, %rs22, 1;
+	mov.pred 	%p16, 0;
+	xor.pred  	%p17, %p15, %p16;
+	not.pred 	%p18, %p17;
+	@%p18 bra 	$L__BB0_16;
+
+	ld.shared.f32 	%f261, [%r19+12];
+	sub.f32 	%f262, %f1, %f261;
+	ld.shared.f32 	%f263, [%r19+16];
+	sub.f32 	%f264, %f2, %f263;
+	ld.shared.f32 	%f265, [%r19+20];
+	sub.f32 	%f266, %f3, %f265;
+	mul.f32 	%f267, %f264, %f264;
+	fma.rn.f32 	%f268, %f262, %f262, %f267;
+	fma.rn.f32 	%f269, %f266, %f266, %f268;
+	sqrt.rn.f32 	%f270, %f269;
+	mov.f32 	%f271, 0f3DCCCCCD;
+	max.f32 	%f24, %f270, %f271;
+	rcp.rn.f32 	%f272, %f24;
+	mul.f32 	%f25, %f262, %f272;
+	mul.f32 	%f26, %f264, %f272;
+	mul.f32 	%f27, %f266, %f272;
+	ld.shared.f32 	%f273, [%r20+4];
+	mul.f32 	%f274, %f273, %f4;
+	sqrt.rn.f32 	%f275, %f274;
+	mul.f32 	%f276, %f275, %f224;
+	div.rn.f32 	%f277, %f276, %f269;
+	fma.rn.f32 	%f655, %f277, %f25, %f655;
+	fma.rn.f32 	%f656, %f277, %f26, %f656;
+	fma.rn.f32 	%f657, %f277, %f27, %f657;
+	and.b16  	%rs23, %rs1, %rs3;
+	and.b16  	%rs24, %rs23, 2;
+	setp.eq.s16 	%p19, %rs24, 0;
+	@%p19 bra 	$L__BB0_16;
+
+	sub.f32 	%f278, %f24, %f223;
+	mul.f32 	%f279, %f278, %f222;
+	mul.f32 	%f280, %f279, %f225;
+	mul.f32 	%f281, %f280, %f25;
+	sub.f32 	%f655, %f655, %f281;
+	mul.f32 	%f282, %f280, %f26;
+	sub.f32 	%f656, %f656, %f282;
+	mul.f32 	%f283, %f280, %f27;
+	sub.f32 	%f657, %f657, %f283;
 
 $L__BB0_16:
-	add.s32 	%r52, %r45, 4;
-	setp.eq.s32 	%p10, %r52, %r2;
-	@%p10 bra 	$L__BB0_18;
-
-	ld.shared.f32 	%f212, [%r16+48];
-	sub.f32 	%f213, %f1, %f212;
-	ld.shared.f32 	%f214, [%r16+52];
-	sub.f32 	%f215, %f2, %f214;
-	ld.shared.f32 	%f216, [%r16+56];
-	sub.f32 	%f217, %f3, %f216;
-	mul.f32 	%f218, %f215, %f215;
-	fma.rn.f32 	%f219, %f213, %f213, %f218;
-	fma.rn.f32 	%f220, %f217, %f217, %f219;
-	sqrt.rn.f32 	%f221, %f220;
-	mov.f32 	%f222, 0f38D1B717;
-	max.f32 	%f223, %f221, %f222;
-	ld.shared.f32 	%f224, [%r17+16];
-	mul.f32 	%f225, %f4, %f224;
-	mul.f32 	%f226, %f223, %f223;
-	div.rn.f32 	%f227, %f225, %f226;
-	mul.f32 	%f228, %f213, %f227;
-	div.rn.f32 	%f229, %f228, %f223;
-	add.f32 	%f474, %f474, %f229;
-	mul.f32 	%f230, %f215, %f227;
-	div.rn.f32 	%f231, %f230, %f223;
-	add.f32 	%f475, %f475, %f231;
-	mul.f32 	%f232, %f217, %f227;
-	div.rn.f32 	%f233, %f232, %f223;
-	add.f32 	%f476, %f476, %f233;
-
-$L__BB0_18:
-	add.s32 	%r54, %r45, 5;
-	setp.eq.s32 	%p11, %r54, %r2;
-	@%p11 bra 	$L__BB0_20;
-
-	ld.shared.f32 	%f234, [%r16+60];
-	sub.f32 	%f235, %f1, %f234;
-	ld.shared.f32 	%f236, [%r16+64];
-	sub.f32 	%f237, %f2, %f236;
-	ld.shared.f32 	%f238, [%r16+68];
-	sub.f32 	%f239, %f3, %f238;
-	mul.f32 	%f240, %f237, %f237;
-	fma.rn.f32 	%f241, %f235, %f235, %f240;
-	fma.rn.f32 	%f242, %f239, %f239, %f241;
-	sqrt.rn.f32 	%f243, %f242;
-	mov.f32 	%f244, 0f38D1B717;
-	max.f32 	%f245, %f243, %f244;
-	ld.shared.f32 	%f246, [%r17+20];
-	mul.f32 	%f247, %f4, %f246;
-	mul.f32 	%f248, %f245, %f245;
-	div.rn.f32 	%f249, %f247, %f248;
-	mul.f32 	%f250, %f235, %f249;
-	div.rn.f32 	%f251, %f250, %f245;
-	add.f32 	%f474, %f474, %f251;
-	mul.f32 	%f252, %f237, %f249;
-	div.rn.f32 	%f253, %f252, %f245;
-	add.f32 	%f475, %f475, %f253;
-	mul.f32 	%f254, %f239, %f249;
-	div.rn.f32 	%f255, %f254, %f245;
-	add.f32 	%f476, %f476, %f255;
+	add.s32 	%r22, %r55, 2;
+	setp.eq.s32 	%p20, %r22, %r3;
+	@%p20 bra 	$L__BB0_20;
+
+	mul.wide.u32 	%rd13, %r22, 16;
+	add.s64 	%rd14, %rd1, %rd13;
+	ld.global.u8 	%rs4, [%rd14+13];
+	and.b16  	%rs25, %rs4, 1;
+	setp.eq.b16 	%p21, %rs25, 1;
+	mov.pred 	%p22, 0;
+	xor.pred  	%p23, %p21, %p22;
+	not.pred 	%p24, %p23;
+	@%p24 bra 	$L__BB0_20;
+
+	ld.shared.f32 	%f284, [%r19+24];
+	sub.f32 	%f285, %f1, %f284;
+	ld.shared.f32 	%f286, [%r19+28];
+	sub.f32 	%f287, %f2, %f286;
+	ld.shared.f32 	%f288, [%r19+32];
+	sub.f32 	%f289, %f3, %f288;
+	mul.f32 	%f290, %f287, %f287;
+	fma.rn.f32 	%f291, %f285, %f285, %f290;
+	fma.rn.f32 	%f292, %f289, %f289, %f291;
+	sqrt.rn.f32 	%f293, %f292;
+	mov.f32 	%f294, 0f3DCCCCCD;
+	max.f32 	%f37, %f293, %f294;
+	rcp.rn.f32 	%f295, %f37;
+	mul.f32 	%f38, %f285, %f295;
+	mul.f32 	%f39, %f287, %f295;
+	mul.f32 	%f40, %f289, %f295;
+	ld.shared.f32 	%f296, [%r20+8];
+	mul.f32 	%f297, %f296, %f4;
+	sqrt.rn.f32 	%f298, %f297;
+	mul.f32 	%f299, %f298, %f224;
+	div.rn.f32 	%f300, %f299, %f292;
+	fma.rn.f32 	%f655, %f300, %f38, %f655;
+	fma.rn.f32 	%f656, %f300, %f39, %f656;
+	fma.rn.f32 	%f657, %f300, %f40, %f657;
+	and.b16  	%rs26, %rs1, %rs4;
+	and.b16  	%rs27, %rs26, 2;
+	setp.eq.s16 	%p25, %rs27, 0;
+	@%p25 bra 	$L__BB0_20;
+
+	sub.f32 	%f301, %f37, %f223;
+	mul.f32 	%f302, %f301, %f222;
+	mul.f32 	%f303, %f302, %f225;
+	mul.f32 	%f304, %f303, %f38;
+	sub.f32 	%f655, %f655, %f304;
+	mul.f32 	%f305, %f303, %f39;
+	sub.f32 	%f656, %f656, %f305;
+	mul.f32 	%f306, %f303, %f40;
+	sub.f32 	%f657, %f657, %f306;
 
 $L__BB0_20:
-	add.s32 	%r56, %r45, 6;
-	setp.eq.s32 	%p12, %r56, %r2;
-	@%p12 bra 	$L__BB0_22;
-
-	ld.shared.f32 	%f256, [%r16+72];
-	sub.f32 	%f257, %f1, %f256;
-	ld.shared.f32 	%f258, [%r16+76];
-	sub.f32 	%f259, %f2, %f258;
-	ld.shared.f32 	%f260, [%r16+80];
-	sub.f32 	%f261, %f3, %f260;
-	mul.f32 	%f262, %f259, %f259;
-	fma.rn.f32 	%f263, %f257, %f257, %f262;
-	fma.rn.f32 	%f264, %f261, %f261, %f263;
-	sqrt.rn.f32 	%f265, %f264;
-	mov.f32 	%f266, 0f38D1B717;
-	max.f32 	%f267, %f265, %f266;
-	ld.shared.f32 	%f268, [%r17+24];
-	mul.f32 	%f269, %f4, %f268;
-	mul.f32 	%f270, %f267, %f267;
-	div.rn.f32 	%f271, %f269, %f270;
-	mul.f32 	%f272, %f257, %f271;
-	div.rn.f32 	%f273, %f272, %f267;
-	add.f32 	%f474, %f474, %f273;
-	mul.f32 	%f274, %f259, %f271;
-	div.rn.f32 	%f275, %f274, %f267;
-	add.f32 	%f475, %f475, %f275;
-	mul.f32 	%f276, %f261, %f271;
-	div.rn.f32 	%f277, %f276, %f267;
-	add.f32 	%f476, %f476, %f277;
-
-$L__BB0_22:
-	add.s32 	%r58, %r45, 7;
-	setp.eq.s32 	%p13, %r58, %r2;
-	@%p13 bra 	$L__BB0_24;
-
-	ld.shared.f32 	%f278, [%r16+84];
-	sub.f32 	%f279, %f1, %f278;
-	ld.shared.f32 	%f280, [%r16+88];
-	sub.f32 	%f281, %f2, %f280;
-	ld.shared.f32 	%f282, [%r16+92];
-	sub.f32 	%f283, %f3, %f282;
-	mul.f32 	%f284, %f281, %f281;
-	fma.rn.f32 	%f285, %f279, %f279, %f284;
-	fma.rn.f32 	%f286, %f283, %f283, %f285;
-	sqrt.rn.f32 	%f287, %f286;
-	mov.f32 	%f288, 0f38D1B717;
-	max.f32 	%f289, %f287, %f288;
-	ld.shared.f32 	%f290, [%r17+28];
-	mul.f32 	%f291, %f4, %f290;
-	mul.f32 	%f292, %f289, %f289;
-	div.rn.f32 	%f293, %f291, %f292;
-	mul.f32 	%f294, %f279, %f293;
-	div.rn.f32 	%f295, %f294, %f289;
-	add.f32 	%f474, %f474, %f295;
-	mul.f32 	%f296, %f281, %f293;
-	div.rn.f32 	%f297, %f296, %f289;
-	add.f32 	%f475, %f475, %f297;
-	mul.f32 	%f298, %f283, %f293;
-	div.rn.f32 	%f299, %f298, %f289;
-	add.f32 	%f476, %f476, %f299;
+	add.s32 	%r23, %r55, 3;
+	setp.eq.s32 	%p26, %r23, %r3;
+	@%p26 bra 	$L__BB0_24;
+
+	mul.wide.u32 	%rd15, %r23, 16;
+	add.s64 	%rd16, %rd1, %rd15;
+	ld.global.u8 	%rs5, [%rd16+13];
+	and.b16  	%rs28, %rs5, 1;
+	setp.eq.b16 	%p27, %rs28, 1;
+	mov.pred 	%p28, 0;
+	xor.pred  	%p29, %p27, %p28;
+	not.pred 	%p30, %p29;
+	@%p30 bra 	$L__BB0_24;
+
+	ld.shared.f32 	%f307, [%r19+36];
+	sub.f32 	%f308, %f1, %f307;
+	ld.shared.f32 	%f309, [%r19+40];
+	sub.f32 	%f310, %f2, %f309;
+	ld.shared.f32 	%f311, [%r19+44];
+	sub.f32 	%f312, %f3, %f311;
+	mul.f32 	%f313, %f310, %f310;
+	fma.rn.f32 	%f314, %f308, %f308, %f313;
+	fma.rn.f32 	%f315, %f312, %f312, %f314;
+	sqrt.rn.f32 	%f316, %f315;
+	mov.f32 	%f317, 0f3DCCCCCD;
+	max.f32 	%f50, %f316, %f317;
+	rcp.rn.f32 	%f318, %f50;
+	mul.f32 	%f51, %f308, %f318;
+	mul.f32 	%f52, %f310, %f318;
+	mul.f32 	%f53, %f312, %f318;
+	ld.shared.f32 	%f319, [%r20+12];
+	mul.f32 	%f320, %f319, %f4;
+	sqrt.rn.f32 	%f321, %f320;
+	mul.f32 	%f322, %f321, %f224;
+	div.rn.f32 	%f323, %f322, %f315;
+	fma.rn.f32 	%f655, %f323, %f51, %f655;
+	fma.rn.f32 	%f656, %f323, %f52, %f656;
+	fma.rn.f32 	%f657, %f323, %f53, %f657;
+	and.b16  	%rs29, %rs1, %rs5;
+	and.b16  	%rs30, %rs29, 2;
+	setp.eq.s16 	%p31, %rs30, 0;
+	@%p31 bra 	$L__BB0_24;
+
+	sub.f32 	%f324, %f50, %f223;
+	mul.f32 	%f325, %f324, %f222;
+	mul.f32 	%f326, %f325, %f225;
+	mul.f32 	%f327, %f326, %f51;
+	sub.f32 	%f655, %f655, %f327;
+	mul.f32 	%f328, %f326, %f52;
+	sub.f32 	%f656, %f656, %f328;
+	mul.f32 	%f329, %f326, %f53;
+	sub.f32 	%f657, %f657, %f329;
 
 $L__BB0_24:
-	shl.b32 	%r74, %r100, 8;
-	add.s32 	%r105, %r105, 8;
-	add.s32 	%r104, %r105, %r74;
-	add.s32 	%r103, %r103, -8;
-	setp.ne.s32 	%p14, %r103, 0;
-	@%p14 bra 	$L__BB0_8;
-
-$L__BB0_25:
-	setp.eq.s32 	%p15, %r11, 0;
-	@%p15 bra 	$L__BB0_45;
-
-	setp.eq.s32 	%p16, %r104, %r2;
-	mad.lo.s32 	%r23, %r105, 12, %r31;
-	shl.b32 	%r60, %r105, 2;
-	add.s32 	%r24, %r33, %r60;
-	@%p16 bra 	$L__BB0_28;
-
-	ld.shared.f32 	%f300, [%r23];
-	sub.f32 	%f301, %f1, %f300;
-	ld.shared.f32 	%f302, [%r23+4];
-	sub.f32 	%f303, %f2, %f302;
-	ld.shared.f32 	%f304, [%r23+8];
-	sub.f32 	%f305, %f3, %f304;
-	mul.f32 	%f306, %f303, %f303;
-	fma.rn.f32 	%f307, %f301, %f301, %f306;
-	fma.rn.f32 	%f308, %f305, %f305, %f307;
-	sqrt.rn.f32 	%f309, %f308;
-	mov.f32 	%f310, 0f38D1B717;
-	max.f32 	%f311, %f309, %f310;
-	ld.shared.f32 	%f312, [%r24];
-	mul.f32 	%f313, %f4, %f312;
-	mul.f32 	%f314, %f311, %f311;
-	div.rn.f32 	%f315, %f313, %f314;
-	mul.f32 	%f316, %f301, %f315;
-	div.rn.f32 	%f317, %f316, %f311;
-	add.f32 	%f474, %f474, %f317;
-	mul.f32 	%f318, %f303, %f315;
-	div.rn.f32 	%f319, %f318, %f311;
-	add.f32 	%f475, %f475, %f319;
-	mul.f32 	%f320, %f305, %f315;
-	div.rn.f32 	%f321, %f320, %f311;
-	add.f32 	%f476, %f476, %f321;
+	add.s32 	%r24, %r55, 4;
+	setp.eq.s32 	%p32, %r24, %r3;
+	@%p32 bra 	$L__BB0_28;
+
+	mul.wide.u32 	%rd17, %r24, 16;
+	add.s64 	%rd18, %rd1, %rd17;
+	ld.global.u8 	%rs6, [%rd18+13];
+	and.b16  	%rs31, %rs6, 1;
+	setp.eq.b16 	%p33, %rs31, 1;
+	mov.pred 	%p34, 0;
+	xor.pred  	%p35, %p33, %p34;
+	not.pred 	%p36, %p35;
+	@%p36 bra 	$L__BB0_28;
+
+	ld.shared.f32 	%f330, [%r19+48];
+	sub.f32 	%f331, %f1, %f330;
+	ld.shared.f32 	%f332, [%r19+52];
+	sub.f32 	%f333, %f2, %f332;
+	ld.shared.f32 	%f334, [%r19+56];
+	sub.f32 	%f335, %f3, %f334;
+	mul.f32 	%f336, %f333, %f333;
+	fma.rn.f32 	%f337, %f331, %f331, %f336;
+	fma.rn.f32 	%f338, %f335, %f335, %f337;
+	sqrt.rn.f32 	%f339, %f338;
+	mov.f32 	%f340, 0f3DCCCCCD;
+	max.f32 	%f63, %f339, %f340;
+	rcp.rn.f32 	%f341, %f63;
+	mul.f32 	%f64, %f331, %f341;
+	mul.f32 	%f65, %f333, %f341;
+	mul.f32 	%f66, %f335, %f341;
+	ld.shared.f32 	%f342, [%r20+16];
+	mul.f32 	%f343, %f342, %f4;
+	sqrt.rn.f32 	%f344, %f343;
+	mul.f32 	%f345, %f344, %f224;
+	div.rn.f32 	%f346, %f345, %f338;
+	fma.rn.f32 	%f655, %f346, %f64, %f655;
+	fma.rn.f32 	%f656, %f346, %f65, %f656;
+	fma.rn.f32 	%f657, %f346, %f66, %f657;
+	and.b16  	%rs32, %rs1, %rs6;
+	and.b16  	%rs33, %rs32, 2;
+	setp.eq.s16 	%p37, %rs33, 0;
+	@%p37 bra 	$L__BB0_28;
+
+	sub.f32 	%f347, %f63, %f223;
+	mul.f32 	%f348, %f347, %f222;
+	mul.f32 	%f349, %f348, %f225;
+	mul.f32 	%f350, %f349, %f64;
+	sub.f32 	%f655, %f655, %f350;
+	mul.f32 	%f351, %f349, %f65;
+	sub.f32 	%f656, %f656, %f351;
+	mul.f32 	%f352, %f349, %f66;
+	sub.f32 	%f657, %f657, %f352;
 
 $L__BB0_28:
-	setp.eq.s32 	%p17, %r11, 1;
-	@%p17 bra 	$L__BB0_45;
-
-	shl.b32 	%r76, %r100, 8;
-	add.s32 	%r62, %r105, %r76;
-	add.s32 	%r63, %r62, 1;
-	setp.eq.s32 	%p18, %r63, %r2;
-	@%p18 bra 	$L__BB0_31;
-
-	ld.shared.f32 	%f322, [%r23+12];
-	sub.f32 	%f323, %f1, %f322;
-	ld.shared.f32 	%f324, [%r23+16];
-	sub.f32 	%f325, %f2, %f324;
-	ld.shared.f32 	%f326, [%r23+20];
-	sub.f32 	%f327, %f3, %f326;
-	mul.f32 	%f328, %f325, %f325;
-	fma.rn.f32 	%f329, %f323, %f323, %f328;
-	fma.rn.f32 	%f330, %f327, %f327, %f329;
-	sqrt.rn.f32 	%f331, %f330;
-	mov.f32 	%f332, 0f38D1B717;
-	max.f32 	%f333, %f331, %f332;
-	ld.shared.f32 	%f334, [%r24+4];
-	mul.f32 	%f335, %f4, %f334;
-	mul.f32 	%f336, %f333, %f333;
-	div.rn.f32 	%f337, %f335, %f336;
-	mul.f32 	%f338, %f323, %f337;
-	div.rn.f32 	%f339, %f338, %f333;
-	add.f32 	%f474, %f474, %f339;
-	mul.f32 	%f340, %f325, %f337;
-	div.rn.f32 	%f341, %f340, %f333;
-	add.f32 	%f475, %f475, %f341;
-	mul.f32 	%f342, %f327, %f337;
-	div.rn.f32 	%f343, %f342, %f333;
-	add.f32 	%f476, %f476, %f343;
-
-$L__BB0_31:
-	setp.eq.s32 	%p19, %r11, 2;
-	@%p19 bra 	$L__BB0_45;
-
-	shl.b32 	%r91, %r100, 8;
-	add.s32 	%r90, %r105, %r91;
-	add.s32 	%r65, %r90, 2;
-	setp.eq.s32 	%p20, %r65, %r2;
-	@%p20 bra 	$L__BB0_34;
-
-	ld.shared.f32 	%f344, [%r23+24];
-	sub.f32 	%f345, %f1, %f344;
-	ld.shared.f32 	%f346, [%r23+28];
-	sub.f32 	%f347, %f2, %f346;
-	ld.shared.f32 	%f348, [%r23+32];
-	sub.f32 	%f349, %f3, %f348;
-	mul.f32 	%f350, %f347, %f347;
-	fma.rn.f32 	%f351, %f345, %f345, %f350;
-	fma.rn.f32 	%f352, %f349, %f349, %f351;
-	sqrt.rn.f32 	%f353, %f352;
-	mov.f32 	%f354, 0f38D1B717;
-	max.f32 	%f355, %f353, %f354;
-	ld.shared.f32 	%f356, [%r24+8];
-	mul.f32 	%f357, %f4, %f356;
-	mul.f32 	%f358, %f355, %f355;
-	div.rn.f32 	%f359, %f357, %f358;
-	mul.f32 	%f360, %f345, %f359;
-	div.rn.f32 	%f361, %f360, %f355;
-	add.f32 	%f474, %f474, %f361;
-	mul.f32 	%f362, %f347, %f359;
-	div.rn.f32 	%f363, %f362, %f355;
-	add.f32 	%f475, %f475, %f363;
-	mul.f32 	%f364, %f349, %f359;
-	div.rn.f32 	%f365, %f364, %f355;
-	add.f32 	%f476, %f476, %f365;
-
-$L__BB0_34:
-	setp.eq.s32 	%p21, %r11, 3;
-	@%p21 bra 	$L__BB0_45;
-
-	shl.b32 	%r93, %r100, 8;
-	add.s32 	%r92, %r105, %r93;
-	add.s32 	%r67, %r92, 3;
-	setp.eq.s32 	%p22, %r67, %r2;
-	@%p22 bra 	$L__BB0_37;
-
-	ld.shared.f32 	%f366, [%r23+36];
-	sub.f32 	%f367, %f1, %f366;
-	ld.shared.f32 	%f368, [%r23+40];
-	sub.f32 	%f369, %f2, %f368;
-	ld.shared.f32 	%f370, [%r23+44];
-	sub.f32 	%f371, %f3, %f370;
-	mul.f32 	%f372, %f369, %f369;
-	fma.rn.f32 	%f373, %f367, %f367, %f372;
-	fma.rn.f32 	%f374, %f371, %f371, %f373;
-	sqrt.rn.f32 	%f375, %f374;
-	mov.f32 	%f376, 0f38D1B717;
-	max.f32 	%f377, %f375, %f376;
-	ld.shared.f32 	%f378, [%r24+12];
-	mul.f32 	%f379, %f4, %f378;
-	mul.f32 	%f380, %f377, %f377;
-	div.rn.f32 	%f381, %f379, %f380;
-	mul.f32 	%f382, %f367, %f381;
-	div.rn.f32 	%f383, %f382, %f377;
-	add.f32 	%f474, %f474, %f383;
-	mul.f32 	%f384, %f369, %f381;
-	div.rn.f32 	%f385, %f384, %f377;
-	add.f32 	%f475, %f475, %f385;
-	mul.f32 	%f386, %f371, %f381;
-	div.rn.f32 	%f387, %f386, %f377;
-	add.f32 	%f476, %f476, %f387;
-
-$L__BB0_37:
-	setp.eq.s32 	%p23, %r11, 4;
-	@%p23 bra 	$L__BB0_45;
-
-	shl.b32 	%r95, %r100, 8;
-	add.s32 	%r94, %r105, %r95;
-	add.s32 	%r69, %r94, 4;
-	setp.eq.s32 	%p24, %r69, %r2;
-	@%p24 bra 	$L__BB0_40;
-
-	ld.shared.f32 	%f388, [%r23+48];
-	sub.f32 	%f389, %f1, %f388;
-	ld.shared.f32 	%f390, [%r23+52];
-	sub.f32 	%f391, %f2, %f390;
-	ld.shared.f32 	%f392, [%r23+56];
-	sub.f32 	%f393, %f3, %f392;
-	mul.f32 	%f394, %f391, %f391;
-	fma.rn.f32 	%f395, %f389, %f389, %f394;
-	fma.rn.f32 	%f396, %f393, %f393, %f395;
-	sqrt.rn.f32 	%f397, %f396;
-	mov.f32 	%f398, 0f38D1B717;
-	max.f32 	%f399, %f397, %f398;
-	ld.shared.f32 	%f400, [%r24+16];
-	mul.f32 	%f401, %f4, %f400;
-	mul.f32 	%f402, %f399, %f399;
-	div.rn.f32 	%f403, %f401, %f402;
-	mul.f32 	%f404, %f389, %f403;
-	div.rn.f32 	%f405, %f404, %f399;
-	add.f32 	%f474, %f474, %f405;
-	mul.f32 	%f406, %f391, %f403;
-	div.rn.f32 	%f407, %f406, %f399;
-	add.f32 	%f475, %f475, %f407;
-	mul.f32 	%f408, %f393, %f403;
-	div.rn.f32 	%f409, %f408, %f399;
-	add.f32 	%f476, %f476, %f409;
+	add.s32 	%r25, %r55, 5;
+	setp.eq.s32 	%p38, %r25, %r3;
+	@%p38 bra 	$L__BB0_32;
+
+	mul.wide.u32 	%rd19, %r25, 16;
+	add.s64 	%rd20, %rd1, %rd19;
+	ld.global.u8 	%rs7, [%rd20+13];
+	and.b16  	%rs34, %rs7, 1;
+	setp.eq.b16 	%p39, %rs34, 1;
+	mov.pred 	%p40, 0;
+	xor.pred  	%p41, %p39, %p40;
+	not.pred 	%p42, %p41;
+	@%p42 bra 	$L__BB0_32;
+
+	ld.shared.f32 	%f353, [%r19+60];
+	sub.f32 	%f354, %f1, %f353;
+	ld.shared.f32 	%f355, [%r19+64];
+	sub.f32 	%f356, %f2, %f355;
+	ld.shared.f32 	%f357, [%r19+68];
+	sub.f32 	%f358, %f3, %f357;
+	mul.f32 	%f359, %f356, %f356;
+	fma.rn.f32 	%f360, %f354, %f354, %f359;
+	fma.rn.f32 	%f361, %f358, %f358, %f360;
+	sqrt.rn.f32 	%f362, %f361;
+	mov.f32 	%f363, 0f3DCCCCCD;
+	max.f32 	%f76, %f362, %f363;
+	rcp.rn.f32 	%f364, %f76;
+	mul.f32 	%f77, %f354, %f364;
+	mul.f32 	%f78, %f356, %f364;
+	mul.f32 	%f79, %f358, %f364;
+	ld.shared.f32 	%f365, [%r20+20];
+	mul.f32 	%f366, %f365, %f4;
+	sqrt.rn.f32 	%f367, %f366;
+	mul.f32 	%f368, %f367, %f224;
+	div.rn.f32 	%f369, %f368, %f361;
+	fma.rn.f32 	%f655, %f369, %f77, %f655;
+	fma.rn.f32 	%f656, %f369, %f78, %f656;
+	fma.rn.f32 	%f657, %f369, %f79, %f657;
+	and.b16  	%rs35, %rs1, %rs7;
+	and.b16  	%rs36, %rs35, 2;
+	setp.eq.s16 	%p43, %rs36, 0;
+	@%p43 bra 	$L__BB0_32;
+
+	sub.f32 	%f370, %f76, %f223;
+	mul.f32 	%f371, %f370, %f222;
+	mul.f32 	%f372, %f371, %f225;
+	mul.f32 	%f373, %f372, %f77;
+	sub.f32 	%f655, %f655, %f373;
+	mul.f32 	%f374, %f372, %f78;
+	sub.f32 	%f656, %f656, %f374;
+	mul.f32 	%f375, %f372, %f79;
+	sub.f32 	%f657, %f657, %f375;
+
+$L__BB0_32:
+	add.s32 	%r26, %r55, 6;
+	setp.eq.s32 	%p44, %r26, %r3;
+	@%p44 bra 	$L__BB0_36;
+
+	mul.wide.u32 	%rd21, %r26, 16;
+	add.s64 	%rd22, %rd1, %rd21;
+	ld.global.u8 	%rs8, [%rd22+13];
+	and.b16  	%rs37, %rs8, 1;
+	setp.eq.b16 	%p45, %rs37, 1;
+	mov.pred 	%p46, 0;
+	xor.pred  	%p47, %p45, %p46;
+	not.pred 	%p48, %p47;
+	@%p48 bra 	$L__BB0_36;
+
+	ld.shared.f32 	%f376, [%r19+72];
+	sub.f32 	%f377, %f1, %f376;
+	ld.shared.f32 	%f378, [%r19+76];
+	sub.f32 	%f379, %f2, %f378;
+	ld.shared.f32 	%f380, [%r19+80];
+	sub.f32 	%f381, %f3, %f380;
+	mul.f32 	%f382, %f379, %f379;
+	fma.rn.f32 	%f383, %f377, %f377, %f382;
+	fma.rn.f32 	%f384, %f381, %f381, %f383;
+	sqrt.rn.f32 	%f385, %f384;
+	mov.f32 	%f386, 0f3DCCCCCD;
+	max.f32 	%f89, %f385, %f386;
+	rcp.rn.f32 	%f387, %f89;
+	mul.f32 	%f90, %f377, %f387;
+	mul.f32 	%f91, %f379, %f387;
+	mul.f32 	%f92, %f381, %f387;
+	ld.shared.f32 	%f388, [%r20+24];
+	mul.f32 	%f389, %f388, %f4;
+	sqrt.rn.f32 	%f390, %f389;
+	mul.f32 	%f391, %f390, %f224;
+	div.rn.f32 	%f392, %f391, %f384;
+	fma.rn.f32 	%f655, %f392, %f90, %f655;
+	fma.rn.f32 	%f656, %f392, %f91, %f656;
+	fma.rn.f32 	%f657, %f392, %f92, %f657;
+	and.b16  	%rs38, %rs1, %rs8;
+	and.b16  	%rs39, %rs38, 2;
+	setp.eq.s16 	%p49, %rs39, 0;
+	@%p49 bra 	$L__BB0_36;
+
+	sub.f32 	%f393, %f89, %f223;
+	mul.f32 	%f394, %f393, %f222;
+	mul.f32 	%f395, %f394, %f225;
+	mul.f32 	%f396, %f395, %f90;
+	sub.f32 	%f655, %f655, %f396;
+	mul.f32 	%f397, %f395, %f91;
+	sub.f32 	%f656, %f656, %f397;
+	mul.f32 	%f398, %f395, %f92;
+	sub.f32 	%f657, %f657, %f398;
+
+$L__BB0_36:
+	add.s32 	%r27, %r55, 7;
+	setp.eq.s32 	%p50, %r27, %r3;
+	@%p50 bra 	$L__BB0_40;
+
+	mul.wide.u32 	%rd23, %r27, 16;
+	add.s64 	%rd24, %rd1, %rd23;
+	ld.global.u8 	%rs9, [%rd24+13];
+	and.b16  	%rs40, %rs9, 1;
+	setp.eq.b16 	%p51, %rs40, 1;
+	mov.pred 	%p52, 0;
+	xor.pred  	%p53, %p51, %p52;
+	not.pred 	%p54, %p53;
+	@%p54 bra 	$L__BB0_40;
+
+	ld.shared.f32 	%f399, [%r19+84];
+	sub.f32 	%f400, %f1, %f399;
+	ld.shared.f32 	%f401, [%r19+88];
+	sub.f32 	%f402, %f2, %f401;
+	ld.shared.f32 	%f403, [%r19+92];
+	sub.f32 	%f404, %f3, %f403;
+	mul.f32 	%f405, %f402, %f402;
+	fma.rn.f32 	%f406, %f400, %f400, %f405;
+	fma.rn.f32 	%f407, %f404, %f404, %f406;
+	sqrt.rn.f32 	%f408, %f407;
+	mov.f32 	%f409, 0f3DCCCCCD;
+	max.f32 	%f102, %f408, %f409;
+	rcp.rn.f32 	%f410, %f102;
+	mul.f32 	%f103, %f400, %f410;
+	mul.f32 	%f104, %f402, %f410;
+	mul.f32 	%f105, %f404, %f410;
+	ld.shared.f32 	%f411, [%r20+28];
+	mul.f32 	%f412, %f411, %f4;
+	sqrt.rn.f32 	%f413, %f412;
+	mul.f32 	%f414, %f413, %f224;
+	div.rn.f32 	%f415, %f414, %f407;
+	fma.rn.f32 	%f655, %f415, %f103, %f655;
+	fma.rn.f32 	%f656, %f415, %f104, %f656;
+	fma.rn.f32 	%f657, %f415, %f105, %f657;
+	and.b16  	%rs41, %rs1, %rs9;
+	and.b16  	%rs42, %rs41, 2;
+	setp.eq.s16 	%p55, %rs42, 0;
+	@%p55 bra 	$L__BB0_40;
+
+	sub.f32 	%f416, %f102, %f223;
+	mul.f32 	%f417, %f416, %f222;
+	mul.f32 	%f418, %f417, %f225;
+	mul.f32 	%f419, %f418, %f103;
+	sub.f32 	%f655, %f655, %f419;
+	mul.f32 	%f420, %f418, %f104;
+	sub.f32 	%f656, %f656, %f420;
+	mul.f32 	%f421, %f418, %f105;
+	sub.f32 	%f657, %f657, %f421;
 
 $L__BB0_40:
-	setp.eq.s32 	%p25, %r11, 5;
-	@%p25 bra 	$L__BB0_45;
-
-	shl.b32 	%r97, %r100, 8;
-	add.s32 	%r96, %r105, %r97;
-	add.s32 	%r71, %r96, 5;
-	setp.eq.s32 	%p26, %r71, %r2;
-	@%p26 bra 	$L__BB0_43;
-
-	ld.shared.f32 	%f410, [%r23+60];
-	sub.f32 	%f411, %f1, %f410;
-	ld.shared.f32 	%f412, [%r23+64];
-	sub.f32 	%f413, %f2, %f412;
-	ld.shared.f32 	%f414, [%r23+68];
-	sub.f32 	%f415, %f3, %f414;
-	mul.f32 	%f416, %f413, %f413;
-	fma.rn.f32 	%f417, %f411, %f411, %f416;
-	fma.rn.f32 	%f418, %f415, %f415, %f417;
-	sqrt.rn.f32 	%f419, %f418;
-	mov.f32 	%f420, 0f38D1B717;
-	max.f32 	%f421, %f419, %f420;
-	ld.shared.f32 	%f422, [%r24+20];
-	mul.f32 	%f423, %f4, %f422;
-	mul.f32 	%f424, %f421, %f421;
-	div.rn.f32 	%f425, %f423, %f424;
-	mul.f32 	%f426, %f411, %f425;
-	div.rn.f32 	%f427, %f426, %f421;
-	add.f32 	%f474, %f474, %f427;
-	mul.f32 	%f428, %f413, %f425;
-	div.rn.f32 	%f429, %f428, %f421;
-	add.f32 	%f475, %f475, %f429;
-	mul.f32 	%f430, %f415, %f425;
-	div.rn.f32 	%f431, %f430, %f421;
-	add.f32 	%f476, %f476, %f431;
-
-$L__BB0_43:
-	shl.b32 	%r99, %r100, 8;
-	add.s32 	%r98, %r105, %r99;
-	add.s32 	%r73, %r98, 6;
-	setp.eq.s32 	%p27, %r73, %r2;
-	setp.eq.s32 	%p28, %r11, 6;
-	or.pred  	%p29, %p28, %p27;
-	@%p29 bra 	$L__BB0_45;
-
-	ld.shared.f32 	%f432, [%r23+72];
-	sub.f32 	%f433, %f1, %f432;
-	ld.shared.f32 	%f434, [%r23+76];
-	sub.f32 	%f435, %f2, %f434;
-	ld.shared.f32 	%f436, [%r23+80];
-	sub.f32 	%f437, %f3, %f436;
-	mul.f32 	%f438, %f435, %f435;
-	fma.rn.f32 	%f439, %f433, %f433, %f438;
-	fma.rn.f32 	%f440, %f437, %f437, %f439;
-	sqrt.rn.f32 	%f441, %f440;
-	mov.f32 	%f442, 0f38D1B717;
-	max.f32 	%f443, %f441, %f442;
-	ld.shared.f32 	%f444, [%r24+24];
-	mul.f32 	%f445, %f4, %f444;
-	mul.f32 	%f446, %f443, %f443;
-	div.rn.f32 	%f447, %f445, %f446;
-	mul.f32 	%f448, %f433, %f447;
-	div.rn.f32 	%f449, %f448, %f443;
-	add.f32 	%f474, %f474, %f449;
-	mul.f32 	%f450, %f435, %f447;
-	div.rn.f32 	%f451, %f450, %f443;
-	add.f32 	%f475, %f475, %f451;
-	mul.f32 	%f452, %f437, %f447;
-	div.rn.f32 	%f453, %f452, %f443;
-	add.f32 	%f476, %f476, %f453;
-
-$L__BB0_45:
-	bar.sync 	0;
-	add.s32 	%r100, %r100, 1;
-	setp.lt.s32 	%p30, %r100, %r5;
-	@%p30 bra 	$L__BB0_3;
+	add.s32 	%r81, %r81, 8;
+	add.s32 	%r80, %r81, %r10;
+	add.s32 	%r79, %r79, -8;
+	setp.ne.s32 	%p56, %r79, 0;
+	@%p56 bra 	$L__BB0_8;
+
+$L__BB0_41:
+	setp.eq.s32 	%p57, %r14, 0;
+	@%p57 bra 	$L__BB0_75;
+
+	setp.eq.s32 	%p58, %r80, %r3;
+	mad.lo.s32 	%r33, %r81, 12, %r46;
+	shl.b32 	%r63, %r81, 2;
+	add.s32 	%r34, %r48, %r63;
+	@%p58 bra 	$L__BB0_46;
+
+	mul.wide.u32 	%rd25, %r80, 16;
+	add.s64 	%rd26, %rd1, %rd25;
+	ld.global.u8 	%rs10, [%rd26+13];
+	and.b16  	%rs43, %rs10, 1;
+	setp.eq.b16 	%p59, %rs43, 1;
+	mov.pred 	%p60, 0;
+	xor.pred  	%p61, %p59, %p60;
+	not.pred 	%p62, %p61;
+	@%p62 bra 	$L__BB0_46;
+
+	ld.shared.f32 	%f422, [%r33];
+	sub.f32 	%f423, %f1, %f422;
+	ld.shared.f32 	%f424, [%r33+4];
+	sub.f32 	%f425, %f2, %f424;
+	ld.shared.f32 	%f426, [%r33+8];
+	sub.f32 	%f427, %f3, %f426;
+	mul.f32 	%f428, %f425, %f425;
+	fma.rn.f32 	%f429, %f423, %f423, %f428;
+	fma.rn.f32 	%f430, %f427, %f427, %f429;
+	sqrt.rn.f32 	%f431, %f430;
+	mov.f32 	%f432, 0f3DCCCCCD;
+	max.f32 	%f121, %f431, %f432;
+	rcp.rn.f32 	%f433, %f121;
+	mul.f32 	%f122, %f423, %f433;
+	mul.f32 	%f123, %f425, %f433;
+	mul.f32 	%f124, %f427, %f433;
+	ld.shared.f32 	%f434, [%r34];
+	mul.f32 	%f435, %f434, %f4;
+	sqrt.rn.f32 	%f436, %f435;
+	mul.f32 	%f437, %f436, %f224;
+	div.rn.f32 	%f438, %f437, %f430;
+	fma.rn.f32 	%f655, %f438, %f122, %f655;
+	fma.rn.f32 	%f656, %f438, %f123, %f656;
+	fma.rn.f32 	%f657, %f438, %f124, %f657;
+	and.b16  	%rs44, %rs1, %rs10;
+	and.b16  	%rs45, %rs44, 2;
+	setp.eq.s16 	%p63, %rs45, 0;
+	@%p63 bra 	$L__BB0_46;
+
+	sub.f32 	%f439, %f121, %f223;
+	mul.f32 	%f440, %f439, %f222;
+	mul.f32 	%f441, %f440, %f225;
+	mul.f32 	%f442, %f441, %f122;
+	sub.f32 	%f655, %f655, %f442;
+	mul.f32 	%f443, %f441, %f123;
+	sub.f32 	%f656, %f656, %f443;
+	mul.f32 	%f444, %f441, %f124;
+	sub.f32 	%f657, %f657, %f444;
 
 $L__BB0_46:
-	ld.param.f32 	%f466, [compute_forces_param_6];
-	mul.lo.s32 	%r77, %r2, 3;
-	cvt.s64.s32 	%rd19, %r77;
-	ld.param.u64 	%rd18, [compute_forces_param_1];
-	cvta.to.global.u64 	%rd15, %rd18;
-	shl.b64 	%rd16, %rd19, 2;
-	add.s64 	%rd17, %rd15, %rd16;
-	ld.global.f32 	%f454, [%rd17];
-	add.f32 	%f455, %f474, %f454;
-	mul.f32 	%f456, %f455, %f466;
-	ld.global.f32 	%f457, [%rd17+4];
-	add.f32 	%f458, %f475, %f457;
-	mul.f32 	%f459, %f458, %f466;
-	ld.global.f32 	%f460, [%rd17+8];
-	add.f32 	%f461, %f476, %f460;
-	mul.f32 	%f462, %f461, %f466;
-	add.f32 	%f463, %f1, %f456;
-	add.f32 	%f464, %f2, %f459;
-	add.f32 	%f465, %f3, %f462;
-	st.global.f32 	[%rd4], %f463;
-	st.global.f32 	[%rd4+4], %f464;
-	st.global.f32 	[%rd4+8], %f465;
-	st.global.f32 	[%rd17], %f456;
-	st.global.f32 	[%rd17+4], %f459;
-	st.global.f32 	[%rd17+8], %f462;
-
-$L__BB0_47:
+	add.s32 	%r65, %r81, %r10;
+	add.s32 	%r35, %r65, 1;
+	setp.eq.s32 	%p64, %r14, 1;
+	@%p64 bra 	$L__BB0_75;
+
+	setp.eq.s32 	%p65, %r35, %r3;
+	@%p65 bra 	$L__BB0_51;
+
+	mul.wide.u32 	%rd27, %r35, 16;
+	add.s64 	%rd28, %rd1, %rd27;
+	ld.global.u8 	%rs11, [%rd28+13];
+	and.b16  	%rs46, %rs11, 1;
+	setp.eq.b16 	%p66, %rs46, 1;
+	mov.pred 	%p67, 0;
+	xor.pred  	%p68, %p66, %p67;
+	not.pred 	%p69, %p68;
+	@%p69 bra 	$L__BB0_51;
+
+	ld.shared.f32 	%f445, [%r33+12];
+	sub.f32 	%f446, %f1, %f445;
+	ld.shared.f32 	%f447, [%r33+16];
+	sub.f32 	%f448, %f2, %f447;
+	ld.shared.f32 	%f449, [%r33+20];
+	sub.f32 	%f450, %f3, %f449;
+	mul.f32 	%f451, %f448, %f448;
+	fma.rn.f32 	%f452, %f446, %f446, %f451;
+	fma.rn.f32 	%f453, %f450, %f450, %f452;
+	sqrt.rn.f32 	%f454, %f453;
+	mov.f32 	%f455, 0f3DCCCCCD;
+	max.f32 	%f134, %f454, %f455;
+	rcp.rn.f32 	%f456, %f134;
+	mul.f32 	%f135, %f446, %f456;
+	mul.f32 	%f136, %f448, %f456;
+	mul.f32 	%f137, %f450, %f456;
+	ld.shared.f32 	%f457, [%r34+4];
+	mul.f32 	%f458, %f457, %f4;
+	sqrt.rn.f32 	%f459, %f458;
+	mul.f32 	%f460, %f459, %f224;
+	div.rn.f32 	%f461, %f460, %f453;
+	fma.rn.f32 	%f655, %f461, %f135, %f655;
+	fma.rn.f32 	%f656, %f461, %f136, %f656;
+	fma.rn.f32 	%f657, %f461, %f137, %f657;
+	and.b16  	%rs47, %rs1, %rs11;
+	and.b16  	%rs48, %rs47, 2;
+	setp.eq.s16 	%p70, %rs48, 0;
+	@%p70 bra 	$L__BB0_51;
+
+	sub.f32 	%f462, %f134, %f223;
+	mul.f32 	%f463, %f462, %f222;
+	mul.f32 	%f464, %f463, %f225;
+	mul.f32 	%f465, %f464, %f135;
+	sub.f32 	%f655, %f655, %f465;
+	mul.f32 	%f466, %f464, %f136;
+	sub.f32 	%f656, %f656, %f466;
+	mul.f32 	%f467, %f464, %f137;
+	sub.f32 	%f657, %f657, %f467;
+
+$L__BB0_51:
+	add.s32 	%r36, %r65, 2;
+	setp.eq.s32 	%p71, %r14, 2;
+	@%p71 bra 	$L__BB0_75;
+
+	setp.eq.s32 	%p72, %r36, %r3;
+	@%p72 bra 	$L__BB0_56;
+
+	mul.wide.u32 	%rd29, %r36, 16;
+	add.s64 	%rd30, %rd1, %rd29;
+	ld.global.u8 	%rs12, [%rd30+13];
+	and.b16  	%rs49, %rs12, 1;
+	setp.eq.b16 	%p73, %rs49, 1;
+	mov.pred 	%p74, 0;
+	xor.pred  	%p75, %p73, %p74;
+	not.pred 	%p76, %p75;
+	@%p76 bra 	$L__BB0_56;
+
+	ld.shared.f32 	%f468, [%r33+24];
+	sub.f32 	%f469, %f1, %f468;
+	ld.shared.f32 	%f470, [%r33+28];
+	sub.f32 	%f471, %f2, %f470;
+	ld.shared.f32 	%f472, [%r33+32];
+	sub.f32 	%f473, %f3, %f472;
+	mul.f32 	%f474, %f471, %f471;
+	fma.rn.f32 	%f475, %f469, %f469, %f474;
+	fma.rn.f32 	%f476, %f473, %f473, %f475;
+	sqrt.rn.f32 	%f477, %f476;
+	mov.f32 	%f478, 0f3DCCCCCD;
+	max.f32 	%f147, %f477, %f478;
+	rcp.rn.f32 	%f479, %f147;
+	mul.f32 	%f148, %f469, %f479;
+	mul.f32 	%f149, %f471, %f479;
+	mul.f32 	%f150, %f473, %f479;
+	ld.shared.f32 	%f480, [%r34+8];
+	mul.f32 	%f481, %f480, %f4;
+	sqrt.rn.f32 	%f482, %f481;
+	mul.f32 	%f483, %f482, %f224;
+	div.rn.f32 	%f484, %f483, %f476;
+	fma.rn.f32 	%f655, %f484, %f148, %f655;
+	fma.rn.f32 	%f656, %f484, %f149, %f656;
+	fma.rn.f32 	%f657, %f484, %f150, %f657;
+	and.b16  	%rs50, %rs1, %rs12;
+	and.b16  	%rs51, %rs50, 2;
+	setp.eq.s16 	%p77, %rs51, 0;
+	@%p77 bra 	$L__BB0_56;
+
+	sub.f32 	%f485, %f147, %f223;
+	mul.f32 	%f486, %f485, %f222;
+	mul.f32 	%f487, %f486, %f225;
+	mul.f32 	%f488, %f487, %f148;
+	sub.f32 	%f655, %f655, %f488;
+	mul.f32 	%f489, %f487, %f149;
+	sub.f32 	%f656, %f656, %f489;
+	mul.f32 	%f490, %f487, %f150;
+	sub.f32 	%f657, %f657, %f490;
+
+$L__BB0_56:
+	add.s32 	%r37, %r65, 3;
+	setp.eq.s32 	%p78, %r14, 3;
+	@%p78 bra 	$L__BB0_75;
+
+	setp.eq.s32 	%p79, %r37, %r3;
+	@%p79 bra 	$L__BB0_61;
+
+	mul.wide.u32 	%rd31, %r37, 16;
+	add.s64 	%rd32, %rd1, %rd31;
+	ld.global.u8 	%rs13, [%rd32+13];
+	and.b16  	%rs52, %rs13, 1;
+	setp.eq.b16 	%p80, %rs52, 1;
+	mov.pred 	%p81, 0;
+	xor.pred  	%p82, %p80, %p81;
+	not.pred 	%p83, %p82;
+	@%p83 bra 	$L__BB0_61;
+
+	ld.shared.f32 	%f491, [%r33+36];
+	sub.f32 	%f492, %f1, %f491;
+	ld.shared.f32 	%f493, [%r33+40];
+	sub.f32 	%f494, %f2, %f493;
+	ld.shared.f32 	%f495, [%r33+44];
+	sub.f32 	%f496, %f3, %f495;
+	mul.f32 	%f497, %f494, %f494;
+	fma.rn.f32 	%f498, %f492, %f492, %f497;
+	fma.rn.f32 	%f499, %f496, %f496, %f498;
+	sqrt.rn.f32 	%f500, %f499;
+	mov.f32 	%f501, 0f3DCCCCCD;
+	max.f32 	%f160, %f500, %f501;
+	rcp.rn.f32 	%f502, %f160;
+	mul.f32 	%f161, %f492, %f502;
+	mul.f32 	%f162, %f494, %f502;
+	mul.f32 	%f163, %f496, %f502;
+	ld.shared.f32 	%f503, [%r34+12];
+	mul.f32 	%f504, %f503, %f4;
+	sqrt.rn.f32 	%f505, %f504;
+	mul.f32 	%f506, %f505, %f224;
+	div.rn.f32 	%f507, %f506, %f499;
+	fma.rn.f32 	%f655, %f507, %f161, %f655;
+	fma.rn.f32 	%f656, %f507, %f162, %f656;
+	fma.rn.f32 	%f657, %f507, %f163, %f657;
+	and.b16  	%rs53, %rs1, %rs13;
+	and.b16  	%rs54, %rs53, 2;
+	setp.eq.s16 	%p84, %rs54, 0;
+	@%p84 bra 	$L__BB0_61;
+
+	sub.f32 	%f508, %f160, %f223;
+	mul.f32 	%f509, %f508, %f222;
+	mul.f32 	%f510, %f509, %f225;
+	mul.f32 	%f511, %f510, %f161;
+	sub.f32 	%f655, %f655, %f511;
+	mul.f32 	%f512, %f510, %f162;
+	sub.f32 	%f656, %f656, %f512;
+	mul.f32 	%f513, %f510, %f163;
+	sub.f32 	%f657, %f657, %f513;
+
+$L__BB0_61:
+	add.s32 	%r38, %r65, 4;
+	setp.eq.s32 	%p85, %r14, 4;
+	@%p85 bra 	$L__BB0_75;
+
+	setp.eq.s32 	%p86, %r38, %r3;
+	@%p86 bra 	$L__BB0_66;
+
+	mul.wide.u32 	%rd33, %r38, 16;
+	add.s64 	%rd34, %rd1, %rd33;
+	ld.global.u8 	%rs14, [%rd34+13];
+	and.b16  	%rs55, %rs14, 1;
+	setp.eq.b16 	%p87, %rs55, 1;
+	mov.pred 	%p88, 0;
+	xor.pred  	%p89, %p87, %p88;
+	not.pred 	%p90, %p89;
+	@%p90 bra 	$L__BB0_66;
+
+	ld.shared.f32 	%f514, [%r33+48];
+	sub.f32 	%f515, %f1, %f514;
+	ld.shared.f32 	%f516, [%r33+52];
+	sub.f32 	%f517, %f2, %f516;
+	ld.shared.f32 	%f518, [%r33+56];
+	sub.f32 	%f519, %f3, %f518;
+	mul.f32 	%f520, %f517, %f517;
+	fma.rn.f32 	%f521, %f515, %f515, %f520;
+	fma.rn.f32 	%f522, %f519, %f519, %f521;
+	sqrt.rn.f32 	%f523, %f522;
+	mov.f32 	%f524, 0f3DCCCCCD;
+	max.f32 	%f173, %f523, %f524;
+	rcp.rn.f32 	%f525, %f173;
+	mul.f32 	%f174, %f515, %f525;
+	mul.f32 	%f175, %f517, %f525;
+	mul.f32 	%f176, %f519, %f525;
+	ld.shared.f32 	%f526, [%r34+16];
+	mul.f32 	%f527, %f526, %f4;
+	sqrt.rn.f32 	%f528, %f527;
+	mul.f32 	%f529, %f528, %f224;
+	div.rn.f32 	%f530, %f529, %f522;
+	fma.rn.f32 	%f655, %f530, %f174, %f655;
+	fma.rn.f32 	%f656, %f530, %f175, %f656;
+	fma.rn.f32 	%f657, %f530, %f176, %f657;
+	and.b16  	%rs56, %rs1, %rs14;
+	and.b16  	%rs57, %rs56, 2;
+	setp.eq.s16 	%p91, %rs57, 0;
+	@%p91 bra 	$L__BB0_66;
+
+	sub.f32 	%f531, %f173, %f223;
+	mul.f32 	%f532, %f531, %f222;
+	mul.f32 	%f533, %f532, %f225;
+	mul.f32 	%f534, %f533, %f174;
+	sub.f32 	%f655, %f655, %f534;
+	mul.f32 	%f535, %f533, %f175;
+	sub.f32 	%f656, %f656, %f535;
+	mul.f32 	%f536, %f533, %f176;
+	sub.f32 	%f657, %f657, %f536;
+
+$L__BB0_66:
+	add.s32 	%r39, %r65, 5;
+	setp.eq.s32 	%p92, %r14, 5;
+	@%p92 bra 	$L__BB0_75;
+
+	setp.eq.s32 	%p93, %r39, %r3;
+	@%p93 bra 	$L__BB0_71;
+
+	mul.wide.u32 	%rd35, %r39, 16;
+	add.s64 	%rd36, %rd1, %rd35;
+	ld.global.u8 	%rs15, [%rd36+13];
+	and.b16  	%rs58, %rs15, 1;
+	setp.eq.b16 	%p94, %rs58, 1;
+	mov.pred 	%p95, 0;
+	xor.pred  	%p96, %p94, %p95;
+	not.pred 	%p97, %p96;
+	@%p97 bra 	$L__BB0_71;
+
+	ld.shared.f32 	%f537, [%r33+60];
+	sub.f32 	%f538, %f1, %f537;
+	ld.shared.f32 	%f539, [%r33+64];
+	sub.f32 	%f540, %f2, %f539;
+	ld.shared.f32 	%f541, [%r33+68];
+	sub.f32 	%f542, %f3, %f541;
+	mul.f32 	%f543, %f540, %f540;
+	fma.rn.f32 	%f544, %f538, %f538, %f543;
+	fma.rn.f32 	%f545, %f542, %f542, %f544;
+	sqrt.rn.f32 	%f546, %f545;
+	mov.f32 	%f547, 0f3DCCCCCD;
+	max.f32 	%f186, %f546, %f547;
+	rcp.rn.f32 	%f548, %f186;
+	mul.f32 	%f187, %f538, %f548;
+	mul.f32 	%f188, %f540, %f548;
+	mul.f32 	%f189, %f542, %f548;
+	ld.shared.f32 	%f549, [%r34+20];
+	mul.f32 	%f550, %f549, %f4;
+	sqrt.rn.f32 	%f551, %f550;
+	mul.f32 	%f552, %f551, %f224;
+	div.rn.f32 	%f553, %f552, %f545;
+	fma.rn.f32 	%f655, %f553, %f187, %f655;
+	fma.rn.f32 	%f656, %f553, %f188, %f656;
+	fma.rn.f32 	%f657, %f553, %f189, %f657;
+	and.b16  	%rs59, %rs1, %rs15;
+	and.b16  	%rs60, %rs59, 2;
+	setp.eq.s16 	%p98, %rs60, 0;
+	@%p98 bra 	$L__BB0_71;
+
+	sub.f32 	%f554, %f186, %f223;
+	mul.f32 	%f555, %f554, %f222;
+	mul.f32 	%f556, %f555, %f225;
+	mul.f32 	%f557, %f556, %f187;
+	sub.f32 	%f655, %f655, %f557;
+	mul.f32 	%f558, %f556, %f188;
+	sub.f32 	%f656, %f656, %f558;
+	mul.f32 	%f559, %f556, %f189;
+	sub.f32 	%f657, %f657, %f559;
+
+$L__BB0_71:
+	add.s32 	%r40, %r65, 6;
+	setp.eq.s32 	%p99, %r40, %r3;
+	setp.eq.s32 	%p100, %r14, 6;
+	or.pred  	%p101, %p100, %p99;
+	@%p101 bra 	$L__BB0_75;
+
+	mul.wide.u32 	%rd37, %r40, 16;
+	add.s64 	%rd38, %rd1, %rd37;
+	ld.global.u8 	%rs16, [%rd38+13];
+	and.b16  	%rs61, %rs16, 1;
+	setp.eq.b16 	%p102, %rs61, 1;
+	mov.pred 	%p103, 0;
+	xor.pred  	%p104, %p102, %p103;
+	not.pred 	%p105, %p104;
+	@%p105 bra 	$L__BB0_75;
+
+	ld.shared.f32 	%f560, [%r33+72];
+	sub.f32 	%f561, %f1, %f560;
+	ld.shared.f32 	%f562, [%r33+76];
+	sub.f32 	%f563, %f2, %f562;
+	ld.shared.f32 	%f564, [%r33+80];
+	sub.f32 	%f565, %f3, %f564;
+	mul.f32 	%f566, %f563, %f563;
+	fma.rn.f32 	%f567, %f561, %f561, %f566;
+	fma.rn.f32 	%f568, %f565, %f565, %f567;
+	sqrt.rn.f32 	%f569, %f568;
+	mov.f32 	%f570, 0f3DCCCCCD;
+	max.f32 	%f199, %f569, %f570;
+	rcp.rn.f32 	%f571, %f199;
+	mul.f32 	%f200, %f561, %f571;
+	mul.f32 	%f201, %f563, %f571;
+	mul.f32 	%f202, %f565, %f571;
+	ld.shared.f32 	%f572, [%r34+24];
+	mul.f32 	%f573, %f572, %f4;
+	sqrt.rn.f32 	%f574, %f573;
+	mul.f32 	%f575, %f574, %f224;
+	div.rn.f32 	%f576, %f575, %f568;
+	fma.rn.f32 	%f655, %f576, %f200, %f655;
+	fma.rn.f32 	%f656, %f576, %f201, %f656;
+	fma.rn.f32 	%f657, %f576, %f202, %f657;
+	and.b16  	%rs62, %rs1, %rs16;
+	and.b16  	%rs63, %rs62, 2;
+	setp.eq.s16 	%p106, %rs63, 0;
+	@%p106 bra 	$L__BB0_75;
+
+	sub.f32 	%f577, %f199, %f223;
+	mul.f32 	%f578, %f577, %f222;
+	mul.f32 	%f579, %f578, %f225;
+	mul.f32 	%f580, %f579, %f200;
+	sub.f32 	%f655, %f655, %f580;
+	mul.f32 	%f581, %f579, %f201;
+	sub.f32 	%f656, %f656, %f581;
+	mul.f32 	%f582, %f579, %f202;
+	sub.f32 	%f657, %f657, %f582;
+
+$L__BB0_75:
+	bar.sync 	0;
+	add.s32 	%r76, %r76, 1;
+	setp.lt.u32 	%p107, %r76, %r8;
+	@%p107 bra 	$L__BB0_3;
+
+$L__BB0_76:
+	mul.f32 	%f583, %f656, %f656;
+	fma.rn.f32 	%f584, %f655, %f655, %f583;
+	fma.rn.f32 	%f585, %f657, %f657, %f584;
+	sqrt.rn.f32 	%f215, %f585;
+	setp.leu.f32 	%p108, %f215, 0f447A0000;
+	@%p108 bra 	$L__BB0_78;
+
+	mov.f32 	%f586, 0f447A0000;
+	div.rn.f32 	%f587, %f586, %f215;
+	mul.f32 	%f655, %f655, %f587;
+	mul.f32 	%f656, %f656, %f587;
+	mul.f32 	%f657, %f657, %f587;
+
+$L__BB0_78:
+	ld.param.f32 	%f600, [compute_forces_param_8];
+	cvt.s64.s32 	%rd45, %r3;
+	ld.param.u64 	%rd44, [compute_forces_param_1];
+	mul.wide.s32 	%rd43, %r3, 16;
+	add.s64 	%rd42, %rd1, %rd43;
+	cvta.to.global.u64 	%rd39, %rd44;
+	mul.lo.s64 	%rd40, %rd45, 12;
+	add.s64 	%rd41, %rd39, %rd40;
+	ld.global.f32 	%f588, [%rd41];
+	fma.rn.f32 	%f589, %f655, 0f3C83126F, %f588;
+	mul.f32 	%f590, %f589, %f600;
+	ld.global.f32 	%f591, [%rd41+4];
+	fma.rn.f32 	%f592, %f656, 0f3C83126F, %f591;
+	mul.f32 	%f593, %f592, %f600;
+	ld.global.f32 	%f594, [%rd41+8];
+	fma.rn.f32 	%f595, %f657, 0f3C83126F, %f594;
+	mul.f32 	%f596, %f595, %f600;
+	fma.rn.f32 	%f597, %f590, 0f3C83126F, %f1;
+	fma.rn.f32 	%f598, %f593, 0f3C83126F, %f2;
+	fma.rn.f32 	%f599, %f596, 0f3C83126F, %f3;
+	st.global.f32 	[%rd42], %f597;
+	st.global.f32 	[%rd42+4], %f598;
+	st.global.f32 	[%rd42+8], %f599;
+	st.global.f32 	[%rd41], %f590;
+	st.global.f32 	[%rd41+4], %f593;
+	st.global.f32 	[%rd41+8], %f596;
+
+$L__BB0_79:
 	ret;
 
 }
diff --git a/src/utils/gpu_compute.cu b/src/utils/gpu_compute.cu
new file mode 100644
index 00000000..0519ecba
--- /dev/null
+++ b/src/utils/gpu_compute.cu
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff --git a/src/utils/gpu_compute.rs b/src/utils/gpu_compute.rs
index e6a40eea..6b838b08 100755
--- a/src/utils/gpu_compute.rs
+++ b/src/utils/gpu_compute.rs
@@ -1,4 +1,4 @@
-use cudarc::driver::{CudaDevice, CudaFunction, CudaSlice, LaunchConfig, LaunchAsync};
+use cudarc::driver::{CudaDevice, CudaFunction, CudaSlice, LaunchConfig, LaunchAsync, DeviceRepr, ValidAsZeroBits};
 use cudarc::nvrtc::Ptx;
 use std::io::Error;
 use std::sync::Arc;
@@ -7,6 +7,20 @@ use crate::models::graph::GraphData;
 use crate::utils::socket_flow_messages::NodeData;
 use crate::models::simulation_params::SimulationParams;
 use tokio::sync::RwLock;
+use bytemuck::{Pod, Zeroable};
+
+// Implement DeviceRepr for VelocityData
+unsafe impl DeviceRepr for VelocityData {}
+unsafe impl ValidAsZeroBits for VelocityData {}
+
+// Define a proper type for velocities that can be used with CUDA
+#[repr(C)]
+#[derive(Clone, Copy, Pod, Zeroable)]
+struct VelocityData {
+    x: f32,
+    y: f32,
+    z: f32,
+}
 
 const BLOCK_SIZE: u32 = 256;
 const MAX_NODES: u32 = 1_000_000;
@@ -17,6 +31,7 @@ pub struct GPUCompute {
     device: Arc<CudaDevice>,
     force_kernel: CudaFunction,
     node_data: CudaSlice<NodeData>,
+    velocity_data: CudaSlice<VelocityData>,
     num_nodes: u32,
     simulation_params: SimulationParams,
 }
@@ -32,8 +47,7 @@ impl GPUCompute {
         }
 
         debug!("Initializing CUDA device");
-        let device = Arc::new(CudaDevice::new(0)
-            .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?);
+        let device = Arc::new(CudaDevice::new(0).map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?);
 
         debug!("Loading force computation kernel");
         let ptx = Ptx::from_file("/app/compute_forces.ptx");
@@ -47,12 +61,15 @@ impl GPUCompute {
         debug!("Allocating device memory for {} nodes", num_nodes);
         let node_data = device.alloc_zeros::<NodeData>(num_nodes as usize)
             .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+        let velocity_data = device.alloc_zeros::<VelocityData>(num_nodes as usize)
+            .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
 
         debug!("Creating GPU compute instance");
         let mut instance = Self {
             device: Arc::clone(&device),
             force_kernel,
             node_data,
+            velocity_data,
             num_nodes,
             simulation_params: SimulationParams::default(),
         };
@@ -71,9 +88,20 @@ impl GPUCompute {
             .map(|node| node.data)
             .collect();
 
+        // Extract velocities
+        let velocity_data: Vec<VelocityData> = graph.nodes.iter()
+            .map(|node| VelocityData {
+                x: node.data.velocity[0],
+                y: node.data.velocity[1],
+                z: node.data.velocity[2],
+            })
+            .collect();
+
         // Copy data to GPU
         self.device.htod_sync_copy_into(&node_data, &mut self.node_data)
             .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+        self.device.htod_sync_copy_into(&velocity_data, &mut self.velocity_data)
+            .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
 
         self.num_nodes = graph.nodes.len() as u32;
         Ok(())
@@ -95,13 +123,18 @@ impl GPUCompute {
 
         let params = &self.simulation_params;
         unsafe {
-            self.force_kernel.clone().launch(cfg, (
-                &mut self.node_data,
-                self.num_nodes as i32,
-                params.spring_strength,
-                params.repulsion,
-                params.damping,
-            )).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+            let kernel = self.force_kernel.clone();
+            kernel.launch(cfg, (
+                &mut self.node_data,     // nodes buffer
+                &mut self.velocity_data, // velocity buffer
+                0u64,                   // unused parameter
+                self.num_nodes as u32,  // num_nodes
+                params.spring_strength, // spring_strength
+                params.spring_length,   // spring_length
+                params.repulsion,      // repulsion
+                params.attraction,     // attraction
+                params.damping,        // damping
+            )).map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
         }
         Ok(())
     }
@@ -118,8 +151,63 @@ impl GPUCompute {
         self.device.dtoh_sync_copy_into(&self.node_data, &mut node_data)
             .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
 
+        // Update velocities from separate buffer
+        let mut velocities = vec![VelocityData { x: 0.0, y: 0.0, z: 0.0 }; self.num_nodes as usize];
+        self.device.dtoh_sync_copy_into(&self.velocity_data, &mut velocities)
+            .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+
+        // Combine position and velocity data
+        for (node, vel) in node_data.iter_mut().zip(velocities.iter()) {
+            node.velocity = [vel.x, vel.y, vel.z];
+        }
+
         Ok(node_data)
     }
+
+    pub fn compute_forces(&mut self, params: &SimulationParams) -> Result<(), Error> {
+        let nodes = self.get_node_data()?;
+
+        unsafe {
+            // Log all nodes before kernel
+            for (i, node) in nodes.iter().enumerate() {
+                debug!("Before kernel, node {}: pos=({:.3}, {:.3}, {:.3}), vel=({:.3}, {:.3}, {:.3})", 
+                    i,
+                    node.position[0], node.position[1], node.position[2],
+                    node.velocity[0], node.velocity[1], node.velocity[2]);
+            }
+
+            let blocks = (self.num_nodes + BLOCK_SIZE - 1) / BLOCK_SIZE;
+            let cfg = LaunchConfig {
+                grid_dim: (blocks, 1, 1),
+                block_dim: (BLOCK_SIZE, 1, 1),
+                shared_mem_bytes: SHARED_MEM_SIZE,
+            };
+
+            let kernel = self.force_kernel.clone();
+            kernel.launch(cfg, (
+                &mut self.node_data,     // nodes buffer
+                &mut self.velocity_data, // velocity buffer
+                0u64,                   // unused parameter
+                self.num_nodes as u32,  // num_nodes
+                params.spring_strength, // spring_strength
+                params.spring_length,   // spring_length
+                params.repulsion,      // repulsion
+                params.attraction,     // attraction
+                params.damping,        // damping
+            )).map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+
+            // Log all nodes after kernel
+            let after = self.get_node_data()?;
+            for (i, node) in after.iter().enumerate() {
+                debug!("After kernel, node {}: pos=({:.3}, {:.3}, {:.3}), vel=({:.3}, {:.3}, {:.3})", 
+                    i,
+                    node.position[0], node.position[1], node.position[2],
+                    node.velocity[0], node.velocity[1], node.velocity[2]);
+            }
+        }
+
+        Ok(())
+    }
 }
 
 #[cfg(test)]
diff --git a/src/utils/socket_flow_constants.rs b/src/utils/socket_flow_constants.rs
index 37912967..d0b757b3 100644
--- a/src/utils/socket_flow_constants.rs
+++ b/src/utils/socket_flow_constants.rs
@@ -1,14 +1,10 @@
-// Node and graph constants
-pub const NODE_SIZE: f32 = 1.0;
-pub const EDGE_WIDTH: f32 = 0.1;
-pub const MIN_DISTANCE: f32 = 2.0;
-pub const MAX_DISTANCE: f32 = 10.0;
+// WebSocket protocol version
+pub const BINARY_PROTOCOL_VERSION: i32 = 1;
 
 // WebSocket constants - matching nginx configuration
 pub const HEARTBEAT_INTERVAL: u64 = 30; // seconds - matches nginx proxy_connect_timeout
 pub const CLIENT_TIMEOUT: u64 = 60; // seconds - double heartbeat interval for safety
 pub const MAX_CLIENT_TIMEOUT: u64 = 3600; // seconds - matches nginx proxy_read_timeout
-pub const MAX_MESSAGE_SIZE: usize = 100 * 1024 * 1024; // 100MB
 pub const BINARY_CHUNK_SIZE: usize = 64 * 1024; // 64KB
 
 // Update rate constants
@@ -16,9 +12,8 @@ pub const POSITION_UPDATE_RATE: u32 = 5; // Hz (matching client's MAX_UPDATES_PE
 pub const METADATA_UPDATE_RATE: u32 = 1; // Hz
 
 // Binary message constants
-pub const NODE_POSITION_SIZE: usize = 24; // 6 f32s (x,y,z,vx,vy,vz) * 4 bytes
-pub const BINARY_HEADER_SIZE: usize = 4; // 1 f32 for header
+pub const NODE_POSITION_SIZE: usize = 24; // 6 f32s per node (position + velocity)
 
-// Compression constants
-pub const COMPRESSION_THRESHOLD: usize = 1024; // 1KB
-pub const ENABLE_COMPRESSION: bool = true;
+// Connection limits
+pub const MAX_CONNECTIONS: usize = 100;
+pub const MAX_MESSAGE_SIZE: usize = 32 * 1024 * 1024;  // 32MB - matches nginx client_max_body_size
diff --git a/src/utils/socket_flow_messages.rs b/src/utils/socket_flow_messages.rs
index 2303c10d..a8de0f68 100644
--- a/src/utils/socket_flow_messages.rs
+++ b/src/utils/socket_flow_messages.rs
@@ -19,18 +19,6 @@ unsafe impl DeviceRepr for NodeData {}
 // Implement ValidAsZeroBits for NodeData
 unsafe impl ValidAsZeroBits for NodeData {}
 
-#[derive(Debug, Serialize, Deserialize)]
-pub struct PingMessage {
-    pub type_: String,
-    pub timestamp: u64,
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct PongMessage {
-    pub type_: String,
-    pub timestamp: u64,
-}
-
 #[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "camelCase")]
 pub struct Node {
@@ -117,11 +105,12 @@ impl Node {
     pub fn set_vz(&mut self, val: f32) { self.data.velocity[2] = val; }
 }
 
+// Simple binary format for position/velocity updates
 #[repr(C)]
-#[derive(Debug, Clone, Copy, Pod, Zeroable, Serialize, Deserialize)]
+#[derive(Debug, Clone, Copy, Pod, Zeroable)]
 pub struct BinaryNodeData {
-    pub position: [f32; 3],  // x, y, z
-    pub velocity: [f32; 3],  // vx, vy, vz
+    pub position: [f32; 3],  // x, y, z as f32
+    pub velocity: [f32; 3],  // vx, vy, vz as f32
 }
 
 // Implement DeviceRepr for BinaryNodeData
@@ -139,6 +128,7 @@ impl BinaryNodeData {
     }
 }
 
+// WebSocket message types
 #[derive(Debug, Serialize, Deserialize)]
 #[serde(tag = "type")]
 pub enum Message {
@@ -149,5 +139,35 @@ pub enum Message {
     Pong { timestamp: u64 },
 }
 
-// Forward declarations to avoid circular dependencies
-use crate::models::graph::GraphData;
+// Separate message types for ping/pong
+#[derive(Debug, Serialize, Deserialize)]
+pub struct PingMessage {
+    #[serde(rename = "type")]
+    pub type_: String,
+    pub timestamp: u64,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct PongMessage {
+    #[serde(rename = "type")]
+    pub type_: String,
+    pub timestamp: u64,
+}
+
+impl PingMessage {
+    pub fn new(timestamp: u64) -> Self {
+        Self {
+            type_: "ping".to_string(),
+            timestamp,
+        }
+    }
+}
+
+impl PongMessage {
+    pub fn new(timestamp: u64) -> Self {
+        Self {
+            type_: "pong".to_string(),
+            timestamp,
+        }
+    }
+}
diff --git a/src/visualization/HologramManager.ts b/src/visualization/HologramManager.ts
new file mode 100644
index 00000000..f1f68e00
--- /dev/null
+++ b/src/visualization/HologramManager.ts
@@ -0,0 +1,210 @@
+import * as THREE from 'three';
+import { HologramSettings } from '../types/metadata';
+import { XRHandedness } from '../types/xr';
+
+export class HologramManager {
+    private readonly hologramGroup: THREE.Group;
+    private readonly geometryCache: Map<string, THREE.BufferGeometry>;
+    private readonly materialCache: Map<string, THREE.Material>;
+    private isXRMode: boolean = false;
+
+    constructor(
+        private readonly scene: THREE.Scene,
+        private readonly camera: THREE.PerspectiveCamera,
+        private settings: HologramSettings
+    ) {
+        this.hologramGroup = new THREE.Group();
+        this.geometryCache = new Map();
+        this.materialCache = new Map();
+        this.scene.add(this.hologramGroup);
+        
+        // Initialize geometries based on quality setting
+        this.initializeGeometries();
+        this.createHolographicStructures();
+    }
+
+    private initializeGeometries(): void {
+        const quality = this.isXRMode ? this.settings.xrQuality : this.settings.desktopQuality;
+        const segments = {
+            low: { ring: 32, sphere: 8 },
+            medium: { ring: 64, sphere: 16 },
+            high: { ring: 128, sphere: 32 }
+        }[quality] || segments.medium;
+
+        // Create and cache geometries
+        this.geometryCache.set('ring', new THREE.TorusGeometry(1, 0.02, segments.ring, segments.ring * 2));
+        this.geometryCache.set('buckminster', new THREE.IcosahedronGeometry(1, quality === 'high' ? 2 : 1));
+        this.geometryCache.set('geodesic', new THREE.IcosahedronGeometry(1, quality === 'low' ? 1 : 2));
+        this.geometryCache.set('triangleSphere', new THREE.SphereGeometry(1, segments.sphere, segments.sphere));
+
+        // Create hologram material
+        const hologramMaterial = new THREE.ShaderMaterial({
+            uniforms: {
+                color: { value: new THREE.Color(this.settings.ringColor) },
+                opacity: { value: this.settings.ringOpacity },
+                time: { value: 0 },
+                pulseSpeed: { value: 1.0 },
+                pulseIntensity: { value: 0.2 }
+            },
+            vertexShader: `
+                varying vec3 vPosition;
+                varying vec2 vUv;
+                void main() {
+                    vPosition = position;
+                    vUv = uv;
+                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+                }
+            `,
+            fragmentShader: `
+                uniform vec3 color;
+                uniform float opacity;
+                uniform float time;
+                uniform float pulseSpeed;
+                uniform float pulseIntensity;
+                varying vec3 vPosition;
+                varying vec2 vUv;
+                
+                void main() {
+                    float pulse = sin(time * pulseSpeed) * pulseIntensity + 1.0;
+                    float edge = 1.0 - smoothstep(0.4, 0.5, abs(vUv.y - 0.5));
+                    vec3 finalColor = color * pulse;
+                    float finalOpacity = opacity * edge;
+                    
+                    #ifdef USE_AR
+                        // Adjust opacity based on distance to camera for AR
+                        float depth = gl_FragCoord.z / gl_FragCoord.w;
+                        finalOpacity *= smoothstep(10.0, 0.0, depth);
+                    #endif
+                    
+                    gl_FragColor = vec4(finalColor, finalOpacity);
+                }
+            `,
+            transparent: true,
+            side: THREE.DoubleSide,
+            depthWrite: false
+        });
+
+        this.materialCache.set('hologram', hologramMaterial);
+    }
+
+    private createHolographicStructures(): void {
+        // Clear existing structures
+        while (this.hologramGroup.children.length > 0) {
+            const child = this.hologramGroup.children[0];
+            this.hologramGroup.remove(child);
+        }
+
+        // Create rings
+        const ringGeometry = this.geometryCache.get('ring')!;
+        const material = this.materialCache.get('hologram')!.clone();
+
+        for (let i = 0; i < this.settings.ringCount; i++) {
+            const ring = new THREE.Mesh(ringGeometry, material.clone());
+            ring.scale.setScalar(this.settings.ringSizes[i] || 20);
+            ring.rotation.x = Math.PI / 2 * i;
+            ring.rotation.y = Math.PI / 4 * i;
+            ring.userData.rotationSpeed = this.settings.ringRotationSpeed * (i + 1);
+            this.hologramGroup.add(ring);
+        }
+
+        // Create geometric structures based on settings
+        if (this.settings.enableBuckminster) {
+            const geometry = this.geometryCache.get('buckminster')!;
+            const mesh = new THREE.Mesh(geometry, material.clone());
+            mesh.scale.setScalar(this.settings.buckminsterScale);
+            mesh.material.uniforms.opacity.value = this.settings.buckminsterOpacity;
+            this.hologramGroup.add(mesh);
+        }
+
+        if (this.settings.enableGeodesic) {
+            const geometry = this.geometryCache.get('geodesic')!;
+            const mesh = new THREE.Mesh(geometry, material.clone());
+            mesh.scale.setScalar(this.settings.geodesicScale);
+            mesh.material.uniforms.opacity.value = this.settings.geodesicOpacity;
+            this.hologramGroup.add(mesh);
+        }
+
+        if (this.settings.enableTriangleSphere) {
+            const geometry = this.geometryCache.get('triangleSphere')!;
+            const mesh = new THREE.Mesh(geometry, material.clone());
+            mesh.scale.setScalar(this.settings.triangleSphereScale);
+            mesh.material.uniforms.opacity.value = this.settings.triangleSphereOpacity;
+            this.hologramGroup.add(mesh);
+        }
+    }
+
+    public setXRMode(enabled: boolean): void {
+        this.isXRMode = enabled;
+        if (enabled) {
+            // Optimize for XR
+            this.hologramGroup.children.forEach(child => {
+                if (child instanceof THREE.Mesh) {
+                    child.material.defines = { USE_AR: '' };
+                    child.material.needsUpdate = true;
+                }
+            });
+        }
+        // Recreate geometries with appropriate quality
+        this.initializeGeometries();
+        this.createHolographicStructures();
+    }
+
+    public update(deltaTime: number): void {
+        // Update hologram animations
+        this.hologramGroup.children.forEach(child => {
+            if (child instanceof THREE.Mesh) {
+                child.rotation.y += (child.userData.rotationSpeed || this.settings.globalRotationSpeed) * deltaTime;
+                if (child.material instanceof THREE.ShaderMaterial) {
+                    child.material.uniforms.time.value += deltaTime;
+                }
+            }
+        });
+    }
+
+    public handleHandInteraction(hand: THREE.XRHand, handedness: XRHandedness): void {
+        if (!this.isXRMode) return;
+
+        // Get index finger tip position
+        const indexTip = hand.joints['index-finger-tip'];
+        if (!indexTip) return;
+
+        // Convert joint position to world space
+        const fingerPosition = new THREE.Vector3()
+            .fromBufferAttribute(indexTip.position as THREE.BufferAttribute, 0)
+            .applyMatrix4(hand.matrixWorld);
+
+        // Check interaction with hologram elements
+        this.hologramGroup.children.forEach(child => {
+            if (child instanceof THREE.Mesh) {
+                const distance = fingerPosition.distanceTo(child.position);
+                if (distance < 0.1) { // 10cm interaction radius
+                    // Increase pulse intensity temporarily
+                    if (child.material instanceof THREE.ShaderMaterial) {
+                        child.material.uniforms.pulseIntensity.value = 0.4;
+                        setTimeout(() => {
+                            child.material.uniforms.pulseIntensity.value = 0.2;
+                        }, 500);
+                    }
+                }
+            }
+        });
+    }
+
+    public updateSettings(settings: Partial<HologramSettings>): void {
+        Object.assign(this.settings, settings);
+        this.createHolographicStructures();
+    }
+
+    public dispose(): void {
+        // Dispose geometries
+        this.geometryCache.forEach(geometry => geometry.dispose());
+        this.geometryCache.clear();
+
+        // Dispose materials
+        this.materialCache.forEach(material => material.dispose());
+        this.materialCache.clear();
+
+        // Remove from scene
+        this.scene.remove(this.hologramGroup);
+    }
+}
diff --git a/src/visualization/MetadataVisualizer.ts b/src/visualization/MetadataVisualizer.ts
new file mode 100644
index 00000000..7b885aa6
--- /dev/null
+++ b/src/visualization/MetadataVisualizer.ts
@@ -0,0 +1,163 @@
+import * as THREE from 'three';
+import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
+import { FontLoader, Font } from 'three/examples/jsm/loaders/FontLoader.js';
+import { NodeMetadata } from '../types/metadata';
+
+export class MetadataVisualizer {
+    private readonly geometries = {
+        SPHERE: new THREE.SphereGeometry(1, 32, 32),
+        ICOSAHEDRON: new THREE.IcosahedronGeometry(1),
+        OCTAHEDRON: new THREE.OctahedronGeometry(1)
+    };
+
+    private font: Font | null = null;
+    private fontLoader: FontLoader;
+    private readonly fontPath = '/fonts/helvetiker_regular.typeface.json';
+    private readonly labelScale = 0.1;
+    private readonly labelHeight = 0.1;
+    private readonly labelGroup: THREE.Group;
+
+    constructor(
+        private readonly camera: THREE.Camera,
+        private readonly settings: any
+    ) {
+        this.fontLoader = new FontLoader();
+        this.loadFont();
+        this.labelGroup = new THREE.Group();
+    }
+
+    private async loadFont(): Promise<void> {
+        try {
+            this.font = await this.fontLoader.loadAsync(this.fontPath);
+        } catch (error) {
+            console.error('Failed to load font:', error);
+        }
+    }
+
+    public async createTextMesh(text: string): Promise<THREE.Mesh | null> {
+        if (!this.font) {
+            console.warn('Font not loaded yet');
+            return null;
+        }
+
+        const geometry = new TextGeometry(text, {
+            font: this.font,
+            size: 1,
+            height: this.labelHeight,
+            curveSegments: 4,
+            bevelEnabled: false
+        });
+
+        const material = new THREE.MeshBasicMaterial({
+            color: 0xffffff,
+            transparent: true,
+            opacity: 0.8
+        });
+
+        const mesh = new THREE.Mesh(geometry, material);
+        mesh.scale.set(this.labelScale, this.labelScale, this.labelScale);
+
+        // Center the text
+        geometry.computeBoundingBox();
+        const textWidth = geometry.boundingBox!.max.x - geometry.boundingBox!.min.x;
+        mesh.position.x = -textWidth * this.labelScale / 2;
+
+        return mesh;
+    }
+
+    public createNodeVisual(metadata: NodeMetadata): THREE.Mesh {
+        const geometry = this.getGeometryFromAge(metadata.commitAge);
+        const material = this.createMaterialFromHyperlinks(metadata.hyperlinkCount);
+        const mesh = new THREE.Mesh(geometry, material);
+
+        const scale = this.calculateScale(metadata.importance);
+        mesh.scale.set(scale, scale, scale);
+
+        mesh.position.set(
+            metadata.position.x,
+            metadata.position.y,
+            metadata.position.z
+        );
+
+        return mesh;
+    }
+
+    private getGeometryFromAge(age: number): THREE.BufferGeometry {
+        if (age < 7) return this.geometries.SPHERE;
+        if (age < 30) return this.geometries.ICOSAHEDRON;
+        return this.geometries.OCTAHEDRON;
+    }
+
+    private createMaterialFromHyperlinks(count: number): THREE.Material {
+        const hue = Math.min(count / 10, 1) * 0.3; // 0 to 0.3 range
+        const color = new THREE.Color().setHSL(hue, 0.7, 0.5);
+
+        return new THREE.MeshPhongMaterial({
+            color: color,
+            shininess: 30,
+            transparent: true,
+            opacity: 0.9
+        });
+    }
+
+    private calculateScale(importance: number): number {
+        const [min, max] = this.settings.nodes.sizeRange;
+        return min + (max - min) * Math.min(importance, 1);
+    }
+
+    public async createMetadataLabel(metadata: NodeMetadata): Promise<THREE.Group> {
+        const group = new THREE.Group();
+
+        // Create text for name
+        const nameMesh = await this.createTextMesh(metadata.name);
+        if (nameMesh) {
+            nameMesh.position.y = 1.2;
+            group.add(nameMesh);
+        }
+
+        // Create text for commit age
+        const ageMesh = await this.createTextMesh(`${Math.round(metadata.commitAge)} days`);
+        if (ageMesh) {
+            ageMesh.position.y = 0.8;
+            group.add(ageMesh);
+        }
+
+        // Create text for hyperlink count
+        const linksMesh = await this.createTextMesh(`${metadata.hyperlinkCount} links`);
+        if (linksMesh) {
+            linksMesh.position.y = 0.4;
+            group.add(linksMesh);
+        }
+
+        // Billboard behavior
+        if (this.settings.labels?.billboard_mode === 'camera') {
+            group.onBeforeRender = () => {
+                group.quaternion.copy(this.camera.quaternion);
+            };
+        } else {
+            // Vertical billboard - only rotate around Y
+            group.onBeforeRender = () => {
+                const cameraPos = this.camera.position.clone();
+                cameraPos.y = group.position.y;
+                group.lookAt(cameraPos);
+            };
+        }
+
+        return group;
+    }
+
+    public dispose(): void {
+        // Clean up geometries
+        Object.values(this.geometries).forEach(geometry => geometry.dispose());
+        
+        // Clean up label group
+        this.labelGroup.traverse(child => {
+            if (child instanceof THREE.Mesh) {
+                child.geometry.dispose();
+                if (child.material instanceof THREE.Material) {
+                    child.material.dispose();
+                }
+            }
+        });
+    }
+}
diff --git a/src/visualization/VisualizationController.ts b/src/visualization/VisualizationController.ts
new file mode 100644
index 00000000..042beb90
--- /dev/null
+++ b/src/visualization/VisualizationController.ts
@@ -0,0 +1,123 @@
+import * as THREE from 'three';
+import { MetadataVisualizer } from './MetadataVisualizer';
+import { HologramManager } from './HologramManager';
+import { NodeMetadata, HologramSettings } from '../types/metadata';
+import { XRHandedness, XRHand } from '../types/xr';
+
+export class VisualizationController {
+    private readonly scene: THREE.Scene;
+    private readonly camera: THREE.PerspectiveCamera;
+    private readonly renderer: THREE.WebGLRenderer;
+    private readonly metadataVisualizer: MetadataVisualizer;
+    private readonly hologramManager: HologramManager;
+    private clock: THREE.Clock;
+    private isXRSession: boolean = false;
+
+    constructor(container: HTMLElement, settings: any) {
+        // Initialize Three.js basics
+        this.scene = new THREE.Scene();
+        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+        this.renderer = new THREE.WebGLRenderer({
+            antialias: true,
+            alpha: true,
+            logarithmicDepthBuffer: true
+        });
+        this.renderer.setPixelRatio(window.devicePixelRatio);
+        this.renderer.setSize(window.innerWidth, window.innerHeight);
+        this.renderer.xr.enabled = true;
+        container.appendChild(this.renderer.domElement);
+
+        // Initialize managers
+        this.metadataVisualizer = new MetadataVisualizer(this.scene, this.camera, settings);
+        this.hologramManager = new HologramManager(this.scene, this.camera, settings.hologram);
+        this.clock = new THREE.Clock();
+
+        // Set up XR session change handling
+        this.renderer.xr.addEventListener('sessionstart', () => {
+            this.isXRSession = true;
+            this.hologramManager.setXRMode(true);
+        });
+
+        this.renderer.xr.addEventListener('sessionend', () => {
+            this.isXRSession = false;
+            this.hologramManager.setXRMode(false);
+        });
+
+        // Set up window resize handling
+        window.addEventListener('resize', this.onWindowResize.bind(this));
+    }
+
+    private onWindowResize(): void {
+        this.camera.aspect = window.innerWidth / window.innerHeight;
+        this.camera.updateProjectionMatrix();
+        this.renderer.setSize(window.innerWidth, window.innerHeight);
+    }
+
+    public updateNodes(nodes: NodeMetadata[]): void {
+        // Clear existing nodes
+        this.scene.children
+            .filter(child => child.userData.isNode)
+            .forEach(node => this.scene.remove(node));
+
+        // Create new nodes
+        nodes.forEach(metadata => {
+            const nodeMesh = this.metadataVisualizer.createNodeVisual(metadata);
+            nodeMesh.userData.isNode = true;
+            nodeMesh.position.set(
+                metadata.position.x,
+                metadata.position.y,
+                metadata.position.z
+            );
+            this.scene.add(nodeMesh);
+        });
+    }
+
+    public updateHologramSettings(settings: Partial<HologramSettings>): void {
+        this.hologramManager.updateSettings(settings);
+    }
+
+    public handleHandInput(hand: XRHand, handedness: XRHandedness): void {
+        if (this.isXRSession) {
+            this.hologramManager.handleHandInteraction(hand, handedness);
+        }
+    }
+
+    public animate(): void {
+        const render = () => {
+            const delta = this.clock.getDelta();
+            
+            // Update hologram animations
+            this.hologramManager.update(delta);
+
+            // Render scene
+            this.renderer.render(this.scene, this.camera);
+        };
+
+        this.renderer.setAnimationLoop(render);
+    }
+
+    public dispose(): void {
+        // Clean up event listeners
+        window.removeEventListener('resize', this.onWindowResize.bind(this));
+
+        // Dispose managers
+        this.metadataVisualizer.dispose();
+        this.hologramManager.dispose();
+
+        // Stop animation loop
+        this.renderer.setAnimationLoop(null);
+
+        // Dispose Three.js resources
+        this.renderer.dispose();
+        this.scene.traverse((object) => {
+            if (object instanceof THREE.Mesh) {
+                object.geometry.dispose();
+                if (Array.isArray(object.material)) {
+                    object.material.forEach(material => material.dispose());
+                } else {
+                    object.material.dispose();
+                }
+            }
+        });
+    }
+}
diff --git a/vite.config.ts b/vite.config.ts
index 60c74e1d..2dc0c5bf 100644
--- a/vite.config.ts
+++ b/vite.config.ts
@@ -14,13 +14,7 @@ export default defineConfig(({ mode, command }) => {
       outDir: resolve(__dirname, 'data/public/dist'),
       emptyOutDir: true,
       sourcemap: !isProd,
-      minify: isProd ? 'terser' : false,
-      terserOptions: {
-        compress: {
-          drop_console: isProd,
-          drop_debugger: isProd
-        }
-      },
+      minify: false,
       rollupOptions: {
         input: {
           main: resolve(__dirname, 'client/index.html')
@@ -56,13 +50,26 @@ export default defineConfig(({ mode, command }) => {
       port: 3001,
       host: true,
       proxy: {
-        '/wss': {  // Updated from /ws to /wss to match nginx
+        '/wss': {
           target: 'ws://localhost:4000',
-          ws: true
+          ws: true,
+          changeOrigin: true,
+          secure: false
+        },
+        '/api/settings': {
+          target: 'http://localhost:4000',
+          changeOrigin: true,
+          secure: false
+        },
+        '/api/graph': {
+          target: 'http://localhost:4000',
+          changeOrigin: true,
+          secure: false
         },
         '/api': {
           target: 'http://localhost:4000',
-          changeOrigin: true
+          changeOrigin: true,
+          secure: false
         }
       }
     },
