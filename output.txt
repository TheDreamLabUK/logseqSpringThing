The following text represents a project with code. The structure of the text consists of sections beginning with ----, followed by a single line containing the file path and file name, and then a variable number of lines containing the file contents. The text representing the project ends when the symbols --END-- are encountered. Any further text beyond --END-- is meant to be interpreted as instructions using the aforementioned project as context.
----
app.js
// data/public/js/app.js

import { createApp } from 'vue';
import ControlPanel from './components/ControlPanel.vue';
import ChatManager from './components/chatManager.vue';
import { WebXRVisualization } from './components/visualization/core.js';
import WebsocketService from './services/websocketService.js';
import { GraphDataManager } from './services/graphDataManager.js';
import { isGPUAvailable, initGPU } from './gpuUtils.js';
import { enableSpacemouse } from './services/spacemouse.js';

export class App {
    constructor() {
        console.log('App constructor called');
        this.websocketService = null;
        this.graphDataManager = null;
        this.visualization = null;
        this.gpuAvailable = false;
        this.gpuUtils = null;
        this.xrActive = false;
        this.vueApp = null;
        this.initializeApp();
    }

    initializeApp() {
        console.log('Initializing Application - Step 1: Services');

        // Initialize Services
        try {
            this.websocketService = new WebsocketService();
            console.log('WebsocketService initialized successfully');
        } catch (error) {
            console.error('Failed to initialize WebsocketService:', error);
        }

        if (this.websocketService) {
            this.graphDataManager = new GraphDataManager(this.websocketService);
            console.log('GraphDataManager initialized successfully');
        } else {
            console.error('Cannot initialize GraphDataManager: WebsocketService is not available');
        }
        
        console.log('Initializing Application - Step 2: Visualization');
        try {
            // Add container check
            const container = document.getElementById('scene-container');
            if (!container) {
                console.error('Scene container not found, creating it');
                const newContainer = document.createElement('div');
                newContainer.id = 'scene-container';
                document.body.appendChild(newContainer);
            }

            this.visualization = new WebXRVisualization(this.graphDataManager);
            console.log('WebXRVisualization initialized successfully');
        } catch (error) {
            console.error('Failed to initialize WebXRVisualization:', error);
            console.error('Error stack:', error.stack);
        }

        console.log('Initializing Application - Step 3: GPU');
        // Initialize GPU if available
        this.gpuAvailable = isGPUAvailable();
        if (this.gpuAvailable) {
            this.gpuUtils = initGPU();
            console.log('GPU acceleration initialized');
        } else {
            console.warn('GPU acceleration not available, using CPU fallback');
        }

        console.log('Initializing Application - Step 4: Vue App');
        // Initialize Vue App with ChatManager and ControlPanel
        this.initVueApp();

        console.log('Initializing Application - Step 5: Event Listeners');
        // Setup Event Listeners
        this.setupEventListeners();

        console.log('Initializing Application - Step 6: Three.js');
        // Initialize the visualization
        if (this.visualization) {
            this.visualization.initThreeJS();
        } else {
            console.error('Visualization not initialized, cannot call initThreeJS');
        }
    }

    initVueApp() {
        console.log('Initializing Vue App - Start');
        const websocketService = this.websocketService;
        const visualization = this.visualization;
        const graphDataManager = this.graphDataManager;

        // Create root Vue app
        this.vueApp = createApp({
            components: {
                ControlPanel,
                ChatManager
            },
            setup() {
                console.log('Vue app setup function called');
                const handleControlChange = (data) => {
                    console.log('Control changed:', data.name, data.value);
                    if (visualization) {
                        console.log('Updating visualization:', data);
                        
                        // Handle XR controls
                        if (data.name === 'xrEnabled') {
                            handleXRToggle(data.value);
                            return;
                        }
                        
                        // Handle force-directed graph parameters
                        if (data.name === 'force_directed_iterations' || 
                            data.name === 'force_directed_spring' ||
                            data.name === 'force_directed_repulsion' || 
                            data.name === 'force_directed_attraction' ||
                            data.name === 'force_directed_damping') {
                            updateForceDirectedParams(data.name, data.value);
                        } else {
                            // Create settings object with the correct structure
                            const settings = {};
                            if (data.name.startsWith('node')) {
                                settings.nodes = { [data.name]: data.value };
                            } else if (data.name.startsWith('edge')) {
                                settings.edges = { [data.name]: data.value };
                            } else if (data.name.startsWith('environment')) {
                                settings.environment = { [data.name]: data.value };
                            } else if (data.name.startsWith('layout')) {
                                settings.layout = { [data.name]: data.value };
                            }
                            visualization.updateSettings(settings);
                        }
                    } else {
                        console.error('Cannot update visualization: not initialized');
                    }
                };

                const handleXRToggle = async (xrConfig) => {
                    if (!visualization) return;
                    
                    try {
                        if (xrConfig.active) {
                            // Start XR session
                            await visualization.startXRSession(xrConfig.mode);
                            window.dispatchEvent(new CustomEvent('xrsessionstart'));
                        } else {
                            // End XR session
                            await visualization.endXRSession();
                            window.dispatchEvent(new CustomEvent('xrsessionend'));
                        }
                    } catch (error) {
                        console.error('XR session error:', error);
                        window.dispatchEvent(new CustomEvent('xrsessionerror', {
                            detail: { error: error.message }
                        }));
                    }
                };

                const updateForceDirectedParams = (name, value) => {
                    if (graphDataManager) {
                        // Update the force-directed parameters in the graph data manager
                        graphDataManager.updateForceDirectedParams(name, value);
                        
                        // Trigger a recalculation of the graph layout
                        graphDataManager.recalculateLayout();
                        
                        // Update the visualization with the new layout
                        const currentData = graphDataManager.getGraphData();
                        if (visualization && currentData) {
                            visualization.updateVisualization(currentData);
                        }
                    } else {
                        console.error('Cannot update force-directed parameters: GraphDataManager not initialized');
                    }
                };

                const toggleFullscreen = () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                };

                return {
                    websocketService,
                    handleControlChange,
                    toggleFullscreen,
                    enableSpacemouse
                };
            },
            template: `
                <div>
                    <chat-manager :websocketService="websocketService"></chat-manager>
                    <control-panel 
                        :websocketService="websocketService"
                        @control-change="handleControlChange"
                        @toggle-fullscreen="toggleFullscreen"
                        @enable-spacemouse="enableSpacemouse"
                    ></control-panel>
                </div>
            `
        });

        // Mount the Vue app
        const mountElement = document.getElementById('app');
        if (!mountElement) {
            console.error('Could not find #app element for mounting Vue application');
            return;
        }

        try {
            this.vueApp.mount('#app');
            console.log('Vue App mounted successfully');
        } catch (error) {
            console.error('Failed to mount Vue app:', error);
            console.error('Error details:', error.stack);
        }
    }

    setupEventListeners() {
        console.log('Setting up event listeners');

        if (this.websocketService) {
            // WebSocket Event Listeners
            this.websocketService.on('open', () => {
                console.log('WebSocket connection established');
                this.updateConnectionStatus(true);
                if (this.graphDataManager) {
                    this.graphDataManager.requestInitialData();
                } else {
                    console.error('GraphDataManager not initialized, cannot request initial data');
                }
            });

            this.websocketService.on('message', (data) => {
                console.log('WebSocket message received:', data);
                this.handleWebSocketMessage(data);
            });

            this.websocketService.on('error', (error) => {
                console.error('WebSocket error:', error);
                this.updateConnectionStatus(false);
            });

            this.websocketService.on('close', () => {
                console.log('WebSocket connection closed');
                this.updateConnectionStatus(false);
            });
        } else {
            console.error('WebsocketService not initialized, cannot set up WebSocket listeners');
        }

        // XR Session Event Listeners
        window.addEventListener('xrsessionstart', () => {
            this.xrActive = true;
            console.log('XR session started');
        });

        window.addEventListener('xrsessionend', () => {
            this.xrActive = false;
            console.log('XR session ended');
        });

        window.addEventListener('xrsessionerror', (event) => {
            console.error('XR session error:', event.detail.error);
            this.xrActive = false;
        });

        // Custom Event Listener for Graph Data Updates
        window.addEventListener('graphDataUpdated', (event) => {
            console.log('Graph data updated event received', event.detail);
            if (this.visualization) {
                this.visualization.updateVisualization(event.detail);
            } else {
                console.error('Cannot update visualization: not initialized');
            }
        });

        // Spacemouse Move Event Listener
        window.addEventListener('spacemouse-move', (event) => {
            const { x, y, z } = event.detail;
            if (this.visualization && !this.xrActive) {
                this.visualization.handleSpacemouseInput(x, y, z);
            }
        });

        // Initialize audio on first user interaction
        const initAudio = () => {
            if (this.websocketService) {
                this.websocketService.initAudio();
            }
        };

        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('touchstart', initAudio, { once: true });
    }

    handleWebSocketMessage(data) {
        console.log('Handling WebSocket message:', data);
        switch (data.type) {
            case 'getInitialData':
                console.log('Received initial data:', data);
                if (data.graph_data && this.graphDataManager) {
                    this.graphDataManager.updateGraphData(data.graph_data);
                    if (this.visualization) {
                        const graphData = this.graphDataManager.getGraphData();
                        this.visualization.updateVisualization(graphData);
                    }
                }
                if (data.settings) {
                    console.log('Received settings:', data.settings);
                    if (this.visualization) {
                        this.visualization.updateSettings(data.settings);
                    }
                    window.dispatchEvent(new CustomEvent('serverSettings', {
                        detail: data.settings
                    }));
                } else {
                    console.warn('No settings received in initial data');
                }
                break;

            case 'graphData':
                console.log('Received graph data:', data);
                if (this.graphDataManager) {
                    this.graphDataManager.updateGraphData(data);
                    if (this.visualization) {
                        const graphData = this.graphDataManager.getGraphData();
                        this.visualization.updateVisualization(graphData);
                    }
                }
                break;

            case 'visualSettings':
            case 'materialSettings':
            case 'physicsSettings':
            case 'bloomSettings':
            case 'fisheyeSettings':
                console.log(`Received ${data.type}:`, data);
                if (this.visualization) {
                    // Create a settings object with the correct structure
                    const settings = {};
                    switch (data.type) {
                        case 'visualSettings':
                            settings.visual = data;
                            break;
                        case 'materialSettings':
                            settings.material = data;
                            break;
                        case 'physicsSettings':
                            settings.physics = data;
                            break;
                        case 'bloomSettings':
                            settings.bloom = data;
                            break;
                        case 'fisheyeSettings':
                            settings.fisheye = data;
                            break;
                    }
                    this.visualization.updateSettings(settings);
                }
                break;

            case 'graphUpdate':
                console.log('Received graph update:', data.graphData);
                if (this.graphDataManager) {
                    this.graphDataManager.updateGraphData(data.graphData);
                    if (this.visualization) {
                        const graphData = this.graphDataManager.getGraphData();
                        this.visualization.updateVisualization(graphData);
                    }
                }
                break;

            case 'ttsMethodSet':
                console.log('TTS method set:', data.method);
                break;

            case 'completion':
                console.log('Received completion message:', data.message);
                break;

            case 'error':
                console.error('Server error:', data.message);
                break;

            default:
                console.warn(`Unhandled message type: ${data.type}`, data);
                break;
        }
    }

    updateConnectionStatus(isConnected) {
        const statusElement = document.getElementById('connection-status');
        if (statusElement) {
            statusElement.textContent = isConnected ? 'Connected' : 'Disconnected';
            statusElement.className = isConnected ? 'connected' : 'disconnected';
        } else {
            console.warn('Connection status element not found');
        }
    }

    start() {
        console.log('Starting the application');
        // No need to call animate here since it's already called in initThreeJS
    }
}

----
index.js
import { App } from './app.js';

console.log('Script loading...');

document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, checking elements:');
    console.log('app element:', document.getElementById('app'));
    console.log('scene-container:', document.getElementById('scene-container'));
    console.log('connection-status:', document.getElementById('connection-status'));
    
    try {
        console.log('Creating App instance');
        const app = new App();
        console.log('Starting App');
        app.start();
    } catch (error) {
        console.error('Failed to initialize app:', error);
        console.error('Error stack:', error.stack);
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
            debugInfo.innerHTML += `<div>Init Error: ${error.message}</div>`;
            debugInfo.innerHTML += `<div>Stack: ${error.stack}</div>`;
        }
    }
});

----
gpuUtils.js
// public/js/gpuUtils.js

/**
 * Checks if the GPU is available for acceleration.
 * @returns {boolean} True if GPU is available, false otherwise.
 */
export function isGPUAvailable() {
  try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      return !!gl;
  } catch (e) {
      console.error('GPU availability check failed:', e);
      return false;
  }
}

/**
* Initializes GPU computation utilities.
* @returns {object} An object containing GPU-related methods.
*/
export function initGPU() {
  // Placeholder for GPU computation initialization
  console.log('Initializing GPU utilities.');

  // Implement GPU-related initializations here, such as setting up compute shaders
  // For this example, we'll return an empty object
  return {
      compute: (data) => {
          // Implement GPU computation logic here
          console.log('Performing GPU computation with data:', data);
      }
  };
}

/**
* Performs computations on the GPU.
* @param {object} gpu - The GPU utilities object.
* @param {object} data - The data to compute.
* @returns {boolean} True if computation was successful, false otherwise.
*/
export function computeOnGPU(gpu, data) {
  if (gpu && typeof gpu.compute === 'function') {
      gpu.compute(data);
      return true;
  } else {
      console.warn('GPU compute function is not available.');
      return false;
  }
}

----
xr/xrSetup.js
import * as THREE from 'three';
import { XRButton } from 'three/examples/jsm/webxr/XRButton.js';
import { initXRInteraction, handleXRInput } from './xrInteraction.js';

// Movement speed constant
const MOVEMENT_SPEED = 0.05;

/**
 * Initializes the WebXR session for immersive experiences.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 * @param {THREE.Scene} scene - The Three.js scene.
 * @param {THREE.PerspectiveCamera} camera - The Three.js camera.
 */
export function initXRSession(renderer, scene, camera) {
    if (!scene || !camera) {
        console.error('Scene or camera not provided to initXRSession');
        return;
    }

    // Initialize hand tracking with enhanced features
    const xrInteraction = initXRInteraction(scene, camera, renderer);

    // Configure renderer for XR
    renderer.xr.enabled = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.alpha = true;

    if ('xr' in navigator) {
        // Check for AR support first
        navigator.xr.isSessionSupported('immersive-ar')
            .then(arSupported => {
                if (arSupported) {
                    const sessionInit = {
                        optionalFeatures: [
                            'dom-overlay',
                            'local-floor',
                            'bounded-floor',
                            'hand-tracking',
                            'layers',
                            'passthrough'  // Enable passthrough for Quest 3
                        ],
                        domOverlay: { root: document.body }
                    };

                    const xrButton = XRButton.createButton(renderer, {
                        mode: 'immersive-ar',
                        sessionInit: sessionInit,
                        onSessionStarted: (session) => {
                            console.log('AR session started');
                            // Ensure all sprites (labels) are visible in XR
                            scene.traverse((object) => {
                                if (object.isSprite) {
                                    object.layers.enableAll();
                                    // Adjust sprite scale for better visibility in XR
                                    const currentScale = object.scale.clone();
                                    object.scale.set(currentScale.x * 0.5, currentScale.y * 0.5, 1);
                                }
                            });
                            session.addEventListener('end', () => {
                                console.log('AR session ended');
                                window.dispatchEvent(new CustomEvent('xrsessionend'));
                            });
                            window.dispatchEvent(new CustomEvent('xrsessionstart'));
                        },
                        onSessionEnded: () => {
                            console.log('AR session cleanup');
                            // Reset sprite scales
                            scene.traverse((object) => {
                                if (object.isSprite) {
                                    const currentScale = object.scale.clone();
                                    object.scale.set(currentScale.x * 2, currentScale.y * 2, 1);
                                }
                            });
                        }
                    });

                    document.body.appendChild(xrButton);
                } else {
                    // Fall back to VR if AR is not supported
                    return navigator.xr.isSessionSupported('immersive-vr')
                        .then(vrSupported => {
                            if (vrSupported) {
                                const sessionInit = {
                                    optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                                };

                                const xrButton = XRButton.createButton(renderer, {
                                    mode: 'immersive-vr',
                                    sessionInit: sessionInit,
                                    onSessionStarted: (session) => {
                                        console.log('VR session started');
                                        // Apply same label visibility settings in VR
                                        scene.traverse((object) => {
                                            if (object.isSprite) {
                                                object.layers.enableAll();
                                                const currentScale = object.scale.clone();
                                                object.scale.set(currentScale.x * 0.5, currentScale.y * 0.5, 1);
                                            }
                                        });
                                        session.addEventListener('end', () => {
                                            console.log('VR session ended');
                                            window.dispatchEvent(new CustomEvent('xrsessionend'));
                                        });
                                        window.dispatchEvent(new CustomEvent('xrsessionstart'));
                                    },
                                    onSessionEnded: () => {
                                        console.log('VR session cleanup');
                                        // Reset sprite scales
                                        scene.traverse((object) => {
                                            if (object.isSprite) {
                                                const currentScale = object.scale.clone();
                                                object.scale.set(currentScale.x * 2, currentScale.y * 2, 1);
                                            }
                                        });
                                    }
                                });

                                document.body.appendChild(xrButton);
                            } else {
                                console.warn('Neither AR nor VR is supported');
                            }
                        });
                }
            })
            .catch(err => {
                console.error('Error checking XR session support:', err);
            });

        renderer.xr.addEventListener('sessionstart', (event) => {
            console.log('XR session started');
            const session = event.target.getSession();
            
            session.requestReferenceSpace('local-floor').then(refSpace => {
                console.log('Got local-floor reference space');
                renderer.xr.setReferenceSpace(refSpace);
            }).catch(err => {
                console.warn('Failed to get local-floor reference space:', err);
                session.requestReferenceSpace('local').then(refSpace => {
                    console.log('Falling back to local reference space');
                    renderer.xr.setReferenceSpace(refSpace);
                });
            });
        });

        renderer.xr.addEventListener('sessionend', () => {
            console.log('XR session ended');
        });
    } else {
        console.warn('WebXR not supported in this browser.');
    }

    window.addEventListener('resize', () => {
        if (camera) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });

    return xrInteraction;
}

/**
 * Updates camera position based on XR pose
 * @param {XRFrame} frame - The XR frame
 * @param {XRReferenceSpace} refSpace - The XR reference space
 * @param {THREE.Camera} camera - The Three.js camera
 */
function updateCameraFromXRPose(frame, refSpace, camera) {
    if (!frame || !refSpace || !camera) return;

    const pose = frame.getViewerPose(refSpace);
    if (pose) {
        const view = pose.views[0];
        if (view) {
            const position = new THREE.Vector3();
            position.set(
                view.transform.position.x,
                view.transform.position.y,
                view.transform.position.z
            );
            camera.position.copy(position);
        }
    }
}

/**
 * Handles the XR session's rendering loop.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 * @param {THREE.Scene} scene - The Three.js scene.
 * @param {THREE.PerspectiveCamera} camera - The Three.js camera.
 * @param {Object} xrInteraction - The XR interaction instance.
 */
export function handleXRSession(renderer, scene, camera, xrInteraction) {
    if (!renderer || !scene || !camera) {
        console.error('Required parameters missing in handleXRSession');
        return;
    }

    renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
            try {
                const session = renderer.xr.getSession();
                const refSpace = renderer.xr.getReferenceSpace();

                if (session && refSpace) {
                    updateCameraFromXRPose(frame, refSpace, camera);

                    // Update hand tracking and interactions
                    if (xrInteraction) {
                        xrInteraction.update();
                        handleXRInput(frame, refSpace);
                    }

                    // Handle input sources
                    for (const source of session.inputSources) {
                        if (source && source.gamepad && source.handedness === 'left') {
                            handleGamepadInput(source.gamepad, camera);
                        }
                    }
                }
            } catch (error) {
                console.error('Error in XR frame:', error);
            }
        }
        renderer.render(scene, camera);
    });
}

/**
 * Handles gamepad input in XR.
 * @param {Gamepad} gamepad - The XR gamepad object.
 * @param {THREE.Camera} camera - The Three.js camera.
 */
function handleGamepadInput(gamepad, camera) {
    if (!gamepad || !camera || !camera.parent) return;

    if (gamepad.axes.length >= 2) {
        const [x, y] = gamepad.axes;

        if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(new THREE.Vector3(0, 1, 0), forward);

            const movement = new THREE.Vector3();
            movement.addScaledVector(right, x * MOVEMENT_SPEED);
            movement.addScaledVector(forward, -y * MOVEMENT_SPEED);

            const userGroup = camera.parent;
            userGroup.position.add(movement);
        }
    }
}

/**
 * Updates the XR frame, if necessary.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 * @param {THREE.Scene} scene - The Three.js scene.
 * @param {THREE.PerspectiveCamera} camera - The Three.js camera.
 * @param {Object} xrInteraction - The XR interaction instance.
 */
export function updateXRFrame(renderer, scene, camera, xrInteraction) {
    if (renderer.xr.isPresenting) {
        try {
            const session = renderer.xr.getSession();
            if (session && xrInteraction) {
                xrInteraction.update();
            }
        } catch (error) {
            console.error('Error updating XR frame:', error);
        }
    }
    renderer.render(scene, camera);
}

----
xr/xrInteraction.js
import * as THREE from 'three';
import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory.js';

// Hand tracking setup
const handModelFactory = new XRHandModelFactory();
const hands = {
    left: null,
    right: null
};

// To store object grab states for both hands
const grabStates = {
    left: { grabbedObject: null, pinching: false },
    right: { grabbedObject: null, pinching: false }
};

// Visual feedback for pinch state
const pinchIndicators = {
    left: null,
    right: null
};

// Collection of interactable objects
const interactableObjects = new Set();

// Constants for interaction
const PINCH_THRESHOLD = 0.015; // Smaller threshold for more precise detection
const GRAB_THRESHOLD = 0.08;   // Distance to grab objects
const PINCH_STRENGTH_THRESHOLD = 0.7; // Required strength for pinch

// XR Label Manager Class
export class XRLabelManager {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.labels = new Map();
    }

    createLabel(text, position) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 128;
        
        context.fillStyle = '#ffffff';
        context.font = '24px Arial';
        context.fillText(text, 10, 64);
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            depthWrite: false
        });
        
        const sprite = new THREE.Sprite(material);
        sprite.position.copy(position);
        sprite.scale.set(0.5, 0.25, 1);
        
        this.scene.add(sprite);
        this.labels.set(text, sprite);
        
        return sprite;
    }

    updateLabel(text, position) {
        const label = this.labels.get(text);
        if (label) {
            label.position.copy(position);
            label.lookAt(this.camera.position);
        }
    }

    removeLabel(text) {
        const label = this.labels.get(text);
        if (label) {
            this.scene.remove(label);
            this.labels.delete(text);
        }
    }

    updateAll() {
        this.labels.forEach(label => {
            label.lookAt(this.camera.position);
        });
    }

    dispose() {
        this.labels.forEach(label => {
            if (label.material.map) {
                label.material.map.dispose();
            }
            label.material.dispose();
            this.scene.remove(label);
        });
        this.labels.clear();
    }
}

// Detect pinch with strength
function isPinching(hand) {
    const indexTip = hand.joints['index-finger-tip'];
    const thumbTip = hand.joints['thumb-tip'];

    if (indexTip && thumbTip) {
        const distance = indexTip.position.distanceTo(thumbTip.position);
        // Calculate pinch strength (1 when touching, 0 when far)
        const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
        return {
            isPinched: distance < PINCH_THRESHOLD,
            strength: strength
        };
    }
    return { isPinched: false, strength: 0 };
}

// Create visual feedback sphere for pinch state
function createPinchIndicator() {
    const geometry = new THREE.SphereGeometry(0.01);
    const material = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5
    });
    return new THREE.Mesh(geometry, material);
}

// Update pinch indicator position and appearance
function updatePinchIndicator(hand, indicator) {
    if (hand && hand.joints && indicator) {
        const indexTip = hand.joints['index-finger-tip'];
        const thumbTip = hand.joints['thumb-tip'];
        
        if (indexTip && thumbTip) {
            indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
            const { strength } = isPinching(hand);
            indicator.material.opacity = strength * 0.8;
            indicator.scale.setScalar(1 - (strength * 0.5));
        }
    }
}

// Initialize XR interaction
export function initXRInteraction(scene, camera, renderer, onSelect) {
    const xrLabelManager = new XRLabelManager(scene, camera);
    
    // Create default interactable objects
    const createInteractableObject = (position) => {
        const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0xff0000,
            roughness: 0.7,
            metalness: 0.3
        });
        const object = new THREE.Mesh(geometry, material);
        object.position.copy(position);
        object.userData.interactable = true;
        scene.add(object);
        interactableObjects.add(object);
        return object;
    };

    // Create multiple interactable objects
    createInteractableObject(new THREE.Vector3(0, 1.5, -1));
    createInteractableObject(new THREE.Vector3(0.2, 1.5, -1));
    createInteractableObject(new THREE.Vector3(-0.2, 1.5, -1));

    // Initialize pinch indicators
    pinchIndicators.left = createPinchIndicator();
    pinchIndicators.right = createPinchIndicator();
    scene.add(pinchIndicators.left);
    scene.add(pinchIndicators.right);

    // Set up hand tracking
    renderer.xr.addEventListener('sessionstart', () => {
        const session = renderer.xr.getSession();
        
        hands.left = renderer.xr.getHand(0);
        hands.right = renderer.xr.getHand(1);
        
        // Add hand models
        for (const [handedness, hand] of Object.entries(hands)) {
            if (hand) {
                const handModel = handModelFactory.createHandModel(hand, 'mesh');
                hand.add(handModel);
                scene.add(hand);
            }
        }
    });

    // Create update function
    const update = () => {
        // Update both hands
        for (const [handedness, hand] of Object.entries(hands)) {
            if (hand?.joints) {
                const grabState = grabStates[handedness];
                const { isPinched, strength } = isPinching(hand);
                
                // Update pinch indicator
                updatePinchIndicator(hand, pinchIndicators[handedness]);

                if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                    if (!grabState.grabbedObject) {
                        // Check for nearby interactable objects
                        const indexTip = hand.joints['index-finger-tip'];
                        
                        for (const object of interactableObjects) {
                            const distance = indexTip.position.distanceTo(object.position);
                            if (distance < GRAB_THRESHOLD && !object.userData.isGrabbed) {
                                grabState.grabbedObject = object;
                                object.userData.isGrabbed = true;
                                object.material.emissive.setHex(0x222222);
                                break;
                            }
                        }
                    } else if (grabState.grabbedObject) {
                        // Move grabbed object
                        const indexTip = hand.joints['index-finger-tip'];
                        grabState.grabbedObject.position.copy(indexTip.position);
                    }
                    grabState.pinching = true;
                } else if (grabState.pinching) {
                    // Release object
                    if (grabState.grabbedObject) {
                        grabState.grabbedObject.userData.isGrabbed = false;
                        grabState.grabbedObject.material.emissive.setHex(0x000000);
                        grabState.grabbedObject = null;
                    }
                    grabState.pinching = false;
                }
            }
        }

        // Update label orientations in XR
        if (renderer.xr.isPresenting) {
            const camera = renderer.xr.getCamera();
            scene.traverse((object) => {
                if (object.isSprite) {
                    object.lookAt(camera.position);
                }
            });
        }
    };

    return {
        hands: Object.values(hands),
        controllers: [], // For compatibility with existing code
        xrLabelManager,
        update,
        addInteractableObject: (object) => {
            object.userData.interactable = true;
            interactableObjects.add(object);
        },
        removeInteractableObject: (object) => {
            interactableObjects.delete(object);
        }
    };
}

// Handle XR input
export function handleXRInput(frame, referenceSpace) {
    // Update both hands
    for (const [handedness, hand] of Object.entries(hands)) {
        if (hand?.joints) {
            const grabState = grabStates[handedness];
            const { isPinched, strength } = isPinching(hand);
            
            // Update pinch indicator
            updatePinchIndicator(hand, pinchIndicators[handedness]);

            if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                if (!grabState.grabbedObject) {
                    // Check for nearby interactable objects
                    const indexTip = hand.joints['index-finger-tip'];
                    
                    for (const object of interactableObjects) {
                        const distance = indexTip.position.distanceTo(object.position);
                        if (distance < GRAB_THRESHOLD && !object.userData.isGrabbed) {
                            grabState.grabbedObject = object;
                            object.userData.isGrabbed = true;
                            object.material.emissive.setHex(0x222222);
                            break;
                        }
                    }
                } else if (grabState.grabbedObject) {
                    // Move grabbed object
                    const indexTip = hand.joints['index-finger-tip'];
                    grabState.grabbedObject.position.copy(indexTip.position);
                }
                grabState.pinching = true;
            } else if (grabState.pinching) {
                // Release object
                if (grabState.grabbedObject) {
                    grabState.grabbedObject.userData.isGrabbed = false;
                    grabState.grabbedObject.material.emissive.setHex(0x000000);
                    grabState.grabbedObject = null;
                }
                grabState.pinching = false;
            }
        }
    }
}

----
services/spacemouse.js
// Spacemouse HID interface

const SPACEMOUSE_VENDOR_ID = 0x256F; // 3Dconnexion vendor ID
const SPACEMOUSE_PRODUCT_ID = 0xC635; // SpaceMouse Compact product ID (may vary for different models)

let spacemouseDevice = null;

async function requestHIDAccess() {
    try {
        const devices = await navigator.hid.requestDevice({
            filters: [{ vendorId: SPACEMOUSE_VENDOR_ID, productId: SPACEMOUSE_PRODUCT_ID }]
        });
        if (devices.length > 0) {
            spacemouseDevice = devices[0];
            await spacemouseDevice.open();
            console.log('HID device opened:', spacemouseDevice.productName);
            spacemouseDevice.addEventListener('inputreport', handleHIDInput);
        }
    } catch (error) {
        console.error('HID access denied:', error);
    }
}

function handleHIDInput(event) {
    const { data } = event;
    
    // Parse the input data
    const x = data.getInt16(1, true);
    const y = data.getInt16(3, true);
    const z = data.getInt16(5, true);

    // Normalize values (adjust as needed based on your Spacemouse model)
    const normalizedX = x / 350;
    const normalizedY = y / 350;
    const normalizedZ = z / 350;

    // Emit an event with the normalized values
    const spacemouseEvent = new CustomEvent('spacemouse-move', {
        detail: { x: normalizedX, y: normalizedY, z: normalizedZ }
    });
    window.dispatchEvent(spacemouseEvent);
}

// Function to be called when the "Enable Spacemouse" button is clicked
function enableSpacemouse() {
    if (navigator.hid) {
        requestHIDAccess();
    } else {
        console.error('WebHID is not supported in this browser');
        alert('WebHID is not supported in this browser. Please use a compatible browser like Chrome or Edge.');
    }
}

// Export the function to be used in Vue components
export { enableSpacemouse };
----
services/visualizationSettings.js
// Manages visualization settings received from the server
export class VisualizationSettings {
    constructor() {
        // Default values matching settings.toml
        this.settings = {
            // Node colors
            nodeColor: process.env.NODE_COLOR || '#1A0B31',
            nodeColorNew: process.env.NODE_COLOR_NEW || '#00ff88',
            nodeColorRecent: process.env.NODE_COLOR_RECENT || '#4444ff',
            nodeColorMedium: process.env.NODE_COLOR_MEDIUM || '#ffaa00',
            nodeColorOld: process.env.NODE_COLOR_OLD || '#ff4444',
            nodeColorCore: process.env.NODE_COLOR_CORE || '#ffa500',
            nodeColorSecondary: process.env.NODE_COLOR_SECONDARY || '#00ffff',
            nodeColorDefault: process.env.NODE_COLOR_DEFAULT || '#00ff00',
            
            // Edge settings
            edgeColor: process.env.EDGE_COLOR || '#ff0000',
            edgeOpacity: parseFloat(process.env.EDGE_OPACITY) || 0.3,
            edgeWeightNormalization: parseFloat(process.env.EDGE_WEIGHT_NORMALIZATION) || 10.0,
            edgeMinWidth: parseFloat(process.env.EDGE_MIN_WIDTH) || 1.0,
            edgeMaxWidth: parseFloat(process.env.EDGE_MAX_WIDTH) || 5.0,
            
            // Node sizes and dimensions (in meters)
            minNodeSize: parseFloat(process.env.MIN_NODE_SIZE) || 0.1,  // 10cm
            maxNodeSize: parseFloat(process.env.MAX_NODE_SIZE) || 0.3,  // 30cm
            nodeAgeMaxDays: parseInt(process.env.NODE_AGE_MAX_DAYS) || 30,
            
            // Hologram settings
            hologramColor: process.env.HOLOGRAM_COLOR || '#FFD700',
            hologramScale: parseInt(process.env.HOLOGRAM_SCALE) || 5,
            hologramOpacity: parseFloat(process.env.HOLOGRAM_OPACITY) || 0.1,
            
            // Label settings
            labelFontSize: parseInt(process.env.LABEL_FONT_SIZE) || 36,
            labelFontFamily: process.env.LABEL_FONT_FAMILY || 'Arial',
            labelPadding: parseInt(process.env.LABEL_PADDING) || 20,
            labelVerticalOffset: parseFloat(process.env.LABEL_VERTICAL_OFFSET) || 2.0,
            labelCloseOffset: parseFloat(process.env.LABEL_CLOSE_OFFSET) || 0.2,
            labelBackgroundColor: process.env.LABEL_BACKGROUND_COLOR || 'rgba(0, 0, 0, 0.8)',
            labelTextColor: process.env.LABEL_TEXT_COLOR || 'white',
            labelInfoTextColor: process.env.LABEL_INFO_TEXT_COLOR || 'lightgray',
            labelXRFontSize: parseInt(process.env.LABEL_XR_FONT_SIZE) || 24,
            
            // Environment settings
            fogDensity: parseFloat(process.env.FOG_DENSITY) || 0.002,
            
            // Geometry settings
            geometryMinSegments: parseInt(process.env.GEOMETRY_MIN_SEGMENTS) || 16,
            geometryMaxSegments: parseInt(process.env.GEOMETRY_MAX_SEGMENTS) || 32,
            geometrySegmentPerHyperlink: parseFloat(process.env.GEOMETRY_SEGMENT_PER_HYPERLINK) || 0.5,
            
            // Interaction settings
            clickEmissiveBoost: parseFloat(process.env.CLICK_EMISSIVE_BOOST) || 2.0,
            clickFeedbackDuration: parseInt(process.env.CLICK_FEEDBACK_DURATION) || 200,
            
            // Material settings
            material: {
                metalness: parseFloat(process.env.NODE_MATERIAL_METALNESS) || 0.2,
                roughness: parseFloat(process.env.NODE_MATERIAL_ROUGHNESS) || 0.2,
                clearcoat: parseFloat(process.env.NODE_MATERIAL_CLEARCOAT) || 0.3,
                clearcoatRoughness: parseFloat(process.env.NODE_MATERIAL_CLEARCOAT_ROUGHNESS) || 0.2,
                opacity: parseFloat(process.env.NODE_MATERIAL_OPACITY) || 0.9,
                emissiveMinIntensity: parseFloat(process.env.NODE_EMISSIVE_MIN_INTENSITY) || 0.3,
                emissiveMaxIntensity: parseFloat(process.env.NODE_EMISSIVE_MAX_INTENSITY) || 1.0
            },
            
            // Force-directed layout settings
            iterations: parseInt(process.env.FORCE_DIRECTED_ITERATIONS) || 250,
            spring_strength: parseFloat(process.env.FORCE_DIRECTED_SPRING) || 0.01,
            repulsion_strength: parseFloat(process.env.FORCE_DIRECTED_REPULSION) || 1000.0,
            attraction_strength: parseFloat(process.env.FORCE_DIRECTED_ATTRACTION) || 0.01,
            damping: parseFloat(process.env.FORCE_DIRECTED_DAMPING) || 0.8,
            
            // Bloom settings
            nodeBloomStrength: parseFloat(process.env.NODE_BLOOM_STRENGTH) || 0.1,
            nodeBloomRadius: parseFloat(process.env.NODE_BLOOM_RADIUS) || 0.1,
            nodeBloomThreshold: parseFloat(process.env.NODE_BLOOM_THRESHOLD) || 0.0,
            edgeBloomStrength: parseFloat(process.env.EDGE_BLOOM_STRENGTH) || 0.2,
            edgeBloomRadius: parseFloat(process.env.EDGE_BLOOM_RADIUS) || 0.3,
            edgeBloomThreshold: parseFloat(process.env.EDGE_BLOOM_THRESHOLD) || 0.0,
            environmentBloomStrength: parseFloat(process.env.ENVIRONMENT_BLOOM_STRENGTH) || 0.5,
            environmentBloomRadius: parseFloat(process.env.ENVIRONMENT_BLOOM_RADIUS) || 0.1,
            environmentBloomThreshold: parseFloat(process.env.ENVIRONMENT_BLOOM_THRESHOLD) || 0.0,

            // Fisheye settings
            fisheye: {
                enabled: process.env.FISHEYE_ENABLED === 'true',
                strength: parseFloat(process.env.FISHEYE_STRENGTH) || 0.5,
                radius: parseFloat(process.env.FISHEYE_RADIUS) || 100.0,
                focusX: parseFloat(process.env.FISHEYE_FOCUS_X) || 0.0,
                focusY: parseFloat(process.env.FISHEYE_FOCUS_Y) || 0.0,
                focusZ: parseFloat(process.env.FISHEYE_FOCUS_Z) || 0.0
            }
        };

        // Bind the WebSocket message handler
        this.handleServerSettings = this.handleServerSettings.bind(this);
        window.addEventListener('serverSettings', this.handleServerSettings);
    }

    handleServerSettings(event) {
        const serverSettings = event.detail;
        
        // Deep merge settings with server values
        this.settings = this.deepMerge(this.settings, {
            ...serverSettings.visualization,
            material: serverSettings.visualization?.material,
            fisheye: serverSettings.fisheye,
            ...serverSettings.bloom
        });

        // Dispatch event to notify components of updated settings
        window.dispatchEvent(new CustomEvent('visualizationSettingsUpdated', {
            detail: this.settings
        }));
    }

    // Deep merge helper function
    deepMerge(target, source) {
        const result = { ...target };
        
        Object.keys(source).forEach(key => {
            if (source[key] instanceof Object && !Array.isArray(source[key])) {
                if (key in target) {
                    result[key] = this.deepMerge(target[key], source[key]);
                } else {
                    result[key] = { ...source[key] };
                }
            } else if (source[key] !== undefined) {
                result[key] = source[key];
            }
        });
        
        return result;
    }

    getSettings() {
        return this.settings;
    }

    // Get settings for specific components
    getNodeSettings() {
        return {
            color: this.settings.nodeColor,
            colorNew: this.settings.nodeColorNew,
            colorRecent: this.settings.nodeColorRecent,
            colorMedium: this.settings.nodeColorMedium,
            colorOld: this.settings.nodeColorOld,
            colorCore: this.settings.nodeColorCore,
            colorSecondary: this.settings.nodeColorSecondary,
            colorDefault: this.settings.nodeColorDefault,
            minNodeSize: this.settings.minNodeSize,
            maxNodeSize: this.settings.maxNodeSize,
            material: this.settings.material,
            ageMaxDays: this.settings.nodeAgeMaxDays,
            geometryMinSegments: this.settings.geometryMinSegments,
            geometryMaxSegments: this.settings.geometryMaxSegments,
            geometrySegmentPerHyperlink: this.settings.geometrySegmentPerHyperlink,
            clickEmissiveBoost: this.settings.clickEmissiveBoost,
            clickFeedbackDuration: this.settings.clickFeedbackDuration
        };
    }

    getEdgeSettings() {
        return {
            color: this.settings.edgeColor,
            opacity: this.settings.edgeOpacity,
            weightNormalization: this.settings.edgeWeightNormalization,
            minWidth: this.settings.edgeMinWidth,
            maxWidth: this.settings.edgeMaxWidth,
            bloomStrength: this.settings.edgeBloomStrength,
            bloomRadius: this.settings.edgeBloomRadius,
            bloomThreshold: this.settings.edgeBloomThreshold
        };
    }

    getLabelSettings() {
        return {
            fontSize: this.settings.labelFontSize,
            fontFamily: this.settings.labelFontFamily,
            padding: this.settings.labelPadding,
            verticalOffset: this.settings.labelVerticalOffset,
            closeOffset: this.settings.labelCloseOffset,
            backgroundColor: this.settings.labelBackgroundColor,
            textColor: this.settings.labelTextColor,
            infoTextColor: this.settings.labelInfoTextColor,
            xrFontSize: this.settings.labelXRFontSize
        };
    }

    getHologramSettings() {
        return {
            color: this.settings.hologramColor,
            scale: this.settings.hologramScale,
            opacity: this.settings.hologramOpacity
        };
    }

    getLayoutSettings() {
        return {
            iterations: this.settings.iterations,
            spring_strength: this.settings.spring_strength,
            repulsion_strength: this.settings.repulsion_strength,
            attraction_strength: this.settings.attraction_strength,
            damping: this.settings.damping
        };
    }

    getEnvironmentSettings() {
        return {
            fogDensity: this.settings.fogDensity,
            bloomStrength: this.settings.environmentBloomStrength,
            bloomRadius: this.settings.environmentBloomRadius,
            bloomThreshold: this.settings.environmentBloomThreshold
        };
    }

    getFisheyeSettings() {
        return this.settings.fisheye;
    }
}

// Create and export a singleton instance
export const visualizationSettings = new VisualizationSettings();

----
services/graphDataManager.js
// public/js/services/graphDataManager.js

/**
 * GraphDataManager handles the management and updating of graph data received from the server.
 */
export class GraphDataManager {
    websocketService = null;
    graphData = null;
    forceDirectedParams = {
        iterations: 250,
        spring_strength: 0.1,
        repulsion_strength: 1000,
        attraction_strength: 0.01,
        damping: 0.8,
        time_step: 0.5  // Add default time_step
    };
    pendingRecalculation = false;
    initialLayoutDone = false;

    /**
     * Creates a new GraphDataManager instance.
     * @param {WebsocketService} websocketService - The WebSocket service instance.
     */
    constructor(websocketService) {
        this.websocketService = websocketService;
        console.log('GraphDataManager initialized');
        
        // Use arrow functions for event handlers to preserve this context
        this.websocketService.on('graphUpdate', this.handleGraphUpdate);
        this.websocketService.on('gpuPositions', this.handleGPUPositions);
    }

    requestInitialData = () => {
        console.log('Requesting initial data');
        this.websocketService.send({ type: 'getInitialData' });
    }

    handleGPUPositions = (update) => {
        if (!this.graphData || !this.graphData.nodes) {
            console.error('Cannot apply GPU position update: No graph data exists');
            return;
        }

        const { positions } = update;
        console.log('Received GPU position update:', positions);
        
        // Transform position array into node objects
        const updatedNodes = this.graphData.nodes.map((node, index) => {
            if (positions[index]) {
                const pos = positions[index];
                if (Array.isArray(pos) && pos.length >= 6) {
                    return {
                        ...node,
                        x: pos[0],
                        y: pos[1],
                        z: pos[2],
                        vx: pos[3],
                        vy: pos[4],
                        vz: pos[5]
                    };
                }
            }
            return node;
        });

        // Update the graph data with the new nodes
        this.graphData = {
            ...this.graphData,
            nodes: updatedNodes
        };

        // Notify visualization of position updates with structured data
        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
            detail: {
                nodes: this.graphData.nodes,
                edges: this.graphData.edges,
                metadata: this.graphData.metadata
            }
        }));
    }

    handleGraphUpdate = (data) => {
        console.log('Received graph update:', data);
        if (!data || !data.graphData) {
            console.error('Invalid graph update data received:', data);
            return;
        }
        this.updateGraphData(data.graphData);
    }

    updateGraphData = (newData) => {
        console.log('Updating graph data with:', newData);
        
        if (!newData) {
            console.error('Received null or undefined graph data');
            return;
        }

        // Preserve metadata if it exists in newData
        const metadata = newData.metadata || {};
        console.log('Received metadata:', metadata);

        // Handle the case where newData already has nodes and edges arrays
        if (Array.isArray(newData.nodes) && Array.isArray(newData.edges)) {
            // Integrate new positions with existing velocities and metadata
            const nodes = newData.nodes.map(node => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === node.id);
                const nodeMetadata = metadata[`${node.id}.md`] || {};
                
                // Keep existing velocities if available, otherwise initialize to 0
                const vx = existingNode?.vx || 0;
                const vy = existingNode?.vy || 0;
                const vz = existingNode?.vz || 0;

                // Use new position if valid, otherwise keep existing or initialize to 0
                const x = (typeof node.x === 'number' && !isNaN(node.x)) ? node.x : 
                         (existingNode?.x || 0);
                const y = (typeof node.y === 'number' && !isNaN(node.y)) ? node.y :
                         (existingNode?.y || 0);
                const z = (typeof node.z === 'number' && !isNaN(node.z)) ? node.z :
                         (existingNode?.z || 0);

                return {
                    ...node,
                    x, y, z,
                    vx, vy, vz,
                    metadata: nodeMetadata
                };
            });

            this.graphData = {
                nodes,
                edges: newData.edges,
                metadata
            };
        }
        // Handle the case where we need to construct nodes from edges
        else if (Array.isArray(newData.edges)) {
            const nodeSet = new Set();
            newData.edges.forEach(edge => {
                nodeSet.add(edge.source);
                nodeSet.add(edge.target);
            });

            const nodes = Array.from(nodeSet).map(id => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === id);
                const nodeMetadata = metadata[`${id}.md`] || {};
                
                return {
                    id,
                    label: id,
                    // Preserve existing position and velocity if available
                    x: existingNode?.x || 0,
                    y: existingNode?.y || 0,
                    z: existingNode?.z || 0,
                    vx: existingNode?.vx || 0,
                    vy: existingNode?.vy || 0,
                    vz: existingNode?.vz || 0,
                    metadata: nodeMetadata
                };
            });

            this.graphData = {
                nodes,
                edges: newData.edges.map(e => ({
                    source: e.source,
                    target: e.target,
                    weight: e.weight,
                    hyperlinks: e.hyperlinks
                })),
                metadata
            };
        } else {
            console.error('Received invalid graph data:', newData);
            return;
        }

        console.log(`Graph data updated: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
        console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
        
        // Dispatch an event to notify that the graph data has been updated with structured data
        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
            detail: {
                nodes: this.graphData.nodes,
                edges: this.graphData.edges,
                metadata: this.graphData.metadata
            }
        }));

        // If there was a pending recalculation, do it now
        if (this.pendingRecalculation) {
            console.log('Processing pending layout recalculation');
            this.pendingRecalculation = false;
            this.recalculateLayout();
        }

        // If this is the first time we've received graph data, mark it as initial layout
        if (!this.initialLayoutDone) {
            console.log('Performing initial layout calculation');
            this.initialLayoutDone = true;
            this.recalculateLayout(true);
        }
    }

    getGraphData = () => {
        if (this.graphData) {
            console.log(`Returning graph data: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
            console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
        } else {
            console.warn('Graph data is null');
        }
        return {
            nodes: this.graphData?.nodes || [],
            edges: this.graphData?.edges || [],
            metadata: this.graphData?.metadata || {}
        };
    }

    isGraphDataValid = () => {
        return this.graphData && 
               Array.isArray(this.graphData.nodes) && 
               Array.isArray(this.graphData.edges) &&
               this.graphData.nodes.length > 0;
    }

    updateForceDirectedParams = (name, value) => {
        console.log(`Updating force-directed parameter: ${name} = ${value}`);
        
        // Convert from forceDirected prefixed names to server parameter names
        const paramMap = {
            'forceDirectedIterations': 'iterations',
            'forceDirectedSpring': 'spring_strength',
            'forceDirectedRepulsion': 'repulsion_strength',
            'forceDirectedAttraction': 'attraction_strength',
            'forceDirectedDamping': 'damping'
        };

        const serverParamName = paramMap[name] || name;
        if (this.forceDirectedParams.hasOwnProperty(serverParamName)) {
            this.forceDirectedParams[serverParamName] = value;
            console.log('Force-directed parameters updated:', this.forceDirectedParams);
            
            // Only recalculate if we have valid graph data, otherwise mark as pending
            if (this.isGraphDataValid()) {
                this.recalculateLayout();
            } else {
                console.log('Marking layout recalculation as pending until graph data is available');
                this.pendingRecalculation = true;
            }
        } else {
            console.warn(`Unknown force-directed parameter: ${name}`);
        }
    }

    recalculateLayout = (isInitial = false) => {
        console.log('Requesting server layout recalculation with parameters:', this.forceDirectedParams);
        if (this.isGraphDataValid()) {
            // Create binary data with multiplexed header
            const buffer = new ArrayBuffer(this.graphData.nodes.length * 24 + 4);
            const view = new Float32Array(buffer);
            
            // Pack is_initial_layout and time_step into a single float32:
            // Integer part (0 or 1) = is_initial_layout
            // Decimal part = time_step
            // Example: 0.5 = not initial layout (0) with time_step of 0.5
            //         1.5 = is initial layout (1) with time_step of 0.5
            view[0] = isInitial ? (1 + this.forceDirectedParams.time_step) : this.forceDirectedParams.time_step;

            // Fill position data
            this.graphData.nodes.forEach((node, index) => {
                const offset = index * 6 + 1; // +1 to skip the header
                // Position
                view[offset] = node.x;
                view[offset + 1] = node.y;
                view[offset + 2] = node.z;
                // Velocity
                view[offset + 3] = node.vx || 0;
                view[offset + 4] = node.vy || 0;
                view[offset + 5] = node.vz || 0;
            });

            // Send binary data directly
            this.websocketService.send(buffer);
            
            window.dispatchEvent(new CustomEvent('layoutRecalculationRequested', {
                detail: this.forceDirectedParams
            }));
        } else {
            console.error('Cannot recalculate layout: Invalid graph data');
            this.pendingRecalculation = true;
        }
    }
}

----
services/websocketService.js
// Secure WebSocket service with improved error handling and security measures
export default class WebsocketService {
    // Event emitter implementation
    _events = new Map();

    // Rate limiting configuration
    messageQueue = [];
    messageRateLimit = 50; // messages per second
    messageTimeWindow = 1000; // 1 second
    lastMessageTime = 0;
    
    // Security configuration
    maxMessageSize = 1024 * 1024; // 1MB limit
    maxAudioSize = 5 * 1024 * 1024; // 5MB limit
    maxQueueSize = 100;
    validMessageTypes = new Set([
        'getInitialData',
        'graphUpdate',
        'audioData',
        'answer',
        'error',
        'ragflowResponse',
        'openaiResponse',
        'simulationModeSet',
        'fisheye_settings_updated',  // Use underscore format consistently
        'completion',                // Add completion message type
        'position_update_complete',   // Add position update completion type
        'graphData',                // Add server-sent message types
        'visualSettings',
        'materialSettings',
        'physicsSettings',
        'bloomSettings',
        'fisheyeSettings',
        'updateSettings',           // Add new settings update type
        'settings_updated'          // Add confirmation response type
    ]);

    // WebSocket configuration
    socket = null;
    reconnectAttempts = 0;
    maxRetries = 3;
    retryDelay = 5000;
    
    // Audio configuration
    audioContext = null;
    audioQueue = [];
    isPlaying = false;
    audioInitialized = false;

    constructor() {
        // Initialize connection
        this.connect();
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => this.cleanup());
    }

    // Event emitter methods
    on = (event, callback) => {
        if (!this._events.has(event)) {
            this._events.set(event, []);
        }
        this._events.get(event).push(callback);
    }

    off = (event, callback) => {
        if (!this._events.has(event)) return;
        const callbacks = this._events.get(event);
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
            callbacks.splice(index, 1);
        }
    }

    emit = (event, ...args) => {
        if (!this._events.has(event)) return;
        const callbacks = this._events.get(event);
        callbacks.forEach(callback => {
            try {
                callback(...args);
            } catch (error) {
                console.error(`Error in event listener for ${event}:`, error);
            }
        });
    }

    // Secure WebSocket URL generation
    getWebSocketUrl = () => {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.hostname;
        const port = window.location.port ? `:${window.location.port}` : '';
        const url = `${protocol}//${host}${port}/ws`;
        console.log('Generated WebSocket URL:', url);
        return url;
    }

    // Establish secure WebSocket connection
    connect = () => {
        const url = this.getWebSocketUrl();
        console.log('Attempting to connect to WebSocket at:', url);
        
        try {
            this.socket = new WebSocket(url);
            this.socket.binaryType = 'arraybuffer';  // Set binary type for position updates

            this.socket.onopen = () => {
                console.log('WebSocket connection established');
                this.reconnectAttempts = 0;
                this.emit('open');
                
                // Update connection status indicator
                const statusElement = document.getElementById('connection-status');
                if (statusElement) {
                    statusElement.textContent = 'Connected';
                    statusElement.className = 'connected';
                }
                
                // Request initial graph data and settings
                console.log('Requesting initial data');
                this.send({ type: 'getInitialData' });
                this.processQueuedMessages();
            };

            this.socket.onclose = (event) => {
                console.log('WebSocket connection closed:', event);
                
                // Update connection status indicator
                const statusElement = document.getElementById('connection-status');
                if (statusElement) {
                    statusElement.textContent = 'Disconnected';
                    statusElement.className = 'disconnected';
                }
                
                this.emit('close');
                this.reconnect();
            };

            this.socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.emit('error', error);
            };

            this.socket.onmessage = this.handleMessage;
            
        } catch (error) {
            console.error('Error creating WebSocket connection:', error);
            this.emit('error', error);
        }
    }

    handleMessage = async (event) => {
        try {
            // Handle binary data (position updates)
            if (event.data instanceof ArrayBuffer) {
                // Log received buffer size
                console.log(`Received binary data of size: ${event.data.byteLength} bytes`);
                
                // Convert ArrayBuffer to Float32Array for position updates
                const positions = new Float32Array(event.data);
                const positionUpdates = [];
                
                // Extract header (first float32)
                const header = positions[0];
                const isInitialLayout = header >= 1.0;
                const timeStep = header % 1.0;
                console.log(`Received position update: isInitial=${isInitialLayout}, timeStep=${timeStep}`);
                
                // Process position data (skip header)
                for (let i = 1; i < positions.length; i += 6) {  // Start from 1 to skip header
                    if (i + 5 < positions.length) {  // Ensure we have complete node data
                        positionUpdates.push([
                            positions[i],     // x
                            positions[i + 1], // y
                            positions[i + 2], // z
                            positions[i + 3], // vx
                            positions[i + 4], // vy
                            positions[i + 5]  // vz
                        ]);
                    }
                }

                console.log(`Processed ${positionUpdates.length} node position updates`);

                // Emit the gpuPositions event with the updates
                this.emit('gpuPositions', { positions: positionUpdates });

                // Also dispatch the event for backward compatibility
                window.dispatchEvent(new CustomEvent('binaryPositionUpdate', {
                    detail: positionUpdates
                }));
                return;
            }

            // Handle JSON messages
            let data;
            try {
                data = JSON.parse(event.data);
            } catch (error) {
                console.error('Failed to parse JSON message:', error);
                console.error('Raw message:', event.data);
                this.emit('error', { 
                    type: 'parse_error', 
                    message: 'Invalid JSON message received',
                    details: error.message
                });
                return;
            }

            // Validate message size
            if (event.data.length > this.maxMessageSize) {
                console.error('Message exceeds size limit');
                this.emit('error', { 
                    type: 'size_error', 
                    message: 'Message size exceeds limit'
                });
                return;
            }

            // Validate message type
            if (!data.type || !this.validMessageTypes.has(data.type)) {
                console.error('Invalid message type:', data.type);
                this.emit('error', { 
                    type: 'validation_error', 
                    message: 'Invalid message type'
                });
                return;
            }

            // Process the validated message
            this.handleServerMessage(data);

        } catch (error) {
            console.error('Error processing WebSocket message:', error);
            console.error('Error stack:', error.stack);
            this.emit('error', { 
                type: 'processing_error', 
                message: error.message
            });
        }
    }

    reconnect = () => {
        if (this.reconnectAttempts < this.maxRetries) {
            this.reconnectAttempts++;
            console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxRetries}) in ${this.retryDelay / 1000} seconds...`);
            setTimeout(() => this.connect(), this.retryDelay);
        } else {
            console.error('Max reconnection attempts reached. Please refresh the page or check your connection.');
            this.emit('maxReconnectAttemptsReached');
        }
    }

    send = (data) => {
        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            if (data instanceof ArrayBuffer) {
                // Log binary data size before sending
                console.log(`Sending binary data of size: ${data.byteLength} bytes`);
                this.socket.send(data);
            } else {
                // Send JSON data
                console.log('Sending WebSocket message:', data);
                try {
                    this.socket.send(JSON.stringify(data));
                } catch (error) {
                    console.error('Error sending WebSocket message:', error);
                    this.emit('error', { type: 'send_error', message: error.message });
                }
            }
        } else {
            console.warn('WebSocket not open. Queuing message...');
            this.queueMessage(data);
        }
    }

    queueMessage = (data) => {
        if (this.messageQueue.length >= this.maxQueueSize) {
            console.warn('Message queue full. Dropping message:', data);
            return;
        }
        this.messageQueue.push(data);
    }

    processQueuedMessages = () => {
        const now = Date.now();
        const messagesToSend = [];
        let messageCount = 0;
        for (const message of this.messageQueue) {
            if (messageCount < this.messageRateLimit && now - this.lastMessageTime >= this.messageTimeWindow / this.messageRateLimit) {
                messagesToSend.push(message);
                this.lastMessageTime = now;
                messageCount++;
            } else {
                break; // Stop if rate limit is reached
            }
        }
        this.messageQueue.splice(0, messagesToSend.length);
        messagesToSend.forEach(message => this.send(message));
    }

    handleServerMessage = (data) => {
        console.log('Handling server message:', data);
        
        // Validate message type
        if (!this.validMessageTypes.has(data.type)) {
            console.warn('Received message with invalid type:', data.type);
            return;
        }
        
        // First emit the raw message for any listeners that need it
        this.emit('message', data);
        
        // Then handle specific message types
        switch (data.type) {
            case 'getInitialData':
                console.log('Received initial data:', data);
                if (data.graph_data) {
                    // Ensure graph data is properly structured
                    const graphData = {
                        nodes: Array.isArray(data.graph_data.nodes) ? data.graph_data.nodes : [],
                        edges: Array.isArray(data.graph_data.edges) ? data.graph_data.edges : [],
                        metadata: data.graph_data.metadata || {}
                    };
                    console.log('Emitting graph update with structured data:', graphData);
                    this.emit('graphUpdate', { graphData });
                }
                if (data.settings) {
                    console.log('Dispatching server settings:', data.settings);
                    if (data.settings.visualization) {
                        const viz = data.settings.visualization;
                        ['nodeColor', 'edgeColor', 'hologramColor'].forEach(key => {
                            if (viz[key]) {
                                let color = viz[key].replace(/['"]/g, '');
                                if (color.startsWith('0x')) {
                                    color = color.slice(2);
                                } else if (color.startsWith('#')) {
                                    color = color.slice(1);
                                }
                                color = color.padStart(6, '0');
                                viz[key] = '#' + color;
                            }
                        });
                    }
                    window.dispatchEvent(new CustomEvent('settingsUpdated', {
                        detail: data.settings
                    }));
                } else {
                    console.warn('No settings received in initial data');
                }
                break;
                
            case 'graphUpdate':
                console.log('Received graph update:', data.graph_data);
                if (data.graph_data) {
                    // Ensure graph data is properly structured
                    const graphData = {
                        nodes: Array.isArray(data.graph_data.nodes) ? data.graph_data.nodes : [],
                        edges: Array.isArray(data.graph_data.edges) ? data.graph_data.edges : [],
                        metadata: data.graph_data.metadata || {}
                    };
                    console.log('Emitting graph update with structured data:', graphData);
                    this.emit('graphUpdate', { graphData });
                }
                break;
                
            case 'audioData':
                this.handleAudioData(data.audio_data);
                break;
                
            case 'answer':
                this.emit('ragflowAnswer', data.answer);
                break;
                
            case 'error':
                console.error('Server error:', data.message);
                this.emit('error', { type: 'server_error', message: data.message });
                break;
                
            case 'ragflowResponse':
                this.handleRagflowResponse(data);
                break;
                
            case 'openaiResponse':
                this.emit('openaiResponse', data.response);
                break;
                
            case 'simulationModeSet':
                console.log('Simulation mode set:', data.mode);
                this.emit('simulationModeSet', data.mode);
                break;

            case 'fisheye_settings_updated':
                console.log('Fisheye settings updated:', data);
                const settings = {
                    enabled: data.fisheye_enabled,
                    strength: data.fisheye_strength,
                    focusPoint: [
                        data.fisheye_focus_x,
                        data.fisheye_focus_y,
                        data.fisheye_focus_z
                    ],
                    radius: data.fisheye_radius
                };
                window.dispatchEvent(new CustomEvent('fisheyeSettingsUpdated', {
                    detail: settings
                }));
                break;

            case 'settings_updated':
                console.log('Settings successfully updated:', data);
                window.dispatchEvent(new CustomEvent('settingsUpdated', {
                    detail: data.settings
                }));
                break;

            case 'completion':
                console.log('Received completion message:', data.message);
                this.emit('completion', data.message);
                break;

            case 'position_update_complete':
                console.log('Position update completed:', data.status);
                this.emit('positionUpdateComplete', data.status);
                break;

            // Add handlers for new message types
            case 'graphData':
            case 'visualSettings':
            case 'materialSettings':
            case 'physicsSettings':
            case 'bloomSettings':
            case 'fisheyeSettings':
                // These messages are handled by the event listeners
                console.log(`Received ${data.type} update:`, data);
                break;
                
            default:
                console.warn('Unhandled message type:', data.type);
                break;
        }
    }

    handleRagflowResponse = (data) => {
        console.log('Handling RAGFlow response:', data);
        this.emit('ragflowAnswer', data.answer);
        if (data.audio) {
            const audioBlob = this.base64ToBlob(data.audio, 'audio/wav');
            this.handleAudioData(audioBlob);
        } else {
            console.warn('No audio data in RAGFlow response');
        }
    }

    base64ToBlob = (base64, mimeType) => {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
    }

    handleAudioData = async (audioBlob) => {
        if (!this.audioContext) {
            console.warn('AudioContext not initialized. Waiting for user interaction...');
            return;
        }

        try {
            console.log('Audio Blob size:', audioBlob.size);
            console.log('Audio Blob type:', audioBlob.type);
            const arrayBuffer = await audioBlob.arrayBuffer();
            console.log('ArrayBuffer size:', arrayBuffer.byteLength);
            const audioBuffer = await this.decodeWavData(arrayBuffer);
            this.audioQueue.push(audioBuffer);
            if (!this.isPlaying) {
                this.playNextAudio();
            }
        } catch (error) {
            console.error('Error processing audio data:', error);
            this.emit('error', { type: 'audio_processing_error', message: error.message });
        }
    }

    decodeWavData = async (wavData) => {
        return new Promise((resolve, reject) => {
            console.log('WAV data size:', wavData.byteLength);
            const dataView = new DataView(wavData.slice(0, 16));
            const header = new TextDecoder().decode(dataView);
            console.log('Header:', header);
            if (header !== 'RIFF') {
                console.error('Invalid WAV header:', header);
                return reject(new Error(`Invalid WAV header: ${header}`));
            }

            this.audioContext.decodeAudioData(
                wavData,
                (buffer) => {
                    console.log('Audio successfully decoded:', buffer);
                    resolve(buffer);
                },
                (error) => {
                    console.error('Error in decodeAudioData:', error);
                    reject(new Error(`Error decoding WAV data: ${error}`));
                }
            );
        });
    }

    playNextAudio = () => {
        if (this.audioQueue.length === 0) {
            this.isPlaying = false;
            return;
        }

        this.isPlaying = true;
        const audioBuffer = this.audioQueue.shift();
        const source = this.audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(this.audioContext.destination);
        source.onended = () => this.playNextAudio();
        source.start();
    }

    initAudio = () => {
        if (this.audioInitialized) {
            console.log('Audio already initialized');
            return;
        }

        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.audioInitialized = true;
            console.log('AudioContext initialized');

            // Process any queued audio data
            if (this.audioQueue.length > 0 && !this.isPlaying) {
                this.playNextAudio();
            }
        } catch (error) {
            console.error('Failed to initialize AudioContext:', error);
            this.emit('error', { type: 'audio_init_error', message: error.message });
        }
    }

    setSimulationMode = (mode) => {
        this.send({
            type: 'setSimulationMode',
            mode: mode
        });
    }

    sendChatMessage = ({ message, useOpenAI }) => {
        this.send({
            type: 'chatMessage',
            message,
            use_openai: useOpenAI
        });
    }

    updateFisheyeSettings = (settings) => {
        console.log('Updating fisheye settings:', settings);
        const focus_point = settings.focusPoint || [0, 0, 0];
        this.send({
            type: 'updateFisheyeSettings',
            enabled: settings.enabled,
            strength: settings.strength,
            focus_point: focus_point,
            radius: settings.radius || 100.0
        });
    }

    updateSettings = (settings) => {
        console.log('Sending settings update:', settings);
        this.send({
            type: 'updateSettings',
            settings
        });
    }

    cleanup = () => {
        if (this.socket) {
            this.socket.close();
        }
        if (this.audioContext) {
            this.audioContext.close();
        }
    }
}

----
components/VRControlPanel.js
import * as THREE from 'three';

export class VRControlPanel {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.panel = new THREE.Group();
        this.controls = new Map();
        this.initPanel();
    }

    initPanel() {
        // Create a background panel
        const panelGeometry = new THREE.PlaneGeometry(1, 1.5);
        const panelMaterial = new THREE.MeshBasicMaterial({ color: 0x202020, transparent: true, opacity: 0.7 });
        const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
        this.panel.add(panelMesh);

        // Position the panel in front of the camera
        this.panel.position.set(0, 0, -2);
        this.panel.lookAt(this.camera.position);

        this.scene.add(this.panel);
    }

    createSlider(name, min, max, value, y) {
        const sliderGroup = new THREE.Group();
        sliderGroup.name = name;

        // Create slider track
        const trackGeometry = new THREE.PlaneGeometry(0.8, 0.05);
        const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x505050 });
        const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
        sliderGroup.add(trackMesh);

        // Create slider handle
        const handleGeometry = new THREE.SphereGeometry(0.03);
        const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
        handleMesh.position.x = this.mapValue(value, min, max, -0.4, 0.4);
        sliderGroup.add(handleMesh);

        // Create label
        const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
        const labelMaterial = new THREE.MeshBasicMaterial({ map: this.createTextTexture(name) });
        const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
        labelMesh.position.set(-0.6, 0, 0);
        sliderGroup.add(labelMesh);

        sliderGroup.position.set(0, y, 0.01);
        this.panel.add(sliderGroup);
        this.controls.set(name, { group: sliderGroup, min, max, value });
    }

    createColorPicker(name, value, y) {
        const pickerGroup = new THREE.Group();
        pickerGroup.name = name;

        // Create color swatch
        const swatchGeometry = new THREE.PlaneGeometry(0.1, 0.1);
        const swatchMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(value) });
        const swatchMesh = new THREE.Mesh(swatchGeometry, swatchMaterial);
        pickerGroup.add(swatchMesh);

        // Create label
        const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
        const labelMaterial = new THREE.MeshBasicMaterial({ map: this.createTextTexture(name) });
        const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
        labelMesh.position.set(-0.3, 0, 0);
        pickerGroup.add(labelMesh);

        pickerGroup.position.set(0, y, 0.01);
        this.panel.add(pickerGroup);
        this.controls.set(name, { group: pickerGroup, value });
    }

    createTextTexture(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        context.font = '48px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 128, 32);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    mapValue(value, inMin, inMax, outMin, outMax) {
        return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    }

    updateControl(name, value) {
        const control = this.controls.get(name);
        if (control) {
            if (control.min !== undefined && control.max !== undefined) {
                // It's a slider
                const handle = control.group.children[1];
                handle.position.x = this.mapValue(value, control.min, control.max, -0.4, 0.4);
            } else {
                // It's a color picker
                const swatch = control.group.children[0];
                swatch.material.color.set(value);
            }
            control.value = value;
        }
    }

    handleInteraction(intersection) {
        const controlName = intersection.object.parent.name;
        const control = this.controls.get(controlName);
        if (control) {
            if (control.min !== undefined && control.max !== undefined) {
                // It's a slider
                const newValue = this.mapValue(intersection.point.x, -0.4, 0.4, control.min, control.max);
                this.updateControl(controlName, newValue);
                return { name: controlName, value: newValue };
            } else {
                // It's a color picker
                // For simplicity, we'll just cycle through a few preset colors
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
                const currentIndex = colors.indexOf(control.value);
                const newValue = colors[(currentIndex + 1) % colors.length];
                this.updateControl(controlName, newValue);
                return { name: controlName, value: '#' + newValue.toString(16).padStart(6, '0') };
            }
        }
        return null;
    }
}

----
components/ControlPanel.vue
<script>
import { defineComponent, ref, reactive, onMounted, onBeforeUnmount, watch } from 'vue';

export default defineComponent({
    name: 'ControlPanel',
    props: {
        websocketService: {
            type: Object,
            required: true
        }
    },
    setup(props, { emit }) {
        console.log('ControlPanel setup called');
        
        // Panel visibility state
        const isHidden = ref(false);
        const collapsedGroups = reactive({
            chat: false,
            nodeAppearance: false,
            edgeAppearance: false,
            bloom: false,
            physics: false,
            fisheye: false,
            environment: false,
            additional: false
        });

        // Chat state
        const chatInput = ref('');
        const chatMessages = ref([]);
        const audioInitialized = ref(false);

        // Node Appearance Controls
        const nodeAppearanceControls = reactive({
            colors: [
                { name: 'nodeColor', label: 'Base Color', value: '#FFA500' },
                { name: 'nodeColorNew', label: 'New Nodes', value: '#FFD700' },
                { name: 'nodeColorRecent', label: 'Recent Nodes', value: '#FFA500' },
                { name: 'nodeColorMedium', label: 'Medium-age Nodes', value: '#DAA520' },
                { name: 'nodeColorOld', label: 'Old Nodes', value: '#CD853F' },
                { name: 'nodeColorCore', label: 'Core Nodes', value: '#FFB90F' },
                { name: 'nodeColorSecondary', label: 'Secondary Nodes', value: '#FFC125' }
            ],
            size: [
                { name: 'minNodeSize', label: 'Min Node Size (cm)', value: 15, min: 5, max: 30, step: 1 },
                { name: 'maxNodeSize', label: 'Max Node Size (cm)', value: 40, min: 20, max: 60, step: 1 }
            ],
            material: [
                { name: 'nodeMaterialMetalness', label: 'Metalness', value: 0.7, min: 0, max: 1, step: 0.1 },
                { name: 'nodeMaterialRoughness', label: 'Roughness', value: 0.1, min: 0, max: 1, step: 0.1 },
                { name: 'nodeMaterialClearcoat', label: 'Clearcoat', value: 0.8, min: 0, max: 1, step: 0.1 },
                { name: 'nodeMaterialClearcoatRoughness', label: 'Clearcoat Roughness', value: 0.1, min: 0, max: 1, step: 0.1 },
                { name: 'nodeMaterialOpacity', label: 'Opacity', value: 0.95, min: 0, max: 1, step: 0.05 }
            ],
            emissive: [
                { name: 'nodeEmissiveMin', label: 'Min Glow', value: 0.4, min: 0, max: 1, step: 0.1 },
                { name: 'nodeEmissiveMax', label: 'Max Glow', value: 1.2, min: 0, max: 2, step: 0.1 }
            ]
        });

        // Edge Appearance Controls
        const edgeAppearanceControls = reactive({
            colors: [
                { name: 'edgeColor', label: 'Edge Color', value: '#FFD700' }
            ],
            properties: [
                { name: 'edgeOpacity', label: 'Edge Opacity', value: 0.4, min: 0, max: 1, step: 0.1 },
                { name: 'edgeWeightNorm', label: 'Weight Normalization', value: 12, min: 1, max: 20, step: 1 },
                { name: 'edgeMinWidth', label: 'Min Width', value: 1.5, min: 0.5, max: 5, step: 0.5 },
                { name: 'edgeMaxWidth', label: 'Max Width', value: 6.0, min: 2, max: 10, step: 0.5 }
            ]
        });

        // Bloom Effect Controls
        const bloomControls = reactive({
            node: [
                { name: 'nodeBloomStrength', label: 'Node Strength', value: 0.8, min: 0, max: 2, step: 0.1 },
                { name: 'nodeBloomRadius', label: 'Node Radius', value: 0.3, min: 0, max: 1, step: 0.1 },
                { name: 'nodeBloomThreshold', label: 'Node Threshold', value: 0.2, min: 0, max: 1, step: 0.1 }
            ],
            edge: [
                { name: 'edgeBloomStrength', label: 'Edge Strength', value: 0.6, min: 0, max: 2, step: 0.1 },
                { name: 'edgeBloomRadius', label: 'Edge Radius', value: 0.4, min: 0, max: 1, step: 0.1 },
                { name: 'edgeBloomThreshold', label: 'Edge Threshold', value: 0.1, min: 0, max: 1, step: 0.1 }
            ],
            environment: [
                { name: 'envBloomStrength', label: 'Environment Strength', value: 0.7, min: 0, max: 2, step: 0.1 },
                { name: 'envBloomRadius', label: 'Environment Radius', value: 0.3, min: 0, max: 1, step: 0.1 },
                { name: 'envBloomThreshold', label: 'Environment Threshold', value: 0.1, min: 0, max: 1, step: 0.1 }
            ]
        });

        // Physics Simulation Controls
        const physicsControls = reactive({
            simulation: [
                { name: 'forceDirectedIterations', label: 'Iterations', value: 300, min: 100, max: 500, step: 10 },
                { name: 'forceDirectedSpring', label: 'Spring Strength', value: 0.015, min: 0.001, max: 0.1, step: 0.001 },
                { name: 'forceDirectedRepulsion', label: 'Repulsion', value: 1200, min: 100, max: 5000, step: 100 },
                { name: 'forceDirectedAttraction', label: 'Attraction', value: 0.012, min: 0.001, max: 0.1, step: 0.001 },
                { name: 'forceDirectedDamping', label: 'Damping', value: 0.85, min: 0.1, max: 0.99, step: 0.01 }
            ],
            geometry: [
                { name: 'geometryMinSegments', label: 'Min Segments', value: 24, min: 8, max: 32, step: 4 },
                { name: 'geometryMaxSegments', label: 'Max Segments', value: 48, min: 24, max: 64, step: 4 },
                { name: 'geometrySegmentPerLink', label: 'Segments per Link', value: 0.6, min: 0.2, max: 1, step: 0.1 }
            ]
        });

        // Fisheye Controls
        const fisheyeEnabled = ref(false);
        const fisheyeControls = reactive({
            properties: [
                { name: 'fisheyeStrength', label: 'Strength', value: 0.5, min: 0, max: 1, step: 0.1 },
                { name: 'fisheyeRadius', label: 'Radius', value: 100, min: 10, max: 200, step: 10 }
            ],
            focus: [
                { name: 'fisheyeFocusX', label: 'Focus X', value: 0, min: -100, max: 100, step: 1 },
                { name: 'fisheyeFocusY', label: 'Focus Y', value: 0, min: -100, max: 100, step: 1 },
                { name: 'fisheyeFocusZ', label: 'Focus Z', value: 0, min: -100, max: 100, step: 1 }
            ]
        });

        // Environment Controls
        const environmentControls = reactive({
            hologram: [
                { name: 'hologramColor', label: 'Hologram Color', value: '#FFC125' },
                { name: 'hologramScale', label: 'Scale', value: 6.0, min: 1, max: 10, step: 0.5 },
                { name: 'hologramOpacity', label: 'Opacity', value: 0.15, min: 0, max: 1, step: 0.05 }
            ],
            fog: [
                { name: 'fogDensity', label: 'Fog Density', value: 0.001, min: 0, max: 0.01, step: 0.001 }
            ]
        });

        // Simulation mode
        const simulationMode = ref('remote');

        // Methods
        const togglePanel = () => {
            isHidden.value = !isHidden.value;
        };

        const toggleGroup = (group) => {
            collapsedGroups[group] = !collapsedGroups[group];
        };

        const emitChange = (name, value) => {
            console.log('Emitting control change:', name, value);
            emit('control-change', { name, value });
        };

        const saveSettings = () => {
            // Collect all settings into TOML structure
            const settings = {
                visualization: {
                    // Node colors
                    node_color: nodeAppearanceControls.colors.find(c => c.name === 'nodeColor')?.value.replace('#', '0x'),
                    node_color_new: nodeAppearanceControls.colors.find(c => c.name === 'nodeColorNew')?.value.replace('#', '0x'),
                    node_color_recent: nodeAppearanceControls.colors.find(c => c.name === 'nodeColorRecent')?.value.replace('#', '0x'),
                    node_color_medium: nodeAppearanceControls.colors.find(c => c.name === 'nodeColorMedium')?.value.replace('#', '0x'),
                    node_color_old: nodeAppearanceControls.colors.find(c => c.name === 'nodeColorOld')?.value.replace('#', '0x'),
                    node_color_core: nodeAppearanceControls.colors.find(c => c.name === 'nodeColorCore')?.value.replace('#', '0x'),
                    node_color_secondary: nodeAppearanceControls.colors.find(c => c.name === 'nodeColorSecondary')?.value.replace('#', '0x'),

                    // Edge colors
                    edge_color: edgeAppearanceControls.colors.find(c => c.name === 'edgeColor')?.value.replace('#', '0x'),
                    
                    // Hologram
                    hologram_color: environmentControls.hologram.find(c => c.name === 'hologramColor')?.value.replace('#', '0x'),
                    hologram_scale: environmentControls.hologram.find(c => c.name === 'hologramScale')?.value,
                    hologram_opacity: environmentControls.hologram.find(c => c.name === 'hologramOpacity')?.value,

                    // Node dimensions
                    min_node_size: nodeAppearanceControls.size.find(c => c.name === 'minNodeSize')?.value / 100, // Convert cm to meters
                    max_node_size: nodeAppearanceControls.size.find(c => c.name === 'maxNodeSize')?.value / 100, // Convert cm to meters
                    
                    // Edge properties
                    edge_opacity: edgeAppearanceControls.properties.find(c => c.name === 'edgeOpacity')?.value,

                    // Material properties
                    node_material_metalness: nodeAppearanceControls.material.find(c => c.name === 'nodeMaterialMetalness')?.value,
                    node_material_roughness: nodeAppearanceControls.material.find(c => c.name === 'nodeMaterialRoughness')?.value,
                    node_material_clearcoat: nodeAppearanceControls.material.find(c => c.name === 'nodeMaterialClearcoat')?.value,
                    node_material_clearcoat_roughness: nodeAppearanceControls.material.find(c => c.name === 'nodeMaterialClearcoatRoughness')?.value,
                    node_material_opacity: nodeAppearanceControls.material.find(c => c.name === 'nodeMaterialOpacity')?.value,
                    
                    // Emissive properties
                    node_emissive_min_intensity: nodeAppearanceControls.emissive.find(c => c.name === 'nodeEmissiveMin')?.value,
                    node_emissive_max_intensity: nodeAppearanceControls.emissive.find(c => c.name === 'nodeEmissiveMax')?.value,

                    // Geometry properties
                    geometry_min_segments: physicsControls.geometry.find(c => c.name === 'geometryMinSegments')?.value,
                    geometry_max_segments: physicsControls.geometry.find(c => c.name === 'geometryMaxSegments')?.value,
                    geometry_segment_per_hyperlink: physicsControls.geometry.find(c => c.name === 'geometrySegmentPerLink')?.value,

                    // Physics simulation parameters
                    force_directed_iterations: physicsControls.simulation.find(c => c.name === 'forceDirectedIterations')?.value,
                    force_directed_spring: physicsControls.simulation.find(c => c.name === 'forceDirectedSpring')?.value,
                    force_directed_repulsion: physicsControls.simulation.find(c => c.name === 'forceDirectedRepulsion')?.value,
                    force_directed_attraction: physicsControls.simulation.find(c => c.name === 'forceDirectedAttraction')?.value,
                    force_directed_damping: physicsControls.simulation.find(c => c.name === 'forceDirectedDamping')?.value,

                    // Environment
                    fog_density: environmentControls.fog.find(c => c.name === 'fogDensity')?.value,
                },
                bloom: {
                    // Node bloom
                    node_bloom_strength: bloomControls.node.find(c => c.name === 'nodeBloomStrength')?.value,
                    node_bloom_radius: bloomControls.node.find(c => c.name === 'nodeBloomRadius')?.value,
                    node_bloom_threshold: bloomControls.node.find(c => c.name === 'nodeBloomThreshold')?.value,
                    
                    // Edge bloom
                    edge_bloom_strength: bloomControls.edge.find(c => c.name === 'edgeBloomStrength')?.value,
                    edge_bloom_radius: bloomControls.edge.find(c => c.name === 'edgeBloomRadius')?.value,
                    edge_bloom_threshold: bloomControls.edge.find(c => c.name === 'edgeBloomThreshold')?.value,
                    
                    // Environment bloom
                    environment_bloom_strength: bloomControls.environment.find(c => c.name === 'envBloomStrength')?.value,
                    environment_bloom_radius: bloomControls.environment.find(c => c.name === 'envBloomRadius')?.value,
                    environment_bloom_threshold: bloomControls.environment.find(c => c.name === 'envBloomThreshold')?.value
                },
                fisheye: {
                    enabled: fisheyeEnabled.value,
                    strength: fisheyeControls.properties.find(c => c.name === 'fisheyeStrength')?.value,
                    radius: fisheyeControls.properties.find(c => c.name === 'fisheyeRadius')?.value,
                    focus_x: fisheyeControls.focus.find(c => c.name === 'fisheyeFocusX')?.value,
                    focus_y: fisheyeControls.focus.find(c => c.name === 'fisheyeFocusY')?.value,
                    focus_z: fisheyeControls.focus.find(c => c.name === 'fisheyeFocusZ')?.value
                }
            };

            // Send settings to backend through websocket
            props.websocketService.send({
                type: 'updateSettings',
                settings
            });
        };

        // Return all reactive state and methods
        return {
            isHidden,
            collapsedGroups,
            nodeAppearanceControls,
            edgeAppearanceControls,
            bloomControls,
            physicsControls,
            fisheyeEnabled,
            fisheyeControls,
            environmentControls,
            simulationMode,
            togglePanel,
            toggleGroup,
            emitChange,
            saveSettings
        };
    }
});
</script>

<template>
    <div id="control-panel" :class="{ hidden: isHidden }">
        <button @click="togglePanel" class="toggle-button">
            {{ isHidden ? '>' : '<' }}
        </button>
        <div class="panel-content" v-show="!isHidden">
            <!-- Node Appearance -->
            <div class="control-group">
                <div class="group-header" @click="toggleGroup('nodeAppearance')">
                    <h3>Node Appearance</h3>
                    <span class="collapse-icon">{{ collapsedGroups.nodeAppearance ? '▼' : '▲' }}</span>
                </div>
                <div class="group-content" v-show="!collapsedGroups.nodeAppearance">
                    <h4>Colors</h4>
                    <div v-for="control in nodeAppearanceControls.colors" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="color"
                            v-model="control.value"
                            @input="emitChange(control.name, control.value)"
                        >
                    </div>

                    <h4>Size</h4>
                    <div v-for="control in nodeAppearanceControls.size" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>

                    <h4>Material</h4>
                    <div v-for="control in nodeAppearanceControls.material" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>

                    <h4>Emissive</h4>
                    <div v-for="control in nodeAppearanceControls.emissive" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>
                </div>
            </div>

            <!-- Edge Appearance -->
            <div class="control-group">
                <div class="group-header" @click="toggleGroup('edgeAppearance')">
                    <h3>Edge Appearance</h3>
                    <span class="collapse-icon">{{ collapsedGroups.edgeAppearance ? '▼' : '▲' }}</span>
                </div>
                <div class="group-content" v-show="!collapsedGroups.edgeAppearance">
                    <h4>Colors</h4>
                    <div v-for="control in edgeAppearanceControls.colors" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="color"
                            v-model="control.value"
                            @input="emitChange(control.name, control.value)"
                        >
                    </div>

                    <h4>Properties</h4>
                    <div v-for="control in edgeAppearanceControls.properties" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>
                </div>
            </div>

            <!-- Bloom Effects -->
            <div class="control-group">
                <div class="group-header" @click="toggleGroup('bloom')">
                    <h3>Bloom Effects</h3>
                    <span class="collapse-icon">{{ collapsedGroups.bloom ? '▼' : '▲' }}</span>
                </div>
                <div class="group-content" v-show="!collapsedGroups.bloom">
                    <h4>Node Bloom</h4>
                    <div v-for="control in bloomControls.node" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>

                    <h4>Edge Bloom</h4>
                    <div v-for="control in bloomControls.edge" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>

                    <h4>Environment Bloom</h4>
                    <div v-for="control in bloomControls.environment" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>
                </div>
            </div>

            <!-- Physics Simulation -->
            <div class="control-group">
                <div class="group-header" @click="toggleGroup('physics')">
                    <h3>Physics Simulation</h3>
                    <span class="collapse-icon">{{ collapsedGroups.physics ? '▼' : '▲' }}</span>
                </div>
                <div class="group-content" v-show="!collapsedGroups.physics">
                    <div class="control-item">
                        <label>Simulation Mode</label>
                        <select v-model="simulationMode" @change="emitChange('simulationMode', simulationMode)">
                            <option value="remote">Remote (GPU Server)</option>
                            <option value="gpu">Local GPU</option>
                            <option value="local">Local CPU</option>
                        </select>
                    </div>

                    <h4>Force Parameters</h4>
                    <div v-for="control in physicsControls.simulation" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>

                    <h4>Geometry</h4>
                    <div v-for="control in physicsControls.geometry" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>
                </div>
            </div>

            <!-- Fisheye Controls -->
            <div class="control-group">
                <div class="group-header" @click="toggleGroup('fisheye')">
                    <h3>Fisheye Effect</h3>
                    <span class="collapse-icon">{{ collapsedGroups.fisheye ? '▼' : '▲' }}</span>
                </div>
                <div class="group-content" v-show="!collapsedGroups.fisheye">
                    <div class="control-item">
                        <label>Enable Fisheye</label>
                        <div class="toggle-switch">
                            <input
                                type="checkbox"
                                v-model="fisheyeEnabled"
                                @change="emitChange('fisheyeEnabled', fisheyeEnabled)"
                            >
                            <span class="toggle-label">{{ fisheyeEnabled ? 'Enabled' : 'Disabled' }}</span>
                        </div>
                    </div>

                    <h4>Properties</h4>
                    <div v-for="control in fisheyeControls.properties" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>

                    <h4>Focus Point</h4>
                    <div v-for="control in fisheyeControls.focus" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>
                </div>
            </div>

            <!-- Environment Settings -->
            <div class="control-group">
                <div class="group-header" @click="toggleGroup('environment')">
                    <h3>Environment</h3>
                    <span class="collapse-icon">{{ collapsedGroups.environment ? '▼' : '▲' }}</span>
                </div>
                <div class="group-content" v-show="!collapsedGroups.environment">
                    <h4>Hologram</h4>
                    <div v-for="control in environmentControls.hologram" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <template v-if="control.name === 'hologramColor'">
                            <input
                                type="color"
                                v-model="control.value"
                                @input="emitChange(control.name, control.value)"
                            >
                        </template>
                        <template v-else>
                            <input
                                type="range"
                                v-model.number="control.value"
                                :min="control.min"
                                :max="control.max"
                                :step="control.step"
                                @input="emitChange(control.name, control.value)"
                            >
                            <span class="range-value">{{ control.value }}</span>
                        </template>
                    </div>

                    <h4>Fog</h4>
                    <div v-for="control in environmentControls.fog" :key="control.name" class="control-item">
                        <label>{{ control.label }}</label>
                        <input
                            type="range"
                            v-model.number="control.value"
                            :min="control.min"
                            :max="control.max"
                            :step="control.step"
                            @input="emitChange(control.name, control.value)"
                        >
                        <span class="range-value">{{ control.value }}</span>
                    </div>
                </div>
            </div>

            <!-- Settings Actions -->
            <div class="settings-actions">
                <button @click="saveSettings" class="save-button">Save Settings to File</button>
            </div>
        </div>
    </div>
</template>

<style scoped>
#control-panel {
    position: fixed;
    top: 20px;
    right: 0;
    width: 300px;
    max-height: 90vh;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    border-radius: 10px 0 0 10px;
    overflow-y: auto;
    z-index: 1000;
    transition: transform 0.3s ease-in-out;
    display: block !important;
    visibility: visible !important;
}

#control-panel.hidden {
    transform: translateX(calc(100% - 40px));
}

.toggle-button {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    border: none;
    padding: 10px;
    cursor: pointer;
    border-radius: 5px 0 0 5px;
    z-index: 1001;
    display: block !important;
    visibility: visible !important;
}

.panel-content {
    padding: 20px 20px 20px 40px;
    height: 100%;
    overflow-y: auto;
}

.control-group {
    margin-bottom: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    overflow: hidden;
}

.group-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background-color: rgba(255, 255, 255, 0.1);
    cursor: pointer;
}

.group-header h3 {
    margin: 0;
    font-size: 1em;
}

.group-content {
    padding: 10px;
}

.control-item {
    margin-bottom: 15px;
}

.control-item label {
    display: block;
    margin-bottom: 5px;
}

.control-item input[type="range"] {
    width: 100%;
    margin-bottom: 5px;
}

.control-item input[type="color"] {
    width: 100%;
    height: 30px;
    padding: 0;
    border: none;
    border-radius: 4px;
}

.range-value {
    float: right;
    font-size: 0.9em;
    color: #aaa;
}

.button-group {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.control-button {
    flex: 1;
    padding: 8px;
    background-color: #444;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.control-button:hover {
    background-color: #555;
}

.reset-button {
    width: 100%;
    padding: 10px;
    background-color: #d32f2f;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 10px;
}

.reset-button:hover {
    background-color: #b71c1c;
}

.chat-messages {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 10px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}

.message {
    margin-bottom: 10px;
    padding: 8px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
}

.save-button {
    width: 100%;
    padding: 12px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.1em;
    transition: background-color 0.2s;
}

.save-button:hover {
    background-color: #45a049;
}

/* Previous styles remain the same */
</style>

----
components/interface.js
// public/js/components/interface.js

/**
 * Interface class manages UI elements like error messages and information panels.
 */
export class Interface {
  /**
   * Creates a new Interface instance.
   * @param {Document} document - The DOM document.
   */
  constructor(document) {
      this.document = document;
      this.createUI();
      this.setupEventListeners();
  }

  /**
   * Creates necessary UI elements and appends them to the DOM.
   */
  createUI() {
      // Create Node Information Panel
      this.createNodeInfoPanel();
  }

  /**
   * Creates a panel to display information about selected nodes.
   */
  createNodeInfoPanel() {
      const infoPanel = this.document.createElement('div');
      infoPanel.id = 'node-info-panel';
      infoPanel.style.position = 'absolute';
      infoPanel.style.top = '20px';
      infoPanel.style.left = '20px';
      infoPanel.style.width = '300px';
      infoPanel.style.maxHeight = '40vh';
      infoPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      infoPanel.style.color = 'white';
      infoPanel.style.padding = '15px';
      infoPanel.style.borderRadius = '8px';
      infoPanel.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
      infoPanel.style.overflowY = 'auto';
      infoPanel.style.display = 'none'; // Hidden by default
      this.document.body.appendChild(infoPanel);

      this.nodeInfoPanel = infoPanel;
  }

  /**
   * Sets up event listeners for custom events.
   */
  setupEventListeners() {
      // Listen for node selection events
      window.addEventListener('nodeSelected', (event) => {
          const nodeInfo = event.detail;
          this.updateNodeInfoPanel(nodeInfo);
      });
  }

  /**
   * Displays an error message on the screen.
   * @param {string} message - The error message to display.
   */
  displayErrorMessage(message) {
      const errorContainer = this.document.createElement('div');
      errorContainer.style.position = 'fixed';
      errorContainer.style.top = '50%';
      errorContainer.style.left = '50%';
      errorContainer.style.transform = 'translate(-50%, -50%)';
      errorContainer.style.backgroundColor = 'rgba(255, 0, 0, 0.85)';
      errorContainer.style.color = 'white';
      errorContainer.style.padding = '20px';
      errorContainer.style.borderRadius = '8px';
      errorContainer.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.3)';
      errorContainer.style.zIndex = '1000';
      errorContainer.textContent = message;

      this.document.body.appendChild(errorContainer);

      // Remove the error message after 5 seconds
      setTimeout(() => {
          if (this.document.body.contains(errorContainer)) {
              this.document.body.removeChild(errorContainer);
          }
      }, 5000);
  }

  /**
   * Updates the Node Information Panel with details of the selected node.
   * @param {object} node - The node object containing its details.
   */
  updateNodeInfoPanel(node) {
      if (!node) {
          this.nodeInfoPanel.style.display = 'none';
          return;
      }

      this.nodeInfoPanel.innerHTML = `
          <h3>Node Information</h3>
          <p><strong>ID:</strong> ${node.id}</p>
          <p><strong>Name:</strong> ${node.name}</p>
          <!-- Add more node properties as needed -->
      `;
      this.nodeInfoPanel.style.display = 'block';
  }
}

----
components/chatManager.vue
<script>
import { defineComponent, ref, onUpdated, onBeforeUnmount } from 'vue';

export default defineComponent({
    name: 'ChatManager',
    props: {
        websocketService: {
            type: Object,
            required: true
        }
    },
    data() {
        return {
            chatInput: '',
            chatMessages: [],
            useOpenAI: false
        };
    },
    methods: {
        sendMessage() {
            if (this.chatInput.trim()) {
                this.websocketService.sendChatMessage({
                    message: this.chatInput,
                    useOpenAI: this.useOpenAI
                });
                this.chatMessages.push({ sender: 'You', message: this.chatInput });
                this.chatInput = '';
            }
        },
        toggleTTS() {
            this.websocketService.toggleTTS(this.useOpenAI);
            console.log(`TTS method set to: ${this.useOpenAI ? 'OpenAI' : 'Sonata'}`);
        },
        handleRagflowAnswer(answer) {
            if (!this.useOpenAI && typeof answer === 'string') {
                this.chatMessages.push({ sender: 'AI', message: answer });
            }
        },
        handleOpenAIResponse(response) {
            // Only show text responses when not using OpenAI TTS
            if (!this.useOpenAI && typeof response === 'string') {
                this.chatMessages.push({ sender: 'AI', message: response });
            }
        }
    },
    mounted() {
        if (this.websocketService) {
            this.websocketService.on('ragflowAnswer', this.handleRagflowAnswer);
            this.websocketService.on('openaiResponse', this.handleOpenAIResponse);
        } else {
            console.error('WebSocketService is undefined');
        }
    },
    beforeUnmount() {
        if (this.websocketService) {
            this.websocketService.off('ragflowAnswer', this.handleRagflowAnswer);
            this.websocketService.off('openaiResponse', this.handleOpenAIResponse);
        }
    },
    setup() {
        const chatMessagesRef = ref(null);

        const scrollToBottom = () => {
            if (chatMessagesRef.value) {
                chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight;
            }
        };

        onUpdated(() => {
            scrollToBottom();
        });

        return {
            chatMessagesRef
        };
    }
});
</script>

<template>
    <div class="chat-container">
        <div class="chat-messages" ref="chatMessagesRef" :class="{ 'hide-messages': useOpenAI }">
            <div v-for="(msg, index) in chatMessages" :key="index" class="message">
                <strong>{{ msg.sender }}:</strong> {{ msg.message }}
            </div>
        </div>
        <div class="chat-input">
            <label class="tts-toggle">
                <input type="checkbox" v-model="useOpenAI" @change="toggleTTS">
                Use OpenAI TTS
            </label>
            <input 
                v-model="chatInput" 
                @keyup.enter="sendMessage" 
                placeholder="Type your message..."
            >
            <button @click="sendMessage">Send</button>
        </div>
    </div>
</template>

<style scoped>
.chat-container {
    display: flex;
    flex-direction: column;
    height: 400px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin: 10px;
}

.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    background: #f9f9f9;
    transition: height 0.3s ease;
}

.chat-messages.hide-messages {
    height: 0;
    padding: 0;
    overflow: hidden;
}

.message {
    margin: 5px 0;
    padding: 5px;
    border-radius: 4px;
    background: white;
}

.chat-input {
    display: flex;
    padding: 10px;
    background: white;
    border-top: 1px solid #ccc;
    align-items: center;
}

.chat-input input {
    flex-grow: 1;
    margin: 0 10px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.chat-input button {
    padding: 5px 15px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.chat-input button:hover {
    background: #0056b3;
}

.tts-toggle {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9em;
}
</style>

----
components/visualization/effects.js
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { BLOOM_LAYER, NORMAL_LAYER } from './nodes.js';

export class EffectsManager {
    constructor(scene, camera, renderer, settings = {}) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        this.bloomComposer = null;
        this.finalComposer = null;
        
        // Bloom settings with defaults
        this.bloomStrength = settings.bloomStrength || 1.5;
        this.bloomRadius = settings.bloomRadius || 0.4;
        this.bloomThreshold = settings.bloomThreshold || 0.8;

        // Hologram settings with defaults
        this.hologramGroup = new THREE.Group();
        this.scene.add(this.hologramGroup);
        this.hologramColor = new THREE.Color(settings.hologramColor || 0xFFD700);
        this.hologramScale = settings.hologramScale || 1;
        this.hologramOpacity = settings.hologramOpacity || 0.1;

        // Fisheye settings with defaults
        this.fisheyeEnabled = false;
        this.fisheyeStrength = 0.5;
        this.fisheyeRadius = 100.0;
        this.fisheyeFocusPoint = [0, 0, 0];
    }

    initPostProcessing() {
        // Create render targets
        const renderTarget = new THREE.WebGLRenderTarget(
            window.innerWidth,
            window.innerHeight,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                colorSpace: THREE.SRGBColorSpace
            }
        );

        // Setup bloom composer with settings
        this.bloomComposer = new EffectComposer(this.renderer, renderTarget);
        this.bloomComposer.renderToScreen = false;
        
        const renderScene = new RenderPass(this.scene, this.camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            this.bloomStrength,
            this.bloomRadius,
            this.bloomThreshold
        );

        this.bloomComposer.addPass(renderScene);
        this.bloomComposer.addPass(bloomPass);

        // Setup final composer
        this.finalComposer = new EffectComposer(this.renderer);
        this.finalComposer.addPass(renderScene);

        // Add custom shader pass to combine bloom with scene
        const finalPass = new ShaderPass(
            new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: this.bloomComposer.renderTarget2.texture }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D baseTexture;
                    uniform sampler2D bloomTexture;
                    varying vec2 vUv;
                    void main() {
                        vec4 baseColor = texture2D(baseTexture, vUv);
                        vec4 bloomColor = texture2D(bloomTexture, vUv);
                        gl_FragColor = baseColor + vec4(1.0) * bloomColor;
                    }
                `,
                defines: {}
            }),
            "baseTexture"
        );
        finalPass.needsSwap = true;
        this.finalComposer.addPass(finalPass);
    }

    createHologramStructure() {
        // Clear existing hologram structure
        while (this.hologramGroup.children.length > 0) {
            const child = this.hologramGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            this.hologramGroup.remove(child);
        }

        // Create multiple rings with different sizes to match each sphere's radius
        const ringSizes = [40, 30, 20];
        for (let i = 0; i < 3; i++) {
            const ringGeometry = new THREE.TorusGeometry(ringSizes[i], 3, 16, 100);
            const ringMaterial = new THREE.MeshStandardMaterial({
                color: this.hologramColor,
                emissive: this.hologramColor,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: this.hologramOpacity,
                metalness: 0.8,
                roughness: 0.2
            });

            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2 * i;
            ring.rotation.y = Math.PI / 4 * i;
            ring.userData.rotationSpeed = 0.002 * (i + 1);
            this.hologramGroup.add(ring);
        }

        // Add Buckminster Fullerene 
        const buckyGeometry = new THREE.IcosahedronGeometry(40 * this.hologramScale, 1);
        const buckyMaterial = new THREE.MeshBasicMaterial({
            color: this.hologramColor,
            wireframe: true,
            transparent: true,
            opacity: this.hologramOpacity
        });
        const buckySphere = new THREE.Mesh(buckyGeometry, buckyMaterial);
        buckySphere.userData.rotationSpeed = 0.0001;
        buckySphere.layers.enable(1);
        this.hologramGroup.add(buckySphere);

        // Add Geodesic Dome
        const geodesicGeometry = new THREE.IcosahedronGeometry(30 * this.hologramScale, 1);
        const geodesicMaterial = new THREE.MeshBasicMaterial({
            color: this.hologramColor,
            wireframe: true,
            transparent: true,
            opacity: this.hologramOpacity
        });
        const geodesicDome = new THREE.Mesh(geodesicGeometry, geodesicMaterial);
        geodesicDome.userData.rotationSpeed = 0.0002;
        geodesicDome.layers.enable(1);
        this.hologramGroup.add(geodesicDome);

        // Add Normal Triangle Sphere
        const triangleGeometry = new THREE.SphereGeometry(20 * this.hologramScale, 32, 32);
        const triangleMaterial = new THREE.MeshBasicMaterial({
            color: this.hologramColor,
            wireframe: true,
            transparent: true,
            opacity: this.hologramOpacity
        });
        const triangleSphere = new THREE.Mesh(triangleGeometry, triangleMaterial);
        triangleSphere.userData.rotationSpeed = 0.0003;
        triangleSphere.layers.enable(1);
        this.hologramGroup.add(triangleSphere);
    }

    animate() {
        // Animate all hologram elements
        this.hologramGroup.children.forEach(child => {
            child.rotation.x += child.userData.rotationSpeed;
            child.rotation.y += child.userData.rotationSpeed;
        });
    }

    render() {
        // Render with bloom effect
        this.camera.layers.set(BLOOM_LAYER);
        this.bloomComposer.render();
        
        this.camera.layers.set(NORMAL_LAYER);
        this.finalComposer.render();
    }

    handleResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        if (this.bloomComposer) this.bloomComposer.setSize(width, height);
        if (this.finalComposer) this.finalComposer.setSize(width, height);
    }

    updateFeature(control, value) {
        console.log(`Updating effect feature: ${control} = ${value}`);
        switch (control) {
            // Bloom features
            case 'bloomStrength':
                this.bloomStrength = value;
                if (this.bloomComposer) {
                    this.bloomComposer.passes.forEach(pass => {
                        if (pass instanceof UnrealBloomPass) {
                            pass.strength = value;
                        }
                    });
                }
                break;
            case 'bloomRadius':
                this.bloomRadius = value;
                if (this.bloomComposer) {
                    this.bloomComposer.passes.forEach(pass => {
                        if (pass instanceof UnrealBloomPass) {
                            pass.radius = value;
                        }
                    });
                }
                break;
            case 'bloomThreshold':
                this.bloomThreshold = value;
                if (this.bloomComposer) {
                    this.bloomComposer.passes.forEach(pass => {
                        if (pass instanceof UnrealBloomPass) {
                            pass.threshold = value;
                        }
                    });
                }
                break;

            // Hologram features
            case 'hologramColor':
                if (typeof value === 'number' || typeof value === 'string') {
                    this.hologramColor = new THREE.Color(value);
                    this.hologramGroup.children.forEach(child => {
                        if (child.material) {
                            child.material.color.copy(this.hologramColor);
                            if (child.material.emissive) {
                                child.material.emissive.copy(this.hologramColor);
                            }
                        }
                    });
                }
                break;
            case 'hologramScale':
                this.hologramScale = value;
                this.hologramGroup.scale.setScalar(value);
                break;
            case 'hologramOpacity':
                this.hologramOpacity = value;
                this.hologramGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = value;
                    }
                });
                break;
        }
    }

    updateBloom(settings) {
        console.log('Updating bloom settings:', settings);
        if (!this.bloomComposer) return;

        this.bloomComposer.passes.forEach(pass => {
            if (pass instanceof UnrealBloomPass) {
                if (settings.nodeBloomStrength !== undefined) {
                    pass.strength = settings.nodeBloomStrength;
                }
                if (settings.nodeBloomRadius !== undefined) {
                    pass.radius = settings.nodeBloomRadius;
                }
                if (settings.nodeBloomThreshold !== undefined) {
                    pass.threshold = settings.nodeBloomThreshold;
                }
            }
        });

        // Store the updated values
        this.bloomStrength = settings.nodeBloomStrength ?? this.bloomStrength;
        this.bloomRadius = settings.nodeBloomRadius ?? this.bloomRadius;
        this.bloomThreshold = settings.nodeBloomThreshold ?? this.bloomThreshold;
    }

    updateFisheye(settings) {
        console.log('Updating fisheye settings:', settings);
        this.fisheyeEnabled = settings.enabled;
        this.fisheyeStrength = settings.strength;
        this.fisheyeRadius = settings.radius;
        this.fisheyeFocusPoint = settings.focusPoint;

        // Apply fisheye effect if enabled
        if (this.fisheyeEnabled) {
            // TODO: Implement fisheye distortion shader
            console.log('Fisheye effect enabled:', {
                strength: this.fisheyeStrength,
                radius: this.fisheyeRadius,
                focusPoint: this.fisheyeFocusPoint
            });
        }
    }

    dispose() {
        // Dispose bloom resources
        if (this.bloomComposer) {
            this.bloomComposer.renderTarget1.dispose();
            this.bloomComposer.renderTarget2.dispose();
        }
        if (this.finalComposer) {
            this.finalComposer.renderTarget1.dispose();
            this.finalComposer.renderTarget2.dispose();
        }

        // Dispose hologram resources
        this.hologramGroup.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
}

----
components/visualization/layout.js
export class LayoutManager {
    constructor(settings = {}) {
        // Configuration
        this.initialIterations = settings.iterations || 250;
        this.updateIterations = 1;       // Single iteration for smooth continuous updates
        this.targetRadius = 200;
        this.naturalLength = 100;
        this.attraction = settings.attraction_strength || 0.01;
        this.repulsion = settings.repulsion_strength || 1000;
        this.spring = settings.spring_strength || 0.1;
        this.damping = settings.damping || 0.8;
        
        // State
        this.isInitialized = false;
        this.isSimulating = false;
        this.animationFrameId = null;
        this.lastPositions = null;       // Store previous positions for change detection
        this.updateThreshold = 0.001;    // Minimum position change to trigger update
        this.lastUpdateTime = 0;         // Last time positions were sent to server
        this.updateInterval = 16.67;     // Exactly 60fps
        this.positionBuffer = null;
        this.edges = [];                 // Store computed edges
        this.nodeCount = 0;              // Track number of nodes
        this.waitingForInitialData = true; // Wait for initial data before sending updates
    }

    initializePositions(nodes) {
        console.log('Initializing positions for nodes:', nodes);
        this.nodeCount = nodes.length;
        nodes.forEach(node => {
            // Initialize only if positions are invalid
            if (isNaN(node.x) || isNaN(node.y) || isNaN(node.z)) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = this.targetRadius * Math.cbrt(Math.random());
                
                node.x = r * Math.sin(phi) * Math.cos(theta);
                node.y = r * Math.sin(phi) * Math.sin(theta);
                node.z = r * Math.cos(phi);
            }
            // Always ensure velocities are initialized
            if (!node.vx) node.vx = 0;
            if (!node.vy) node.vy = 0;
            if (!node.vz) node.vz = 0;
        });

        // Initialize last positions with velocities
        this.lastPositions = nodes.map(node => ({
            x: node.x,
            y: node.y,
            z: node.z,
            vx: node.vx,
            vy: node.vy,
            vz: node.vz
        }));

        this.isInitialized = true;
        this.waitingForInitialData = false; // Initial data received
        console.log('Position initialization complete');

        // Send initial positions to server
        this.sendPositionUpdates(nodes, true);
    }

    applyForceDirectedLayout(nodes, edges) {
        if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
            console.warn('Invalid nodes array provided to force-directed layout');
            return;
        }

        if (!this.isInitialized || this.waitingForInitialData) {
            console.warn('Layout manager not initialized or waiting for initial data');
            return;
        }

        console.log('Applying force-directed layout to', nodes.length, 'nodes');
        const dt = 0.1;

        // Apply forces based on edges (topic counts)
        edges.forEach(edge => {
            const sourceNode = nodes.find(n => n.id === edge.source);
            const targetNode = nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                // Calculate spring force based on topic counts
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dz = targetNode.z - sourceNode.z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) return;

                // Use edge weight (from topic counts) to scale the force
                const force = (distance - this.naturalLength) * this.spring * (edge.weight || 1);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                // Apply forces to both nodes
                sourceNode.vx += fx * this.attraction;
                sourceNode.vy += fy * this.attraction;
                sourceNode.vz += fz * this.attraction;
                targetNode.vx -= fx * this.attraction;
                targetNode.vy -= fy * this.attraction;
                targetNode.vz -= fz * this.attraction;
            }
        });

        // Apply repulsion between all nodes
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dz = nodes[j].z - nodes[i].z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) continue;

                const force = this.repulsion / (distance * distance);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                nodes[i].vx -= fx;
                nodes[i].vy -= fy;
                nodes[i].vz -= fz;
                nodes[j].vx += fx;
                nodes[j].vy += fy;
                nodes[j].vz += fz;
            }
        }

        // Update positions and apply damping
        nodes.forEach(node => {
            // Apply current velocity
            node.x += node.vx * dt;
            node.y += node.vy * dt;
            node.z += node.vz * dt;

            // Apply damping
            node.vx *= this.damping;
            node.vy *= this.damping;
            node.vz *= this.damping;

            // Bound checking
            const bound = 500;
            if (Math.abs(node.x) > bound) node.vx *= -0.5;
            if (Math.abs(node.y) > bound) node.vy *= -0.5;
            if (Math.abs(node.z) > bound) node.vz *= -0.5;
        });
    }

    updateFeature(control, value) {
        console.log(`Updating layout feature: ${control} = ${value}`);
        
        // Convert from forceDirected prefixed names to internal parameter names
        const paramMap = {
            'forceDirectedIterations': 'iterations',
            'forceDirectedSpring': 'spring_strength',
            'forceDirectedRepulsion': 'repulsion_strength',
            'forceDirectedAttraction': 'attraction_strength',
            'forceDirectedDamping': 'damping'
        };

        const paramName = paramMap[control] || control;
        switch(paramName) {
            case 'iterations':
                this.initialIterations = value;
                break;
            case 'spring_strength':
                this.spring = value;
                break;
            case 'repulsion_strength':
                this.repulsion = value;
                break;
            case 'attraction_strength':
                this.attraction = value;
                break;
            case 'damping':
                this.damping = value;
                break;
            default:
                console.warn(`Unknown layout parameter: ${control}`);
        }
    }

    updatePhysics(settings) {
        console.log('Updating physics settings:', settings);
        
        // Update all physics parameters at once
        if (settings.iterations !== undefined) {
            this.initialIterations = settings.iterations;
        }
        if (settings.spring_strength !== undefined) {
            this.spring = settings.spring_strength;
        }
        if (settings.repulsion_strength !== undefined) {
            this.repulsion = settings.repulsion_strength;
        }
        if (settings.attraction_strength !== undefined) {
            this.attraction = settings.attraction_strength;
        }
        if (settings.damping !== undefined) {
            this.damping = settings.damping;
        }

        // If simulation is running, apply new settings immediately
        if (this.isSimulating) {
            console.log('Applying new physics settings to running simulation');
        }
    }

    performLayout(graphData) {
        if (!this.isInitialized || !graphData || this.waitingForInitialData) {
            console.warn('Cannot perform layout: not initialized, no graph data, or waiting for initial data');
            return;
        }

        const now = Date.now();
        if (now - this.lastUpdateTime >= this.updateInterval) {
            // Apply force-directed layout
            this.applyForceDirectedLayout(graphData.nodes, graphData.edges);
            
            // Send position updates
            this.sendPositionUpdates(graphData.nodes, false);
            this.lastUpdateTime = now;
        }
    }

    sendPositionUpdates(nodes, isInitialLayout = false) {
        if (!this.lastPositions || !this.isInitialized || nodes.length !== this.nodeCount || this.waitingForInitialData) {
            console.warn('Cannot send position updates: not initialized, node count mismatch, or waiting for initial data');
            return;
        }

        // Create binary buffer for all node positions and velocities (24 bytes per node)
        const buffer = new ArrayBuffer(nodes.length * 24 + 4); // Extra 4 bytes for is_initial_layout flag
        const dataView = new Float32Array(buffer);
        let hasChanges = false;

        // Set is_initial_layout flag (1.0 for true, 0.0 for false)
        dataView[0] = isInitialLayout ? 1.0 : 0.0;

        nodes.forEach((node, index) => {
            const offset = index * 6 + 1; // +1 to account for is_initial_layout flag
            const lastPos = this.lastPositions[index];

            if (!lastPos || 
                Math.abs(node.x - lastPos.x) > this.updateThreshold ||
                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
                Math.abs(node.z - lastPos.z) > this.updateThreshold ||
                Math.abs(node.vx - lastPos.vx) > this.updateThreshold ||
                Math.abs(node.vy - lastPos.vy) > this.updateThreshold ||
                Math.abs(node.vz - lastPos.vz) > this.updateThreshold) {
                
                hasChanges = true;
                
                // Update last position and velocity
                if (lastPos) {
                    lastPos.x = node.x;
                    lastPos.y = node.y;
                    lastPos.z = node.z;
                    lastPos.vx = node.vx;
                    lastPos.vy = node.vy;
                    lastPos.vz = node.vz;
                }

                // Position (vec3<f32>)
                dataView[offset] = node.x;
                dataView[offset + 1] = node.y;
                dataView[offset + 2] = node.z;

                // Velocity (vec3<f32>)
                dataView[offset + 3] = node.vx || 0;
                dataView[offset + 4] = node.vy || 0;
                dataView[offset + 5] = node.vz || 0;
            }
        });

        if (hasChanges || isInitialLayout) {
            // Log the buffer size before sending
            console.log(`Sending position update buffer of size: ${buffer.byteLength} bytes for ${nodes.length} nodes (isInitialLayout: ${isInitialLayout})`);
            
            // Dispatch binary data event
            window.dispatchEvent(new CustomEvent('positionUpdate', {
                detail: buffer
            }));
        }
    }

    startContinuousSimulation(graphData) {
        if (this.isSimulating) return;
        
        console.log('Starting continuous simulation');
        this.isSimulating = true;
        const animate = () => {
            if (!this.isSimulating) return;
            
            // Send position updates at regular intervals
            this.performLayout(graphData);
            this.animationFrameId = requestAnimationFrame(animate);
        };
        
        animate();
    }

    stopSimulation() {
        console.log('Stopping simulation');
        this.isSimulating = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
}

----
components/visualization/nodes.js
import * as THREE from 'three';
import { visualizationSettings } from '../../services/visualizationSettings.js';

// Constants
export const BLOOM_LAYER = 1;
export const NORMAL_LAYER = 0;

export class NodeManager {
    constructor(scene, camera, settings = {}) {
        this.scene = scene;
        this.camera = camera;
        this.nodeMeshes = new Map();
        this.nodeLabels = new Map();
        this.edgeMeshes = new Map();
        this.nodeData = new Map();
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        // Get settings from visualization settings service
        const nodeSettings = visualizationSettings.getNodeSettings();
        
        // Physical dimensions in meters
        this.minNodeSize = settings.minNodeSize || nodeSettings.minNodeSize; // 0.1m = 10cm
        this.maxNodeSize = settings.maxNodeSize || nodeSettings.maxNodeSize; // 0.3m = 30cm
        
        // Visual settings
        this.labelFontSize = settings.labelFontSize || nodeSettings.labelFontSize;
        this.nodeColor = new THREE.Color(settings.nodeColor || nodeSettings.color);
        this.materialSettings = nodeSettings.material;
        this.ageColors = {
            NEW: new THREE.Color(nodeSettings.colorNew),
            RECENT: new THREE.Color(nodeSettings.colorRecent),
            MEDIUM: new THREE.Color(nodeSettings.colorMedium),
            OLD: new THREE.Color(nodeSettings.colorOld)
        };
        this.maxAge = nodeSettings.ageMaxDays;

        // Edge settings
        const edgeSettings = visualizationSettings.getEdgeSettings();
        this.edgeColor = new THREE.Color(settings.edgeColor || edgeSettings.color);
        this.edgeOpacity = settings.edgeOpacity || edgeSettings.opacity;

        this.handleClick = this.handleClick.bind(this);
        this.xrEnabled = false;
        this.xrLabelManager = null;
    }

    getNodeSize(metadata) {
        // Calculate node size in meters based on metadata
        if (metadata.node_size) {
            const size = parseFloat(metadata.node_size);
            // Normalize size between minNodeSize (0.1m) and maxNodeSize (0.3m)
            return this.minNodeSize + (size * (this.maxNodeSize - this.minNodeSize));
        }
        return this.minNodeSize; // Default to minimum size (10cm)
    }

    calculateNodeColor(metadata) {
        // Use github_last_modified if available, otherwise fall back to last_modified
        const lastModified = metadata.github_last_modified || metadata.last_modified || new Date().toISOString();
        const now = Date.now();
        const age = now - new Date(lastModified).getTime();
        const dayInMs = 24 * 60 * 60 * 1000;
        
        if (age < 3 * dayInMs) return this.ageColors.NEW;        // Less than 3 days old
        if (age < 7 * dayInMs) return this.ageColors.RECENT;     // Less than 7 days old
        if (age < 30 * dayInMs) return this.ageColors.MEDIUM;    // Less than 30 days old
        return this.ageColors.OLD;                               // 30 days or older
    }

    createNodeGeometry(size, hyperlinkCount) {
        // Create a sphere with radius in meters
        // Scale segments based on hyperlink count for performance vs. quality
        const minSegments = visualizationSettings.getNodeSettings().geometryMinSegments;
        const maxSegments = visualizationSettings.getNodeSettings().geometryMaxSegments;
        const segmentPerLink = visualizationSettings.getNodeSettings().geometrySegmentPerHyperlink;
        
        const segments = Math.min(
            maxSegments,
            Math.max(minSegments, Math.floor(hyperlinkCount * segmentPerLink) + minSegments)
        );
        
        return new THREE.SphereGeometry(size, segments, segments);
    }

    createNodeMaterial(color, metadata) {
        // Use github_last_modified if available, otherwise fall back to last_modified
        const lastModified = metadata.github_last_modified || metadata.last_modified || new Date().toISOString();
        const now = Date.now();
        const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
        
        // Normalize age to 0-1 range and invert (newer = brighter)
        const normalizedAge = Math.min(ageInDays / this.maxAge, 1);
        const emissiveIntensity = this.materialSettings.emissiveMaxIntensity - 
            (normalizedAge * (this.materialSettings.emissiveMaxIntensity - this.materialSettings.emissiveMinIntensity));

        return new THREE.MeshPhysicalMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: emissiveIntensity,
            metalness: this.materialSettings.metalness,
            roughness: this.materialSettings.roughness,
            transparent: true,
            opacity: this.materialSettings.opacity,
            envMapIntensity: 1.0,
            clearcoat: this.materialSettings.clearcoat,
            clearcoatRoughness: this.materialSettings.clearcoatRoughness
        });
    }

    createNodeLabel(text, metadata) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = `${this.labelFontSize}px Arial`;
        
        // Get metadata values
        const fileSize = parseInt(metadata.file_size) || 1;
        const lastModified = metadata.github_last_modified || metadata.last_modified || new Date().toISOString();
        const hyperlinkCount = parseInt(metadata.hyperlink_count) || 0;
        const githubInfo = metadata.github_info || {};
        
        // Measure and create text
        const nameMetrics = context.measureText(text);
        let infoText = `${this.formatFileSize(fileSize)} | ${this.formatAge(lastModified)} | ${hyperlinkCount} links`;
        if (githubInfo.author) {
            infoText += ` | ${githubInfo.author}`;
        }
        if (githubInfo.commit_message) {
            const shortMessage = githubInfo.commit_message.split('\n')[0].slice(0, 30);
            infoText += ` | ${shortMessage}${githubInfo.commit_message.length > 30 ? '...' : ''}`;
        }
        
        const infoMetrics = context.measureText(infoText);
        const textWidth = Math.max(nameMetrics.width, infoMetrics.width);
        
        // Set canvas size
        canvas.width = textWidth + 20;
        canvas.height = this.labelFontSize * 2 + 30;

        // Draw background and text
        context.fillStyle = visualizationSettings.getLabelSettings().backgroundColor;
        context.fillRect(0, 0, canvas.width, canvas.height);

        context.font = `${this.labelFontSize}px ${visualizationSettings.getLabelSettings().fontFamily}`;
        context.fillStyle = visualizationSettings.getLabelSettings().textColor;
        context.fillText(text, 10, this.labelFontSize);
        
        context.font = `${this.labelFontSize / 2}px ${visualizationSettings.getLabelSettings().fontFamily}`;
        context.fillStyle = visualizationSettings.getLabelSettings().infoTextColor;
        context.fillText(infoText, 10, this.labelFontSize + 20);

        // Create sprite
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthWrite: false
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        
        // Scale sprite to maintain readable text size in meters
        const labelScale = visualizationSettings.getLabelSettings().verticalOffset;
        sprite.scale.set(
            (canvas.width / this.labelFontSize) * labelScale,
            (canvas.height / this.labelFontSize) * labelScale,
            1
        );
        sprite.layers.set(NORMAL_LAYER);

        return sprite;
    }

    formatFileSize(size) {
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let i = 0;
        while (size >= 1024 && i < units.length - 1) {
            size /= 1024;
            i++;
        }
        return `${size.toFixed(2)} ${units[i]}`;
    }

    formatAge(lastModified) {
        const now = Date.now();
        const age = now - new Date(lastModified).getTime();
        const days = Math.floor(age / (24 * 60 * 60 * 1000));
        
        if (days < 1) return 'Today';
        if (days === 1) return 'Yesterday';
        if (days < 7) return `${days}d ago`;
        if (days < 30) return `${Math.floor(days / 7)}w ago`;
        if (days < 365) return `${Math.floor(days / 30)}m ago`;
        return `${Math.floor(days / 365)}y ago`;
    }

    formatNodeNameToUrl(nodeName) {
        // Get base URL from environment or default to logseq
        const baseUrl = window.location.origin;
        // Convert node name to lowercase and replace spaces with dashes
        const formattedName = nodeName.toLowerCase().replace(/ /g, '-');
        return `${baseUrl}/#/page/${formattedName}`;
    }

        handleClick(event, isXR = false, intersectedObject = null) {
            let clickedMesh;
    
            if (isXR && intersectedObject) {
                // In XR mode, use the passed intersected object directly
                clickedMesh = intersectedObject;
            } else if (!isXR && event) {
                // Regular mouse click handling
                const rect = event.target.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(Array.from(this.nodeMeshes.values()));
                
                if (intersects.length > 0) {
                    clickedMesh = intersects[0].object;
                }
            }
    
            if (clickedMesh) {
                // Find the clicked node
                const nodeId = Array.from(this.nodeMeshes.entries())
                    .find(([_, mesh]) => mesh === clickedMesh)?.[0];
    
                if (nodeId) {
                    const nodeData = this.nodeData.get(nodeId);
                    if (nodeData) {
                        // Open URL in new tab
                        const url = this.formatNodeNameToUrl(nodeData.label || nodeId);
                        window.open(url, '_blank');
    
                        // Visual feedback
                        const originalEmissive = clickedMesh.material.emissiveIntensity;
                        clickedMesh.material.emissiveIntensity = 2.0;
                        setTimeout(() => {
                            clickedMesh.material.emissiveIntensity = originalEmissive;
                        }, 200);
    
                        // Show XR label if in XR mode
                        if (isXR && this.xrLabelManager) {
                            this.xrLabelManager.showLabel(
                                nodeData.label || nodeId,
                                clickedMesh.position,
                                {
                                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                    color: '#ffffff',
                                    font: '24px Arial'
                                }
                            );
                        }
    
                        // Trigger haptic feedback in XR mode
                        if (isXR && window.xrSession) {
                            const inputSource = Array.from(window.xrSession.inputSources).find(source => 
                                source.handedness === 'right' || source.handedness === 'left'
                            );
                            if (inputSource?.gamepad?.hapticActuators?.length > 0) {
                                inputSource.gamepad.hapticActuators[0].pulse(0.5, 100);
                            }
                        }
                    }
                }
            }
        }
    
        initClickHandling(renderer) {
            // Add click event listener to renderer's DOM element
            renderer.domElement.addEventListener('click', this.handleClick);
        }
    
        removeClickHandling(renderer) {
            // Remove click event listener
            renderer.domElement.removeEventListener('click', this.handleClick);
        }

    centerNodes(nodes) {
        if (!nodes || (!Array.isArray(nodes) && typeof nodes !== 'object')) {
            console.warn('Invalid nodes data passed to centerNodes');
            return;
        }

        const nodeArray = Array.isArray(nodes) ? nodes.map((node, index) => {
            if (Array.isArray(node)) {
                return {
                    id: index,
                    x: node[0],
                    y: node[1],
                    z: node[2],
                    vx: node[3],
                    vy: node[4],
                    vz: node[5]
                };
            }
            return node;
        }) : Object.values(nodes);

        if (nodeArray.length === 0) {
            console.warn('Empty nodes array passed to centerNodes');
            return;
        }

        // Calculate center of mass
        let centerX = 0, centerY = 0, centerZ = 0;
        nodeArray.forEach(node => {
            centerX += node.x || 0;
            centerY += node.y || 0;
            centerZ += node.z || 0;
        });
        centerX /= nodeArray.length;
        centerY /= nodeArray.length;
        centerZ /= nodeArray.length;

        // Center around origin
        nodeArray.forEach(node => {
            node.x = (node.x || 0) - centerX;
            node.y = (node.y || 0) - centerY;
            node.z = (node.z || 0) - centerZ;
        });

        // Scale positions to reasonable range in meters
        const maxDist = nodeArray.reduce((max, node) => {
            const dist = Math.sqrt(
                (node.x || 0) * (node.x || 0) + 
                (node.y || 0) * (node.y || 0) + 
                (node.z || 0) * (node.z || 0)
            );
            return Math.max(max, dist);
        }, 0);

        if (maxDist > 0) {
            // Scale to fit in 5 meter radius by default
            const targetRadius = 5.0; // meters
            const scale = targetRadius / maxDist;
            nodeArray.forEach(node => {
                node.x = (node.x || 0) * scale;
                node.y = (node.y || 0) * scale;
                node.z = (node.z || 0) * scale;
            });
        }

        return nodeArray;
    }

        updateNodes(nodes) {
            if (!Array.isArray(nodes)) {
                console.error('updateNodes received invalid nodes:', nodes);
                return;
            }
    
            console.log(`Updating nodes: ${nodes.length}`);
            
            // Center and scale nodes
            const centeredNodes = this.centerNodes(nodes);
            if (!centeredNodes) return;
            
            const existingNodeIds = new Set(centeredNodes.map(node => node.id));
    
            // Remove non-existent nodes
            this.nodeMeshes.forEach((mesh, nodeId) => {
                if (!existingNodeIds.has(nodeId)) {
                    this.scene.remove(mesh);
                    this.nodeMeshes.delete(nodeId);
                    this.nodeData.delete(nodeId);
                    const label = this.nodeLabels.get(nodeId);
                    if (label) {
                        this.scene.remove(label);
                        this.nodeLabels.delete(nodeId);
                    }
                }
            });
    
            // Update or create nodes
            centeredNodes.forEach(node => {
                if (!node.id || typeof node.x !== 'number' || typeof node.y !== 'number' || typeof node.z !== 'number') {
                    console.warn('Invalid node data:', node);
                    return;
                }
    
                // Store node data for click handling
                this.nodeData.set(node.id, node);
    
                const metadata = node.metadata || {};
                const size = this.getNodeSize(metadata);
                const color = this.calculateNodeColor(metadata);
    
                let mesh = this.nodeMeshes.get(node.id);
    
                if (!mesh) {
                    const geometry = this.createNodeGeometry(size, metadata.hyperlink_count || 0);
                    const material = this.createNodeMaterial(color, metadata);
    
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.layers.enable(BLOOM_LAYER);
                    this.scene.add(mesh);
                    this.nodeMeshes.set(node.id, mesh);
    
                    const label = this.createNodeLabel(node.label || node.id, metadata);
                    this.scene.add(label);
                    this.nodeLabels.set(node.id, label);
                } else {
                    mesh.geometry.dispose();
                    mesh.geometry = this.createNodeGeometry(size, metadata.hyperlink_count || 0);
                    mesh.material.dispose();
                    mesh.material = this.createNodeMaterial(color, metadata);
    }

            mesh.position.set(node.x, node.y, node.z);
            const label = this.nodeLabels.get(node.id);
            if (label) {
                label.position.set(node.x, node.y + size + 2, node.z);
            }
        });
    }

    updateEdges(edges) {
        console.log(`Updating edges: ${edges.length}`);
        
        // Create a map of edges with their weights from topic counts
        const edgeWeights = new Map();
        edges.forEach(edge => {
            if (!edge.source || !edge.target_node) {
                console.warn('Invalid edge data:', edge);
                return;
            }

            const edgeKey = `${edge.source}-${edge.target_node}`;
            const weight = edge.weight || 1; // Use provided weight or default to 1
            edgeWeights.set(edgeKey, weight);
        });

        // Remove non-existent edges
        this.edgeMeshes.forEach((line, edgeKey) => {
            if (!edgeWeights.has(edgeKey)) {
                this.scene.remove(line);
                this.edgeMeshes.delete(edgeKey);
            }
        });

        // Update or create edges
        edgeWeights.forEach((weight, edgeKey) => {
            const [source, target] = edgeKey.split('-');
            let line = this.edgeMeshes.get(edgeKey);
            const sourceMesh = this.nodeMeshes.get(source);
            const targetMesh = this.nodeMeshes.get(target);

            if (!line && sourceMesh && targetMesh) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Scale edge opacity based on weight
                const normalizedWeight = Math.min(weight / 10, 1); // Normalize weight, cap at 1
                const material = new THREE.LineBasicMaterial({
                    color: this.edgeColor,
                    transparent: true,
                    opacity: this.edgeOpacity * normalizedWeight,
                    linewidth: Math.max(1, Math.min(weight, 5)) // Scale line width with weight, between 1-5
                });

                line = new THREE.Line(geometry, material);
                line.layers.set(NORMAL_LAYER);
                this.scene.add(line);
                this.edgeMeshes.set(edgeKey, line);
            }

            if (line && sourceMesh && targetMesh) {
                const positions = line.geometry.attributes.position.array;
                positions[0] = sourceMesh.position.x;
                positions[1] = sourceMesh.position.y;
                positions[2] = sourceMesh.position.z;
                positions[3] = targetMesh.position.x;
                positions[4] = targetMesh.position.y;
                positions[5] = targetMesh.position.z;
                line.geometry.attributes.position.needsUpdate = true;

                // Update edge appearance based on weight
                const normalizedWeight = Math.min(weight / 10, 1);
                line.material.opacity = this.edgeOpacity * normalizedWeight;
                line.material.linewidth = Math.max(1, Math.min(weight, 5));
            }
        });
    }

    updateLabelOrientations(camera) {
        this.nodeLabels.forEach((label, nodeId) => {
            const mesh = this.nodeMeshes.get(nodeId);
            if (mesh) {
                // Position label closer to node due to smaller size
                const size = mesh.geometry.parameters.radius || 
                           mesh.geometry.parameters.width || 
                           this.minNodeSize;
                label.position.set(
                    mesh.position.x,
                    mesh.position.y + size + 0.2, // Reduced offset
                    mesh.position.z
                );
                label.lookAt(camera.position);
            }
        });
    }

    updateFeature(control, value) {
        console.log(`Updating feature: ${control} = ${value}`);
        switch (control) {
            // Node features
            case 'nodeColor':
                if (typeof value === 'number' || typeof value === 'string') {
                    this.nodeColor = new THREE.Color(value);
                    this.nodeMeshes.forEach(mesh => {
                        if (mesh.material) {
                            mesh.material.color.copy(this.nodeColor);
                            mesh.material.emissive.copy(this.nodeColor);
                        }
                    });
                }
                break;
            case 'minNodeSize':
                this.minNodeSize = value; // Value in meters
                break;
            case 'maxNodeSize':
                this.maxNodeSize = value; // Value in meters
                break;
            case 'labelFontSize':
                this.labelFontSize = value;
                break;

            // Edge features
            case 'edgeColor':
                if (typeof value === 'number' || typeof value === 'string') {
                    this.edgeColor = new THREE.Color(value);
                    this.edgeMeshes.forEach(line => {
                        if (line.material) {
                            line.material.color.copy(this.edgeColor);
                        }
                    });
                }
                break;
            case 'edgeOpacity':
                this.edgeOpacity = value;
                this.edgeMeshes.forEach(line => {
                    if (line.material) {
                        line.material.opacity = value;
                    }
                });
                break;
        }
    }

    updateMaterial(settings) {
        console.log('Updating node material settings:', settings);
        
        // Update material settings
        this.materialSettings = {
            ...this.materialSettings,
            metalness: settings.metalness ?? this.materialSettings.metalness,
            roughness: settings.roughness ?? this.materialSettings.roughness,
            clearcoat: settings.clearcoat ?? this.materialSettings.clearcoat,
            clearcoatRoughness: settings.clearcoatRoughness ?? this.materialSettings.clearcoatRoughness,
            opacity: settings.opacity ?? this.materialSettings.opacity,
            emissiveMinIntensity: settings.emissiveMinIntensity ?? this.materialSettings.emissiveMinIntensity,
            emissiveMaxIntensity: settings.emissiveMaxIntensity ?? this.materialSettings.emissiveMaxIntensity
        };

        // Update all existing node materials
        this.nodeMeshes.forEach((mesh, nodeId) => {
            const nodeData = this.nodeData.get(nodeId);
            if (nodeData && mesh.material) {
                // Create new material with updated settings
                mesh.material.dispose(); // Dispose old material
                mesh.material = this.createNodeMaterial(mesh.material.color, nodeData.metadata || {});
            }
        });
    }

    updateEdgesForNode(nodeId) {
        this.edgeMeshes.forEach((line, edgeKey) => {
            const [source, target] = edgeKey.split('-');
            if (source === nodeId || target === nodeId) {
                const positions = line.geometry.attributes.position.array;
                const sourceMesh = this.nodeMeshes.get(source);
                const targetMesh = this.nodeMeshes.get(target);

                if (sourceMesh && targetMesh) {
                    positions[0] = sourceMesh.position.x;
                    positions[1] = sourceMesh.position.y;
                    positions[2] = sourceMesh.position.z;
                    positions[3] = targetMesh.position.x;
                    positions[4] = targetMesh.position.y;
                    positions[5] = targetMesh.position.z;
                    line.geometry.attributes.position.needsUpdate = true;
                }
            }
        });
    }

    getNodePositions() {
        return Array.from(this.nodeMeshes.values()).map(mesh => [
            mesh.position.x,
            mesh.position.y,
            mesh.position.z
        ]);
    }

    dispose() {
        // Dispose node resources
        this.nodeMeshes.forEach(mesh => {
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
            if (mesh.parent) mesh.parent.remove(mesh);
        });

        this.nodeLabels.forEach(label => {
            if (label.material.map) label.material.map.dispose();
            if (label.material) label.material.dispose();
            if (label.parent) label.parent.remove(label);
        });

        // Dispose edge resources
        this.edgeMeshes.forEach(line => {
            if (line.geometry) line.geometry.dispose();
            if (line.material) line.material.dispose();
            if (line.parent) line.parent.remove(line);
        });

        // Clear data maps
        this.nodeMeshes.clear();
        this.nodeLabels.clear();
        this.edgeMeshes.clear();
        this.nodeData.clear();

        // Clean up event listeners
        if (this.renderer) {
            this.removeClickHandling(this.renderer);
        }
    }
}

----
components/visualization/core.js
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { NodeManager } from './nodes.js';
import { EffectsManager } from './effects.js';
import { LayoutManager } from './layout.js';
import { visualizationSettings } from '../../services/visualizationSettings.js';
import { initXRSession, handleXRSession } from '../../xr/xrSetup.js';
import { initXRInteraction, handleXRInput, XRLabelManager } from '../../xr/xrInteraction.js';

// Constants for Spacemouse sensitivity
const TRANSLATION_SPEED = 0.01;
const ROTATION_SPEED = 0.01;
const VR_MOVEMENT_SPEED = 0.05; // Speed for VR joystick movement

function updateNodeDynamics(nodeManager, updates, isInitialLayout, timeStep) {
    if (isInitialLayout) {
        console.log('Applying initial layout positions and velocities');
        nodeManager.resetSimulation();
    }

    nodeManager.updateNodeDynamics(updates);

    if (timeStep > 0) {
        nodeManager.setTimeStep(timeStep);
    }

    if (nodeManager.isInteractive()) {
        nodeManager.updatePhysics(updates);
    }
}

export class WebXRVisualization {
    constructor(graphDataManager) {
        console.log('WebXRVisualization constructor called');
        this.graphDataManager = graphDataManager;

        // Initialize the scene, camera, and renderer
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        
        // Create camera
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.camera.matrixAutoUpdate = true;

        // Create VR camera rig
        this.cameraRig = new THREE.Group();
        this.cameraRig.name = 'cameraRig';
        this.scene.add(this.cameraRig);

        // Create user movement group
        this.userGroup = new THREE.Group();
        this.userGroup.name = 'userGroup';
        this.cameraRig.add(this.userGroup);
        
        // Set initial camera position and add to user group
        this.camera.position.set(0, 1.6, 3); // Set initial position at standing height
        this.userGroup.add(this.camera);
        
        console.log('Camera hierarchy:', {
            camera: this.camera.name || 'camera',
            parent: this.camera.parent?.name || 'none',
            grandparent: this.camera.parent?.parent?.name || 'none'
        });

        // Initialize renderer with XR support
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true,
            logarithmicDepthBuffer: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.xr.enabled = true;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Initialize managers with settings from service
        this.nodeManager = new NodeManager(this.scene, this.camera, visualizationSettings.getNodeSettings());
        this.effectsManager = new EffectsManager(
            this.scene,
            this.camera,
            this.renderer,
            visualizationSettings.getEnvironmentSettings()
        );
        this.layoutManager = new LayoutManager(visualizationSettings.getLayoutSettings());

        this.controls = null;
        this.xrControllers = [];
        this.xrHands = [];
        this.xrLabelManager = null;

        this.animationFrameId = null;
        this.lastPositionUpdate = 0;
        this.positionUpdateThreshold = 16;

        this.previousPositions = new Map();
        this.previousTimes = new Map();
        this.lastUpdateTime = performance.now();

        // Bind methods
        this.onWindowResize = this.onWindowResize.bind(this);
        this.animate = this.animate.bind(this);

        // Initialize settings and add event listeners
        this.initializeSettings();
        this.setupEventListeners();

        console.log('WebXRVisualization constructor completed');
    }

    onWindowResize() {
        if (this.camera && this.renderer) {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            if (this.effectsManager) {
                this.effectsManager.handleResize();
            }
        }
    }

    setupEventListeners() {
        window.addEventListener('graphDataUpdated', (event) => {
            if (event.detail && Array.isArray(event.detail.nodes)) {
                this.updateVisualization(event.detail);
            }
        });

        window.addEventListener('visualizationSettingsUpdated', (event) => {
            this.updateSettings(event.detail);
        });

        window.addEventListener('positionUpdate', (event) => {
            if (this.graphDataManager.isGraphDataValid() && this.graphDataManager.websocketService) {
                this.graphDataManager.websocketService.send(event.detail);
            }
        });

        window.addEventListener('binaryPositionUpdate', (event) => {
            this.handleBinaryPositionUpdate(event.detail);
        });
    }

    initializeSettings() {
        console.log('Initializing settings');
        const envSettings = visualizationSettings.getEnvironmentSettings();
        
        // Initialize fog
        this.fogDensity = envSettings.fogDensity;
        this.scene.fog = new THREE.FogExp2(0x000000, this.fogDensity);
        
        // Initialize lighting
        this.ambientLightIntensity = 50;
        this.directionalLightIntensity = 5.0;
        this.directionalLightColor = 0xffffff;
        this.ambientLightColor = 0x404040;
        
        // Add ambient light
        this.ambientLight = new THREE.AmbientLight(this.ambientLightColor, this.ambientLightIntensity);
        this.scene.add(this.ambientLight);

        // Add directional light
        this.directionalLight = new THREE.DirectionalLight(
            this.directionalLightColor,
            this.directionalLightIntensity
        );
        this.directionalLight.position.set(5, 5, 5);
        this.directionalLight.castShadow = true;
        this.scene.add(this.directionalLight);

        // Add point lights for better illumination
        const pointLight1 = new THREE.PointLight(0xffffff, 1, 100);
        pointLight1.position.set(10, 10, 10);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1, 100);
        pointLight2.position.set(-10, -10, -10);
        this.scene.add(pointLight2);
    }

    initThreeJS() {
        console.log('Initializing Three.js with XR support');
        const container = document.getElementById('scene-container');
        if (!container) {
            console.error("Could not find 'scene-container' element");
            return;
        }

        container.appendChild(this.renderer.domElement);

        // Initialize XR
        initXRSession(this.renderer, this.scene, this.camera);

        // Initialize XR interaction with proper event handling
        const { controllers, hands, xrLabelManager } = initXRInteraction(
            this.scene,
            this.camera,
            this.renderer,
            (event) => {
                if (event.detail && event.detail.intersection) {
                    const intersectedObject = event.detail.intersection.object;
                    this.nodeManager.handleClick(null, true, intersectedObject);
                }
            }
        );

        this.xrControllers = controllers;
        this.xrHands = hands;
        this.xrLabelManager = xrLabelManager;

        // Initialize non-XR controls
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;

        // Disable OrbitControls when in XR
        this.renderer.xr.addEventListener('sessionstart', () => {
            console.log('XR session started - Disabling OrbitControls');
            this.controls.enabled = false;
            
            // Reset positions when entering VR
            this.userGroup.position.set(0, 0, 0);
            this.cameraRig.position.set(0, 0, 0);
            
            console.log('VR Session Start - Camera hierarchy:', {
                camera: this.camera.name || 'camera',
                parent: this.camera.parent?.name || 'none',
                grandparent: this.camera.parent?.parent?.name || 'none',
                positions: {
                    camera: this.camera.position.toArray(),
                    userGroup: this.userGroup.position.toArray(),
                    cameraRig: this.cameraRig.position.toArray()
                }
            });
        });

        this.renderer.xr.addEventListener('sessionend', () => {
            console.log('XR session ended - Enabling OrbitControls');
            this.controls.enabled = true;
            
            // Reset positions when exiting VR
            this.camera.position.set(0, 1.6, 3);
            this.userGroup.position.set(0, 0, 0);
            this.cameraRig.position.set(0, 0, 0);
            
            console.log('VR Session End - Camera hierarchy:', {
                camera: this.camera.name || 'camera',
                parent: this.camera.parent?.name || 'none',
                grandparent: this.camera.parent?.parent?.name || 'none',
                positions: {
                    camera: this.camera.position.toArray(),
                    userGroup: this.userGroup.position.toArray(),
                    cameraRig: this.cameraRig.position.toArray()
                }
            });
        });

        this.effectsManager.initPostProcessing();
        this.effectsManager.createHologramStructure();

        window.addEventListener('resize', this.onWindowResize);

        this.animate();
    }

    animate() {
        this.renderer.setAnimationLoop((timestamp, frame) => {
            // Handle VR movement if in XR session
            if (this.renderer.xr.isPresenting && frame) {
                const session = this.renderer.xr.getSession();
                if (session) {
                    // Log camera hierarchy and positions for debugging
                    console.log('Animation Frame - Camera hierarchy:', {
                        camera: this.camera.name || 'camera',
                        parent: this.camera.parent?.name || 'none',
                        grandparent: this.camera.parent?.parent?.name || 'none',
                        positions: {
                            camera: this.camera.position.toArray(),
                            userGroup: this.userGroup.position.toArray(),
                            cameraRig: this.cameraRig.position.toArray()
                        }
                    });
                }
            } else {
                // Update non-XR controls
                this.controls.update();
            }

            this.effectsManager.animate();
            this.nodeManager.updateLabelOrientations(this.camera);

            // Render the scene
            if (this.renderer.xr.isPresenting) {
                this.renderer.render(this.scene, this.camera);
            } else {
                this.effectsManager.render();
            }
        });
    }

    updateVisualization(graphData) {
        if (this.nodeManager && graphData) {
            // Update nodes
            if (Array.isArray(graphData.nodes)) {
                this.nodeManager.updateNodes(graphData.nodes);
            }
            
            // Update edges if available
            if (Array.isArray(graphData.edges)) {
                this.nodeManager.updateEdges(graphData.edges);
            }
        }
    }

    updateSettings(settings) {
        console.log('Updating visualization settings:', settings);
        
        if (settings.visual) {
            // Update visual settings
            const visualSettings = {
                nodeColor: settings.visual.nodeColor,
                edgeColor: settings.visual.edgeColor,
                hologramColor: settings.visual.hologramColor,
                minNodeSize: settings.visual.minNodeSize,
                maxNodeSize: settings.visual.maxNodeSize,
                hologramScale: settings.visual.hologramScale,
                hologramOpacity: settings.visual.hologramOpacity,
                edgeOpacity: settings.visual.edgeOpacity,
                fogDensity: settings.visual.fogDensity
            };
            this.nodeManager.updateFeature(visualSettings);
            
            // Update fog density
            if (this.scene.fog && settings.visual.fogDensity !== undefined) {
                this.scene.fog.density = settings.visual.fogDensity;
            }
        }

        if (settings.material) {
            // Update material settings
            const materialSettings = {
                metalness: settings.material.metalness,
                roughness: settings.material.roughness,
                clearcoat: settings.material.clearcoat,
                clearcoatRoughness: settings.material.clearcoatRoughness,
                opacity: settings.material.opacity,
                emissiveMinIntensity: settings.material.emissiveMin,
                emissiveMaxIntensity: settings.material.emissiveMax
            };
            this.nodeManager.updateMaterial(materialSettings);
        }

        if (settings.physics) {
            // Update physics settings
            const physicsSettings = {
                iterations: settings.physics.iterations,
                spring_strength: settings.physics.spring,
                repulsion_strength: settings.physics.repulsion,
                attraction_strength: settings.physics.attraction,
                damping: settings.physics.damping
            };
            this.layoutManager.updateFeature(physicsSettings);
        }

        if (settings.bloom) {
            // Update bloom settings
            const bloomSettings = {
                nodeBloomStrength: settings.bloom.nodeStrength,
                nodeBloomRadius: settings.bloom.nodeRadius,
                nodeBloomThreshold: settings.bloom.nodeThreshold,
                edgeBloomStrength: settings.bloom.edgeStrength,
                edgeBloomRadius: settings.bloom.edgeRadius,
                edgeBloomThreshold: settings.bloom.edgeThreshold,
                environmentBloomStrength: settings.bloom.envStrength,
                environmentBloomRadius: settings.bloom.envRadius,
                environmentBloomThreshold: settings.bloom.envThreshold
            };
            this.effectsManager.updateBloom(bloomSettings);
        }

        if (settings.fisheye) {
            // Update fisheye settings
            const fisheyeSettings = {
                enabled: settings.fisheye.enabled,
                strength: settings.fisheye.strength,
                radius: settings.fisheye.radius,
                focusPoint: [
                    settings.fisheye.focusX,
                    settings.fisheye.focusY,
                    settings.fisheye.focusZ
                ]
            };
            this.effectsManager.updateFisheye(fisheyeSettings);
        }
    }

    handleSpacemouseInput(x, y, z) {
        if (!this.camera || this.renderer.xr.isPresenting) return;

        // Translation
        this.camera.position.x += x * TRANSLATION_SPEED;
        this.camera.position.y += y * TRANSLATION_SPEED;
        this.camera.position.z += z * TRANSLATION_SPEED;

        // Update controls target
        if (this.controls) {
            this.controls.target.copy(this.camera.position).add(
                new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion)
            );
            this.controls.update();
        }
    }

    dispose() {
        console.log('Disposing WebXRVisualization');
        this.renderer.setAnimationLoop(null);

        window.removeEventListener('resize', this.onWindowResize);

        this.nodeManager.dispose();
        this.effectsManager.dispose();
        this.layoutManager.stopSimulation();
        
        if (this.xrLabelManager) {
            this.xrLabelManager.dispose();
        }

        if (this.xrControllers) {
            this.xrControllers.forEach(controller => {
                if (controller) {
                    this.scene.remove(controller);
                }
            });
        }

        if (this.xrHands) {
            this.xrHands.forEach(hand => {
                if (hand) {
                    this.scene.remove(hand);
                }
            });
        }

        this.renderer.dispose();
        if (this.controls) {
            this.controls.dispose();
        }

        console.log('WebXRVisualization disposed');
    }
}

----
threeJS/threeSetup.js
// public/js/threeJS/threeSetup.js

import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {object} An object containing the scene, camera, and renderer.
 */
export function initThreeScene() {
    // Create the scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    // Create the camera with XR-friendly settings
    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,  // Closer near plane for XR
        1000
    );
    camera.position.set(0, 1.6, 3); // Default height ~1.6m (average human height)

    // Create the renderer with XR-specific configuration
    const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true, // Enable alpha for AR passthrough
        logarithmicDepthBuffer: true, // Better depth precision for XR
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Modern color space handling
    renderer.xr.enabled = true; // Enable WebXR
    renderer.shadowMap.enabled = true; // Enable shadows for better visual quality
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for realism

    // Set up XR-friendly lighting
    setupLighting(scene);

    // Append the renderer to the DOM
    const container = document.getElementById('scene-container');
    if (container) {
        container.appendChild(renderer.domElement);
    } else {
        document.body.appendChild(renderer.domElement);
    }

    // Add ambient light for better visibility in XR
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    return { scene, camera, renderer };
}

/**
 * Sets up XR-friendly lighting in the scene
 * @param {THREE.Scene} scene - The Three.js scene
 */
function setupLighting(scene) {
    // Main directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    scene.add(directionalLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    // Ambient light for overall scene brightness
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
}

/**
 * Creates and configures orbit controls for the camera.
 * @param {THREE.Camera} camera - The Three.js camera.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 * @returns {OrbitControls} The configured orbit controls.
 */
export function createOrbitControls(camera, renderer) {
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // Configure controls for XR compatibility
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI * 0.95; // Prevent camera from going below ground
    controls.minDistance = 1; // Minimum zoom distance
    controls.maxDistance = 50; // Maximum zoom distance
    
    // Disable controls when in XR mode
    renderer.xr.addEventListener('sessionstart', () => {
        controls.enabled = false;
    });
    
    renderer.xr.addEventListener('sessionend', () => {
        controls.enabled = true;
    });

    return controls;
}

/**
 * Handles window resize events by updating the camera and renderer.
 * @param {THREE.Camera} camera - The Three.js camera.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 */
export function updateSceneSize(camera, renderer) {
    // Only update if not in XR session
    if (!renderer.xr.isPresenting) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

/**
 * Creates a basic environment for XR scenes
 * @param {THREE.Scene} scene - The Three.js scene
 */
export function createBasicEnvironment(scene) {
    // Add a ground plane for reference and shadows
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x808080,
        roughness: 0.8,
        metalness: 0.2,
        transparent: true,
        opacity: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Add grid helper for spatial reference
    const gridHelper = new THREE.GridHelper(100, 100);
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.2;
    scene.add(gridHelper);
}

----
threeJS/threeGraph.js
// public/js/threeJS/threeGraph.js

import * as THREE from 'three';
import { visualizationSettings } from '../services/visualizationSettings.js';

/**
 * ForceGraph class manages the creation and updating of nodes and edges in the Three.js scene.
 */
export class ForceGraph {
    /**
     * Creates a new ForceGraph instance.
     * @param {THREE.Scene} scene - The Three.js scene.
     */
    constructor(scene) {
        this.scene = scene;

        // Data structures
        this.nodes = [];
        this.links = [];

        // Meshes
        this.nodeMeshes = new Map();
        this.linkMeshes = new Map();

        // Instanced meshes for performance
        this.nodeInstancedMesh = null;
        this.nodeCount = 0;

        // Object pools
        this.nodeMeshPool = [];
        this.linkMeshPool = [];

        // Level of Detail
        this.lod = new THREE.LOD();
        this.scene.add(this.lod);

        // Get settings
        const nodeSettings = visualizationSettings.getNodeSettings();
        const edgeSettings = visualizationSettings.getEdgeSettings();
        
        // Store settings
        this.nodeColors = {
            NEW: new THREE.Color(nodeSettings.colorNew),
            RECENT: new THREE.Color(nodeSettings.colorRecent),
            MEDIUM: new THREE.Color(nodeSettings.colorMedium),
            OLD: new THREE.Color(nodeSettings.colorOld),
            CORE: new THREE.Color(nodeSettings.colorCore),
            SECONDARY: new THREE.Color(nodeSettings.colorSecondary),
            DEFAULT: new THREE.Color(nodeSettings.colorDefault)
        };
        this.edgeColor = new THREE.Color(edgeSettings.color);
        this.edgeOpacity = edgeSettings.opacity;
        this.minNodeSize = nodeSettings.minNodeSize;  // In meters (0.1m = 10cm)
        this.maxNodeSize = nodeSettings.maxNodeSize;  // In meters (0.3m = 30cm)
        this.materialSettings = nodeSettings.material;
    }

    /**
     * Calculates node size in meters based on metadata.
     * @param {object} node - The node object with metadata.
     * @returns {number} - The node size in meters.
     */
    getNodeSize(node) {
        if (node.metadata?.node_size) {
            const size = parseFloat(node.metadata.node_size);
            // Normalize size between minNodeSize (0.1m) and maxNodeSize (0.3m)
            return this.minNodeSize + (size * (this.maxNodeSize - this.minNodeSize));
        }
        return this.minNodeSize; // Default to minimum size (10cm)
    }

    /**
     * Calculates node color based on age and type.
     * @param {object} node - The node object with metadata.
     * @returns {THREE.Color} - The color of the node.
     */
    getNodeColor(node) {
        // First check node type
        if (node.type === 'core') return this.nodeColors.CORE;
        if (node.type === 'secondary') return this.nodeColors.SECONDARY;

        // Then check age if type is not special
        const lastModified = node.metadata?.github_last_modified || 
                           node.metadata?.last_modified || 
                           new Date().toISOString();
        const now = Date.now();
        const age = now - new Date(lastModified).getTime();
        const dayInMs = 24 * 60 * 60 * 1000;
        
        if (age < 3 * dayInMs) return this.nodeColors.NEW;        // Less than 3 days old
        if (age < 7 * dayInMs) return this.nodeColors.RECENT;     // Less than 7 days old
        if (age < 30 * dayInMs) return this.nodeColors.MEDIUM;    // Less than 30 days old
        return this.nodeColors.OLD;                               // 30 days or older
    }

    /**
     * Creates a material for a node.
     * @param {THREE.Color} color - The base color for the node.
     * @param {object} node - The node object with metadata.
     * @returns {THREE.MeshPhysicalMaterial} - The material for the node.
     */
    createNodeMaterial(color, node) {
        const lastModified = node.metadata?.github_last_modified || 
                           node.metadata?.last_modified || 
                           new Date().toISOString();
        const now = Date.now();
        const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
        
        // Normalize age to 0-1 range and invert (newer = brighter)
        const normalizedAge = Math.min(ageInDays / 30, 1);
        const emissiveIntensity = this.materialSettings.emissiveMaxIntensity - 
            (normalizedAge * (this.materialSettings.emissiveMaxIntensity - this.materialSettings.emissiveMinIntensity));

        return new THREE.MeshPhysicalMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: emissiveIntensity,
            metalness: this.materialSettings.metalness,
            roughness: this.materialSettings.roughness,
            transparent: true,
            opacity: this.materialSettings.opacity,
            envMapIntensity: 1.0,
            clearcoat: this.materialSettings.clearcoat,
            clearcoatRoughness: this.materialSettings.clearcoatRoughness
        });
    }

    /**
     * Updates the graph with new data.
     * @param {object} graphData - The graph data containing nodes and edges.
     */
    updateGraph(graphData) {
        this.nodes = graphData.nodes;
        this.links = graphData.edges;
        this.renderGraph();
    }

    /**
     * Renders the graph by creating and updating nodes and edges.
     */
    renderGraph() {
        this.updateNodes();
        this.updateLinks();
    }

    /**
     * Updates nodes in the scene based on the graph data.
     */
    updateNodes() {
        const newNodeIds = new Set(this.nodes.map((node) => node.id));

        // Remove nodes that no longer exist
        this.nodeMeshes.forEach((mesh, nodeId) => {
            if (!newNodeIds.has(nodeId)) {
                this.lod.removeLevel(mesh);
                this.nodeMeshes.delete(nodeId);
                this.nodeMeshPool.push(mesh); // Return to pool
            }
        });

        // Add or update nodes
        this.nodes.forEach((node) => {
            const nodeSize = this.getNodeSize(node);
            const nodeColor = this.getNodeColor(node);

            if (this.nodeMeshes.has(node.id)) {
                const mesh = this.nodeMeshes.get(node.id);
                mesh.position.set(node.x, node.y, node.z);
                
                // Update geometry and material if needed
                if (mesh.geometry.parameters.radius !== nodeSize) {
                    mesh.geometry.dispose();
                    mesh.geometry = new THREE.SphereGeometry(nodeSize, 32, 32);
                }
                mesh.material.dispose();
                mesh.material = this.createNodeMaterial(nodeColor, node);
            } else {
                // Get mesh from pool or create new one
                let mesh;
                if (this.nodeMeshPool.length > 0) {
                    mesh = this.nodeMeshPool.pop();
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                    mesh.geometry = new THREE.SphereGeometry(nodeSize, 32, 32);
                    mesh.material = this.createNodeMaterial(nodeColor, node);
                } else {
                    const geometry = new THREE.SphereGeometry(nodeSize, 32, 32);
                    const material = this.createNodeMaterial(nodeColor, node);
                    mesh = new THREE.Mesh(geometry, material);
                }

                mesh.position.set(node.x, node.y, node.z);
                mesh.userData = { id: node.id, name: node.label };
                this.lod.addLevel(mesh, 0);

                this.nodeMeshes.set(node.id, mesh);
            }
        });
    }

    /**
     * Updates edges in the scene based on the graph data.
     */
    updateLinks() {
        const newLinkKeys = new Set(this.links.map((link) => `${link.source}-${link.target}`));

        // Remove edges that no longer exist
        this.linkMeshes.forEach((line, linkKey) => {
            if (!newLinkKeys.has(linkKey)) {
                this.scene.remove(line);
                this.linkMeshes.delete(linkKey);
                this.linkMeshPool.push(line);
            }
        });

        // Add or update edges
        this.links.forEach((link) => {
            const linkKey = `${link.source}-${link.target}`;
            const weight = link.weight || 1;
            const normalizedWeight = Math.min(weight / 10, 1);

            if (this.linkMeshes.has(linkKey)) {
                const line = this.linkMeshes.get(linkKey);
                const sourceMesh = this.nodeMeshes.get(link.source);
                const targetMesh = this.nodeMeshes.get(link.target);
                if (sourceMesh && targetMesh) {
                    const positions = line.geometry.attributes.position.array;
                    positions[0] = sourceMesh.position.x;
                    positions[1] = sourceMesh.position.y;
                    positions[2] = sourceMesh.position.z;
                    positions[3] = targetMesh.position.x;
                    positions[4] = targetMesh.position.y;
                    positions[5] = targetMesh.position.z;
                    line.geometry.attributes.position.needsUpdate = true;
                    
                    // Update edge appearance
                    line.material.opacity = this.edgeOpacity * normalizedWeight;
                }
            } else {
                // Get line from pool or create new one
                let line;
                if (this.linkMeshPool.length > 0) {
                    line = this.linkMeshPool.pop();
                } else {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                    const material = new THREE.LineBasicMaterial({ 
                        color: this.edgeColor, 
                        opacity: this.edgeOpacity * normalizedWeight, 
                        transparent: true,
                        linewidth: Math.max(1, Math.min(weight, 5))
                    });
                    line = new THREE.Line(geometry, material);
                }

                const sourceMesh = this.nodeMeshes.get(link.source);
                const targetMesh = this.nodeMeshes.get(link.target);
                if (sourceMesh && targetMesh) {
                    const positions = line.geometry.attributes.position.array;
                    positions[0] = sourceMesh.position.x;
                    positions[1] = sourceMesh.position.y;
                    positions[2] = sourceMesh.position.z;
                    positions[3] = targetMesh.position.x;
                    positions[4] = targetMesh.position.y;
                    positions[5] = targetMesh.position.z;
                    line.geometry.attributes.position.needsUpdate = true;

                    this.scene.add(line);
                    this.linkMeshes.set(linkKey, line);
                }
            }
        });
    }
}

--END--