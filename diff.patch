diff --git a/.dockerignore b/.dockerignore
index b5e42a8a..c6481f06 100755
--- a/.dockerignore
+++ b/.dockerignore
@@ -1,6 +1,7 @@
 # Git
 .git
 .gitignore
+.pmpm-store
 
 # Rust
 target/
diff --git a/.env_template b/.env_template
index 8b0ca9c2..99951c81 100755
--- a/.env_template
+++ b/.env_template
@@ -81,8 +81,6 @@ RETRY_DELAY=5
 API_CLIENT_TIMEOUT=30
 MAX_PAYLOAD_SIZE=5242880
 ENABLE_REQUEST_LOGGING=false
-ENABLE_METRICS=true
-METRICS_PORT=9090
 LOG_LEVEL=info
 LOG_FORMAT=json
 
diff --git a/.gitignore b/.gitignore
index cce3108d..bbf1a0cf 100755
--- a/.gitignore
+++ b/.gitignore
@@ -9,6 +9,7 @@ data/public/dist
 data/public/node_modules
 dist
 data/markdown
+.pmpm-store
 
 data/piper/en_GB-northern_english_male-medium.onnx
 config.yml
diff --git a/Cargo.lock b/Cargo.lock
old mode 100644
new mode 100755
diff --git a/Dockerfile b/Dockerfile
index 03d35621..ed377d9e 100755
--- a/Dockerfile
+++ b/Dockerfile
@@ -3,21 +3,28 @@ FROM node:23.1.0-slim AS frontend-builder
 
 WORKDIR /app
 
-# Copy package files, vite config, and the public directory
-COPY package.json pnpm-lock.yaml vite.config.js ./
-COPY data/public ./data/public
-
-# Configure npm and build
+# Configure npm
 ENV NPM_CONFIG_PREFIX=/home/node/.npm-global
 ENV PATH=/home/node/.npm-global/bin:$PATH
 RUN mkdir -p /home/node/.npm-global && \
     chown -R node:node /app /home/node/.npm-global && \
     npm config set prefix /home/node/.npm-global
 
+# Copy only necessary files for the build
+COPY --chown=node:node package.json pnpm-lock.yaml ./
+COPY --chown=node:node vite.config.js ./
+COPY --chown=node:node data ./data
+
 USER node
-RUN npm install -g pnpm && \
+RUN set -x && \
+    npm install -g pnpm && \
     pnpm install --frozen-lockfile && \
-    pnpm run build
+    pwd && \
+    ls -la && \
+    echo "Running build..." && \
+    pnpm run build && \
+    echo "Build complete" && \
+    ls -la data/public/dist
 
 # Stage 2: Rust Dependencies Cache
 FROM nvidia/cuda:12.2.0-runtime-ubuntu22.04 AS rust-deps-builder
@@ -130,11 +137,13 @@ RUN mkdir -p /var/lib/nginx/client_temp \
     chown -R appuser:nginx /var/lib/nginx \
                           /var/log/nginx \
                           /var/run/nginx \
-                          /var/cache/nginx && \
+                          /var/cache/nginx \
+                          /etc/nginx && \
     chmod -R 770 /var/lib/nginx \
                  /var/log/nginx \
                  /var/run/nginx \
-                 /var/cache/nginx && \
+                 /var/cache/nginx \
+                 /etc/nginx && \
     touch /var/log/nginx/error.log \
           /var/log/nginx/access.log && \
     chown appuser:nginx /var/log/nginx/*.log && \
@@ -147,13 +156,14 @@ RUN mkdir -p /var/lib/nginx/client_temp \
 # Set up directory structure
 WORKDIR /app
 
-# Create required directories
-RUN mkdir -p /app/data/public/dist \
+# Create required directories with correct permissions
+RUN mkdir -p /app/data/public \
              /app/data/markdown \
              /app/data/runtime \
              /app/src \
              /app/data/piper && \
-    chown -R appuser:appuser /app
+    chown -R appuser:appuser /app && \
+    chmod -R 755 /app
 
 # Copy Python virtual environment
 COPY --from=python-builder --chown=appuser:appuser /app/venv /app/venv
@@ -165,9 +175,11 @@ COPY --from=frontend-builder --chown=appuser:appuser /app/data/public/dist /app/
 
 # Copy configuration and scripts
 COPY --chown=appuser:appuser src/generate_audio.py /app/src/
-COPY --chown=root:root nginx.conf /etc/nginx/nginx.conf
+COPY --chown=appuser:nginx nginx.conf /etc/nginx/nginx.conf
 COPY --chown=appuser:appuser start.sh /app/start.sh
-RUN chmod 755 /app/start.sh
+RUN chmod 755 /app/start.sh && \
+    chmod 644 /etc/nginx/nginx.conf && \
+    ls -la /app/data/public/dist
 
 # Add security labels
 LABEL org.opencontainers.image.source="https://github.com/yourusername/logseq-xr" \
diff --git a/data/public/index.html b/data/public/index.html
index 0d18202b..f0dac3b0 100755
--- a/data/public/index.html
+++ b/data/public/index.html
@@ -30,7 +30,7 @@
             z-index: 1000;
             pointer-events: none;
         }
-        #app * {
+        #app > * {
             pointer-events: auto;
         }
         #connection-status {
@@ -50,6 +50,13 @@
             background-color: #dc3545;
             color: white;
         }
+        /* Debug styles */
+        #app {
+            border: 1px solid blue;
+        }
+        #app > div {
+            border: 1px solid green;
+        }
     </style>
 </head>
 <body>
diff --git a/data/public/js/app.js b/data/public/js/app.js
index edd12b51..9cb1a951 100755
--- a/data/public/js/app.js
+++ b/data/public/js/app.js
@@ -39,23 +39,48 @@ export class App {
     }
 
     async initializeApp() {
+        console.log('DOM ready state:', document.readyState);
         console.log('Initializing Application - Step 1: Services');
 
         // Initialize Services
         try {
-            // Create WebsocketService but don't connect yet (it auto-connects in constructor)
+            // Create WebsocketService and wait for connection
             this.websocketService = new WebsocketService();
-            console.log('WebsocketService initialized successfully');
+            
+            // Modified connection promise to handle both successful messages and connection event
+            await new Promise((resolve, reject) => {
+                let messageReceived = false;
+                const timeout = setTimeout(() => {
+                    if (!messageReceived) {
+                        reject(new Error('WebSocket connection timeout'));
+                    }
+                }, 5000);
+
+                this.websocketService.on('message', () => {
+                    messageReceived = true;
+                    clearTimeout(timeout);
+                    resolve();
+                });
+
+                this.websocketService.on('error', (error) => {
+                    clearTimeout(timeout);
+                    reject(error);
+                });
+            });
+            
+            console.log('WebsocketService connected successfully');
         } catch (error) {
             console.error('Failed to initialize WebsocketService:', error);
-            throw error; // Propagate error since WebsocketService is critical
+            throw error;
         }
 
-        if (this.websocketService) {
+        // Initialize GraphDataManager after websocket is connected
+        try {
             this.graphDataManager = new GraphDataManager(this.websocketService);
             console.log('GraphDataManager initialized successfully');
-        } else {
-            throw new Error('Cannot initialize GraphDataManager: WebsocketService is not available');
+        } catch (error) {
+            console.error('Failed to initialize GraphDataManager:', error);
+            throw error;
         }
         
         console.log('Initializing Application - Step 2: Visualization');
@@ -74,14 +99,14 @@ export class App {
         } catch (error) {
             console.error('Failed to initialize WebXRVisualization:', error);
             console.error('Error stack:', error.stack);
-            throw error; // Propagate error since visualization is critical
+            throw error;
         }
 
         console.log('Initializing Application - Step 3: GPU');
         // Initialize GPU if available
-        this.gpuAvailable = isGPUAvailable();
+        this.gpuAvailable = await isGPUAvailable();
         if (this.gpuAvailable) {
-            this.gpuUtils = initGPU();
+            this.gpuUtils = await initGPU();
             console.log('GPU acceleration initialized');
         } else {
             console.warn('GPU acceleration not available, using CPU fallback');
@@ -102,61 +127,71 @@ export class App {
         console.log('Initializing Application - Step 6: Event Listeners');
         // Setup Event Listeners
         this.setupEventListeners();
+
+        // Request initial data after everything is initialized
+        console.log('Requesting initial graph data');
+        this.websocketService.send({ type: 'getInitialData' });
     }
 
     async initVueApp() {
         try {
             console.log('Initializing Vue application');
             
-            // Store websocketService reference for closure
-            const websocketService = this.websocketService;
+            // Verify app container exists
+            const appContainer = document.getElementById('app');
+            if (!appContainer) {
+                throw new Error("Could not find '#app' element");
+            }
+            console.log('Found app container:', appContainer);
+
+            const self = this;
             
-            // Create Vue app instance
+            // Create Vue app with debug styling
             const app = createApp({
                 components: {
-                    ControlPanel,
-                    ChatManager
-                },
-                setup() {
-                    return {
-                        websocketService,
-                        enableSpacemouse // Make enableSpacemouse available to components
-                    };
+                    ControlPanel
                 },
                 template: `
-                    <div>
-                        <ControlPanel 
+                    <div style="position: fixed; top: 0; right: 0; z-index: 1000; background: rgba(0,0,0,0.8); padding: 20px;">
+                        <control-panel 
                             :websocket-service="websocketService"
-                            :enable-spacemouse="enableSpacemouse"
                             @control-change="handleControlChange"
                         />
-                        <ChatManager 
-                            :websocket-service="websocketService"
-                        />
                     </div>
                 `,
-                methods: {
-                    handleControlChange(change) {
-                        console.log('Control changed:', change);
-                        // Handle control changes here if needed
+                setup() {
+                    // Verify websocketService is available
+                    if (!self.websocketService) {
+                        console.error('WebsocketService not initialized');
                     }
+                    
+                    return {
+                        websocketService: self.websocketService,
+                        handleControlChange: (change) => {
+                            console.log('Control changed:', change);
+                            if (self.visualization) {
+                                self.visualization.updateSettings(change);
+                            } else {
+                                console.error('Visualization not initialized');
+                            }
+                        }
+                    };
                 }
             });
 
-            // Mount the app
-            const appContainer = document.getElementById('app');
-            if (!appContainer) {
-                console.error('App container not found, creating it');
-                const newContainer = document.createElement('div');
-                newContainer.id = 'app';
-                document.body.appendChild(newContainer);
-            }
+            // Add error handler
+            app.config.errorHandler = (err, vm, info) => {
+                console.error('Vue Error:', err);
+                console.error('Error Info:', info);
+            };
 
-            this.vueApp = app.mount('#app');
-            console.log('Vue application initialized successfully');
+            // Mount with verification
+            app.mount('#app');
+            this.vueApp = app;
+
+            console.log('Vue application mounted successfully');
         } catch (error) {
             console.error('Failed to initialize Vue application:', error);
-            console.error('Error stack:', error.stack);
             throw error;
         }
     }
@@ -166,13 +201,30 @@ export class App {
             // Setup websocket event listeners
             this.websocketService.on('connect', () => {
                 console.log('WebSocket connected');
+                // Re-request initial data if reconnected
+                this.websocketService.send({ type: 'getInitialData' });
             });
 
             this.websocketService.on('disconnect', () => {
                 console.log('WebSocket disconnected');
             });
 
-            // Add other event listeners as needed
+            // Add debug listener for graph updates
+            this.websocketService.on('graphUpdate', (data) => {
+                console.log('Received graph update:', data);
+            });
+        }
+    }
+
+    stop() {
+        if (this.visualization) {
+            this.visualization.dispose();
+        }
+        if (this.websocketService) {
+            this.websocketService.disconnect();
+        }
+        if (this.vueApp) {
+            this.vueApp.unmount();
         }
     }
 }
diff --git a/data/public/js/components/ControlPanel.vue b/data/public/js/components/ControlPanel.vue
index 6f1ba0e1..e5aec95c 100755
--- a/data/public/js/components/ControlPanel.vue
+++ b/data/public/js/components/ControlPanel.vue
@@ -1,4 +1,211 @@
-<!-- Previous template and style sections remain the same -->
+<template>
+    <div id="control-panel" :class="{ hidden: isHidden }" @mounted="logMount">
+        <button class="toggle-button" @click="togglePanel">
+            {{ isHidden ? 'Show Controls' : 'Hide Controls' }}
+        </button>
+        <div class="panel-content">
+            <!-- Audio Controls -->
+            <div class="control-group">
+                <div class="group-header" @click="toggleGroup('audio')">
+                    <h3>Audio System</h3>
+                </div>
+                <div v-if="!collapsedGroups.audio" class="group-content">
+                    <div class="audio-status">
+                        <button v-if="!audioInitialized" @click="initializeAudio" class="save-button">
+                            Initialize Audio
+                        </button>
+                        <div v-else class="status-indicator enabled">
+                            Audio System Active
+                        </div>
+                    </div>
+                    <div class="control-item">
+                        <label>Simulation Mode</label>
+                        <select v-model="simulationMode" @change="setSimulationMode">
+                            <option value="remote">Remote</option>
+                            <option value="local">Local</option>
+                        </select>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Node Appearance -->
+            <div class="control-group">
+                <div class="group-header" @click="toggleGroup('nodeAppearance')">
+                    <h3>Node Appearance</h3>
+                </div>
+                <div v-if="!collapsedGroups.nodeAppearance" class="group-content">
+                    <!-- Node Colors -->
+                    <div v-for="color in nodeColors" :key="color.name" class="control-item">
+                        <label>{{ color.label }}</label>
+                        <input type="color" 
+                               :value="color.value"
+                               @input="emitChange(color.name, $event.target.value)">
+                    </div>
+
+                    <!-- Material Properties -->
+                    <div v-for="prop in materialProperties" :key="prop.name" class="control-item">
+                        <label>{{ prop.label }}</label>
+                        <input type="range"
+                               :min="prop.min"
+                               :max="prop.max"
+                               :step="prop.step"
+                               :value="prop.value"
+                               @input="emitChange(prop.name, parseFloat($event.target.value))">
+                        <span class="range-value">{{ prop.value.toFixed(2) }}</span>
+                    </div>
+
+                    <!-- Size Controls -->
+                    <div v-for="control in sizeControls" :key="control.name" class="control-item">
+                        <label>{{ control.label }}</label>
+                        <input type="range"
+                               :min="control.min"
+                               :max="control.max"
+                               :step="control.step"
+                               :value="control.value"
+                               @input="emitChange(control.name, parseFloat($event.target.value))">
+                        <span class="range-value">{{ control.value.toFixed(2) }}</span>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Edge Appearance -->
+            <div class="control-group">
+                <div class="group-header" @click="toggleGroup('edgeAppearance')">
+                    <h3>Edge Appearance</h3>
+                </div>
+                <div v-if="!collapsedGroups.edgeAppearance" class="group-content">
+                    <div v-for="control in edgeControls" :key="control.name" class="control-item">
+                        <label>{{ control.label }}</label>
+                        <template v-if="control.type === 'color'">
+                            <input type="color"
+                                   :value="control.value"
+                                   @input="emitChange(control.name, $event.target.value)">
+                        </template>
+                        <template v-else>
+                            <input type="range"
+                                   :min="control.min"
+                                   :max="control.max"
+                                   :step="control.step"
+                                   :value="control.value"
+                                   @input="emitChange(control.name, parseFloat($event.target.value))">
+                            <span class="range-value">{{ control.value.toFixed(2) }}</span>
+                        </template>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Bloom Effects -->
+            <div class="control-group">
+                <div class="group-header" @click="toggleGroup('bloom')">
+                    <h3>Bloom Effects</h3>
+                </div>
+                <div v-if="!collapsedGroups.bloom" class="group-content">
+                    <div v-for="(group, groupKey) in bloomControls" :key="groupKey" class="sub-group">
+                        <h4>{{ group.label }}</h4>
+                        <div v-for="control in group.controls" :key="control.name" class="control-item">
+                            <label>{{ control.label }}</label>
+                            <input type="range"
+                                   :min="control.min"
+                                   :max="control.max"
+                                   :step="control.step"
+                                   :value="control.value"
+                                   @input="emitChange(control.name, parseFloat($event.target.value))">
+                            <span class="range-value">{{ control.value.toFixed(2) }}</span>
+                        </div>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Physics Controls -->
+            <div class="control-group">
+                <div class="group-header" @click="toggleGroup('physics')">
+                    <h3>Physics Simulation</h3>
+                </div>
+                <div v-if="!collapsedGroups.physics" class="group-content">
+                    <div v-for="control in physicsControls" :key="control.name" class="control-item">
+                        <label>{{ control.label }}</label>
+                        <input type="range"
+                               :min="control.min"
+                               :max="control.max"
+                               :step="control.step"
+                               :value="control.value"
+                               @input="emitChange(control.name, parseFloat($event.target.value))">
+                        <span class="range-value">{{ control.value.toFixed(2) }}</span>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Environment Controls -->
+            <div class="control-group">
+                <div class="group-header" @click="toggleGroup('environment')">
+                    <h3>Environment</h3>
+                </div>
+                <div v-if="!collapsedGroups.environment" class="group-content">
+                    <!-- Hologram Controls -->
+                    <div v-for="control in hologramControls" :key="control.name" class="control-item">
+                        <label>{{ control.label }}</label>
+                        <template v-if="control.type === 'color'">
+                            <input type="color"
+                                   :value="control.value"
+                                   @input="emitChange(control.name, $event.target.value)">
+                        </template>
+                        <template v-else>
+                            <input type="range"
+                                   :min="control.min"
+                                   :max="control.max"
+                                   :step="control.step"
+                                   :value="control.value"
+                                   @input="emitChange(control.name, parseFloat($event.target.value))">
+                            <span class="range-value">{{ control.value.toFixed(2) }}</span>
+                        </template>
+                    </div>
+
+                    <!-- Fog Density -->
+                    <div class="control-item">
+                        <label>Fog Density</label>
+                        <input type="range"
+                               :min="0"
+                               :max="0.01"
+                               :step="0.0001"
+                               :value="fogDensity"
+                               @input="emitChange('fogDensity', parseFloat($event.target.value))">
+                        <span class="range-value">{{ fogDensity.toFixed(4) }}</span>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Fisheye Controls -->
+            <div class="control-group">
+                <div class="group-header" @click="toggleGroup('fisheye')">
+                    <h3>Fisheye Effect</h3>
+                </div>
+                <div v-if="!collapsedGroups.fisheye" class="group-content">
+                    <div class="control-item">
+                        <label>Enable Fisheye</label>
+                        <input type="checkbox"
+                               :checked="fisheyeEnabled"
+                               @change="emitChange('fisheyeEnabled', $event.target.checked)">
+                    </div>
+                    <div v-for="control in fisheyeControls" :key="control.name" class="control-item">
+                        <label>{{ control.label }}</label>
+                        <input type="range"
+                               :min="control.min"
+                               :max="control.max"
+                               :step="control.step"
+                               :value="control.value"
+                               @input="emitChange(control.name, parseFloat($event.target.value))">
+                        <span class="range-value">{{ control.value.toFixed(2) }}</span>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Save Settings Button -->
+            <button class="save-button" @click="saveSettings">
+                Save Settings
+            </button>
+        </div>
+    </div>
+</template>
 
 <script>
 import { defineComponent, ref, reactive, onMounted } from 'vue';
@@ -149,6 +356,12 @@ export default defineComponent({
 
         const emitChange = (name, value) => {
             emit('control-change', { name, value });
+            
+            // Dispatch event for visualization settings update
+            window.dispatchEvent(new CustomEvent('visualizationSettingsUpdated', {
+                detail: { [name]: value }
+            }));
+
             if (props.websocketService) {
                 props.websocketService.send({
                     type: 'settingUpdate',
@@ -290,14 +503,27 @@ export default defineComponent({
             }
         });
 
+        // Add mounted hook
+        onMounted(() => {
+            console.log('ControlPanel mounted');
+            console.log('WebsocketService available:', !!props.websocketService);
+            // Check visibility
+            const panel = document.getElementById('control-panel');
+            if (panel) {
+                console.log('Panel styles:', window.getComputedStyle(panel));
+            } else {
+                console.error('Control panel element not found');
+            }
+        });
+
         return {
             isHidden,
             audioInitialized,
             simulationMode,
             collapsedGroups,
             nodeColors,
-            nodeMaterialMetalness,
-            minNodeSize,
+            materialProperties,
+            sizeControls,
             edgeControls,
             bloomControls,
             physicsControls,
@@ -330,6 +556,8 @@ export default defineComponent({
     z-index: 1000;
     transition: transform 0.3s ease-in-out;
     box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
+    /* Add debug outline */
+    border: 1px solid red;
 }
 
 #control-panel.hidden {
@@ -350,6 +578,7 @@ export default defineComponent({
     border-radius: 5px 5px 0 0;
     font-size: 0.9em;
     white-space: nowrap;
+    z-index: 1001; /* Ensure it's above the panel */
 }
 
 .panel-content {
diff --git a/data/public/js/components/visualization/core.js b/data/public/js/components/visualization/core.js
index 575e087d..be8a8326 100755
--- a/data/public/js/components/visualization/core.js
+++ b/data/public/js/components/visualization/core.js
@@ -2,329 +2,285 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
 import { NodeManager } from './nodes.js';
 import { EffectsManager } from './effects.js';
-import { LayoutManager } from './layout.js';
 import { visualizationSettings } from '../../services/visualizationSettings.js';
-import { initXRSession, handleXRSession } from '../../xr/xrSetup.js';
-import { initXRInteraction, handleXRInput, XRLabelManager } from '../../xr/xrInteraction.js';
+import { initXRSession, addXRButton } from '../../xr/xrSetup.js';
+import { initXRInteraction } from '../../xr/xrInteraction.js';
 
-// Constants for Spacemouse sensitivity
+// Constants for input sensitivity
 const TRANSLATION_SPEED = 0.01;
 const ROTATION_SPEED = 0.01;
 const VR_MOVEMENT_SPEED = 0.05;
 
-function updateNodeDynamics(nodeManager, updates, isInitialLayout, timeStep) {
-    if (isInitialLayout) {
-        console.log('Applying initial layout positions and velocities');
-        nodeManager.resetSimulation();
-    }
-
-    nodeManager.updateNodeDynamics(updates);
-
-    if (timeStep > 0) {
-        nodeManager.setTimeStep(timeStep);
-    }
-
-    if (nodeManager.isInteractive()) {
-        nodeManager.updatePhysics(updates);
-    }
-}
-
 export class WebXRVisualization {
     constructor(graphDataManager) {
-        console.log('WebXRVisualization constructor called');
+        console.log('WebXRVisualization constructor called with graphDataManager:', !!graphDataManager);
+        if (!graphDataManager) {
+            throw new Error('GraphDataManager is required for WebXRVisualization');
+        }
         this.graphDataManager = graphDataManager;
 
-        // Initialize the scene, camera, and renderer
+        // Initialize the scene with a dark gray background for better contrast
         this.scene = new THREE.Scene();
-        this.scene.background = new THREE.Color(0x000000);
-        
-        // Create camera
-        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
-        this.camera.matrixAutoUpdate = true;
-
-        // Create VR camera rig
-        this.cameraRig = new THREE.Group();
-        this.cameraRig.name = 'cameraRig';
-        this.scene.add(this.cameraRig);
-
-        // Create user movement group
-        this.userGroup = new THREE.Group();
-        this.userGroup.name = 'userGroup';
-        this.cameraRig.add(this.userGroup);
+        this.scene.background = new THREE.Color(0x111111);
         
-        // Set initial camera position and add to user group
-        this.camera.position.set(0, 1.6, 3); // Set initial position at standing height
-        this.userGroup.add(this.camera);
-        
-        console.log('Camera hierarchy:', {
-            camera: this.camera.name || 'camera',
-            parent: this.camera.parent?.name || 'none',
-            grandparent: this.camera.parent?.parent?.name || 'none'
-        });
+        // Create camera with optimized initial position for graph viewing
+        this.camera = new THREE.PerspectiveCamera(
+            50, // Narrower FOV for better depth perception
+            window.innerWidth / window.innerHeight,
+            0.1,
+            2000
+        );
+        // Position camera further back for better overview of large graphs
+        this.camera.position.set(0, 15, 50);
+        this.camera.lookAt(0, 0, 0);
+
+        // Create and initialize canvas
+        this.canvas = document.createElement('canvas');
+        this.canvas.width = window.innerWidth;
+        this.canvas.height = window.innerHeight;
+
+        // Initialize renderer with WebGL2 and HDR support
+        try {
+            const contextAttributes = {
+                alpha: false,
+                antialias: true,
+                powerPreference: "high-performance",
+                failIfMajorPerformanceCaveat: false,
+                preserveDrawingBuffer: true // Important for texture updates
+            };
 
-        // Initialize renderer with XR support
-        this.renderer = new THREE.WebGLRenderer({ 
-            antialias: true,
-            alpha: true,
-            logarithmicDepthBuffer: true,
-            powerPreference: "high-performance"
-        });
-        this.renderer.setSize(window.innerWidth, window.innerHeight);
-        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
-        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
-        this.renderer.xr.enabled = true;
-        this.renderer.shadowMap.enabled = true;
-        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
-
-        // Initialize managers with settings from service
+            // Try WebGL 2 first for better performance
+            let gl = this.canvas.getContext('webgl2', contextAttributes);
+            let isWebGL2 = !!gl;
+
+            if (!gl) {
+                console.warn('WebGL 2 not available, falling back to WebGL 1');
+                gl = this.canvas.getContext('webgl', contextAttributes) ||
+                     this.canvas.getContext('experimental-webgl', contextAttributes);
+                isWebGL2 = false;
+            }
+
+            if (!gl) {
+                throw new Error('WebGL not supported');
+            }
+
+            // Create renderer with optimized settings
+            this.renderer = new THREE.WebGLRenderer({
+                canvas: this.canvas,
+                context: gl,
+                antialias: true,
+                alpha: false,
+                logarithmicDepthBuffer: true,
+                powerPreference: "high-performance",
+                preserveDrawingBuffer: true
+            });
+
+            // Configure renderer for HDR and optimal quality
+            this.renderer.setSize(window.innerWidth, window.innerHeight);
+            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
+            this.renderer.outputColorSpace = THREE.SRGBColorSpace;
+            this.renderer.shadowMap.enabled = true;
+            this.renderer.shadowMap.type = isWebGL2 ? THREE.PCFSoftShadowMap : THREE.PCFShadowMap;
+            this.renderer.setClearColor(0x111111, 1);
+            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
+            this.renderer.toneMappingExposure = 1.2;
+
+            // Enable XR if available
+            if (navigator.xr) {
+                this.renderer.xr.enabled = true;
+            } else {
+                console.warn('WebXR not supported');
+            }
+
+            console.log(`Renderer initialized with ${isWebGL2 ? 'WebGL 2' : 'WebGL 1'}`);
+        } catch (error) {
+            console.error('Failed to initialize renderer:', error);
+            throw error;
+        }
+
+        // Initialize scene container with proper styling
+        const container = document.getElementById('scene-container');
+        if (container) {
+            container.style.position = 'absolute';
+            container.style.top = '0';
+            container.style.left = '0';
+            container.style.width = '100%';
+            container.style.height = '100%';
+            container.style.overflow = 'hidden';
+            container.style.backgroundColor = '#111111';
+            
+            this.canvas.style.position = 'absolute';
+            this.canvas.style.top = '0';
+            this.canvas.style.left = '0';
+            this.canvas.style.width = '100%';
+            this.canvas.style.height = '100%';
+            container.appendChild(this.canvas);
+        }
+
+        // Initialize texture loader with proper settings
+        this.textureLoader = new THREE.TextureLoader();
+        this.textureLoader.crossOrigin = 'anonymous';
+
+        // Initialize managers
+        console.log('Initializing NodeManager');
         this.nodeManager = new NodeManager(this.scene, this.camera, visualizationSettings.getNodeSettings());
-        this.effectsManager = new EffectsManager(
-            this.scene,
-            this.camera,
-            this.renderer,
-            visualizationSettings.getEnvironmentSettings()
-        );
-        this.layoutManager = new LayoutManager(visualizationSettings.getLayoutSettings());
+        
+        // Initialize effects manager with error handling
+        console.log('Initializing EffectsManager');
+        try {
+            this.effectsManager = new EffectsManager(this.scene, this.camera, this.renderer);
+            this.effectsEnabled = true;
+        } catch (error) {
+            console.error('Failed to initialize effects manager:', error);
+            this.effectsManager = null;
+            this.effectsEnabled = false;
+        }
 
-        this.controls = null;
+        // Initialize controls with optimized settings
+        this.controls = new OrbitControls(this.camera, this.canvas);
+        this.controls.enableDamping = true;
+        this.controls.dampingFactor = 0.1;
+        this.controls.rotateSpeed = 0.8;
+        this.controls.panSpeed = 0.8;
+        this.controls.zoomSpeed = 0.8;
+        this.controls.target.set(0, 0, 0);
+
+        // XR-related properties
+        this.xrSessionManager = null;
         this.xrControllers = [];
         this.xrHands = [];
         this.xrLabelManager = null;
-
-        this.animationFrameId = null;
-        this.lastPositionUpdate = 0;
-        this.positionUpdateThreshold = 16;
-
-        this.previousPositions = new Map();
-        this.previousTimes = new Map();
-        this.lastUpdateTime = performance.now();
+        this.isXRActive = false;
 
         // Bind methods
         this.onWindowResize = this.onWindowResize.bind(this);
         this.animate = this.animate.bind(this);
+        this.updateVisualization = this.updateVisualization.bind(this);
+        this.fallbackRender = this.fallbackRender.bind(this);
+        this.handleSpacemouseInput = this.handleSpacemouseInput.bind(this);
 
-        // Initialize settings and add event listeners
+        // Initialize scene settings and start animation
         this.initializeSettings();
         this.setupEventListeners();
+        this.animate();
 
         console.log('WebXRVisualization constructor completed');
     }
 
-    onWindowResize() {
-        if (this.camera && this.renderer) {
-            this.camera.aspect = window.innerWidth / window.innerHeight;
-            this.camera.updateProjectionMatrix();
-            this.renderer.setSize(window.innerWidth, window.innerHeight);
-            if (this.effectsManager) {
-                this.effectsManager.handleResize();
-            }
-        }
-    }
-
-    setupEventListeners() {
-        window.addEventListener('graphDataUpdated', (event) => {
-            if (event.detail && Array.isArray(event.detail.nodes)) {
-                this.updateVisualization(event.detail);
-            }
-        });
-
-        window.addEventListener('visualizationSettingsUpdated', (event) => {
-            this.updateSettings(event.detail);
-        });
-
-        window.addEventListener('positionUpdate', (event) => {
-            if (this.graphDataManager.isGraphDataValid() && this.graphDataManager.websocketService) {
-                this.graphDataManager.websocketService.send(event.detail);
-            }
-        });
-
-        window.addEventListener('binaryPositionUpdate', (event) => {
-            this.handleBinaryPositionUpdate(event.detail);
-        });
-    }
-
     initializeSettings() {
         console.log('Initializing settings');
-        const envSettings = visualizationSettings.getEnvironmentSettings();
         
-        // Initialize fog
-        this.fogDensity = envSettings.fogDensity;
-        this.scene.fog = new THREE.FogExp2(0x000000, this.fogDensity);
+        // Add a grid helper for spatial reference
+        const gridHelper = new THREE.GridHelper(100, 100, 0x555555, 0x282828);
+        gridHelper.position.y = -10; // Move grid down for better perspective
+        this.scene.add(gridHelper);
+
+        // Add ambient light for base illumination
+        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
+        this.scene.add(ambientLight);
+
+        // Add directional light for shadows and highlights
+        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
+        directionalLight.position.set(10, 20, 10);
+        directionalLight.castShadow = true;
         
-        // Initialize lighting
-        this.ambientLightIntensity = 50;
-        this.directionalLightIntensity = 5.0;
-        this.directionalLightColor = 0xffffff;
-        this.ambientLightColor = 0x404040;
+        // Increase shadow map size for better quality
+        directionalLight.shadow.mapSize.width = 2048;
+        directionalLight.shadow.mapSize.height = 2048;
+        directionalLight.shadow.camera.near = 0.5;
+        directionalLight.shadow.camera.far = 200;
+        directionalLight.shadow.bias = -0.0001;
         
-        // Add ambient light
-        this.ambientLight = new THREE.AmbientLight(this.ambientLightColor, this.ambientLightIntensity);
-        this.scene.add(this.ambientLight);
-
-        // Add directional light
-        this.directionalLight = new THREE.DirectionalLight(
-            this.directionalLightColor,
-            this.directionalLightIntensity
-        );
-        this.directionalLight.position.set(5, 5, 5);
-        this.directionalLight.castShadow = true;
-        this.scene.add(this.directionalLight);
+        this.scene.add(directionalLight);
 
         // Add point lights for better illumination
-        const pointLight1 = new THREE.PointLight(0xffffff, 1, 100);
-        pointLight1.position.set(10, 10, 10);
+        const pointLight1 = new THREE.PointLight(0xffffff, 0.3, 200);
+        pointLight1.position.set(50, 50, 50);
         this.scene.add(pointLight1);
 
-        const pointLight2 = new THREE.PointLight(0xffffff, 1, 100);
-        pointLight2.position.set(-10, -10, -10);
+        const pointLight2 = new THREE.PointLight(0xffffff, 0.3, 200);
+        pointLight2.position.set(-50, -50, -50);
         this.scene.add(pointLight2);
+
+        // Add very subtle fog for depth
+        const envSettings = visualizationSettings.getEnvironmentSettings();
+        this.scene.fog = new THREE.FogExp2(0x111111, envSettings.fogDensity || 0.001);
     }
 
     async initThreeJS() {
-        console.log('Initializing Three.js with XR support');
+        console.log('Initializing Three.js');
         const container = document.getElementById('scene-container');
         if (!container) {
             console.error("Could not find 'scene-container' element");
             return;
         }
 
-        // Setup renderer with proper stacking context
-        this.renderer.domElement.style.position = 'absolute';
-        this.renderer.domElement.style.top = '0';
-        this.renderer.domElement.style.left = '0';
-        this.renderer.domElement.style.zIndex = '0';
-        container.appendChild(this.renderer.domElement);
-
-        // Create a separate div for OrbitControls
-        const controlsContainer = document.createElement('div');
-        controlsContainer.style.position = 'absolute';
-        controlsContainer.style.top = '0';
-        controlsContainer.style.left = '0';
-        controlsContainer.style.width = '100%';
-        controlsContainer.style.height = '100%';
-        controlsContainer.style.zIndex = '1';
-        container.appendChild(controlsContainer);
-
-        // Initialize controls with optimized settings
-        this.controls = new OrbitControls(this.camera, controlsContainer);
-        this.controls.enableDamping = true;
-        this.controls.dampingFactor = 0.1;
-        this.controls.rotateSpeed = 0.8;
-        this.controls.panSpeed = 0.8;
-        this.controls.zoomSpeed = 0.8;
-
-        // Setup pointer events
-        const updatePointerEvents = (isInteracting) => {
-            if (!this.renderer.xr.isPresenting) {
-                this.renderer.domElement.style.pointerEvents = isInteracting ? 'auto' : 'none';
-                controlsContainer.style.pointerEvents = isInteracting ? 'auto' : 'none';
-            }
-        };
-
-        container.addEventListener('mouseenter', () => updatePointerEvents(true));
-        container.addEventListener('mouseleave', () => updatePointerEvents(false));
+        // Initialize controls if not already initialized
+        if (!this.controls) {
+            this.controls = new OrbitControls(this.camera, this.canvas);
+            this.controls.enableDamping = true;
+            this.controls.dampingFactor = 0.1;
+            this.controls.rotateSpeed = 0.8;
+            this.controls.panSpeed = 0.8;
+            this.controls.zoomSpeed = 0.8;
+        }
         
-        // Initialize click handling
         this.nodeManager.initClickHandling(this.renderer);
 
-        // Initialize XR
-        await this.initializeXR();
+        // Initialize desktop effects first
+        await this.initializeDesktopEffects();
 
-        // Initialize effects after XR setup
-        if (this.effectsManager) {
-            this.effectsManager.initPostProcessing();
-        }
+        // Initialize XR support after effects
+        this.xrSessionManager = await initXRSession(this.renderer, this.scene, this.camera);
 
-        // Add resize listener
         window.addEventListener('resize', this.onWindowResize);
-
-        // Start animation loop
-        this.animate();
+        
+        if (this.xrSessionManager) {
+            await addXRButton(this.xrSessionManager);
     }
-
-    async initializeXR() {
-        // Initialize XR session with effects manager
-        await initXRSession(this.renderer, this.scene, this.camera, this.effectsManager);
-
-        // Initialize XR interaction
-        const { controllers, hands, xrLabelManager } = await initXRInteraction(
-            this.scene,
-            this.camera,
-            this.renderer,
-            (event) => {
-                if (event.detail?.intersection?.object) {
-                    this.nodeManager.handleClick(null, true, event.detail.intersection.object);
-                }
-            }
-        );
-
-        this.xrControllers = controllers;
-        this.xrHands = hands;
-        this.xrLabelManager = xrLabelManager;
-
-        // Setup XR event listeners
-        this.renderer.xr.addEventListener('sessionstart', () => {
-            console.log('XR session started - Disabling OrbitControls');
-            this.controls.enabled = false;
-            this.renderer.domElement.style.pointerEvents = 'none';
-            
-            // Reset positions
-            this.userGroup.position.set(0, 0, 0);
-            this.cameraRig.position.set(0, 0, 0);
-            
-            // Update effects manager for XR mode
-            if (this.effectsManager) {
-                this.effectsManager.handleXRSessionStart();
-            }
-        });
-
-        this.renderer.xr.addEventListener('sessionend', () => {
-            console.log('XR session ended - Enabling OrbitControls');
-            this.controls.enabled = true;
-            
-            // Reset positions
-            this.camera.position.set(0, 1.6, 3);
-            this.userGroup.position.set(0, 0, 0);
-            this.cameraRig.position.set(0, 0, 0);
-            
-            // Update effects manager for desktop mode
-            if (this.effectsManager) {
-                this.effectsManager.handleXRSessionEnd();
-            }
-        });
     }
 
     animate() {
         const renderFrame = (timestamp, frame) => {
-            // Update controls if enabled
-            if (this.controls && this.controls.enabled) {
+            if (this.controls && this.controls.enabled && !this.isXRActive) {
                 this.controls.update();
             }
 
-            // Update labels
             this.nodeManager.updateLabelOrientations(this.camera);
 
-            // Animate effects
-            this.effectsManager.animate();
-
-            // Render scene with effects in both desktop and XR modes
-            this.effectsManager.render();
+            // Try effects rendering first, fallback to normal if needed
+            if (this.effectsManager && this.effectsEnabled) {
+                try {
+                    this.effectsManager.render();
+                } catch (error) {
+                    console.error('Error in effects rendering:', error);
+                    this.effectsEnabled = false;
+                    this.fallbackRender();
+                }
+            } else {
+                this.fallbackRender();
+            }
         };
 
         this.renderer.setAnimationLoop(renderFrame);
     }
 
     updateVisualization(graphData) {
-        if (this.nodeManager && graphData) {
-            // Update nodes
-            if (Array.isArray(graphData.nodes)) {
-                this.nodeManager.updateNodes(graphData.nodes);
-            }
-            
-            // Update edges if available
-            if (Array.isArray(graphData.edges)) {
-                this.nodeManager.updateEdges(graphData.edges);
-            }
+        if (!this.nodeManager || !graphData) {
+            console.warn('Cannot update visualization: missing manager or data');
+            return;
+        }
+
+        console.log(`Updating visualization with ${graphData.nodes?.length || 0} nodes and ${graphData.edges?.length || 0} edges`);
+
+        if (Array.isArray(graphData.nodes)) {
+            console.log('Updating nodes');
+            this.nodeManager.updateNodes(graphData.nodes);
+        }
+        
+        if (Array.isArray(graphData.edges)) {
+            console.log('Updating edges');
+            this.nodeManager.updateEdges(graphData.edges);
         }
     }
 
@@ -332,7 +288,6 @@ export class WebXRVisualization {
         console.log('Updating visualization settings:', settings);
         
         if (settings.visual) {
-            // Update visual settings
             const visualSettings = {
                 nodeColor: settings.visual.nodeColor,
                 edgeColor: settings.visual.edgeColor,
@@ -346,14 +301,12 @@ export class WebXRVisualization {
             };
             this.nodeManager.updateFeature(visualSettings);
             
-            // Update fog density
             if (this.scene.fog && settings.visual.fogDensity !== undefined) {
                 this.scene.fog.density = settings.visual.fogDensity;
             }
         }
 
         if (settings.material) {
-            // Update material settings
             const materialSettings = {
                 metalness: settings.material.metalness,
                 roughness: settings.material.roughness,
@@ -366,65 +319,53 @@ export class WebXRVisualization {
             this.nodeManager.updateMaterial(materialSettings);
         }
 
-        if (settings.physics) {
-            // Update physics settings one by one
-            const physicsParamMap = {
-                iterations: 'forceDirectedIterations',
-                spring: 'forceDirectedSpring',
-                repulsion: 'forceDirectedRepulsion',
-                attraction: 'forceDirectedAttraction',
-                damping: 'forceDirectedDamping'
-            };
-
-            // Update each physics parameter individually
-            Object.entries(settings.physics).forEach(([key, value]) => {
-                if (physicsParamMap[key]) {
-                    this.layoutManager.updateFeature(physicsParamMap[key], value);
-                }
-            });
-        }
-
-        if (settings.bloom) {
-            // Update bloom settings
-            const bloomSettings = {
-                nodeBloomStrength: settings.bloom.nodeStrength,
-                nodeBloomRadius: settings.bloom.nodeRadius,
-                nodeBloomThreshold: settings.bloom.nodeThreshold,
-                edgeBloomStrength: settings.bloom.edgeStrength,
-                edgeBloomRadius: settings.bloom.edgeRadius,
-                edgeBloomThreshold: settings.bloom.edgeThreshold,
-                environmentBloomStrength: settings.bloom.envStrength,
-                environmentBloomRadius: settings.bloom.envRadius,
-                environmentBloomThreshold: settings.bloom.envThreshold
-            };
-            this.effectsManager.updateBloom(bloomSettings);
+        if (settings.bloom && this.effectsEnabled) {
+            try {
+                const bloomSettings = {
+                    nodeBloomStrength: settings.bloom.nodeStrength,
+                    nodeBloomRadius: settings.bloom.nodeRadius,
+                    nodeBloomThreshold: settings.bloom.nodeThreshold,
+                    edgeBloomStrength: settings.bloom.edgeStrength,
+                    edgeBloomRadius: settings.bloom.edgeRadius,
+                    edgeBloomThreshold: settings.bloom.edgeThreshold,
+                    environmentBloomStrength: settings.bloom.envStrength,
+                    environmentBloomRadius: settings.bloom.envRadius,
+                    environmentBloomThreshold: settings.bloom.envThreshold
+                };
+                this.effectsManager.updateBloom(bloomSettings);
+            } catch (error) {
+                console.error('Error updating bloom settings:', error);
+                this.effectsEnabled = false;
+            }
         }
 
-        if (settings.fisheye) {
-            // Update fisheye settings
-            const fisheyeSettings = {
-                enabled: settings.fisheye.enabled,
-                strength: settings.fisheye.strength,
-                radius: settings.fisheye.radius,
-                focusPoint: [
-                    settings.fisheye.focusX,
-                    settings.fisheye.focusY,
-                    settings.fisheye.focusZ
-                ]
-            };
-            this.effectsManager.updateFisheye(fisheyeSettings);
+        if (settings.fisheye && this.effectsEnabled) {
+            try {
+                const fisheyeSettings = {
+                    enabled: settings.fisheye.enabled,
+                    strength: settings.fisheye.strength,
+                    radius: settings.fisheye.radius,
+                    focusPoint: [
+                        settings.fisheye.focusX,
+                        settings.fisheye.focusY,
+                        settings.fisheye.focusZ
+                    ]
+                };
+                this.effectsManager.updateFisheye(fisheyeSettings);
+            } catch (error) {
+                console.error('Error updating fisheye settings:', error);
+                this.effectsEnabled = false;
+            }
         }
     }
 
     handleSpacemouseInput(x, y, z) {
         if (!this.camera || this.renderer.xr.isPresenting) return;
 
-        // Translation
         this.camera.position.x += x * TRANSLATION_SPEED;
         this.camera.position.y += y * TRANSLATION_SPEED;
         this.camera.position.z += z * TRANSLATION_SPEED;
 
-        // Update controls target
         if (this.controls) {
             this.controls.target.copy(this.camera.position).add(
                 new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion)
@@ -433,15 +374,144 @@ export class WebXRVisualization {
         }
     }
 
+    onWindowResize() {
+        if (this.camera && this.renderer && this.canvas) {
+            // Update canvas size
+            this.canvas.width = window.innerWidth;
+            this.canvas.height = window.innerHeight;
+            
+            // Update camera
+            this.camera.aspect = window.innerWidth / window.innerHeight;
+            this.camera.updateProjectionMatrix();
+            
+            // Update renderer
+            this.renderer.setSize(window.innerWidth, window.innerHeight);
+            
+            // Update effects if enabled
+            if (this.effectsManager && this.effectsEnabled) {
+                try {
+                    this.effectsManager.handleResize();
+                } catch (error) {
+                    console.error('Error handling effects resize:', error);
+                    this.effectsEnabled = false;
+                }
+            }
+        }
+    }
+
+    setupEventListeners() {
+        console.log('Setting up event listeners');
+        
+        window.addEventListener('graphDataUpdated', (event) => {
+            console.log('Received graphDataUpdated event:', event.detail);
+            if (event.detail && Array.isArray(event.detail.nodes)) {
+                this.updateVisualization(event.detail);
+            } else {
+                console.warn('Invalid graph data in event:', event.detail);
+            }
+        });
+
+        window.addEventListener('visualizationSettingsUpdated', (event) => {
+            console.log('Received settings update:', event.detail);
+            this.updateSettings(event.detail);
+        });
+
+        window.addEventListener('positionUpdate', (event) => {
+            if (this.graphDataManager.isGraphDataValid() && this.graphDataManager.websocketService) {
+                console.log('Sending position update to server');
+                this.graphDataManager.websocketService.send(event.detail);
+            }
+        });
+
+        window.addEventListener('binaryPositionUpdate', (event) => {
+            if (event.detail) {
+                console.log('Applying binary position update');
+                this.applyPositionUpdate(event.detail);
+            }
+        });
+
+        // XR session state listeners
+        if (this.renderer.xr) {
+            this.renderer.xr.addEventListener('sessionstart', () => {
+                console.log('XR session started');
+                this.isXRActive = true;
+                this.initializeXREffects();
+            });
+
+            this.renderer.xr.addEventListener('sessionend', () => {
+                console.log('XR session ended');
+                this.isXRActive = false;
+                this.initializeDesktopEffects();
+            });
+        }
+    }
+
+    fallbackRender() {
+        const currentCamera = this.isXRActive ? this.renderer.xr.getCamera() : this.camera;
+        // Clear the scene before rendering
+        this.renderer.clear(true, true, true);
+        // Render the scene directly without effects
+        this.renderer.render(this.scene, currentCamera);
+    }
+
+    async initializeDesktopEffects() {
+        if (this.effectsManager) {
+            try {
+                await this.effectsManager.initPostProcessing(false);
+                this.effectsEnabled = true;
+            } catch (error) {
+                console.error('Failed to initialize desktop effects:', error);
+                this.effectsEnabled = false;
+            }
+        }
+    }
+
+    async initializeXREffects() {
+        if (this.effectsManager) {
+            try {
+                await this.effectsManager.initPostProcessing(true);
+                this.effectsEnabled = true;
+            } catch (error) {
+                console.error('Failed to initialize XR effects:', error);
+                this.effectsEnabled = false;
+            }
+        }
+    }
+
+    applyPositionUpdate(update) {
+        if (!this.nodeManager) {
+            console.warn('Cannot apply position update: NodeManager not initialized');
+            return;
+        }
+
+        try {
+            // Assuming update is a binary buffer containing node positions
+            if (update instanceof ArrayBuffer) {
+                const positions = new Float32Array(update);
+                this.nodeManager.updateNodePositions(positions);
+            } else {
+                console.warn('Invalid position update format:', update);
+        }
+        } catch (error) {
+            console.error('Error applying position update:', error);
+        }
+    }
+
     dispose() {
         console.log('Disposing WebXRVisualization');
         this.renderer.setAnimationLoop(null);
 
         window.removeEventListener('resize', this.onWindowResize);
 
+        // Dispose of textures
+        if (this.textureLoader) {
+            THREE.Cache.clear(); // Clear texture cache
+        }
+
         this.nodeManager.dispose();
-        this.effectsManager.dispose();
-        this.layoutManager.stopSimulation();
+        if (this.effectsManager) {
+            this.effectsManager.dispose();
+        }
         
         if (this.xrLabelManager) {
             this.xrLabelManager.dispose();
@@ -463,6 +533,11 @@ export class WebXRVisualization {
             });
         }
 
+        // Clean up canvas
+        if (this.canvas && this.canvas.parentNode) {
+            this.canvas.parentNode.removeChild(this.canvas);
+        }
+
         this.renderer.dispose();
         if (this.controls) {
             this.controls.dispose();
diff --git a/data/public/js/components/visualization/effects.js b/data/public/js/components/visualization/effects.js
index ab46ab67..c2ebcb80 100755
--- a/data/public/js/components/visualization/effects.js
+++ b/data/public/js/components/visualization/effects.js
@@ -1,13 +1,14 @@
 import * as THREE from 'three';
-import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
-import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
-import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
-import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
+import { BloomEffect } from './effects/BloomEffect.js';
+import { CompositionEffect } from './effects/CompositionEffect.js';
 import { LAYERS } from './layerManager.js';
 import { visualizationSettings } from '../../services/visualizationSettings.js';
 
 export class EffectsManager {
-    constructor(scene, camera, renderer, settings = {}) {
+    constructor(scene, camera, renderer) {
+        if (!renderer || !renderer.domElement) {
+            throw new Error('Invalid renderer provided to EffectsManager');
+        }
         this.scene = scene;
         this.camera = camera;
         this.renderer = renderer;
@@ -17,287 +18,218 @@ export class EffectsManager {
         this.originalClearAlpha = this.renderer.getClearAlpha();
         this.originalAutoClear = this.renderer.autoClear;
         
-        // Composers for each layer
-        this.composers = new Map();
-        this.finalComposer = null;
-        this.baseComposer = null;
+        // Configure renderer for optimal performance
+        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
+        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
+        this.renderer.toneMappingExposure = 1.0;
         
-        // Create hologram group
-        this.hologramGroup = new THREE.Group();
-        this.scene.add(this.hologramGroup);
+        // Initialize effects as null
+        this.bloomEffect = null;
+        this.compositionEffect = null;
+        this.initialized = false;
         
-        // Get settings
-        this.bloomSettings = visualizationSettings.getBloomSettings();
-        this.hologramSettings = visualizationSettings.getHologramSettings();
+        // XR properties
+        this.isXRActive = false;
+        this.xrRenderTargets = new Map();
+        
+        // Bind methods that need binding
+        this.render = this.render.bind(this);
+        this.handleResize = this.handleResize.bind(this);
+        this.updateBloom = this.updateBloom.bind(this);
+        this.updateFisheye = this.updateFisheye.bind(this);
+        this.dispose = this.dispose.bind(this);
+        
+        // Settings handler - bind and add listener
+        this.handleSettingsUpdate = (event) => {
+            if (!this.initialized) return;
+            try {
+                const settings = event.detail;
+                if (settings.bloom) {
+                    this.updateBloom(settings.bloom);
+                }
+                if (settings.fisheye) {
+                    this.updateFisheye(settings.fisheye);
+                }
+            } catch (error) {
+                console.error('Error handling settings update:', error);
+            }
+        };
         
-        // Bind settings update handler
-        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
         window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
-
-        // XR-specific properties
-        this.xrRenderTarget = null;
-        this.isXRActive = false;
     }
     
-    initPostProcessing() {
-        if (!this.renderer || !this.renderer.domElement) {
-            console.warn('Renderer not ready, deferring post-processing initialization');
-            return;
-        }
+    async initPostProcessing(isXR = false) {
+        try {
+            console.log('Starting post-processing initialization');
+            if (!this.renderer || !this.renderer.domElement) {
+                throw new Error('Renderer not ready for post-processing initialization');
+            }
 
-        // Configure renderer for post-processing
-        this.renderer.autoClear = false;
-        
-        // Create render targets with HDR format
-        const renderTarget = new THREE.WebGLRenderTarget(
-            window.innerWidth,
-            window.innerHeight,
-            {
-                minFilter: THREE.LinearFilter,
-                magFilter: THREE.LinearFilter,
-                format: THREE.RGBAFormat,
-                type: THREE.HalfFloatType,
-                encoding: THREE.sRGBEncoding,
-                stencilBuffer: false,
-                depthBuffer: true
+            // Clean up existing effects if reinitializing
+            if (this.initialized) {
+                this.dispose();
             }
-        );
 
-        // Create XR-compatible render target
-        this.xrRenderTarget = renderTarget.clone();
-        
-        // Create base composer for scene
-        this.baseComposer = new EffectComposer(this.renderer, renderTarget.clone());
-        const basePass = new RenderPass(this.scene, this.camera);
-        basePass.clear = true;
-        this.baseComposer.addPass(basePass);
-        
-        // Create bloom composers for each layer
-        const layers = [
-            {
-                layer: LAYERS.BLOOM,
-                settings: {
-                    strength: this.bloomSettings.nodeBloomStrength * 1.2,
-                    radius: this.bloomSettings.nodeBloomRadius,
-                    threshold: this.bloomSettings.nodeBloomThreshold * 0.8
-                }
-            },
-            {
-                layer: LAYERS.HOLOGRAM,
-                settings: {
-                    strength: this.bloomSettings.environmentBloomStrength * 1.5,
-                    radius: this.bloomSettings.environmentBloomRadius * 1.2,
-                    threshold: this.bloomSettings.environmentBloomThreshold * 0.7
-                }
-            },
-            {
-                layer: LAYERS.EDGE,
-                settings: {
-                    strength: this.bloomSettings.edgeBloomStrength * 1.3,
-                    radius: this.bloomSettings.edgeBloomRadius,
-                    threshold: this.bloomSettings.edgeBloomThreshold * 0.9
-                }
+            // Configure renderer
+            this.renderer.autoClear = false;
+            this.isXRActive = isXR;
+            
+            // Initialize effects with mode-specific settings
+            const bloomSettings = visualizationSettings.getBloomSettings();
+            if (isXR) {
+                // Adjust settings for XR
+                bloomSettings.nodeBloomStrength *= 0.8;
+                bloomSettings.edgeBloomRadius *= 0.7;
+                bloomSettings.environmentBloomThreshold *= 1.2;
             }
-        ];
-        
-        // Create composers for each layer
-        layers.forEach(({ layer, settings }) => {
-            const composer = new EffectComposer(this.renderer, renderTarget.clone());
-            composer.renderToScreen = false;
             
-            const renderPass = new RenderPass(this.scene, this.camera);
-            renderPass.clear = true;
+            // Initialize bloom first
+            console.log('Initializing bloom effect');
+            this.bloomEffect = new BloomEffect(this.renderer, this.scene, this.camera);
+            await this.bloomEffect.init(bloomSettings);
             
-            const bloomPass = new UnrealBloomPass(
-                new THREE.Vector2(window.innerWidth, window.innerHeight),
-                settings.strength,
-                settings.radius,
-                settings.threshold
-            );
+            // Get bloom render targets
+            const bloomRenderTargets = this.bloomEffect.getRenderTargets();
+            if (!bloomRenderTargets) {
+                throw new Error('Failed to get bloom render targets');
+            }
             
-            composer.addPass(renderPass);
-            composer.addPass(bloomPass);
+            // Store XR-specific render targets if needed
+            if (isXR) {
+                this.xrRenderTargets = bloomRenderTargets;
+            }
             
-            this.composers.set(layer, composer);
-        });
-
-        // Create final composer
-        this.finalComposer = new EffectComposer(this.renderer, renderTarget.clone());
-        
-        // Add custom shader pass to combine base scene and bloom layers
-        const finalPass = new ShaderPass(
-            new THREE.ShaderMaterial({
-                uniforms: {
-                    baseTexture: { value: this.baseComposer.renderTarget2.texture },
-                    bloomTexture0: { value: this.composers.get(LAYERS.BLOOM).renderTarget2.texture },
-                    bloomTexture1: { value: this.composers.get(LAYERS.HOLOGRAM).renderTarget2.texture },
-                    bloomTexture2: { value: this.composers.get(LAYERS.EDGE).renderTarget2.texture }
-                },
-                vertexShader: `
-                    varying vec2 vUv;
-                    void main() {
-                        vUv = uv;
-                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
-                    }
-                `,
-                fragmentShader: `
-                    uniform sampler2D baseTexture;
-                    uniform sampler2D bloomTexture0;
-                    uniform sampler2D bloomTexture1;
-                    uniform sampler2D bloomTexture2;
-                    varying vec2 vUv;
-
-                    void main() {
-                        vec4 base = texture2D(baseTexture, vUv);
-                        vec4 bloom0 = texture2D(bloomTexture0, vUv);
-                        vec4 bloom1 = texture2D(bloomTexture1, vUv);
-                        vec4 bloom2 = texture2D(bloomTexture2, vUv);
-                        
-                        // Start with base scene color
-                        vec3 color = base.rgb;
-                        
-                        // Add bloom layers
-                        color += bloom0.rgb;
-                        color += bloom1.rgb;
-                        color += bloom2.rgb;
-                        
-                        // HDR tone mapping
-                        color = color / (vec3(1.0) + color);
-                        
-                        // Gamma correction
-                        color = pow(color, vec3(1.0 / 2.2));
-                        
-                        gl_FragColor = vec4(color, base.a);
-                    }
-                `,
-                transparent: true,
-                depthWrite: false,
-                depthTest: true
-            })
-        );
-        finalPass.clear = false;
-        this.finalComposer.addPass(finalPass);
-
-        // Create hologram structure after composers are ready
-        this.createHologramStructure();
-
-        // Set up XR session listeners
-        this.renderer.xr.addEventListener('sessionstart', () => {
-            this.isXRActive = true;
-            this.handleXRSessionStart();
-        });
-
-        this.renderer.xr.addEventListener('sessionend', () => {
-            this.isXRActive = false;
-            this.handleXRSessionEnd();
-        });
-    }
-
-    handleXRSessionStart() {
-        // Update render targets for XR
-        const session = this.renderer.xr.getSession();
-        if (session) {
-            const baseLayer = session.renderState.baseLayer;
-            const { width, height } = baseLayer.getViewport(session.views[0]);
+            // Initialize composition effect
+            console.log('Initializing composition effect');
+            this.compositionEffect = new CompositionEffect(this.renderer);
+            await this.compositionEffect.init(bloomRenderTargets);
             
-            this.composers.forEach(composer => {
-                composer.setSize(width, height);
-            });
-            this.baseComposer.setSize(width, height);
-            this.finalComposer.setSize(width, height);
+            this.initialized = true;
+            console.log('Post-processing initialization complete');
+            return true;
+        } catch (error) {
+            console.error('Error in post-processing initialization:', error);
+            this.dispose();
+            return false;
         }
     }
-
-    handleXRSessionEnd() {
-        // Reset to normal rendering
-        this.handleResize();
-    }
-
-    createHologramStructure() {
-        // ... (hologram structure code remains unchanged)
-    }
-
-    animate() {
-        // ... (animation code remains unchanged)
-    }
     
     render() {
-        const currentCamera = this.isXRActive ? this.renderer.xr.getCamera() : this.camera;
-        
-        // Clear everything
-        this.renderer.clear(true, true, true);
+        if (!this.initialized || !this.bloomEffect || !this.compositionEffect) {
+            throw new Error('Effects not properly initialized');
+        }
 
-        // Render base scene
-        currentCamera.layers.set(LAYERS.NORMAL_LAYER);
-        this.baseComposer.render();
+        try {
+            const currentCamera = this.isXRActive ? this.renderer.xr.getCamera() : this.camera;
+            
+            // Clear everything
+            this.renderer.clear(true, true, true);
 
-        // Render bloom layers
-        this.composers.forEach((composer, layer) => {
-            currentCamera.layers.set(layer);
-            composer.render();
-        });
-        
-        // Reset camera layers and render final composition
-        currentCamera.layers.set(LAYERS.NORMAL_LAYER);
-        this.finalComposer.render();
+            // Render bloom layers
+            this.bloomEffect.render(currentCamera);
+            
+            // Get appropriate render targets
+            const renderTargets = this.isXRActive ? this.xrRenderTargets : this.bloomEffect.getRenderTargets();
+            if (!renderTargets) {
+                throw new Error('No render targets available');
+            }
+            
+            const baseTexture = renderTargets.get(LAYERS.BLOOM).texture;
+            if (!baseTexture) {
+                throw new Error('No base texture available');
+            }
+            
+            // Reset camera to normal layer and render final composition
+            currentCamera.layers.set(LAYERS.NORMAL_LAYER);
+            this.compositionEffect.render(baseTexture);
+        } catch (error) {
+            throw new Error(`Error during effect rendering: ${error.message}`);
+        }
     }
     
-    handleResize() {
-        const width = window.innerWidth;
-        const height = window.innerHeight;
-        
-        // Resize all composers
-        this.composers.forEach(composer => {
-            composer.setSize(width, height);
-        });
-        
-        if (this.baseComposer) {
-            this.baseComposer.setSize(width, height);
+    handleResize(width = window.innerWidth, height = window.innerHeight) {
+        if (!this.initialized) {
+            return;
         }
-        
-        if (this.finalComposer) {
-            this.finalComposer.setSize(width, height);
+
+        try {
+            if (this.bloomEffect) {
+                this.bloomEffect.resize(width, height);
+            }
+            if (this.compositionEffect) {
+                this.compositionEffect.resize(width, height);
+            }
+        } catch (error) {
+            console.error('Error handling resize:', error);
+            throw error;
         }
     }
     
     updateBloom(settings) {
-        // ... (updateBloom code remains unchanged)
+        if (!this.initialized || !this.bloomEffect) {
+            return;
+        }
+
+        try {
+            // Adjust settings for XR if needed
+            if (this.isXRActive) {
+                settings = {
+                    ...settings,
+                    nodeBloomStrength: settings.nodeBloomStrength * 0.8,
+                    edgeBloomRadius: settings.edgeBloomRadius * 0.7,
+                    environmentBloomThreshold: settings.environmentBloomThreshold * 1.2
+                };
+            }
+            
+            // Reinitialize bloom with new settings
+            this.bloomEffect.init(settings);
+            
+            // Reinitialize composition effect with updated bloom render targets
+            const bloomRenderTargets = this.bloomEffect.getRenderTargets();
+            if (bloomRenderTargets) {
+                if (this.isXRActive) {
+                    this.xrRenderTargets = bloomRenderTargets;
+                }
+                this.compositionEffect.init(bloomRenderTargets);
+            }
+        } catch (error) {
+            console.error('Error updating bloom settings:', error);
+            throw error;
+        }
     }
     
-    handleSettingsUpdate(event) {
-        // ... (handleSettingsUpdate code remains unchanged)
+    updateFisheye(settings) {
+        // Placeholder for future fisheye effect implementation
+        console.log('Fisheye effect not yet implemented');
     }
     
     dispose() {
-        // Restore original renderer settings
-        this.renderer.autoClear = this.originalAutoClear;
-        this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
-        
-        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
-        
-        // Dispose all composers
-        this.composers.forEach(composer => {
-            composer.dispose();
-        });
-        
-        if (this.baseComposer) {
-            this.baseComposer.dispose();
-        }
-        
-        if (this.finalComposer) {
-            this.finalComposer.dispose();
-        }
-
-        // Dispose hologram resources
-        this.hologramGroup.children.forEach(child => {
-            if (child.geometry) child.geometry.dispose();
-            if (child.material) child.material.dispose();
-        });
-        this.scene.remove(this.hologramGroup);
-
-        // Dispose XR render target
-        if (this.xrRenderTarget) {
-            this.xrRenderTarget.dispose();
+        try {
+            // Remove event listeners
+            window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
+            
+            // Restore original renderer settings
+            if (this.renderer) {
+                this.renderer.autoClear = this.originalAutoClear;
+                this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
+            }
+            
+            // Dispose effects
+            if (this.bloomEffect) {
+                this.bloomEffect.dispose();
+                this.bloomEffect = null;
+            }
+            if (this.compositionEffect) {
+                this.compositionEffect.dispose();
+                this.compositionEffect = null;
+            }
+            
+            // Clear XR render targets
+            this.xrRenderTargets.clear();
+            
+            this.initialized = false;
+        } catch (error) {
+            console.error('Error disposing effects:', error);
         }
     }
 }
diff --git a/data/public/js/components/visualization/effects/BloomEffect.js b/data/public/js/components/visualization/effects/BloomEffect.js
new file mode 100755
index 00000000..b8d01559
--- /dev/null
+++ b/data/public/js/components/visualization/effects/BloomEffect.js
@@ -0,0 +1,223 @@
+import * as THREE from 'three';
+import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
+import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
+import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
+import { LAYERS } from '../layerManager.js';
+
+export class BloomEffect {
+    constructor(renderer, scene, camera) {
+        if (!renderer || !renderer.domElement) {
+            throw new Error('Invalid renderer provided to BloomEffect');
+        }
+        this.renderer = renderer;
+        this.scene = scene;
+        this.camera = camera;
+        this.composers = new Map();
+        this.renderTargets = new Map();
+        this.initialized = false;
+
+        // Store original renderer state
+        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
+        this.originalClearAlpha = this.renderer.getClearAlpha();
+    }
+
+    createRenderTarget() {
+        const pixelRatio = this.renderer.getPixelRatio();
+        const width = Math.floor(window.innerWidth * pixelRatio);
+        const height = Math.floor(window.innerHeight * pixelRatio);
+
+        // Use FloatType for WebGL2, UnsignedByteType for WebGL1
+        const isWebGL2 = this.renderer.capabilities.isWebGL2;
+        return new THREE.WebGLRenderTarget(
+            width,
+            height,
+            {
+                minFilter: THREE.LinearFilter,
+                magFilter: THREE.LinearFilter,
+                format: THREE.RGBAFormat,
+                type: isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType,
+                colorSpace: isWebGL2 ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace,
+                stencilBuffer: false,
+                depthBuffer: true,
+                samples: isWebGL2 ? 4 : 0
+            }
+        );
+    }
+
+    init(settings) {
+        if (this.initialized) {
+            this.dispose();
+        }
+
+        if (!this.renderer || !this.renderer.domElement) {
+            console.error('Renderer not ready for bloom effect initialization');
+            return;
+        }
+
+        // Create base render target for scene
+        const baseTarget = this.createRenderTarget();
+        this.renderTargets.set('base', baseTarget);
+
+        // Adjust settings based on WebGL version
+        const isWebGL2 = this.renderer.capabilities.isWebGL2;
+        if (!isWebGL2) {
+            // Reduce quality for WebGL1
+            settings = {
+                ...settings,
+                nodeBloomStrength: settings.nodeBloomStrength * 0.8,
+                nodeBloomRadius: settings.nodeBloomRadius * 0.7,
+                edgeBloomStrength: settings.edgeBloomStrength * 0.8,
+                edgeBloomRadius: settings.edgeBloomRadius * 0.7,
+                environmentBloomStrength: settings.environmentBloomStrength * 0.8,
+                environmentBloomRadius: settings.environmentBloomRadius * 0.7
+            };
+        }
+
+        const layers = [
+            {
+                layer: LAYERS.BLOOM,
+                settings: {
+                    strength: settings.nodeBloomStrength * 2.0,
+                    radius: settings.nodeBloomRadius * 0.5,
+                    threshold: settings.nodeBloomThreshold * 0.5
+                }
+            },
+            {
+                layer: LAYERS.HOLOGRAM,
+                settings: {
+                    strength: settings.environmentBloomStrength * 2.5,
+                    radius: settings.environmentBloomRadius * 0.8,
+                    threshold: settings.environmentBloomThreshold * 0.4
+                }
+            },
+            {
+                layer: LAYERS.EDGE,
+                settings: {
+                    strength: settings.edgeBloomStrength * 1.5,
+                    radius: settings.edgeBloomRadius * 0.7,
+                    threshold: settings.edgeBloomThreshold * 0.6
+                }
+            }
+        ];
+
+        try {
+            // Set renderer color space based on WebGL version
+            this.renderer.outputColorSpace = isWebGL2 ? 
+                THREE.LinearSRGBColorSpace : 
+                THREE.SRGBColorSpace;
+
+            // Create base composer for main scene
+            const baseComposer = new EffectComposer(this.renderer, baseTarget);
+            const baseRenderPass = new RenderPass(this.scene, this.camera);
+            baseRenderPass.clear = true;
+            baseComposer.addPass(baseRenderPass);
+            this.composers.set('base', baseComposer);
+
+            // Create bloom composers for each layer
+            layers.forEach(({ layer, settings }) => {
+                const renderTarget = this.createRenderTarget();
+                this.renderTargets.set(layer, renderTarget);
+                
+                const composer = new EffectComposer(this.renderer, renderTarget);
+                composer.renderToScreen = false;
+                
+                const renderPass = new RenderPass(this.scene, this.camera);
+                renderPass.clear = true;
+                
+                const bloomPass = new UnrealBloomPass(
+                    new THREE.Vector2(window.innerWidth, window.innerHeight),
+                    settings.strength,
+                    settings.radius,
+                    settings.threshold
+                );
+                
+                // Adjust bloom quality based on WebGL version
+                bloomPass.highQualityBloom = isWebGL2;
+                bloomPass.gammaCorrectionInShader = isWebGL2;
+                
+                composer.addPass(renderPass);
+                composer.addPass(bloomPass);
+                
+                this.composers.set(layer, composer);
+            });
+
+            this.initialized = true;
+        } catch (error) {
+            console.error('Error initializing bloom effect:', error);
+            this.dispose();
+        }
+    }
+
+    render(currentCamera) {
+        if (!this.initialized || !currentCamera) return;
+
+        try {
+            // Store original camera layers
+            const originalLayerMask = currentCamera.layers.mask;
+
+            // Render base scene first
+            currentCamera.layers.set(LAYERS.NORMAL_LAYER);
+            this.composers.get('base').render();
+
+            // Render bloom layers
+            this.composers.forEach((composer, layer) => {
+                if (layer !== 'base') {
+                    currentCamera.layers.set(layer);
+                    composer.render();
+                }
+            });
+
+            // Restore camera layers
+            currentCamera.layers.mask = originalLayerMask;
+        } catch (error) {
+            console.error('Error rendering bloom effect:', error);
+        }
+    }
+
+    resize(width, height) {
+        if (!this.initialized) return;
+
+        const pixelRatio = this.renderer.getPixelRatio();
+        const actualWidth = Math.floor(width * pixelRatio);
+        const actualHeight = Math.floor(height * pixelRatio);
+
+        this.renderTargets.forEach(target => {
+            if (target && target.setSize) {
+                target.setSize(actualWidth, actualHeight);
+            }
+        });
+        
+        this.composers.forEach(composer => {
+            if (composer && composer.setSize) {
+                composer.setSize(actualWidth, actualHeight);
+            }
+        });
+    }
+
+    dispose() {
+        this.renderTargets.forEach(target => {
+            if (target && target.dispose) {
+                target.dispose();
+            }
+        });
+        
+        this.composers.forEach(composer => {
+            if (composer && composer.dispose) {
+                composer.dispose();
+            }
+        });
+        
+        if (this.renderer) {
+            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
+        }
+        
+        this.renderTargets.clear();
+        this.composers.clear();
+        this.initialized = false;
+    }
+
+    getRenderTargets() {
+        if (!this.initialized) return null;
+        return this.renderTargets;
+    }
+}
diff --git a/data/public/js/components/visualization/effects/CompositionEffect.js b/data/public/js/components/visualization/effects/CompositionEffect.js
new file mode 100755
index 00000000..cf40f99e
--- /dev/null
+++ b/data/public/js/components/visualization/effects/CompositionEffect.js
@@ -0,0 +1,203 @@
+import * as THREE from 'three';
+import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
+import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
+import { LAYERS } from '../layerManager.js';
+
+export class CompositionEffect {
+    constructor(renderer) {
+        if (!renderer || !renderer.domElement) {
+            throw new Error('Invalid renderer provided to CompositionEffect');
+        }
+        this.renderer = renderer;
+        this.composer = null;
+        this.initialized = false;
+
+        // Store original renderer state
+        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
+        this.originalClearAlpha = this.renderer.getClearAlpha();
+    }
+
+    createRenderTarget() {
+        const pixelRatio = this.renderer.getPixelRatio();
+        const width = Math.floor(window.innerWidth * pixelRatio);
+        const height = Math.floor(window.innerHeight * pixelRatio);
+
+        return new THREE.WebGLRenderTarget(
+            width,
+            height,
+            {
+                minFilter: THREE.LinearFilter,
+                magFilter: THREE.LinearFilter,
+                format: THREE.RGBAFormat,
+                type: THREE.HalfFloatType,
+                colorSpace: THREE.LinearSRGBColorSpace,
+                stencilBuffer: false,
+                depthBuffer: true,
+                samples: this.renderer.capabilities.isWebGL2 ? 4 : 0
+            }
+        );
+    }
+
+    init(bloomRenderTargets) {
+        try {
+            if (this.initialized) {
+                this.dispose();
+            }
+
+            if (!bloomRenderTargets) {
+                throw new Error('No bloom render targets provided');
+            }
+
+            // Verify all required textures are available
+            const requiredLayers = [LAYERS.BLOOM, LAYERS.HOLOGRAM, LAYERS.EDGE];
+            requiredLayers.forEach(layer => {
+                const target = bloomRenderTargets.get(layer);
+                if (!target || !target.texture) {
+                    throw new Error(`Missing bloom render target for layer ${layer}`);
+                }
+            });
+
+            const baseTexture = bloomRenderTargets.get('base')?.texture;
+            if (!baseTexture) {
+                throw new Error('Missing base render target');
+            }
+
+            const renderTarget = this.createRenderTarget();
+            this.composer = new EffectComposer(this.renderer, renderTarget);
+
+            const shader = {
+                uniforms: {
+                    baseTexture: { value: baseTexture },
+                    bloomTexture0: { value: bloomRenderTargets.get(LAYERS.BLOOM).texture },
+                    bloomTexture1: { value: bloomRenderTargets.get(LAYERS.HOLOGRAM).texture },
+                    bloomTexture2: { value: bloomRenderTargets.get(LAYERS.EDGE).texture },
+                    bloomStrength0: { value: 1.5 },
+                    bloomStrength1: { value: 1.2 },
+                    bloomStrength2: { value: 0.8 },
+                    exposure: { value: 1.2 },
+                    gamma: { value: 2.2 },
+                    saturation: { value: 1.2 }
+                },
+                vertexShader: `
+                    varying vec2 vUv;
+                    void main() {
+                        vUv = uv;
+                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+                    }
+                `,
+                fragmentShader: `
+                    uniform sampler2D baseTexture;
+                    uniform sampler2D bloomTexture0;
+                    uniform sampler2D bloomTexture1;
+                    uniform sampler2D bloomTexture2;
+                    uniform float bloomStrength0;
+                    uniform float bloomStrength1;
+                    uniform float bloomStrength2;
+                    uniform float exposure;
+                    uniform float gamma;
+                    uniform float saturation;
+                    
+                    varying vec2 vUv;
+
+                    vec3 adjustSaturation(vec3 color, float saturation) {
+                        float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
+                        return mix(vec3(luminance), color, saturation);
+                    }
+
+                    vec3 toneMap(vec3 color) {
+                        // ACES filmic tone mapping
+                        float a = 2.51;
+                        float b = 0.03;
+                        float c = 2.43;
+                        float d = 0.59;
+                        float e = 0.14;
+                        return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
+                    }
+
+                    void main() {
+                        // Sample all textures in linear space
+                        vec3 baseColor = texture2D(baseTexture, vUv).rgb;
+                        vec3 bloom0 = texture2D(bloomTexture0, vUv).rgb * bloomStrength0;
+                        vec3 bloom1 = texture2D(bloomTexture1, vUv).rgb * bloomStrength1;
+                        vec3 bloom2 = texture2D(bloomTexture2, vUv).rgb * bloomStrength2;
+                        
+                        // Combine bloom layers
+                        vec3 bloomSum = bloom0 + bloom1 + bloom2;
+                        
+                        // Add bloom to base color
+                        vec3 hdrColor = baseColor + bloomSum;
+                        
+                        // Apply exposure
+                        hdrColor *= exposure;
+                        
+                        // Tone mapping
+                        vec3 color = toneMap(hdrColor);
+                        
+                        // Adjust saturation
+                        color = adjustSaturation(color, saturation);
+                        
+                        // Gamma correction
+                        color = pow(color, vec3(1.0 / gamma));
+                        
+                        gl_FragColor = vec4(color, 1.0);
+                    }
+                `
+            };
+
+            const finalPass = new ShaderPass(new THREE.ShaderMaterial(shader));
+            finalPass.renderToScreen = true;
+            finalPass.clear = false;
+            this.composer.addPass(finalPass);
+
+            this.initialized = true;
+        } catch (error) {
+            console.error('Error initializing composition effect:', error);
+            this.dispose();
+        }
+    }
+
+    render(baseTexture) {
+        if (!this.initialized || !this.composer) return;
+
+        try {
+            const finalPass = this.composer.passes[0];
+            if (finalPass && finalPass.uniforms) {
+                finalPass.uniforms.baseTexture.value = baseTexture;
+                this.composer.render();
+            }
+        } catch (error) {
+            console.error('Error rendering composition effect:', error);
+        }
+    }
+
+    resize(width, height) {
+        if (!this.initialized || !this.composer) return;
+
+        try {
+            const pixelRatio = this.renderer.getPixelRatio();
+            const actualWidth = Math.floor(width * pixelRatio);
+            const actualHeight = Math.floor(height * pixelRatio);
+            
+            this.composer.setSize(actualWidth, actualHeight);
+        } catch (error) {
+            console.error('Error resizing composition effect:', error);
+        }
+    }
+
+    dispose() {
+        if (this.composer) {
+            try {
+                this.composer.dispose();
+            } catch (error) {
+                console.error('Error disposing composition effect:', error);
+            }
+        }
+        
+        if (this.renderer) {
+            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
+        }
+        
+        this.composer = null;
+        this.initialized = false;
+    }
+}
diff --git a/data/public/js/components/visualization/layerManager.js b/data/public/js/components/visualization/layerManager.js
old mode 100644
new mode 100755
index 0d703c2e..28fcbcab
--- a/data/public/js/components/visualization/layerManager.js
+++ b/data/public/js/components/visualization/layerManager.js
@@ -1,3 +1,5 @@
+import * as THREE from 'three';
+
 // Layer constants for rendering pipeline
 export const LAYERS = {
     NORMAL_LAYER: 0,  // Base layer for regular rendering
@@ -7,7 +9,7 @@ export const LAYERS = {
     LABEL: 4         // Layer for labels
 };
 
-// Layer groups for optimization
+// Layer groups with specific rendering requirements
 export const LAYER_GROUPS = {
     // Base scene elements (no bloom)
     BASE: [LAYERS.NORMAL_LAYER],
@@ -15,10 +17,10 @@ export const LAYER_GROUPS = {
     // Elements that should have bloom
     BLOOM: [LAYERS.NORMAL_LAYER, LAYERS.BLOOM],
     
-    // Hologram elements
+    // Hologram elements with enhanced bloom
     HOLOGRAM: [LAYERS.NORMAL_LAYER, LAYERS.HOLOGRAM],
     
-    // Edge elements
+    // Edge elements with subtle bloom
     EDGE: [LAYERS.NORMAL_LAYER, LAYERS.EDGE],
     
     // Label elements (should be visible in all layers)
@@ -31,18 +33,66 @@ export const LAYER_GROUPS = {
     ]
 };
 
-// Helper functions for layer management
+// Material presets for different layer groups
+const MATERIAL_PRESETS = {
+    BLOOM: {
+        emissiveIntensity: 1.0,
+        transparent: true,
+        opacity: 0.9,
+        blending: THREE.AdditiveBlending,
+        depthWrite: false,
+        toneMapped: false
+    },
+    HOLOGRAM: {
+        emissiveIntensity: 1.5,
+        transparent: true,
+        opacity: 0.7,
+        blending: THREE.AdditiveBlending,
+        depthWrite: false,
+        toneMapped: false
+    },
+    EDGE: {
+        emissiveIntensity: 0.8,
+        transparent: true,
+        opacity: 0.6,
+        blending: THREE.NormalBlending,
+        depthWrite: true,
+        toneMapped: false
+    }
+};
+
+// Enhanced LayerManager with better type checking and error handling
 export const LayerManager = {
     // Enable multiple layers for an object
     enableLayers(object, layers) {
+        if (!object || !object.layers) {
+            console.error('Invalid object provided to enableLayers');
+            return;
+        }
+
         if (!Array.isArray(layers)) {
             layers = [layers];
         }
-        layers.forEach(layer => object.layers.enable(layer));
+
+        // Reset layers before enabling new ones
+        object.layers.mask = 0;
+        
+        layers.forEach(layer => {
+            if (typeof layer === 'number' && layer >= 0) {
+                object.layers.enable(layer);
+            } else {
+                console.warn(`Invalid layer value: ${layer}`);
+            }
+        });
     },
 
-    // Set object to specific layer group
+    // Set object to specific layer group with material optimization
     setLayerGroup(object, groupName) {
+        if (!object || !object.layers) {
+            console.error('Invalid object provided to setLayerGroup');
+            return;
+        }
+
         const layers = LAYER_GROUPS[groupName];
         if (!layers) {
             console.warn(`Unknown layer group: ${groupName}`);
@@ -54,21 +104,122 @@ export const LayerManager = {
         
         // Enable all layers in group
         layers.forEach(layer => object.layers.enable(layer));
+
+        // Apply material presets if object has material
+        if (object.material && MATERIAL_PRESETS[groupName]) {
+            // Clone material to avoid affecting other objects
+            if (!object.material._isCloned) {
+                object.material = object.material.clone();
+                object.material._isCloned = true;
+            }
+            
+            // Apply preset properties
+            Object.assign(object.material, MATERIAL_PRESETS[groupName]);
+            
+            // Special handling for emissive color
+            if (object.material.color && object.material.emissive) {
+                object.material.emissive.copy(object.material.color);
+            }
+        }
     },
 
-    // Check if object is in layer
+    // Check if object is in layer with proper type checking
     isInLayer(object, layer) {
+        if (!object || !object.layers || typeof layer !== 'number') {
+            return false;
+        }
         return object.layers.test(new THREE.Layers().set(layer));
     },
 
-    // Get all objects in a specific layer
-    getObjectsInLayer(scene, layer) {
+    // Get all objects in a specific layer with filtering options
+    getObjectsInLayer(scene, layer, options = {}) {
+        if (!scene || typeof layer !== 'number') {
+            console.error('Invalid parameters provided to getObjectsInLayer');
+            return [];
+        }
+
         const objects = [];
+        const {
+            includeInvisible = false,
+            includeHelpers = false
+        } = options;
+
         scene.traverse(object => {
             if (this.isInLayer(object, layer)) {
+                if (!includeInvisible && !object.visible) return;
+                if (!includeHelpers && object.isHelper) return;
                 objects.push(object);
             }
         });
         return objects;
+    },
+
+    // Get objects that should receive bloom
+    getBloomObjects(scene) {
+        return this.getObjectsInLayer(scene, LAYERS.BLOOM).concat(
+            this.getObjectsInLayer(scene, LAYERS.HOLOGRAM),
+            this.getObjectsInLayer(scene, LAYERS.EDGE)
+        );
+    },
+
+    // Optimize material for bloom rendering
+    optimizeForBloom(object, intensity = 1.0) {
+        if (!object || !object.material) return;
+
+        // Clone material to avoid affecting other objects
+        if (!object.material._isCloned) {
+            object.material = object.material.clone();
+            object.material._isCloned = true;
+        }
+
+        // Apply bloom-specific optimizations
+        object.material.toneMapped = false;
+        object.material.transparent = true;
+        object.material.blending = THREE.AdditiveBlending;
+        object.material.depthWrite = false;
+        
+        if (object.material.emissive) {
+            object.material.emissive.copy(object.material.color || new THREE.Color(1, 1, 1));
+            object.material.emissiveIntensity = intensity;
+        }
+    },
+
+    // Reset object to base layer
+    resetToBaseLayer(object) {
+        if (!object || !object.layers) return;
+        
+        object.layers.set(LAYERS.NORMAL_LAYER);
+        
+        if (object.material && object.material._isCloned) {
+            object.material.dispose();
+            object.material = new THREE.MeshStandardMaterial({
+                color: object.material.color,
+                transparent: false,
+                toneMapped: true,
+                emissiveIntensity: 0
+            });
+            object.material._isCloned = false;
+        }
+    },
+
+    // Check if object should receive bloom
+    shouldReceiveBloom(object) {
+        return this.isInLayer(object, LAYERS.BLOOM) ||
+               this.isInLayer(object, LAYERS.HOLOGRAM) ||
+               this.isInLayer(object, LAYERS.EDGE);
+    },
+
+    // Create a bloom-optimized material
+    createBloomMaterial(color, intensity = 1.0) {
+        return new THREE.MeshPhysicalMaterial({
+            color: color,
+            emissive: color,
+            emissiveIntensity: intensity,
+            transparent: true,
+            opacity: 0.9,
+            blending: THREE.AdditiveBlending,
+            depthWrite: false,
+            toneMapped: false
+        });
     }
 };
diff --git a/data/public/js/components/visualization/nodes.js b/data/public/js/components/visualization/nodes.js
index 6390d64c..f0fb0d64 100755
--- a/data/public/js/components/visualization/nodes.js
+++ b/data/public/js/components/visualization/nodes.js
@@ -38,9 +38,70 @@ export class NodeManager {
         this.edgeColor = new THREE.Color(settings.edgeColor || edgeSettings.color);
         this.edgeOpacity = settings.edgeOpacity || edgeSettings.opacity;
 
+        // Bind event handlers
         this.handleClick = this.handleClick.bind(this);
+        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
+        
+        // Add settings update listener
+        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
+
         this.xrEnabled = false;
         this.xrLabelManager = null;
+
+        // Create frustum for label visibility checks
+        this.frustum = new THREE.Frustum();
+        this.projScreenMatrix = new THREE.Matrix4();
+    }
+
+    handleSettingsUpdate(event) {
+        const settings = event.detail;
+        if (!settings) return;
+
+        if (settings.visual) {
+            // Update visual settings
+            if (settings.visual.nodeColor !== undefined) {
+                this.updateFeature('nodeColor', settings.visual.nodeColor);
+            }
+            if (settings.visual.minNodeSize !== undefined) {
+                this.updateFeature('minNodeSize', settings.visual.minNodeSize);
+            }
+            if (settings.visual.maxNodeSize !== undefined) {
+                this.updateFeature('maxNodeSize', settings.visual.maxNodeSize);
+            }
+            if (settings.visual.labelFontSize !== undefined) {
+                this.updateFeature('labelFontSize', settings.visual.labelFontSize);
+            }
+            if (settings.visual.edgeColor !== undefined) {
+                this.updateFeature('edgeColor', settings.visual.edgeColor);
+            }
+            if (settings.visual.edgeOpacity !== undefined) {
+                this.updateFeature('edgeOpacity', settings.visual.edgeOpacity);
+            }
+        }
+
+        if (settings.material) {
+            this.updateMaterial(settings.material);
+        }
+
+        // Update node colors if age-based colors are changed
+        if (settings.ageColors) {
+            if (settings.ageColors.new) this.ageColors.NEW.set(settings.ageColors.new);
+            if (settings.ageColors.recent) this.ageColors.RECENT.set(settings.ageColors.recent);
+            if (settings.ageColors.medium) this.ageColors.MEDIUM.set(settings.ageColors.medium);
+            if (settings.ageColors.old) this.ageColors.OLD.set(settings.ageColors.old);
+            
+            // Update all nodes to reflect new colors
+            this.nodeMeshes.forEach((mesh, nodeId) => {
+                const nodeData = this.nodeData.get(nodeId);
+                if (nodeData) {
+                    const color = this.calculateNodeColor(nodeData.metadata || {});
+                    if (mesh.material) {
+                        mesh.material.color.copy(color);
+                        mesh.material.emissive.copy(color);
+                    }
+                }
+            });
+        }
     }
 
     centerNodes(nodes) {
@@ -93,9 +154,9 @@ export class NodeManager {
 
     formatNodeNameToUrl(nodeName) {
         // Get base URL from environment or default to logseq
-        const baseUrl = window.location.origin;
-        // Convert node name to lowercase and replace spaces with dashes
-        const formattedName = nodeName.toLowerCase().replace(/ /g, '-');
+        const baseUrl = 'https://www.narrativegoldmine.com';
+        // Convert node name to lowercase and properly encode for URLs
+        const formattedName = encodeURIComponent(nodeName.toLowerCase());
         return `${baseUrl}/#/page/${formattedName}`;
     }
 
@@ -169,11 +230,20 @@ export class NodeManager {
             existingLabel.material.dispose();
         }
 
+        // Create canvas with alpha support
         const canvas = document.createElement('canvas');
         const context = canvas.getContext('2d', {
             alpha: true,
-            desynchronized: true // Optimize for performance
+            desynchronized: true,
+            willReadFrequently: false
         });
+
+        if (!context) {
+            console.error('Failed to get 2D context for label');
+            return null;
+        }
+
+        // Set initial font to measure text
         context.font = `${this.labelFontSize}px Arial`;
         
         // Get metadata values
@@ -182,7 +252,7 @@ export class NodeManager {
         const hyperlinkCount = parseInt(metadata.hyperlink_count) || 0;
         const githubInfo = metadata.github_info || {};
         
-        // Measure and create text
+        // Measure text dimensions
         const nameMetrics = context.measureText(text);
         let infoText = `${this.formatFileSize(fileSize)} | ${this.formatAge(lastModified)} | ${hyperlinkCount} links`;
         if (githubInfo.author) {
@@ -196,46 +266,73 @@ export class NodeManager {
         const infoMetrics = context.measureText(infoText);
         const textWidth = Math.max(nameMetrics.width, infoMetrics.width);
         
-        // Set canvas size to power of 2 for better texture performance
-        const canvasWidth = Math.pow(2, Math.ceil(Math.log2(textWidth + 20)));
-        const canvasHeight = Math.pow(2, Math.ceil(Math.log2(this.labelFontSize * 2 + 30)));
+        // Calculate power-of-2 dimensions with padding
+        const padding = 20;
+        const canvasWidth = Math.pow(2, Math.ceil(Math.log2(textWidth + padding * 2)));
+        const canvasHeight = Math.pow(2, Math.ceil(Math.log2(this.labelFontSize * 3)));
+
+        // Set canvas size
         canvas.width = canvasWidth;
         canvas.height = canvasHeight;
 
-        // Draw background with higher opacity
-        context.fillStyle = 'rgba(0, 0, 0, 0.9)'; // Increased opacity for better visibility
-        context.fillRect(0, 0, canvas.width, canvas.height);
+        // Clear canvas with transparent background
+        context.clearRect(0, 0, canvas.width, canvas.height);
 
-        // Draw text with enhanced contrast
+        // Draw semi-transparent background with rounded corners
+        context.fillStyle = visualizationSettings.getLabelSettings().backgroundColor;
+        const cornerRadius = 8;
+        this.roundRect(context, 0, 0, canvas.width, canvas.height, cornerRadius);
+
+        // Reset font after canvas resize
         context.font = `${this.labelFontSize}px ${visualizationSettings.getLabelSettings().fontFamily}`;
-        context.fillStyle = '#ffffff'; // Pure white for better visibility
-        context.fillText(text, 10, this.labelFontSize);
+        context.textBaseline = 'middle';
+        context.textAlign = 'left';
+
+        // Enable text anti-aliasing
+        context.imageSmoothingEnabled = true;
+        context.imageSmoothingQuality = 'high';
+
+        // Draw main text with shadow
+        context.shadowColor = 'rgba(0, 0, 0, 0.5)';
+        context.shadowBlur = 4;
+        context.shadowOffsetX = 2;
+        context.shadowOffsetY = 2;
+        context.fillStyle = visualizationSettings.getLabelSettings().textColor;
+        context.fillText(text, padding, canvas.height * 0.35);
+        
+        // Reset shadow for info text
+        context.shadowColor = 'transparent';
+        context.shadowBlur = 0;
+        context.shadowOffsetX = 0;
+        context.shadowOffsetY = 0;
         
-        context.font = `${this.labelFontSize / 2}px ${visualizationSettings.getLabelSettings().fontFamily}`;
-        context.fillStyle = '#cccccc'; // Light gray for info text
-        context.fillText(infoText, 10, this.labelFontSize + 20);
+        // Draw info text
+        context.font = `${this.labelFontSize * 0.6}px ${visualizationSettings.getLabelSettings().fontFamily}`;
+        context.fillStyle = visualizationSettings.getLabelSettings().infoTextColor;
+        context.fillText(infoText, padding, canvas.height * 0.7);
 
-        // Create sprite with optimized texture and material settings
+        // Create optimized texture
         const texture = new THREE.CanvasTexture(canvas);
         texture.generateMipmaps = false;
         texture.minFilter = THREE.LinearFilter;
         texture.magFilter = THREE.LinearFilter;
         texture.format = THREE.RGBAFormat;
+        texture.needsUpdate = true;
         
+        // Create sprite material with proper blending
         const spriteMaterial = new THREE.SpriteMaterial({
             map: texture,
             transparent: true,
-            opacity: 1.0, // Full opacity
             depthWrite: false,
             depthTest: true,
+            blending: THREE.NormalBlending,
             sizeAttenuation: true,
-            toneMapped: false,
-            blending: THREE.NormalBlending
+            toneMapped: false
         });
 
         const sprite = new THREE.Sprite(spriteMaterial);
         
-        // Scale sprite to maintain readable text size in meters
+        // Scale sprite based on canvas dimensions
         const labelScale = visualizationSettings.getLabelSettings().verticalOffset;
         sprite.scale.set(
             (canvas.width / this.labelFontSize) * labelScale * 1.5,
@@ -243,17 +340,32 @@ export class NodeManager {
             1
         );
         
-        // Set label to be visible in all necessary layers
+        // Set proper layer for rendering
         LayerManager.setLayerGroup(sprite, 'LABEL');
 
-        // Ensure sprite is always facing the camera
-        sprite.onBeforeRender = (renderer, scene, camera) => {
-            sprite.quaternion.copy(camera.quaternion);
-        };
+        // Clean up canvas
+        canvas.width = 1;
+        canvas.height = 1;
 
         return sprite;
     }
 
+    // Helper function for rounded rectangles
+    roundRect(ctx, x, y, width, height, radius) {
+        ctx.beginPath();
+        ctx.moveTo(x + radius, y);
+        ctx.lineTo(x + width - radius, y);
+        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
+        ctx.lineTo(x + width, y + height - radius);
+        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
+        ctx.lineTo(x + radius, y + height);
+        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
+        ctx.lineTo(x, y + radius);
+        ctx.quadraticCurveTo(x, y, x + radius, y);
+        ctx.closePath();
+        ctx.fill();
+    }
+
     handleClick(event, isXR = false, intersectedObject = null) {
         let clickedMesh;
 
@@ -494,19 +606,58 @@ export class NodeManager {
     }
 
     updateLabelOrientations(camera) {
+        // Update frustum for visibility checks
+        this.projScreenMatrix.multiplyMatrices(
+            camera.projectionMatrix,
+            camera.matrixWorldInverse
+        );
+        this.frustum.setFromProjectionMatrix(this.projScreenMatrix);
+
         this.nodeLabels.forEach((label, nodeId) => {
             const mesh = this.nodeMeshes.get(nodeId);
             if (mesh) {
                 const size = mesh.geometry.parameters.radius || 
                            mesh.geometry.parameters.width || 
                            this.minNodeSize;
-                const labelOffset = size * 1.5; // Increased offset
+                
+                // Get label settings
+                const labelSettings = visualizationSettings.getLabelSettings();
+                const verticalOffset = labelSettings.verticalOffset || 0.8;
+                
+                // Calculate label position with proper offset
+                const labelOffset = size * 3.0 * verticalOffset; // Increased offset for better visibility
+                
+                // Position label above node
                 label.position.set(
                     mesh.position.x,
                     mesh.position.y + labelOffset,
                     mesh.position.z
                 );
+
+                // Make label face camera
                 label.lookAt(camera.position);
+
+                // Calculate distance to camera
+                const distance = camera.position.distanceTo(mesh.position);
+                
+                // Scale label based on distance with improved visibility
+                const baseScale = 0.8; // Base scale factor
+                const distanceScale = Math.max(0.8, Math.min(2.0, distance * 0.04));
+                const finalScale = baseScale * distanceScale;
+                
+                // Apply scale
+                label.scale.set(finalScale, finalScale, 1);
+
+                // Check if node is in view frustum and not too far
+                const inView = this.frustum.containsPoint(mesh.position);
+                const notTooFar = distance < 100;
+                label.visible = inView && notTooFar;
+
+                // Adjust opacity based on distance
+                if (label.material) {
+                    const opacity = Math.max(0.2, 1 - (distance / 100));
+                    label.material.opacity = opacity;
+                }
             }
         });
     }
@@ -572,37 +723,6 @@ export class NodeManager {
             emissiveMinIntensity: settings.emissiveMinIntensity ?? this.materialSettings.emissiveMinIntensity,
             emissiveMaxIntensity: settings.emissiveMaxIntensity ?? this.materialSettings.emissiveMaxIntensity
         };
-
-        // Update all existing node materials
-        this.nodeMeshes.forEach((mesh, nodeId) => {
-            const nodeData = this.nodeData.get(nodeId);
-            if (nodeData && mesh.material) {
-                // Create new material with updated settings
-                mesh.material.dispose(); // Dispose old material
-                mesh.material = this.createNodeMaterial(mesh.material.color, nodeData.metadata || {});
-            }
-        });
-    }
-
-    updateEdgesForNode(nodeId) {
-        this.edgeMeshes.forEach((line, edgeKey) => {
-            const [source, target] = edgeKey.split('-');
-            if (source === nodeId || target === nodeId) {
-                const positions = line.geometry.attributes.position.array;
-                const sourceMesh = this.nodeMeshes.get(source);
-                const targetMesh = this.nodeMeshes.get(target);
-
-                if (sourceMesh && targetMesh) {
-                    positions[0] = sourceMesh.position.x;
-                    positions[1] = sourceMesh.position.y;
-                    positions[2] = sourceMesh.position.z;
-                    positions[3] = targetMesh.position.x;
-                    positions[4] = targetMesh.position.y;
-                    positions[5] = targetMesh.position.z;
-                    line.geometry.attributes.position.needsUpdate = true;
-                }
-            }
-        });
     }
 
     getNodePositions() {
@@ -614,6 +734,13 @@ export class NodeManager {
     }
 
     dispose() {
+        // Remove event listeners
+        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
+        
+        if (this.renderer) {
+            this.removeClickHandling(this.renderer);
+        }
+
         // Dispose node resources
         this.nodeMeshes.forEach(mesh => {
             if (mesh.geometry) {
@@ -667,10 +794,25 @@ export class NodeManager {
         this.nodeLabels.clear();
         this.edgeMeshes.clear();
         this.nodeData.clear();
+    }
 
-        // Clean up event listeners
-        if (this.renderer) {
-            this.removeClickHandling(this.renderer);
+    initInstancedMeshes() {
+        console.log('Initializing instanced meshes');
+        try {
+            // ... existing initialization code ...
+            
+            // Verify initialization
+            console.log('Instanced meshes created:', {
+                nodeCount: this.nodeInstanceCount,
+                linkCount: this.linkInstanceCount,
+                highDetailMesh: !!this.nodeInstancedMeshes.high,
+                mediumDetailMesh: !!this.nodeInstancedMeshes.medium,
+                lowDetailMesh: !!this.nodeInstancedMeshes.low,
+                linkMesh: !!this.linkInstancedMesh
+            });
+        } catch (error) {
+            console.error('Error initializing instanced meshes:', error);
+            throw error;
         }
     }
 }
diff --git a/data/public/js/components/visualization/textRenderer.js b/data/public/js/components/visualization/textRenderer.js
old mode 100644
new mode 100755
diff --git a/data/public/js/gpuUtils.js b/data/public/js/gpuUtils.js
index 7b20497f..74322091 100755
--- a/data/public/js/gpuUtils.js
+++ b/data/public/js/gpuUtils.js
@@ -1,50 +1,85 @@
 // public/js/gpuUtils.js
 
 /**
- * Checks if the GPU is available for acceleration.
- * @returns {boolean} True if GPU is available, false otherwise.
+ * GPU/WebGL utilities for rendering
+ * Note: Force-directed calculations are now handled server-side
+ */
+
+/**
+ * Check if GPU/WebGL is available for rendering
+ * @returns {boolean} True if GPU rendering is available
  */
 export function isGPUAvailable() {
-  try {
-      const canvas = document.createElement('canvas');
-      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
-      return !!gl;
-  } catch (e) {
-      console.error('GPU availability check failed:', e);
-      return false;
-  }
+    try {
+        const canvas = document.createElement('canvas');
+        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
+        const isAvailable = !!gl;
+        
+        if (!gl) {
+            console.warn('WebGL not available, rendering may be limited');
+            return false;
+        }
+
+        // Check if it's WebGL 2
+        if (gl instanceof WebGL2RenderingContext) {
+            console.log('WebGL 2 available');
+        } else {
+            console.log('WebGL 1 available');
+        }
+
+        return isAvailable;
+    } catch (error) {
+        console.error('Error checking GPU availability:', error);
+        return false;
+    }
 }
 
 /**
-* Initializes GPU computation utilities.
-* @returns {object} An object containing GPU-related methods.
-*/
+ * Initialize GPU/WebGL context
+ * @returns {object|null} GPU context if available
+ */
 export function initGPU() {
-  // Placeholder for GPU computation initialization
-  console.log('Initializing GPU utilities.');
-
-  // Implement GPU-related initializations here, such as setting up compute shaders
-  // For this example, we'll return an empty object
-  return {
-      compute: (data) => {
-          // Implement GPU computation logic here
-          console.log('Performing GPU computation with data:', data);
-      }
-  };
+    if (isGPUAvailable()) {
+        return {
+            initialized: true,
+            webgl2: typeof WebGL2RenderingContext !== 'undefined' && 
+                   document.createElement('canvas').getContext('webgl2') instanceof WebGL2RenderingContext
+        };
+    }
+    return null;
 }
 
 /**
-* Performs computations on the GPU.
-* @param {object} gpu - The GPU utilities object.
-* @param {object} data - The data to compute.
-* @returns {boolean} True if computation was successful, false otherwise.
-*/
-export function computeOnGPU(gpu, data) {
-  if (gpu && typeof gpu.compute === 'function') {
-      gpu.compute(data);
-      return true;
-  } else {
-      console.warn('GPU compute function is not available.');
-      return false;
-  }
+ * Apply position updates received from server
+ * @param {Float32Array} buffer - Binary position data from server
+ * @returns {object} Processed position data
+ */
+export function processPositionUpdate(buffer) {
+    try {
+        const dataView = new Float32Array(buffer);
+        const isInitialLayout = dataView[0] === 1.0;
+        const positions = [];
+        
+        // Skip header (first float32)
+        for (let i = 1; i < dataView.length; i += 6) {
+            if (i + 5 < dataView.length) {
+                positions.push({
+                    x: dataView[i],
+                    y: dataView[i + 1],
+                    z: dataView[i + 2],
+                    vx: dataView[i + 3],
+                    vy: dataView[i + 4],
+                    vz: dataView[i + 5]
+                });
+            }
+        }
+
+        return {
+            isInitialLayout,
+            positions
+        };
+    } catch (error) {
+        console.error('Error processing position update:', error);
+        return null;
+    }
 }
diff --git a/data/public/js/index.js b/data/public/js/index.js
index 8e09eb5e..7dc49cbe 100755
--- a/data/public/js/index.js
+++ b/data/public/js/index.js
@@ -1,117 +1,6 @@
-import { createApp } from 'vue';
-import WebsocketService from './services/websocketService.js';
-import { WebXRVisualization } from './components/visualization/core.js';
-import ControlPanel from './components/ControlPanel.vue';
+// data/public/js/index.js
 
-class App {
-    constructor() {
-        // Initialize WebSocket service first
-        this.websocketService = new WebsocketService();
-        
-        // Initialize visualization with the websocket service as the graph data manager
-        this.visualization = new WebXRVisualization(this.websocketService);
-        this.vueApp = null;
-
-        // Set up graph data handling
-        this.websocketService.on('graphUpdate', ({ graphData }) => {
-            console.log('Received graph update:', graphData);
-            if (this.visualization) {
-                this.visualization.updateVisualization(graphData);
-            }
-        });
-    }
-
-    async start() {
-        try {
-            // Initialize WebSocket connection
-            await this.websocketService.connect();
-            
-            // Initialize visualization
-            const container = document.getElementById('scene-container');
-            if (!container) {
-                throw new Error("Could not find 'scene-container' element");
-            }
-            await this.visualization.initThreeJS(container);
-            
-            // Create Vue application
-            const websocketService = this.websocketService;
-            const visualization = this.visualization;
-            
-            this.vueApp = createApp({
-                components: {
-                    ControlPanel
-                },
-                setup() {
-                    return {
-                        websocketService,
-                        handleControlChange(change) {
-                            console.log('Control changed:', change);
-                            visualization.updateSettings(change);
-                        }
-                    };
-                },
-                template: `
-                    <div class="app-wrapper">
-                        <ControlPanel 
-                            :websocket-service="websocketService"
-                            @control-change="handleControlChange"
-                        />
-                    </div>
-                `
-            });
-
-            // Mount the application
-            const appContainer = document.getElementById('app');
-            if (!appContainer) {
-                throw new Error("Could not find 'app' element");
-            }
-            this.vueApp.mount(appContainer);
-
-            // Update connection status
-            this.websocketService.on('connect', () => {
-                const statusEl = document.getElementById('connection-status');
-                if (statusEl) {
-                    statusEl.textContent = 'Connected';
-                    statusEl.className = 'connected';
-                }
-            });
-
-            this.websocketService.on('disconnect', () => {
-                const statusEl = document.getElementById('connection-status');
-                if (statusEl) {
-                    statusEl.textContent = 'Disconnected';
-                    statusEl.className = 'disconnected';
-                }
-            });
-
-            // Handle window resize
-            window.addEventListener('resize', () => {
-                if (this.visualization) {
-                    this.visualization.onWindowResize();
-                }
-            });
-
-            // Request initial data
-            this.websocketService.send({ type: 'getInitialData' });
-
-        } catch (error) {
-            console.error('Failed to start application:', error);
-            throw error;
-        }
-    }
-
-    stop() {
-        if (this.visualization) {
-            this.visualization.dispose();
-        }
-        if (this.websocketService) {
-            this.websocketService.disconnect();
-        }
-        if (this.vueApp) {
-            this.vueApp.unmount();
-        }
-    }
-}
+import { App } from './app.js';
 
 // Initialize application when DOM is ready
 document.addEventListener('DOMContentLoaded', () => {
@@ -125,5 +14,3 @@ document.addEventListener('DOMContentLoaded', () => {
         app.stop();
     });
 });
-
-export { App };
diff --git a/data/public/js/services/graphDataManager.js b/data/public/js/services/graphDataManager.js
index 9f552275..683b0338 100755
--- a/data/public/js/services/graphDataManager.js
+++ b/data/public/js/services/graphDataManager.js
@@ -4,61 +4,60 @@
  * GraphDataManager handles the management and updating of graph data received from the server.
  */
 export class GraphDataManager {
-    websocketService = null;
-    graphData = null;
-    forceDirectedParams = {
-        iterations: 250,
-        spring_strength: 0.1,
-        repulsion_strength: 1000,
-        attraction_strength: 0.01,
-        damping: 0.8,
-        time_step: 0.5  // Add default time_step
-    };
-    pendingRecalculation = false;
-    initialLayoutDone = false;
-
-    /**
-     * Creates a new GraphDataManager instance.
-     * @param {WebsocketService} websocketService - The WebSocket service instance.
-     */
     constructor(websocketService) {
         this.websocketService = websocketService;
+        this.graphData = null;
+        
         console.log('GraphDataManager initialized');
         
-        // Use arrow functions for event handlers to preserve this context
-        this.websocketService.on('graphUpdate', this.handleGraphUpdate);
-        this.websocketService.on('gpuPositions', this.handleGPUPositions);
+        // Bind methods to preserve this context
+        this.handleGraphUpdate = this.handleGraphUpdate.bind(this);
+        this.handleBinaryPositionUpdate = this.handleBinaryPositionUpdate.bind(this);
+        
+        // Set up event listeners
+        if (this.websocketService) {
+            this.websocketService.on('graphUpdate', this.handleGraphUpdate);
+            this.websocketService.on('gpuPositions', this.handleBinaryPositionUpdate);
+
+            // Debug listener for websocket connection state
+            this.websocketService.on('connect', () => {
+                console.log('GraphDataManager detected websocket connection');
+                this.requestInitialData();
+            });
+        } else {
+            console.error('GraphDataManager initialized without websocket service');
+        }
     }
 
-    requestInitialData = () => {
+    requestInitialData() {
         console.log('Requesting initial data');
-        this.websocketService.send({ type: 'getInitialData' });
+        if (this.websocketService) {
+            this.websocketService.send({ type: 'getInitialData' });
+        }
     }
 
-    handleGPUPositions = (update) => {
+    handleBinaryPositionUpdate(update) {
         if (!this.graphData || !this.graphData.nodes) {
-            console.error('Cannot apply GPU position update: No graph data exists');
+            console.error('Cannot apply position update: No graph data exists');
             return;
         }
 
         const { positions } = update;
-        console.log('Received GPU position update:', positions);
+        console.log('Received position update for', positions.length, 'nodes');
         
         // Transform position array into node objects
         const updatedNodes = this.graphData.nodes.map((node, index) => {
             if (positions[index]) {
                 const pos = positions[index];
-                if (Array.isArray(pos) && pos.length >= 6) {
-                    return {
-                        ...node,
-                        x: pos[0],
-                        y: pos[1],
-                        z: pos[2],
-                        vx: pos[3],
-                        vy: pos[4],
-                        vz: pos[5]
-                    };
-                }
+                return {
+                    ...node,
+                    x: pos.x,
+                    y: pos.y,
+                    z: pos.z,
+                    vx: pos.vx,
+                    vy: pos.vy,
+                    vz: pos.vz
+                };
             }
             return node;
         });
@@ -69,7 +68,7 @@ export class GraphDataManager {
             nodes: updatedNodes
         };
 
-        // Notify visualization of position updates with structured data
+        // Notify visualization of position updates
         window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
             detail: {
                 nodes: this.graphData.nodes,
@@ -79,7 +78,7 @@ export class GraphDataManager {
         }));
     }
 
-    handleGraphUpdate = (data) => {
+    handleGraphUpdate(data) {
         console.log('Received graph update:', data);
         if (!data || !data.graphData) {
             console.error('Invalid graph update data received:', data);
@@ -88,7 +87,7 @@ export class GraphDataManager {
         this.updateGraphData(data.graphData);
     }
 
-    updateGraphData = (newData) => {
+    updateGraphData(newData) {
         console.log('Updating graph data with:', newData);
         
         if (!newData) {
@@ -107,23 +106,11 @@ export class GraphDataManager {
                 const existingNode = this.graphData?.nodes?.find(n => n.id === node.id);
                 const nodeMetadata = metadata[`${node.id}.md`] || {};
                 
-                // Keep existing velocities if available, otherwise initialize to 0
-                const vx = existingNode?.vx || 0;
-                const vy = existingNode?.vy || 0;
-                const vz = existingNode?.vz || 0;
-
-                // Use new position if valid, otherwise keep existing or initialize to 0
-                const x = (typeof node.x === 'number' && !isNaN(node.x)) ? node.x : 
-                         (existingNode?.x || 0);
-                const y = (typeof node.y === 'number' && !isNaN(node.y)) ? node.y :
-                         (existingNode?.y || 0);
-                const z = (typeof node.z === 'number' && !isNaN(node.z)) ? node.z :
-                         (existingNode?.z || 0);
-
                 return {
                     ...node,
-                    x, y, z,
-                    vx, vy, vz,
+                    x: (typeof node.x === 'number' && !isNaN(node.x)) ? node.x : (existingNode?.x || 0),
+                    y: (typeof node.y === 'number' && !isNaN(node.y)) ? node.y : (existingNode?.y || 0),
+                    z: (typeof node.z === 'number' && !isNaN(node.z)) ? node.z : (existingNode?.z || 0),
                     metadata: nodeMetadata
                 };
             });
@@ -149,13 +136,9 @@ export class GraphDataManager {
                 return {
                     id,
                     label: id,
-                    // Preserve existing position and velocity if available
                     x: existingNode?.x || 0,
                     y: existingNode?.y || 0,
                     z: existingNode?.z || 0,
-                    vx: existingNode?.vx || 0,
-                    vy: existingNode?.vy || 0,
-                    vz: existingNode?.vz || 0,
                     metadata: nodeMetadata
                 };
             });
@@ -176,9 +159,8 @@ export class GraphDataManager {
         }
 
         console.log(`Graph data updated: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
-        console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
         
-        // Dispatch an event to notify that the graph data has been updated with structured data
+        // Dispatch update event
         window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
             detail: {
                 nodes: this.graphData.nodes,
@@ -186,23 +168,9 @@ export class GraphDataManager {
                 metadata: this.graphData.metadata
             }
         }));
-
-        // If there was a pending recalculation, do it now
-        if (this.pendingRecalculation) {
-            console.log('Processing pending layout recalculation');
-            this.pendingRecalculation = false;
-            this.recalculateLayout();
-        }
-
-        // If this is the first time we've received graph data, mark it as initial layout
-        if (!this.initialLayoutDone) {
-            console.log('Performing initial layout calculation');
-            this.initialLayoutDone = true;
-            this.recalculateLayout(true);
-        }
     }
 
-    getGraphData = () => {
+    getGraphData() {
         if (this.graphData) {
             console.log(`Returning graph data: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
             console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
@@ -216,78 +184,10 @@ export class GraphDataManager {
         };
     }
 
-    isGraphDataValid = () => {
+    isGraphDataValid() {
         return this.graphData && 
                Array.isArray(this.graphData.nodes) && 
                Array.isArray(this.graphData.edges) &&
                this.graphData.nodes.length > 0;
     }
-
-    updateForceDirectedParams = (name, value) => {
-        console.log(`Updating force-directed parameter: ${name} = ${value}`);
-        
-        // Convert from forceDirected prefixed names to server parameter names
-        const paramMap = {
-            'forceDirectedIterations': 'iterations',
-            'forceDirectedSpring': 'spring_strength',
-            'forceDirectedRepulsion': 'repulsion_strength',
-            'forceDirectedAttraction': 'attraction_strength',
-            'forceDirectedDamping': 'damping'
-        };
-
-        const serverParamName = paramMap[name] || name;
-        if (this.forceDirectedParams.hasOwnProperty(serverParamName)) {
-            this.forceDirectedParams[serverParamName] = value;
-            console.log('Force-directed parameters updated:', this.forceDirectedParams);
-            
-            // Only recalculate if we have valid graph data, otherwise mark as pending
-            if (this.isGraphDataValid()) {
-                this.recalculateLayout();
-            } else {
-                console.log('Marking layout recalculation as pending until graph data is available');
-                this.pendingRecalculation = true;
-            }
-        } else {
-            console.warn(`Unknown force-directed parameter: ${name}`);
-        }
-    }
-
-    recalculateLayout = (isInitial = false) => {
-        console.log('Requesting server layout recalculation with parameters:', this.forceDirectedParams);
-        if (this.isGraphDataValid()) {
-            // Create binary data with multiplexed header
-            const buffer = new ArrayBuffer(this.graphData.nodes.length * 24 + 4);
-            const view = new Float32Array(buffer);
-            
-            // Pack is_initial_layout and time_step into a single float32:
-            // Integer part (0 or 1) = is_initial_layout
-            // Decimal part = time_step
-            // Example: 0.5 = not initial layout (0) with time_step of 0.5
-            //         1.5 = is initial layout (1) with time_step of 0.5
-            view[0] = isInitial ? (1 + this.forceDirectedParams.time_step) : this.forceDirectedParams.time_step;
-
-            // Fill position data
-            this.graphData.nodes.forEach((node, index) => {
-                const offset = index * 6 + 1; // +1 to skip the header
-                // Position
-                view[offset] = node.x;
-                view[offset + 1] = node.y;
-                view[offset + 2] = node.z;
-                // Velocity
-                view[offset + 3] = node.vx || 0;
-                view[offset + 4] = node.vy || 0;
-                view[offset + 5] = node.vz || 0;
-            });
-
-            // Send binary data directly
-            this.websocketService.send(buffer);
-            
-            window.dispatchEvent(new CustomEvent('layoutRecalculationRequested', {
-                detail: this.forceDirectedParams
-            }));
-        } else {
-            console.error('Cannot recalculate layout: Invalid graph data');
-            this.pendingRecalculation = true;
-        }
-    }
 }
diff --git a/data/public/js/services/visualizationSettings.js b/data/public/js/services/visualizationSettings.js
index 3307a285..66820ba8 100755
--- a/data/public/js/services/visualizationSettings.js
+++ b/data/public/js/services/visualizationSettings.js
@@ -15,14 +15,14 @@ export class VisualizationSettings {
             
             // Edge settings
             edgeColor: '#FFD700',             // Golden
-            edgeOpacity: 0.4,
+            edgeOpacity: 0.3,                 // Reduced from 0.4
             edgeWeightNormalization: 12.0,
-            edgeMinWidth: 1.5,
-            edgeMaxWidth: 6.0,
+            edgeMinWidth: 1.0,                // Reduced from 1.5
+            edgeMaxWidth: 4.0,                // Reduced from 6.0
             
             // Node sizes and dimensions (in meters)
-            minNodeSize: 0.15,                // 15cm minimum node size
-            maxNodeSize: 0.4,                 // 40cm maximum node size
+            minNodeSize: 0.3,                 // Increased from 0.15
+            maxNodeSize: 0.6,                 // Increased from 0.4
             nodeAgeMaxDays: 30,
             
             // Hologram settings
@@ -32,13 +32,13 @@ export class VisualizationSettings {
             
             // Material settings
             material: {
-                metalness: 0.3,
-                roughness: 0.5,
-                clearcoat: 0.8,
-                clearcoatRoughness: 0.1,
-                opacity: 0.95,
-                emissiveMinIntensity: 0.0,
-                emissiveMaxIntensity: 0.3
+                metalness: 0.2,               // Reduced from 0.3
+                roughness: 0.7,               // Increased from 0.5
+                clearcoat: 0.5,               // Reduced from 0.8
+                clearcoatRoughness: 0.2,      // Increased from 0.1
+                opacity: 0.9,                 // Reduced from 0.95
+                emissiveMinIntensity: 0.1,    // Increased from 0.0
+                emissiveMaxIntensity: 0.4     // Increased from 0.3
             },
             
             // Force-directed layout settings
@@ -49,18 +49,18 @@ export class VisualizationSettings {
             damping: 0.85,
             
             // Environment settings
-            fogDensity: 0.001,
+            fogDensity: 0.0005,              // Reduced from 0.001
             
             // Label settings
-            labelFontSize: 42,
+            labelFontSize: 32,                // Reduced from 42
             labelFontFamily: 'Arial',
-            labelPadding: 24,
-            labelVerticalOffset: 2.5,
-            labelCloseOffset: 0.25,
-            labelBackgroundColor: 'rgba(0, 0, 0, 0.85)',
+            labelPadding: 16,                 // Reduced from 24
+            labelVerticalOffset: 0.8,         // Reduced from 2.5
+            labelCloseOffset: 0.2,
+            labelBackgroundColor: 'rgba(0, 0, 0, 0.7)', // More transparent
             labelTextColor: 'white',
-            labelInfoTextColor: 'lightgray',
-            labelXRFontSize: 28,
+            labelInfoTextColor: '#cccccc',    // Slightly darker for better contrast
+            labelXRFontSize: 24,
             
             // Geometry settings
             geometryMinSegments: 24,
@@ -72,15 +72,15 @@ export class VisualizationSettings {
             clickFeedbackDuration: 250,
             
             // Bloom settings
-            nodeBloomStrength: 0.8,
-            nodeBloomRadius: 0.3,
-            nodeBloomThreshold: 0.2,
-            edgeBloomStrength: 0.6,
-            edgeBloomRadius: 0.4,
-            edgeBloomThreshold: 0.1,
-            environmentBloomStrength: 0.7,
+            nodeBloomStrength: 0.6,           // Reduced from 0.8
+            nodeBloomRadius: 0.4,             // Increased from 0.3
+            nodeBloomThreshold: 0.3,          // Increased from 0.2
+            edgeBloomStrength: 0.4,           // Reduced from 0.6
+            edgeBloomRadius: 0.3,             // Reduced from 0.4
+            edgeBloomThreshold: 0.2,          // Increased from 0.1
+            environmentBloomStrength: 0.5,     // Reduced from 0.7
             environmentBloomRadius: 0.3,
-            environmentBloomThreshold: 0.1,
+            environmentBloomThreshold: 0.2,    // Increased from 0.1
 
             // Fisheye settings
             fisheye: {
@@ -240,5 +240,5 @@ export class VisualizationSettings {
     }
 }
 
-// Create and export a singleton instance
+// Create and export singleton instance
 export const visualizationSettings = new VisualizationSettings();
diff --git a/data/public/js/threeJS/threeGraph.js b/data/public/js/threeJS/threeGraph.js
index 5ccc0535..942fc02a 100755
--- a/data/public/js/threeJS/threeGraph.js
+++ b/data/public/js/threeJS/threeGraph.js
@@ -4,43 +4,37 @@ import * as THREE from 'three';
 import { visualizationSettings } from '../services/visualizationSettings.js';
 
 /**
- * ForceGraph class manages the creation and updating of nodes and edges in the Three.js scene.
+ * Enhanced ForceGraph class with instanced mesh rendering
  */
 export class ForceGraph {
-    /**
-     * Creates a new ForceGraph instance.
-     * @param {THREE.Scene} scene - The Three.js scene.
-     */
     constructor(scene) {
         this.scene = scene;
 
         // Data structures
         this.nodes = [];
         this.links = [];
+        this.nodeInstances = new Map();
+        this.linkInstances = new Map();
 
-        // Meshes
-        this.nodeMeshes = new Map();
-        this.linkMeshes = new Map();
+        // Instanced meshes
+        this.nodeInstancedMesh = null;
+        this.linkInstancedMesh = null;
 
-        // Object pools with pre-allocation
-        this.nodeMeshPool = [];
-        this.linkMeshPool = [];
-        this.geometryPool = new Map(); // Pool for reusing geometries
-        this.materialPool = new Map(); // Pool for reusing materials
+        // Temporary objects for matrix calculations
+        this.tempMatrix = new THREE.Matrix4();
+        this.tempColor = new THREE.Color();
+        this.tempVector = new THREE.Vector3();
+        this.tempQuaternion = new THREE.Quaternion();
+        this.tempScale = new THREE.Vector3();
 
         // Level of Detail
         this.lod = new THREE.LOD();
         this.scene.add(this.lod);
 
-        // Shared geometry for instancing
-        this.sharedNodeGeometry = null;
-        this.sharedEdgeGeometry = null;
-
-        // Get settings
+        // Settings
         const nodeSettings = visualizationSettings.getNodeSettings();
         const edgeSettings = visualizationSettings.getEdgeSettings();
         
-        // Store settings
         this.nodeColors = {
             NEW: new THREE.Color(nodeSettings.colorNew),
             RECENT: new THREE.Color(nodeSettings.colorRecent),
@@ -52,276 +46,98 @@ export class ForceGraph {
         };
         this.edgeColor = new THREE.Color(edgeSettings.color);
         this.edgeOpacity = edgeSettings.opacity;
-        this.minNodeSize = nodeSettings.minNodeSize;  // In meters (0.1m = 10cm)
-        this.maxNodeSize = nodeSettings.maxNodeSize;  // In meters (0.3m = 30cm)
+        this.minNodeSize = nodeSettings.minNodeSize;
+        this.maxNodeSize = nodeSettings.maxNodeSize;
         this.materialSettings = nodeSettings.material;
 
-        // Initialize shared resources
-        this.initSharedResources();
-    }
-
-    /**
-     * Initialize shared geometries and materials
-     */
-    initSharedResources() {
-        // Create shared node geometry with different LOD levels
-        const highDetail = new THREE.SphereGeometry(1, 32, 32);
-        const mediumDetail = new THREE.SphereGeometry(1, 16, 16);
-        const lowDetail = new THREE.SphereGeometry(1, 8, 8);
-
-        this.geometryPool.set('node-high', highDetail);
-        this.geometryPool.set('node-medium', mediumDetail);
-        this.geometryPool.set('node-low', lowDetail);
-
-        // Create shared edge geometry
-        const edgeGeometry = new THREE.BufferGeometry();
-        const positions = new Float32Array(6);
-        edgeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
-        this.geometryPool.set('edge', edgeGeometry);
+        // Initialize instanced meshes
+        this.initInstancedMeshes();
     }
 
     /**
-     * Get or create a geometry from the pool
-     * @param {string} type - The type of geometry
-     * @param {number} size - The size for node geometries
-     * @returns {THREE.BufferGeometry}
+     * Initialize instanced meshes for nodes and links
      */
-    getGeometry(type, size = 1) {
-        const key = `${type}-${size}`;
-        if (this.geometryPool.has(key)) {
-            return this.geometryPool.get(key);
-        }
+    initInstancedMeshes() {
+        // Create node geometry with different LOD levels
+        const highDetailGeometry = new THREE.SphereGeometry(1, 32, 32);
+        const mediumDetailGeometry = new THREE.SphereGeometry(1, 16, 16);
+        const lowDetailGeometry = new THREE.SphereGeometry(1, 8, 8);
+
+        // Create node material
+        const nodeMaterial = new THREE.MeshPhysicalMaterial({
+            metalness: this.materialSettings.metalness,
+            roughness: this.materialSettings.roughness,
+            transparent: true,
+            opacity: this.materialSettings.opacity,
+            envMapIntensity: 1.0,
+            clearcoat: this.materialSettings.clearcoat,
+            clearcoatRoughness: this.materialSettings.clearcoatRoughness
+        });
 
-        let geometry;
-        switch (type) {
-            case 'node-high':
-                geometry = new THREE.SphereGeometry(size, 32, 32);
-                break;
-            case 'node-medium':
-                geometry = new THREE.SphereGeometry(size, 16, 16);
-                break;
-            case 'node-low':
-                geometry = new THREE.SphereGeometry(size, 8, 8);
-                break;
-            case 'edge':
-                geometry = new THREE.BufferGeometry();
-                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
-                break;
-        }
+        // Create instanced meshes for each LOD level
+        const maxInstances = 10000; // Adjust based on expected graph size
+        this.nodeInstancedMeshes = {
+            high: new THREE.InstancedMesh(highDetailGeometry, nodeMaterial.clone(), maxInstances),
+            medium: new THREE.InstancedMesh(mediumDetailGeometry, nodeMaterial.clone(), maxInstances),
+            low: new THREE.InstancedMesh(lowDetailGeometry, nodeMaterial.clone(), maxInstances)
+        };
 
-        this.geometryPool.set(key, geometry);
-        return geometry;
-    }
+        // Add LOD levels
+        this.lod.addLevel(this.nodeInstancedMeshes.high, 0);
+        this.lod.addLevel(this.nodeInstancedMeshes.medium, 10);
+        this.lod.addLevel(this.nodeInstancedMeshes.low, 20);
+
+        // Create link geometry
+        const linkGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 8, 1);
+        linkGeometry.rotateX(Math.PI / 2); // Align with Z-axis
+
+        // Create link material
+        const linkMaterial = new THREE.MeshBasicMaterial({
+            color: this.edgeColor,
+            transparent: true,
+            opacity: this.edgeOpacity,
+            depthWrite: false
+        });
 
-    /**
-     * Get or create a material from the pool
-     * @param {string} type - The type of material
-     * @param {object} params - Material parameters
-     * @returns {THREE.Material}
-     */
-    getMaterial(type, params) {
-        const key = `${type}-${JSON.stringify(params)}`;
-        if (this.materialPool.has(key)) {
-            return this.materialPool.get(key);
-        }
+        // Create instanced mesh for links
+        this.linkInstancedMesh = new THREE.InstancedMesh(
+            linkGeometry,
+            linkMaterial,
+            maxInstances * 2 // Links typically more numerous than nodes
+        );
 
-        let material;
-        switch (type) {
-            case 'node':
-                material = new THREE.MeshPhysicalMaterial({
-                    color: params.color,
-                    emissive: params.color,
-                    emissiveIntensity: params.emissiveIntensity,
-                    metalness: this.materialSettings.metalness,
-                    roughness: this.materialSettings.roughness,
-                    transparent: true,
-                    opacity: this.materialSettings.opacity,
-                    envMapIntensity: 1.0,
-                    clearcoat: this.materialSettings.clearcoat,
-                    clearcoatRoughness: this.materialSettings.clearcoatRoughness
-                });
-                break;
-            case 'edge':
-                material = new THREE.LineBasicMaterial({
-                    color: params.color,
-                    opacity: params.opacity,
-                    transparent: true,
-                    linewidth: params.linewidth || 1
-                });
-                break;
-        }
+        this.scene.add(this.linkInstancedMesh);
 
-        this.materialPool.set(key, material);
-        return material;
+        // Initialize instance counts
+        this.nodeInstanceCount = 0;
+        this.linkInstanceCount = 0;
     }
 
-    // Previous methods remain the same until updateNodes...
-
     /**
-     * Updates nodes in the scene based on the graph data.
+     * Calculate node size based on metadata
+     * @param {object} node - Node object
+     * @returns {number} Node size
      */
-    updateNodes() {
-        const newNodeIds = new Set(this.nodes.map((node) => node.id));
-
-        // Remove nodes that no longer exist
-        this.nodeMeshes.forEach((mesh, nodeId) => {
-            if (!newNodeIds.has(nodeId)) {
-                this.lod.removeLevel(mesh);
-                this.nodeMeshes.delete(nodeId);
-                
-                // Return mesh to pool
-                if (mesh.material) {
-                    mesh.material.dispose();
-                }
-                this.nodeMeshPool.push(mesh);
-            }
-        });
-
-        // Add or update nodes
-        this.nodes.forEach((node) => {
-            const nodeSize = this.getNodeSize(node);
-            const nodeColor = this.getNodeColor(node);
-            const distance = node.metadata?.distance || 0;
-
-            if (this.nodeMeshes.has(node.id)) {
-                const mesh = this.nodeMeshes.get(node.id);
-                mesh.position.set(node.x, node.y, node.z);
-                
-                // Update material if needed
-                const material = this.getMaterial('node', {
-                    color: nodeColor,
-                    emissiveIntensity: this.calculateEmissiveIntensity(node)
-                });
-                
-                if (mesh.material !== material) {
-                    if (mesh.material) mesh.material.dispose();
-                    mesh.material = material;
-                }
-
-                // Update geometry if size changed
-                if (mesh.geometry.parameters.radius !== nodeSize) {
-                    const geometry = this.getGeometry('node-high', nodeSize);
-                    mesh.geometry = geometry;
-                }
-            } else {
-                // Create LOD levels
-                const highDetail = new THREE.Mesh(
-                    this.getGeometry('node-high', nodeSize),
-                    this.getMaterial('node', {
-                        color: nodeColor,
-                        emissiveIntensity: this.calculateEmissiveIntensity(node)
-                    })
-                );
-                
-                const mediumDetail = new THREE.Mesh(
-                    this.getGeometry('node-medium', nodeSize),
-                    highDetail.material
-                );
-                
-                const lowDetail = new THREE.Mesh(
-                    this.getGeometry('node-low', nodeSize),
-                    highDetail.material
-                );
-
-                // Create LOD object
-                const nodeLOD = new THREE.LOD();
-                nodeLOD.addLevel(highDetail, 0);
-                nodeLOD.addLevel(mediumDetail, 10);
-                nodeLOD.addLevel(lowDetail, 20);
-                nodeLOD.position.set(node.x, node.y, node.z);
-                
-                this.lod.addLevel(nodeLOD, distance);
-                this.nodeMeshes.set(node.id, nodeLOD);
-            }
-        });
+    getNodeSize(node) {
+        const baseSize = (node.metadata?.size || 1) * this.minNodeSize;
+        const weight = node.metadata?.weight || 1;
+        return Math.min(baseSize * Math.sqrt(weight), this.maxNodeSize);
     }
 
     /**
-     * Updates edges in the scene based on the graph data.
+     * Get node color based on metadata
+     * @param {object} node - Node object
+     * @returns {THREE.Color} Node color
      */
-    updateLinks() {
-        const newLinkKeys = new Set(this.links.map((link) => `${link.source}-${link.target}`));
-
-        // Remove edges that no longer exist
-        this.linkMeshes.forEach((line, linkKey) => {
-            if (!newLinkKeys.has(linkKey)) {
-                this.scene.remove(line);
-                if (line.material) line.material.dispose();
-                this.linkMeshes.delete(linkKey);
-                this.linkMeshPool.push(line);
-            }
-        });
-
-        // Add or update edges
-        this.links.forEach((link) => {
-            const linkKey = `${link.source}-${link.target}`;
-            const weight = link.weight || 1;
-            const normalizedWeight = Math.min(weight / 10, 1);
-
-            const sourceMesh = this.nodeMeshes.get(link.source);
-            const targetMesh = this.nodeMeshes.get(link.target);
-            
-            if (!sourceMesh || !targetMesh) return;
-
-            if (this.linkMeshes.has(linkKey)) {
-                const line = this.linkMeshes.get(linkKey);
-                const positions = line.geometry.attributes.position.array;
-                positions[0] = sourceMesh.position.x;
-                positions[1] = sourceMesh.position.y;
-                positions[2] = sourceMesh.position.z;
-                positions[3] = targetMesh.position.x;
-                positions[4] = targetMesh.position.y;
-                positions[5] = targetMesh.position.z;
-                line.geometry.attributes.position.needsUpdate = true;
-                
-                // Update material if needed
-                const material = this.getMaterial('edge', {
-                    color: this.edgeColor,
-                    opacity: this.edgeOpacity * normalizedWeight,
-                    linewidth: Math.max(1, Math.min(weight, 5))
-                });
-                
-                if (line.material !== material) {
-                    if (line.material) line.material.dispose();
-                    line.material = material;
-                }
-            } else {
-                // Create new edge
-                const geometry = this.getGeometry('edge');
-                const material = this.getMaterial('edge', {
-                    color: this.edgeColor,
-                    opacity: this.edgeOpacity * normalizedWeight,
-                    linewidth: Math.max(1, Math.min(weight, 5))
-                });
-
-                let line;
-                if (this.linkMeshPool.length > 0) {
-                    line = this.linkMeshPool.pop();
-                    line.geometry = geometry;
-                    line.material = material;
-                } else {
-                    line = new THREE.Line(geometry, material);
-                }
-
-                const positions = line.geometry.attributes.position.array;
-                positions[0] = sourceMesh.position.x;
-                positions[1] = sourceMesh.position.y;
-                positions[2] = sourceMesh.position.z;
-                positions[3] = targetMesh.position.x;
-                positions[4] = targetMesh.position.y;
-                positions[5] = targetMesh.position.z;
-                line.geometry.attributes.position.needsUpdate = true;
-
-                this.scene.add(line);
-                this.linkMeshes.set(linkKey, line);
-            }
-        });
+    getNodeColor(node) {
+        const type = node.metadata?.type || 'DEFAULT';
+        return this.nodeColors[type] || this.nodeColors.DEFAULT;
     }
 
     /**
      * Calculate emissive intensity based on node age
-     * @param {object} node - The node object
-     * @returns {number} - The emissive intensity
+     * @param {object} node - Node object
+     * @returns {number} Emissive intensity
      */
     calculateEmissiveIntensity(node) {
         const lastModified = node.metadata?.github_last_modified || 
@@ -330,66 +146,139 @@ export class ForceGraph {
         const now = Date.now();
         const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
         
-        // Normalize age to 0-1 range and invert (newer = brighter)
         const normalizedAge = Math.min(ageInDays / 30, 1);
         return this.materialSettings.emissiveMaxIntensity - 
             (normalizedAge * (this.materialSettings.emissiveMaxIntensity - this.materialSettings.emissiveMinIntensity));
     }
 
     /**
-     * Dispose of all resources
+     * Update node instances
      */
-    dispose() {
-        // Dispose of node resources
-        this.nodeMeshes.forEach(mesh => {
-            if (mesh.geometry) mesh.geometry.dispose();
-            if (mesh.material) {
-                if (Array.isArray(mesh.material)) {
-                    mesh.material.forEach(mat => mat.dispose());
-                } else {
-                    mesh.material.dispose();
-                }
-            }
+    updateNodes() {
+        // Reset instance count
+        this.nodeInstanceCount = 0;
+
+        // Update node instances
+        this.nodes.forEach((node, index) => {
+            const size = this.getNodeSize(node);
+            const color = this.getNodeColor(node);
+            const emissiveIntensity = this.calculateEmissiveIntensity(node);
+
+            // Set transform matrix
+            this.tempMatrix.compose(
+                new THREE.Vector3(node.x, node.y, node.z),
+                this.tempQuaternion,
+                new THREE.Vector3(size, size, size)
+            );
+
+            // Update instances for each LOD level
+            Object.values(this.nodeInstancedMeshes).forEach(instancedMesh => {
+                instancedMesh.setMatrixAt(index, this.tempMatrix);
+                instancedMesh.setColorAt(index, color);
+                instancedMesh.material.emissiveIntensity = emissiveIntensity;
+            });
+
+            this.nodeInstances.set(node.id, index);
+            this.nodeInstanceCount = Math.max(this.nodeInstanceCount, index + 1);
         });
 
-        // Dispose of edge resources
-        this.linkMeshes.forEach(line => {
-            if (line.geometry) line.geometry.dispose();
-            if (line.material) line.material.dispose();
+        // Update instance meshes
+        Object.values(this.nodeInstancedMeshes).forEach(instancedMesh => {
+            instancedMesh.count = this.nodeInstanceCount;
+            instancedMesh.instanceMatrix.needsUpdate = true;
+            if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
         });
+    }
+
+    /**
+     * Update link instances
+     */
+    updateLinks() {
+        // Reset instance count
+        this.linkInstanceCount = 0;
+
+        // Update link instances
+        this.links.forEach((link, index) => {
+            const sourceIndex = this.nodeInstances.get(link.source);
+            const targetIndex = this.nodeInstances.get(link.target);
+
+            if (sourceIndex === undefined || targetIndex === undefined) return;
+
+            const sourcePos = new THREE.Vector3(
+                this.nodes[sourceIndex].x,
+                this.nodes[sourceIndex].y,
+                this.nodes[sourceIndex].z
+            );
+            const targetPos = new THREE.Vector3(
+                this.nodes[targetIndex].x,
+                this.nodes[targetIndex].y,
+                this.nodes[targetIndex].z
+            );
+
+            // Calculate link transform
+            const distance = sourcePos.distanceTo(targetPos);
+            this.tempVector.subVectors(targetPos, sourcePos);
+            this.tempQuaternion.setFromUnitVectors(
+                new THREE.Vector3(0, 0, 1),
+                this.tempVector.normalize()
+            );
+
+            this.tempMatrix.compose(
+                sourcePos.lerp(targetPos, 0.5), // Position at midpoint
+                this.tempQuaternion,
+                new THREE.Vector3(1, 1, distance)
+            );
+
+            // Update link instance
+            this.linkInstancedMesh.setMatrixAt(index, this.tempMatrix);
+            
+            const weight = link.weight || 1;
+            const normalizedWeight = Math.min(weight / 10, 1);
+            this.tempColor.copy(this.edgeColor).multiplyScalar(normalizedWeight);
+            this.linkInstancedMesh.setColorAt(index, this.tempColor);
 
-        // Dispose of pooled resources
-        this.nodeMeshPool.forEach(mesh => {
-            if (mesh.geometry) mesh.geometry.dispose();
-            if (mesh.material) {
-                if (Array.isArray(mesh.material)) {
-                    mesh.material.forEach(mat => mat.dispose());
-                } else {
-                    mesh.material.dispose();
-                }
-            }
+            this.linkInstances.set(`${link.source}-${link.target}`, index);
+            this.linkInstanceCount = Math.max(this.linkInstanceCount, index + 1);
         });
 
-        this.linkMeshPool.forEach(line => {
-            if (line.geometry) line.geometry.dispose();
-            if (line.material) line.material.dispose();
+        // Update link instance mesh
+        this.linkInstancedMesh.count = this.linkInstanceCount;
+        this.linkInstancedMesh.instanceMatrix.needsUpdate = true;
+        if (this.linkInstancedMesh.instanceColor) this.linkInstancedMesh.instanceColor.needsUpdate = true;
+    }
+
+    /**
+     * Update graph visualization
+     */
+    update() {
+        this.updateNodes();
+        this.updateLinks();
+    }
+
+    /**
+     * Clean up resources
+     */
+    dispose() {
+        // Dispose of node resources
+        Object.values(this.nodeInstancedMeshes).forEach(instancedMesh => {
+            instancedMesh.geometry.dispose();
+            instancedMesh.material.dispose();
         });
 
-        // Dispose of shared resources
-        this.geometryPool.forEach(geometry => geometry.dispose());
-        this.materialPool.forEach(material => material.dispose());
-
-        // Clear all collections
-        this.nodeMeshes.clear();
-        this.linkMeshes.clear();
-        this.nodeMeshPool.length = 0;
-        this.linkMeshPool.length = 0;
-        this.geometryPool.clear();
-        this.materialPool.clear();
-
-        // Remove LOD from scene
-        if (this.lod.parent) {
-            this.lod.parent.remove(this.lod);
+        // Dispose of link resources
+        if (this.linkInstancedMesh) {
+            this.linkInstancedMesh.geometry.dispose();
+            this.linkInstancedMesh.material.dispose();
         }
+
+        // Remove from scene
+        this.scene.remove(this.lod);
+        this.scene.remove(this.linkInstancedMesh);
+
+        // Clear collections
+        this.nodeInstances.clear();
+        this.linkInstances.clear();
+        this.nodes = [];
+        this.links = [];
     }
 }
diff --git a/data/public/js/threeJS/threeSetup.js b/data/public/js/threeJS/threeSetup.js
index c2c8ce10..098c7b9a 100755
--- a/data/public/js/threeJS/threeSetup.js
+++ b/data/public/js/threeJS/threeSetup.js
@@ -21,25 +21,67 @@ export function initThreeScene() {
     );
     camera.position.set(0, 1.6, 3); // Default height ~1.6m (average human height)
 
-    // Create the renderer with optimized configuration
-    const renderer = new THREE.WebGLRenderer({ 
-        antialias: true,
-        alpha: true, // Enable alpha for AR passthrough
-        logarithmicDepthBuffer: true, // Better depth precision for XR
-        powerPreference: "high-performance",
-        premultipliedAlpha: false,
-        stencil: false,
-        depth: true,
-        preserveDrawingBuffer: false
-    });
+    // Try WebGL2 first, fall back to WebGL1
+    let renderer;
+    try {
+        const canvas = document.createElement('canvas');
+        const contextAttributes = {
+            alpha: true,
+            antialias: true,
+            powerPreference: "high-performance",
+            failIfMajorPerformanceCaveat: false,
+            preserveDrawingBuffer: false
+        };
+
+        // Try WebGL2 first
+        let gl = canvas.getContext('webgl2', contextAttributes);
+        let isWebGL2 = !!gl;
+
+        if (!gl) {
+            console.warn('WebGL2 not available, falling back to WebGL1');
+            gl = canvas.getContext('webgl', contextAttributes) ||
+                 canvas.getContext('experimental-webgl', contextAttributes);
+            isWebGL2 = false;
+        }
+
+        if (!gl) {
+            throw new Error('WebGL not supported');
+        }
+
+        // Create renderer with detected context
+        renderer = new THREE.WebGLRenderer({
+            canvas: canvas,
+            context: gl,
+            antialias: true,
+            alpha: true,
+            powerPreference: "high-performance",
+            preserveDrawingBuffer: false
+        });
 
-    // Configure renderer
-    renderer.setSize(window.innerWidth, window.innerHeight);
-    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
-    renderer.outputColorSpace = THREE.SRGBColorSpace; // Modern color space handling
-    renderer.xr.enabled = true; // Enable WebXR
-    renderer.shadowMap.enabled = true; // Enable shadows for better visual quality
-    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for realism
+        // Configure renderer based on WebGL version
+        if (isWebGL2) {
+            console.log('Using WebGL2 renderer');
+            renderer.outputColorSpace = THREE.SRGBColorSpace;
+            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
+        } else {
+            console.log('Using WebGL1 renderer');
+            renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
+            renderer.shadowMap.type = THREE.PCFShadowMap;
+        }
+
+        // Common renderer settings
+        renderer.setSize(window.innerWidth, window.innerHeight);
+        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
+        renderer.shadowMap.enabled = true;
+        renderer.xr.enabled = true;
+
+        // Store WebGL version for other components
+        renderer.capabilities.isWebGL2 = isWebGL2;
+
+    } catch (error) {
+        console.error('Error creating renderer:', error);
+        throw error;
+    }
 
     // Add WebGL context loss handling
     renderer.domElement.addEventListener('webglcontextlost', handleContextLost, false);
@@ -97,8 +139,8 @@ function setupLighting(scene) {
     directionalLight.castShadow = true;
     
     // Optimize shadow map settings
-    directionalLight.shadow.mapSize.width = 2048;
-    directionalLight.shadow.mapSize.height = 2048;
+    directionalLight.shadow.mapSize.width = 1024; // Reduced for WebGL1
+    directionalLight.shadow.mapSize.height = 1024;
     directionalLight.shadow.camera.near = 0.5;
     directionalLight.shadow.camera.far = 500;
     directionalLight.shadow.bias = -0.0001;
@@ -127,9 +169,9 @@ export function createOrbitControls(camera, renderer) {
     // Configure controls for XR compatibility
     controls.enableDamping = true;
     controls.dampingFactor = 0.05;
-    controls.maxPolarAngle = Math.PI * 0.95; // Prevent camera from going below ground
-    controls.minDistance = 1; // Minimum zoom distance
-    controls.maxDistance = 50; // Maximum zoom distance
+    controls.maxPolarAngle = Math.PI * 0.95;
+    controls.minDistance = 1;
+    controls.maxDistance = 50;
     controls.enablePan = true;
     controls.panSpeed = 0.5;
     controls.rotateSpeed = 0.5;
@@ -191,7 +233,6 @@ export function createBasicEnvironment(scene) {
         ground,
         gridHelper,
         dispose: () => {
-            // Cleanup materials and geometries
             groundGeometry.dispose();
             groundMaterial.dispose();
             if (gridHelper.material) {
@@ -200,7 +241,6 @@ export function createBasicEnvironment(scene) {
             if (gridHelper.geometry) {
                 gridHelper.geometry.dispose();
             }
-            // Remove from scene
             scene.remove(ground);
             scene.remove(gridHelper);
         }
diff --git a/data/public/js/xr/xrInteraction.js b/data/public/js/xr/xrInteraction.js
index 5b7d4c64..b3764b43 100755
--- a/data/public/js/xr/xrInteraction.js
+++ b/data/public/js/xr/xrInteraction.js
@@ -8,440 +8,315 @@ const PINCH_STRENGTH_THRESHOLD = 0.7;
 const LABEL_SIZE = { width: 256, height: 128 };
 const LABEL_SCALE = { x: 0.5, y: 0.25, z: 1 };
 
-// Resource pools
-const materialPool = new Map();
-const geometryPool = new Map();
-const texturePool = new Map();
-
-// Hand tracking setup
-const handModelFactory = new XRHandModelFactory();
-const hands = { left: null, right: null };
-const grabStates = {
-    left: { grabbedObject: null, pinching: false },
-    right: { grabbedObject: null, pinching: false }
-};
-const pinchIndicators = { left: null, right: null };
-const interactableObjects = new Set();
-
-// XR Label Manager Class
-export class XRLabelManager {
-    constructor(scene, camera) {
+/**
+ * Enhanced XR Interaction Handler
+ */
+class EnhancedXRInteractionHandler {
+    constructor(scene, camera, renderer) {
         this.scene = scene;
         this.camera = camera;
-        this.labels = new Map();
-        this.labelCanvas = document.createElement('canvas');
-        this.labelContext = this.labelCanvas.getContext('2d', {
-            alpha: true,
-            desynchronized: true
-        });
+        this.renderer = renderer;
         
-        // Set canvas size to power of 2
-        this.labelCanvas.width = LABEL_SIZE.width;
-        this.labelCanvas.height = LABEL_SIZE.height;
-    }
-
-    /**
-     * Get or create a texture for label
-     * @param {string} text - Label text
-     * @returns {THREE.Texture} The texture
-     */
-    getTexture(text) {
-        if (texturePool.has(text)) {
-            return texturePool.get(text);
-        }
-
-        // Clear canvas
-        this.labelContext.clearRect(0, 0, LABEL_SIZE.width, LABEL_SIZE.height);
+        // Hand tracking
+        this.handModelFactory = new XRHandModelFactory();
+        this.hands = { left: null, right: null };
+        this.handModels = { left: null, right: null };
+        
+        // Interaction states
+        this.grabStates = {
+            left: { grabbedObject: null, pinching: false },
+            right: { grabbedObject: null, pinching: false }
+        };
         
-        // Draw background
-        this.labelContext.fillStyle = 'rgba(0, 0, 0, 0.8)';
-        this.labelContext.fillRect(0, 0, LABEL_SIZE.width, LABEL_SIZE.height);
+        // Visual feedback
+        this.pinchIndicators = { left: null, right: null };
         
-        // Draw text
-        this.labelContext.fillStyle = '#ffffff';
-        this.labelContext.font = '24px Arial';
-        this.labelContext.textBaseline = 'middle';
-        this.labelContext.fillText(text, 10, LABEL_SIZE.height / 2);
-
-        const texture = new THREE.CanvasTexture(this.labelCanvas);
-        texture.generateMipmaps = false;
-        texture.minFilter = THREE.LinearFilter;
-        texture.magFilter = THREE.LinearFilter;
+        // Interactable objects
+        this.interactableObjects = new Set();
         
-        texturePool.set(text, texture);
-        return texture;
+        // Resource pools
+        this.materialPool = new Map();
+        this.geometryPool = new Map();
+        
+        // Initialize resources
+        this.initResources();
     }
 
     /**
-     * Get or create a material for label
-     * @param {THREE.Texture} texture - The label texture
-     * @returns {THREE.SpriteMaterial} The material
+     * Initialize shared resources
      */
-    getMaterial(texture) {
-        const key = texture.uuid;
-        if (materialPool.has(key)) {
-            return materialPool.get(key);
-        }
-
-        const material = new THREE.SpriteMaterial({
-            map: texture,
+    initResources() {
+        // Create pinch indicator geometry
+        const geometry = new THREE.SphereGeometry(0.01, 8, 8);
+        this.geometryPool.set('pinchIndicator', geometry);
+
+        // Create pinch indicator material
+        const material = new THREE.MeshPhongMaterial({
+            color: 0x00ff00,
             transparent: true,
-            depthWrite: false,
-            sizeAttenuation: true
+            opacity: 0.5,
+            depthWrite: false
         });
+        this.materialPool.set('pinchIndicator', material);
 
-        materialPool.set(key, material);
-        return material;
+        // Create pinch indicators
+        this.pinchIndicators.left = this.createPinchIndicator();
+        this.pinchIndicators.right = this.createPinchIndicator();
+        this.scene.add(this.pinchIndicators.left);
+        this.scene.add(this.pinchIndicators.right);
     }
 
-    createLabel(text, position) {
+    /**
+     * Initialize hand tracking
+     * @param {XRSession} session - The XR session
+     */
+    async initHandTracking(session) {
         try {
-            const texture = this.getTexture(text);
-            const material = this.getMaterial(texture);
-            const sprite = new THREE.Sprite(material);
-            
-            sprite.position.copy(position);
-            sprite.scale.set(LABEL_SCALE.x, LABEL_SCALE.y, LABEL_SCALE.z);
-            
-            this.scene.add(sprite);
-            this.labels.set(text, sprite);
-            
-            return sprite;
-        } catch (error) {
-            console.error('Error creating label:', error);
-            return null;
-        }
-    }
+            // Set up hand tracking
+            for (const handedness of ['left', 'right']) {
+                const hand = this.renderer.xr.getHand(handedness === 'left' ? 0 : 1);
+                const handModel = this.handModelFactory.createHandModel(hand, 'mesh');
+                
+                this.hands[handedness] = hand;
+                this.handModels[handedness] = handModel;
+                
+                hand.add(handModel);
+                this.scene.add(hand);
 
-    updateLabel(text, position) {
-        const label = this.labels.get(text);
-        if (label) {
-            label.position.copy(position);
-            label.lookAt(this.camera.position);
-        }
-    }
+                // Add hand input event listeners
+                hand.addEventListener('pinchstart', () => this.onPinchStart(handedness));
+                hand.addEventListener('pinchend', () => this.onPinchEnd(handedness));
+            }
 
-    removeLabel(text) {
-        const label = this.labels.get(text);
-        if (label) {
-            this.scene.remove(label);
-            
-            // Return material and texture to pools
-            if (label.material) {
-                const texture = label.material.map;
-                if (texture) {
-                    texturePool.delete(text);
-                    texture.dispose();
+            // Set up hand tracking events
+            session.addEventListener('handtracking', (event) => {
+                const hand = event.hand;
+                const handedness = hand.handedness;
+                
+                // Update hand model visibility
+                if (this.handModels[handedness]) {
+                    this.handModels[handedness].visible = hand.visible;
                 }
-                materialPool.delete(label.material.uuid);
-                label.material.dispose();
-            }
-            
-            this.labels.delete(text);
+            });
+        } catch (error) {
+            console.error('Error initializing hand tracking:', error);
         }
     }
 
-    updateAll() {
-        const cameraPosition = this.camera.position;
-        this.labels.forEach(label => {
-            label.lookAt(cameraPosition);
-        });
+    /**
+     * Create visual feedback for pinch state
+     * @returns {THREE.Mesh} Pinch indicator mesh
+     */
+    createPinchIndicator() {
+        const geometry = this.geometryPool.get('pinchIndicator');
+        const material = this.materialPool.get('pinchIndicator').clone();
+        return new THREE.Mesh(geometry, material);
     }
 
-    dispose() {
-        // Dispose of all labels
-        this.labels.forEach((label, text) => {
-            this.removeLabel(text);
-        });
+    /**
+     * Update pinch indicator position and appearance
+     * @param {XRHand} hand - The XR hand
+     * @param {THREE.Mesh} indicator - The pinch indicator mesh
+     */
+    updatePinchIndicator(hand, indicator) {
+        if (!hand?.joints || !indicator) return;
 
-        // Clear pools
-        texturePool.forEach(texture => texture.dispose());
-        materialPool.forEach(material => material.dispose());
-        
-        texturePool.clear();
-        materialPool.clear();
-        
-        // Clear canvas
-        this.labelContext.clearRect(0, 0, LABEL_SIZE.width, LABEL_SIZE.height);
-        this.labelCanvas.width = 1;
-        this.labelCanvas.height = 1;
+        try {
+            const indexTip = hand.joints['index-finger-tip'];
+            const thumbTip = hand.joints['thumb-tip'];
+            
+            if (indexTip && thumbTip) {
+                // Position indicator between finger and thumb
+                indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
+                
+                // Update appearance based on pinch strength
+                const { strength } = this.isPinching(hand);
+                indicator.material.opacity = strength * 0.8;
+                indicator.scale.setScalar(1 - (strength * 0.5));
+            }
+        } catch (error) {
+            console.error('Error updating pinch indicator:', error);
+        }
     }
-}
 
-// Detect pinch with strength
-function isPinching(hand) {
-    try {
-        const indexTip = hand.joints['index-finger-tip'];
-        const thumbTip = hand.joints['thumb-tip'];
+    /**
+     * Check if hand is performing pinch gesture
+     * @param {XRHand} hand - The XR hand
+     * @returns {object} Pinch state and strength
+     */
+    isPinching(hand) {
+        try {
+            const indexTip = hand.joints['index-finger-tip'];
+            const thumbTip = hand.joints['thumb-tip'];
 
-        if (indexTip && thumbTip) {
-            const distance = indexTip.position.distanceTo(thumbTip.position);
-            const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
-            return { isPinched: distance < PINCH_THRESHOLD, strength };
+            if (indexTip && thumbTip) {
+                const distance = indexTip.position.distanceTo(thumbTip.position);
+                const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
+                return { isPinched: distance < PINCH_THRESHOLD, strength };
+            }
+        } catch (error) {
+            console.error('Error detecting pinch:', error);
         }
-    } catch (error) {
-        console.error('Error detecting pinch:', error);
-    }
-    return { isPinched: false, strength: 0 };
-}
-
-// Get or create geometry for pinch indicator
-function getPinchIndicatorGeometry() {
-    const key = 'pinchIndicator';
-    if (geometryPool.has(key)) {
-        return geometryPool.get(key);
+        return { isPinched: false, strength: 0 };
     }
 
-    const geometry = new THREE.SphereGeometry(0.01, 8, 8);
-    geometryPool.set(key, geometry);
-    return geometry;
-}
-
-// Get or create material for pinch indicator
-function getPinchIndicatorMaterial() {
-    const key = 'pinchIndicator';
-    if (materialPool.has(key)) {
-        return materialPool.get(key);
-    }
+    /**
+     * Handle pinch start event
+     * @param {string} handedness - The hand that started pinching
+     */
+    onPinchStart(handedness) {
+        const hand = this.hands[handedness];
+        const grabState = this.grabStates[handedness];
 
-    const material = new THREE.MeshPhongMaterial({
-        color: 0x00ff00,
-        transparent: true,
-        opacity: 0.5,
-        depthWrite: false
-    });
-    materialPool.set(key, material);
-    return material;
-}
+        if (!hand || grabState.pinching) return;
 
-// Create visual feedback sphere for pinch state
-function createPinchIndicator() {
-    const geometry = getPinchIndicatorGeometry();
-    const material = getPinchIndicatorMaterial();
-    return new THREE.Mesh(geometry, material);
-}
+        try {
+            const indexTip = hand.joints['index-finger-tip'];
+            
+            // Find closest interactable object
+            let closestObject = null;
+            let closestDistance = GRAB_THRESHOLD;
+
+            for (const object of this.interactableObjects) {
+                if (!object.userData.isGrabbed) {
+                    const distance = indexTip.position.distanceTo(object.position);
+                    if (distance < closestDistance) {
+                        closestDistance = distance;
+                        closestObject = object;
+                    }
+                }
+            }
 
-// Update pinch indicator position and appearance
-function updatePinchIndicator(hand, indicator) {
-    if (!hand?.joints || !indicator) return;
+            if (closestObject) {
+                grabState.grabbedObject = closestObject;
+                closestObject.userData.isGrabbed = true;
+                
+                // Highlight grabbed object
+                if (closestObject.material?.emissive) {
+                    closestObject.material.emissive.setHex(0x222222);
+                }
+            }
 
-    try {
-        const indexTip = hand.joints['index-finger-tip'];
-        const thumbTip = hand.joints['thumb-tip'];
-        
-        if (indexTip && thumbTip) {
-            indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
-            const { strength } = isPinching(hand);
-            indicator.material.opacity = strength * 0.8;
-            indicator.scale.setScalar(1 - (strength * 0.5));
+            grabState.pinching = true;
+        } catch (error) {
+            console.error('Error handling pinch start:', error);
         }
-    } catch (error) {
-        console.error('Error updating pinch indicator:', error);
     }
-}
 
-// Initialize XR interaction
-export function initXRInteraction(scene, camera, renderer, onSelect) {
-    const xrLabelManager = new XRLabelManager(scene, camera);
-    
-    // Create default interactable object geometry and material
-    const interactableGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
-    geometryPool.set('interactable', interactableGeometry);
-    
-    const interactableMaterial = new THREE.MeshStandardMaterial({
-        color: 0xff0000,
-        roughness: 0.7,
-        metalness: 0.3
-    });
-    materialPool.set('interactable', interactableMaterial);
-
-    // Create interactable object function
-    const createInteractableObject = (position) => {
-        const geometry = geometryPool.get('interactable');
-        const material = materialPool.get('interactable').clone(); // Clone material for individual control
-        
-        const object = new THREE.Mesh(geometry, material);
-        object.position.copy(position);
-        object.userData.interactable = true;
-        scene.add(object);
-        interactableObjects.add(object);
-        return object;
-    };
-
-    // Create default objects
-    createInteractableObject(new THREE.Vector3(0, 1.5, -1));
-    createInteractableObject(new THREE.Vector3(0.2, 1.5, -1));
-    createInteractableObject(new THREE.Vector3(-0.2, 1.5, -1));
-
-    // Initialize pinch indicators
-    pinchIndicators.left = createPinchIndicator();
-    pinchIndicators.right = createPinchIndicator();
-    scene.add(pinchIndicators.left);
-    scene.add(pinchIndicators.right);
-
-    // Set up hand tracking
-    renderer.xr.addEventListener('sessionstart', () => {
+    /**
+     * Handle pinch end event
+     * @param {string} handedness - The hand that ended pinching
+     */
+    onPinchEnd(handedness) {
+        const grabState = this.grabStates[handedness];
+
+        if (!grabState.pinching) return;
+
         try {
-            const session = renderer.xr.getSession();
-            
-            hands.left = renderer.xr.getHand(0);
-            hands.right = renderer.xr.getHand(1);
-            
-            // Add hand models
-            for (const [handedness, hand] of Object.entries(hands)) {
-                if (hand) {
-                    const handModel = handModelFactory.createHandModel(hand, 'mesh');
-                    hand.add(handModel);
-                    scene.add(hand);
+            if (grabState.grabbedObject) {
+                grabState.grabbedObject.userData.isGrabbed = false;
+                if (grabState.grabbedObject.material?.emissive) {
+                    grabState.grabbedObject.material.emissive.setHex(0x000000);
                 }
+                grabState.grabbedObject = null;
             }
+
+            grabState.pinching = false;
         } catch (error) {
-            console.error('Error setting up hand tracking:', error);
+            console.error('Error handling pinch end:', error);
         }
-    });
+    }
 
-    // Create update function
-    const update = () => {
+    /**
+     * Make an object interactable
+     * @param {THREE.Object3D} object - The object to make interactable
+     */
+    makeInteractable(object) {
+        object.userData.interactable = true;
+        this.interactableObjects.add(object);
+    }
+
+    /**
+     * Remove interactable status from object
+     * @param {THREE.Object3D} object - The object to remove
+     */
+    removeInteractable(object) {
+        object.userData.interactable = false;
+        this.interactableObjects.delete(object);
+    }
+
+    /**
+     * Update interaction state
+     */
+    update() {
         try {
             // Update both hands
-            for (const [handedness, hand] of Object.entries(hands)) {
+            for (const [handedness, hand] of Object.entries(this.hands)) {
                 if (hand?.joints) {
-                    const grabState = grabStates[handedness];
-                    const { isPinched, strength } = isPinching(hand);
+                    const grabState = this.grabStates[handedness];
+                    const { isPinched, strength } = this.isPinching(hand);
                     
-                    updatePinchIndicator(hand, pinchIndicators[handedness]);
+                    this.updatePinchIndicator(hand, this.pinchIndicators[handedness]);
 
                     if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
-                        if (!grabState.grabbedObject) {
-                            const indexTip = hand.joints['index-finger-tip'];
-                            
-                            for (const object of interactableObjects) {
-                                const distance = indexTip.position.distanceTo(object.position);
-                                if (distance < GRAB_THRESHOLD && !object.userData.isGrabbed) {
-                                    grabState.grabbedObject = object;
-                                    object.userData.isGrabbed = true;
-                                    object.material.emissive.setHex(0x222222);
-                                    break;
-                                }
-                            }
-                        } else if (grabState.grabbedObject) {
+                        if (grabState.grabbedObject) {
+                            // Update grabbed object position
                             const indexTip = hand.joints['index-finger-tip'];
                             grabState.grabbedObject.position.copy(indexTip.position);
                         }
-                        grabState.pinching = true;
-                    } else if (grabState.pinching) {
-                        if (grabState.grabbedObject) {
-                            grabState.grabbedObject.userData.isGrabbed = false;
-                            grabState.grabbedObject.material.emissive.setHex(0x000000);
-                            grabState.grabbedObject = null;
-                        }
-                        grabState.pinching = false;
                     }
                 }
             }
-
-            // Update labels if in XR
-            if (renderer.xr.isPresenting) {
-                xrLabelManager.updateAll();
-            }
         } catch (error) {
-            console.error('Error in XR update:', error);
+            console.error('Error in XR interaction update:', error);
         }
-    };
+    }
 
-    // Create cleanup function
-    const cleanup = () => {
+    /**
+     * Clean up resources
+     */
+    cleanup() {
         try {
-            // Dispose of all pooled resources
-            geometryPool.forEach(geometry => geometry.dispose());
-            materialPool.forEach(material => material.dispose());
-            
-            // Clear pools
-            geometryPool.clear();
-            materialPool.clear();
-            
-            // Dispose of pinch indicators
-            Object.values(pinchIndicators).forEach(indicator => {
+            // Dispose of geometries
+            this.geometryPool.forEach(geometry => geometry.dispose());
+            this.geometryPool.clear();
+
+            // Dispose of materials
+            this.materialPool.forEach(material => material.dispose());
+            this.materialPool.clear();
+
+            // Remove pinch indicators
+            Object.values(this.pinchIndicators).forEach(indicator => {
                 if (indicator) {
                     if (indicator.geometry) indicator.geometry.dispose();
                     if (indicator.material) indicator.material.dispose();
-                    scene.remove(indicator);
+                    this.scene.remove(indicator);
                 }
             });
-            
-            // Dispose of hand models
-            Object.values(hands).forEach(hand => {
+
+            // Remove hand models
+            Object.values(this.hands).forEach(hand => {
                 if (hand) {
-                    scene.remove(hand);
+                    this.scene.remove(hand);
                 }
             });
-            
-            // Clear interactable objects
-            interactableObjects.clear();
-            
-            // Dispose of label manager
-            xrLabelManager.dispose();
+
+            // Clear collections
+            this.interactableObjects.clear();
+            this.grabStates.left = { grabbedObject: null, pinching: false };
+            this.grabStates.right = { grabbedObject: null, pinching: false };
         } catch (error) {
-            console.error('Error cleaning up XR resources:', error);
-        }
-    };
-
-    return {
-        hands: Object.values(hands),
-        controllers: [],
-        xrLabelManager,
-        update,
-        cleanup,
-        addInteractableObject: (object) => {
-            object.userData.interactable = true;
-            interactableObjects.add(object);
-        },
-        removeInteractableObject: (object) => {
-            interactableObjects.delete(object);
+            console.error('Error cleaning up XR interaction:', error);
         }
-    };
+    }
+}
+
+// Export functions
+export function initXRInteraction(scene, camera, renderer) {
+    return new EnhancedXRInteractionHandler(scene, camera, renderer);
 }
 
-// Handle XR input
 export function handleXRInput(frame, referenceSpace) {
-    try {
-        // Update both hands
-        for (const [handedness, hand] of Object.entries(hands)) {
-            if (hand?.joints) {
-                const grabState = grabStates[handedness];
-                const { isPinched, strength } = isPinching(hand);
-                
-                updatePinchIndicator(hand, pinchIndicators[handedness]);
-
-                if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
-                    if (!grabState.grabbedObject) {
-                        const indexTip = hand.joints['index-finger-tip'];
-                        
-                        for (const object of interactableObjects) {
-                            const distance = indexTip.position.distanceTo(object.position);
-                            if (distance < GRAB_THRESHOLD && !object.userData.isGrabbed) {
-                                grabState.grabbedObject = object;
-                                object.userData.isGrabbed = true;
-                                object.material.emissive.setHex(0x222222);
-                                break;
-                            }
-                        }
-                    } else if (grabState.grabbedObject) {
-                        const indexTip = hand.joints['index-finger-tip'];
-                        grabState.grabbedObject.position.copy(indexTip.position);
-                    }
-                    grabState.pinching = true;
-                } else if (grabState.pinching) {
-                    if (grabState.grabbedObject) {
-                        grabState.grabbedObject.userData.isGrabbed = false;
-                        grabState.grabbedObject.material.emissive.setHex(0x000000);
-                        grabState.grabbedObject = null;
-                    }
-                    grabState.pinching = false;
-                }
-            }
-        }
-    } catch (error) {
-        console.error('Error handling XR input:', error);
-    }
+    // This function is now handled internally by EnhancedXRInteractionHandler
+    // Left for backward compatibility
 }
diff --git a/data/public/js/xr/xrSetup.js b/data/public/js/xr/xrSetup.js
index 557a3904..0f1c2d30 100755
--- a/data/public/js/xr/xrSetup.js
+++ b/data/public/js/xr/xrSetup.js
@@ -7,61 +7,265 @@ const MOVEMENT_SPEED = 0.05;
 const XR_SPRITE_SCALE = 0.5;
 
 /**
- * Initializes the WebXR session for immersive experiences.
- * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
- * @param {THREE.Scene} scene - The Three.js scene.
- * @param {THREE.PerspectiveCamera} camera - The Three.js camera.
- * @param {EffectsManager} effectsManager - The effects manager instance.
+ * Enhanced XR Session Manager using Three.js WebXR
  */
-export function initXRSession(renderer, scene, camera, effectsManager) {
-    if (!scene || !camera) {
-        console.error('Scene or camera not provided to initXRSession');
-        return;
+class XRSessionManager {
+    constructor(renderer, scene, camera, effectsManager) {
+        this.renderer = renderer;
+        this.scene = scene;
+        this.camera = camera;
+        this.effectsManager = effectsManager;
+        this.referenceSpace = null;
+        this.originalScales = new WeakMap();
+        this.xrInteraction = null;
+        this.sessionActive = false;
+        this.cameraRig = null;
+        this.effectsEnabled = true;
+    }
+
+    /**
+     * Initialize XR session manager
+     */
+    async init() {
+        try {
+            // Check if XR is supported
+            if (!this.renderer.xr) {
+                console.warn('WebXR not supported by renderer');
+                return;
+            }
+
+            // Enable XR on renderer
+            this.renderer.xr.enabled = true;
+
+            // Initialize camera rig
+            this.initCameraRig();
+
+            // Initialize XR interaction
+            this.xrInteraction = initXRInteraction(this.scene, this.camera, this.renderer);
+
+            // Set up session event handlers
+            this.setupEventHandlers();
+
+        } catch (error) {
+            console.error('Error initializing XR session manager:', error);
+        }
+    }
+
+    /**
+     * Initialize camera rig with proper hierarchy
+     */
+    initCameraRig() {
+        // Create camera rig if it doesn't exist
+        if (!this.cameraRig) {
+            this.cameraRig = new THREE.Group();
+            this.cameraRig.name = 'cameraRig';
+        }
+
+        // Create camera offset for height adjustment if not already a child of the rig
+        let cameraOffset = this.cameraRig.children.find(child => child.name === 'cameraOffset');
+        if (!cameraOffset) {
+            cameraOffset = new THREE.Group();
+            cameraOffset.name = 'cameraOffset';
+            cameraOffset.position.y = 1.6; // Average eye height
+            this.cameraRig.add(cameraOffset);
+        }
+
+        // Add camera to offset if not already there
+        if (!cameraOffset.children.includes(this.camera)) {
+            this.camera.name = 'xrCamera';
+            cameraOffset.add(this.camera);
+        }
+
+        // Add rig to scene if not already there
+        if (!this.scene.children.includes(this.cameraRig)) {
+            this.scene.add(this.cameraRig);
+        }
+
+        // Set initial positions
+        this.camera.position.set(0, 0, 0);
+        this.cameraRig.position.set(0, 0, 0);
     }
 
-    // Store original sprite scales for restoration
-    const originalScales = new WeakMap();
+    /**
+     * Set up session event handlers
+     */
+    setupEventHandlers() {
+        // Session start handler
+        this.renderer.xr.addEventListener('sessionstart', async (event) => {
+            console.log('XR session started');
+            this.sessionActive = true;
+
+            const session = this.renderer.xr.getSession();
+            await this.setupReferenceSpace(session);
+            this.handleXRSprites(true);
+
+            // Initialize camera position
+            this.cameraRig.position.set(0, 0, 0);
+            this.camera.position.set(0, 0, 0);
+
+            // Initialize XR-specific effects
+            if (this.effectsManager) {
+                try {
+                    await this.effectsManager.initPostProcessing(true);
+                    this.effectsEnabled = true;
+                } catch (error) {
+                    console.error('Failed to initialize XR effects:', error);
+                    this.effectsEnabled = false;
+                }
+            }
+
+            window.dispatchEvent(new CustomEvent('xrsessionstart'));
+        });
+
+        // Session end handler
+        this.renderer.xr.addEventListener('sessionend', () => {
+            console.log('XR session ended');
+            this.sessionActive = false;
+            this.handleXRSprites(false);
+            this.resetCameraRig();
 
-    // Initialize hand tracking with enhanced features
-    const xrInteraction = initXRInteraction(scene, camera, renderer);
+            // Reinitialize desktop effects
+            if (this.effectsManager) {
+                try {
+                    this.effectsManager.initPostProcessing(false);
+                    this.effectsEnabled = true;
+                } catch (error) {
+                    console.error('Failed to reinitialize desktop effects:', error);
+                    this.effectsEnabled = false;
+                }
+            }
 
-    // Configure renderer for XR with optimized settings
-    renderer.xr.enabled = true;
-    renderer.xr.setFramebufferScaleFactor(1.0); // Optimize resolution
-    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
-    renderer.setSize(window.innerWidth, window.innerHeight);
-    renderer.setClearColor(0x000000, 0);
-    renderer.alpha = true;
+            window.dispatchEvent(new CustomEvent('xrsessionend'));
+        });
+    }
 
     /**
-     * Handles sprite scaling and visibility for XR
+     * Render scene with effects fallback
+     */
+    render() {
+        if (this.effectsManager && this.effectsEnabled) {
+            try {
+                this.effectsManager.render();
+            } catch (error) {
+                console.error('Error in effects rendering:', error);
+                this.effectsEnabled = false;
+                this.fallbackRender();
+            }
+        } else {
+            this.fallbackRender();
+        }
+    }
+
+    /**
+     * Fallback render without effects
+     */
+    fallbackRender() {
+        const currentCamera = this.sessionActive ? this.renderer.xr.getCamera() : this.camera;
+        this.renderer.render(this.scene, currentCamera);
+    }
+
+    /**
+     * Add XR button to the scene
+     * @returns {Promise<void>}
+     */
+    async addXRButton() {
+        try {
+            if (!this.renderer.xr.enabled) {
+                console.warn('XR not enabled on renderer');
+                return;
+            }
+
+            const sessionInit = {
+                optionalFeatures: [
+                    'local-floor',
+                    'bounded-floor',
+                    'hand-tracking',
+                    'layers'
+                ]
+            };
+
+            // Check if VR is supported
+            const isVRSupported = await navigator.xr?.isSessionSupported('immersive-vr');
+            
+            if (isVRSupported) {
+                const button = XRButton.createButton(this.renderer, {
+                    mode: 'immersive-vr',
+                    sessionInit,
+                    onSessionStarted: (session) => this.onSessionStarted(session),
+                    onSessionEnded: () => this.onSessionEnded()
+                });
+                document.body.appendChild(button);
+            } else {
+                console.warn('VR not supported on this device');
+            }
+        } catch (error) {
+            console.error('Error adding XR button:', error);
+        }
+    }
+
+    /**
+     * Handle session start
+     * @param {XRSession} session - The XR session
+     */
+    async onSessionStarted(session) {
+        try {
+            await this.setupReferenceSpace(session);
+            this.handleXRSprites(true);
+        } catch (error) {
+            console.error('Error starting XR session:', error);
+        }
+    }
+
+    /**
+     * Handle session end
+     */
+    onSessionEnded() {
+        this.handleXRSprites(false);
+        this.resetCameraRig();
+    }
+
+    /**
+     * Set up reference space with fallback options
+     * @param {XRSession} session - The XR session
+     */
+    async setupReferenceSpace(session) {
+        try {
+            this.referenceSpace = await session.requestReferenceSpace('local-floor');
+            console.log('Using local-floor reference space');
+        } catch (error) {
+            console.warn('Failed to get local-floor reference space:', error);
+            try {
+                this.referenceSpace = await session.requestReferenceSpace('local');
+                console.log('Falling back to local reference space');
+            } catch (error) {
+                console.error('Failed to get any reference space:', error);
+            }
+        }
+    }
+
+    /**
+     * Handle sprite scaling for XR
      * @param {boolean} enteringXR - Whether entering or exiting XR
      */
-    function handleXRSprites(enteringXR) {
-        scene.traverse((object) => {
+    handleXRSprites(enteringXR) {
+        this.scene.traverse((object) => {
             if (object.isSprite) {
                 if (enteringXR) {
-                    // Store original scale
-                    originalScales.set(object, object.scale.clone());
-                    
-                    // Scale for XR
+                    this.originalScales.set(object, object.scale.clone());
                     object.scale.multiplyScalar(XR_SPRITE_SCALE);
                     object.layers.enableAll();
                     
-                    // Optimize sprite texture
                     if (object.material.map) {
                         object.material.map.generateMipmaps = false;
                         object.material.map.minFilter = THREE.LinearFilter;
                         object.material.map.needsUpdate = true;
                     }
                 } else {
-                    // Restore original scale
-                    const originalScale = originalScales.get(object);
+                    const originalScale = this.originalScales.get(object);
                     if (originalScale) {
                         object.scale.copy(originalScale);
                     }
                     
-                    // Reset texture settings
                     if (object.material.map) {
                         object.material.map.generateMipmaps = true;
                         object.material.map.minFilter = THREE.LinearMipmapLinearFilter;
@@ -73,285 +277,155 @@ export function initXRSession(renderer, scene, camera, effectsManager) {
     }
 
     /**
-     * Creates XR session configuration
-     * @param {string} mode - XR session mode
-     * @returns {Object} Session configuration
+     * Reset camera rig to initial position
      */
-    function createSessionConfig(mode) {
-        return {
-            mode: mode,
-            sessionInit: {
-                optionalFeatures: [
-                    'dom-overlay',
-                    'local-floor',
-                    'bounded-floor',
-                    'hand-tracking',
-                    'layers',
-                    mode === 'immersive-ar' ? 'passthrough' : null
-                ].filter(Boolean),
-                domOverlay: { root: document.body }
-            },
-            onSessionStarted: (session) => {
-                console.log(`${mode} session started`);
-                handleXRSprites(true);
-                
-                session.addEventListener('end', () => {
-                    console.log(`${mode} session ended`);
-                    handleXRSprites(false);
-                    window.dispatchEvent(new CustomEvent('xrsessionend'));
-                });
-
-                // Request reference space with fallback
-                requestReferenceSpace(session, renderer);
-                
-                window.dispatchEvent(new CustomEvent('xrsessionstart'));
-            },
-            onSessionEnded: () => {
-                console.log(`${mode} session cleanup`);
-                handleXRSprites(false);
-                
-                // Clear any cached resources
-                originalScales.clear();
-                
-                // Force renderer reset
-                renderer.setPixelRatio(window.devicePixelRatio);
-                renderer.setSize(window.innerWidth, window.innerHeight);
-            }
-        };
-    }
-
-    if ('xr' in navigator) {
-        // Check for AR support first
-        navigator.xr.isSessionSupported('immersive-ar')
-            .then(arSupported => {
-                if (arSupported) {
-                    const xrButton = XRButton.createButton(renderer, createSessionConfig('immersive-ar'));
-                    document.body.appendChild(xrButton);
-                } else {
-                    // Fall back to VR if AR is not supported
-                    return navigator.xr.isSessionSupported('immersive-vr')
-                        .then(vrSupported => {
-                            if (vrSupported) {
-                                const xrButton = XRButton.createButton(renderer, createSessionConfig('immersive-vr'));
-                                document.body.appendChild(xrButton);
-                            } else {
-                                console.warn('Neither AR nor VR is supported');
-                            }
-                        });
-                }
-            })
-            .catch(err => {
-                console.error('Error checking XR session support:', err);
-            });
-
-        // Add session event listeners
-        renderer.xr.addEventListener('sessionstart', (event) => {
-            console.log('XR session started');
-            const session = event.target.getSession();
-            requestReferenceSpace(session, renderer);
-        });
-
-        renderer.xr.addEventListener('sessionend', () => {
-            console.log('XR session ended');
-            // Force a renderer reset
-            renderer.setPixelRatio(window.devicePixelRatio);
-            renderer.setSize(window.innerWidth, window.innerHeight);
-        });
-    } else {
-        console.warn('WebXR not supported in this browser.');
-    }
-
-    // Handle window resizes
-    window.addEventListener('resize', () => {
-        if (!renderer.xr.isPresenting) {
-            camera.aspect = window.innerWidth / window.innerHeight;
-            camera.updateProjectionMatrix();
-            renderer.setSize(window.innerWidth, window.innerHeight);
-        }
-    });
-
-    return xrInteraction;
-}
-
-/**
- * Request reference space with fallback options
- * @param {XRSession} session - The XR session
- * @param {THREE.WebGLRenderer} renderer - The Three.js renderer
- */
-async function requestReferenceSpace(session, renderer) {
-    try {
-        const refSpace = await session.requestReferenceSpace('local-floor');
-        console.log('Got local-floor reference space');
-        renderer.xr.setReferenceSpace(refSpace);
-    } catch (err) {
-        console.warn('Failed to get local-floor reference space:', err);
-        try {
-            const refSpace = await session.requestReferenceSpace('local');
-            console.log('Falling back to local reference space');
-            renderer.xr.setReferenceSpace(refSpace);
-        } catch (err) {
-            console.error('Failed to get any reference space:', err);
+    resetCameraRig() {
+        if (this.cameraRig) {
+            this.cameraRig.position.set(0, 0, 0);
+            this.cameraRig.rotation.set(0, 0, 0);
         }
-    }
-}
-
-/**
- * Updates camera position based on XR pose with error handling
- * @param {XRFrame} frame - The XR frame
- * @param {XRReferenceSpace} refSpace - The XR reference space
- * @param {THREE.Camera} camera - The Three.js camera
- */
-function updateCameraFromXRPose(frame, refSpace, camera) {
-    if (!frame || !refSpace || !camera) return;
-
-    try {
-        const pose = frame.getViewerPose(refSpace);
-        if (pose) {
-            const view = pose.views[0];
-            if (view) {
-                const position = new THREE.Vector3(
-                    view.transform.position.x,
-                    view.transform.position.y,
-                    view.transform.position.z
-                );
-                camera.position.copy(position);
-            }
+        if (this.camera) {
+            this.camera.position.set(0, 0, 0);
+            this.camera.rotation.set(0, 0, 0);
         }
-    } catch (error) {
-        console.error('Error updating camera from XR pose:', error);
-    }
-}
-
-/**
- * Handles the XR session's rendering loop with error recovery
- * @param {THREE.WebGLRenderer} renderer - The Three.js renderer
- * @param {THREE.Scene} scene - The Three.js scene
- * @param {THREE.Camera} camera - The Three.js camera
- * @param {Object} xrInteraction - The XR interaction instance
- * @param {EffectsManager} effectsManager - The effects manager instance
- */
-export function handleXRSession(renderer, scene, camera, xrInteraction, effectsManager) {
-    if (!renderer || !scene || !camera) {
-        console.error('Required parameters missing in handleXRSession');
-        return;
     }
 
-    let frameCount = 0;
-    const MAX_ERRORS = 5;
-    let errorCount = 0;
-
-    renderer.setAnimationLoop((timestamp, frame) => {
-        if (frame) {
-            try {
-                frameCount++;
-                const session = renderer.xr.getSession();
-                const refSpace = renderer.xr.getReferenceSpace();
-
-                if (session && refSpace) {
-                    updateCameraFromXRPose(frame, refSpace, camera);
+    /**
+     * Update XR frame
+     * @param {number} timestamp - Frame timestamp
+     * @param {XRFrame} frame - XR frame
+     */
+    update(timestamp, frame) {
+        if (!this.sessionActive || !frame) return;
 
-                    // Update hand tracking and interactions
-                    if (xrInteraction) {
-                        xrInteraction.update();
-                        handleXRInput(frame, refSpace);
-                    }
+        try {
+            // Update XR camera pose
+            if (this.referenceSpace) {
+                const pose = frame.getViewerPose(this.referenceSpace);
+                if (pose) {
+                    // Update camera rig based on pose
+                    const position = pose.transform.position;
+                    const orientation = pose.transform.orientation;
+                    
+                    this.cameraRig.position.set(position.x, position.y, position.z);
+                    this.cameraRig.quaternion.set(
+                        orientation.x,
+                        orientation.y,
+                        orientation.z,
+                        orientation.w
+                    );
+                }
+            }
 
-                    // Handle input sources
-                    for (const source of session.inputSources) {
-                        if (source?.gamepad?.handedness === 'left') {
-                            handleGamepadInput(source.gamepad, camera);
-                        }
-                    }
+            // Update XR interaction
+            if (this.xrInteraction) {
+                this.xrInteraction.update();
+                handleXRInput(frame, this.referenceSpace);
+            }
 
-                    // Reset error count on successful frames
-                    if (frameCount % 60 === 0) {
-                        errorCount = 0;
-                    }
-                }
-            } catch (error) {
-                console.error('Error in XR frame:', error);
-                errorCount++;
-                
-                // End session if too many errors occur
-                if (errorCount >= MAX_ERRORS) {
-                    console.error('Too many XR errors, ending session');
-                    renderer.xr.getSession()?.end();
-                    return;
+            // Handle input sources
+            const session = frame.session;
+            for (const inputSource of session.inputSources) {
+                if (inputSource.gamepad) {
+                    this.handleControllerInput(inputSource.gamepad);
                 }
             }
+
+        } catch (error) {
+            console.error('Error updating XR frame:', error);
         }
-        
-        // Render the scene using the effects manager
-        if (effectsManager) {
-            effectsManager.animate();
-            effectsManager.render();
-        } else {
-            // Fallback to direct rendering if effects manager is not available
-            renderer.render(scene, camera);
-        }
-    });
-}
+    }
 
-/**
- * Handles gamepad input in XR with improved movement
- * @param {Gamepad} gamepad - The XR gamepad
- * @param {THREE.Camera} camera - The Three.js camera
- */
-function handleGamepadInput(gamepad, camera) {
-    if (!gamepad || !camera || !camera.parent) return;
+    /**
+     * Handle controller input
+     * @param {Gamepad} gamepad - The XR gamepad
+     */
+    handleControllerInput(gamepad) {
+        if (!gamepad?.axes || gamepad.axes.length < 2) return;
 
-    try {
-        if (gamepad.axes.length >= 2) {
+        try {
             const [x, y] = gamepad.axes;
             const deadzone = 0.1;
 
             if (Math.abs(x) > deadzone || Math.abs(y) > deadzone) {
+                // Get movement direction in camera space
                 const forward = new THREE.Vector3();
-                camera.getWorldDirection(forward);
+                this.camera.getWorldDirection(forward);
                 forward.y = 0;
                 forward.normalize();
 
                 const right = new THREE.Vector3();
                 right.crossVectors(new THREE.Vector3(0, 1, 0), forward);
 
+                // Calculate movement
                 const movement = new THREE.Vector3();
                 movement.addScaledVector(right, x * MOVEMENT_SPEED);
                 movement.addScaledVector(forward, -y * MOVEMENT_SPEED);
 
-                const userGroup = camera.parent;
-                userGroup.position.add(movement);
+                // Apply movement to camera rig
+                this.cameraRig.position.add(movement);
             }
+        } catch (error) {
+            console.error('Error handling controller input:', error);
         }
-    } catch (error) {
-        console.error('Error handling gamepad input:', error);
     }
+
+    /**
+     * Clean up resources
+     */
+    dispose() {
+        this.originalScales.clear();
+        if (this.xrInteraction) {
+            this.xrInteraction.cleanup();
+        }
+    }
+}
+
+// Export functions
+export function initXRSession(renderer, scene, camera, effectsManager) {
+    // Check if renderer has XR capability
+    if (!renderer.xr) {
+        console.warn('WebXR not supported by renderer');
+        return null;
+    }
+
+    const xrSessionManager = new XRSessionManager(renderer, scene, camera, effectsManager);
+    xrSessionManager.init();
+    return xrSessionManager;
 }
 
 /**
- * Updates the XR frame with error handling
- * @param {THREE.WebGLRenderer} renderer - The Three.js renderer
- * @param {THREE.Scene} scene - The Three.js scene
- * @param {THREE.Camera} camera - The Three.js camera
- * @param {Object} xrInteraction - The XR interaction instance
- * @param {EffectsManager} effectsManager - The effects manager instance
+ * Add XR button to enable VR mode
+ * @param {XRSessionManager} xrSessionManager - The XR session manager
+ * @returns {Promise<void>}
  */
-export function updateXRFrame(renderer, scene, camera, xrInteraction, effectsManager) {
-    if (renderer.xr.isPresenting) {
-        try {
-            const session = renderer.xr.getSession();
-            if (session && xrInteraction) {
-                xrInteraction.update();
-            }
-        } catch (error) {
-            console.error('Error updating XR frame:', error);
-        }
-    }
-    
-    // Use effects manager for rendering if available
-    if (effectsManager) {
-        effectsManager.animate();
-        effectsManager.render();
-    } else {
-        renderer.render(scene, camera);
+export async function addXRButton(xrSessionManager) {
+    if (!xrSessionManager) {
+        console.warn('XR session manager not initialized');
+        return;
     }
+    await xrSessionManager.addXRButton();
+}
+
+export function handleXRSession(renderer, scene, camera, xrSessionManager) {
+    if (!xrSessionManager) return;
+
+    renderer.setAnimationLoop((timestamp, frame) => {
+        // Update XR session
+        xrSessionManager.update(timestamp, frame);
+
+        // Render scene with effects fallback
+        xrSessionManager.render();
+    });
+}
+
+export function updateXRFrame(renderer, scene, camera, xrSessionManager) {
+    if (!xrSessionManager?.sessionActive) return;
+
+    // Update XR session
+    const frame = renderer.xr.getFrame();
+    xrSessionManager.update(performance.now(), frame);
+
+    // Render scene with effects fallback
+    xrSessionManager.render();
 }
diff --git a/docker-compose.yml b/docker-compose.yml
index 7c5fc272..945d754f 100755
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -35,7 +35,11 @@ services:
     env_file:
       - .env
     volumes:
-      - ./data:/app/data
+      - ./data/markdown:/app/data/markdown
+      - ./data/piper:/app/data/piper
+      - ./data/public/js:/app/data/public/js
+      - ./data/public/favicon.ico:/app/data/public/favicon.ico
+      - ./data/public/index.html:/app/data/public/index.html
       - ./settings.toml:/app/settings.toml:ro
       - type: tmpfs
         target: /tmp
diff --git a/launch-docker.sh b/launch-docker.sh
index c2d61a57..4b77d4c5 100755
--- a/launch-docker.sh
+++ b/launch-docker.sh
@@ -112,7 +112,7 @@ cleanup_existing_processes() {
 
     # Clean up port if in use
     if netstat -tuln | grep -q ":$PORT "; then
-        local pid=$(lsof -t -i:"$PORT")
+        local pid=$(lsof -ti ":$PORT")
         if [ ! -z "$pid" ]; then
             kill -9 $pid
         fi
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
old mode 100644
new mode 100755
diff --git a/settings.toml b/settings.toml
old mode 100755
new mode 100644
diff --git a/start.sh b/start.sh
old mode 100644
new mode 100755
diff --git a/variables.md b/variables.md
old mode 100644
new mode 100755
