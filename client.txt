The following text represents a project with code. The structure of the text consists of sections beginning with ----, followed by a single line containing the file path and file name, and then a variable number of lines containing the file contents. The text representing the project ends when the symbols --END-- are encountered. Any further text beyond --END-- is meant to be interpreted as instructions using the aforementioned project as context.
----
index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Graph Visualization</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }
        #scene-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            background: #000000;
            touch-action: none;
        }
        #app {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        #app > * {
            pointer-events: auto;
        }
        #connection-status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.7);
        }
        canvas {
            display: block;
            outline: none;
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="app"></div>
    <div id="connection-status" class="disconnected">Disconnected</div>

    <script type="module">
        // Import and initialize app
        import('./index.ts')
            .then(() => {
                console.info('Application loaded successfully');
            })
            .catch(error => {
                console.error('Failed to load application', {
                    message: error.message,
                    stack: error.stack,
                    context: 'Application Load'
                });
            });
    </script>
</body>
</html>

----
index.ts
// Force-directed initialization must come first
import './init/forceDirected';

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './components/App.vue'
import { errorTracking } from './services/errorTracking'

// Disable Vue devtools
window.__VUE_PROD_DEVTOOLS__ = false

// Create Vue application
const app = createApp(App)

// Configure global error handler for Vue
app.config.errorHandler = (err, instance, info) => {
  // Track error with our service
  errorTracking.trackError(err, {
    context: 'Vue Error Handler',
    component: (instance as any)?.$options?.name || 'Unknown Component',
    additional: { info }
  })

  // Log to console in development
  if (process.env.NODE_ENV === 'development') {
    console.error('Vue Error:', err)
    console.error('Component:', instance)
    console.error('Error Info:', info)
  }
}

// Create and use Pinia
const pinia = createPinia()
app.use(pinia)

// Add error tracking to Pinia
pinia.use(() => {
  return {
    error: (error: Error) => {
      errorTracking.trackError(error, {
        context: 'Pinia Store',
        additional: { store: error?.cause }
      })
    }
  }
})

// Mount the app
app.mount('#app')

// Log successful initialization
console.info('Application initialized', {
  context: 'App Initialization',
  environment: process.env.NODE_ENV,
  forceDirected: false // Log that force-directed is disabled
})

----
init/forceDirected.ts
/**
 * Force-directed graph functionality is permanently disabled in favor of server-side calculations.
 * This file remains as a placeholder to maintain compatibility with existing code that may check
 * these values, but the functionality cannot be enabled.
 */

// Force-directed is permanently disabled
(window as any).__FORCE_DIRECTED_CLIENT = false;

// Always returns false since force-directed is permanently disabled
export function isForceDirectedEnabled(): boolean {
  return false;
}

// No-op since force-directed cannot be enabled
export function setForceDirected(_enabled: boolean): void {
  console.warn('Force-directed graph is permanently disabled in favor of server-side calculations.');
}

----
utils/gpuUtils.ts
import type { Vector3 } from 'three';

export interface GPUContext {
  initialized: boolean;
  webgl2: boolean;
}

export interface PositionUpdate {
  positions: NodePosition[];
}

export interface NodePosition {
  x: number;
  y: number;
  z: number;
  vx: number;
  vy: number;
  vz: number;
}

/**
 * Check if GPU/WebGL is available for rendering
 * @returns Promise that resolves to true if GPU rendering is available
 */
export async function isGPUAvailable(): Promise<boolean> {
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2') || 
               canvas.getContext('webgl') || 
               canvas.getContext('experimental-webgl');
    
    if (!gl) {
      console.warn('WebGL not available, rendering may be limited');
      return false;
    }

    // Check if it's WebGL 2
    if (gl instanceof WebGL2RenderingContext) {
      console.log('WebGL 2 available');
    } else {
      console.log('WebGL 1 available');
    }

    return true;
  } catch (error) {
    console.error('Error checking GPU availability:', error);
    return false;
  }
}

/**
 * Initialize GPU/WebGL context
 * @returns Promise that resolves to GPU context if available
 */
export async function initGPU(): Promise<GPUContext | null> {
  const available = await isGPUAvailable();
  if (available) {
    return {
      initialized: true,
      webgl2: typeof WebGL2RenderingContext !== 'undefined' && 
              document.createElement('canvas').getContext('webgl2') instanceof WebGL2RenderingContext
    };
  }
  return null;
}

/**
 * Apply position updates received from server
 * @param buffer - Binary position data from server (6 float32s per node: x,y,z,vx,vy,vz)
 * @returns Processed position data
 */
export function processPositionUpdate(buffer: ArrayBuffer): PositionUpdate | null {
  try {
    const dataView = new Float32Array(buffer);
    const positions: NodePosition[] = [];
    
    // Process 6 floats at a time (x,y,z,vx,vy,vz)
    for (let i = 0; i < dataView.length; i += 6) {
      if (i + 5 < dataView.length) {
        positions.push({
          x: dataView[i],
          y: dataView[i + 1],
          z: dataView[i + 2],
          vx: dataView[i + 3],
          vy: dataView[i + 4],
          vz: dataView[i + 5]
        });
      }
    }

    return { positions };
  } catch (error) {
    console.error('Error processing position update:', error);
    return null;
  }
}

/**
 * Convert NodePosition to Vector3
 * @param position - Node position data
 * @returns THREE.Vector3 position
 */
export function positionToVector3(position: NodePosition): Vector3 {
  return {
    x: position.x,
    y: position.y,
    z: position.z
  } as Vector3;
}

/**
 * Convert Vector3 to NodePosition
 * @param vector - THREE.Vector3 position
 * @returns Node position data
 */
export function vector3ToPosition(vector: Vector3): NodePosition {
  return {
    x: vector.x,
    y: vector.y,
    z: vector.z,
    vx: 0,
    vy: 0,
    vz: 0
  };
}

----
utils/threeUtils.ts
import type { 
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  Camera,
  WebGLRenderTarget,
  Texture,
  Object3D
} from 'three';

import type { Pass } from 'three/examples/jsm/postprocessing/Pass';
import type { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';

// Base pass interface that matches actual implementation
export interface BasePass extends Pass {
  render(
    renderer: WebGLRenderer,
    writeBuffer: WebGLRenderTarget<Texture> | null,
    readBuffer: WebGLRenderTarget<Texture>,
    deltaTime?: number,
    maskActive?: boolean
  ): void;
}

// Extended pass interface for custom functionality
export interface ExtendedPass extends BasePass {
  selectedObjects?: Object3D[];
  output?: number;
}

// Type assertion functions with any to bypass strict checks
export function asRenderer(renderer: any): WebGLRenderer {
  return renderer;
}

export function asScene(scene: any): Scene {
  return scene;
}

export function asCamera(camera: any): Camera {
  return camera;
}

export function asPass(pass: any): ExtendedPass {
  return pass;
}

export function asEffectComposer(composer: any): EffectComposer {
  return composer;
}

// Type guard for checking if an object is a valid Pass
export function isValidPass(obj: any): obj is ExtendedPass {
  return obj && typeof obj.render === 'function';
}

// Constants for pass outputs
export const PASS_OUTPUT = {
  Default: 0,
  Beauty: 1,
  Depth: 2,
  Normal: 3
};

----
utils/three.ts
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Export everything from three
export * from 'three';
// Export specific imports
export { OrbitControls };
// Export THREE as default
export default THREE;

----
utils/debug_log.ts
// Debug logging levels
export enum LogLevel {
  ERROR = 'ERROR',
  WARN = 'WARN',
  DEBUG = 'DEBUG'
}

// Debug settings interface matching settings.toml
interface ClientDebugSettings {
  enabled: boolean;
  enable_websocket_debug: boolean;
  enable_data_debug: boolean;
  log_binary_headers: boolean;
  log_full_json: boolean;
}

let debugSettings: ClientDebugSettings = {
  enabled: false,
  enable_websocket_debug: false,
  enable_data_debug: false,
  log_binary_headers: false,
  log_full_json: false
};

// Initialize debug settings
export function initDebugSettings(settings: Partial<ClientDebugSettings>) {
  debugSettings = { ...debugSettings, ...settings };
  console.info('Client debug settings initialized:', debugSettings);
}

// Format data for logging
function formatData(data: any): string {
  if (data instanceof ArrayBuffer) {
    const nodeCount = data.byteLength / 24;
    return `Binary Data: ${nodeCount} nodes, ${data.byteLength} bytes`;
  }
  
  if (data instanceof Event) {
    return `Event: ${data.type}`;
  }
  
  if (data instanceof Error) {
    return `Error: ${data.message}`;
  }
  
  if (typeof data === 'object') {
    try {
      return JSON.stringify(data, null, 2);
    } catch {
      return String(data);
    }
  }
  
  return String(data);
}

// Base logging function
function log(level: LogLevel, context: string, message: string, data?: any) {
  const timestamp = new Date().toISOString();
  const prefix = `[${level} ${context} ${timestamp}]`;
  
  switch (level) {
    case LogLevel.ERROR:
      console.error(`${prefix} ${message}`, data ? '\n' + formatData(data) : '');
      break;
    case LogLevel.WARN:
      if (debugSettings.enabled) {
        console.warn(`${prefix} ${message}`, data ? '\n' + formatData(data) : '');
      }
      break;
    case LogLevel.DEBUG:
      if (debugSettings.enabled || 
          (context === 'WS' && debugSettings.enable_websocket_debug) ||
          (context === 'DATA' && debugSettings.enable_data_debug)) {
        console.debug(`${prefix} ${message}`, data ? '\n' + formatData(data) : '');
      }
      break;
  }
}

// Exported logging functions
export const logError = (message: string, data?: any) => log(LogLevel.ERROR, 'APP', message, data);
export const logWarn = (message: string, data?: any) => log(LogLevel.WARN, 'APP', message, data);
export const logDebug = (message: string, data?: any) => log(LogLevel.DEBUG, 'APP', message, data);

// Context-specific logging
export const logWebsocket = (message: string, data?: any) => log(LogLevel.DEBUG, 'WS', message, data);
export const logData = (message: string, data?: any) => log(LogLevel.DEBUG, 'DATA', message, data);

// Binary data specific logging
export function logBinaryHeader(data: ArrayBuffer) {
  if (debugSettings.log_binary_headers) {
    const header = new Uint8Array(data.slice(0, 16));
    const hexHeader = Array.from(header)
      .map(b => b.toString(16).padStart(2, '0'))
      .join(' ');
    log(LogLevel.DEBUG, 'BINARY', `Header: ${hexHeader}`);
  }
}

// JSON specific logging
export function logJson(data: any) {
  if (debugSettings.log_full_json) {
    try {
      const formatted = JSON.stringify(data, null, 2);
      log(LogLevel.DEBUG, 'JSON', 'Full JSON data:', formatted);
    } catch (error) {
      log(LogLevel.ERROR, 'JSON', 'Failed to stringify JSON', error);
    }
  }
}

// Get current debug settings
export function getDebugSettings(): Readonly<ClientDebugSettings> {
  return { ...debugSettings };
}

// Toggle specific debug features
export function toggleDebugFeature(feature: keyof ClientDebugSettings): boolean {
  if (feature in debugSettings) {
    debugSettings[feature] = !debugSettings[feature];
    console.info(`Debug feature '${feature}' ${debugSettings[feature] ? 'enabled' : 'disabled'}`);
    return debugSettings[feature];
  }
  return false;
}

// Reset debug settings to default
export function resetDebugSettings() {
  debugSettings = {
    enabled: false,
    enable_websocket_debug: false,
    enable_data_debug: false,
    log_binary_headers: false,
    log_full_json: false
  };
  console.info('Debug settings reset to defaults');
}

----
utils/validation.ts
import { VALIDATION } from '../constants/visualization';

// Validate a single position value
export function isValidPosition(value: number): boolean {
    return !isNaN(value) && 
           isFinite(value) && 
           value >= VALIDATION.MIN_POSITION && 
           value <= VALIDATION.MAX_POSITION;
}

// Validate a single velocity value
export function isValidVelocity(value: number): boolean {
    return !isNaN(value) && 
           isFinite(value) && 
           value >= VALIDATION.MIN_VELOCITY && 
           value <= VALIDATION.MAX_VELOCITY;
}

// Check if position has changed enough to warrant an update
export function hasSignificantChange(oldPos: number, newPos: number): boolean {
    return Math.abs(oldPos - newPos) > VALIDATION.POSITION_CHANGE_THRESHOLD;
}

// Validate binary data size
export function isValidBinarySize(byteLength: number, nodeCount: number): boolean {
    const expectedSize = 4 + (nodeCount * VALIDATION.EXPECTED_BINARY_SIZE); // 4 bytes header + 24 bytes per node
    return byteLength === expectedSize;
}

// Validate and clamp position values
export function clampPosition(value: number): number {
    if (!isFinite(value) || isNaN(value)) return 0;
    return Math.max(VALIDATION.MIN_POSITION, Math.min(VALIDATION.MAX_POSITION, value));
}

// Validate and clamp velocity values
export function clampVelocity(value: number): number {
    if (!isFinite(value) || isNaN(value)) return 0;
    return Math.max(VALIDATION.MIN_VELOCITY, Math.min(VALIDATION.MAX_VELOCITY, value));
}

// Rate limiting helper
export class UpdateThrottler {
    private lastUpdateTime: number = 0;
    private pendingUpdates: ArrayBuffer[] = [];
    private batchTimeout: number | null = null;

    constructor(private minInterval: number = VALIDATION.UPDATE_INTERVAL) {}

    canUpdate(): boolean {
        const now = performance.now();
        return now - this.lastUpdateTime >= this.minInterval;
    }

    addUpdate(data: ArrayBuffer): void {
        this.pendingUpdates.push(data);
        
        // Start batch timeout if not already started
        if (this.batchTimeout === null && this.pendingUpdates.length < VALIDATION.BATCH_SIZE) {
            this.batchTimeout = window.setTimeout(() => this.processBatch(), this.minInterval);
        } else if (this.pendingUpdates.length >= VALIDATION.BATCH_SIZE) {
            // Process immediately if batch size reached
            if (this.batchTimeout !== null) {
                window.clearTimeout(this.batchTimeout);
                this.batchTimeout = null;
            }
            this.processBatch();
        }
    }

    private processBatch(): void {
        if (this.pendingUpdates.length === 0) return;

        // Use the most recent update
        const latestUpdate = this.pendingUpdates[this.pendingUpdates.length - 1];
        this.pendingUpdates = [];
        this.lastUpdateTime = performance.now();
        this.batchTimeout = null;

        // Notify listeners
        if (this.onUpdate) {
            this.onUpdate(latestUpdate);
        }
    }

    onUpdate: ((data: ArrayBuffer) => void) | null = null;

    reset(): void {
        this.pendingUpdates = [];
        if (this.batchTimeout !== null) {
            window.clearTimeout(this.batchTimeout);
            this.batchTimeout = null;
        }
    }
}

// Debug logging helper that respects settings.toml configuration
export class DebugLogger {
    private static instance: DebugLogger;
    private enabled: boolean = false;
    private websocketDebug: boolean = false;
    private dataDebug: boolean = false;
    private binaryHeaders: boolean = false;
    private fullJson: boolean = false;

    private constructor() {}

    static getInstance(): DebugLogger {
        if (!DebugLogger.instance) {
            DebugLogger.instance = new DebugLogger();
        }
        return DebugLogger.instance;
    }

    configure(settings: any): void {
        if (settings?.client_debug) {
            this.enabled = settings.client_debug.enabled;
            this.websocketDebug = settings.client_debug.enable_websocket_debug;
            this.dataDebug = settings.client_debug.enable_data_debug;
            this.binaryHeaders = settings.client_debug.log_binary_headers;
            this.fullJson = settings.client_debug.log_full_json;
        }
    }

    log(type: 'websocket' | 'data' | 'binary' | 'json', message: string, data?: any): void {
        if (!this.enabled) return;

        switch (type) {
            case 'websocket':
                if (this.websocketDebug) {
                    console.debug(`[WebSocket] ${message}`, data);
                }
                break;
            case 'data':
                if (this.dataDebug) {
                    console.debug(`[Data] ${message}`, data);
                }
                break;
            case 'binary':
                if (this.binaryHeaders) {
                    console.debug(`[Binary] ${message}`, data);
                }
                break;
            case 'json':
                if (this.fullJson) {
                    console.debug(`[JSON] ${message}`, data);
                }
                break;
        }
    }
}

----
shaders/fisheye.glsl
// TODO: Future client-side fisheye implementation
// This shader will be used to apply fisheye distortion during rendering,
// rather than modifying actual node positions.
//
// Implementation notes:
// - Should be applied in the visualization layer only
// - Operates on rendered positions, not data positions
// - Allows for interactive distortion without affecting layout
// - Can be toggled without impacting graph structure
//
// Example implementation (to be integrated later):
/*
uniform bool fisheyeEnabled;
uniform float fisheyeStrength;
uniform float fisheyeRadius;
uniform vec3 fisheyeFocusPoint;

vec3 applyFisheyeDistortion(vec3 position) {
    if (!fisheyeEnabled) {
        return position;
    }

    // Calculate distance from focus point
    vec3 directionFromFocus = position - fisheyeFocusPoint;
    float distance = length(directionFromFocus);
    
    if (distance > fisheyeRadius) {
        return position;
    }

    // Normalize distance to [0,1] range
    float normalizedDistance = distance / fisheyeRadius;
    
    // Calculate distortion factor
    float distortionFactor = 1.0 - (1.0 - normalizedDistance) * fisheyeStrength;
    
    // Apply distortion
    return fisheyeFocusPoint + directionFromFocus * distortionFactor;
}
*/

----
xr/xrSetup.js
import * as THREE from 'three';
import { XRButton } from 'three/examples/jsm/webxr/XRButton.js';
import { initXRInteraction, handleXRInput } from './xrInteraction.js';

// Constants
const MOVEMENT_SPEED = 0.05;
const XR_SPRITE_SCALE = 0.5;

/**
 * Enhanced XR Session Manager using Three.js WebXR
 */
class XRSessionManager {
    constructor(renderer, scene, camera, effectsManager) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.effectsManager = effectsManager;
        this.referenceSpace = null;
        this.originalScales = new WeakMap();
        this.xrInteraction = null;
        this.sessionActive = false;
        this.cameraRig = null;
        this.effectsEnabled = true;
    }

    /**
     * Initialize XR session manager
     */
    async init() {
        try {
            // Check if XR is supported
            if (!this.renderer.xr) {
                console.warn('WebXR not supported by renderer');
                return;
            }

            // Enable XR on renderer
            this.renderer.xr.enabled = true;

            // Initialize camera rig
            this.initCameraRig();

            // Initialize XR interaction
            this.xrInteraction = initXRInteraction(this.scene, this.camera, this.renderer);

            // Set up session event handlers
            this.setupEventHandlers();

        } catch (error) {
            console.error('Error initializing XR session manager:', error);
        }
    }

    /**
     * Initialize camera rig with proper hierarchy
     */
    initCameraRig() {
        // Create camera rig if it doesn't exist
        if (!this.cameraRig) {
            this.cameraRig = new THREE.Group();
            this.cameraRig.name = 'cameraRig';
        }

        // Create camera offset for height adjustment if not already a child of the rig
        let cameraOffset = this.cameraRig.children.find(child => child.name === 'cameraOffset');
        if (!cameraOffset) {
            cameraOffset = new THREE.Group();
            cameraOffset.name = 'cameraOffset';
            cameraOffset.position.y = 1.6; // Average eye height
            this.cameraRig.add(cameraOffset);
        }

        // Add camera to offset if not already there
        if (!cameraOffset.children.includes(this.camera)) {
            this.camera.name = 'xrCamera';
            cameraOffset.add(this.camera);
        }

        // Add rig to scene if not already there
        if (!this.scene.children.includes(this.cameraRig)) {
            this.scene.add(this.cameraRig);
        }

        // Set initial positions
        this.camera.position.set(0, 0, 0);
        this.cameraRig.position.set(0, 0, 0);
    }

    /**
     * Set up session event handlers
     */
    setupEventHandlers() {
        // Session start handler
        this.renderer.xr.addEventListener('sessionstart', async (event) => {
            console.log('XR session started');
            this.sessionActive = true;

            const session = this.renderer.xr.getSession();
            await this.setupReferenceSpace(session);
            this.handleXRSprites(true);

            // Initialize camera position
            this.cameraRig.position.set(0, 0, 0);
            this.camera.position.set(0, 0, 0);

            // Initialize XR-specific effects
            if (this.effectsManager) {
                try {
                    await this.effectsManager.initPostProcessing(true);
                    this.effectsEnabled = true;
                } catch (error) {
                    console.error('Failed to initialize XR effects:', error);
                    this.effectsEnabled = false;
                }
            }

            window.dispatchEvent(new CustomEvent('xrsessionstart'));
        });

        // Session end handler
        this.renderer.xr.addEventListener('sessionend', () => {
            console.log('XR session ended');
            this.sessionActive = false;
            this.handleXRSprites(false);
            this.resetCameraRig();

            // Reinitialize desktop effects
            if (this.effectsManager) {
                try {
                    this.effectsManager.initPostProcessing(false);
                    this.effectsEnabled = true;
                } catch (error) {
                    console.error('Failed to reinitialize desktop effects:', error);
                    this.effectsEnabled = false;
                }
            }

            window.dispatchEvent(new CustomEvent('xrsessionend'));
        });
    }

    /**
     * Render scene with effects fallback
     */
    render() {
        if (this.effectsManager && this.effectsEnabled) {
            try {
                this.effectsManager.render();
            } catch (error) {
                console.error('Error in effects rendering:', error);
                this.effectsEnabled = false;
                this.fallbackRender();
            }
        } else {
            this.fallbackRender();
        }
    }

    /**
     * Fallback render without effects
     */
    fallbackRender() {
        const currentCamera = this.sessionActive ? this.renderer.xr.getCamera() : this.camera;
        this.renderer.render(this.scene, currentCamera);
    }

    /**
     * Add XR button to the scene
     * @returns {Promise<void>}
     */
    async addXRButton() {
        try {
            if (!this.renderer.xr.enabled) {
                console.warn('XR not enabled on renderer');
                return;
            }

            const sessionInit = {
                optionalFeatures: [
                    'local-floor',
                    'bounded-floor',
                    'hand-tracking',
                    'layers'
                ]
            };

            // Check if VR is supported
            const isVRSupported = await navigator.xr?.isSessionSupported('immersive-vr');
            
            if (isVRSupported) {
                const button = XRButton.createButton(this.renderer, {
                    mode: 'immersive-vr',
                    sessionInit,
                    onSessionStarted: (session) => this.onSessionStarted(session),
                    onSessionEnded: () => this.onSessionEnded()
                });
                document.body.appendChild(button);
            } else {
                console.warn('VR not supported on this device');
            }
        } catch (error) {
            console.error('Error adding XR button:', error);
        }
    }

    /**
     * Handle session start
     * @param {XRSession} session - The XR session
     */
    async onSessionStarted(session) {
        try {
            await this.setupReferenceSpace(session);
            this.handleXRSprites(true);
        } catch (error) {
            console.error('Error starting XR session:', error);
        }
    }

    /**
     * Handle session end
     */
    onSessionEnded() {
        this.handleXRSprites(false);
        this.resetCameraRig();
    }

    /**
     * Set up reference space with fallback options
     * @param {XRSession} session - The XR session
     */
    async setupReferenceSpace(session) {
        try {
            this.referenceSpace = await session.requestReferenceSpace('local-floor');
            console.log('Using local-floor reference space');
        } catch (error) {
            console.warn('Failed to get local-floor reference space:', error);
            try {
                this.referenceSpace = await session.requestReferenceSpace('local');
                console.log('Falling back to local reference space');
            } catch (error) {
                console.error('Failed to get any reference space:', error);
            }
        }
    }

    /**
     * Handle sprite scaling for XR
     * @param {boolean} enteringXR - Whether entering or exiting XR
     */
    handleXRSprites(enteringXR) {
        this.scene.traverse((object) => {
            if (object.isSprite) {
                if (enteringXR) {
                    this.originalScales.set(object, object.scale.clone());
                    object.scale.multiplyScalar(XR_SPRITE_SCALE);
                    object.layers.enableAll();
                    
                    if (object.material.map) {
                        object.material.map.generateMipmaps = false;
                        object.material.map.minFilter = THREE.LinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                } else {
                    const originalScale = this.originalScales.get(object);
                    if (originalScale) {
                        object.scale.copy(originalScale);
                    }
                    
                    if (object.material.map) {
                        object.material.map.generateMipmaps = true;
                        object.material.map.minFilter = THREE.LinearMipmapLinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                }
            }
        });
    }

    /**
     * Reset camera rig to initial position
     */
    resetCameraRig() {
        if (this.cameraRig) {
            this.cameraRig.position.set(0, 0, 0);
            this.cameraRig.rotation.set(0, 0, 0);
        }
        if (this.camera) {
            this.camera.position.set(0, 0, 0);
            this.camera.rotation.set(0, 0, 0);
        }
    }

    /**
     * Update XR frame
     * @param {number} timestamp - Frame timestamp
     * @param {XRFrame} frame - XR frame
     */
    update(timestamp, frame) {
        if (!this.sessionActive || !frame) return;

        try {
            // Update XR camera pose
            if (this.referenceSpace) {
                const pose = frame.getViewerPose(this.referenceSpace);
                if (pose) {
                    // Update camera rig based on pose
                    const position = pose.transform.position;
                    const orientation = pose.transform.orientation;
                    
                    this.cameraRig.position.set(position.x, position.y, position.z);
                    this.cameraRig.quaternion.set(
                        orientation.x,
                        orientation.y,
                        orientation.z,
                        orientation.w
                    );
                }
            }

            // Update XR interaction
            if (this.xrInteraction) {
                this.xrInteraction.update();
                handleXRInput(frame, this.referenceSpace);
            }

            // Handle input sources
            const session = frame.session;
            for (const inputSource of session.inputSources) {
                if (inputSource.gamepad) {
                    this.handleControllerInput(inputSource.gamepad);
                }
            }

        } catch (error) {
            console.error('Error updating XR frame:', error);
        }
    }

    /**
     * Handle controller input
     * @param {Gamepad} gamepad - The XR gamepad
     */
    handleControllerInput(gamepad) {
        if (!gamepad?.axes || gamepad.axes.length < 2) return;

        try {
            const [x, y] = gamepad.axes;
            const deadzone = 0.1;

            if (Math.abs(x) > deadzone || Math.abs(y) > deadzone) {
                // Get movement direction in camera space
                const forward = new THREE.Vector3();
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);

                // Calculate movement
                const movement = new THREE.Vector3();
                movement.addScaledVector(right, x * MOVEMENT_SPEED);
                movement.addScaledVector(forward, -y * MOVEMENT_SPEED);

                // Apply movement to camera rig
                this.cameraRig.position.add(movement);
            }
        } catch (error) {
            console.error('Error handling controller input:', error);
        }
    }

    /**
     * Clean up resources
     */
    dispose() {
        this.originalScales.clear();
        if (this.xrInteraction) {
            this.xrInteraction.cleanup();
        }
    }
}

// Export functions
export function initXRSession(renderer, scene, camera, effectsManager) {
    // Check if renderer has XR capability
    if (!renderer.xr) {
        console.warn('WebXR not supported by renderer');
        return null;
    }

    const xrSessionManager = new XRSessionManager(renderer, scene, camera, effectsManager);
    xrSessionManager.init();
    return xrSessionManager;
}

/**
 * Add XR button to enable VR mode
 * @param {XRSessionManager} xrSessionManager - The XR session manager
 * @returns {Promise<void>}
 */
export async function addXRButton(xrSessionManager) {
    if (!xrSessionManager) {
        console.warn('XR session manager not initialized');
        return;
    }
    await xrSessionManager.addXRButton();
}

export function handleXRSession(renderer, scene, camera, xrSessionManager) {
    if (!xrSessionManager) return;

    renderer.setAnimationLoop((timestamp, frame) => {
        // Update XR session
        xrSessionManager.update(timestamp, frame);

        // Render scene with effects fallback
        xrSessionManager.render();
    });
}

export function updateXRFrame(renderer, scene, camera, xrSessionManager) {
    if (!xrSessionManager?.sessionActive) return;

    // Update XR session
    const frame = renderer.xr.getFrame();
    xrSessionManager.update(performance.now(), frame);

    // Render scene with effects fallback
    xrSessionManager.render();
}

----
xr/xrInteraction.js
import * as THREE from 'three';
import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory.js';

// Constants for interaction
const PINCH_THRESHOLD = 0.015;
const GRAB_THRESHOLD = 0.08;
const PINCH_STRENGTH_THRESHOLD = 0.7;
const LABEL_SIZE = { width: 256, height: 128 };
const LABEL_SCALE = { x: 0.5, y: 0.25, z: 1 };

/**
 * Enhanced XR Interaction Handler
 */
class EnhancedXRInteractionHandler {
    constructor(scene, camera, renderer) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Hand tracking
        this.handModelFactory = new XRHandModelFactory();
        this.hands = { left: null, right: null };
        this.handModels = { left: null, right: null };
        
        // Interaction states
        this.grabStates = {
            left: { grabbedObject: null, pinching: false },
            right: { grabbedObject: null, pinching: false }
        };
        
        // Visual feedback
        this.pinchIndicators = { left: null, right: null };
        
        // Interactable objects
        this.interactableObjects = new Set();
        
        // Resource pools
        this.materialPool = new Map();
        this.geometryPool = new Map();
        
        // Initialize resources
        this.initResources();
    }

    /**
     * Initialize shared resources
     */
    initResources() {
        // Create pinch indicator geometry
        const geometry = new THREE.SphereGeometry(0.01, 8, 8);
        this.geometryPool.set('pinchIndicator', geometry);

        // Create pinch indicator material
        const material = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5,
            depthWrite: false
        });
        this.materialPool.set('pinchIndicator', material);

        // Create pinch indicators
        this.pinchIndicators.left = this.createPinchIndicator();
        this.pinchIndicators.right = this.createPinchIndicator();
        this.scene.add(this.pinchIndicators.left);
        this.scene.add(this.pinchIndicators.right);
    }

    /**
     * Initialize hand tracking
     * @param {XRSession} session - The XR session
     */
    async initHandTracking(session) {
        try {
            // Set up hand tracking
            for (const handedness of ['left', 'right']) {
                const hand = this.renderer.xr.getHand(handedness === 'left' ? 0 : 1);
                const handModel = this.handModelFactory.createHandModel(hand, 'mesh');
                
                this.hands[handedness] = hand;
                this.handModels[handedness] = handModel;
                
                hand.add(handModel);
                this.scene.add(hand);

                // Add hand input event listeners
                hand.addEventListener('pinchstart', () => this.onPinchStart(handedness));
                hand.addEventListener('pinchend', () => this.onPinchEnd(handedness));
            }

            // Set up hand tracking events
            session.addEventListener('handtracking', (event) => {
                const hand = event.hand;
                const handedness = hand.handedness;
                
                // Update hand model visibility
                if (this.handModels[handedness]) {
                    this.handModels[handedness].visible = hand.visible;
                }
            });
        } catch (error) {
            console.error('Error initializing hand tracking:', error);
        }
    }

    /**
     * Create visual feedback for pinch state
     * @returns {THREE.Mesh} Pinch indicator mesh
     */
    createPinchIndicator() {
        const geometry = this.geometryPool.get('pinchIndicator');
        const material = this.materialPool.get('pinchIndicator').clone();
        return new THREE.Mesh(geometry, material);
    }

    /**
     * Update pinch indicator position and appearance
     * @param {XRHand} hand - The XR hand
     * @param {THREE.Mesh} indicator - The pinch indicator mesh
     */
    updatePinchIndicator(hand, indicator) {
        if (!hand?.joints || !indicator) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];
            
            if (indexTip && thumbTip) {
                // Position indicator between finger and thumb
                indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
                
                // Update appearance based on pinch strength
                const { strength } = this.isPinching(hand);
                indicator.material.opacity = strength * 0.8;
                indicator.scale.setScalar(1 - (strength * 0.5));
            }
        } catch (error) {
            console.error('Error updating pinch indicator:', error);
        }
    }

    /**
     * Check if hand is performing pinch gesture
     * @param {XRHand} hand - The XR hand
     * @returns {object} Pinch state and strength
     */
    isPinching(hand) {
        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];

            if (indexTip && thumbTip) {
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
                return { isPinched: distance < PINCH_THRESHOLD, strength };
            }
        } catch (error) {
            console.error('Error detecting pinch:', error);
        }
        return { isPinched: false, strength: 0 };
    }

    /**
     * Handle pinch start event
     * @param {string} handedness - The hand that started pinching
     */
    onPinchStart(handedness) {
        const hand = this.hands[handedness];
        const grabState = this.grabStates[handedness];

        if (!hand || grabState.pinching) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            
            // Find closest interactable object
            let closestObject = null;
            let closestDistance = GRAB_THRESHOLD;

            for (const object of this.interactableObjects) {
                if (!object.userData.isGrabbed) {
                    const distance = indexTip.position.distanceTo(object.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestObject = object;
                    }
                }
            }

            if (closestObject) {
                grabState.grabbedObject = closestObject;
                closestObject.userData.isGrabbed = true;
                
                // Highlight grabbed object
                if (closestObject.material?.emissive) {
                    closestObject.material.emissive.setHex(0x222222);
                }
            }

            grabState.pinching = true;
        } catch (error) {
            console.error('Error handling pinch start:', error);
        }
    }

    /**
     * Handle pinch end event
     * @param {string} handedness - The hand that ended pinching
     */
    onPinchEnd(handedness) {
        const grabState = this.grabStates[handedness];

        if (!grabState.pinching) return;

        try {
            if (grabState.grabbedObject) {
                grabState.grabbedObject.userData.isGrabbed = false;
                if (grabState.grabbedObject.material?.emissive) {
                    grabState.grabbedObject.material.emissive.setHex(0x000000);
                }
                grabState.grabbedObject = null;
            }

            grabState.pinching = false;
        } catch (error) {
            console.error('Error handling pinch end:', error);
        }
    }

    /**
     * Make an object interactable
     * @param {THREE.Object3D} object - The object to make interactable
     */
    makeInteractable(object) {
        object.userData.interactable = true;
        this.interactableObjects.add(object);
    }

    /**
     * Remove interactable status from object
     * @param {THREE.Object3D} object - The object to remove
     */
    removeInteractable(object) {
        object.userData.interactable = false;
        this.interactableObjects.delete(object);
    }

    /**
     * Update interaction state
     */
    update() {
        try {
            // Update both hands
            for (const [handedness, hand] of Object.entries(this.hands)) {
                if (hand?.joints) {
                    const grabState = this.grabStates[handedness];
                    const { isPinched, strength } = this.isPinching(hand);
                    
                    this.updatePinchIndicator(hand, this.pinchIndicators[handedness]);

                    if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                        if (grabState.grabbedObject) {
                            // Update grabbed object position
                            const indexTip = hand.joints['index-finger-tip'];
                            grabState.grabbedObject.position.copy(indexTip.position);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error in XR interaction update:', error);
        }
    }

    /**
     * Clean up resources
     */
    cleanup() {
        try {
            // Dispose of geometries
            this.geometryPool.forEach(geometry => geometry.dispose());
            this.geometryPool.clear();

            // Dispose of materials
            this.materialPool.forEach(material => material.dispose());
            this.materialPool.clear();

            // Remove pinch indicators
            Object.values(this.pinchIndicators).forEach(indicator => {
                if (indicator) {
                    if (indicator.geometry) indicator.geometry.dispose();
                    if (indicator.material) indicator.material.dispose();
                    this.scene.remove(indicator);
                }
            });

            // Remove hand models
            Object.values(this.hands).forEach(hand => {
                if (hand) {
                    this.scene.remove(hand);
                }
            });

            // Clear collections
            this.interactableObjects.clear();
            this.grabStates.left = { grabbedObject: null, pinching: false };
            this.grabStates.right = { grabbedObject: null, pinching: false };
        } catch (error) {
            console.error('Error cleaning up XR interaction:', error);
        }
    }
}

// Export functions
export function initXRInteraction(scene, camera, renderer) {
    return new EnhancedXRInteractionHandler(scene, camera, renderer);
}

export function handleXRInput(frame, referenceSpace) {
    // This function is now handled internally by EnhancedXRInteractionHandler
    // Left for backward compatibility
}

----
xr/xrInteraction.ts
import * as THREE from 'three';
import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory.js';
import type { Scene, Camera, WebGLRenderer, Object3D } from 'three';

// Constants for interaction
const PINCH_THRESHOLD = 0.015;
const GRAB_THRESHOLD = 0.08;
const PINCH_STRENGTH_THRESHOLD = 0.7;
const UPDATE_INTERVAL = 200; // 5 FPS (200ms between updates)

interface GrabState {
    grabbedObject: Object3D | null;
    pinching: boolean;
}

interface HandState {
    [key: string]: any;
    joints: {
        [key: string]: THREE.Object3D & {
            position: THREE.Vector3;
        };
    };
}

interface PinchState {
    isPinched: boolean;
    strength: number;
}

interface InteractableMesh extends THREE.Mesh {
    material: THREE.MeshPhongMaterial | THREE.MeshStandardMaterial;
}

interface PositionUpdate {
    nodeId: string;
    position: THREE.Vector3;
    timestamp: number;
}

export class EnhancedXRInteractionHandler {
    private scene: Scene;
    private camera: Camera;
    private renderer: WebGLRenderer;
    private handModelFactory: XRHandModelFactory;
    private hands: { [key: string]: HandState | null };
    private handModels: { [key: string]: Object3D | null };
    private grabStates: { [key: string]: GrabState };
    private pinchIndicators: { [key: string]: THREE.Mesh | null };
    private interactableObjects: Set<Object3D>;
    private materialPool: Map<string, THREE.MeshPhongMaterial>;
    private geometryPool: Map<string, THREE.BufferGeometry>;
    private lastUpdateTime: number;
    private pendingUpdates: Map<string, PositionUpdate>;
    private onPositionUpdate?: (nodeId: string, position: THREE.Vector3) => void;

    constructor(scene: Scene, camera: Camera, renderer: WebGLRenderer) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        this.handModelFactory = new XRHandModelFactory();
        this.hands = { left: null, right: null };
        this.handModels = { left: null, right: null };
        
        this.grabStates = {
            left: { grabbedObject: null, pinching: false },
            right: { grabbedObject: null, pinching: false }
        };
        
        this.pinchIndicators = { left: null, right: null };
        this.interactableObjects = new Set();
        this.materialPool = new Map();
        this.geometryPool = new Map();
        this.lastUpdateTime = 0;
        this.pendingUpdates = new Map();
        
        this.initResources();
    }

    private initResources(): void {
        const geometry = new THREE.SphereGeometry(0.01, 8, 8);
        this.geometryPool.set('pinchIndicator', geometry);

        const material = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5,
            depthWrite: false
        });
        this.materialPool.set('pinchIndicator', material);

        this.pinchIndicators.left = this.createPinchIndicator();
        this.pinchIndicators.right = this.createPinchIndicator();
        this.scene.add(this.pinchIndicators.left!);
        this.scene.add(this.pinchIndicators.right!);
    }

    async initHandTracking(session: XRSession): Promise<void> {
        try {
            for (const handedness of ['left', 'right']) {
                const hand = this.renderer.xr.getHand(handedness === 'left' ? 0 : 1);
                const handModel = this.handModelFactory.createHandModel(hand, 'mesh');
                
                this.hands[handedness] = hand as unknown as HandState;
                this.handModels[handedness] = handModel;
                
                hand.add(handModel);
                this.scene.add(hand);

                hand.addEventListener('pinchstart', () => this.onPinchStart(handedness));
                hand.addEventListener('pinchend', () => this.onPinchEnd(handedness));
            }

            session.addEventListener('handtracking', (event: any) => {
                const hand = event.hand;
                const handedness = hand.handedness;
                
                if (this.handModels[handedness]) {
                    this.handModels[handedness]!.visible = hand.visible;
                }
            });
        } catch (error) {
            console.error('Error initializing hand tracking:', error);
        }
    }

    private createPinchIndicator(): THREE.Mesh {
        const geometry = this.geometryPool.get('pinchIndicator')!;
        const material = this.materialPool.get('pinchIndicator')!.clone();
        return new THREE.Mesh(geometry, material);
    }

    private updatePinchIndicator(hand: HandState, indicator: THREE.Mesh): void {
        if (!hand?.joints || !indicator) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];
            
            if (indexTip && thumbTip && indicator.material instanceof THREE.MeshPhongMaterial) {
                indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
                const { strength } = this.isPinching(hand);
                indicator.material.opacity = strength * 0.8;
                indicator.scale.setScalar(1 - (strength * 0.5));
            }
        } catch (error) {
            console.error('Error updating pinch indicator:', error);
        }
    }

    private isPinching(hand: HandState): PinchState {
        try {
            const indexTip = hand.joints['index-finger-tip'];
            const thumbTip = hand.joints['thumb-tip'];

            if (indexTip && thumbTip) {
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
                return { isPinched: distance < PINCH_THRESHOLD, strength };
            }
        } catch (error) {
            console.error('Error detecting pinch:', error);
        }
        return { isPinched: false, strength: 0 };
    }

    private onPinchStart(handedness: string): void {
        const hand = this.hands[handedness];
        const grabState = this.grabStates[handedness];

        if (!hand || grabState.pinching) return;

        try {
            const indexTip = hand.joints['index-finger-tip'];
            
            let closestObject: Object3D | null = null;
            let closestDistance = GRAB_THRESHOLD;

            for (const object of this.interactableObjects) {
                if (!object.userData.isGrabbed) {
                    const distance = indexTip.position.distanceTo(object.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestObject = object;
                    }
                }
            }

            if (closestObject && this.isInteractableMesh(closestObject)) {
                grabState.grabbedObject = closestObject;
                closestObject.userData.isGrabbed = true;
                
                if (closestObject.material instanceof THREE.MeshStandardMaterial) {
                    closestObject.material.emissive.setHex(0x222222);
                }
            }

            grabState.pinching = true;
        } catch (error) {
            console.error('Error handling pinch start:', error);
        }
    }

    private onPinchEnd(handedness: string): void {
        const grabState = this.grabStates[handedness];

        if (!grabState.pinching) return;

        try {
            if (grabState.grabbedObject && this.isInteractableMesh(grabState.grabbedObject)) {
                grabState.grabbedObject.userData.isGrabbed = false;
                if (grabState.grabbedObject.material instanceof THREE.MeshStandardMaterial) {
                    grabState.grabbedObject.material.emissive.setHex(0x000000);
                }
                grabState.grabbedObject = null;
            }

            grabState.pinching = false;
        } catch (error) {
            console.error('Error handling pinch end:', error);
        }
    }

    private isInteractableMesh(object: Object3D): object is InteractableMesh {
        return object instanceof THREE.Mesh && 
               (object.material instanceof THREE.MeshPhongMaterial || 
                object.material instanceof THREE.MeshStandardMaterial);
    }

    setPositionUpdateCallback(callback: (nodeId: string, position: THREE.Vector3) => void): void {
        this.onPositionUpdate = callback;
    }

    private processPendingUpdates(): void {
        const now = performance.now();
        if (now - this.lastUpdateTime < UPDATE_INTERVAL) {
            return;
        }

        this.pendingUpdates.forEach((update, nodeId) => {
            if (this.onPositionUpdate) {
                this.onPositionUpdate(nodeId, update.position);
            }
        });

        this.pendingUpdates.clear();
        this.lastUpdateTime = now;
    }

    makeInteractable(object: Object3D): void {
        object.userData.interactable = true;
        this.interactableObjects.add(object);
    }

    removeInteractable(object: Object3D): void {
        object.userData.interactable = false;
        this.interactableObjects.delete(object);
    }

    update(): void {
        try {
            for (const [handedness, hand] of Object.entries(this.hands)) {
                if (hand?.joints) {
                    const grabState = this.grabStates[handedness];
                    const { isPinched, strength } = this.isPinching(hand);
                    
                    this.updatePinchIndicator(hand, this.pinchIndicators[handedness]!);

                    if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                        if (grabState.grabbedObject) {
                            const indexTip = hand.joints['index-finger-tip'];
                            grabState.grabbedObject.position.copy(indexTip.position);

                            // Queue position update
                            if (grabState.grabbedObject.userData.id) {
                                this.pendingUpdates.set(grabState.grabbedObject.userData.id, {
                                    nodeId: grabState.grabbedObject.userData.id,
                                    position: grabState.grabbedObject.position.clone(),
                                    timestamp: performance.now()
                                });
                            }
                        }
                    }
                }
            }

            // Process pending updates at 5 FPS
            this.processPendingUpdates();
        } catch (error) {
            console.error('Error in XR interaction update:', error);
        }
    }

    cleanup(): void {
        try {
            this.geometryPool.forEach(geometry => geometry.dispose());
            this.geometryPool.clear();

            this.materialPool.forEach(material => material.dispose());
            this.materialPool.clear();

            Object.values(this.pinchIndicators).forEach(indicator => {
                if (indicator) {
                    if (indicator.geometry) indicator.geometry.dispose();
                    if (indicator.material instanceof THREE.Material) {
                        indicator.material.dispose();
                    }
                    this.scene.remove(indicator);
                }
            });

            Object.values(this.hands).forEach(hand => {
                if (hand) {
                    this.scene.remove(hand as unknown as Object3D);
                }
            });

            this.interactableObjects.clear();
            this.grabStates.left = { grabbedObject: null, pinching: false };
            this.grabStates.right = { grabbedObject: null, pinching: false };
            this.pendingUpdates.clear();
        } catch (error) {
            console.error('Error cleaning up XR interaction:', error);
        }
    }
}

export function initXRInteraction(
    scene: Scene, 
    camera: Camera, 
    renderer: WebGLRenderer, 
    onPositionUpdate?: (nodeId: string, position: THREE.Vector3) => void
): EnhancedXRInteractionHandler {
    const handler = new EnhancedXRInteractionHandler(scene, camera, renderer);
    if (onPositionUpdate) {
        handler.setPositionUpdateCallback(onPositionUpdate);
    }
    return handler;
}

----
platform/platformManager.ts
import { ref, shallowRef } from 'vue';
import type { CoreState, PlatformCapabilities, SceneConfig, Transform } from '../types/core';
import type { BrowserState, BrowserInitOptions } from '../types/platform/browser';
import type { QuestState, QuestInitOptions, XRController, XRHand, XRHandedness, XRSession, XRHitTestSource } from '../types/platform/quest';
import * as THREE from 'three';
import type { Object3D, Material, BufferGeometry, PerspectiveCamera, OrthographicCamera, Group, WebGLRenderer, Camera } from 'three';

// Import OrbitControls dynamically to avoid type conflicts
let OrbitControls: any;

export type PlatformState = BrowserState | QuestState;
type ResizeCallback = (width: number, height: number) => void;
type RenderCallback = (renderer: WebGLRenderer, scene: THREE.Scene, camera: Camera) => void;

/**
 * Platform Manager Interface
 * Defines the contract for platform-specific implementations
 */
export interface IPlatformManager {
  initialize(options: BrowserInitOptions | QuestInitOptions): Promise<void>;
  dispose(): void;
  getState(): PlatformState | null;
  getCapabilities(): PlatformCapabilities | null;
  getPlatform(): 'browser' | 'quest';
  isQuest(): boolean;
  isBrowser(): boolean;
  hasXRSupport(): boolean;
  startXRSession(mode: 'immersive-vr' | 'immersive-ar'): Promise<XRSession>;
  endXRSession(): Promise<void>;
  isInXRSession(): boolean;
  getXRSessionMode(): 'immersive-vr' | 'immersive-ar' | null;
  onResize(callback: ResizeCallback): () => void;
  onBeforeRender(callback: RenderCallback): () => void;
}

/**
 * Platform Manager Implementation
 * Handles platform-specific initialization and XR session management
 */
export class PlatformManager implements IPlatformManager {
  private static instance: PlatformManager;
  private state = shallowRef<PlatformState | null>(null);
  private capabilities = ref<PlatformCapabilities | null>(null);
  private platform: 'browser' | 'quest' = 'browser';
  private animationFrameId: number | null = null;
  private resizeCallbacks: Set<ResizeCallback> = new Set();
  private renderCallbacks: Set<RenderCallback> = new Set();
  private lastFrameTime = 0;
  private xrSessionMode: 'immersive-vr' | 'immersive-ar' | null = null;

  private constructor() {
    this.detectPlatform();
    this.setupResizeHandler();
  }

  /**
   * Get singleton instance of PlatformManager
   */
  static getInstance(): PlatformManager {
    if (!PlatformManager.instance) {
      PlatformManager.instance = new PlatformManager();
    }
    return PlatformManager.instance;
  }

  /**
   * Initialize platform with given options
   */
  async initialize(options: BrowserInitOptions | QuestInitOptions): Promise<void> {
    if (this.platform === 'quest') {
      await this.initializeQuest(options as QuestInitOptions);
    } else {
      await this.initializeBrowser(options as BrowserInitOptions);
    }

    if (this.state.value?.canvas) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      this.resizeCallbacks.forEach(callback => callback(width, height));
    }
  }

  /**
   * Initialize Quest platform with XR support
   */
  private async initializeQuest(options: QuestInitOptions): Promise<void> {
    const sceneConfig: SceneConfig = {
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance'
    };

    const renderer = new THREE.WebGLRenderer({
      canvas: options.canvas,
      ...sceneConfig,
      xr: { enabled: true }
    });

    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType(options.xr?.referenceSpaceType ?? 'local-floor');

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    const scene = new THREE.Scene();

    const controllers = new Map<XRHandedness, XRController>();
    const hands = new Map<XRHandedness, XRHand>();

    // Initialize controllers
    const handednesses: XRHandedness[] = ['left', 'right'];
    handednesses.forEach((handedness, index) => {
      const controller = renderer.xr.getController(index);
      const grip = renderer.xr.getControllerGrip(index);

      controllers.set(handedness, {
        controller,
        grip,
        ray: new THREE.Group(),
        handedness,
        targetRayMode: 'tracked-pointer',
        visible: true,
        connected: false
      });

      scene.add(controller);
      scene.add(grip);
    });

    // Initialize hands
    handednesses.forEach((handedness, index) => {
      const hand = renderer.xr.getHand(index);
      
      hands.set(handedness, {
        hand,
        joints: new Map(),
        visible: true,
        connected: false
      });

      scene.add(hand);
    });

    const transform: Transform = {
      position: [0, 0, 0],
      rotation: [0, 0, 0],
      scale: [1, 1, 1]
    };

    this.state.value = {
      type: 'xr',
      renderer,
      camera,
      scene,
      canvas: options.canvas,
      isInitialized: true,
      isXRSupported: true,
      isWebGL2: true,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0,
      xrSession: null,
      xrSpace: null,
      xrLayer: null,
      hitTestSource: null,
      controllers,
      hands,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio
      },
      transform,
      config: {
        scene: sceneConfig,
        performance: {
          targetFPS: 90,
          maxDrawCalls: 10000,
          enableStats: false
        },
        xr: {
          referenceSpaceType: options.xr?.referenceSpaceType ?? 'local-floor',
          sessionMode: options.xr?.sessionMode ?? 'immersive-vr',
          optionalFeatures: options.xr?.optionalFeatures ?? ['hand-tracking'],
          requiredFeatures: options.xr?.requiredFeatures ?? ['local-floor']
        }
      }
    };

    renderer.setAnimationLoop(this.render.bind(this));
  }

  /**
   * Initialize browser platform with standard WebGL support
   */
  private async initializeBrowser(options: BrowserInitOptions): Promise<void> {
    if (!OrbitControls) {
      const module = await import('three/examples/jsm/controls/OrbitControls.js');
      OrbitControls = module.OrbitControls;
    }

    const sceneConfig: SceneConfig = {
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
      powerPreference: 'high-performance'
    };

    const renderer = new THREE.WebGLRenderer({
      canvas: options.canvas,
      ...sceneConfig
    });

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    const scene = new THREE.Scene();

    const controls = new OrbitControls(camera, options.canvas);
    Object.assign(controls, options.controls ?? {});
    controls.enableDamping = true;

    const transform: Transform = {
      position: [0, 0, 0],
      rotation: [0, 0, 0],
      scale: [1, 1, 1]
    };

    this.state.value = {
      type: 'browser',
      renderer,
      camera,
      scene,
      canvas: options.canvas,
      controls,
      isInitialized: true,
      isXRSupported: false,
      isWebGL2: true,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0,
      mousePosition: new THREE.Vector2(),
      touchActive: false,
      pointerLocked: false,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio
      },
      transform,
      config: {
        scene: sceneConfig,
        performance: {
          targetFPS: 60,
          maxDrawCalls: 10000,
          enableStats: false
        }
      }
    };

    this.startRenderLoop();
  }

  /**
   * Start XR session with specified mode (VR or AR)
   */
  async startXRSession(mode: 'immersive-vr' | 'immersive-ar'): Promise<XRSession> {
    const state = this.state.value;
    if (!state?.renderer) {
      throw new Error('Renderer not initialized');
    }

    try {
      if (!navigator.xr) {
        throw new Error('WebXR not supported');
      }

      const isSupported = await navigator.xr.isSessionSupported(mode);
      if (!isSupported) {
        throw new Error(`${mode} not supported`);
      }

      // Configure session features based on mode
      const sessionInit: XRSessionInit = {
        optionalFeatures: [],
        requiredFeatures: []
      };

      // Base features for both modes
      sessionInit.optionalFeatures = [
        'local-floor',
        'bounded-floor',
        'hand-tracking',
        'layers'
      ];

      // Add AR-specific features
      if (mode === 'immersive-ar') {
        sessionInit.optionalFeatures.push(
          'dom-overlay',
          'hit-test',
          'anchors',
          'plane-detection',
          'light-estimation'
        );
        sessionInit.requiredFeatures = ['hit-test'];
        sessionInit.domOverlay = { root: document.body };
      } else {
        // VR-specific features
        sessionInit.requiredFeatures = ['local-floor'];
      }

      const session = await navigator.xr.requestSession(mode, sessionInit);
      if (!session) {
        throw new Error('Failed to create XR session');
      }

      // Set up XR layer
      const gl = state.renderer.getContext();
      const xrLayer = new XRWebGLLayer(session, gl);
      await session.updateRenderState({ baseLayer: xrLayer });

      // Set reference space based on mode
      const referenceSpaceType = mode === 'immersive-ar' ? 'unbounded' : 'local-floor';
      const referenceSpace = await session.requestReferenceSpace(referenceSpaceType);

      // Set up hit testing for AR
      if (mode === 'immersive-ar' && 'requestHitTestSource' in session) {
        try {
          const hitTestSourcePromise = session.requestHitTestSource?.({
            space: referenceSpace
          });

          if (hitTestSourcePromise) {
            const hitTestSource = await hitTestSourcePromise;
            if (this.state.value && 'xrSession' in this.state.value) {
              this.state.value.hitTestSource = hitTestSource;
            }
          }
        } catch (error) {
          console.warn('Hit testing not available:', error);
        }
      }

      if (this.state.value && 'xrSession' in this.state.value) {
        this.state.value.xrSession = session;
        this.state.value.xrSpace = referenceSpace;
        this.state.value.xrLayer = xrLayer;
      }

      this.xrSessionMode = mode;

      // Set up session end handler
      session.addEventListener('end', () => {
        this.xrSessionMode = null;
        if (this.state.value && 'xrSession' in this.state.value) {
          this.state.value.xrSession = null;
          this.state.value.xrSpace = null;
          this.state.value.xrLayer = null;
          this.state.value.hitTestSource = null;
        }
      });

      // Update renderer and camera for AR
      if (mode === 'immersive-ar') {
        state.renderer.xr.setReferenceSpaceType('unbounded');
        const camera = state.camera;
        if (camera && 'aspect' in camera) {
          camera.near = 0.01;
          camera.far = 1000;
          camera.updateProjectionMatrix();
        }
      }

      return session;

    } catch (error) {
      console.error(`Error starting ${mode} session:`, error);
      throw error;
    }
  }

  /**
   * End current XR session
   */
  async endXRSession(): Promise<void> {
    const state = this.state.value;
    if (state && 'xrSession' in state && state.xrSession) {
      await state.xrSession.end();
    }
  }

  /**
   * Get current platform state
   */
  getState(): PlatformState | null {
    return this.state.value;
  }

  /**
   * Get platform capabilities
   */
  getCapabilities(): PlatformCapabilities | null {
    return this.capabilities.value;
  }

  /**
   * Get current platform type
   */
  getPlatform(): 'browser' | 'quest' {
    return this.platform;
  }

  /**
   * Check if current platform is Quest
   */
  isQuest(): boolean {
    return this.platform === 'quest';
  }

  /**
   * Check if current platform is browser
   */
  isBrowser(): boolean {
    return this.platform === 'browser';
  }

  /**
   * Check if XR is supported
   */
  hasXRSupport(): boolean {
    return !!this.capabilities.value?.xr;
  }

  /**
   * Check if XR session is active
   */
  isInXRSession(): boolean {
    return this.xrSessionMode !== null;
  }

  /**
   * Get current XR session mode
   */
  getXRSessionMode(): 'immersive-vr' | 'immersive-ar' | null {
    return this.xrSessionMode;
  }

  /**
   * Add resize callback
   */
  onResize(callback: ResizeCallback): () => void {
    this.resizeCallbacks.add(callback);
    return () => this.resizeCallbacks.delete(callback);
  }

  /**
   * Add render callback
   */
  onBeforeRender(callback: RenderCallback): () => void {
    this.renderCallbacks.add(callback);
    return () => this.renderCallbacks.delete(callback);
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.state.value) {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }

      this.resizeCallbacks.clear();
      this.renderCallbacks.clear();

      if (this.isQuest()) {
        const questState = this.state.value as QuestState;
        if (questState.xrSession) {
          questState.xrSession.end().catch(console.error);
        }
      }

      if (this.state.value.renderer) {
        this.state.value.renderer.dispose();
        this.state.value.renderer.forceContextLoss();
      }

      this.state.value = null;
    }
  }

  /**
   * Detect platform and capabilities
   */
  private async detectPlatform() {
    const isQuest = /Oculus|Quest|VR/i.test(navigator.userAgent);
    const xrSupported = 'xr' in navigator;
    const webgl2 = this.checkWebGL2Support();

    // Check AR and VR support
    let arSupported = false;
    let vrSupported = false;
    
    if (xrSupported && navigator.xr) {
      try {
        arSupported = await navigator.xr.isSessionSupported('immersive-ar');
        vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      } catch (error) {
        console.warn('Error checking XR support:', error);
      }
    }

    this.capabilities.value = {
      webgl2,
      xr: xrSupported,
      ar: arSupported,
      vr: vrSupported,
      maxTextureSize: 4096,
      maxDrawCalls: 10000,
      gpuTier: 1
    };

    this.platform = isQuest ? 'quest' : 'browser';
  }

  /**
   * Check WebGL2 support
   */
  private checkWebGL2Support(): boolean {
    try {
      const canvas = document.createElement('canvas');
      return !!canvas.getContext('webgl2');
    } catch {
      return false;
    }
  }

  /**
   * Set up resize handler
   */
  private setupResizeHandler() {
    const handleResize = () => {
      const state = this.state.value;
      if (!state?.canvas || !state.renderer) return;

      const width = window.innerWidth;
      const height = window.innerHeight;
      const pixelRatio = window.devicePixelRatio;

      state.renderer.setSize(width, height);
      state.renderer.setPixelRatio(pixelRatio);

      if (state.camera && 'aspect' in state.camera) {
        state.camera.aspect = width / height;
        state.camera.updateProjectionMatrix();
      }

      state.viewport = {
        width,
        height,
        pixelRatio
      };

      this.resizeCallbacks.forEach(callback => callback(width, height));
    };

    window.addEventListener('resize', handleResize);
  }

  /**
   * Render loop
   */
  private render() {
    const state = this.state.value;
    if (!state?.renderer || !state.scene || !state.camera) return;

    const now = performance.now();
    const deltaTime = now - this.lastFrameTime;
    this.lastFrameTime = now;

    // Update FPS
    state.fps = 1000 / deltaTime;
    state.lastFrameTime = now;

    if (this.platform === 'browser') {
      const browserState = state as BrowserState;
      if (browserState.controls) {
        browserState.controls.update();
      }
    }

    // Execute render callbacks
    this.renderCallbacks.forEach(callback => {
      if (state.renderer && state.scene && state.camera) {
        callback(state.renderer, state.scene, state.camera);
      }
    });

    // Final render
    state.renderer.render(state.scene, state.camera);
  }

  /**
   * Start render loop
   */
  private startRenderLoop() {
    const animate = () => {
      this.render();
      this.animationFrameId = requestAnimationFrame(animate);
    };
    animate();
  }
}

export const platformManager = PlatformManager.getInstance();

----
platform/spacemouse.ts
// SpaceMouse HID interface types
interface SpaceMouseEvent {
    x: number;
    y: number;
    z: number;
}

interface HIDDevice {
    open(): Promise<void>;
    productName: string;
    addEventListener(event: string, handler: (event: any) => void): void;
}

const SPACEMOUSE_VENDOR_ID = 0x256F; // 3Dconnexion vendor ID
const SPACEMOUSE_PRODUCT_ID = 0xC635; // SpaceMouse Compact product ID

let spacemouseDevice: HIDDevice | null = null;

async function requestHIDAccess(): Promise<void> {
    try {
        // @ts-ignore - HID API types not available
        const devices = await navigator.hid.requestDevice({
            filters: [{ vendorId: SPACEMOUSE_VENDOR_ID, productId: SPACEMOUSE_PRODUCT_ID }]
        });
        
        if (devices.length > 0) {
            const device = devices[0];
            if (!device) {
                throw new Error('No device found');
            }
            
            await device.open();
            console.log('HID device opened:', device.productName);
            device.addEventListener('inputreport', handleHIDInput);
            spacemouseDevice = device;
        }
    } catch (error) {
        console.error('HID access denied:', error);
    }
}

function handleHIDInput(event: { data: DataView }): void {
    const { data } = event;
    
    // Parse the input data
    const x = data.getInt16(1, true);
    const y = data.getInt16(3, true);
    const z = data.getInt16(5, true);

    // Normalize values (adjust as needed based on your Spacemouse model)
    const normalizedX = x / 350;
    const normalizedY = y / 350;
    const normalizedZ = z / 350;

    // Create a typed event
    const detail: SpaceMouseEvent = {
        x: normalizedX,
        y: normalizedY,
        z: normalizedZ
    };

    // Dispatch the event
    window.dispatchEvent(new CustomEvent('spacemouse-move', { detail }));
}

// Function to check if WebHID is supported
function isHIDSupported(): boolean {
    // @ts-ignore - HID API types not available
    return 'hid' in navigator;
}

// Function to check if device is connected
function isConnected(): boolean {
    return spacemouseDevice !== null;
}

// Function to be called when the "Enable Spacemouse" button is clicked
function enableSpacemouse(): void {
    if (isHIDSupported()) {
        requestHIDAccess();
    } else {
        console.error('WebHID is not supported in this browser');
        alert('WebHID is not supported in this browser. Please use a compatible browser like Chrome or Edge.');
    }
}

export { 
    enableSpacemouse,
    isHIDSupported,
    isConnected,
    type SpaceMouseEvent 
};

----
constants/visualization.ts
import * as THREE from 'three';

// Position validation constants
export const VALIDATION = {
  MAX_POSITION: 1000,
  MIN_POSITION: -1000,
  MAX_VELOCITY: 50,
  MIN_VELOCITY: -50,
  POSITION_CHANGE_THRESHOLD: 0.01,
  EXPECTED_BINARY_SIZE: 24,
  UPDATE_INTERVAL: 200, // Increased to 200ms (5 FPS)
  BATCH_SIZE: 100
};

export const VISUALIZATION_CONSTANTS = {
  TRANSLATION_SPEED: 0.01,
  ROTATION_SPEED: 0.01,
  VR_MOVEMENT_SPEED: 0.05,
  MIN_CAMERA_DISTANCE: 50,
  MAX_CAMERA_DISTANCE: 500,
  DEFAULT_FOV: 50,
  NEAR_PLANE: 0.1,
  FAR_PLANE: 2000,
  DEFAULT_CAMERA_POSITION: [0, 75, 200] as [number, number, number],
  DEFAULT_CAMERA_TARGET: [0, 0, 0] as [number, number, number],
  TARGET_FRAMERATE: 5, // Reduced to 5 FPS
  MIN_FRAME_TIME: 200, // Increased to 200ms for 5 FPS
  POSITION_UPDATE_INTERVAL: 200, // Increased to 200ms (5 FPS)
  FORCE_DIRECTED_CLIENT: false // Force-directed graph permanently disabled
};

export const SCENE_SETTINGS = {
  fogNear: 1,
  fogFar: 5,
  gridSize: 2,
  gridDivisions: 20
};

export const CAMERA_SETTINGS = {
  fov: 60,
  near: 0.01,
  far: 10000,
  position: new THREE.Vector3(0, 0.5, 2),
  target: new THREE.Vector3(0, 0, 0)
};

export const WEBGL_CONTEXT_ATTRIBUTES: WebGLContextAttributes = {
  alpha: false,
  antialias: true,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  preserveDrawingBuffer: true,
  xrCompatible: true
};

export const RENDERER_SETTINGS = {
  clearColor: 0x000000,
  clearAlpha: 1,
  pixelRatio: Math.min(window.devicePixelRatio, 2),
  toneMapping: THREE.ACESFilmicToneMapping,
  toneMappingExposure: 1.5,
  outputColorSpace: THREE.SRGBColorSpace
};

export const LIGHT_SETTINGS = {
  ambient: {
    color: 0xffffff,
    intensity: 1.5
  },
  directional: {
    color: 0xffffff,
    intensity: 2.0,
    position: [10, 20, 10] as [number, number, number]
  },
  hemisphere: {
    skyColor: 0xffffff,
    groundColor: 0x444444,
    intensity: 1.5
  },
  points: [
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [100, 100, 100] as [number, number, number]
    },
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [-100, -100, -100] as [number, number, number]
    }
  ]
};

export const CONTROLS_SETTINGS = {
  enableDamping: true,
  dampingFactor: 0.1,
  rotateSpeed: 0.4,
  panSpeed: 0.6,
  zoomSpeed: 1.2,
  minDistance: 50,
  maxDistance: 500
};

----
constants/websocket.ts
// Binary protocol scale factors for network transmission
export const POSITION_SCALE = 10000; // Increased from 1000 to handle larger boundaries (up to 600 units)
export const VELOCITY_SCALE = 20000; // Increased from 10000 to handle higher velocities (up to 20 units)

// WebSocket configuration defaults
export const DEFAULT_RECONNECT_ATTEMPTS = 3;
export const DEFAULT_RECONNECT_DELAY = 5000;
export const DEFAULT_MESSAGE_RATE_LIMIT = 5; // Reduced to 5 messages per second
export const DEFAULT_MESSAGE_TIME_WINDOW = 1000;
export const DEFAULT_MAX_MESSAGE_SIZE = 5 * 1024 * 1024; // 5MB
export const DEFAULT_MAX_AUDIO_SIZE = 10 * 1024 * 1024; // 10MB
export const DEFAULT_MAX_QUEUE_SIZE = 1000;

// Connection timeouts (matching server)
export const CONNECTION_TIMEOUT = 10000;      // 10 seconds to establish connection
export const HEARTBEAT_INTERVAL = 15000;      // 15 seconds between pings (matching server)
export const HEARTBEAT_TIMEOUT = 60000;       // 60 seconds to receive pong (matching server)

// Binary protocol constants
export const BINARY_UPDATE_NODE_SIZE = 24;    // 6 float32s per node (position + velocity)
export const FLOAT32_SIZE = 4;                // Size of Float32 in bytes
export const BINARY_HEADER_SIZE = 4;          // Size of binary message header in bytes
export const MAX_BINARY_MESSAGE_SIZE = 100 * 1024 * 1024; // 100MB maximum binary message size

// Validation constants
export const MAX_VALID_POSITION = 1000;       // Maximum valid position value
export const MAX_VALID_VELOCITY = 50;         // Maximum valid velocity value
export const MIN_VALID_POSITION = -1000;      // Minimum valid position value
export const MIN_VALID_VELOCITY = -50;        // Minimum valid velocity value
export const MAX_NODE_COUNT = 1000000;        // Maximum number of nodes to prevent memory issues
export const MAX_EDGE_COUNT = 5000000;        // Maximum number of edges to prevent memory issues

// Performance thresholds
export const MAX_PERFORMANCE_SAMPLES = 100;    // Number of samples to keep for performance metrics
export const PERFORMANCE_RESET_INTERVAL = 60000; // Reset performance metrics every minute
export const MAX_MESSAGE_PROCESSING_TIME = 100;  // Maximum acceptable message processing time (ms)
export const MAX_POSITION_UPDATE_TIME = 200;     // Increased to 200ms (5 FPS)
export const MEMORY_WARNING_THRESHOLD = 100 * 1024 * 1024; // 100MB memory usage warning threshold
export const MAX_UPDATES_PER_SECOND = 5;      // Reduced to 5 updates per second
export const UPDATE_THROTTLE_MS = 200;        // Set to 200ms for 5 FPS
export const POSITION_CHANGE_THRESHOLD = 0.01; // Minimum position change to trigger update
export const VELOCITY_CHANGE_THRESHOLD = 0.001; // Minimum velocity change to trigger update
export const THRESHOLD_ADJUSTMENT_FACTOR = 1.5; // Factor to adjust thresholds under high load

// Debug flags
export const ENABLE_BINARY_DEBUG = true;         // Enable detailed binary update logging
export const ENABLE_POSITION_VALIDATION = true;  // Enable position/velocity validation
export const ENABLE_PERFORMANCE_LOGGING = true;  // Enable performance metric logging
export const ENABLE_MEMORY_MONITORING = true;    // Enable memory usage monitoring
export const ENABLE_THRESHOLD_ADJUSTMENT = true; // Enable dynamic threshold adjustment

// Server message types (matching server's ServerMessage enum)
export const SERVER_MESSAGE_TYPES = {
    // Direct server message types from ServerMessage enum
    GRAPH_UPDATE: 'graphUpdate',
    ERROR: 'error',
    POSITION_UPDATE_COMPLETE: 'positionUpdateComplete',
    SETTINGS_UPDATED: 'settingsUpdated',
    SIMULATION_MODE_SET: 'simulationModeSet',
    FISHEYE_SETTINGS_UPDATED: 'fisheyeSettingsUpdated',
    BINARY_POSITION_UPDATE: 'binaryPositionUpdate',
    
    // Additional client-side message types
    INITIAL_DATA: 'initialData',
    GPU_STATE: 'gpuState',
    LAYOUT_STATE: 'layoutState',
    OPENAI_RESPONSE: 'openaiResponse',
    RAGFLOW_RESPONSE: 'ragflowResponse',
    COMPLETION: 'completion',
    UPDATE_SETTINGS: 'updateSettings'
} as const;

// Error codes (matching server error structure)
export const ERROR_CODES = {
    // Connection errors
    CONNECTION_FAILED: 'CONNECTION_FAILED',
    MAX_RETRIES_EXCEEDED: 'MAX_RETRIES_EXCEEDED',
    HEARTBEAT_TIMEOUT: 'HEARTBEAT_TIMEOUT',
    
    // Message errors
    MESSAGE_TOO_LARGE: 'MESSAGE_TOO_LARGE',
    INVALID_MESSAGE: 'INVALID_MESSAGE',
    BINARY_MESSAGE_TOO_LARGE: 'BINARY_MESSAGE_TOO_LARGE',
    INVALID_BINARY_FORMAT: 'INVALID_BINARY_FORMAT',
    BUFFER_ALIGNMENT_ERROR: 'BUFFER_ALIGNMENT_ERROR',
    
    // Data validation errors
    INVALID_POSITION: 'INVALID_POSITION',
    INVALID_VELOCITY: 'INVALID_VELOCITY',
    NODE_COUNT_MISMATCH: 'NODE_COUNT_MISMATCH',
    INVALID_NODE_COUNT: 'INVALID_NODE_COUNT',
    
    // Performance errors
    PROCESSING_TIME_EXCEEDED: 'PROCESSING_TIME_EXCEEDED',
    MEMORY_LIMIT_EXCEEDED: 'MEMORY_LIMIT_EXCEEDED',
    UPDATE_RATE_EXCEEDED: 'UPDATE_RATE_EXCEEDED',
    
    // Graph errors
    INVALID_NODE: 'INVALID_NODE',
    INVALID_EDGE: 'INVALID_EDGE',
    
    // State errors
    INVALID_STATE: 'INVALID_STATE',
    SIMULATION_ERROR: 'SIMULATION_ERROR'
} as const;

// Message field names (matching server struct fields)
export const MESSAGE_FIELDS = {
    // GraphUpdate fields
    GRAPH_DATA: 'graphData',
    
    // Error fields
    MESSAGE: 'message',
    CODE: 'code',
    DETAILS: 'details',
    
    // PositionUpdateComplete fields
    STATUS: 'status',
    
    // SimulationModeSet fields
    MODE: 'mode',
    GPU_ENABLED: 'gpuEnabled',
    
    // FisheyeSettingsUpdated fields
    ENABLED: 'enabled',
    STRENGTH: 'strength',
    FOCUS_POINT: 'focusPoint',
    RADIUS: 'radius',

    // Settings fields
    SETTINGS: 'settings',
    MATERIAL: 'material',
    BLOOM: 'bloom',
    FISHEYE: 'fisheye',
    
    // Performance fields
    PROCESSING_TIME: 'processingTime',
    MEMORY_USAGE: 'memoryUsage',
    UPDATE_FREQUENCY: 'updateFrequency'
} as const;

// Performance metric names
export const PERFORMANCE_METRICS = {
    PROCESSING_TIME: 'processingTime',
    AVERAGE_PROCESSING_TIME: 'averageProcessingTime',
    MEMORY_USAGE: 'memoryUsage',
    UPDATE_FREQUENCY: 'updateFrequency',
    INVALID_UPDATE_RATE: 'invalidUpdateRate',
    CHANGED_NODES: 'changedNodes'
} as const;

----
docs/flow.md
sequenceDiagram
    participant User
    participant App
    participant WebSocket
    participant Store
    participant Visualization
    participant GPU
    participant ThreeJS
    
    Note over App,ThreeJS: Initialization Phase
    User->>App: Load Application
    App->>Store: Create Pinia Stores
    App->>WebSocket: Initialize Connection
    App->>Visualization: Initialize Scene
    
    Note over WebSocket,Store:  Potential Bottleneck #1
    WebSocket->>Store: Request Initial Data
    Store->>WebSocket: Send Binary Position Data
    
    rect rgb(255, 240, 240)
        Note over Visualization,GPU:  High CPU Risk Area
        loop Force Simulation
            Visualization->>GPU: Update Positions
            GPU->>Store: Binary Position Update
            Store->>WebSocket: Send Position Data
            Note right of Store: Rate Limited to 60fps
        end
    end
    
    rect rgb(240, 240, 255)
        Note over ThreeJS,User: Render Loop
        loop Animation Frame
            Visualization->>ThreeJS: Update Scene
            ThreeJS->>User: Render Frame
            Note right of ThreeJS:  Potential Frame Drop
        end
    end
    
    Note over WebSocket,Store: Data Flow
    WebSocket-->>Store: Binary Position Updates
    Store-->>Visualization: Update Node Positions
    
    rect rgb(255, 240, 240)
        Note over Store,Visualization:  Feedback Loop Risk
        loop Position Updates
            Store->>Visualization: Update Positions
            Visualization->>GPU: Process Forces
            GPU->>Store: New Positions
            Note right of GPU: Can cause lockup if<br/>positions invalid
        end
    end
    
    rect rgb(240, 255, 240)
        Note over User,Visualization: User Interaction
        User->>Visualization: Drag Node
        Visualization->>Store: Update Position
        Store->>WebSocket: Send Update
        Note right of Store:  Can flood websocket
    end
    
    Note over App,ThreeJS: Critical Points
    Note over WebSocket: 1. WebSocket message flood
    Note over Store: 2. Store update cascade
    Note over GPU: 3. GPU force calculation
    Note over ThreeJS: 4. Three.js render loop
    
    rect rgb(240, 240, 255)
        Note over Store,WebSocket: Safeguards
        Store-->>Store: Rate Limiting
        WebSocket-->>WebSocket: Message Throttling
        GPU-->>GPU: Position Validation
        ThreeJS-->>ThreeJS: Frame Throttling
    end
```

# Client Code Flow and Bottleneck Analysis

## Critical Points

1. **WebSocket Message Flood**
   - Risk: Client sending too many position updates
   - Mitigation: Rate limiting to 60fps
   - Location: websocketService.ts

2. **Store Update Cascade**
   - Risk: Store updates triggering excessive recalculations
   - Mitigation: Batch updates, debouncing
   - Location: visualization store

3. **GPU Force Calculation**
   - Risk: Invalid positions causing infinite force values
   - Mitigation: Position/velocity clamping
   - Location: compute_forces.cu

4. **Three.js Render Loop**
   - Risk: Frame drops from excessive updates
   - Mitigation: Frame throttling
   - Location: useVisualization.ts

## Feedback Loops

1. **Position Update Loop**
   ```
   Store -> Visualization -> GPU -> Store
   ```
   - Risk: Can cause lockup if positions become invalid
   - Mitigation: Position validation and clamping

2. **User Interaction Loop**
   ```
   User -> Visualization -> Store -> WebSocket
   ```
   - Risk: Can flood websocket with updates
   - Mitigation: Rate limiting and update throttling

## Safeguards

1. **Rate Limiting**
   - WebSocket updates limited to 60fps
   - Store updates batched and debounced
   - Frame rendering throttled

2. **Validation**
   - Position values clamped
   - Velocity values clamped
   - Binary message size validated

3. **Error Handling**
   - Error-only logging enforced
   - Invalid updates discarded
   - Connection retry backoff

----
composables/useForceGraph.ts
import { ref, onBeforeUnmount, markRaw } from 'vue';
import * as THREE from 'three';
import { useSettingsStore } from '../stores/settings';
import { useBinaryUpdateStore } from '../stores/binaryUpdate';
import type { Scene, InstancedMesh, Material, Camera, PerspectiveCamera, Vector3 } from 'three';
import type { Node, Edge } from '../types/core';

// Performance tuning constants
const FRAME_SKIP_THRESHOLD = 16; // ms
const FRUSTUM_CULL_MARGIN = 2.0; // Units beyond camera frustum to render
const MAX_VISIBLE_NODES = 10000; // Maximum nodes to render at once
const OBJECT_POOL_SIZE = 1000; // Size of reusable object pool
const MIN_NODE_DISTANCE = 0.1; // Minimum distance between nodes for LOD
const MAX_INSTANCES = 100000; // Maximum number of instances
const SPATIAL_GRID_SIZE = 100; // Size of spatial grid for culling

interface NodeInstance {
  id: string;
  index: number;
  x: number;
  y: number;
  z: number;
  visible: boolean;
  lastUpdateFrame: number;
  metadata?: Record<string, any>;
}

interface LinkInstance {
  source: string;
  target: string;
  visible: boolean;
  lastUpdateFrame: number;
  weight?: number;
}

interface NodeColors {
  NEW: THREE.Color;
  RECENT: THREE.Color;
  MEDIUM: THREE.Color;
  OLD: THREE.Color;
  CORE: THREE.Color;
  SECONDARY: THREE.Color;
  DEFAULT: THREE.Color;
}

interface NodeInstancedMeshes {
  high: THREE.InstancedMesh;
  medium: THREE.InstancedMesh;
  low: THREE.InstancedMesh;
}

interface SpatialGridCell {
  nodes: NodeInstance[];
  center: Vector3;
}

interface ForceGraphResources {
  lod: THREE.LOD;
  nodeInstancedMeshes: NodeInstancedMeshes;
  linkInstancedMesh: THREE.InstancedMesh;
  nodeInstances: Map<string, number>;
  linkInstances: Map<string, number>;
  nodeInstanceCount: number;
  linkInstanceCount: number;
  frustum: THREE.Frustum;
  objectPool: {
    vector3: THREE.Vector3[];
    matrix4: THREE.Matrix4[];
    color: THREE.Color[];
    quaternion: THREE.Quaternion[];
  };
  frameCount: number;
  lastUpdateTime: number;
  visibleNodes: Set<number>;
  visibleLinks: Set<string>;
  spatialGrid: Map<string, SpatialGridCell>;
}

// Helper to check if camera is perspective
const isPerspectiveCamera = (camera: Camera): camera is PerspectiveCamera => {
  return (camera as PerspectiveCamera).isPerspectiveCamera;
};

// Create object pool
const createObjectPool = () => ({
  vector3: Array(OBJECT_POOL_SIZE).fill(null).map(() => markRaw(new THREE.Vector3())),
  matrix4: Array(OBJECT_POOL_SIZE).fill(null).map(() => markRaw(new THREE.Matrix4())),
  color: Array(OBJECT_POOL_SIZE).fill(null).map(() => markRaw(new THREE.Color())),
  quaternion: Array(OBJECT_POOL_SIZE).fill(null).map(() => markRaw(new THREE.Quaternion()))
});

// Helper to get grid cell key
const getGridKey = (x: number, y: number, z: number): string => {
  const gridX = Math.floor(x / SPATIAL_GRID_SIZE);
  const gridY = Math.floor(y / SPATIAL_GRID_SIZE);
  const gridZ = Math.floor(z / SPATIAL_GRID_SIZE);
  return `${gridX},${gridY},${gridZ}`;
};

export function useForceGraph(scene: Scene) {
  const settingsStore = useSettingsStore();
  const binaryUpdateStore = useBinaryUpdateStore();
  const resources = ref<ForceGraphResources | null>(null);
  
  // Temporary objects for matrix calculations
  const tempMatrix = markRaw(new THREE.Matrix4());
  const tempColor = markRaw(new THREE.Color());
  const tempVector = markRaw(new THREE.Vector3());
  const tempQuaternion = markRaw(new THREE.Quaternion());
  const tempScale = markRaw(new THREE.Vector3());

  // Data
  const nodes = ref<NodeInstance[]>([]);
  const links = ref<LinkInstance[]>([]);

  // Initialize node colors from settings
  const nodeColors: NodeColors = {
    NEW: markRaw(new THREE.Color(settingsStore.getVisualizationSettings.node_color_new)),
    RECENT: markRaw(new THREE.Color(settingsStore.getVisualizationSettings.node_color_recent)),
    MEDIUM: markRaw(new THREE.Color(settingsStore.getVisualizationSettings.node_color_medium)),
    OLD: markRaw(new THREE.Color(settingsStore.getVisualizationSettings.node_color_old)),
    CORE: markRaw(new THREE.Color(settingsStore.getVisualizationSettings.node_color_core)),
    SECONDARY: markRaw(new THREE.Color(settingsStore.getVisualizationSettings.node_color_secondary)),
    DEFAULT: markRaw(new THREE.Color(settingsStore.getVisualizationSettings.node_color))
  };

  const initInstancedMeshes = () => {
    // Create optimized geometries
    const highDetailGeometry = markRaw(new THREE.SphereGeometry(1, 32, 32).toNonIndexed());
    const mediumDetailGeometry = markRaw(new THREE.SphereGeometry(1, 16, 16).toNonIndexed());
    const lowDetailGeometry = markRaw(new THREE.SphereGeometry(1, 8, 8).toNonIndexed());

    const settings = settingsStore.getVisualizationSettings;

    // Create optimized material
    const nodeMaterial = markRaw(new THREE.MeshPhysicalMaterial({
      metalness: settings.material.node_material_metalness,
      roughness: settings.material.node_material_roughness,
      transparent: true,
      opacity: settings.material.node_material_opacity,
      envMapIntensity: 1.0,
      clearcoat: settings.material.node_material_clearcoat,
      clearcoatRoughness: settings.material.node_material_clearcoat_roughness,
      side: THREE.FrontSide,
      flatShading: true,
      vertexColors: true
    }));

    // Create instanced meshes with optimizations
    const nodeInstancedMeshes: NodeInstancedMeshes = {
      high: markRaw(new THREE.InstancedMesh(highDetailGeometry, nodeMaterial.clone(), MAX_INSTANCES)),
      medium: markRaw(new THREE.InstancedMesh(mediumDetailGeometry, nodeMaterial.clone(), MAX_INSTANCES)),
      low: markRaw(new THREE.InstancedMesh(lowDetailGeometry, nodeMaterial.clone(), MAX_INSTANCES))
    };

    // Configure meshes for performance
    Object.values(nodeInstancedMeshes).forEach(mesh => {
      mesh.frustumCulled = true;
      mesh.matrixAutoUpdate = false;
      mesh.castShadow = false;
      mesh.receiveShadow = false;
    });

    // Create LOD with optimized distances
    const lod = markRaw(new THREE.LOD());
    lod.addLevel(nodeInstancedMeshes.high, 0);
    lod.addLevel(nodeInstancedMeshes.medium, 50);
    lod.addLevel(nodeInstancedMeshes.low, 150);
    scene.add(lod);

    // Create optimized link geometry
    const linkGeometry = markRaw(new THREE.CylinderGeometry(0.01, 0.01, 1, 6, 1).toNonIndexed());
    linkGeometry.rotateX(Math.PI / 2);

    // Create optimized link material
    const linkMaterial = markRaw(new THREE.MeshBasicMaterial({
      color: settings.edge_color,
      transparent: true,
      opacity: settings.edge_opacity,
      depthWrite: false,
      side: THREE.FrontSide,
      vertexColors: true
    }));

    // Create optimized link mesh
    const linkInstancedMesh = markRaw(new THREE.InstancedMesh(
      linkGeometry,
      linkMaterial,
      MAX_INSTANCES
    ));
    linkInstancedMesh.frustumCulled = true;
    linkInstancedMesh.matrixAutoUpdate = false;
    linkInstancedMesh.castShadow = false;
    linkInstancedMesh.receiveShadow = false;
    scene.add(linkInstancedMesh);

    resources.value = {
      lod,
      nodeInstancedMeshes,
      linkInstancedMesh,
      nodeInstances: new Map(),
      linkInstances: new Map(),
      nodeInstanceCount: 0,
      linkInstanceCount: 0,
      frustum: markRaw(new THREE.Frustum()),
      objectPool: createObjectPool(),
      frameCount: 0,
      lastUpdateTime: 0,
      visibleNodes: new Set(),
      visibleLinks: new Set(),
      spatialGrid: new Map()
    };
  };

  const updateSpatialGrid = () => {
    const res = resources.value;
    if (!res) return;

    // Clear previous grid
    res.spatialGrid.clear();

    // Add nodes to grid
    nodes.value.forEach((node) => {
      const key = getGridKey(node.x, node.y, node.z);
      let cell = res.spatialGrid.get(key);
      
      if (!cell) {
        const centerX = Math.floor(node.x / SPATIAL_GRID_SIZE) * SPATIAL_GRID_SIZE + SPATIAL_GRID_SIZE / 2;
        const centerY = Math.floor(node.y / SPATIAL_GRID_SIZE) * SPATIAL_GRID_SIZE + SPATIAL_GRID_SIZE / 2;
        const centerZ = Math.floor(node.z / SPATIAL_GRID_SIZE) * SPATIAL_GRID_SIZE + SPATIAL_GRID_SIZE / 2;
        
        cell = {
          nodes: [],
          center: markRaw(new THREE.Vector3(centerX, centerY, centerZ))
        };
        res.spatialGrid.set(key, cell);
      }
      
      cell.nodes.push(node);
    });
  };

  const isNodeVisible = (node: NodeInstance, camera: Camera): boolean => {
    const res = resources.value;
    if (!res) return false;

    // Get vector from pool
    const poolIndex = node.index % OBJECT_POOL_SIZE;
    const nodePos = res.objectPool.vector3[poolIndex].set(node.x, node.y, node.z);

    // Check if node is within frustum plus margin
    const distance = camera.position.distanceTo(nodePos);
    if (isPerspectiveCamera(camera) && distance > camera.far * FRUSTUM_CULL_MARGIN) {
      return false;
    }

    // Check spatial grid for nearby nodes
    const key = getGridKey(node.x, node.y, node.z);
    const cell = res.spatialGrid.get(key);
    if (cell && cell.nodes.length > 1) {
      // If there are other nodes in the same cell, only show the closest one to camera
      const closestNode = cell.nodes.reduce((closest: NodeInstance, current: NodeInstance) => {
        const currentDist = camera.position.distanceTo(new THREE.Vector3(current.x, current.y, current.z));
        const closestDist = camera.position.distanceTo(new THREE.Vector3(closest.x, closest.y, closest.z));
        return currentDist < closestDist ? current : closest;
      });
      if (closestNode !== node) return false;
    }

    return res.frustum.containsPoint(nodePos);
  };

  const getNodeSize = (node: NodeInstance): number => {
    const settings = settingsStore.getVisualizationSettings;
    const baseSize = (node.metadata?.size || 1) * settings.min_node_size;
    const weight = node.metadata?.weight || 1;
    return Math.min(baseSize * Math.sqrt(weight), settings.max_node_size);
  };

  const getNodeColor = (node: NodeInstance): THREE.Color => {
    const type = node.metadata?.type || 'DEFAULT';
    return nodeColors[type as keyof NodeColors] || nodeColors.DEFAULT;
  };

  const calculateEmissiveIntensity = (node: NodeInstance): number => {
    const settings = settingsStore.getVisualizationSettings;
    const lastModified = node.metadata?.github_last_modified || 
                        node.metadata?.last_modified || 
                        new Date().toISOString();
    const now = Date.now();
    const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
    
    const normalizedAge = Math.min(ageInDays / 30, 1);
    return settings.material.node_emissive_max_intensity - 
           (normalizedAge * (settings.material.node_emissive_max_intensity - 
                           settings.material.node_emissive_min_intensity));
  };

  const updateNodes = (camera: Camera) => {
    const res = resources.value;
    if (!res) return;

    const now = performance.now();
    const timeSinceLastUpdate = now - res.lastUpdateTime;

    // Skip frame if too soon
    if (timeSinceLastUpdate < FRAME_SKIP_THRESHOLD) return;

    // Update frustum for culling
    res.frustum.setFromProjectionMatrix(
      tempMatrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
      )
    );

    // Get changed nodes from binary update store
    const changedNodes = binaryUpdateStore.getChangedNodes;
    
    // Update spatial grid if nodes have changed
    if (changedNodes.size > 0) {
      updateSpatialGrid();
    }

    // Clear previous visible nodes
    res.visibleNodes.clear();

    // Reset visible instance count
    let visibleCount = 0;

    // Update only changed nodes that are visible
    nodes.value.forEach((node: NodeInstance, index: number) => {
      // Skip if node hasn't changed and was recently updated
      if (!changedNodes.has(index) && 
          node.lastUpdateFrame === res.frameCount - 1) return;

      // Update visibility
      node.visible = isNodeVisible(node, camera);
      if (!node.visible) return;

      // Skip if we've hit max visible nodes
      if (visibleCount >= MAX_VISIBLE_NODES) return;

      // Get objects from pool
      const poolIndex = visibleCount % OBJECT_POOL_SIZE;
      const matrix = res.objectPool.matrix4[poolIndex];
      const position = res.objectPool.vector3[poolIndex];
      const quaternion = res.objectPool.quaternion[poolIndex];

      const size = getNodeSize(node);
      const color = getNodeColor(node);
      const emissiveIntensity = calculateEmissiveIntensity(node);

      // Update transform
      position.set(node.x, node.y, node.z);
      matrix.compose(
        position,
        quaternion,
        tempScale.set(size, size, size)
      );

      // Update instances for each LOD level
      Object.values(res.nodeInstancedMeshes).forEach(instancedMesh => {
        instancedMesh.setMatrixAt(visibleCount, matrix);
        instancedMesh.setColorAt(visibleCount, color);
        (instancedMesh.material as THREE.MeshPhysicalMaterial).emissiveIntensity = emissiveIntensity;
      });

      // Update tracking
      res.nodeInstances.set(node.id, visibleCount);
      res.visibleNodes.add(index);
      node.lastUpdateFrame = res.frameCount;
      visibleCount++;
    });

    // Update instance meshes
    Object.values(res.nodeInstancedMeshes).forEach(instancedMesh => {
      instancedMesh.count = visibleCount;
      instancedMesh.instanceMatrix.needsUpdate = true;
      if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
    });

    res.nodeInstanceCount = visibleCount;
    res.lastUpdateTime = now;
    res.frameCount++;
  };

  const updateLinks = (camera: Camera) => {
    const res = resources.value;
    if (!res) return;

    // Skip if no nodes have changed
    const changedNodes = binaryUpdateStore.getChangedNodes;
    if (changedNodes.size === 0) return;

    // Clear previous visible links
    res.visibleLinks.clear();

    let visibleCount = 0;

    // Update only links connected to changed nodes that are visible
    links.value.forEach((link: LinkInstance, index: number) => {
      const sourceIndex = res.nodeInstances.get(link.source);
      const targetIndex = res.nodeInstances.get(link.target);

      if (sourceIndex === undefined || targetIndex === undefined) return;

      // Skip if neither node has changed and link was recently updated
      if (!changedNodes.has(sourceIndex) && 
          !changedNodes.has(targetIndex) &&
          link.lastUpdateFrame === res.frameCount - 1) return;

      // Skip if either node is not visible
      if (!res.visibleNodes.has(sourceIndex) || !res.visibleNodes.has(targetIndex)) return;

      // Skip if we've hit max visible links
      if (visibleCount >= MAX_VISIBLE_NODES) return;

      // Get objects from pool
      const poolIndex = visibleCount % OBJECT_POOL_SIZE;
      const sourcePos = res.objectPool.vector3[poolIndex];
      const targetPos = res.objectPool.vector3[(poolIndex + 1) % OBJECT_POOL_SIZE];
      const matrix = res.objectPool.matrix4[poolIndex];
      const quaternion = res.objectPool.quaternion[poolIndex];

      const sourceNode = nodes.value[sourceIndex];
      const targetNode = nodes.value[targetIndex];

      sourcePos.set(sourceNode.x, sourceNode.y, sourceNode.z);
      targetPos.set(targetNode.x, targetNode.y, targetNode.z);

      // Calculate link transform
      const distance = sourcePos.distanceTo(targetPos);
      tempVector.subVectors(targetPos, sourcePos);
      quaternion.setFromUnitVectors(
        markRaw(new THREE.Vector3(0, 0, 1)),
        tempVector.normalize()
      );

      matrix.compose(
        sourcePos.lerp(targetPos, 0.5),
        quaternion,
        markRaw(new THREE.Vector3(1, 1, distance))
      );

      // Update link instance
      res.linkInstancedMesh.setMatrixAt(visibleCount, matrix);
      
      const weight = link.weight || 1;
      const normalizedWeight = Math.min(weight / 10, 1);
      const settings = settingsStore.getVisualizationSettings;
      res.objectPool.color[poolIndex]
        .set(settings.edge_color)
        .multiplyScalar(normalizedWeight);
      res.linkInstancedMesh.setColorAt(visibleCount, res.objectPool.color[poolIndex]);

      // Update tracking
      res.linkInstances.set(`${link.source}-${link.target}`, visibleCount);
      res.visibleLinks.add(`${link.source}-${link.target}`);
      link.lastUpdateFrame = res.frameCount;
      visibleCount++;
    });

    // Update link instance mesh
    res.linkInstancedMesh.count = visibleCount;
    res.linkInstancedMesh.instanceMatrix.needsUpdate = true;
    if (res.linkInstancedMesh.instanceColor) {
      res.linkInstancedMesh.instanceColor.needsUpdate = true;
    }

    res.linkInstanceCount = visibleCount;
  };

  const updateGraph = (graphNodes: Node[], graphEdges: Edge[]) => {
    // Convert graph data to internal format
    nodes.value = graphNodes.map((node, index) => ({
      id: node.id,
      index,
      x: node.position?.[0] || 0,
      y: node.position?.[1] || 0,
      z: node.position?.[2] || 0,
      visible: true,
      lastUpdateFrame: -1,
      metadata: node.metadata
    }));

    links.value = graphEdges.map(edge => ({
      source: edge.source,
      target: edge.target,
      visible: true,
      lastUpdateFrame: -1,
      weight: edge.weight
    }));

    // Force full update
    const res = resources.value;
    if (res) {
      res.frameCount++;
      res.lastUpdateTime = 0;
      // Update spatial grid
      updateSpatialGrid();
    }
  };

  const dispose = () => {
    const res = resources.value;
    if (!res) return;

    // Dispose of node resources
    Object.values(res.nodeInstancedMeshes).forEach(instancedMesh => {
      instancedMesh.geometry.dispose();
      if (instancedMesh.material instanceof THREE.Material) {
        instancedMesh.material.dispose();
      } else if (Array.isArray(instancedMesh.material)) {
        instancedMesh.material.forEach((mat: Material) => mat.dispose());
      }
    });

    // Dispose of link resources
    res.linkInstancedMesh.geometry.dispose();
    if (res.linkInstancedMesh.material instanceof THREE.Material) {
      res.linkInstancedMesh.material.dispose();
    } else if (Array.isArray(res.linkInstancedMesh.material)) {
      res.linkInstancedMesh.material.forEach((mat: Material) => mat.dispose());
    }

    // Clear spatial grid
    res.spatialGrid.clear();

    // Remove from scene
    scene.remove(res.lod);
    scene.remove(res.linkInstancedMesh);

    // Clear collections
    res.nodeInstances.clear();
    res.linkInstances.clear();
    res.visibleNodes.clear();
    res.visibleLinks.clear();
    nodes.value = [];
    links.value = [];
    resources.value = null;
  };

  // Initialize on creation
  initInstancedMeshes();

  // Clean up on unmount
  onBeforeUnmount(() => {
    dispose();
  });

  return {
    updateGraph,
    updateNodes,
    updateLinks,
    dispose
  };
}

----
composables/useEffectsSystem.ts
import { ref, computed, watch, onMounted, onBeforeUnmount } from 'vue';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
import { useSettingsStore } from '@stores/settings';
import { usePlatform } from './usePlatform';
import { PASS_OUTPUT } from '../utils/threeUtils';

// Configure color management for modern Three.js
THREE.ColorManagement.enabled = true;

interface ExtendedUnrealBloomPass extends UnrealBloomPass {
  selectedObjects?: THREE.Object3D[];
}

export function useEffectsSystem(
  renderer: THREE.WebGLRenderer,
  scene: THREE.Scene,
  camera: THREE.PerspectiveCamera
) {
  const settingsStore = useSettingsStore();
  const { getPlatformInfo } = usePlatform();

  // Effect composer and passes
  const composer = ref<EffectComposer | null>(null);
  const bloomPass = ref<ExtendedUnrealBloomPass | null>(null);
  const ssaoPass = ref<SSAOPass | null>(null);
  const fxaaPass = ref<ShaderPass | null>(null);

  // Settings
  const bloomSettings = computed(() => settingsStore.getBloomSettings);
  const platformInfo = computed(() => getPlatformInfo());

  // Resolution
  const resolution = computed(() => {
    const pixelRatio = renderer.getPixelRatio();
    const size = new THREE.Vector2();
    renderer.getSize(size);
    return new THREE.Vector2(
      size.width * pixelRatio,
      size.height * pixelRatio
    );
  });

  // Initialize effect composer
  const initializeComposer = () => {
    // Create render target with appropriate color space
    const renderTarget = new THREE.WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight,
      {
        colorSpace: THREE.SRGBColorSpace,
        samples: (renderer as any).capabilities.isWebGL2 ? 4 : 0
      }
    );

    // Create new composer
    composer.value = new EffectComposer(renderer as any, renderTarget as any);

    // Add render pass
    const renderPass = new RenderPass(scene as any, camera as any);
    (composer.value as any).addPass(renderPass);

    // Initialize bloom if enabled
    if (bloomSettings.value.enabled) {
      const bloom = new UnrealBloomPass(
        resolution.value,
        bloomSettings.value.strength,
        bloomSettings.value.radius,
        bloomSettings.value.threshold
      ) as ExtendedUnrealBloomPass;
      bloomPass.value = bloom;
      (composer.value as any).addPass(bloom);
    }

    // Initialize SSAO for browser platform
    if (platformInfo.value.isBrowser) {
      const ssao = new SSAOPass(scene as any, camera as any);
      ssao.output = PASS_OUTPUT.Default;
      ssaoPass.value = ssao;
      (composer.value as any).addPass(ssao);
    }

    // Initialize FXAA
    const fxaa = new ShaderPass(FXAAShader);
    const uniforms = fxaa.material.uniforms;
    if (uniforms['resolution']) {
      uniforms['resolution'].value.x = 1 / resolution.value.x;
      uniforms['resolution'].value.y = 1 / resolution.value.y;
    }
    fxaaPass.value = fxaa;
    (composer.value as any).addPass(fxaa);
  };

  // Update effect settings
  const updateBloomSettings = () => {
    if (!bloomPass.value) return;

    const settings = bloomSettings.value;
    bloomPass.value.strength = settings.strength;
    bloomPass.value.radius = settings.radius;
    bloomPass.value.threshold = settings.threshold;

    // Update selective bloom settings
    const selectedObjects: THREE.Object3D[] = [];

    // Add objects based on bloom settings
    scene.traverse((object) => {
      if (object.userData.bloomLayer) {
        if (settings.node_bloom_strength > 0 && object.userData.type === 'node') {
          selectedObjects.push(object);
        }
        if (settings.edge_bloom_strength > 0 && object.userData.type === 'edge') {
          selectedObjects.push(object);
        }
        if (settings.environment_bloom_strength > 0 && object.userData.type === 'environment') {
          selectedObjects.push(object);
        }
      }
    });

    // Set selected objects for bloom
    bloomPass.value.selectedObjects = selectedObjects;
  };

  // Handle resize
  const handleResize = () => {
    if (!composer.value || !fxaaPass.value) return;

    const size = new THREE.Vector2();
    renderer.getSize(size);
    composer.value.setSize(size.width, size.height);

    // Update FXAA resolution
    const pixelRatio = renderer.getPixelRatio();
    const uniforms = fxaaPass.value.material.uniforms;
    if (uniforms['resolution']) {
      uniforms['resolution'].value.x = 1 / (size.width * pixelRatio);
      uniforms['resolution'].value.y = 1 / (size.height * pixelRatio);
    }
  };

  // Render function
  const render = () => {
    if (composer.value) {
      composer.value.render();
    }
  };

  // Watch for settings changes
  watch(() => bloomSettings.value, () => {
    updateBloomSettings();
  }, { deep: true });

  // Lifecycle
  onMounted(() => {
    initializeComposer();
    window.addEventListener('resize', handleResize);
  });

  onBeforeUnmount(() => {
    window.removeEventListener('resize', handleResize);
    
    // Dispose of resources
    if (composer.value) {
      composer.value.passes.forEach(pass => {
        if ('dispose' in pass && typeof pass.dispose === 'function') {
          pass.dispose();
        }
      });
    }

    // Clear references
    bloomPass.value = null;
    ssaoPass.value = null;
    fxaaPass.value = null;
    composer.value = null;
  });

  return {
    composer,
    bloomPass,
    ssaoPass,
    fxaaPass,
    render,
    handleResize,
    updateBloomSettings
  };
}

----
composables/useControlGroups.ts
import { ref, reactive } from 'vue';
import type { ControlGroup, ControlItem } from '../types/components';

export function useControlGroups() {
  const collapsedGroups = reactive<Record<string, boolean>>({
    appearance: true,
    material: true,
    physics: true,
    bloom: true,
    environment: true,
    fisheye: true
  });

  const toggleGroup = (groupName: string) => {
    collapsedGroups[groupName] = !collapsedGroups[groupName];
  };

  const createControlGroup = (
    name: string,
    label: string,
    controls: ControlItem[]
  ): ControlGroup => ({
    name,
    label,
    controls,
    collapsed: collapsedGroups[name]
  });

  const createRangeControl = (
    name: string,
    label: string,
    value: number,
    min: number,
    max: number,
    step: number
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'range',
    min,
    max,
    step
  });

  const createColorControl = (
    name: string,
    label: string,
    value: string
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'color'
  });

  const createCheckboxControl = (
    name: string,
    label: string,
    value: boolean
  ): ControlItem => ({
    name,
    label,
    value,
    type: 'checkbox'
  });

  return {
    collapsedGroups,
    toggleGroup,
    createControlGroup,
    createRangeControl,
    createColorControl,
    createCheckboxControl
  };
}

----
composables/useVisualization.ts
import { ref, computed, onBeforeUnmount, provide, markRaw, shallowRef, watch } from 'vue';
import * as THREE from 'three';
import { OrbitControls as ThreeOrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { useSettingsStore } from '../stores/settings';
import { useVisualizationStore } from '../stores/visualization';
import { useBinaryUpdateStore } from '../stores/binaryUpdate';
import { useWebSocketStore } from '../stores/websocket';
import type { Node, Edge, CoreState, InitializationOptions, GraphNode, GraphEdge, GraphData } from '../types/core';
import { POSITION_SCALE } from '../constants/websocket';
import { VISUALIZATION_CONSTANTS as CONSTANTS, LIGHT_SETTINGS, SCENE_SETTINGS, CAMERA_SETTINGS } from '../constants/visualization';

// Symbol for providing scene to components
export const SCENE_KEY = Symbol('three-scene');

// Add binary data helper
function createBinaryPositionData(nodes: Node[]): ArrayBuffer {
  // 4 bytes for header + 24 bytes per node (x,y,z,vx,vy,vz as f32)
  const buffer = new ArrayBuffer(4 + nodes.length * 24);
  const view = new DataView(buffer);
  
  // Write header (1.0 to indicate client-side update)
  view.setFloat32(0, 1.0, true);
  
  // Write node positions and velocities
  nodes.forEach((node, i) => {
    const offset = 4 + i * 24;
    const position = node.position || [0, 0, 0];
    view.setFloat32(offset, position[0], true);
    view.setFloat32(offset + 4, position[1], true);
    view.setFloat32(offset + 8, position[2], true);
    // Set velocities to 0 since we're not calculating forces
    view.setFloat32(offset + 12, 0, true);
    view.setFloat32(offset + 16, 0, true);
    view.setFloat32(offset + 20, 0, true);
  });
  
  return buffer;
}

export function useVisualization() {
  const settingsStore = useSettingsStore();
  const visualizationStore = useVisualizationStore();
  const binaryStore = useBinaryUpdateStore();
  const webSocketStore = useWebSocketStore();
  
  // Core visualization state
  const state = shallowRef<CoreState>({
    renderer: null,
    camera: null,
    scene: null,
    canvas: null,
    isInitialized: false,
    isXRSupported: false,
    isWebGL2: false,
    isGPUMode: false,
    fps: 0,
    lastFrameTime: 0
  });

  // Mesh cache using Maps for O(1) lookup
  const meshCache = {
    nodes: new Map<string, THREE.Mesh>()
  };

  // Interaction state
  const hoveredNode = ref<string | null>(null);
  const selectedNode = ref<string | null>(null);
  const isProcessingUpdate = ref(false);
  const isInteracting = ref(false);

  // GPU acceleration state
  const isGPUEnabled = computed(() => webSocketStore.isGPUEnabled);

  // Track animation frame for cleanup
  let animationFrameId: number | null = null;
  let controls: ThreeOrbitControls | null = null;

  // Create or update node mesh with efficient caching
  const createNodeMesh = (node: Node): THREE.Mesh => {
    const geometry = new THREE.SphereGeometry(0.02, 32, 32);
    const material = new THREE.MeshStandardMaterial({
      color: node.color || 0xffffff,
      metalness: 0.3,
      roughness: 0.7,
      emissive: node.color || 0xffffff,
      emissiveIntensity: 0.2
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    if (node.position) {
      mesh.position.set(
        node.position[0] / POSITION_SCALE,
        node.position[1] / POSITION_SCALE,
        node.position[2] / POSITION_SCALE
      );
    }
    
    const size = (node.size || 1) * 0.02;
    mesh.scale.setScalar(size);

    mesh.userData = {
      id: node.id,
      type: 'node',
      originalData: { ...node }
    };

    return markRaw(mesh);
  };

  // Initialize Three.js scene
  const initScene = (canvas: HTMLCanvasElement) => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, SCENE_SETTINGS.fogNear, SCENE_SETTINGS.fogFar);

    const camera = new THREE.PerspectiveCamera(
      CAMERA_SETTINGS.fov,
      window.innerWidth / window.innerHeight,
      CAMERA_SETTINGS.near,
      CAMERA_SETTINGS.far
    );
    camera.position.copy(CAMERA_SETTINGS.position);
    camera.lookAt(CAMERA_SETTINGS.target);

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance',
      logarithmicDepthBuffer: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Add lights
    const ambientLight = new THREE.AmbientLight(
      LIGHT_SETTINGS.ambient.color,
      LIGHT_SETTINGS.ambient.intensity
    );
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(
      LIGHT_SETTINGS.directional.color,
      LIGHT_SETTINGS.directional.intensity
    );
    directionalLight.position.set(...LIGHT_SETTINGS.directional.position);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    const hemiLight = new THREE.HemisphereLight(
      LIGHT_SETTINGS.hemisphere.skyColor,
      LIGHT_SETTINGS.hemisphere.groundColor,
      LIGHT_SETTINGS.hemisphere.intensity
    );
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    // Add controls
    controls = new ThreeOrbitControls(camera, renderer.domElement);
    if (controls) {
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxDistance = 5;
      controls.minDistance = 0.1;
      controls.maxPolarAngle = Math.PI * 0.8;
      controls.target.copy(CAMERA_SETTINGS.target);
    }

    // Add grid helper
    const gridHelper = new THREE.GridHelper(
      SCENE_SETTINGS.gridSize,
      SCENE_SETTINGS.gridDivisions,
      0x444444,
      0x222222
    );
    scene.add(gridHelper);

    // Add axes helper
    const axesHelper = new THREE.AxesHelper(1);
    scene.add(axesHelper);

    // Store GPU state in scene
    scene.userData.gpuEnabled = isGPUEnabled.value;

    provide(SCENE_KEY, scene);

    return {
      scene: markRaw(scene),
      camera: markRaw(camera),
      renderer: markRaw(renderer)
    };
  };

  // Animation loop with optimized updates
  const animate = () => {
    if (!state.value.isInitialized) return;

    const { renderer, scene, camera } = state.value;
    if (renderer && scene && camera) {
      controls?.update();

      // Use server-provided positions
      const positions = binaryStore.getAllPositions;
      const nodeCount = binaryStore.nodeCount;
      
      for (let i = 0; i < nodeCount; i++) {
        const nodeId = visualizationStore.graphData?.nodes[i]?.id;
        if (!nodeId) continue;

        const mesh = meshCache.nodes.get(nodeId);
        if (!mesh) continue;

        const posOffset = i * 3;
        mesh.position.set(
          positions[posOffset] / POSITION_SCALE,
          positions[posOffset + 1] / POSITION_SCALE,
          positions[posOffset + 2] / POSITION_SCALE
        );
      }

      const currentTime = performance.now();
      const delta = currentTime - state.value.lastFrameTime;
      state.value.fps = 1000 / delta;
      state.value.lastFrameTime = currentTime;

      const needsRender = scene.userData?.needsRender !== false || 
                         controls?.enabled || 
                         currentTime - (scene.userData?.lastUpdate || 0) > 1000;

      if (needsRender) {
        renderer.render(scene, camera);
        scene.userData.needsRender = false;
        scene.userData.lastUpdate = currentTime;
      }
    }

    animationFrameId = requestAnimationFrame(animate);
  };

  // Initialize visualization system
  const initialize = async (options: InitializationOptions) => {
    if (state.value.isInitialized) return;

    try {
      const { scene, camera, renderer } = initScene(options.canvas);

      state.value = markRaw({
        renderer,
        camera,
        scene,
        canvas: options.canvas,
        isInitialized: true,
        isXRSupported: false,
        isWebGL2: renderer.capabilities.isWebGL2,
        isGPUMode: isGPUEnabled.value,
        fps: 0,
        lastFrameTime: performance.now()
      });

      // Watch for graph data changes
      watch(() => visualizationStore.graphData, (graphData: GraphData | null) => {
        if (!graphData) return;
        // Update nodes with server-provided positions
        updateNodes(graphData.nodes);
      }, { deep: true });

      animate();

      window.addEventListener('resize', () => {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      console.log('Visualization system initialized');
    } catch (error) {
      console.error('Failed to initialize visualization:', error);
      throw error;
    }
  };

  // Event handlers
  const handleNodeHover = (nodeId: string | null) => {
    hoveredNode.value = nodeId;
    if (state.value.scene) {
      state.value.scene.userData.needsRender = true;
    }
  };

  const handleNodeSelect = (nodeId: string | null) => {
    selectedNode.value = nodeId;
    if (state.value.scene) {
      state.value.scene.userData.needsRender = true;
    }
  };

  // Update nodes
  const updateNodes = (nodes: Node[]) => {
    if (!state.value.scene || isProcessingUpdate.value) return;

    isProcessingUpdate.value = true;
    try {
      const scene = state.value.scene;
      const currentIds = new Set(nodes.map(n => n.id));

      // Remove old nodes
      for (const [id, mesh] of meshCache.nodes.entries()) {
        if (!currentIds.has(id)) {
          scene.remove(mesh);
          mesh.geometry.dispose();
          (mesh.material as THREE.Material).dispose();
          meshCache.nodes.delete(id);
        }
      }

      // Add or update nodes
      nodes.forEach(node => {
        let mesh = meshCache.nodes.get(node.id);
        
        if (!mesh) {
          // Create new mesh
          mesh = createNodeMesh(node);
          scene.add(mesh);
          meshCache.nodes.set(node.id, mesh);
        } else {
          // Update existing mesh
          if (node.position) {
            mesh.position.set(
              node.position[0] / POSITION_SCALE,
              node.position[1] / POSITION_SCALE,
              node.position[2] / POSITION_SCALE
            );
          }
          if (node.size) {
            mesh.scale.setScalar(node.size * 0.02);
          }
          if (node.color) {
            (mesh.material as THREE.MeshStandardMaterial).color.set(node.color);
            (mesh.material as THREE.MeshStandardMaterial).emissive.set(node.color);
          }
        }
      });

      scene.userData.needsRender = true;
    } finally {
      isProcessingUpdate.value = false;
    }
  };

  // Update positions from binary data
  const updatePositions = (positions: Float32Array, velocities: Float32Array, nodeCount: number) => {
    if (!state.value.scene || !state.value.isInitialized || isProcessingUpdate.value) return;

    isProcessingUpdate.value = true;
    try {
      const nodes = visualizationStore.graphData?.nodes || [];
      for (let i = 0; i < nodeCount; i++) {
        const node = nodes[i];
        if (!node) continue;

        const mesh = meshCache.nodes.get(node.id);
        if (!mesh) continue;

        const posOffset = i * 3;
        mesh.position.set(
          positions[posOffset] / POSITION_SCALE,
          positions[posOffset + 1] / POSITION_SCALE,
          positions[posOffset + 2] / POSITION_SCALE
        );
      }

      if (state.value.scene) {
        state.value.scene.userData.needsRender = true;
      }
    } finally {
      isProcessingUpdate.value = false;
    }
  };

  // Cleanup
  onBeforeUnmount(() => {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
    }

    if (controls) {
      controls.dispose();
    }

    // Clean up meshes
    meshCache.nodes.forEach(mesh => {
      mesh.geometry.dispose();
      (mesh.material as THREE.Material).dispose();
    });
    meshCache.nodes.clear();

    if (state.value.renderer) {
      state.value.renderer.dispose();
      state.value.renderer.forceContextLoss();
    }
    
    state.value.canvas?.remove();
    state.value = {
      renderer: null,
      camera: null,
      scene: null,
      canvas: null,
      isInitialized: false,
      isXRSupported: false,
      isWebGL2: false,
      isGPUMode: false,
      fps: 0,
      lastFrameTime: 0
    };
  });

  return {
    state,
    initialize,
    updateNodes,
    updatePositions,
    handleNodeHover,
    handleNodeSelect,
    hoveredNode: computed(() => hoveredNode.value),
    selectedNode: computed(() => selectedNode.value),
    isGPUEnabled,
    isInteracting: computed(() => isInteracting.value)
  };
}

----
composables/useControlSettings.ts
import { computed } from 'vue';
import type { 
  VisualizationConfig, 
  BloomConfig, 
  FisheyeConfig,
  ControlGroup,
  ControlItem 
} from '../types/components';
import { useControlGroups } from './useControlGroups';
import { useSettingsStore } from '../stores/settings';
import { storeToRefs } from 'pinia';

export function useControlSettings() {
  const settingsStore = useSettingsStore();
  const { 
    createControlGroup, 
    createRangeControl, 
    createColorControl, 
    createCheckboxControl 
  } = useControlGroups();

  // Create appearance controls
  const createAppearanceGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createColorControl('node_color', 'Base Node Color', config.node_color),
      createColorControl('node_color_new', 'New Nodes', config.node_color_new),
      createColorControl('node_color_recent', 'Recent Nodes', config.node_color_recent),
      createColorControl('node_color_medium', 'Medium Age', config.node_color_medium),
      createColorControl('node_color_old', 'Old Nodes', config.node_color_old),
      createColorControl('node_color_core', 'Core Nodes', config.node_color_core),
      createColorControl('node_color_secondary', 'Secondary Nodes', config.node_color_secondary),
      createRangeControl('min_node_size', 'Minimum Size', config.min_node_size, 0.05, 0.5, 0.05),
      createRangeControl('max_node_size', 'Maximum Size', config.max_node_size, 0.1, 1.0, 0.1)
    ];

    return createControlGroup('appearance', 'Node Appearance', controls);
  };

  // Create material controls
  const createMaterialGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('node_material_metalness', 'Metalness', config.material.node_material_metalness, 0, 1, 0.1),
      createRangeControl('node_material_roughness', 'Roughness', config.material.node_material_roughness, 0, 1, 0.1),
      createRangeControl('node_material_clearcoat', 'Clearcoat', config.material.node_material_clearcoat, 0, 1, 0.1),
      createRangeControl('node_material_clearcoat_roughness', 'Clearcoat Roughness', config.material.node_material_clearcoat_roughness, 0, 1, 0.1),
      createRangeControl('node_material_opacity', 'Opacity', config.material.node_material_opacity, 0, 1, 0.1),
      createRangeControl('node_emissive_min_intensity', 'Min Emissive', config.material.node_emissive_min_intensity, 0, 1, 0.1),
      createRangeControl('node_emissive_max_intensity', 'Max Emissive', config.material.node_emissive_max_intensity, 0, 2, 0.1)
    ];

    return createControlGroup('material', 'Material Properties', controls);
  };

  // Create physics controls
  const createPhysicsGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('force_directed_iterations', 'Iterations', config.physics.force_directed_iterations, 100, 500, 10),
      createRangeControl('force_directed_spring', 'Spring Strength', config.physics.force_directed_spring, 0.001, 0.1, 0.001),
      createRangeControl('force_directed_repulsion', 'Repulsion', config.physics.force_directed_repulsion, 100, 2000, 100),
      createRangeControl('force_directed_attraction', 'Attraction', config.physics.force_directed_attraction, 0.001, 0.1, 0.001),
      createRangeControl('force_directed_damping', 'Damping', config.physics.force_directed_damping, 0.1, 1.0, 0.1)
    ];

    return createControlGroup('physics', 'Physics Simulation', controls);
  };

  // Create bloom controls
  const createBloomGroup = (config: BloomConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createRangeControl('node_bloom_strength', 'Node Strength', config.node_bloom_strength, 0, 2, 0.1),
      createRangeControl('node_bloom_radius', 'Node Radius', config.node_bloom_radius, 0, 1, 0.1),
      createRangeControl('node_bloom_threshold', 'Node Threshold', config.node_bloom_threshold, 0, 1, 0.1),
      createRangeControl('edge_bloom_strength', 'Edge Strength', config.edge_bloom_strength, 0, 2, 0.1),
      createRangeControl('edge_bloom_radius', 'Edge Radius', config.edge_bloom_radius, 0, 1, 0.1),
      createRangeControl('edge_bloom_threshold', 'Edge Threshold', config.edge_bloom_threshold, 0, 1, 0.1),
      createRangeControl('environment_bloom_strength', 'Environment Strength', config.environment_bloom_strength, 0, 2, 0.1),
      createRangeControl('environment_bloom_radius', 'Environment Radius', config.environment_bloom_radius, 0, 1, 0.1),
      createRangeControl('environment_bloom_threshold', 'Environment Threshold', config.environment_bloom_threshold, 0, 1, 0.1)
    ];

    return createControlGroup('bloom', 'Bloom Effects', controls);
  };

  // Create environment controls
  const createEnvironmentGroup = (config: VisualizationConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createColorControl('hologram_color', 'Hologram Color', config.hologram_color),
      createRangeControl('hologram_scale', 'Hologram Scale', config.hologram_scale, 1, 10, 1),
      createRangeControl('hologram_opacity', 'Hologram Opacity', config.hologram_opacity, 0, 1, 0.05),
      createRangeControl('fog_density', 'Fog Density', config.fog_density, 0, 0.01, 0.0001)
    ];

    return createControlGroup('environment', 'Environment', controls);
  };

  // Create fisheye controls
  const createFisheyeGroup = (config: FisheyeConfig): ControlGroup => {
    const controls: ControlItem[] = [
      createCheckboxControl('enabled', 'Enable Fisheye', config.enabled),
      createRangeControl('strength', 'Strength', config.strength, 0, 1, 0.1),
      createRangeControl('radius', 'Radius', config.radius, 10, 200, 10),
      createRangeControl('focus_x', 'Focus X', config.focus_x, -100, 100, 1),
      createRangeControl('focus_y', 'Focus Y', config.focus_y, -100, 100, 1),
      createRangeControl('focus_z', 'Focus Z', config.focus_z, -100, 100, 1)
    ];

    return createControlGroup('fisheye', 'Fisheye Effect', controls);
  };

  // Handle control changes
  const handleControlChange = (groupName: string, controlName: string, value: any) => {
    const { getVisualizationSettings } = storeToRefs(settingsStore);
    const currentSettings = getVisualizationSettings.value;

    switch (groupName) {
      case 'appearance':
      case 'environment':
        settingsStore.updateVisualizationSettings({ [controlName]: value });
        break;
      case 'material':
        settingsStore.updateVisualizationSettings({
          material: {
            ...currentSettings.material,
            [controlName]: value
          }
        });
        break;
      case 'physics':
        settingsStore.updateVisualizationSettings({
          physics: {
            ...currentSettings.physics,
            [controlName]: value
          }
        });
        break;
      case 'bloom':
        settingsStore.updateBloomSettings({ [controlName]: value });
        break;
      case 'fisheye':
        settingsStore.updateFisheyeSettings({ [controlName]: value });
        break;
    }
  };

  return {
    createAppearanceGroup,
    createMaterialGroup,
    createPhysicsGroup,
    createBloomGroup,
    createEnvironmentGroup,
    createFisheyeGroup,
    handleControlChange
  };
}

----
composables/useGraphSystem.ts
import { ref, computed, onBeforeUnmount } from 'vue';
import * as THREE from 'three';
import { useVisualizationStore } from '../stores/visualization';
import { usePlatform } from './usePlatform';
import { initXRInteraction } from '../xr/xrInteraction';
import type { GraphNode, GraphEdge, GraphData } from '../types/core';
import type { Scene, PerspectiveCamera, WebGLRenderer } from 'three';

// Performance tuning constants
const MIN_UPDATE_INTERVAL = 200 // 5 FPS
const BATCH_UPDATE_SIZE = 1000 // Number of nodes to update per frame
const FRAME_BUDGET_MS = 200 // Target 5 FPS
const PERFORMANCE_SAMPLE_SIZE = 60 // Number of frames to average for performance metrics

// Geometry constants
const NODE_SEGMENTS = 32
const NODE_RINGS = 32
const MIN_NODE_SIZE = 0.02
const MAX_NODE_SIZE = 0.1

// Material constants
const DEFAULT_NODE_COLOR = 0x666666
const HOVERED_NODE_COLOR = 0x00ff00
const SELECTED_NODE_COLOR = 0xff0000
const DEFAULT_EDGE_COLOR = 0x666666
const MIN_EDGE_WIDTH = 0.005
const MAX_EDGE_WIDTH = 0.02

export function useGraphSystem() {
  const visualizationStore = useVisualizationStore();
  const platform = usePlatform();
  
  // Three.js objects
  const graphGroup = new THREE.Group();
  const nodeGeometry = new THREE.SphereGeometry(1, NODE_SEGMENTS, NODE_RINGS);
  const nodeMaterial = new THREE.MeshPhysicalMaterial({
    color: DEFAULT_NODE_COLOR,
    metalness: 0.3,
    roughness: 0.7,
    emissive: DEFAULT_NODE_COLOR,
    emissiveIntensity: 0.2
  });
  
  // State
  const nodes = ref<Map<string, THREE.Mesh>>(new Map());
  const edges = ref<Map<string, THREE.Line>>(new Map());
  const hoveredNode = ref<string | null>(null);
  const selectedNode = ref<string | null>(null);
  const nodeCount = ref(0);
  const edgeCount = ref(0);
  const lastUpdateTime = ref(0);
  const performanceMetrics = ref({
    updateTime: 0,
    frameTime: 0,
    samples: [] as number[]
  });

  // XR interaction handler
  let xrInteractionHandler: any = null;

  // Node position and scale helpers
  const getNodePosition = (node: GraphNode): THREE.Vector3 => {
    const position = node.position || [0, 0, 0];
    return new THREE.Vector3(position[0], position[1], position[2]);
  };

  const getNodeScale = (node: GraphNode): number => {
    const size = node.size || 1;
    return THREE.MathUtils.clamp(size * MIN_NODE_SIZE, MIN_NODE_SIZE, MAX_NODE_SIZE);
  };

  const getNodeColor = (node: GraphNode): THREE.Color => {
    if (node.id === selectedNode.value) {
      return new THREE.Color(SELECTED_NODE_COLOR);
    }
    if (node.id === hoveredNode.value) {
      return new THREE.Color(HOVERED_NODE_COLOR);
    }
    return new THREE.Color(node.color || DEFAULT_NODE_COLOR);
  };

  // Edge helpers
  const getEdgePoints = (edge: GraphEdge): [THREE.Vector3, THREE.Vector3] => {
    const sourcePos = getNodePosition(edge.sourceNode);
    const targetPos = getNodePosition(edge.targetNode);
    return [sourcePos, targetPos];
  };

  const getEdgeColor = (edge: GraphEdge): THREE.Color => {
    return new THREE.Color(edge.color || DEFAULT_EDGE_COLOR);
  };

  const getEdgeWidth = (edge: GraphEdge): number => {
    const weight = edge.weight || 1;
    return THREE.MathUtils.clamp(
      weight * MIN_EDGE_WIDTH,
      MIN_EDGE_WIDTH,
      MAX_EDGE_WIDTH
    );
  };

  // Event handlers
  const handleNodeClick = (nodeId: string) => {
    selectedNode.value = nodeId;
    visualizationStore.updateNode(nodeId, { userData: { ...visualizationStore.getNodeById(nodeId)?.userData, selected: true } });

    // Provide haptic feedback in XR mode
    if (platform.isXRActive()) {
      platform.vibrate('right', 0.5, 50);
    }
  };

  const handleNodeHover = (nodeId: string | null) => {
    hoveredNode.value = nodeId;
    if (nodeId) {
      visualizationStore.updateNode(nodeId, { userData: { ...visualizationStore.getNodeById(nodeId)?.userData, hovered: true } });
    }
  };

  // Update methods
  const updateNodePosition = (nodeId: string, position: THREE.Vector3, velocity?: THREE.Vector3) => {
    const now = performance.now();
    if (now - lastUpdateTime.value < MIN_UPDATE_INTERVAL) {
      return;
    }

    const mesh = nodes.value.get(nodeId);
    if (mesh) {
      mesh.position.copy(position);
      if (velocity) {
        mesh.userData.velocity = velocity;
      }

      // Send position update to server at 5 FPS
      visualizationStore.updateNode(nodeId, {
        position: [position.x, position.y, position.z],
        velocity: velocity ? [velocity.x, velocity.y, velocity.z] : undefined
      });

      lastUpdateTime.value = now;
    }
  };

  const updateGraphData = (data: GraphData) => {
    const now = performance.now();
    if (now - lastUpdateTime.value < MIN_UPDATE_INTERVAL) {
      return;
    }

    // Update nodes
    const currentNodeIds = new Set<string>();
    data.nodes.forEach((node, index) => {
      currentNodeIds.add(node.id);
      let mesh = nodes.value.get(node.id);

      if (!mesh) {
        // Create new node
        mesh = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
        mesh.userData = { id: node.id, type: 'node', data: node };
        nodes.value.set(node.id, mesh);
        graphGroup.add(mesh);

        // Make node interactable in XR
        if (xrInteractionHandler) {
          xrInteractionHandler.makeInteractable(mesh);
        }
      }

      // Update position and scale
      mesh.position.copy(getNodePosition(node));
      mesh.scale.setScalar(getNodeScale(node));

      // Update material
      const material = mesh.material as THREE.MeshPhysicalMaterial;
      const color = getNodeColor(node);
      material.color.copy(color);
      material.emissive.copy(color);

      // Process in batches to maintain performance
      if (index % BATCH_UPDATE_SIZE === 0) {
        if (performance.now() - now > FRAME_BUDGET_MS) {
          requestAnimationFrame(() => updateGraphData(data));
          return;
        }
      }
    });

    // Remove old nodes
    nodes.value.forEach((mesh, id) => {
      if (!currentNodeIds.has(id)) {
        if (xrInteractionHandler) {
          xrInteractionHandler.removeInteractable(mesh);
        }
        graphGroup.remove(mesh);
        nodes.value.delete(id);
      }
    });

    // Update edges
    const currentEdgeIds = new Set<string>();
    data.edges.forEach(edge => {
      const edgeId = `${edge.source}-${edge.target}`;
      currentEdgeIds.add(edgeId);
      let line = edges.value.get(edgeId);

      if (!line) {
        // Create new edge
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.LineBasicMaterial({
          color: getEdgeColor(edge),
          linewidth: getEdgeWidth(edge)
        });
        line = new THREE.Line(geometry, material);
        line.userData = { id: edgeId, type: 'edge', data: edge };
        edges.value.set(edgeId, line);
        graphGroup.add(line);
      }

      // Update position
      const [start, end] = getEdgePoints(edge);
      const positions = new Float32Array([
        start.x, start.y, start.z,
        end.x, end.y, end.z
      ]);
      line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    });

    // Remove old edges
    edges.value.forEach((line, id) => {
      if (!currentEdgeIds.has(id)) {
        graphGroup.remove(line);
        edges.value.delete(id);
      }
    });

    // Update counts
    nodeCount.value = nodes.value.size;
    edgeCount.value = edges.value.size;

    // Update performance metrics
    const updateTime = performance.now() - now;
    performanceMetrics.value.updateTime = updateTime;
    performanceMetrics.value.samples.push(updateTime);
    if (performanceMetrics.value.samples.length > PERFORMANCE_SAMPLE_SIZE) {
      performanceMetrics.value.samples.shift();
    }
    performanceMetrics.value.frameTime = performanceMetrics.value.samples.reduce((a, b) => a + b, 0) / 
                                       performanceMetrics.value.samples.length;

    lastUpdateTime.value = now;
  };

  // Initialize XR interaction if available
  const initializeXR = (scene: Scene, camera: PerspectiveCamera, renderer: WebGLRenderer) => {
    if (platform.hasXRSupport()) {
      // Initialize XR interaction handler with position update callback
      xrInteractionHandler = initXRInteraction(
        scene, 
        camera, 
        renderer,
        (nodeId: string, position: THREE.Vector3) => {
          updateNodePosition(nodeId, position);
        }
      );
      
      // Make existing nodes interactable
      nodes.value.forEach(mesh => {
        xrInteractionHandler.makeInteractable(mesh);
      });
    }
  };

  // Cleanup
  onBeforeUnmount(() => {
    if (xrInteractionHandler) {
      xrInteractionHandler.cleanup();
    }

    nodes.value.forEach(mesh => {
      mesh.geometry.dispose();
      (mesh.material as THREE.Material).dispose();
    });
    edges.value.forEach(line => {
      line.geometry.dispose();
      (line.material as THREE.Material).dispose();
    });
    nodes.value.clear();
    edges.value.clear();
  });

  return {
    graphGroup,
    hoveredNode: computed(() => hoveredNode.value),
    selectedNode: computed(() => selectedNode.value),
    nodeCount: computed(() => nodeCount.value),
    edgeCount: computed(() => edgeCount.value),
    performanceMetrics: computed(() => performanceMetrics.value),
    getNodePosition,
    getNodeScale,
    getNodeColor,
    getEdgePoints,
    getEdgeColor,
    getEdgeWidth,
    handleNodeClick,
    handleNodeHover,
    updateNodePosition,
    updateGraphData,
    initializeXR
  };
}

----
composables/useThreeScene.ts
import { ref, onBeforeUnmount } from 'vue';
import THREE, { OrbitControls } from '../utils/three';
import type { Scene, PerspectiveCamera, WebGLRenderer, Object3D, Material, Texture } from 'three';

interface ThreeResources {
  scene: Scene;
  camera: PerspectiveCamera;
  renderer: WebGLRenderer;
  controls?: OrbitControls;
  environment?: {
    ground: THREE.Mesh;
    gridHelper: THREE.GridHelper;
    dispose: () => void;
  };
}

interface MaterialWithMap extends Material {
  map?: Texture | null;
}

export function useThreeScene() {
  const resources = ref<ThreeResources | null>(null);

  const handleContextLost = (event: Event) => {
    event.preventDefault();
    console.warn('WebGL context lost. Attempting to restore...');
  };

  const handleContextRestored = () => {
    console.log('WebGL context restored');
    window.dispatchEvent(new Event('webglcontextrestored'));
  };

  const setupLighting = (scene: Scene) => {
    // Main directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    
    // Optimize shadow map settings
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.bias = -0.0001;
    
    scene.add(directionalLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    // Ambient light for overall scene brightness
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
  };

  const initScene = async () => {
    try {
      // Create scene
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      // Create camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 3);

      // Create renderer
      const canvas = document.createElement('canvas');
      const contextAttributes = {
        alpha: true,
        antialias: true,
        powerPreference: "high-performance" as WebGLPowerPreference,
        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false
      };

      // Try WebGL2 first
      let gl = canvas.getContext('webgl2', contextAttributes);
      let isWebGL2 = !!gl;

      if (!gl) {
        console.warn('WebGL2 not available, falling back to WebGL1');
        gl = canvas.getContext('webgl', contextAttributes) ||
             canvas.getContext('experimental-webgl', contextAttributes);
        isWebGL2 = false;
      }

      if (!gl) {
        throw new Error('WebGL not supported');
      }

      const renderer = new THREE.WebGLRenderer({
        canvas,
        context: gl as WebGLRenderingContext | WebGL2RenderingContext,
        antialias: true,
        alpha: true,
        powerPreference: "high-performance",
        preserveDrawingBuffer: false
      });

      // Configure renderer based on WebGL version
      if (isWebGL2) {
        console.log('Using WebGL2 renderer');
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      } else {
        console.log('Using WebGL1 renderer');
        renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
        renderer.shadowMap.type = THREE.PCFShadowMap;
      }

      // Common renderer settings
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;

      // Store WebGL version
      (renderer as any).capabilities.isWebGL2 = isWebGL2;

      // Add context loss handling
      renderer.domElement.addEventListener('webglcontextlost', handleContextLost, false);
      renderer.domElement.addEventListener('webglcontextrestored', handleContextRestored, false);

      // Set up lighting
      setupLighting(scene);

      // Append renderer to DOM
      const container = document.getElementById('scene-container');
      if (container) {
        container.appendChild(renderer.domElement);
      } else {
        document.body.appendChild(renderer.domElement);
      }

      // Create orbit controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI * 0.95;
      controls.minDistance = 1;
      controls.maxDistance = 50;
      controls.enablePan = true;
      controls.panSpeed = 0.5;
      controls.rotateSpeed = 0.5;
      controls.zoomSpeed = 0.5;

      // Disable controls in XR
      renderer.xr.addEventListener('sessionstart', () => {
        controls.enabled = false;
      });
      
      renderer.xr.addEventListener('sessionend', () => {
        controls.enabled = true;
      });

      // Create basic environment
      const environment = createBasicEnvironment(scene);

      // Store resources
      resources.value = {
        scene,
        camera,
        renderer,
        controls,
        environment
      };

      // Handle window resize
      window.addEventListener('resize', handleResize);

      return resources.value;

    } catch (error) {
      console.error('Error initializing Three.js scene:', error);
      throw error;
    }
  };

  const createBasicEnvironment = (scene: Scene) => {
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      roughness: 0.8,
      metalness: 0.2,
      transparent: true,
      opacity: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 100);
    (gridHelper.material as THREE.Material).transparent = true;
    (gridHelper.material as THREE.Material).opacity = 0.2;
    scene.add(gridHelper);

    return {
      ground,
      gridHelper,
      dispose: () => {
        groundGeometry.dispose();
        groundMaterial.dispose();
        if (gridHelper.material) {
          (gridHelper.material as THREE.Material).dispose();
        }
        if (gridHelper.geometry) {
          gridHelper.geometry.dispose();
        }
        scene.remove(ground);
        scene.remove(gridHelper);
      }
    };
  };

  const handleResize = () => {
    if (!resources.value) return;

    const { camera, renderer } = resources.value;
    if (!renderer.xr.isPresenting) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  };

  const dispose = () => {
    if (!resources.value) return;

    const { scene, renderer, controls, environment } = resources.value;

    // Dispose of scene objects
    scene.traverse((object: Object3D) => {
      if ((object as THREE.Mesh).geometry) {
        (object as THREE.Mesh).geometry.dispose();
      }
      
      if ((object as THREE.Mesh).material) {
        const material = (object as THREE.Mesh).material;
        if (Array.isArray(material)) {
          material.forEach(mat => {
            const matWithMap = mat as MaterialWithMap;
            if (matWithMap.map) matWithMap.map.dispose();
            mat.dispose();
          });
        } else {
          const matWithMap = material as MaterialWithMap;
          if (matWithMap.map) matWithMap.map.dispose();
          material.dispose();
        }
      }
    });

    // Dispose of environment
    if (environment) {
      environment.dispose();
    }

    // Dispose of renderer
    renderer.dispose();
    renderer.forceContextLoss();
    renderer.domElement.remove();

    // Remove context loss listeners
    renderer.domElement.removeEventListener('webglcontextlost', handleContextLost);
    renderer.domElement.removeEventListener('webglcontextrestored', handleContextRestored);

    // Dispose of controls
    if (controls) {
      controls.dispose();
    }

    // Remove resize listener
    window.removeEventListener('resize', handleResize);

    resources.value = null;
  };

  onBeforeUnmount(() => {
    dispose();
  });

  return {
    resources,
    initScene,
    dispose
  };
}

----
composables/usePlatform.ts
import { ref, onMounted, onBeforeUnmount } from 'vue';
import { platformManager, type PlatformState } from '../platform/platformManager';
import type { SceneConfig } from '../types/core';
import type { BrowserState, BrowserInitOptions } from '../types/platform/browser';
import type { QuestState, QuestInitOptions, XRHandedness, XRHand } from '../types/platform/quest';
import type { Camera, Group, WebGLRenderer, Scene } from 'three';

// Convert core initialization options to platform-specific options
const convertToPlatformOptions = (options: {
  canvas: HTMLCanvasElement;
  scene?: Partial<SceneConfig>;
}): BrowserInitOptions | QuestInitOptions => {
  const baseOptions = {
    canvas: options.canvas,
    scene: options.scene ? {
      antialias: options.scene.antialias ?? true,
      alpha: options.scene.alpha ?? true,
      preserveDrawingBuffer: options.scene.preserveDrawingBuffer ?? true,
      powerPreference: options.scene.powerPreference ?? 'high-performance'
    } : undefined
  };

  if (platformManager.isQuest()) {
    return {
      ...baseOptions,
      xr: {
        referenceSpaceType: 'local-floor',
        sessionMode: 'immersive-vr',
        optionalFeatures: ['hand-tracking'],
        requiredFeatures: ['local-floor']
      }
    } as QuestInitOptions;
  }

  return baseOptions as BrowserInitOptions;
};

export function usePlatform() {
  const isInitialized = ref(false);
  const isLoading = ref(false);
  const error = ref<Error | null>(null);

  const initialize = async (options: { canvas: HTMLCanvasElement; scene?: Partial<SceneConfig> }) => {
    isLoading.value = true;
    error.value = null;

    try {
      const platformOptions = convertToPlatformOptions(options);
      await platformManager.initialize(platformOptions);
      isInitialized.value = true;
    } catch (err) {
      error.value = err instanceof Error ? err : new Error('Failed to initialize platform');
      console.error('Platform initialization failed:', err);
    } finally {
      isLoading.value = false;
    }
  };

  // Alias for backward compatibility
  const initializePlatform = initialize;

  const getState = <T extends PlatformState>(): T | null => {
    return platformManager.getState() as T | null;
  };

  const getBrowserState = (): BrowserState | null => {
    if (!platformManager.isBrowser()) return null;
    return getState<BrowserState>();
  };

  const getQuestState = (): QuestState | null => {
    if (!platformManager.isQuest()) return null;
    return getState<QuestState>();
  };

  const getPlatformInfo = () => {
    return {
      platform: platformManager.getPlatform(),
      capabilities: platformManager.getCapabilities(),
      isQuest: platformManager.isQuest(),
      isBrowser: platformManager.isBrowser(),
      hasXRSupport: platformManager.hasXRSupport()
    };
  };

  // XR Session Management
  const enableVR = async () => {
    if (!platformManager.hasXRSupport()) {
      throw new Error('WebXR not supported');
    }
    return platformManager.startXRSession('immersive-vr');
  };

  const enableAR = async () => {
    if (!platformManager.hasXRSupport()) {
      throw new Error('WebXR not supported');
    }
    const capabilities = platformManager.getCapabilities();
    if (!capabilities?.ar) {
      throw new Error('AR not supported on this device');
    }
    return platformManager.startXRSession('immersive-ar');
  };

  const disableXR = async () => {
    return platformManager.endXRSession();
  };

  const isXRActive = () => platformManager.isInXRSession();
  const isVRActive = () => platformManager.getXRSessionMode() === 'immersive-vr';
  const isARActive = () => platformManager.getXRSessionMode() === 'immersive-ar';

  // Controller and Hand Access
  const getControllerGrip = (handedness: XRHandedness): Group | null => {
    const state = getQuestState();
    return state?.controllers.get(handedness)?.grip ?? null;
  };

  const getControllerRay = (handedness: XRHandedness): Group | null => {
    const state = getQuestState();
    return state?.controllers.get(handedness)?.ray ?? null;
  };

  const getHand = (handedness: XRHandedness): XRHand | null => {
    const state = getQuestState();
    return state?.hands.get(handedness) ?? null;
  };

  // Haptic Feedback
  const vibrate = (handedness: XRHandedness, intensity = 1.0, duration = 100) => {
    const state = getQuestState();
    const controller = state?.controllers.get(handedness);
    if (controller?.gamepad?.hapticActuators?.[0]) {
      controller.gamepad.hapticActuators[0].pulse(intensity, duration);
    }
  };

  // Render and Resize Callbacks
  const onResize = (callback: (width: number, height: number) => void) => {
    return platformManager.onResize(callback);
  };

  const onBeforeRender = (callback: (renderer: WebGLRenderer, scene: Scene, camera: Camera) => void) => {
    return platformManager.onBeforeRender(callback);
  };

  // Lifecycle
  onMounted(() => {
    // Platform manager handles resize internally
  });

  onBeforeUnmount(() => {
    if (isInitialized.value) {
      platformManager.dispose();
    }
  });

  return {
    // State
    isInitialized,
    isLoading,
    error,

    // Core Methods
    initialize,
    initializePlatform,
    getState,
    getBrowserState,
    getQuestState,
    getPlatformInfo,

    // Platform Checks
    isQuest: platformManager.isQuest,
    isBrowser: platformManager.isBrowser,
    hasXRSupport: platformManager.hasXRSupport,

    // XR Methods
    enableVR,
    enableAR,
    disableXR,
    isXRActive,
    isVRActive,
    isARActive,

    // Controller Methods
    getControllerGrip,
    getControllerRay,
    getHand,
    vibrate,

    // Event Callbacks
    onResize,
    onBeforeRender
  };
}

----
types/three-ext.d.ts
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { Pass } from 'three/examples/jsm/postprocessing/Pass';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Extend existing types
declare module 'three' {
  interface ColorManagement {
    enabled: boolean;
    legacyMode?: boolean;
  }

  interface WebGLRendererParameters {
    antialias?: boolean;
    alpha?: boolean;
    depth?: boolean;
    stencil?: boolean;
    premultipliedAlpha?: boolean;
    preserveDrawingBuffer?: boolean;
    powerPreference?: string;
    failIfMajorPerformanceCaveat?: boolean;
    canvas?: HTMLCanvasElement;
    context?: WebGLRenderingContext | WebGL2RenderingContext;
    xr?: {
      enabled: boolean;
    };
  }

  interface WebGLRenderer {
    capabilities: {
      isWebGL2: boolean;
      maxTextures: number;
      maxVertexTextures: number;
      maxTextureSize: number;
      maxCubemapSize: number;
      maxAttributes: number;
      maxVertexUniforms: number;
      maxVaryings: number;
      maxFragmentUniforms: number;
      vertexTextures: boolean;
      floatFragmentTextures: boolean;
      floatVertexTextures: boolean;
    };
  }
}

// Extend OrbitControls type
declare module 'three/examples/jsm/controls/OrbitControls' {
  export interface OrbitControls {
    enabled: boolean;
    enableDamping: boolean;
    dampingFactor: number;
    enableZoom: boolean;
    enableRotate: boolean;
    enablePan: boolean;
    autoRotate: boolean;
    autoRotateSpeed: number;
    minDistance: number;
    maxDistance: number;
    minPolarAngle: number;
    maxPolarAngle: number;
    target: THREE.Vector3;
    update(): void;
    dispose(): void;
  }
}

// Custom type helpers
export type SafeWebGLRenderer = Omit<THREE.WebGLRenderer, 'readRenderTargetPixelsAsync' | 'initRenderTarget' | 'outputEncoding' | 'useLegacyLights'>;

export type SafePass = Omit<Pass, 'render'> & {
  render(
    renderer: SafeWebGLRenderer,
    writeBuffer: THREE.WebGLRenderTarget | null,
    readBuffer: THREE.WebGLRenderTarget,
    deltaTime?: number,
    maskActive?: boolean
  ): void;
};

export type SafeEffectComposer = Omit<EffectComposer, 'addPass'> & {
  addPass(pass: SafePass): void;
};

// Type assertion functions
export function asSafeRenderer(renderer: THREE.WebGLRenderer): SafeWebGLRenderer {
  return renderer as unknown as SafeWebGLRenderer;
}

export function asSafePass(pass: Pass): SafePass {
  return pass as unknown as SafePass;
}

export function asSafeEffectComposer(composer: EffectComposer): SafeEffectComposer {
  return composer as unknown as SafeEffectComposer;
}

// Camera type compatibility helper
export function asCompatibleCamera(camera: THREE.Camera): THREE.Camera {
  return camera as THREE.Camera & { matrixWorldInverse: THREE.Matrix4 };
}

----
types/global.d.ts
declare global {
  interface Window {
    __VUE_PROD_DEVTOOLS__?: boolean;
    __VUE_PROD_ERROR_HANDLER__?: (err: Error, vm: any, info: string) => void;
  }
}

export {};

----
types/vue-threejs.d.ts
declare module 'vue-threejs' {
  import { Plugin, Component } from 'vue'
  import { Scene, PerspectiveCamera, WebGLRenderer, Vector3, Color } from 'three'

  interface RendererProps {
    antialias?: boolean;
    xr?: boolean;
    size: {
      w: number;
      h: number;
    };
  }

  interface SceneProps {
    ref?: string;
  }

  interface GroupProps {
    ref?: string;
    position?: { x: number; y: number; z: number };
    rotation?: { x: number; y: number; z: number };
    scale?: { x: number; y: number; z: number };
  }

  interface CameraProps {
    position?: {
      x: number;
      y: number;
      z: number;
    };
    fov?: number;
    aspect?: number;
    near?: number;
    far?: number;
  }

  interface LightProps {
    intensity?: number;
    position?: {
      x: number;
      y: number;
      z: number;
    };
    color?: number | string;
    castShadow?: boolean;
  }

  interface HemisphereLightProps extends LightProps {
    skyColor?: number | string;
    groundColor?: number | string;
  }

  interface MeshProps {
    position?: { x: number; y: number; z: number };
    rotation?: { x: number; y: number; z: number };
    scale?: { x: number; y: number; z: number } | number;
  }

  interface GeometryProps {
    args?: any[];
  }

  interface MaterialProps {
    color?: number | string;
    metalness?: number;
    roughness?: number;
    opacity?: number;
    transparent?: boolean;
  }

  interface LineProps {
    points: Vector3[];
    color?: number | string;
    linewidth?: number;
    opacity?: number;
    transparent?: boolean;
  }

  interface HtmlProps {
    position: Vector3;
    occlude?: boolean;
    center?: boolean;
    sprite?: boolean;
  }

  export const Renderer: Component<RendererProps>
  export const Scene: Component<SceneProps>
  export const Group: Component<GroupProps>
  export const Camera: Component<CameraProps>
  export const AmbientLight: Component<LightProps>
  export const DirectionalLight: Component<LightProps>
  export const HemisphereLight: Component<HemisphereLightProps>
  export const Mesh: Component<MeshProps>
  export const SphereGeometry: Component<GeometryProps>
  export const MeshStandardMaterial: Component<MaterialProps>
  export const Line: Component<LineProps>
  export const Html: Component<HtmlProps>

  const VueThreejs: Plugin
  export default VueThreejs
}

----
types/stores.ts
import type { Node, Edge } from './core';
import type { 
  BaseMessage, 
  MaterialSettings, 
  PhysicsSettings, 
  BloomSettings, 
  FisheyeSettings 
} from './websocket';

// Re-export Node and Edge types
export type { Node, Edge };

// Binary message format types (no state storage needed)
export type BinaryMessageHeader = {
  timeStep: number;
  nodeCount: number;
};

export type BinaryPositionUpdate = {
  nodeId: string;
  position: [number, number, number];
};

// WebSocket Store State
export interface WebSocketState {
  isConnected: boolean;
  reconnectAttempts: number;
  messageQueue: (BaseMessage | ArrayBuffer)[];
  lastError: string | null;
  graphData: {
    nodes: Node[];
    edges: Edge[];
    metadata: Record<string, any>;
  } | null;
}

// Visualization Store State
export interface VisualizationState {
  nodes: Node[];
  edges: Edge[];
  metadata: Record<string, any>;
  selectedNode: Node | null;
  hoveredNode: Node | null;
  cameraPosition: [number, number, number];
  cameraTarget: [number, number, number];
  isLoading: boolean;
  error: string | null;
  renderSettings: {
    nodeSize: number;
    nodeColor: string;
    edgeWidth: number;
    edgeColor: string;
    highlightColor: string;
    opacity: number;
    bloom: {
      enabled: boolean;
      strength: number;
      radius: number;
      threshold: number;
    };
    fisheye: {
      enabled: boolean;
      strength: number;
      focusPoint: [number, number, number];
      radius: number;
    };
  };
  physicsSettings: {
    enabled: boolean;
    gravity: number;
    springLength: number;
    springStrength: number;
    repulsion: number;
    damping: number;
    timeStep: number;
  };
}

// Settings Store State
export interface SettingsState {
  visualization: MaterialSettings;
  physics: PhysicsSettings;
  bloom: BloomSettings;
  fisheye: FisheyeSettings;
  audio: {
    enabled: boolean;
    volume: number;
    useOpenAI: boolean;
    ttsEnabled: boolean;
  };
  performance: {
    gpuAcceleration: boolean;
    maxFPS: number;
    quality: 'low' | 'medium' | 'high';
    autoAdjust: boolean;
  };
  debug: {
    showStats: boolean;
    logLevel: 'error' | 'warn' | 'info' | 'debug';
    showGrid: boolean;
    showAxes: boolean;
  };
}

// Store Actions
export interface WebSocketActions {
  connect(): Promise<void>;
  disconnect(): void;
  send(message: BaseMessage | ArrayBuffer): void;
  handleMessage(message: BaseMessage): void;
  handleBinaryMessage(data: ArrayBuffer): void;
}

export interface VisualizationActions {
  updateNodePositions(updates: Array<[string, [number, number, number]]>): void;
  setGraphData(nodes: Node[], edges: Edge[], metadata: Record<string, any>): void;
  selectNode(node: Node | null): void;
  hoverNode(node: Node | null): void;
  updateCamera(position: [number, number, number], target: [number, number, number]): void;
  updateRenderSettings(settings: Partial<VisualizationState['renderSettings']>): void;
  updatePhysicsSettings(settings: Partial<VisualizationState['physicsSettings']>): void;
  startAnimation(): void;
  stopAnimation(): void;
  updatePerformanceMetrics(): void;
}

export interface SettingsActions {
  updateVisualization(settings: Partial<MaterialSettings>): void;
  updatePhysics(settings: Partial<PhysicsSettings>): void;
  updateBloom(settings: Partial<BloomSettings>): void;
  updateFisheye(settings: Partial<FisheyeSettings>): void;
  updateAudio(settings: Partial<SettingsState['audio']>): void;
  updatePerformance(settings: Partial<SettingsState['performance']>): void;
  updateDebug(settings: Partial<SettingsState['debug']>): void;
  resetToDefaults(): void;
  applyServerSettings(settings: {
    visualization?: Partial<MaterialSettings>;
    physics?: Partial<PhysicsSettings>;
    bloom?: Partial<BloomSettings>;
    fisheye?: Partial<FisheyeSettings>;
  }): void;
}

// Store Getters
export interface WebSocketGetters {
  isConnected: boolean;
  hasError: boolean;
  queueLength: number;
  graphData: WebSocketState['graphData'];
}

export interface VisualizationGetters {
  selectedNode: Node | null;
  hoveredNode: Node | null;
  nodeCount: number;
  edgeCount: number;
  fps: number;
  isPerformant: boolean;
}

export interface SettingsGetters {
  isGPUAccelerated: boolean;
  currentQuality: SettingsState['performance']['quality'];
  debugEnabled: boolean;
  audioEnabled: boolean;
}

----
types/core.ts
import type { WebGLRenderer, Scene, PerspectiveCamera, Object3D, Vector3 } from 'three';

/**
 * Core visualization state interface
 */
export interface CoreState {
  renderer: WebGLRenderer | null;
  camera: PerspectiveCamera | null;
  scene: Scene | null;
  canvas: HTMLCanvasElement | null;
  isInitialized: boolean;
  isXRSupported: boolean;
  isWebGL2: boolean;
  isGPUMode: boolean;
  fps: number;
  lastFrameTime: number;
}

/**
 * Platform-specific core states
 */
export interface BrowserCoreState extends CoreState {
  type: 'browser';
}

export interface XRCoreState extends CoreState {
  type: 'xr';
  xrSession: any; // XRSession type from WebXR
}

/**
 * Transform interface for object positioning
 */
export interface Transform {
  position: [number, number, number];
  rotation: [number, number, number];
  scale: [number, number, number];
}

/**
 * Viewport configuration
 */
export interface Viewport {
  width: number;
  height: number;
  pixelRatio: number;
}

/**
 * Scene configuration
 */
export interface SceneConfig {
  antialias: boolean;
  alpha: boolean;
  preserveDrawingBuffer: boolean;
  powerPreference: 'high-performance' | 'low-power' | 'default';
}

/**
 * Performance configuration
 */
export interface PerformanceConfig {
  targetFPS: number;
  maxDrawCalls: number;
  enableStats: boolean;
}

/**
 * Platform capabilities
 */
export interface PlatformCapabilities {
  webgl2: boolean;
  xr: boolean;
  ar: boolean;  // Added AR support flag
  vr: boolean;  // Added VR support flag
  maxTextureSize: number;
  maxDrawCalls: number;
  gpuTier: number;
}

/**
 * Node interfaces
 */
export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  velocity?: [number, number, number];
  size?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  weight?: number;  // Added to match Rust struct
  group?: string;   // Added to match Rust struct
}

export interface GraphNode extends Node {
  edges: GraphEdge[];  // Changed from Edge[] to GraphEdge[]
  weight: number;      // Required in GraphNode
  group?: string;
}

/**
 * Edge interfaces
 */
export interface Edge {
  id: string;
  source: string;
  target: string;
  weight?: number;
  width?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  directed?: boolean;  // Added to match Rust struct
}

export interface GraphEdge extends Edge {
  sourceNode: GraphNode;
  targetNode: GraphNode;
  directed: boolean;   // Required in GraphEdge
}

/**
 * Graph data structure
 */
export interface GraphData {
  nodes: GraphNode[];
  edges: GraphEdge[];
  metadata: Record<string, any>;
}

/**
 * Fisheye effect settings
 */
export interface FisheyeSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  focus_x: number;
  focus_y: number;
  focus_z: number;

}

/**
 * Material settings
 */
export interface MaterialSettings {
  nodeSize: number;
  nodeColor: string;
  edgeWidth: number;
  edgeColor: string;
  highlightColor: string;
  opacity: number;
  metalness: number;
  roughness: number;
}

/**
 * Physics simulation settings
 */
export interface PhysicsSettings {
  enabled: boolean;
  gravity: number;
  springLength: number;
  springStrength: number;
  repulsion: number;
  damping: number;
  timeStep: number;
}

/**
 * Bloom effect settings
 */
export interface BloomSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
}

/**
 * Complete visualization settings
 */
export interface VisualizationSettings {
  material: MaterialSettings;
  physics: PhysicsSettings;
  bloom: BloomSettings;
  fisheye: FisheyeSettings;
}

/**
 * Performance metrics
 */
export interface PerformanceMetrics {
  fps: number;
  drawCalls: number;
  triangles: number;
  points: number;
}

/**
 * Camera state
 */
export interface CameraState {
  position: [number, number, number];
  target: [number, number, number];
  zoom: number;
}

/**
 * Renderer capabilities
 */
export interface RendererCapabilities {
  isWebGL2: boolean;
  maxTextures: number;
  maxAttributes: number;
  maxVertices: number;
  precision: string;
}

/**
 * Initialization options
 */
export interface InitializationOptions {
  canvas: HTMLCanvasElement;
  scene?: Partial<SceneConfig>;
  performance?: Partial<PerformanceConfig>;
}

/**
 * Object3D with additional properties
 */
export interface EnhancedObject3D extends Object3D {
  userData: {
    id?: string;
    type?: string;
    originalPosition?: Vector3;
    velocity?: Vector3;
    [key: string]: any;
  };
}

// Rest of the file remains the same...

----
types/components.ts
// Control Panel Types
export interface ControlGroup {
  label: string;
  name: string;
  controls: ControlItem[];
  collapsed: boolean;
}

export interface ControlItem {
  name: string;
  label: string;
  value: number | string | boolean;
  type: 'range' | 'color' | 'checkbox' | 'select';
  min?: number;
  max?: number;
  step?: number;
  options?: string[];
}

// Visualization Config Types
export interface VisualizationConfig {
  // Node appearance
  node_color: string;
  node_color_new: string;
  node_color_recent: string;
  node_color_medium: string;
  node_color_old: string;
  node_color_core: string;
  node_color_secondary: string;
  min_node_size: number;
  max_node_size: number;

  // Edge appearance
  edge_color: string;
  edge_opacity: number;
  edge_min_width: number;
  edge_max_width: number;

  // Material properties
  material: {
    node_material_metalness: number;
    node_material_roughness: number;
    node_material_clearcoat: number;
    node_material_clearcoat_roughness: number;
    node_material_opacity: number;
    node_emissive_min_intensity: number;
    node_emissive_max_intensity: number;
  };

  // Physics simulation
  physics: {
    force_directed_iterations: number;
    force_directed_spring: number;
    force_directed_repulsion: number;
    force_directed_attraction: number;
    force_directed_damping: number;
  };

  // Label settings
  label_font_size: number;
  label_font_family: string;
  label_padding: number;
  label_vertical_offset: number;
  label_close_offset: number;
  label_background_color: string;
  label_text_color: string;
  label_info_text_color: string;
  label_xr_font_size: number;

  // Environment settings
  fog_density: number;
  hologram_color: string;
  hologram_scale: number;
  hologram_opacity: number;
}

// Effect Settings
export interface BloomConfig {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
  node_bloom_strength: number;
  node_bloom_radius: number;
  node_bloom_threshold: number;
  edge_bloom_strength: number;
  edge_bloom_radius: number;
  edge_bloom_threshold: number;
  environment_bloom_strength: number;
  environment_bloom_radius: number;
  environment_bloom_threshold: number;
}

export interface FisheyeConfig {
  enabled: boolean;
  strength: number;
  radius: number;
  focus_x: number;
  focus_y: number;
  focus_z: number;
}

export interface ControlPanelProps {
  visualizationConfig: VisualizationConfig;
  bloomConfig: BloomConfig;
  fisheyeConfig: FisheyeConfig;
}

export interface ControlPanelEmits {
  (event: 'update:visualizationConfig', value: Partial<VisualizationConfig>): void;
  (event: 'update:bloomConfig', value: Partial<BloomConfig>): void;
  (event: 'update:fisheyeConfig', value: Partial<FisheyeConfig>): void;
  (event: 'saveSettings'): void;
}

// Default Values
export const DEFAULT_VISUALIZATION_CONFIG: VisualizationConfig = {
  // Node appearance
  node_color: '#FFA500',
  node_color_new: '#FFD700',
  node_color_recent: '#FFA500',
  node_color_medium: '#DAA520',
  node_color_old: '#CD853F',
  node_color_core: '#FFB90F',
  node_color_secondary: '#FFC125',
  min_node_size: 0.15,
  max_node_size: 0.4,

  // Edge appearance
  edge_color: '#FFD700',
  edge_opacity: 0.4,
  edge_min_width: 1.5,
  edge_max_width: 6.0,

  // Material properties
  material: {
    node_material_metalness: 0.7,
    node_material_roughness: 0.2,
    node_material_clearcoat: 0.8,
    node_material_clearcoat_roughness: 0.1,
    node_material_opacity: 0.95,
    node_emissive_min_intensity: 0.4,
    node_emissive_max_intensity: 1.0
  },

  // Physics simulation
  physics: {
    force_directed_iterations: 300,
    force_directed_spring: 0.015,
    force_directed_repulsion: 1200.0,
    force_directed_attraction: 0.012,
    force_directed_damping: 0.85
  },

  // Label settings
  label_font_size: 42,
  label_font_family: 'Arial',
  label_padding: 24,
  label_vertical_offset: 2.5,
  label_close_offset: 0.25,
  label_background_color: 'rgba(0, 0, 0, 0.85)',
  label_text_color: 'white',
  label_info_text_color: 'lightgray',
  label_xr_font_size: 28,

  // Environment settings
  fog_density: 0.001,
  hologram_color: '#FFC125',
  hologram_scale: 6.0,
  hologram_opacity: 0.15
};

export const DEFAULT_BLOOM_CONFIG: BloomConfig = {
  enabled: true,
  strength: 1.5,
  radius: 0.4,
  threshold: 0.2,
  node_bloom_strength: 1.5,
  node_bloom_radius: 0.4,
  node_bloom_threshold: 0.2,
  edge_bloom_strength: 1.2,
  edge_bloom_radius: 0.4,
  edge_bloom_threshold: 0.2,
  environment_bloom_strength: 1.0,
  environment_bloom_radius: 0.4,
  environment_bloom_threshold: 0.2
};

export const DEFAULT_FISHEYE_CONFIG: FisheyeConfig = {
  enabled: false,
  strength: 0.5,
  radius: 100.0,
  focus_x: 0.0,
  focus_y: 0.0,
  focus_z: 0.0
};

----
types/visualization.ts
import type { Scene, PerspectiveCamera, WebGLRenderer, Vector3, Quaternion } from 'three';
import type { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import type { VisualizationConfig, BloomConfig, FisheyeConfig } from './components';

export interface GraphData {
  nodes: Node[];
  edges: Edge[];
  metadata?: Record<string, any>;
}

export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  color?: string;
  size?: number;
  type?: string;
  [key: string]: any;
}

export interface Edge {
  source: string;
  target: string;
  weight?: number;
  color?: string;
  width?: number;
  [key: string]: any;
}

export interface XRSessionManager {
  session: XRSession | null;
  referenceSpace: XRReferenceSpace | null;
  init(): Promise<void>;
  update(): void;
  dispose(): void;
}

export interface NodeManagerOptions {
  minNodeSize: number;
  maxNodeSize: number;
  nodeColor: string;
  edgeColor: string;
  edgeOpacity: number;
  labelFontSize: number;
  labelFontFamily: string;
  materialMetalness: number;
  materialRoughness: number;
  materialClearcoat: number;
  materialOpacity: number;
}

export interface VisualizationSettings {
  visualization: VisualizationConfig;
  bloom: BloomConfig;
  fisheye: FisheyeConfig;
}

export interface WebXRVisualizationState {
  initialized: boolean;
  pendingInitialization: boolean;
  scene: Scene | null;
  camera: PerspectiveCamera | null;
  renderer: WebGLRenderer | null;
  controls: OrbitControls | null;
  xrSessionManager: XRSessionManager | null;
  canvas: HTMLCanvasElement | null;
}

export interface CameraState {
  position: Vector3;
  rotation: Quaternion;
  target: Vector3;
}

export interface RenderState {
  fps: number;
  lastFrameTime: number;
  frameCount: number;
}

// Constants
export const VISUALIZATION_CONSTANTS = {
  TRANSLATION_SPEED: 0.01,
  ROTATION_SPEED: 0.01,
  VR_MOVEMENT_SPEED: 0.05,
  MIN_CAMERA_DISTANCE: 50,
  MAX_CAMERA_DISTANCE: 500,
  DEFAULT_FOV: 50,
  NEAR_PLANE: 0.1,
  FAR_PLANE: 2000,
  DEFAULT_CAMERA_POSITION: [0, 75, 200] as [number, number, number],
  DEFAULT_CAMERA_TARGET: [0, 0, 0] as [number, number, number]
} as const;

// WebGL Context Attributes
export const WEBGL_CONTEXT_ATTRIBUTES: WebGLContextAttributes = {
  alpha: false,
  antialias: true,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  preserveDrawingBuffer: true,
  xrCompatible: true
} as const;

// Renderer Settings
export const RENDERER_SETTINGS = {
  clearColor: 0x000000,
  clearAlpha: 1,
  pixelRatio: Math.min(window.devicePixelRatio, 2),
  toneMapping: 'ACESFilmic',
  toneMappingExposure: 1.5,
  outputColorSpace: 'srgb'
} as const;

// Light Settings
export const LIGHT_SETTINGS = {
  ambient: {
    color: 0xffffff,
    intensity: 1.5
  },
  directional: {
    color: 0xffffff,
    intensity: 2.0,
    position: [10, 20, 10] as [number, number, number]
  },
  hemisphere: {
    skyColor: 0xffffff,
    groundColor: 0x444444,
    intensity: 1.5
  },
  points: [
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [100, 100, 100] as [number, number, number]
    },
    {
      color: 0xffffff,
      intensity: 1.0,
      distance: 300,
      position: [-100, -100, -100] as [number, number, number]
    }
  ]
} as const;

// Controls Settings
export const CONTROLS_SETTINGS = {
  enableDamping: true,
  dampingFactor: 0.1,
  rotateSpeed: 0.4,
  panSpeed: 0.6,
  zoomSpeed: 1.2,
  minDistance: 50,
  maxDistance: 500
} as const;

----
types/shims-vue.d.ts
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

declare module 'vue-threejs' {
  import type { Plugin } from 'vue'
  const VueThreejs: Plugin
  export default VueThreejs
}

declare module 'three/*' {
  import * as THREE from 'three'
  export * from 'three'
}

----
types/websocket.ts
// Add ForceNode interface for force simulation
export interface ForceNode {
    id: string;
    x?: number;
    y?: number;
    z?: number;
    vx?: number;
    vy?: number;
    vz?: number;
    position?: [number, number, number];
    velocity?: [number, number, number];
    fx?: number | null;
    fy?: number | null;
    fz?: number | null;
}

// Message Types (matching server's ServerMessage enum)
export type MessageType = 
  | 'graphUpdate'
  | 'error'
  | 'positionUpdateComplete'
  | 'settingsUpdated'
  | 'simulationModeSet'
  | 'fisheyeSettingsUpdated'
  | 'initialData'
  | 'gpuState'
  | 'layoutState'
  | 'audioData'
  | 'updateSettings'
  | 'openaiResponse'
  | 'ragflowResponse'
  | 'completion'
  | 'ping'
  | 'pong'
  | 'updatePositions'
  | 'binaryPositionUpdate';  // Added for binary position updates

// Binary Protocol Types
export interface BinaryMessage {
  type: 'binaryPositionUpdate';
  data: ArrayBuffer;        // Raw binary data in format:
                           // [x,y,z,vx,vy,vz](24) per node
                           // Node index in array matches index in original graph data
  positions: NodePosition[];  // Processed position data
  nodeCount: number;        // Number of nodes in the update
}

export interface NodePosition {
  x: number;
  y: number;
  z: number;
  vx: number;
  vy: number;
  vz: number;
}

// Position update message for client-side force simulation
export interface UpdatePositionsMessage extends BaseMessage {
  type: 'updatePositions';
  nodes: Array<{
    id: string;
    position: [number, number, number];
  }>;
}

// Position update complete message from server
export interface PositionUpdateCompleteMessage extends BaseMessage {
  type: 'positionUpdateComplete';
  status: string;
}

// Graph Data (establishes node order for binary updates)
export interface GraphData {
  nodes: Node[];  // Order of nodes here determines binary update indices
  edges: Edge[];
  metadata?: Record<string, any>;
}

export interface Node {
  id: string;
  label?: string;
  position?: [number, number, number];
  velocity?: [number, number, number];
  size?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  weight?: number;
  group?: string;
}

export interface Edge {
  id: string;  // Added to match core Edge type
  source: string;
  target: string;
  weight?: number;
  width?: number;
  color?: string;
  type?: string;
  metadata?: Record<string, any>;
  userData?: Record<string, any>;
  directed?: boolean;
}

// Graph Update Message
export interface GraphUpdateMessage extends BaseMessage {
  type: 'graphUpdate';
  graphData: GraphData;
}

// Initial Data Message
export interface InitialDataMessage extends BaseMessage {
  type: 'initialData';
  graphData: GraphData;
  settings: {
    material?: MaterialSettings;
    physics?: PhysicsSettings;
    bloom?: BloomSettings;
    fisheye?: FisheyeSettings;
  };
}

// Base Message Interface
export interface BaseMessage {
  type: MessageType;
  [key: string]: any;
}

// Settings Interfaces
export interface FisheyeSettings {
  enabled: boolean;
  strength: number;
  focusPoint: [number, number, number];
  radius: number;
}

export interface MaterialSettings {
  nodeSize: number;
  nodeColor: string;
  edgeWidth: number;
  edgeColor: string;
  highlightColor: string;
  opacity: number;
}

export interface PhysicsSettings {
  gravity: number;
  springLength: number;
  springStrength: number;
  repulsion: number;
  damping: number;
  timeStep: number;
}

export interface BloomSettings {
  enabled: boolean;
  strength: number;
  radius: number;
  threshold: number;
}

// Message Type Interfaces (matching server's ServerMessage variants)
export interface FisheyeUpdateMessage extends BaseMessage {
  type: 'fisheyeSettingsUpdated';
  enabled: boolean;
  strength: number;
  focusPoint: [number, number, number];
  radius: number;
}

export interface ErrorMessage extends BaseMessage {
  type: 'error';
  message: string;
  details?: string;
  code?: string;
}

export interface AudioMessage extends BaseMessage {
  type: 'audioData';
  audioData: Blob;
}

export interface RagflowResponse extends BaseMessage {
  type: 'ragflowResponse';
  answer: string;
  audio?: string;
}

export interface SimulationModeMessage extends BaseMessage {
  type: 'simulationModeSet';
  mode: string;
  gpuEnabled: boolean;
}

export interface SettingsUpdateMessage extends BaseMessage {
  type: 'updateSettings';
  settings: {
    material?: Partial<MaterialSettings>;
    physics?: Partial<PhysicsSettings>;
    bloom?: Partial<BloomSettings>;
    fisheye?: Partial<FisheyeSettings>;
  };
}

export interface SettingsUpdatedMessage extends BaseMessage {
  type: 'settingsUpdated';
  settings: {
    material?: MaterialSettings;
    physics?: PhysicsSettings;
    bloom?: BloomSettings;
    fisheye?: FisheyeSettings;
  };
}

// Heartbeat Messages
export interface PingMessage extends BaseMessage {
  type: 'ping';
}

export interface PongMessage extends BaseMessage {
  type: 'pong';
}

// WebSocket Configuration
export interface WebSocketConfig {
  messageRateLimit: number;
  messageTimeWindow: number;
  maxMessageSize: number;
  maxAudioSize: number;
  maxQueueSize: number;
  maxRetries: number;
  retryDelay: number;
}

// Event System Types
export type WebSocketEventMap = {
  open: void;
  close: CloseEvent;
  error: ErrorMessage;
  message: BaseMessage;
  graphUpdate: GraphUpdateMessage;
  initialData: InitialDataMessage;  // Add initialData event type
  serverSettings: Record<string, any>;
  ragflowAnswer: string;
  openaiResponse: string;
  simulationModeSet: string;
  completion: string;
  positionUpdateComplete: string;
  gpuPositions: BinaryMessage;
  maxReconnectAttemptsReached: void;
};

export type WebSocketEventCallback<T> = (data: T) => void;

----
types/platform/quest.ts
import type { XRCoreState, Transform, Viewport, SceneConfig, PerformanceConfig } from '../core';
import type { Group, Object3D } from 'three';

// Base XR interfaces
export interface XRRigidTransform {
    position: { x: number; y: number; z: number };
    orientation: { x: number; y: number; z: number; w: number };
    matrix: Float32Array;
}

export interface XRSpace extends EventTarget {
    // Base XR space interface
}

export interface XRReferenceSpace extends XRSpace {
    getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
}

export interface XRRay {
    origin: DOMPointReadOnly;
    direction: DOMPointReadOnly;
    matrix: Float32Array;
}

export interface XRHitTestSource {
    cancel(): void;
}

export interface XRHitTestOptionsInit {
    space: XRSpace;
    offsetRay?: XRRay;
    entityTypes?: string[];
}

// Use the global XRWebGLLayer type
export type XRWebGLLayer = globalThis.XRWebGLLayer;

// Extend XRSession type with AR-specific methods
export interface XRSession extends globalThis.XRSession {
    requestHitTestSource?(options: XRHitTestOptionsInit): Promise<XRHitTestSource> | undefined;
}

export interface XRRenderStateInit {
    baseLayer?: XRWebGLLayer;
    depthFar?: number;
    depthNear?: number;
    inlineVerticalFieldOfView?: number;
}

export interface XRView {
    eye: 'left' | 'right' | 'none';
    projectionMatrix: Float32Array;
    transform: XRRigidTransform;
}

export interface XRViewport {
    x: number;
    y: number;
    width: number;
    height: number;
}

export type XRFrameRequestCallback = (time: number, frame: XRFrame) => void;
export type XRReferenceSpaceType = 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
export type XRSessionMode = 'inline' | 'immersive-vr' | 'immersive-ar';
export type XRHandedness = 'none' | 'left' | 'right';
export type XRTargetRayMode = 'gaze' | 'tracked-pointer' | 'screen';

export interface XRControllerEvent extends Event {
    data?: any;
    target: EventTarget & {
        handedness: XRHandedness;
        targetRayMode: XRTargetRayMode;
    };
}

export interface XRController {
    grip: Group;
    ray: Group;
    hand?: XRHand;
    handedness: XRHandedness;
    targetRayMode: XRTargetRayMode;
    gamepad?: Gamepad;
    controller: Object3D;
    model?: Object3D;
    visible: boolean;
    connected: boolean;
}

export interface XRHand {
    joints: Map<XRHandJoint, XRJointSpace>;
    hand: Object3D;
    model?: Object3D;
    visible: boolean;
    connected: boolean;
}

export type XRHandJoint = 
    | 'wrist'
    | 'thumb-metacarpal'
    | 'thumb-phalanx-proximal'
    | 'thumb-phalanx-distal'
    | 'thumb-tip'
    | 'index-finger-metacarpal'
    | 'index-finger-phalanx-proximal'
    | 'index-finger-phalanx-intermediate'
    | 'index-finger-phalanx-distal'
    | 'index-finger-tip';

export interface XRJointSpace extends XRSpace {
    jointRadius: number;
}

export interface QuestInitOptions {
    canvas: HTMLCanvasElement;
    scene?: SceneConfig;
    performance?: PerformanceConfig;
    xr?: {
        referenceSpaceType?: XRReferenceSpaceType;
        sessionMode?: XRSessionMode;
        optionalFeatures?: string[];
        requiredFeatures?: string[];
    };
}

export interface QuestState extends XRCoreState {
    xrSession: XRSession | null;
    xrSpace: XRReferenceSpace | null;
    xrLayer: XRWebGLLayer | null;
    hitTestSource: XRHitTestSource | null;
    controllers: Map<XRHandedness, XRController>;
    hands: Map<XRHandedness, XRHand>;
    viewport: Viewport;
    transform: Transform;
    config: {
        scene: SceneConfig;
        performance: PerformanceConfig;
        xr: {
            referenceSpaceType: XRReferenceSpaceType;
            sessionMode: XRSessionMode;
            optionalFeatures: string[];
            requiredFeatures: string[];
        };
    };
}

export interface QuestPlatform {
    state: QuestState;
    initialize(options: QuestInitOptions): Promise<void>;
    dispose(): void;
    render(): void;
    resize(width: number, height: number): void;
    setPixelRatio(ratio: number): void;
    getViewport(): Viewport;
    setTransform(transform: Partial<Transform>): void;
    getTransform(): Transform;
    enableVR(): Promise<void>;
    disableVR(): void;
    isVRSupported(): boolean;
    isVRActive(): boolean;
    getControllerGrip(handedness: XRHandedness): Group | null;
    getControllerRay(handedness: XRHandedness): Group | null;
    getHand(handedness: XRHandedness): XRHand | null;
    vibrate(handedness: XRHandedness, intensity?: number, duration?: number): void;
}

----
types/platform/browser.ts
import type { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import type { BrowserCoreState, Transform, Viewport, SceneConfig, PerformanceConfig } from '../core';
import type { Vector2 } from 'three';

export interface BrowserInitOptions {
  canvas: HTMLCanvasElement;
  scene?: SceneConfig;
  performance?: PerformanceConfig;
  controls?: {
    enableDamping?: boolean;
    dampingFactor?: number;
    enableZoom?: boolean;
    enableRotate?: boolean;
    enablePan?: boolean;
    autoRotate?: boolean;
    autoRotateSpeed?: number;
    minDistance?: number;
    maxDistance?: number;
    minPolarAngle?: number;
    maxPolarAngle?: number;
  };
}

export interface BrowserState extends BrowserCoreState {
  controls: OrbitControls | null;
  viewport: Viewport;
  transform: Transform;
  mousePosition: Vector2;
  touchActive: boolean;
  pointerLocked: boolean;
  config: {
    scene: SceneConfig;
    performance: PerformanceConfig;
  };
}

export interface BrowserPlatform {
  state: BrowserState;
  initialize(options: BrowserInitOptions): Promise<void>;
  dispose(): void;
  render(): void;
  resize(width: number, height: number): void;
  setPixelRatio(ratio: number): void;
  getViewport(): Viewport;
  setTransform(transform: Partial<Transform>): void;
  getTransform(): Transform;
  enableVR(): Promise<void>;
  disableVR(): void;
  isVRSupported(): boolean;
  isVRActive(): boolean;
}

----
services/fisheyeManager.ts
// TODO: Future client-side fisheye implementation
// This manager will handle fisheye visualization settings and shader uniforms,
// keeping the effect purely in the visualization layer.
//
// Implementation notes:
// - Fisheye should be a visualization-only effect
// - No server communication needed for fisheye updates
// - Settings affect only the rendering, not the data
// - Can be enabled/disabled without impacting graph layout
//
// Example implementation (to be integrated later):
/*
import { ref, watch } from 'vue';

export interface FisheyeSettings {
    enabled: boolean;
    strength: number;
    radius: number;
    focusPoint: [number, number, number];
}

export class FisheyeManager {
    private enabled = ref(false);
    private strength = ref(0.5);
    private radius = ref(100.0);
    private focusPoint = ref([0, 0, 0]);

    // Shader uniforms that will be updated
    private uniforms = {
        fisheyeEnabled: { value: false },
        fisheyeStrength: { value: 0.5 },
        fisheyeRadius: { value: 100.0 },
        fisheyeFocusPoint: { value: [0, 0, 0] }
    };

    constructor() {
        // Watch for changes and update uniforms
        watch(this.enabled, (value) => {
            this.uniforms.fisheyeEnabled.value = value;
        });

        watch(this.strength, (value) => {
            this.uniforms.fisheyeStrength.value = value;
        });

        watch(this.radius, (value) => {
            this.uniforms.fisheyeRadius.value = value;
        });

        watch(this.focusPoint, (value) => {
            this.uniforms.fisheyeFocusPoint.value = value;
        });
    }

    // Update settings locally (no server communication needed)
    updateSettings(settings: FisheyeSettings) {
        this.enabled.value = settings.enabled;
        this.strength.value = settings.strength;
        this.radius.value = settings.radius;
        this.focusPoint.value = settings.focusPoint;
    }

    // Get uniforms for shader
    getUniforms() {
        return this.uniforms;
    }
}

// Singleton instance (commented out until implementation)
// export const fisheyeManager = new FisheyeManager();
*/

----
services/websocketService.ts
import type {
  WebSocketConfig,
  WebSocketEventMap,
  WebSocketEventCallback,
  BaseMessage,
  ErrorMessage,
  BinaryMessage,
  GraphUpdateMessage,
  NodePosition,
  InitialDataMessage,
  Node,
  ForceNode
} from '../types/websocket';

import { processPositionUpdate } from '../utils/gpuUtils';
import { DebugLogger } from '../utils/validation';

import {
  DEFAULT_RECONNECT_ATTEMPTS,
  DEFAULT_RECONNECT_DELAY,
  DEFAULT_MESSAGE_RATE_LIMIT,
  DEFAULT_MESSAGE_TIME_WINDOW,
  DEFAULT_MAX_MESSAGE_SIZE,
  DEFAULT_MAX_AUDIO_SIZE,
  DEFAULT_MAX_QUEUE_SIZE,
  HEARTBEAT_INTERVAL,
  HEARTBEAT_TIMEOUT,
  CONNECTION_TIMEOUT,
  UPDATE_THROTTLE_MS,
  POSITION_SCALE,
  VELOCITY_SCALE,
  MAX_VALID_POSITION,
  MIN_VALID_POSITION,
  MAX_VALID_VELOCITY,
  MIN_VALID_VELOCITY,
  POSITION_CHANGE_THRESHOLD,
  BINARY_UPDATE_NODE_SIZE,
  ERROR_CODES
} from '../constants/websocket';

const DEFAULT_CONFIG: WebSocketConfig = {
  messageRateLimit: DEFAULT_MESSAGE_RATE_LIMIT,
  messageTimeWindow: DEFAULT_MESSAGE_TIME_WINDOW,
  maxMessageSize: DEFAULT_MAX_MESSAGE_SIZE,
  maxAudioSize: DEFAULT_MAX_AUDIO_SIZE,
  maxQueueSize: DEFAULT_MAX_QUEUE_SIZE,
  maxRetries: DEFAULT_RECONNECT_ATTEMPTS,
  retryDelay: DEFAULT_RECONNECT_DELAY
};

const logger = DebugLogger.getInstance();

// Validation helpers
function isValidPosition(value: number): boolean {
  return !isNaN(value) && isFinite(value) && 
         value >= MIN_VALID_POSITION && value <= MAX_VALID_POSITION;
}

function isValidVelocity(value: number): boolean {
  return !isNaN(value) && isFinite(value) && 
         value >= MIN_VALID_VELOCITY && value <= MAX_VALID_VELOCITY;
}

function hasSignificantChange(oldValue: number, newValue: number): boolean {
  return Math.abs(oldValue - newValue) > POSITION_CHANGE_THRESHOLD;
}

function clampPosition(value: number): number {
  if (!isFinite(value) || isNaN(value)) return 0;
  return Math.max(MIN_VALID_POSITION, Math.min(MAX_VALID_POSITION, value));
}

function clampVelocity(value: number): number {
  if (!isFinite(value) || isNaN(value)) return 0;
  return Math.max(MIN_VALID_VELOCITY, Math.min(MAX_VALID_VELOCITY, value));
}

// Rate limiting helper
class UpdateThrottler {
  private lastUpdateTime: number = 0;
  private pendingUpdate: ArrayBuffer | null = null;
  private timeoutId: number | null = null;

  constructor(private minInterval: number = UPDATE_THROTTLE_MS) {}

  addUpdate(data: ArrayBuffer): void {
    this.pendingUpdate = data;
    
    if (this.timeoutId === null) {
      const now = performance.now();
      const timeSinceLastUpdate = now - this.lastUpdateTime;
      
      if (timeSinceLastUpdate >= this.minInterval) {
        this.processPendingUpdate();
      } else {
        this.timeoutId = window.setTimeout(
          () => this.processPendingUpdate(),
          this.minInterval - timeSinceLastUpdate
        );
      }
    }
  }

  private processPendingUpdate(): void {
    if (this.pendingUpdate && this.onUpdate) {
      this.onUpdate(this.pendingUpdate);
      this.lastUpdateTime = performance.now();
    }
    this.pendingUpdate = null;
    this.timeoutId = null;
  }

  onUpdate: ((data: ArrayBuffer) => void) | null = null;
}

export default class WebSocketService {
    private ws: WebSocket | null = null;
    private config: WebSocketConfig;
    private messageQueue: any[] = [];
    private messageCount = 0;
    private lastMessageTime = 0;
    private reconnectAttempts = 0;
    private reconnectTimeout: number | null = null;
    private heartbeatInterval: number | null = null;
    private lastPongTime: number = Date.now();
    private eventListeners: Map<keyof WebSocketEventMap, Set<WebSocketEventCallback<any>>> = new Map();
    private url: string;
    private nodeIdToIndex: Map<string, number> = new Map();
    private indexToNodeId: string[] = [];
    private isReconnecting: boolean = false;
    private forceClose: boolean = false;
    private pendingBinaryUpdate: boolean = false;
    private updateThrottler: UpdateThrottler;

    constructor(config: Partial<WebSocketConfig> = {}) {
        this.config = { ...DEFAULT_CONFIG, ...config };
        const hostname = window.location.hostname;
        this.url = `wss://${hostname}/ws`;
        
        this.updateThrottler = new UpdateThrottler();
        this.updateThrottler.onUpdate = (data: ArrayBuffer) => {
            if (this.ws?.readyState === WebSocket.OPEN) {
                this.ws.send(data);
            }
        };
    }

    public async connect(): Promise<void> {
        if (this.ws?.readyState === WebSocket.OPEN) return;

        return new Promise((resolve, reject) => {
            try {
                this.ws = new WebSocket(this.url);
                this.ws.binaryType = 'arraybuffer';

                const connectionTimeout = setTimeout(() => {
                    if (this.ws?.readyState !== WebSocket.OPEN) {
                        this.ws?.close();
                        reject(new Error('WebSocket connection timeout'));
                        this.reconnect();
                    }
                }, CONNECTION_TIMEOUT);

                this.ws.onopen = () => {
                    clearTimeout(connectionTimeout);
                    this.reconnectAttempts = 0;
                    this.lastPongTime = Date.now();
                    this.startHeartbeat();
                    this.emit('open');
                    this.processQueuedMessages();
                    resolve();
                };

                this.ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    this.handleClose(event);
                };

                this.ws.onerror = (event) => {
                    clearTimeout(connectionTimeout);
                    this.handleError(event);
                    if (this.ws?.readyState !== WebSocket.OPEN) {
                        reject(new Error('WebSocket connection failed'));
                    }
                };

                this.ws.onmessage = this.handleMessage.bind(this);

            } catch (error) {
                reject(error);
                this.reconnect();
            }
        });
    }

    private startHeartbeat(): void {
        if (this.heartbeatInterval) {
            window.clearInterval(this.heartbeatInterval);
        }

        this.heartbeatInterval = window.setInterval(() => {
            if (this.ws?.readyState === WebSocket.OPEN) {
                if (Date.now() - this.lastPongTime > HEARTBEAT_TIMEOUT) {
                    this.reconnect();
                    return;
                }

                try {
                    this.ws.send(JSON.stringify({ type: 'ping' }));
                } catch (error) {
                    this.reconnect();
                }
            }
        }, HEARTBEAT_INTERVAL);
    }

    private handleClose(event: CloseEvent): void {
        this.stopHeartbeat();
        if (!this.forceClose) {
            this.reconnect();
        }
        this.emit('close', event);
    }

    private handleError(event: Event): void {
        const errorDetails = event instanceof ErrorEvent ? event.message :
                           'error' in event ? (event.error as Error).message :
                           'Unknown error';

        const errorMsg: ErrorMessage = {
            type: 'error',
            message: 'WebSocket connection error',
            code: ERROR_CODES.CONNECTION_FAILED,
            details: errorDetails
        };
        
        this.emit('error', errorMsg);
    }

    private handleMessage(event: MessageEvent): void {
        try {
            if (event.data instanceof ArrayBuffer) {
                this.handleBinaryMessage(event.data);
            } else {
                this.handleJsonMessage(event.data);
            }
        } catch (error) {
            const errorMsg: ErrorMessage = {
                type: 'error',
                message: 'Error processing message',
                code: ERROR_CODES.INVALID_MESSAGE,
                details: error instanceof Error ? error.message : String(error)
            };
            this.emit('error', errorMsg);
        }
    }

    private handleBinaryMessage(data: ArrayBuffer): void {
        if (!this.pendingBinaryUpdate) return;

        // Validate buffer size
        const expectedSize = this.indexToNodeId.length * BINARY_UPDATE_NODE_SIZE;
        if (data.byteLength !== expectedSize) return;

        const result = processPositionUpdate(data);
        if (!result) return;

        if (result.positions.length !== this.indexToNodeId.length) return;

        // Process and validate positions
        const positions = result.positions.map((pos, index) => {
            const nodeId = this.indexToNodeId[index];
            if (!nodeId) return null;

            // Validate all values
            if (!isValidPosition(pos.x) || !isValidPosition(pos.y) || !isValidPosition(pos.z) ||
                !isValidVelocity(pos.vx) || !isValidVelocity(pos.vy) || !isValidVelocity(pos.vz)) {
                return null;
            }

            return {
                ...pos,
                id: nodeId
            };
        }).filter((pos): pos is NodePosition & { id: string } => pos !== null);

        const binaryMessage: BinaryMessage = {
            type: 'binaryPositionUpdate',
            data,
            positions,
            nodeCount: this.indexToNodeId.length
        };

        this.emit('gpuPositions', binaryMessage);
        this.pendingBinaryUpdate = false;
    }

    private handleJsonMessage(data: string): void {
        const message = JSON.parse(data) as BaseMessage;
        
        if (message.type === 'pong') {
            this.lastPongTime = Date.now();
            return;
        }

        if (message.type === 'binaryPositionUpdate') {
            this.pendingBinaryUpdate = true;
            return;
        }

        this.emit('message', message);
        
        switch (message.type) {
            case 'error':
                this.emit('error', message as ErrorMessage);
                break;
            case 'graphUpdate':
                this.handleGraphUpdate(message as GraphUpdateMessage);
                break;
            case 'initialData':
                this.handleInitialData(message as InitialDataMessage);
                break;
            case 'simulationModeSet':
                this.emit('simulationModeSet', message.mode);
                break;
        }
    }

    private handleGraphUpdate(message: GraphUpdateMessage): void {
        if (!message.graphData) return;
        this.updateNodeMappings(message.graphData.nodes);
        this.emit('graphUpdate', message);
    }

    private handleInitialData(message: InitialDataMessage): void {
        if (!message.graphData) return;
        this.updateNodeMappings(message.graphData.nodes);
        this.emit('initialData', message);
    }

    private updateNodeMappings(nodes: Node[]): void {
        this.nodeIdToIndex.clear();
        this.indexToNodeId = [];
        
        nodes.forEach((node, index) => {
            this.nodeIdToIndex.set(node.id, index);
            this.indexToNodeId[index] = node.id;
        });
    }

    public send(data: any): void {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            if (this.messageQueue.length < this.config.maxQueueSize) {
                this.messageQueue.push(data);
            }
            return;
        }

        const now = Date.now();
        if (now - this.lastMessageTime > this.config.messageTimeWindow) {
            this.messageCount = 0;
            this.lastMessageTime = now;
        }

        if (this.messageCount >= this.config.messageRateLimit) {
            if (this.messageQueue.length < this.config.maxQueueSize) {
                this.messageQueue.push(data);
            }
            return;
        }

        try {
            const message = JSON.stringify(data);
            if (message.length > this.config.maxMessageSize) {
                throw new Error('Message exceeds maximum size');
            }
            
            this.ws.send(message);
            this.messageCount++;
            this.lastMessageTime = now;
            this.processQueue();
        } catch (error) {
            const errorMsg: ErrorMessage = {
                type: 'error',
                message: 'Error sending message',
                code: ERROR_CODES.MESSAGE_TOO_LARGE,
                details: error instanceof Error ? error.message : String(error)
            };
            this.emit('error', errorMsg);
        }
    }

    public sendBinary(data: ArrayBuffer): void {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

        // Validate data size
        const expectedSize = this.indexToNodeId.length * BINARY_UPDATE_NODE_SIZE;
        if (data.byteLength !== expectedSize) return;

        // Add to throttled updates
        this.updateThrottler.addUpdate(data);
    }

    private processQueue(): void {
        while (
            this.messageQueue.length > 0 &&
            this.messageCount < this.config.messageRateLimit
        ) {
            const data = this.messageQueue.shift();
            if (data) this.send(data);
        }
    }

    private processQueuedMessages(): void {
        const messages = [...this.messageQueue];
        this.messageQueue = [];
        messages.forEach(message => this.send(message));
    }

    public on<K extends keyof WebSocketEventMap>(
        event: K,
        callback: WebSocketEventCallback<WebSocketEventMap[K]>
    ): void {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, new Set());
        }
        this.eventListeners.get(event)!.add(callback);
    }

    public off<K extends keyof WebSocketEventMap>(
        event: K,
        callback: WebSocketEventCallback<WebSocketEventMap[K]>
    ): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.delete(callback);
        }
    }

    private emit<K extends keyof WebSocketEventMap>(
        event: K,
        data?: WebSocketEventMap[K]
    ): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.forEach(callback => callback(data));
        }
    }

    private reconnect(): void {
        if (this.isReconnecting || this.forceClose) return;
        
        this.isReconnecting = true;
        this.cleanup(false);
        
        if (this.reconnectAttempts < this.config.maxRetries) {
            this.reconnectAttempts++;
            const delay = this.config.retryDelay * Math.pow(2, this.reconnectAttempts - 1);
            
            this.reconnectTimeout = window.setTimeout(() => {
                this.connect().catch(() => {
                    this.reconnect();
                }).finally(() => {
                    this.isReconnecting = false;
                });
            }, delay);
        } else {
            this.emit('maxReconnectAttemptsReached');
            this.isReconnecting = false;
        }
    }

    private stopHeartbeat(): void {
        if (this.heartbeatInterval) {
            window.clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }

    public cleanup(force: boolean = true): void {
        this.stopHeartbeat();
        
        if (this.reconnectTimeout !== null) {
            window.clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }

        if (this.ws) {
            this.forceClose = force;
            this.ws.onclose = null;
            this.ws.close();
            this.ws = null;
        }

        this.messageQueue = [];
        this.messageCount = 0;
        this.lastMessageTime = 0;
        
        if (force) {
            this.reconnectAttempts = 0;
            this.eventListeners.clear();
            this.nodeIdToIndex.clear();
            this.indexToNodeId = [];
        }
    }
}

----
services/errorTracking.ts
interface ErrorInfo {
  message: string;
  context?: string;
  component?: string;
  stack?: string;
  timestamp: number;
  additional?: any;
}

class ErrorTrackingService {
  private errors: ErrorInfo[] = [];
  private maxErrors = 100;

  private constructor() {
    this.setupGlobalHandlers();
  }

  private static instance: ErrorTrackingService;

  public static getInstance(): ErrorTrackingService {
    if (!ErrorTrackingService.instance) {
      ErrorTrackingService.instance = new ErrorTrackingService();
    }
    return ErrorTrackingService.instance;
  }

  private setupGlobalHandlers() {
    window.onerror = (message, source, lineno, colno, error) => {
      this.trackError(error || new Error(String(message)), {
        context: 'Global Error Handler',
        additional: { source, lineno, colno }
      });
    };

    window.onunhandledrejection = (event) => {
      this.trackError(event.reason, {
        context: 'Unhandled Promise Rejection'
      });
    };
  }

  public trackError(error: Error | unknown, info?: {
    context?: string;
    component?: string;
    additional?: any;
  }) {
    const errorInfo: ErrorInfo = {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      context: info?.context,
      component: info?.component,
      additional: info?.additional,
      timestamp: Date.now()
    };

    this.errors.unshift(errorInfo);

    // Trim old errors
    if (this.errors.length > this.maxErrors) {
      this.errors = this.errors.slice(0, this.maxErrors);
    }

    // Emit event for any listeners
    window.dispatchEvent(new CustomEvent('error-tracked', {
      detail: errorInfo
    }));
  }

  public getErrors(): ErrorInfo[] {
    return [...this.errors];
  }

  public clearErrors(): void {
    this.errors = [];
  }
}

export const errorTracking = ErrorTrackingService.getInstance();

----
components/App.vue
<template>
  <ErrorBoundary>
    <div id="app">
      <div id="scene-container" ref="sceneContainer">
        <canvas ref="canvas" />
        <GraphSystem 
          v-if="visualizationState.scene" 
          :visual-settings="visualSettings" 
        />
      </div>
      <ControlPanel />
      <div class="connection-status" :class="{ connected: isConnected }">
        WebSocket: {{ isConnected ? 'Connected' : 'Disconnected' }}
      </div>
      <div v-if="error" class="error-message">
        {{ error }}
      </div>
      <div v-if="process.env.NODE_ENV === 'development'" class="debug-info">
        Scene Status: {{ visualizationState.isInitialized ? 'Ready' : 'Initializing' }}
        <br />
        Nodes: {{ visualizationStore.nodes.length }}
        <br />
        Edges: {{ visualizationStore.edges.length }}
      </div>
    </div>
  </ErrorBoundary>
</template>

<script lang="ts">
import { defineComponent, onMounted, onErrorCaptured, ref, onBeforeUnmount, ComponentPublicInstance, watch, computed, provide } from 'vue'
import { storeToRefs } from 'pinia'
import { useSettingsStore } from '../stores/settings'
import { useVisualizationStore } from '../stores/visualization'
import { useWebSocketStore } from '../stores/websocket'
import { useBinaryUpdateStore } from '../stores/binaryUpdate'
import ControlPanel from '@components/ControlPanel.vue'
import ErrorBoundary from '@components/ErrorBoundary.vue'
import GraphSystem from '@components/visualization/GraphSystem.vue'
import { errorTracking } from '../services/errorTracking'
import { useVisualization, SCENE_KEY } from '../composables/useVisualization'
import { SERVER_MESSAGE_TYPES, MESSAGE_FIELDS, ENABLE_BINARY_DEBUG } from '../constants/websocket'
import type { BaseMessage, GraphUpdateMessage, ErrorMessage, Node, Edge, BinaryMessage } from '../types/websocket'
import type { GraphNode, GraphEdge, GraphData } from '../types/core'
import type { FisheyeConfig } from '../types/components'

export default defineComponent({
  name: 'App',
  components: {
    ControlPanel,
    ErrorBoundary,
    GraphSystem
  },
  setup() {
    const settingsStore = useSettingsStore()
    const visualizationStore = useVisualizationStore()
    const websocketStore = useWebSocketStore()
    const binaryUpdateStore = useBinaryUpdateStore()

    const { connected: isConnected } = storeToRefs(websocketStore)
    
    const sceneContainer = ref<HTMLElement | null>(null)
    const canvas = ref<HTMLCanvasElement | null>(null)
    const error = ref<string | null>(null)
    const isInitialDataRequested = ref(false)

    const visualSettings = computed(() => {
      const settings = settingsStore.getVisualizationSettings;
      console.debug('Visualization settings:', {
        material: {
          metalness: settings.material.node_material_metalness,
          roughness: settings.material.node_material_roughness,
          opacity: settings.material.node_material_opacity
        },
        nodeColors: {
          base: settings.node_color,
          core: settings.node_color_core
        },
        sizes: {
          min: settings.min_node_size,
          max: settings.max_node_size
        }
      });
      return settings;
    });

    const { initialize: initVisualization, updateNodes, updatePositions, state: visualizationState } = useVisualization()

    provide('visualizationState', visualizationState)

    const setupWebSocketHandlers = () => {
      if (!websocketStore.service) {
        console.error('WebSocket service not initialized');
        return;
      }

      websocketStore.service.on('open', () => {
        console.log('WebSocket connected');
        error.value = null;
        
        if (!isInitialDataRequested.value) {
          console.debug('Requesting initial graph data');
          websocketStore.service?.send({
            type: SERVER_MESSAGE_TYPES.INITIAL_DATA
          });
          isInitialDataRequested.value = true;
        }
      });

      websocketStore.service.on('close', () => {
        console.log('WebSocket disconnected');
        binaryUpdateStore.clear();
        isInitialDataRequested.value = false;
      });

      websocketStore.service.on('error', (err: ErrorMessage) => {
        console.error('WebSocket error:', err);
        error.value = err.message;
        errorTracking.trackError(new Error(err.message), {
          context: 'WebSocket Error',
          component: 'App'
        });
      });

      websocketStore.service.on('message', (message: BaseMessage) => {
        console.debug('Received message:', message);
        switch (message.type) {
          case SERVER_MESSAGE_TYPES.GRAPH_UPDATE:
            const graphMsg = message as GraphUpdateMessage;
            if (!graphMsg.graphData) {
              console.warn('Received graph update with no data');
              return;
            }

            console.log('Received graph update:', {
              nodes: graphMsg.graphData.nodes?.length || 0,
              edges: graphMsg.graphData.edges?.length || 0,
              metadata: graphMsg.graphData.metadata ? Object.keys(graphMsg.graphData.metadata).length : 0,
              sampleNode: graphMsg.graphData.nodes?.[0] ? {
                id: graphMsg.graphData.nodes[0].id,
                position: graphMsg.graphData.nodes[0].position
              } : null
            });
            
            visualizationStore.setGraphData(
              graphMsg.graphData.nodes,
              graphMsg.graphData.edges,
              graphMsg.graphData.metadata || {}
            );

            updateNodes(graphMsg.graphData.nodes);

            console.log('Graph data state after update:', {
              storeNodes: visualizationStore.nodes.length,
              storeEdges: visualizationStore.edges.length,
              graphData: visualizationStore.graphData ? {
                nodes: visualizationStore.graphData.nodes.length,
                edges: visualizationStore.graphData.edges.length
              } : null
            });
            break;

          case SERVER_MESSAGE_TYPES.SETTINGS_UPDATED:
            settingsStore.applyServerSettings(message.settings);
            break;

          case SERVER_MESSAGE_TYPES.POSITION_UPDATE_COMPLETE:
            console.debug('Position update completed:', message[MESSAGE_FIELDS.STATUS]);
            break;
        }
      });

      websocketStore.service.on('gpuPositions', (data: BinaryMessage) => {
        if (ENABLE_BINARY_DEBUG) {
          console.debug('Received GPU positions update:', {
            bufferSize: data.data.byteLength,
            nodeCount: visualizationStore.nodes.length
          });
        }

        binaryUpdateStore.updateFromBinary(data);

        const positions = binaryUpdateStore.getAllPositions;
        const velocities = binaryUpdateStore.getAllVelocities;
        const nodeCount = visualizationStore.nodes.length;

        updatePositions(positions, velocities, nodeCount);
      });
    };

    onMounted(async () => {
      try {
        settingsStore.applyServerSettings({});
        console.info('Settings initialized', {
          context: 'App Setup',
          settings: settingsStore.$state
        });

        if (canvas.value && sceneContainer.value) {
          console.log('Initializing visualization system...');
          
          const rect = sceneContainer.value.getBoundingClientRect();
          canvas.value.width = rect.width;
          canvas.value.height = rect.height;
          
          await initVisualization({
            canvas: canvas.value,
            scene: {
              antialias: true,
              alpha: true,
              preserveDrawingBuffer: true,
              powerPreference: 'high-performance'
            }
          });
          console.log('Visualization system initialized');

          if (visualizationState.value.scene) {
            provide(SCENE_KEY, visualizationState.value.scene);
          }
        }

        await websocketStore.initialize();
        setupWebSocketHandlers();

        console.info('Application initialized', {
          context: 'App Initialization',
          environment: process.env.NODE_ENV
        });

      } catch (err) {
        console.error('Error during App setup:', err);
        error.value = err instanceof Error ? err.message : 'Unknown error during setup';
        errorTracking.trackError(err, {
          context: 'App Setup',
          component: 'App'
        });
      }
    });

    onBeforeUnmount(() => {
      websocketStore.cleanup();
      binaryUpdateStore.clear();
    });

    onErrorCaptured((err, instance: ComponentPublicInstance | null, info) => {
      error.value = err instanceof Error ? err.message : 'An error occurred';
      errorTracking.trackError(err, {
        context: 'App Root Error',
        component: (instance as any)?.$options?.name || 'Unknown',
        additional: { info }
      });
      return false;
    });

    return {
      sceneContainer,
      canvas,
      isConnected,
      error,
      visualSettings,
      visualizationState,
      visualizationStore,
      process: {
        env: {
          NODE_ENV: process.env.NODE_ENV
        }
      }
    };
  }
});
</script>

<style>
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  background: #000000;
}

#scene-container {
  width: 100%;
  height: 100%;
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  background: #000000;
  touch-action: none;
}

#scene-container canvas {
  width: 100%;
  height: 100%;
  display: block;
}

#app {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
  pointer-events: none;
}

#app > * {
  pointer-events: auto;
}

.connection-status {
  position: fixed;
  top: 10px;
  right: 10px;
  padding: 5px 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: #ff4444;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
}

.connection-status.connected {
  color: #44ff44;
}

.error-message {
  position: fixed;
  top: 50px;
  right: 10px;
  padding: 10px;
  background-color: rgba(255, 0, 0, 0.8);
  color: white;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
  max-width: 300px;
  word-wrap: break-word;
}

.debug-info {
  position: fixed;
  top: 90px;
  right: 10px;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  border-radius: 4px;
  font-family: monospace;
  z-index: 1000;
  max-width: 300px;
  word-wrap: break-word;
}
</style>

----
components/ErrorMessage.vue
<template>
  <Transition name="fade">
    <div 
      v-if="error"
      class="error-message"
      @click="dismiss"
    >
      {{ error }}
    </div>
  </Transition>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted, onBeforeUnmount } from 'vue';

interface Props {
  message: string;
  duration: number;
  dismissible: boolean;
}

export default defineComponent({
  name: 'ErrorMessage',
  
  props: {
    message: {
      type: String,
      required: true
    },
    duration: {
      type: Number,
      default: 5000
    },
    dismissible: {
      type: Boolean,
      default: true
    }
  },

  emits: ['dismiss'],

  setup(props: Props, { emit }: { emit: (event: 'dismiss') => void }) {
    const error = ref<string | null>(props.message);
    let timeout: number | null = null;

    const dismiss = () => {
      if (props.dismissible) {
        error.value = null;
        emit('dismiss');
      }
    };

    onMounted(() => {
      if (props.duration > 0) {
        timeout = window.setTimeout(() => {
          error.value = null;
          emit('dismiss');
        }, props.duration);
      }
    });

    onBeforeUnmount(() => {
      if (timeout) {
        clearTimeout(timeout);
      }
    });

    return {
      error,
      dismiss
    };
  }
});
</script>

<style scoped>
.error-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(255, 0, 0, 0.85);
  color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  cursor: pointer;
  max-width: 80vw;
  text-align: center;
  font-weight: 500;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>

----
components/ControlPanel.vue
<template>
  <div id="control-panel" :class="{ hidden: isHidden }">
    <button class="toggle-button" @click="togglePanel">
      {{ isHidden ? 'Show Controls' : 'Hide Controls' }}
    </button>
    
    <div class="panel-content">
      <!-- Node Appearance -->
      <div v-for="group in controlGroups" :key="group.name" class="control-group">
        <div class="group-header" @click="toggleGroup(group.name)">
          <h3>{{ group.label }}</h3>
        </div>
        <div v-if="!collapsedGroups[group.name]" class="group-content">
          <div v-for="control in group.controls" :key="control.name" class="control-item">
            <label>{{ control.label }}</label>
            
            <!-- Color Input -->
            <template v-if="control.type === 'color'">
              <input type="color"
                     :value="control.value"
                     @input="($event: Event) => handleColorInput($event, group.name, control.name)">
            </template>
            
            <!-- Range Input -->
            <template v-if="control.type === 'range'">
              <input type="range"
                     :min="control.min"
                     :max="control.max"
                     :step="control.step"
                     :value="control.value"
                     @input="($event: Event) => handleRangeInput($event, group.name, control.name)">
              <span class="range-value">{{ typeof control.value === 'number' ? control.value.toFixed(2) : control.value }}</span>
            </template>
            
            <!-- Checkbox Input -->
            <template v-if="control.type === 'checkbox'">
              <input type="checkbox"
                     :value="control.value"
                     :checked="Boolean(control.value)"
                     @change="($event: Event) => handleCheckboxChange($event, group.name, control.name)">
            </template>
          </div>
        </div>
      </div>

      <!-- Save Settings Button -->
      <button class="save-button" 
              @click="saveSettings"
              :disabled="!hasUnsavedChanges || isSaving">
        {{ getSaveButtonText() }}
      </button>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useSettingsStore } from '../stores/settings';
import { useWebSocketStore } from '../stores/websocket';
import { useControlGroups } from '../composables/useControlGroups';
import { useControlSettings } from '../composables/useControlSettings';
import { SERVER_MESSAGE_TYPES, MESSAGE_FIELDS } from '../constants/websocket';
import type { ControlGroup } from '../types/components';
import type { SettingsUpdateMessage, MaterialSettings, BloomSettings, FisheyeSettings } from '../types/websocket';

export default defineComponent({
  name: 'ControlPanel',
  
  setup() {
    const settingsStore = useSettingsStore();
    const websocketStore = useWebSocketStore();
    const { collapsedGroups, toggleGroup } = useControlGroups();
    const { 
      createAppearanceGroup,
      createMaterialGroup,
      createPhysicsGroup,
      createBloomGroup,
      createEnvironmentGroup,
      createFisheyeGroup,
      handleControlChange
    } = useControlSettings();

    const isHidden = ref(false);
    const isSaving = ref(false);
    const { visualization, bloom, fisheye, isDirty: hasUnsavedChanges } = storeToRefs(settingsStore);

    // Map visualization settings to material settings
    const getMaterialSettings = computed((): Partial<MaterialSettings> => ({
      nodeSize: (visualization.value.min_node_size + visualization.value.max_node_size) / 2,
      nodeColor: visualization.value.node_color,
      edgeWidth: (visualization.value.edge_min_width + visualization.value.edge_max_width) / 2,
      edgeColor: visualization.value.edge_color,
      highlightColor: visualization.value.node_color_core,
      opacity: visualization.value.material.node_material_opacity
    }));

    // Compute control groups based on current settings
    const controlGroups = computed<ControlGroup[]>(() => [
      createAppearanceGroup(visualization.value),
      createMaterialGroup(visualization.value),
      createPhysicsGroup(visualization.value),
      createBloomGroup(bloom.value),
      createEnvironmentGroup(visualization.value),
      createFisheyeGroup(fisheye.value)
    ]);

    const togglePanel = () => {
      isHidden.value = !isHidden.value;
    };

    // Type-safe event handlers
    const handleColorInput = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, input.value);
    };

    const handleRangeInput = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, parseFloat(input.value));
    };

    const handleCheckboxChange = (event: Event, groupName: string, controlName: string) => {
      const input = event.target as HTMLInputElement;
      handleControlChange(groupName, controlName, input.checked);
    };

    const getSaveButtonText = () => {
      if (isSaving.value) return 'Saving...';
      if (!hasUnsavedChanges.value) return 'No Changes';
      return 'Save Settings';
    };

    const saveSettings = async () => {
      if (!hasUnsavedChanges.value || isSaving.value) return;
      
      try {
        isSaving.value = true;
        
        // Prepare settings update message
        const updateMessage: SettingsUpdateMessage = {
          type: SERVER_MESSAGE_TYPES.UPDATE_SETTINGS,
          settings: {
            [MESSAGE_FIELDS.MATERIAL]: getMaterialSettings.value,
            [MESSAGE_FIELDS.BLOOM]: bloom.value,
            [MESSAGE_FIELDS.FISHEYE]: fisheye.value
          }
        };

        // Send settings through WebSocket
        websocketStore.send(updateMessage);
        
        // Mark settings as saved in store
        settingsStore.markSaved();
        
        console.debug('Settings update sent:', updateMessage);
      } catch (error) {
        console.error('Failed to save settings:', error);
      } finally {
        isSaving.value = false;
      }
    };

    onMounted(() => {
      console.debug('ControlPanel mounted, initial settings:', {
        material: getMaterialSettings.value,
        bloom: bloom.value,
        fisheye: fisheye.value
      });
    });

    return {
      isHidden,
      isSaving,
      collapsedGroups,
      controlGroups,
      hasUnsavedChanges,
      togglePanel,
      toggleGroup,
      handleColorInput,
      handleRangeInput,
      handleCheckboxChange,
      saveSettings,
      getSaveButtonText
    };
  }
});
</script>

<style scoped>
/* Styles remain unchanged */
#control-panel {
  position: fixed;
  top: 20px;
  right: 0;
  width: 300px;
  max-height: 90vh;
  background-color: rgba(20, 20, 20, 0.9);
  color: #ffffff;
  border-radius: 10px 0 0 10px;
  overflow-y: auto;
  z-index: 1000;
  transition: transform 0.3s ease-in-out;
  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
}

#control-panel.hidden {
  transform: translateX(calc(100% - 40px));
}

.toggle-button {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%) rotate(-90deg);
  transform-origin: left center;
  background-color: rgba(20, 20, 20, 0.9);
  color: #ffffff;
  border: none;
  padding: 8px 16px;
  cursor: pointer;
  border-radius: 5px 5px 0 0;
  font-size: 0.9em;
  white-space: nowrap;
  z-index: 1001;
}

.panel-content {
  padding: 20px;
}

.control-group {
  margin-bottom: 16px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  overflow: hidden;
}

.group-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background-color: rgba(255, 255, 255, 0.1);
  cursor: pointer;
}

.group-header h3 {
  margin: 0;
  font-size: 1em;
  font-weight: 500;
}

.group-content {
  padding: 12px;
}

.control-item {
  margin-bottom: 12px;
}

.control-item label {
  display: block;
  margin-bottom: 4px;
  font-size: 0.9em;
  color: #cccccc;
}

.control-item input[type="range"] {
  width: 100%;
  height: 6px;
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
  -webkit-appearance: none;
}

.control-item input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background-color: #ffffff;
  border-radius: 50%;
  cursor: pointer;
}

.control-item input[type="color"] {
  width: 100%;
  height: 30px;
  border: none;
  border-radius: 4px;
  background-color: transparent;
}

.range-value {
  float: right;
  font-size: 0.8em;
  color: #999999;
}

.save-button {
  width: 100%;
  padding: 12px;
  margin-top: 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s;
}

.save-button:hover:not(:disabled) {
  background-color: #218838;
}

.save-button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  opacity: 0.65;
}
</style>

----
components/ErrorBoundary.vue
<template>
  <div>
    <div v-if="error" class="error-boundary">
      <div class="error-content">
        <h3>Component Error</h3>
        <div class="error-message">{{ error.message }}</div>
        <div class="error-info">
          <div class="error-component">Component: {{ error.component }}</div>
          <div class="error-stack">{{ error.stack }}</div>
        </div>
        <button @click="handleError" class="retry-button">
          Retry
        </button>
      </div>
    </div>
    <slot v-else></slot>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, onErrorCaptured, ComponentPublicInstance } from 'vue'

export default defineComponent({
  name: 'ErrorBoundary',
  
  setup() {
    const error = ref<{
      message: string;
      component?: string;
      stack?: string;
    } | null>(null)

    onErrorCaptured((err, instance: ComponentPublicInstance | null, info) => {
      // Get component name
      const componentName = (instance as any)?.$options?.name || 'Unknown Component'
      
      // Format error for display
      error.value = {
        message: err.message || String(err),
        component: componentName,
        stack: err.stack
      }

      // Log to debug console
      console.error('Component Error:', {
        message: err.message,
        component: componentName,
        stack: err.stack,
        context: `Vue Component: ${componentName}`
      })

      // Prevent error from propagating
      return false
    })

    const handleError = () => {
      error.value = null
    }

    return {
      error,
      handleError
    }
  }
})
</script>

<style scoped>
.error-boundary {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.85);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.error-content {
  background-color: #2c3e50;
  padding: 20px;
  border-radius: 8px;
  max-width: 80%;
  max-height: 80%;
  overflow-y: auto;
  color: white;
  font-family: monospace;
}

.error-content h3 {
  color: #e74c3c;
  margin-top: 0;
}

.error-message {
  color: #f1c40f;
  margin: 10px 0;
  font-size: 16px;
}

.error-info {
  margin: 15px 0;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

.error-component {
  color: #3498db;
  margin-bottom: 8px;
}

.error-stack {
  color: #95a5a6;
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.retry-button {
  background-color: #2ecc71;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin-top: 15px;
}

.retry-button:hover {
  background-color: #27ae60;
}
</style>

----
components/chatManager.vue
<template>
  <div class="chat-manager">
    <div class="chat-messages" ref="messagesContainer">
      <div v-for="(message, index) in messages" :key="index" class="message">
        {{ message }}
      </div>
    </div>
    <div class="chat-input">
      <input
        v-model="chatInput"
        @keyup.enter="sendMessage"
        placeholder="Type your message..."
        :disabled="!websocketService"
      />
      <div class="button-group">
        <button @click="sendMessage" :disabled="!websocketService || !chatInput.trim()">
          Send
        </button>
        <button 
          @click="toggleTTS" 
          :disabled="!websocketService"
          :class="{ active: useOpenAI }"
          :title="useOpenAI ? 'Using OpenAI for TTS' : 'Using Sonata for TTS'"
        >
          TTS: {{ useOpenAI ? 'OpenAI' : 'Sonata' }}
        </button>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, PropType, onMounted, onBeforeUnmount, nextTick } from 'vue'
import type WebsocketService from '../services/websocketService'

export default defineComponent({
  name: 'ChatManager',
  
  props: {
    websocketService: {
      type: Object as PropType<WebsocketService>,
      required: true
    }
  },

  setup(props) {
    const chatInput = ref('')
    const messages = ref<string[]>([])
    const useOpenAI = ref(false)
    const messagesContainer = ref<HTMLElement | null>(null)

    const scrollToBottom = async () => {
      await nextTick()
      if (messagesContainer.value) {
        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
      }
    }

    const handleRagflowAnswer = (answer: string) => {
      messages.value.push(`AI: ${answer}`)
      scrollToBottom()
    }

    const handleOpenAIResponse = (response: string) => {
      messages.value.push(`OpenAI: ${response}`)
      scrollToBottom()
    }

    const sendMessage = () => {
      if (chatInput.value.trim()) {
        messages.value.push(`You: ${chatInput.value}`)
        props.websocketService.send({
          type: 'chatMessage',
          message: chatInput.value,
          useOpenAI: useOpenAI.value
        })
        chatInput.value = ''
        scrollToBottom()
      }
    }

    const toggleTTS = () => {
      useOpenAI.value = !useOpenAI.value
      props.websocketService.send({
        type: 'setTTSMethod',
        useOpenAI: useOpenAI.value
      })
      console.log(`TTS method set to: ${useOpenAI.value ? 'OpenAI' : 'Sonata'}`)
    }

    onMounted(() => {
      props.websocketService.on('ragflowAnswer', handleRagflowAnswer)
      props.websocketService.on('openaiResponse', handleOpenAIResponse)
    })

    onBeforeUnmount(() => {
      props.websocketService.off('ragflowAnswer', handleRagflowAnswer)
      props.websocketService.off('openaiResponse', handleOpenAIResponse)
    })

    return {
      chatInput,
      messages,
      useOpenAI,
      messagesContainer,
      sendMessage,
      toggleTTS
    }
  }
})
</script>

<style scoped>
.chat-manager {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 300px;
  height: 400px;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  padding: 10px;
  z-index: 1000;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.chat-messages {
  flex-grow: 1;
  overflow-y: auto;
  margin-bottom: 10px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

.message {
  margin: 8px 0;
  padding: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  color: #fff;
  word-wrap: break-word;
}

.chat-input {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.chat-input input {
  width: 100%;
  padding: 8px;
  border: none;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  font-size: 14px;
}

.chat-input input::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.chat-input input:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.15);
}

.button-group {
  display: flex;
  gap: 8px;
}

button {
  flex: 1;
  padding: 8px;
  border: none;
  border-radius: 4px;
  background: #2196f3;
  color: white;
  cursor: pointer;
  transition: background-color 0.2s;
}

button:hover:not(:disabled) {
  background: #1976d2;
}

button:disabled {
  background: #ccc;
  cursor: not-allowed;
  opacity: 0.7;
}

button.active {
  background: #4caf50;
}

button.active:hover:not(:disabled) {
  background: #388e3c;
}

/* Scrollbar styling */
.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
</style>

----
components/NodeInfoPanel.vue
<template>
  <div 
    v-if="nodeData"
    class="node-info-panel"
  >
    <h3>Node Information</h3>
    <p><strong>ID:</strong> {{ nodeData.id }}</p>
    <p v-if="nodeData.label"><strong>Name:</strong> {{ nodeData.label }}</p>
    <template v-if="nodeData.metadata">
      <div v-for="(value, key) in nodeData.metadata" :key="key" class="metadata-item">
        <strong>{{ formatKey(key) }}:</strong> {{ formatValue(value) }}
      </div>
    </template>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue';
import { useVisualizationStore } from '../stores/visualization';
import type { Node } from '../types/core';

export default defineComponent({
  name: 'NodeInfoPanel',
  
  setup() {
    const store = useVisualizationStore();
    
    const nodeData = computed(() => store.selectedNode);

    const formatKey = (key: string) => {
      return key
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    };

    const formatValue = (value: any) => {
      if (typeof value === 'object') {
        return JSON.stringify(value, null, 2);
      }
      return value;
    };

    return {
      nodeData,
      formatKey,
      formatValue
    };
  }
});
</script>

<style scoped>
.node-info-panel {
  position: absolute;
  top: 20px;
  left: 20px;
  width: 300px;
  max-height: 40vh;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  overflow-y: auto;
}

.metadata-item {
  margin: 5px 0;
}

h3 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 1.2em;
}

p {
  margin: 8px 0;
}

strong {
  font-weight: 600;
}
</style>

----
components/three/index.ts
import { defineComponent, h, onMounted, onBeforeUnmount, watch, ref, inject, type Ref } from 'vue'
import * as THREE from 'three'
import { SCENE_KEY } from '../../composables/useVisualization'

// Define our supported event types
type SupportedEventType = 'click' | 'pointerenter' | 'pointerleave' | 'pointerdown' | 'pointermove' | 'pointerup';

// Event handler setup
const setupEventHandlers = (
  mesh: THREE.Mesh,
  emit: (event: SupportedEventType, data: THREE.Event) => void
) => {
  // Map Vue events to Three.js events
  const handlers: Record<string, (event: THREE.Event) => void> = {
    'click': (event) => {
      debugLog('Mesh', 'Event: click', { id: mesh.id });
      emit('click', event);
    },
    'pointermove': (event) => {
      debugLog('Mesh', 'Event: pointermove', { id: mesh.id });
      emit('pointermove', event);
    },
    'pointerdown': (event) => {
      debugLog('Mesh', 'Event: pointerdown', { id: mesh.id });
      emit('pointerdown', event);
    },
    'pointerup': (event) => {
      debugLog('Mesh', 'Event: pointerup', { id: mesh.id });
      emit('pointerup', event);
    },
    'pointerover': (event) => {
      debugLog('Mesh', 'Event: pointerenter', { id: mesh.id });
      emit('pointerenter', event);
    },
    'pointerout': (event) => {
      debugLog('Mesh', 'Event: pointerleave', { id: mesh.id });
      emit('pointerleave', event);
    }
  };

  // Add event listeners
  Object.entries(handlers).forEach(([type, handler]) => {
    mesh.addEventListener(type as keyof THREE.Object3DEventMap, handler);
  });

  return () => {
    // Remove event listeners on cleanup
    Object.entries(handlers).forEach(([type, handler]) => {
      mesh.removeEventListener(type as keyof THREE.Object3DEventMap, handler);
    });
  };
};

// Debug logging helper
const debugLog = (component: string, action: string, details: any) => {
  console.debug(`[Three.js ${component}] ${action}:`, details);
};

// Helper to safely get fog properties
const getFogDetails = (fog: THREE.Fog | THREE.FogExp2 | null) => {
  if (!fog) return null;
  if (fog instanceof THREE.Fog) {
    return {
      type: 'Fog',
      near: fog.near,
      far: fog.far
    };
  }
  if (fog instanceof THREE.FogExp2) {
    return {
      type: 'FogExp2',
      density: fog.density
    };
  }
  return null;
};

// Provide/inject keys
const PARENT_KEY = Symbol('three-parent');
const GEOMETRY_REF = Symbol('geometry-ref');
const MATERIAL_REF = Symbol('material-ref');

// Basic Three.js component wrapper
export const Group = defineComponent({
  name: 'Group',
  setup(_, { slots }) {
    const group = new THREE.Group();
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;
    const scene = inject(SCENE_KEY, null) as THREE.Scene | null;
    
    debugLog('Group', 'Created', { id: group.id });
    
    onMounted(() => {
      if (parent) {
        parent.add(group);
      } else if (scene) {
        scene.add(group);
      }
      debugLog('Group', 'Mounted', { 
        id: group.id,
        parent: parent?.type || 'Scene',
        childCount: group.children.length
      });
    });

    onBeforeUnmount(() => {
      debugLog('Group', 'Disposing', { id: group.id });
      if (parent) {
        parent.remove(group);
      } else if (scene) {
        scene.remove(group);
      }
      group.clear();
    });

    return () => h('div', { provide: { [PARENT_KEY]: group } }, slots.default?.());
  }
});

export const Scene = defineComponent({
  name: 'Scene',
  props: {
    background: {
      type: [Number, String],
      default: 0x000000
    }
  },
  setup(props, { slots }) {
    // Create scene
    const scene = new THREE.Scene();
    
    // Set initial background
    scene.background = new THREE.Color(props.background);
    
    debugLog('Scene', 'Created', { 
      id: scene.id,
      background: scene.background instanceof THREE.Color ? scene.background.getHexString() : 'none'
    });

    // Watch for background changes
    watch(() => props.background, (newColor) => {
      scene.background = new THREE.Color(newColor);
      debugLog('Scene', 'Background updated', { 
        background: scene.background instanceof THREE.Color ? scene.background.getHexString() : 'none'
      });
    });

    // Clean up
    onBeforeUnmount(() => {
      debugLog('Scene', 'Disposing', { id: scene.id });
      scene.clear();
    });

    // Provide scene to child components
    return () => h('div', { provide: { [SCENE_KEY]: scene } }, slots.default?.());
  }
});

// Mesh component that wraps Three.js mesh
export const Mesh = defineComponent({
  name: 'Mesh',
  props: {
    position: {
      type: Object as () => THREE.Vector3,
      required: true
    },
    scale: {
      type: Object as () => { x: number; y: number; z: number },
      default: () => ({ x: 1, y: 1, z: 1 })
    }
  },
  emits: ['click', 'pointerenter', 'pointerleave', 'pointerdown', 'pointermove', 'pointerup'] as const,
  setup(props, { emit, slots }) {
    const mesh = new THREE.Mesh();
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;
    const scene = inject(SCENE_KEY, null) as THREE.Scene | null;
    let cleanup: (() => void) | null = null;

    if (!parent && !scene) {
      throw new Error('Mesh must be used within a Scene or Group component');
    }

    // Wait for geometry and material from child components
    const geometryRef = ref<THREE.BufferGeometry | null>(null);
    const materialRef = ref<THREE.Material | null>(null);

    // Update mesh when geometry or material change
    watch([geometryRef, materialRef], ([geometry, material]) => {
      if (geometry && material) {
        mesh.geometry = geometry;
        mesh.material = material;
        
        // Force geometry update
        geometry.attributes.position.needsUpdate = true;
        if (geometry.index) {
          geometry.index.needsUpdate = true;
        }
        
        // Force transform update
        mesh.updateMatrix();
        mesh.updateMatrixWorld(true);
        
        // Mark for render
        if (scene?.userData) {
          scene.userData.needsRender = true;
        }

        debugLog('Mesh', 'Updated geometry and material', {
          id: mesh.id,
          geometryType: geometry.type,
          materialType: material.type,
          vertices: geometry.attributes.position?.count,
          needsUpdate: geometry.attributes.position.needsUpdate
        });
      }
    }, { immediate: true });

    onMounted(() => {
      mesh.position.copy(props.position);
      mesh.scale.set(props.scale.x, props.scale.y, props.scale.z);
      
      if (parent) {
        parent.add(mesh);
      } else if (scene) {
        scene.add(mesh);
      }

      debugLog('Mesh', 'Added to scene', {
        id: mesh.id,
        position: mesh.position.toArray(),
        scale: [mesh.scale.x, mesh.scale.y, mesh.scale.z],
        parent: parent?.type || 'Scene',
        hasGeometry: !!mesh.geometry,
        hasMaterial: !!mesh.material
      });

      // Set up event handlers
      cleanup = setupEventHandlers(mesh, emit);
    });

    // Watch for prop changes
    watch(() => props.position, (newPos) => {
      mesh.position.copy(newPos);
      debugLog('Mesh', 'Position updated', {
        id: mesh.id,
        position: mesh.position.toArray()
      });
    });

    watch(() => props.scale, (newScale) => {
      mesh.scale.set(newScale.x, newScale.y, newScale.z);
      debugLog('Mesh', 'Scale updated', {
        id: mesh.id,
        scale: [mesh.scale.x, mesh.scale.y, mesh.scale.z]
      });
    });

    onBeforeUnmount(() => {
      // Clean up event handlers
      if (cleanup) {
        cleanup();
      }

      debugLog('Mesh', 'Removing from scene', {
        id: mesh.id,
        position: mesh.position.toArray()
      });
      if (parent) {
        parent.remove(mesh);
      } else if (scene) {
        scene.remove(mesh);
      }
      mesh.geometry?.dispose();
      if (Array.isArray(mesh.material)) {
        mesh.material.forEach(m => m.dispose());
      } else if (mesh.material) {
        mesh.material.dispose();
      }
    });

    // Provide mesh to child components and handle their setup
    return () => h('div', { 
      provide: { 
        [PARENT_KEY]: mesh,
        [GEOMETRY_REF]: geometryRef,
        [MATERIAL_REF]: materialRef
      } 
    }, slots.default?.());
  }
});

// Update SphereGeometry to connect with parent mesh
export const SphereGeometry = defineComponent({
  name: 'SphereGeometry',
  props: {
    args: {
      type: Array as unknown as () => [number, number, number],
      default: () => [1, 32, 32]
    }
  },
  setup(props) {
    const geometry = new THREE.SphereGeometry(...props.args);
    const geometryRef = inject<Ref<THREE.BufferGeometry | null>>(GEOMETRY_REF);
    
    if (geometryRef) {
      geometryRef.value = geometry;
    }
    
    debugLog('SphereGeometry', 'Created', {
      radius: props.args[0],
      segments: [props.args[1], props.args[2]],
      vertices: geometry.attributes.position.count
    });

    onBeforeUnmount(() => {
      if (geometryRef) {
        geometryRef.value = null;
      }
      debugLog('SphereGeometry', 'Disposing', {
        vertices: geometry.attributes.position.count
      });
      geometry.dispose();
    });

    return { geometry };
  }
});

// Update MeshStandardMaterial to connect with parent mesh
export const MeshStandardMaterial = defineComponent({
  name: 'MeshStandardMaterial',
  props: {
    color: {
      type: String,
      default: '#ffffff'
    },
    metalness: {
      type: Number,
      default: 0.1
    },
    roughness: {
      type: Number,
      default: 0.5
    },
    opacity: {
      type: Number,
      default: 1.0
    },
    transparent: {
      type: Boolean,
      default: false
    },
    emissive: {
      type: String,
      default: '#000000'
    },
    emissiveIntensity: {
      type: Number,
      default: 1.0
    }
  },
  setup(props) {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color(props.color),
      metalness: props.metalness,
      roughness: props.roughness,
      opacity: props.opacity,
      transparent: props.transparent,
      emissive: new THREE.Color(props.emissive),
      emissiveIntensity: props.emissiveIntensity
    });

    const materialRef = inject<Ref<THREE.Material | null>>(MATERIAL_REF);
    
    if (materialRef) {
      materialRef.value = material;
    }

    debugLog('MeshStandardMaterial', 'Created', {
      color: props.color,
      metalness: props.metalness,
      roughness: props.roughness,
      opacity: props.opacity,
      emissive: props.emissive,
      emissiveIntensity: props.emissiveIntensity
    });

    watch(() => props.color, (newColor) => {
      material.color.set(newColor);
      debugLog('MeshStandardMaterial', 'Color updated', { color: newColor });
    });

    watch(() => props.emissive, (newColor) => {
      material.emissive.set(newColor);
      debugLog('MeshStandardMaterial', 'Emissive updated', { emissive: newColor });
    });

    onBeforeUnmount(() => {
      if (materialRef) {
        materialRef.value = null;
      }
      debugLog('MeshStandardMaterial', 'Disposing', {
        color: material.color.getHexString(),
        emissive: material.emissive.getHexString()
      });
      material.dispose();
    });

    return { material };
  }
});

// Line component
export const Line = defineComponent({
  name: 'Line',
  props: {
    points: {
      type: Array as unknown as () => [THREE.Vector3, THREE.Vector3],
      required: true,
      validator: (value: unknown) => {
        if (!Array.isArray(value) || value.length !== 2) return false;
        return value.every(v => v instanceof THREE.Vector3);
      }
    },
    color: {
      type: String,
      default: '#ffffff'
    },
    linewidth: {
      type: Number,
      default: 1
    },
    opacity: {
      type: Number,
      default: 1
    },
    transparent: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const scene = inject(SCENE_KEY) as THREE.Scene | null;
    const parent = inject(PARENT_KEY, null) as THREE.Object3D | null;

    if (!scene && !parent) {
      throw new Error('Line must be used within a Scene or Group component');
    }

    const geometry = new THREE.BufferGeometry().setFromPoints(props.points);
    const material = new THREE.LineBasicMaterial({
      color: props.color,
      linewidth: props.linewidth,
      opacity: props.opacity,
      transparent: props.transparent
    });
    const line = new THREE.Line(geometry, material);

    onMounted(() => {
      if (parent) {
        parent.add(line);
      } else if (scene) {
        scene.add(line);
      }

      debugLog('Line', 'Added to scene', {
        points: props.points.map(p => p.toArray()),
        color: props.color,
        linewidth: props.linewidth,
        opacity: props.opacity,
        parent: parent?.type || 'Scene'
      });
    });

    watch(() => props.points, (newPoints) => {
      geometry.setFromPoints(newPoints);
      geometry.attributes.position.needsUpdate = true;
      debugLog('Line', 'Points updated', {
        points: newPoints.map(p => p.toArray())
      });
    });

    onBeforeUnmount(() => {
      debugLog('Line', 'Removing from scene', {
        points: props.points.map(p => p.toArray())
      });
      if (parent) {
        parent.remove(line);
      } else if (scene) {
        scene.remove(line);
      }
      geometry.dispose();
      material.dispose();
    });

    return { line };
  }
});

// Html component for labels
export const Html = defineComponent({
  name: 'Html',
  props: {
    position: {
      type: Object as () => THREE.Vector3,
      required: true
    },
    occlude: {
      type: Boolean,
      default: true
    },
    center: {
      type: Boolean,
      default: true
    },
    sprite: {
      type: Boolean,
      default: false
    },
    style: {
      type: Object as () => Record<string, string>,
      default: () => ({})
    }
  },
  setup(props, { slots }) {
    const container = ref<HTMLDivElement | null>(null);

    onMounted(() => {
      if (container.value) {
        const pos = props.position;
        container.value.style.transform = `translate3d(${pos.x}px, ${pos.y}px, ${pos.z}px)`;
        Object.assign(container.value.style, props.style);
        
        if (props.center) {
          container.value.style.transform += ' translate(-50%, -50%)';
        }

        debugLog('Html', 'Mounted', {
          position: [pos.x, pos.y, pos.z],
          center: props.center,
          occlude: props.occlude,
          sprite: props.sprite
        });
      }
    });

    watch(() => props.position, (newPos) => {
      if (container.value) {
        container.value.style.transform = `translate3d(${newPos.x}px, ${newPos.y}px, ${newPos.z}px)`;
        if (props.center) {
          container.value.style.transform += ' translate(-50%, -50%)';
        }
        debugLog('Html', 'Position updated', {
          position: [newPos.x, newPos.y, newPos.z]
        });
      }
    });

    return () => h('div', {
      ref: container,
      class: 'html-overlay',
      style: {
        position: 'absolute',
        pointerEvents: 'none',
        ...props.style
      }
    }, slots.default?.());
  }
});

// Export all components
export default {
  Scene,
  Mesh,
  SphereGeometry,
  MeshStandardMaterial,
  Line,
  Html
};

----
components/vr/VRControlPanel.vue
<template>
  <!-- This is a 3D component, so no template needed -->
</template>

<script lang="ts">
import { defineComponent, onMounted, onBeforeUnmount, ref } from 'vue';
import * as THREE from 'three';
import { useVisualizationStore } from '../../stores/visualization';
import { useSettingsStore } from '../../stores/settings';
import type { VisualizationConfig } from '../../types/components';

interface Props {
  scene: THREE.Scene;
  camera: THREE.Camera;
}

interface ControlChange {
  name: string;
  value: number | string;
}

interface Control {
  group: THREE.Group;
  min?: number;
  max?: number;
  value: number | string;
}

export default defineComponent({
  name: 'VRControlPanel',

  props: {
    scene: {
      type: Object as () => THREE.Scene,
      required: true
    },
    camera: {
      type: Object as () => THREE.Camera,
      required: true
    }
  },

  emits: {
    controlChange: (payload: ControlChange) => true
  },

  setup(props: Props, { emit }: { emit: (event: 'controlChange', payload: ControlChange) => void }) {
    const panel = ref<THREE.Group>(new THREE.Group());
    const controls = ref<Map<string, Control>>(new Map());
    const visualizationStore = useVisualizationStore();
    const settingsStore = useSettingsStore();

    const createTextTexture = (text: string): THREE.CanvasTexture => {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (!context) throw new Error('Could not get 2D context');

      canvas.width = 256;
      canvas.height = 64;
      context.font = '48px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 128, 32);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    };

    const mapValue = (value: number, inMin: number, inMax: number, outMin: number, outMax: number): number => {
      return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    };

    const initPanel = () => {
      // Create background panel
      const panelGeometry = new THREE.PlaneGeometry(1, 1.5);
      const panelMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x202020, 
        transparent: true, 
        opacity: 0.7 
      });
      const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
      panel.value.add(panelMesh);

      // Position panel in front of camera
      panel.value.position.set(0, 0, -2);
      panel.value.lookAt(props.camera.position);

      props.scene.add(panel.value);
    };

    const createSlider = (name: string, min: number, max: number, value: number, y: number) => {
      const sliderGroup = new THREE.Group();
      sliderGroup.name = name;

      // Create slider track
      const trackGeometry = new THREE.PlaneGeometry(0.8, 0.05);
      const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x505050 });
      const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
      sliderGroup.add(trackMesh);

      // Create slider handle
      const handleGeometry = new THREE.SphereGeometry(0.03);
      const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
      handleMesh.position.x = mapValue(value, min, max, -0.4, 0.4);
      sliderGroup.add(handleMesh);

      // Create label
      const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
      const labelMaterial = new THREE.MeshBasicMaterial({ 
        map: createTextTexture(name) 
      });
      const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
      labelMesh.position.set(-0.6, 0, 0);
      sliderGroup.add(labelMesh);

      sliderGroup.position.set(0, y, 0.01);
      panel.value.add(sliderGroup);
      controls.value.set(name, { group: sliderGroup, min, max, value });
    };

    const createColorPicker = (name: string, value: string, y: number) => {
      const pickerGroup = new THREE.Group();
      pickerGroup.name = name;

      // Create color swatch
      const swatchGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const swatchMaterial = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color(value) 
      });
      const swatchMesh = new THREE.Mesh(swatchGeometry, swatchMaterial);
      pickerGroup.add(swatchMesh);

      // Create label
      const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
      const labelMaterial = new THREE.MeshBasicMaterial({ 
        map: createTextTexture(name) 
      });
      const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
      labelMesh.position.set(-0.3, 0, 0);
      pickerGroup.add(labelMesh);

      pickerGroup.position.set(0, y, 0.01);
      panel.value.add(pickerGroup);
      controls.value.set(name, { group: pickerGroup, value });
    };

    const updateControl = (name: string, value: number | string) => {
      const control = controls.value.get(name);
      if (!control) return;

      if ('min' in control && 'max' in control && typeof value === 'number') {
        // Slider
        const handle = control.group.children[1];
        handle.position.x = mapValue(value, control.min!, control.max!, -0.4, 0.4);
      } else if (typeof value === 'string') {
        // Color picker
        const swatch = control.group.children[0] as THREE.Mesh;
        if (swatch.material instanceof THREE.MeshBasicMaterial) {
          swatch.material.color.set(value);
        }
      }
      control.value = value;
    };

    const handleInteraction = (intersection: THREE.Intersection) => {
      const controlName = intersection.object.parent?.name;
      if (!controlName) return null;

      const control = controls.value.get(controlName);
      if (!control) return null;

      if ('min' in control && 'max' in control) {
        // Slider
        const newValue = mapValue(intersection.point.x, -0.4, 0.4, control.min!, control.max!);
        updateControl(controlName, newValue);
        emit('controlChange', { name: controlName, value: newValue });
        return { name: controlName, value: newValue };
      } else {
        // Color picker
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        const currentIndex = colors.indexOf(parseInt(control.value as string));
        const newValue = colors[(currentIndex + 1) % colors.length];
        const hexValue = '#' + newValue.toString(16).padStart(6, '0');
        updateControl(controlName, hexValue);
        emit('controlChange', { name: controlName, value: hexValue });
        return { name: controlName, value: hexValue };
      }
    };

    onMounted(() => {
      initPanel();

      // Initialize controls based on current settings
      const settings = settingsStore.getVisualizationSettings;
      let yPosition = 0.6;

      // Add sliders
      createSlider('Scale', 0.1, 2.0, settings.min_node_size, yPosition);
      yPosition -= 0.2;
      createSlider('Opacity', 0, 1, settings.material.node_material_opacity, yPosition);
      yPosition -= 0.2;

      // Add color pickers
      createColorPicker('Node Color', settings.node_color, yPosition);
      yPosition -= 0.2;
      createColorPicker('Edge Color', settings.edge_color, yPosition);
    });

    onBeforeUnmount(() => {
      // Cleanup Three.js objects
      controls.value.forEach((control: Control) => {
        control.group.traverse((obj: THREE.Object3D) => {
          if (obj instanceof THREE.Mesh) {
            obj.geometry.dispose();
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => m.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
      });

      if (panel.value.parent) {
        panel.value.parent.remove(panel.value);
      }
    });

    return {
      panel,
      controls,
      handleInteraction,
      updateControl
    };
  }
});
</script>

----
components/visualization/BaseVisualization.vue
<template>
  <Renderer
    :antialias="true"
    :xr="platformInfo.hasXRSupport"
    :size="{ w: windowSize.width, h: windowSize.height }"
    ref="renderer"
  >
    <Scene ref="scene">
      <!-- Camera System -->
      <Camera
        :position="cameraPosition"
        :fov="75"
        :aspect="aspect"
        :near="0.1"
        :far="1000"
        ref="camera"
      />

      <!-- Lighting -->
      <AmbientLight :intensity="1.5" />
      <DirectionalLight
        :position="{ x: 10, y: 20, z: 10 }"
        :intensity="2.0"
        :cast-shadow="true"
      />
      <HemisphereLight
        :sky-color="0xffffff"
        :ground-color="0x444444"
        :intensity="1.5"
      />

      <!-- Graph Visualization -->
      <graph-system
        v-if="graphData"
        :nodes="graphData.nodes"
        :edges="graphData.edges"
        :settings="visualSettings"
      />

      <!-- XR Controllers and Hands -->
      <template v-if="platformInfo.isQuest">
        <xr-controllers />
        <xr-hands />
      </template>

      <!-- Effects -->
      <effects-system :settings="effectsSettings">
        <bloom v-if="effectsSettings.bloom.enabled" v-bind="effectsSettings.bloom" />
        <ssao v-if="effectsSettings.ssao.enabled" v-bind="effectsSettings.ssao" />
      </effects-system>
    </Scene>
  </Renderer>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted, onBeforeUnmount } from 'vue';
import { useSettingsStore } from '../../stores/settings';
import { usePlatform } from '../../composables/usePlatform';
import type { GraphData } from '../../types/core';
import { WebGLRenderer, Scene as ThreeScene, PerspectiveCamera } from 'three';
import {
  Renderer,
  Scene,
  Camera,
  AmbientLight,
  DirectionalLight,
  HemisphereLight
} from 'vue-threejs';

export default defineComponent({
  name: 'BaseVisualization',

  components: {
    Renderer,
    Scene,
    Camera,
    AmbientLight,
    DirectionalLight,
    HemisphereLight
  },

  setup() {
    // Refs for Three.js components
    const renderer = ref<WebGLRenderer | null>(null);
    const scene = ref<ThreeScene | null>(null);
    const camera = ref<PerspectiveCamera | null>(null);

    // Platform and settings
    const { getPlatformInfo } = usePlatform();
    const settingsStore = useSettingsStore();
    const platformInfo = computed(() => getPlatformInfo());

    // Window size reactive state
    const windowSize = ref({
      width: window.innerWidth,
      height: window.innerHeight
    });
    const aspect = computed(() => windowSize.value.width / windowSize.value.height);

    // Camera position with reactive updates
    const cameraPosition = ref({ x: 0, y: 75, z: 200 });

    // Graph data
    const graphData = ref<GraphData | null>(null);

    // Settings from store
    const visualSettings = computed(() => settingsStore.getVisualizationSettings);
    const effectsSettings = computed(() => ({
      bloom: settingsStore.getBloomSettings,
      ssao: {
        enabled: false,
        radius: 0.5,
        intensity: 1.0,
        bias: 0.5
      }
    }));

    // Window resize handler
    const handleResize = () => {
      windowSize.value = {
        width: window.innerWidth,
        height: window.innerHeight
      };
    };

    // Lifecycle hooks
    onMounted(() => {
      window.addEventListener('resize', handleResize);
      
      // Initialize platform-specific features
      if (platformInfo.value.isQuest) {
        initializeXR();
      }
    });

    onBeforeUnmount(() => {
      window.removeEventListener('resize', handleResize);
    });

    // XR initialization
    const initializeXR = async () => {
      if (!renderer.value || !platformInfo.value.hasXRSupport) return;

      try {
        const session = await navigator.xr?.requestSession('immersive-vr', {
          requiredFeatures: ['local-floor', 'bounded-floor'],
          optionalFeatures: ['hand-tracking']
        });

        if (session && renderer.value.xr) {
          await renderer.value.xr.setSession(session);
        }
      } catch (error) {
        console.error('Failed to initialize XR:', error);
      }
    };

    // Public methods
    const updateGraphData = (data: GraphData) => {
      graphData.value = data;
    };

    return {
      // Template refs
      renderer,
      scene,
      camera,

      // Computed properties
      platformInfo,
      windowSize,
      aspect,
      cameraPosition,
      graphData,
      visualSettings,
      effectsSettings,

      // Methods
      updateGraphData
    };
  }
});
</script>

<style scoped>
.renderer-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
</style>

----
components/visualization/GraphSystem.vue
<template>
  <div v-if="isReady && graphData">
    <!-- Graph Content -->
    <primitive :object="graphGroup" />
    <div v-if="process.env.NODE_ENV === 'development'" class="debug-info">
      Nodes: {{ graphData.nodes.length }} | Edges: {{ graphData.edges.length }}
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, watch, onMounted, inject } from 'vue';
import { Vector3, Vector2, Plane, Raycaster } from 'three';
import { useGraphSystem } from '../../composables/useGraphSystem';
import { useWebSocketStore } from '../../stores/websocket';
import { useBinaryUpdateStore } from '../../stores/binaryUpdate';
import { useVisualizationStore } from '../../stores/visualization';
import { useVisualization } from '../../composables/useVisualization';
import { usePlatform } from '../../composables/usePlatform';
import type { VisualizationConfig } from '../../types/components';
import type { GraphNode, GraphEdge, GraphData, CoreState } from '../../types/core';

export default defineComponent({
  name: 'GraphSystem',

  props: {
    visualSettings: {
      type: Object as () => VisualizationConfig,
      required: true
    }
  },

  setup(props) {
    // Get visualization state and composable
    const visualizationState = inject<{ value: CoreState }>('visualizationState');
    const visualization = useVisualization();
    
    const isReady = computed(() => {
      const ready = visualizationState?.value.scene != null && 
             visualizationState?.value.isInitialized === true;
      console.debug('Graph system ready state:', {
        hasScene: visualizationState?.value.scene != null,
        isInitialized: visualizationState?.value.isInitialized,
        ready,
        timestamp: new Date().toISOString()
      });
      return ready;
    });

    // Get platform info
    const { 
      getPlatformInfo, 
      enableVR, 
      enableAR, 
      disableXR,
      isXRActive,
      isVRActive,
      isARActive 
    } = usePlatform();
    
    const platformInfo = getPlatformInfo();

    // Initialize graph system
    const {
      graphGroup,
      hoveredNode,
      getNodePosition,
      getNodeScale,
      getNodeColor,
      getEdgePoints,
      getEdgeColor,
      getEdgeWidth,
      handleNodeClick,
      handleNodeHover,
      updateGraphData,
      updateNodePosition
    } = useGraphSystem();

    const websocketStore = useWebSocketStore();
    const binaryUpdateStore = useBinaryUpdateStore();
    const visualizationStore = useVisualizationStore();
    
    // Drag state
    const isDragging = ref(false);
    const draggedNode = ref<GraphNode | null>(null);
    const dragStartPosition = ref<Vector3 | null>(null);
    const dragPlane = ref<Plane | null>(null);
    const dragIntersection = new Vector3();

    // Graph data from store with enhanced debug logging
    const graphData = computed<GraphData>(() => {
      const data = visualizationStore.getGraphData || { nodes: [], edges: [], metadata: {} };
      console.debug('Graph data computed:', {
        nodes: data.nodes.length,
        edges: data.edges.length,
        hasMetadata: Object.keys(data.metadata || {}).length > 0,
        sampleNodes: data.nodes.slice(0, 3).map(n => ({
          id: n.id,
          hasPosition: !!n.position,
          edgeCount: n.edges?.length || 0
        })),
        timestamp: new Date().toISOString()
      });
      return data;
    });

    // Watch for ready state and request initial data
    watch(isReady, (ready) => {
      if (ready && !websocketStore.initialDataRequested) {
        console.debug('Graph system ready, requesting initial data');
        websocketStore.requestInitialData();
      }
    });

    // Watch for graph data changes with enhanced logging
    watch(() => graphData.value, (newData) => {
      if (newData && newData.nodes.length > 0) {
        console.debug('Graph data changed:', {
          nodes: newData.nodes.length,
          edges: newData.edges.length,
          sampleNode: newData.nodes[0] ? {
            id: newData.nodes[0].id,
            hasPosition: !!newData.nodes[0].position,
            edgeCount: newData.nodes[0].edges?.length || 0
          } : null,
          timestamp: new Date().toISOString()
        });
        
        // Use mergeGraphData to preserve client-side positions
        visualizationStore.mergeGraphData(newData);
        
        // Update graph system with merged data
        const graphDataToUpdate = visualizationStore.getGraphData || { nodes: [], edges: [], metadata: {} };
        updateGraphData(graphDataToUpdate);
        
        // Trigger layout update if needed
        visualization.updateLayoutPositions();
      }
    }, { deep: true });

    // Watch for binary updates with enhanced logging
    watch(() => binaryUpdateStore.getAllPositions, (positions) => {
      const nodeCount = positions.length / 3;
      if (nodeCount > 0 && !visualization.isInteracting.value) {
        console.debug('Processing binary position update:', {
          nodeCount,
          timestamp: new Date().toISOString()
        });
        
        // Update node positions using array indices
        graphData.value.nodes.forEach((node, index) => {
          const position = binaryUpdateStore.getNodePosition(index);
          const velocity = binaryUpdateStore.getNodeVelocity(index);
          
          if (position && velocity) {
            // Create Vector3 objects for position and velocity
            const pos = new Vector3(position[0], position[1], position[2]);
            const vel = new Vector3(velocity[0], velocity[1], velocity[2]);
            
            // Update both the graph system and the node data
            updateNodePosition(node.id, pos, vel);
            node.position = position;
            node.velocity = velocity;
          }
        });

        // Trigger graph update
        if (visualizationState?.value.scene) {
          visualizationState.value.scene.userData.needsRender = true;
        }
      }
    }, { deep: true });

    // Drag handlers with enhanced logging
    const onDragStart = (event: PointerEvent, node: GraphNode) => {
      console.debug('Starting node drag:', {
        nodeId: node.id,
        initialPosition: getNodePosition(node),
        timestamp: new Date().toISOString()
      });

      isDragging.value = true;
      draggedNode.value = node;

      const camera = visualizationState?.value.camera;
      if (!camera) return;

      const normal = new Vector3(0, 0, 1);
      normal.applyQuaternion(camera.quaternion);
      dragPlane.value = new Plane(normal, 0);
      dragStartPosition.value = getNodePosition(node).clone();

      // Start local force simulation
      visualization.startInteraction();

      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
      }
    };

    const onDragMove = (event: PointerEvent) => {
      if (!isDragging.value || !draggedNode.value || !dragPlane.value) return;

      const camera = visualizationState?.value.camera;
      if (!camera) return;

      const target = event.currentTarget as HTMLElement;
      const rect = target.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      const raycaster = new Raycaster();
      const pointer = new Vector2(x, y);
      raycaster.setFromCamera(pointer, camera);

      if (raycaster.ray.intersectPlane(dragPlane.value, dragIntersection)) {
        const node = draggedNode.value;
        const position = getNodePosition(node);
        position.copy(dragIntersection);

        // Update node position in visualization store
        visualizationStore.updateNode(node.id, {
          position: [position.x, position.y, position.z]
        });

        // Trigger layout update
        visualization.updateLayoutPositions();

        if (visualizationState?.value.scene) {
          visualizationState.value.scene.userData.needsRender = true;
        }
      }
    };

    const onDragEnd = () => {
      if (!isDragging.value || !draggedNode.value || !dragStartPosition.value) return;

      const finalPosition = getNodePosition(draggedNode.value);

      console.debug('Node drag ended:', {
        nodeId: draggedNode.value.id,
        startPosition: dragStartPosition.value.toArray(),
        finalPosition: finalPosition.toArray(),
        timestamp: new Date().toISOString()
      });

      // End local force simulation
      visualization.endInteraction();

      isDragging.value = false;
      draggedNode.value = null;
      dragStartPosition.value = null;
      dragPlane.value = null;

      if (visualizationState?.value.scene) {
        visualizationState.value.scene.userData.needsRender = true;
      }
    };

    // XR handlers
    const handleEnableAR = async () => {
      try {
        if (isARActive()) {
          await disableXR();
        } else {
          await enableAR();
        }
      } catch (err) {
        console.error('Failed to toggle AR:', err);
      }
    };

    const handleEnableVR = async () => {
      try {
        if (isVRActive()) {
          await disableXR();
        } else {
          await enableVR();
        }
      } catch (err) {
        console.error('Failed to toggle VR:', err);
      }
    };

    // Update graph data when component mounts
    onMounted(() => {
      console.debug('GraphSystem mounted, initialization state:', {
        isReady: isReady.value,
        hasGraphData: !!graphData.value,
        initialDataRequested: websocketStore.initialDataRequested,
        timestamp: new Date().toISOString()
      });
      
      if (graphData.value) {
        console.debug('Initial graph data update:', {
          nodes: graphData.value.nodes.length,
          edges: graphData.value.edges.length,
          timestamp: new Date().toISOString()
        });
        updateGraphData(graphData.value);
      }
    });

    return {
      isReady,
      platformInfo,
      isXRActive,
      isVRActive,
      isARActive,
      enableAR: handleEnableAR,
      enableVR: handleEnableVR,
      graphGroup,
      hoveredNode,
      isDragging,
      graphData,
      onDragStart,
      onDragMove,
      onDragEnd,
      process: {
        env: {
          NODE_ENV: process.env.NODE_ENV
        }
      }
    };
  }
});
</script>

<style scoped>
.debug-info {
  position: fixed;
  top: 40px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 5px 10px;
  border-radius: 4px;
  font-family: monospace;
  font-size: 12px;
  z-index: 1000;
}

.xr-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 10px;
  z-index: 1000;
}

.ar-button,
.vr-button {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.2s;
}

.ar-button {
  background: #4CAF50;
  color: white;
}

.ar-button:hover:not(:disabled) {
  background: #45a049;
}

.vr-button {
  background: #2196F3;
  color: white;
}

.vr-button:hover:not(:disabled) {
  background: #1976D2;
}

.ar-button:disabled,
.vr-button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  opacity: 0.65;
}
</style>

----
visualization/effects.js
import * as THREE from 'three';
import { BloomEffect } from './effects/BloomEffect.js';
import { CompositionEffect } from './effects/CompositionEffect.js';
import { LAYERS } from './layerManager.js';
import { visualizationSettings } from '../services/visualizationSettings.js';

export class EffectsManager {
    constructor(scene, camera, renderer) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to EffectsManager');
        }
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Store original renderer settings
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();
        this.originalAutoClear = this.renderer.autoClear;
        
        // Configure renderer for optimal performance
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        // Initialize effects
        this.bloomEffect = null;
        this.compositionEffect = null;
        this.initialized = false;
        this.pendingInitialization = true;
        
        // XR properties
        this.isXRActive = false;
        
        // Bind methods
        this.render = this.render.bind(this);
        this.handleResize = this.handleResize.bind(this);
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.dispose = this.dispose.bind(this);
        
        // Add event listeners
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }
    
    async initPostProcessing(isXR = false) {
        try {
            console.log('Starting post-processing initialization');
            if (!this.renderer || !this.renderer.domElement) {
                throw new Error('Renderer not ready for post-processing initialization');
            }

            // Wait for settings if needed
            if (this.pendingInitialization) {
                console.log('Waiting for settings before initializing effects...');
                return false;
            }

            // Clean up existing effects if reinitializing
            if (this.initialized) {
                this.dispose();
            }

            // Configure renderer
            this.renderer.autoClear = true;
            this.isXRActive = isXR;

            // Get settings from server
            const settings = visualizationSettings.getSettings();
            if (!settings?.bloom) {
                console.error('Bloom settings not available from server');
                return false;
            }

            // Initialize bloom effect with server settings
            this.bloomEffect = new BloomEffect(this.renderer, this.scene, this.camera);
            await this.bloomEffect.init(settings.bloom);

            // Initialize composition effect
            this.compositionEffect = new CompositionEffect(this.renderer);
            await this.compositionEffect.init(this.bloomEffect.getRenderTargets());
            
            this.initialized = true;
            console.log('Post-processing initialization complete with server settings');
            return true;
        } catch (error) {
            console.error('Error in post-processing initialization:', error);
            this.dispose();
            return false;
        }
    }

    handleXRSessionStart() {
        console.log('XR session started');
        this.isXRActive = true;
        if (this.initialized) {
            // Reinitialize effects for XR
            this.initPostProcessing(true);
        }
    }

    handleXRSessionEnd() {
        console.log('XR session ended');
        this.isXRActive = false;
        if (this.initialized) {
            // Reinitialize effects for non-XR
            this.initPostProcessing(false);
        }
    }
    
    render() {
        if (!this.initialized) {
            // Fallback to direct rendering if effects aren't initialized
            this.renderer.render(this.scene, this.camera);
            return;
        }

        try {
            const currentCamera = this.isXRActive ? this.renderer.xr.getCamera() : this.camera;
            
            // Render bloom passes
            if (this.bloomEffect) {
                this.bloomEffect.render(currentCamera);
            }

            // Render final composition
            if (this.compositionEffect) {
                const baseTexture = this.bloomEffect.getRenderTargets().get('base').texture;
                this.compositionEffect.render(baseTexture);
            }
        } catch (error) {
            console.error('Error during rendering:', error);
            // Fallback to direct rendering on error
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    handleResize(width = window.innerWidth, height = window.innerHeight) {
        if (!this.initialized) return;

        try {
            // Update renderer size
            this.renderer.setSize(width, height);

            // Update effect sizes
            if (this.bloomEffect) {
                this.bloomEffect.resize(width, height);
            }
            if (this.compositionEffect) {
                this.compositionEffect.resize(width, height);
            }
        } catch (error) {
            console.error('Error handling resize:', error);
        }
    }
    
    handleSettingsUpdate(event) {
        console.log('Received settings update:', event.detail);

        // If waiting for initial settings, initialize
        if (this.pendingInitialization) {
            this.pendingInitialization = false;
            this.initPostProcessing(this.isXRActive);
            return;
        }

        // Update existing effects with new settings
        if (!this.initialized) return;

        try {
            const settings = event.detail;
            
            if (settings.bloom && this.bloomEffect) {
                this.bloomEffect.updateSettings(settings.bloom);
                if (this.compositionEffect) {
                    this.compositionEffect.updateSettings(this.bloomEffect.getRenderTargets());
                }
            }

            if (settings.visualization?.material && this.bloomEffect) {
                this.bloomEffect.updateMaterialSettings(settings.visualization.material);
            }
        } catch (error) {
            console.error('Error handling settings update:', error);
        }
    }
    
    dispose() {
        // Remove event listeners
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);
        
        // Dispose effects
        if (this.bloomEffect) {
            this.bloomEffect.dispose();
            this.bloomEffect = null;
        }
        
        if (this.compositionEffect) {
            this.compositionEffect.dispose();
            this.compositionEffect = null;
        }
        
        // Restore renderer settings
        if (this.renderer) {
            this.renderer.autoClear = this.originalAutoClear;
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        this.initialized = false;
        this.isXRActive = false;
    }

    isInitialized() {
        return this.initialized;
    }

    isXREnabled() {
        return this.isXRActive;
    }
}

----
visualization/layout.js
export class LayoutManager {
    constructor(settings = {}) {
        // Configuration
        this.initialIterations = settings.iterations || 250;
        this.updateIterations = 1;       // Single iteration for smooth continuous updates
        this.targetRadius = 200;
        this.naturalLength = 100;
        this.attraction = settings.attraction_strength || 0.01;
        this.repulsion = settings.repulsion_strength || 1000;
        this.spring = settings.spring_strength || 0.1;
        this.damping = settings.damping || 0.8;
        
        // State
        this.isInitialized = false;
        this.isSimulating = false;
        this.animationFrameId = null;
        this.lastPositions = null;       // Store previous positions for change detection
        this.updateThreshold = 0.001;    // Minimum position change to trigger update
        this.lastUpdateTime = 0;         // Last time positions were sent to server
        this.updateInterval = 16.67;     // Exactly 60fps
        this.positionBuffer = null;
        this.edges = [];                 // Store computed edges
        this.nodeCount = 0;              // Track number of nodes
        this.waitingForInitialData = true; // Wait for initial data before sending updates

        // Debug logging
        console.debug('[LayoutManager] Initialized with settings:', {
            iterations: this.initialIterations,
            attraction: this.attraction,
            repulsion: this.repulsion,
            spring: this.spring,
            damping: this.damping
        });
    }

    initializePositions(nodes) {
        console.debug('[LayoutManager] Initializing positions for nodes:', {
            nodeCount: nodes.length,
            sample: nodes.slice(0, 3).map(n => ({ id: n.id, hasPosition: !isNaN(n.x) && !isNaN(n.y) && !isNaN(n.z) }))
        });
        
        this.nodeCount = nodes.length;
        nodes.forEach(node => {
            // Initialize only if positions are invalid
            if (isNaN(node.x) || isNaN(node.y) || isNaN(node.z)) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = this.targetRadius * Math.cbrt(Math.random());
                
                node.x = r * Math.sin(phi) * Math.cos(theta);
                node.y = r * Math.sin(phi) * Math.sin(theta);
                node.z = r * Math.cos(phi);

                console.debug(`[LayoutManager] Initialized position for node ${node.id}:`, {
                    x: node.x, y: node.y, z: node.z
                });
            }
            // Always ensure velocities are initialized
            if (!node.vx) node.vx = 0;
            if (!node.vy) node.vy = 0;
            if (!node.vz) node.vz = 0;
        });

        // Initialize last positions with velocities
        this.lastPositions = nodes.map(node => ({
            x: node.x,
            y: node.y,
            z: node.z,
            vx: node.vx,
            vy: node.vy,
            vz: node.vz
        }));

        this.isInitialized = true;
        this.waitingForInitialData = false; // Initial data received
        console.debug('[LayoutManager] Position initialization complete');

        // Send initial positions to server
        this.sendPositionUpdates(nodes);
    }

    applyForceDirectedLayout(nodes, edges) {
        if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
            console.warn('[LayoutManager] Invalid nodes array provided to force-directed layout');
            return;
        }

        if (!this.isInitialized || this.waitingForInitialData) {
            console.warn('[LayoutManager] Layout manager not initialized or waiting for initial data');
            return;
        }

        console.debug('[LayoutManager] Applying force-directed layout:', {
            nodeCount: nodes.length,
            edgeCount: edges.length,
            isInitialized: this.isInitialized,
            waitingForInitialData: this.waitingForInitialData
        });

        const dt = 0.1;

        // Apply forces based on edges (topic counts)
        edges.forEach(edge => {
            const sourceNode = nodes.find(n => n.id === edge.source);
            const targetNode = nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                // Calculate spring force based on topic counts
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dz = targetNode.z - sourceNode.z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) return;

                // Use edge weight (from topic counts) to scale the force
                const force = (distance - this.naturalLength) * this.spring * (edge.weight || 1);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                // Apply forces to both nodes
                sourceNode.vx += fx * this.attraction;
                sourceNode.vy += fy * this.attraction;
                sourceNode.vz += fz * this.attraction;
                targetNode.vx -= fx * this.attraction;
                targetNode.vy -= fy * this.attraction;
                targetNode.vz -= fz * this.attraction;
            }
        });

        // Apply repulsion between all nodes
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dz = nodes[j].z - nodes[i].z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) continue;

                const force = this.repulsion / (distance * distance);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                nodes[i].vx -= fx;
                nodes[i].vy -= fy;
                nodes[i].vz -= fz;
                nodes[j].vx += fx;
                nodes[j].vy += fy;
                nodes[j].vz += fz;
            }
        }

        // Update positions and apply damping
        nodes.forEach(node => {
            // Apply current velocity
            node.x += node.vx * dt;
            node.y += node.vy * dt;
            node.z += node.vz * dt;

            // Apply damping
            node.vx *= this.damping;
            node.vy *= this.damping;
            node.vz *= this.damping;

            // Bound checking with detailed logging for out-of-bounds
            const bound = 500;
            if (Math.abs(node.x) > bound) {
                console.debug(`[LayoutManager] Node ${node.id} X position out of bounds:`, node.x);
                node.vx *= -0.5;
            }
            if (Math.abs(node.y) > bound) {
                console.debug(`[LayoutManager] Node ${node.id} Y position out of bounds:`, node.y);
                node.vy *= -0.5;
            }
            if (Math.abs(node.z) > bound) {
                console.debug(`[LayoutManager] Node ${node.id} Z position out of bounds:`, node.z);
                node.vz *= -0.5;
            }
        });
    }

    updateFeature(control, value) {
        console.debug(`[LayoutManager] Updating layout feature: ${control} = ${value}`);
        
        // Convert from forceDirected prefixed names to internal parameter names
        const paramMap = {
            'forceDirectedIterations': 'iterations',
            'forceDirectedSpring': 'spring_strength',
            'forceDirectedRepulsion': 'repulsion_strength',
            'forceDirectedAttraction': 'attraction_strength',
            'forceDirectedDamping': 'damping'
        };

        const paramName = paramMap[control] || control;
        switch(paramName) {
            case 'iterations':
                this.initialIterations = value;
                break;
            case 'spring_strength':
                this.spring = value;
                break;
            case 'repulsion_strength':
                this.repulsion = value;
                break;
            case 'attraction_strength':
                this.attraction = value;
                break;
            case 'damping':
                this.damping = value;
                break;
            default:
                console.warn(`[LayoutManager] Unknown layout parameter: ${control}`);
        }
    }

    updatePhysics(settings) {
        console.debug('[LayoutManager] Updating physics settings:', settings);
        
        // Update all physics parameters at once
        if (settings.iterations !== undefined) {
            this.initialIterations = settings.iterations;
        }
        if (settings.spring_strength !== undefined) {
            this.spring = settings.spring_strength;
        }
        if (settings.repulsion_strength !== undefined) {
            this.repulsion = settings.repulsion_strength;
        }
        if (settings.attraction_strength !== undefined) {
            this.attraction = settings.attraction_strength;
        }
        if (settings.damping !== undefined) {
            this.damping = settings.damping;
        }

        // If simulation is running, apply new settings immediately
        if (this.isSimulating) {
            console.debug('[LayoutManager] Applying new physics settings to running simulation');
        }
    }

    performLayout(graphData) {
        if (!this.isInitialized || !graphData || this.waitingForInitialData) {
            console.warn('[LayoutManager] Cannot perform layout:', {
                isInitialized: this.isInitialized,
                hasGraphData: !!graphData,
                waitingForInitialData: this.waitingForInitialData
            });
            return;
        }

        const now = Date.now();
        if (now - this.lastUpdateTime >= this.updateInterval) {
            // Apply force-directed layout
            this.applyForceDirectedLayout(graphData.nodes, graphData.edges);
            
            // Send position updates
            this.sendPositionUpdates(graphData.nodes);
            this.lastUpdateTime = now;
        }
    }

    sendPositionUpdates(nodes) {
        // Validate node count consistency
        if (nodes.length !== this.nodeCount) {
            console.error('[LayoutManager] Node count mismatch:', {
                expected: this.nodeCount,
                received: nodes.length
            });
            return;
        }

        // Validate initialization state
        if (!this.lastPositions || !this.isInitialized || this.waitingForInitialData) {
            console.warn('[LayoutManager] Cannot send position updates:', {
                hasLastPositions: !!this.lastPositions,
                isInitialized: this.isInitialized,
                waitingForInitialData: this.waitingForInitialData
            });
            return;
        }

        // Create binary buffer for all node positions and velocities (24 bytes per node)
        const buffer = new ArrayBuffer(nodes.length * 24);
        const dataView = new Float32Array(buffer);
        let hasChanges = false;

        // Debug log for buffer initialization
        console.debug('[LayoutManager] Initializing position update buffer:', {
            totalSize: buffer.byteLength,
            nodeCount: nodes.length,
            bytesPerNode: 24
        });

        nodes.forEach((node, index) => {
            // Validate node position values
            if (isNaN(node.x) || isNaN(node.y) || isNaN(node.z)) {
                console.error(`[LayoutManager] Invalid position values for node ${node.id}:`, {
                    x: node.x, y: node.y, z: node.z
                });
                return;
            }

            const offset = index * 6;
            const lastPos = this.lastPositions[index];

            // Position change detection
            const positionChanged = !lastPos || 
                Math.abs(node.x - lastPos.x) > this.updateThreshold ||
                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
                Math.abs(node.z - lastPos.z) > this.updateThreshold ||
                Math.abs(node.vx - lastPos.vx) > this.updateThreshold ||
                Math.abs(node.vy - lastPos.vy) > this.updateThreshold ||
                Math.abs(node.vz - lastPos.vz) > this.updateThreshold;

            if (positionChanged) {
                hasChanges = true;
                
                // Log significant position changes
                console.debug(`[LayoutManager] Significant position change for node ${node.id}:`, {
                    current: { x: node.x, y: node.y, z: node.z, vx: node.vx, vy: node.vy, vz: node.vz },
                    previous: lastPos ? { x: lastPos.x, y: lastPos.y, z: lastPos.z, vx: lastPos.vx, vy: lastPos.vy, vz: lastPos.vz } : null
                });

                // Update last position and velocity
                if (lastPos) {
                    lastPos.x = node.x;
                    lastPos.y = node.y;
                    lastPos.z = node.z;
                    lastPos.vx = node.vx;
                    lastPos.vy = node.vy;
                    lastPos.vz = node.vz;
                }

                // Position (vec3<f32>)
                dataView[offset] = node.x;
                dataView[offset + 1] = node.y;
                dataView[offset + 2] = node.z;

                // Velocity (vec3<f32>)
                dataView[offset + 3] = node.vx || 0;
                dataView[offset + 4] = node.vy || 0;
                dataView[offset + 5] = node.vz || 0;
            }
        });

        if (hasChanges) {
            // Log the final buffer state
            console.debug('[LayoutManager] Sending position update:', {
                bufferSize: buffer.byteLength,
                nodeCount: nodes.length,
                hasChanges
            });
            
            // Dispatch binary data event
            window.dispatchEvent(new CustomEvent('positionUpdate', {
                detail: buffer
            }));
        }
    }

    startContinuousSimulation(graphData) {
        if (this.isSimulating) return;
        
        console.debug('[LayoutManager] Starting continuous simulation:', {
            nodeCount: graphData.nodes.length,
            edgeCount: graphData.edges.length
        });
        
        this.isSimulating = true;
        const animate = () => {
            if (!this.isSimulating) return;
            
            // Send position updates at regular intervals
            this.performLayout(graphData);
            this.animationFrameId = requestAnimationFrame(animate);
        };
        
        animate();
    }

    stopSimulation() {
        console.debug('[LayoutManager] Stopping simulation');
        this.isSimulating = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
}

----
visualization/nodes.js
import * as THREE from 'three';
import { visualizationSettings } from '../services/visualizationSettings.js';
import { LAYERS, LAYER_GROUPS, LayerManager } from './layerManager.js';
import { TextRenderer } from './textRenderer.js';

/**
 * NodeManager handles the efficient rendering and updating of nodes and edges in the graph visualization.
 * It uses THREE.js InstancedMesh for performance and supports both regular updates and binary position updates.
 */
export class NodeManager {
    constructor(scene, camera, settings = {}) {
        // Core references
        this.scene = scene;
        this.camera = camera;
        
        // Data structures
        this.nodeData = new Map();          // Stores node data
        this.labelPool = new Map();         // Reusable label sprites
        this.instanceIds = new Map();       // Maps positions to node IDs
        
        // Rendering structures
        this.nodeInstancedMeshes = null;    // Different LOD meshes for nodes
        this.edgeInstancedMesh = null;      // Single mesh for all edges
        this.instancedContainer = null;      // Container for all instanced meshes
        
        // Binary update optimization
        this.instancePositions = new Float32Array(30000);  // Pre-allocated for position updates
        this.instanceSizes = new Float32Array(10000);      // Pre-allocated for size updates
        this._labelUpdateTimeout = null;                   // For throttling label updates
        
        // Reusable objects for matrix operations
        this.matrix = new THREE.Matrix4();
        this.quaternion = new THREE.Quaternion();
        this.position = new THREE.Vector3();
        this.scale = new THREE.Vector3();
        this.color = new THREE.Color();

        // Text renderer for labels
        this.textRenderer = new TextRenderer();
        
        // Initialize settings
        this.initializeSettings(settings);
        
        // Create container and initialize meshes
        this.instancedContainer = new THREE.Group();
        this.instancedContainer.name = 'instancedContainer';
        this.scene.add(this.instancedContainer);
        
        // Initialize instanced meshes
        this.initInstancedMeshes();
        
        // Set up label rendering
        this.initializeLabelRenderer();
        
        // Bind methods
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.updateNodePositions = this.updateNodePositions.bind(this);
        
        // Add event listeners
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
    }

    /**
     * Creates or updates a label for a node
     */
    createNodeLabel(nodeId, node) {
        let label = this.labelPool.get(nodeId);
        
        // Create label text with metadata
        let labelText = node.label || nodeId;
        if (node.metadata && Object.keys(node.metadata).length > 0) {
            labelText += '\n' + Object.entries(node.metadata)
                .map(([key, value]) => `${key}: ${value}`)
                .join('\n');
        }

        // Create or update label sprite
        if (!label) {
            label = this.textRenderer.createTextSprite(labelText, {
                fontSize: this.labelFontSize,
                color: 0xffffff,
                backgroundColor: 0x000000,
                backgroundOpacity: 0.85
            });
            
            // Make label always face camera
            label.material.depthWrite = false;
            label.material.depthTest = false;
            label.renderOrder = 1;
            
            this.labelPool.set(nodeId, label);
            this.scene.add(label);
        } else {
            // Update existing label
            const newSprite = this.textRenderer.createTextSprite(labelText, {
                fontSize: this.labelFontSize,
                color: 0xffffff,
                backgroundColor: 0x000000,
                backgroundOpacity: 0.85
            });
            
            // Update material and texture
            if (label.material) {
                if (label.material.map) label.material.map.dispose();
                label.material.dispose();
            }
            label.material = newSprite.material;
            label.scale.copy(newSprite.scale);
        }

        // Position label above node
        const nodeSize = this.getNodeSize(node.metadata || {});
        const pos = new THREE.Vector3(node.x, node.y, node.z);
        label.position.copy(pos).add(new THREE.Vector3(0, nodeSize * 1.5, 0));
        
        // Make label face camera
        label.quaternion.copy(this.camera.quaternion);
        
        return label;
    }

    /**
     * Updates labels for all nodes
     */
    updateLabels() {
        this.nodeData.forEach((node, nodeId) => {
            this.createNodeLabel(nodeId, node);
        });
    }

    /**
     * Handles binary position updates from WebSocket
     */
    updateNodePositions(positions) {
        if (!this.nodeInstancedMeshes) return;

        const matrix = this.matrix;
        const position = this.position;
        const quaternion = this.quaternion;
        const updatedNodes = new Set();

        // Update positions in batches
        for (let i = 0; i < positions.length; i++) {
            const nodeId = Array.from(this.nodeData.keys())[i];
            if (!nodeId) continue;

            const pos = positions[i];
            const node = this.nodeData.get(nodeId);
            
            // Update node data
            node.x = pos[0];
            node.y = pos[1];
            node.z = pos[2];
            node.vx = pos[3];
            node.vy = pos[4];
            node.vz = pos[5];

            // Update instance matrix
            position.set(pos[0], pos[1], pos[2]);
            const size = this.getNodeSize(node.metadata || {});
            this.scale.set(size, size, size);
            matrix.compose(position, quaternion, this.scale);

            // Update appropriate LOD mesh
            const distance = this.camera.position.distanceTo(position);
            let targetMesh;
            if (distance < 50) targetMesh = this.nodeInstancedMeshes.high;
            else if (distance < 100) targetMesh = this.nodeInstancedMeshes.medium;
            else targetMesh = this.nodeInstancedMeshes.low;

            targetMesh.setMatrixAt(i, matrix);

            // Track updates
            updatedNodes.add(nodeId);

            // Update instance lookup data
            const posIndex = i * 3;
            this.instancePositions[posIndex] = pos[0];
            this.instancePositions[posIndex + 1] = pos[1];
            this.instancePositions[posIndex + 2] = pos[2];
            this.instanceIds.set(`${[pos[0], pos[1], pos[2]]}`, nodeId);

            // Update label position
            const label = this.labelPool.get(nodeId);
            if (label) {
                label.position.copy(position).add(new THREE.Vector3(0, size * 1.5, 0));
                label.quaternion.copy(this.camera.quaternion);
            }
        }

        // Update instance matrices
        Object.values(this.nodeInstancedMeshes).forEach(mesh => {
            mesh.instanceMatrix.needsUpdate = true;
        });

        // Update edges and labels
        if (updatedNodes.size > 0) {
            this.updateEdgesForNodes(updatedNodes);
            this.throttledLabelUpdate(updatedNodes);
        }
    }

    /**
     * Updates edges connected to moved nodes
     * @param {Set<string>} updatedNodes - Set of node IDs that moved
     */
    updateEdgesForNodes(updatedNodes) {
        if (!this.edgeInstancedMesh) return;

        const matrix = this.matrix;
        const position = this.position;
        const quaternion = this.quaternion;
        const scale = this.scale;
        let edgeIndex = 0;

        // Update only affected edges
        this.nodeData.forEach((sourceNode, sourceId) => {
            this.nodeData.forEach((targetNode, targetId) => {
                if (sourceId === targetId) return;
                if (!updatedNodes.has(sourceId) && !updatedNodes.has(targetId)) return;

                const start = new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z);
                const end = new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z);
                const direction = end.clone().sub(start);
                const length = direction.length();

                if (length === 0) return;

                // Update edge transform
                const center = start.clone().add(end).multiplyScalar(0.5);
                position.copy(center);
                direction.normalize();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                scale.set(0.15, length, 0.15);

                matrix.compose(position, quaternion, scale);
                this.edgeInstancedMesh.setMatrixAt(edgeIndex++, matrix);
            });
        });

        this.edgeInstancedMesh.count = edgeIndex;
        this.edgeInstancedMesh.instanceMatrix.needsUpdate = true;
    }

    /**
     * Throttled label update to improve performance
     * @param {Set<string>} updatedNodes - Set of node IDs that need label updates
     */
    throttledLabelUpdate(updatedNodes) {
        if (this._labelUpdateTimeout) return;

        this._labelUpdateTimeout = setTimeout(() => {
            updatedNodes.forEach(nodeId => {
                const node = this.nodeData.get(nodeId);
                if (!node) return;

                const label = this.labelPool.get(nodeId);
                if (label) {
                    const size = this.getNodeSize(node.metadata || {});
                    label.position.set(node.x, node.y + size * 1.5, node.z);
                    label.visible = true;
                }
            });
            this._labelUpdateTimeout = null;
        }, 100);
    }

    dispose() {
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        window.removeEventListener('xrsessionstart', () => this.handleXRStateChange(true));
        window.removeEventListener('xrsessionend', () => this.handleXRStateChange(false));
        
        if (this.xrController) {
            this.xrController.removeEventListener('select', this.handleXRSelect);
            this.scene.remove(this.xrController);
        }

        Object.values(this.nodeInstancedMeshes).forEach(mesh => {
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
            this.instancedContainer.remove(mesh);
        });

        if (this.edgeInstancedMesh) {
            if (this.edgeInstancedMesh.geometry) this.edgeInstancedMesh.geometry.dispose();
            if (this.edgeInstancedMesh.material) this.edgeInstancedMesh.material.dispose();
            this.instancedContainer.remove(this.edgeInstancedMesh);
        }

        this.labelPool.forEach(label => {
            if (label.material) {
                if (label.material.map) label.material.map.dispose();
                label.material.dispose();
            }
            this.scene.remove(label);
        });

        this.scene.remove(this.instancedContainer);
        
        this.nodeData.clear();
        this.labelPool.clear();
        this.instanceIds.clear();
    }
}

----
visualization/core.js
// Previous imports unchanged...
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { NodeManager } from './nodes.js';
import { EffectsManager } from './effects.js';
import { visualizationSettings } from '../services/visualizationSettings.js';
import { initXRSession, addXRButton, handleXRSession } from '../xr/xrSetup.js';
import { initXRInteraction } from '../xr/xrInteraction.js';

// Constants for input sensitivity
const TRANSLATION_SPEED = 0.01;
const ROTATION_SPEED = 0.01;
const VR_MOVEMENT_SPEED = 0.05;

export class WebXRVisualization {
    constructor(graphDataManager) {
        console.log('WebXRVisualization constructor called with graphDataManager:', !!graphDataManager);
        if (!graphDataManager) {
            throw new Error('GraphDataManager is required for WebXRVisualization');
        }
        this.graphDataManager = graphDataManager;

        // Wait for settings before initializing
        this.initialized = false;
        this.pendingInitialization = true;

        // Store references that will be initialized once settings are received
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.nodeManager = null;
        this.controls = null;
        this.xrSessionManager = null;
        this.canvas = null;

        // Position tracking
        this.nodePositions = new Map();
        this.positionBuffer = null;

        // Bind methods
        this.onWindowResize = this.onWindowResize.bind(this);
        this.animate = this.animate.bind(this);
        this.updateVisualization = this.updateVisualization.bind(this);
        this.handleSpacemouseInput = this.handleSpacemouseInput.bind(this);
        this.renderFrame = this.renderFrame.bind(this);
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        this.handleBinaryUpdate = this.handleBinaryUpdate.bind(this);

        // Add event listeners
        window.addEventListener('binaryPositionUpdate', this.handleBinaryUpdate);
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
    }

    handleBinaryUpdate(event) {
        if (!this.initialized || !this.nodeManager) return;

        const { positions } = event.detail;
        
        // Update position cache
        this.nodeManager.nodes.forEach((node, index) => {
            if (positions[index]) {
                const pos = positions[index];
                // Update node position directly
                node.position.set(pos[0], pos[1], pos[2]);
                // Cache position for quick access
                this.nodePositions.set(node.id, {
                    position: [pos[0], pos[1], pos[2]],
                    velocity: [pos[3], pos[4], pos[5]]
                });
            }
        });

        // Update edges if needed (they might need to follow node positions)
        if (this.nodeManager.updateEdgePositions) {
            this.nodeManager.updateEdgePositions();
        }
    }

    updateVisualization(data) {
        if (!this.nodeManager || !data) {
            console.warn('Cannot update visualization: missing manager or data');
            return;
        }

        console.log(`Updating visualization with ${data.nodes?.length || 0} nodes and ${data.edges?.length || 0} edges`);

        // Handle full graph updates (structure changes)
        if (data.nodes || data.edges) {
            if (Array.isArray(data.nodes)) {
                console.log('Updating nodes');
                this.nodeManager.updateNodes(data.nodes);
                // Update position cache
                data.nodes.forEach(node => {
                    this.nodePositions.set(node.id, {
                        position: [node.x, node.y, node.z],
                        velocity: [node.vx || 0, node.vy || 0, node.vz || 0]
                    });
                });
            }
            
            if (Array.isArray(data.edges)) {
                console.log('Updating edges');
                this.nodeManager.updateEdges(data.edges);
            }
        }
    }

    async initializeXR() {
        try {
            // Enable XR on renderer
            this.renderer.xr.enabled = true;

            // Initialize XR session manager
            this.xrSessionManager = await initXRSession(this.renderer, this.scene, this.camera);
            
            if (this.xrSessionManager) {
                // Add XR button to the scene
                await addXRButton(this.xrSessionManager);
                console.log('XR initialization complete');
            } else {
                console.warn('XR not supported or initialization failed');
            }
        } catch (error) {
            console.error('Error initializing XR:', error);
        }
    }

    renderFrame() {
        // Update controls if not in XR mode
        if (this.controls && (!this.xrSessionManager || !this.renderer.xr.isPresenting)) {
            this.controls.update();
        }

        // Update XR session if active
        if (this.xrSessionManager && this.renderer.xr.isPresenting) {
            this.xrSessionManager.update();
        }

        // Update node labels using cached positions
        if (this.nodeManager) {
            this.nodeManager.updateLabelOrientations(this.camera);
        }

        // Render scene
        this.renderer.render(this.scene, this.camera);
    }

    animate() {
        // Use requestAnimationFrame for non-XR rendering
        if (!this.renderer.xr.isPresenting) {
            requestAnimationFrame(this.animate);
            this.renderFrame();
        }
    }

    initializeSettings() {
        console.log('Initializing settings');
        
        const settings = visualizationSettings.getSettings();
        if (!settings?.visualization) {
            console.warn('No visualization settings available');
            return;
        }

        const vis = settings.visualization;
        
        // Add strong ambient light for better visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        this.scene.add(ambientLight);

        // Add directional light for shadows and highlights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
        directionalLight.position.set(10, 20, 10);
        this.scene.add(directionalLight);

        // Add hemisphere light for better ambient illumination
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        this.scene.add(hemisphereLight);

        // Add point lights for better illumination
        const pointLight1 = new THREE.PointLight(0xffffff, 1.0, 300);
        pointLight1.position.set(100, 100, 100);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1.0, 300);
        pointLight2.position.set(-100, -100, -100);
        this.scene.add(pointLight2);

        // Set fog from settings
        this.scene.fog = new THREE.FogExp2(0x000000, vis.fog_density);

        console.log('Scene settings initialized with settings from server');
    }

    onWindowResize() {
        if (this.camera && this.renderer && this.canvas) {
            // Update canvas size
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            
            // Update camera
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            
            // Update renderer
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    setupEventListeners() {
        console.log('Setting up event listeners');
        
        window.addEventListener('graphDataUpdated', (event) => {
            console.log('Received graphDataUpdated event:', event.detail);
            if (event.detail && Array.isArray(event.detail.nodes)) {
                this.updateVisualization(event.detail);
            } else {
                console.warn('Invalid graph data in event:', event.detail);
            }
        });

        window.addEventListener('resize', this.onWindowResize);
    }

    handleSpacemouseInput(x, y, z) {
        if (!this.camera) return;

        this.camera.position.x += x * TRANSLATION_SPEED;
        this.camera.position.y += y * TRANSLATION_SPEED;
        this.camera.position.z += z * TRANSLATION_SPEED;

        if (this.controls) {
            this.controls.target.copy(this.camera.position).add(
                new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion)
            );
            this.controls.update();
        }
    }

    dispose() {
        console.log('Disposing WebXRVisualization');
        
        // Remove event listeners
        window.removeEventListener('binaryPositionUpdate', this.handleBinaryUpdate);
        window.removeEventListener('resize', this.onWindowResize);
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);

        // Clear position cache
        this.nodePositions.clear();
        this.positionBuffer = null;

        // Clean up renderer
        this.renderer.setAnimationLoop(null);

        // Clean up managers
        if (this.nodeManager) {
            this.nodeManager.dispose();
        }

        // Clean up DOM elements
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }

        // Dispose of Three.js resources
        if (this.renderer) {
            this.renderer.dispose();
        }

        if (this.controls) {
            this.controls.dispose();
        }

        console.log('WebXRVisualization disposed');
    }
}

----
visualization/textRenderer.js
import * as THREE from 'three';

// SDF font atlas generation
function generateSDFData(text, fontSize, padding) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size to power of 2 for better texture performance
    const size = Math.pow(2, Math.ceil(Math.log2(fontSize * 2 + padding * 2)));
    canvas.width = size;
    canvas.height = size;
    
    // Setup font
    ctx.font = `${fontSize}px Arial`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    
    // Draw text
    ctx.fillStyle = 'white';
    ctx.fillText(text, size/2, size/2);
    
    // Generate SDF
    const imageData = ctx.getImageData(0, 0, size, size);
    const sdf = new Float32Array(size * size);
    
    // Calculate SDF values
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            const alpha = imageData.data[idx + 3] / 255;
            
            // Calculate distance field
            let minDist = Number.MAX_VALUE;
            const maxSearchDist = fontSize / 2;
            
            for (let sy = -maxSearchDist; sy <= maxSearchDist; sy++) {
                for (let sx = -maxSearchDist; sx <= maxSearchDist; sx++) {
                    const sampX = x + sx;
                    const sampY = y + sy;
                    
                    if (sampX >= 0 && sampX < size && sampY >= 0 && sampY < size) {
                        const sampIdx = (sampY * size + sampX) * 4;
                        const sampAlpha = imageData.data[sampIdx + 3] / 255;
                        
                        if (sampAlpha !== alpha) {
                            const dist = Math.sqrt(sx*sx + sy*sy);
                            minDist = Math.min(minDist, dist);
                        }
                    }
                }
            }
            
            // Normalize and store SDF value
            sdf[y * size + x] = alpha === 1 ? minDist / maxSearchDist : -minDist / maxSearchDist;
        }
    }
    
    return {
        data: sdf,
        size: size,
        texture: new THREE.DataTexture(
            sdf,
            size,
            size,
            THREE.RedFormat,
            THREE.FloatType
        )
    };
}

export class TextRenderer {
    constructor() {
        // SDF shader for high-quality text rendering
        this.material = new THREE.ShaderMaterial({
            uniforms: {
                sdfTexture: { value: null },
                color: { value: new THREE.Color(0xffffff) },
                smoothing: { value: 0.25 },
                threshold: { value: 0.5 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D sdfTexture;
                uniform vec3 color;
                uniform float smoothing;
                uniform float threshold;
                varying vec2 vUv;
                
                void main() {
                    float sdf = texture2D(sdfTexture, vUv).r;
                    float alpha = smoothstep(threshold - smoothing, threshold + smoothing, sdf);
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });
    }
    
    createTextSprite(text, options = {}) {
        const {
            fontSize = 32,
            padding = 8,
            color = 0xffffff,
            backgroundColor = 0x000000,
            backgroundOpacity = 0.85
        } = options;
        
        // Generate SDF data
        const sdfData = generateSDFData(text, fontSize, padding);
        
        // Create geometry
        const geometry = new THREE.PlaneGeometry(1, 1);
        
        // Update material with new texture
        const material = this.material.clone();
        material.uniforms.sdfTexture.value = sdfData.texture;
        material.uniforms.color.value = new THREE.Color(color);
        
        // Create mesh
        const mesh = new THREE.Mesh(geometry, material);
        
        // Add background plane if needed
        if (backgroundOpacity > 0) {
            const bgGeometry = new THREE.PlaneGeometry(1.1, 1.1);
            const bgMaterial = new THREE.MeshBasicMaterial({
                color: backgroundColor,
                transparent: true,
                opacity: backgroundOpacity,
                depthWrite: false
            });
            const background = new THREE.Mesh(bgGeometry, bgMaterial);
            background.position.z = -0.001;
            mesh.add(background);
        }
        
        // Scale mesh based on texture size
        const scale = fontSize / sdfData.size;
        mesh.scale.set(sdfData.size * scale, sdfData.size * scale, 1);
        
        return mesh;
    }
    
    dispose() {
        this.material.dispose();
    }
}

----
visualization/layerManager.js
import * as THREE from 'three';

// Layer constants for rendering pipeline
export const LAYERS = {
    NORMAL_LAYER: 0,  // Base layer for regular rendering
    BLOOM: 1,        // Layer for node bloom effects
    HOLOGRAM: 2,     // Layer for hologram effects
    EDGE: 3,         // Layer for edge bloom effects
    LABEL: 4         // Layer for labels
};

// Simplified layer groups - everything visible on normal layer
export const LAYER_GROUPS = {
    // Base scene elements
    BASE: [LAYERS.NORMAL_LAYER],
    
    // Nodes
    BLOOM: [LAYERS.NORMAL_LAYER],
    
    // Hologram elements
    HOLOGRAM: [LAYERS.NORMAL_LAYER],
    
    // Edge elements
    EDGE: [LAYERS.NORMAL_LAYER],
    
    // Label elements
    LABEL: [LAYERS.NORMAL_LAYER]
};

// Simplified material presets for basic rendering
const MATERIAL_PRESETS = {
    BLOOM: {
        transparent: true,
        opacity: 1.0,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    },
    HOLOGRAM: {
        transparent: true,
        opacity: 0.8,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    },
    EDGE: {
        transparent: true,
        opacity: 0.8,
        blending: THREE.NormalBlending,
        depthWrite: true,
        toneMapped: true
    }
};

// Enhanced LayerManager with simplified rendering
export const LayerManager = {
    // Enable multiple layers for an object
    enableLayers(object, layers) {
        if (!object || !object.layers) {
            console.error('Invalid object provided to enableLayers');
            return;
        }

        // Always enable normal layer
        object.layers.set(LAYERS.NORMAL_LAYER);
    },

    // Set object to specific layer group with basic material settings
    setLayerGroup(object, groupName) {
        if (!object || !object.layers) {
            console.error('Invalid object provided to setLayerGroup');
            return;
        }

        // Always set to normal layer for visibility
        object.layers.set(LAYERS.NORMAL_LAYER);

        // Apply basic material presets if object has material
        if (object.material && MATERIAL_PRESETS[groupName]) {
            // Clone material to avoid affecting other objects
            if (!object.material._isCloned) {
                object.material = object.material.clone();
                object.material._isCloned = true;
            }
            
            // Apply basic preset properties
            Object.assign(object.material, MATERIAL_PRESETS[groupName]);
            
            // Ensure material is visible and properly rendered
            object.material.needsUpdate = true;
        }
    },

    // Check if object is in layer
    isInLayer(object, layer) {
        if (!object || !object.layers || typeof layer !== 'number') {
            return false;
        }
        return object.layers.test(new THREE.Layers().set(layer));
    },

    // Get all objects in a specific layer
    getObjectsInLayer(scene, layer, options = {}) {
        if (!scene || typeof layer !== 'number') {
            console.error('Invalid parameters provided to getObjectsInLayer');
            return [];
        }

        const objects = [];
        const {
            includeInvisible = false,
            includeHelpers = false
        } = options;

        scene.traverse(object => {
            if (this.isInLayer(object, layer)) {
                if (!includeInvisible && !object.visible) return;
                if (!includeHelpers && object.isHelper) return;
                objects.push(object);
            }
        });
        return objects;
    },

    // Reset object to base layer with standard material
    resetToBaseLayer(object) {
        if (!object || !object.layers) return;
        
        object.layers.set(LAYERS.NORMAL_LAYER);
        
        if (object.material && object.material._isCloned) {
            object.material.dispose();
            object.material = new THREE.MeshStandardMaterial({
                color: object.material.color,
                transparent: true,
                opacity: 1.0,
                toneMapped: true
            });
            object.material._isCloned = false;
        }
    },

    // Create a standard material
    createStandardMaterial(color) {
        return new THREE.MeshStandardMaterial({
            color: color,
            transparent: true,
            opacity: 1.0,
            toneMapped: true,
            depthWrite: true,
            blending: THREE.NormalBlending
        });
    }
};

----
visualization/effects/BloomEffect.js
import * as THREE from 'three';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { LAYERS } from '../layerManager.js';

export class BloomEffect {
    constructor(renderer, scene, camera) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to BloomEffect');
        }
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.composers = new Map();
        this.renderTargets = new Map();
        this.xrRenderTargets = new Map();
        this.initialized = false;
        this.isXRActive = false;

        // Store original renderer state
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();

        // Bind XR session change handlers
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);

        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }

    handleXRSessionStart() {
        this.isXRActive = true;
        // Create XR-specific render targets if needed
        if (this.initialized) {
            this.createXRRenderTargets();
        }
    }

    handleXRSessionEnd() {
        this.isXRActive = false;
        // Clean up XR render targets
        this.xrRenderTargets.forEach(target => {
            if (target && target.dispose) {
                target.dispose();
            }
        });
        this.xrRenderTargets.clear();
    }

    createRenderTarget(isXR = false) {
        let width, height;
        
        if (isXR && this.renderer.xr.getSession()) {
            const glProperties = this.renderer.properties.get(this.renderer.xr.getSession());
            const renderWidth = glProperties?.renderWidth || window.innerWidth * 2;
            const renderHeight = glProperties?.renderHeight || window.innerHeight;
            width = renderWidth;
            height = renderHeight;
        } else {
            const pixelRatio = this.renderer.getPixelRatio();
            width = Math.floor(window.innerWidth * pixelRatio);
            height = Math.floor(window.innerHeight * pixelRatio);
        }

        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        return new THREE.WebGLRenderTarget(
            width,
            height,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType,
                colorSpace: isWebGL2 ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace,
                stencilBuffer: false,
                depthBuffer: true,
                samples: isWebGL2 ? 4 : 0
            }
        );
    }

    createXRRenderTargets() {
        const layers = [LAYERS.BLOOM, LAYERS.HOLOGRAM, LAYERS.EDGE];
        
        // Create base XR render target
        const baseTarget = this.createRenderTarget(true);
        this.xrRenderTargets.set('base', baseTarget);

        // Create XR render targets for each layer
        layers.forEach(layer => {
            const renderTarget = this.createRenderTarget(true);
            this.xrRenderTargets.set(layer, renderTarget);
        });
    }

    init(settings) {
        if (!settings) {
            console.error('No bloom settings provided');
            return;
        }

        if (this.initialized) {
            this.dispose();
        }

        if (!this.renderer || !this.renderer.domElement) {
            console.error('Renderer not ready for bloom effect initialization');
            return;
        }

        // Create base render target for scene
        const baseTarget = this.createRenderTarget();
        this.renderTargets.set('base', baseTarget);

        // Create XR render targets if in XR mode
        if (this.isXRActive) {
            this.createXRRenderTargets();
        }

        // Adjust settings based on WebGL version and XR state
        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        let adjustedSettings = { ...settings };

        if (!isWebGL2) {
            // Reduce quality for WebGL1
            adjustedSettings = {
                ...adjustedSettings,
                node_bloom_strength: settings.node_bloom_strength * 0.8,
                node_bloom_radius: settings.node_bloom_radius * 0.7,
                edge_bloom_strength: settings.edge_bloom_strength * 0.8,
                edge_bloom_radius: settings.edge_bloom_radius * 0.7,
                environment_bloom_strength: settings.environment_bloom_strength * 0.8,
                environment_bloom_radius: settings.environment_bloom_radius * 0.7
            };
        }

        if (this.isXRActive) {
            // Adjust bloom for XR
            adjustedSettings = {
                ...adjustedSettings,
                node_bloom_strength: adjustedSettings.node_bloom_strength * 1.2,
                node_bloom_radius: adjustedSettings.node_bloom_radius * 0.8,
                edge_bloom_strength: adjustedSettings.edge_bloom_strength * 1.2,
                edge_bloom_radius: adjustedSettings.edge_bloom_radius * 0.8
            };
        }

        const layers = [
            {
                layer: LAYERS.BLOOM,
                settings: {
                    strength: adjustedSettings.node_bloom_strength,
                    radius: adjustedSettings.node_bloom_radius,
                    threshold: adjustedSettings.node_bloom_threshold
                }
            },
            {
                layer: LAYERS.HOLOGRAM,
                settings: {
                    strength: adjustedSettings.environment_bloom_strength,
                    radius: adjustedSettings.environment_bloom_radius,
                    threshold: adjustedSettings.environment_bloom_threshold
                }
            },
            {
                layer: LAYERS.EDGE,
                settings: {
                    strength: adjustedSettings.edge_bloom_strength,
                    radius: adjustedSettings.edge_bloom_radius,
                    threshold: adjustedSettings.edge_bloom_threshold
                }
            }
        ];

        try {
            // Set renderer color space based on WebGL version
            this.renderer.outputColorSpace = isWebGL2 ? 
                THREE.LinearSRGBColorSpace : 
                THREE.SRGBColorSpace;

            // Create composers for both regular and XR rendering
            this.createComposers(layers, false); // Regular composers
            if (this.isXRActive) {
                this.createComposers(layers, true); // XR composers
            }

            this.initialized = true;
        } catch (error) {
            console.error('Error initializing bloom effect:', error);
            this.dispose();
        }
    }

    updateSettings(settings) {
        if (!this.initialized || !settings) return;

        try {
            const layers = [
                {
                    layer: LAYERS.BLOOM,
                    settings: {
                        strength: settings.node_bloom_strength,
                        radius: settings.node_bloom_radius,
                        threshold: settings.node_bloom_threshold
                    }
                },
                {
                    layer: LAYERS.HOLOGRAM,
                    settings: {
                        strength: settings.environment_bloom_strength,
                        radius: settings.environment_bloom_radius,
                        threshold: settings.environment_bloom_threshold
                    }
                },
                {
                    layer: LAYERS.EDGE,
                    settings: {
                        strength: settings.edge_bloom_strength,
                        radius: settings.edge_bloom_radius,
                        threshold: settings.edge_bloom_threshold
                    }
                }
            ];

            // Update bloom passes in composers
            layers.forEach(({ layer, settings }) => {
                const composer = this.composers.get(layer.toString());
                if (composer) {
                    const bloomPass = composer.passes.find(pass => pass instanceof UnrealBloomPass);
                    if (bloomPass) {
                        bloomPass.strength = settings.strength;
                        bloomPass.radius = settings.radius;
                        bloomPass.threshold = settings.threshold;
                    }
                }

                // Update XR composers if active
                if (this.isXRActive) {
                    const xrComposer = this.composers.get(`xr_${layer}`);
                    if (xrComposer) {
                        const bloomPass = xrComposer.passes.find(pass => pass instanceof UnrealBloomPass);
                        if (bloomPass) {
                            bloomPass.strength = settings.strength * 1.2; // Adjust for XR
                            bloomPass.radius = settings.radius * 0.8; // Adjust for XR
                            bloomPass.threshold = settings.threshold;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error updating bloom settings:', error);
        }
    }

    createComposers(layers, isXR) {
        const targets = isXR ? this.xrRenderTargets : this.renderTargets;
        const composerPrefix = isXR ? 'xr_' : '';

        // Create base composer
        const baseComposer = new EffectComposer(this.renderer, targets.get('base'));
        const baseRenderPass = new RenderPass(this.scene, this.camera);
        baseRenderPass.clear = true;
        baseComposer.addPass(baseRenderPass);
        this.composers.set(`${composerPrefix}base`, baseComposer);

        // Create bloom composers for each layer
        layers.forEach(({ layer, settings }) => {
            const composer = new EffectComposer(this.renderer, targets.get(layer));
            composer.renderToScreen = false;
            
            const renderPass = new RenderPass(this.scene, this.camera);
            renderPass.clear = true;
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(
                    targets.get(layer).width,
                    targets.get(layer).height
                ),
                settings.strength,
                settings.radius,
                settings.threshold
            );
            
            bloomPass.highQualityBloom = this.renderer.capabilities.isWebGL2;
            bloomPass.gammaCorrectionInShader = this.renderer.capabilities.isWebGL2;
            
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            
            this.composers.set(`${composerPrefix}${layer}`, composer);
        });
    }

    render(currentCamera) {
        if (!this.initialized || !currentCamera) return;

        try {
            const isXRFrame = this.renderer.xr.isPresenting;
            const composerPrefix = isXRFrame ? 'xr_' : '';
            
            // Store original camera layers
            const originalLayerMask = currentCamera.layers.mask;

            // Render base scene first
            currentCamera.layers.set(LAYERS.NORMAL_LAYER);
            this.composers.get(`${composerPrefix}base`).render();

            // Render bloom layers
            this.composers.forEach((composer, key) => {
                if (key.startsWith(composerPrefix) && !key.endsWith('base')) {
                    const layer = parseInt(key.split('_').pop());
                    currentCamera.layers.set(layer);
                    composer.render();
                }
            });

            // Restore camera layers
            currentCamera.layers.mask = originalLayerMask;
        } catch (error) {
            console.error('Error rendering bloom effect:', error);
        }
    }

    resize(width, height) {
        if (!this.initialized) return;

        const pixelRatio = this.renderer.getPixelRatio();
        const actualWidth = Math.floor(width * pixelRatio);
        const actualHeight = Math.floor(height * pixelRatio);

        // Resize regular render targets and composers
        this.renderTargets.forEach(target => {
            if (target && target.setSize) {
                target.setSize(actualWidth, actualHeight);
            }
        });
        
        this.composers.forEach((composer, key) => {
            if (!key.startsWith('xr_') && composer && composer.setSize) {
                composer.setSize(actualWidth, actualHeight);
            }
        });

        // Don't resize XR targets - they're managed by the XR system
    }

    dispose() {
        // Remove event listeners
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);

        // Dispose render targets
        this.renderTargets.forEach(target => {
            if (target && target.dispose) target.dispose();
        });
        
        this.xrRenderTargets.forEach(target => {
            if (target && target.dispose) target.dispose();
        });
        
        // Dispose composers
        this.composers.forEach(composer => {
            if (composer && composer.dispose) composer.dispose();
        });
        
        // Reset renderer state
        if (this.renderer) {
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        // Clear collections
        this.renderTargets.clear();
        this.xrRenderTargets.clear();
        this.composers.clear();
        this.initialized = false;
        this.isXRActive = false;
    }

    getRenderTargets() {
        if (!this.initialized) return null;
        return this.isXRActive ? this.xrRenderTargets : this.renderTargets;
    }
}

----
visualization/effects/CompositionEffect.js
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { LAYERS } from '../layerManager.js';
import { visualizationSettings } from '../../services/visualizationSettings.js';

export class CompositionEffect {
    constructor(renderer) {
        if (!renderer || !renderer.domElement) {
            throw new Error('Invalid renderer provided to CompositionEffect');
        }
        this.renderer = renderer;
        this.composer = null;
        this.xrComposer = null;
        this.initialized = false;
        this.isXRActive = false;

        // Store original renderer state
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();

        // Bind XR session handlers
        this.handleXRSessionStart = this.handleXRSessionStart.bind(this);
        this.handleXRSessionEnd = this.handleXRSessionEnd.bind(this);

        window.addEventListener('xrsessionstart', this.handleXRSessionStart);
        window.addEventListener('xrsessionend', this.handleXRSessionEnd);
    }

    handleXRSessionStart() {
        this.isXRActive = true;
        if (this.initialized) {
            // Create XR-specific composer if needed
            this.createXRComposer();
        }
    }

    handleXRSessionEnd() {
        this.isXRActive = false;
        if (this.xrComposer) {
            this.xrComposer.dispose();
            this.xrComposer = null;
        }
    }

    createRenderTarget(isXR = false) {
        let width, height;
        
        if (isXR && this.renderer.xr.getSession()) {
            const glProperties = this.renderer.properties.get(this.renderer.xr.getSession());
            const renderWidth = glProperties?.renderWidth || window.innerWidth * 2;
            const renderHeight = glProperties?.renderHeight || window.innerHeight;
            width = renderWidth;
            height = renderHeight;
        } else {
            const pixelRatio = this.renderer.getPixelRatio();
            width = Math.floor(window.innerWidth * pixelRatio);
            height = Math.floor(window.innerHeight * pixelRatio);
        }

        const isWebGL2 = this.renderer.capabilities.isWebGL2;
        return new THREE.WebGLRenderTarget(
            width,
            height,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType,
                colorSpace: isWebGL2 ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace,
                stencilBuffer: false,
                depthBuffer: true,
                samples: isWebGL2 ? 4 : 0
            }
        );
    }

    createCompositionShader(isXR = false) {
        // Get bloom settings from server
        const settings = visualizationSettings.getBloomSettings();
        if (!settings) {
            console.warn('No bloom settings available, using defaults');
        }

        return {
            uniforms: {
                baseTexture: { value: null },
                bloomTexture0: { value: null },
                bloomTexture1: { value: null },
                bloomTexture2: { value: null },
                bloomStrength0: { value: settings?.node_bloom_strength || 1.5 },
                bloomStrength1: { value: settings?.environment_bloom_strength || 1.2 },
                bloomStrength2: { value: settings?.edge_bloom_strength || 0.8 },
                exposure: { value: isXR ? 1.0 : 1.2 },
                gamma: { value: 2.2 },
                saturation: { value: isXR ? 1.1 : 1.2 },
                isXR: { value: isXR ? 1.0 : 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D baseTexture;
                uniform sampler2D bloomTexture0;
                uniform sampler2D bloomTexture1;
                uniform sampler2D bloomTexture2;
                uniform float bloomStrength0;
                uniform float bloomStrength1;
                uniform float bloomStrength2;
                uniform float exposure;
                uniform float gamma;
                uniform float saturation;
                uniform float isXR;
                
                varying vec2 vUv;

                vec3 adjustSaturation(vec3 color, float saturation) {
                    float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
                    return mix(vec3(luminance), color, saturation);
                }

                vec3 toneMap(vec3 color) {
                    // ACES filmic tone mapping
                    float a = 2.51;
                    float b = 0.03;
                    float c = 2.43;
                    float d = 0.59;
                    float e = 0.14;
                    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
                }

                void main() {
                    // Adjust UV for XR if needed
                    vec2 adjustedUV = vUv;
                    if (isXR > 0.5) {
                        // Handle stereo rendering
                        adjustedUV.x = adjustedUV.x * 0.5;
                        if (gl_FragCoord.x > gl_FragCoord.w) {
                            adjustedUV.x += 0.5;
                        }
                    }
                    
                    // Sample all textures in linear space
                    vec3 baseColor = texture2D(baseTexture, adjustedUV).rgb;
                    vec3 bloom0 = texture2D(bloomTexture0, adjustedUV).rgb * bloomStrength0;
                    vec3 bloom1 = texture2D(bloomTexture1, adjustedUV).rgb * bloomStrength1;
                    vec3 bloom2 = texture2D(bloomTexture2, adjustedUV).rgb * bloomStrength2;
                    
                    // Combine bloom layers
                    vec3 bloomSum = bloom0 + bloom1 + bloom2;
                    
                    // Add bloom to base color
                    vec3 hdrColor = baseColor + bloomSum;
                    
                    // Apply exposure
                    hdrColor *= exposure;
                    
                    // Tone mapping
                    vec3 color = toneMap(hdrColor);
                    
                    // Adjust saturation
                    color = adjustSaturation(color, saturation);
                    
                    // Gamma correction
                    color = pow(color, vec3(1.0 / gamma));
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };
    }

    createComposer(bloomRenderTargets, isXR = false) {
        const renderTarget = this.createRenderTarget(isXR);
        const composer = new EffectComposer(this.renderer, renderTarget);

        const shader = this.createCompositionShader(isXR);
        shader.uniforms.baseTexture.value = bloomRenderTargets.get('base').texture;
        shader.uniforms.bloomTexture0.value = bloomRenderTargets.get(LAYERS.BLOOM).texture;
        shader.uniforms.bloomTexture1.value = bloomRenderTargets.get(LAYERS.HOLOGRAM).texture;
        shader.uniforms.bloomTexture2.value = bloomRenderTargets.get(LAYERS.EDGE).texture;

        const finalPass = new ShaderPass(new THREE.ShaderMaterial(shader));
        finalPass.renderToScreen = true;
        finalPass.clear = false;
        composer.addPass(finalPass);

        return composer;
    }

    init(bloomRenderTargets) {
        try {
            if (this.initialized) {
                this.dispose();
            }

            if (!bloomRenderTargets) {
                throw new Error('No bloom render targets provided');
            }

            // Verify all required textures are available
            const requiredLayers = [LAYERS.BLOOM, LAYERS.HOLOGRAM, LAYERS.EDGE];
            requiredLayers.forEach(layer => {
                const target = bloomRenderTargets.get(layer);
                if (!target || !target.texture) {
                    throw new Error(`Missing bloom render target for layer ${layer}`);
                }
            });

            // Create regular composer
            this.composer = this.createComposer(bloomRenderTargets, false);

            // Create XR composer if in XR mode
            if (this.isXRActive) {
                this.createXRComposer(bloomRenderTargets);
            }

            this.initialized = true;
        } catch (error) {
            console.error('Error initializing composition effect:', error);
            this.dispose();
        }
    }

    updateSettings(bloomRenderTargets) {
        if (!this.initialized) return;

        try {
            const settings = visualizationSettings.getBloomSettings();
            if (!settings) return;

            // Update regular composer
            if (this.composer) {
                const finalPass = this.composer.passes[0];
                if (finalPass && finalPass.uniforms) {
                    finalPass.uniforms.bloomStrength0.value = settings.node_bloom_strength;
                    finalPass.uniforms.bloomStrength1.value = settings.environment_bloom_strength;
                    finalPass.uniforms.bloomStrength2.value = settings.edge_bloom_strength;
                }
            }

            // Update XR composer
            if (this.xrComposer) {
                const finalPass = this.xrComposer.passes[0];
                if (finalPass && finalPass.uniforms) {
                    finalPass.uniforms.bloomStrength0.value = settings.node_bloom_strength * 1.2;
                    finalPass.uniforms.bloomStrength1.value = settings.environment_bloom_strength * 1.2;
                    finalPass.uniforms.bloomStrength2.value = settings.edge_bloom_strength * 1.2;
                }
            }
        } catch (error) {
            console.error('Error updating composition settings:', error);
        }
    }

    createXRComposer(bloomRenderTargets) {
        if (!this.renderer.xr.getSession()) return;
        this.xrComposer = this.createComposer(bloomRenderTargets, true);
    }

    render(baseTexture) {
        if (!this.initialized) return;

        try {
            const activeComposer = this.isXRActive ? this.xrComposer : this.composer;
            if (!activeComposer) return;

            const finalPass = activeComposer.passes[0];
            if (finalPass && finalPass.uniforms) {
                finalPass.uniforms.baseTexture.value = baseTexture;
                activeComposer.render();
            }
        } catch (error) {
            console.error('Error rendering composition effect:', error);
        }
    }

    resize(width, height) {
        if (!this.initialized) return;

        try {
            const pixelRatio = this.renderer.getPixelRatio();
            const actualWidth = Math.floor(width * pixelRatio);
            const actualHeight = Math.floor(height * pixelRatio);
            
            // Only resize non-XR composer
            if (this.composer) {
                this.composer.setSize(actualWidth, actualHeight);
            }
        } catch (error) {
            console.error('Error resizing composition effect:', error);
        }
    }

    dispose() {
        // Remove event listeners
        window.removeEventListener('xrsessionstart', this.handleXRSessionStart);
        window.removeEventListener('xrsessionend', this.handleXRSessionEnd);

        // Dispose composers
        if (this.composer) {
            this.composer.dispose();
            this.composer = null;
        }
        
        if (this.xrComposer) {
            this.xrComposer.dispose();
            this.xrComposer = null;
        }
        
        if (this.renderer) {
            this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        }
        
        this.initialized = false;
        this.isXRActive = false;
    }
}

----
stores/binaryUpdate.ts
import { defineStore } from 'pinia'
import type { BinaryMessage } from '../types/websocket'
import { logError, logWarn, logData } from '../utils/debug_log'
import {
  BINARY_UPDATE_NODE_SIZE,
  FLOAT32_SIZE,
  MAX_VALID_POSITION,
  MIN_VALID_POSITION,
  MAX_VALID_VELOCITY,
  MIN_VALID_VELOCITY,
  ENABLE_POSITION_VALIDATION,
  UPDATE_THROTTLE_MS,
  POSITION_CHANGE_THRESHOLD,
  VELOCITY_CHANGE_THRESHOLD
} from '../constants/websocket'

// Maximum array size to prevent memory issues
const MAX_ARRAY_SIZE = 1000000

interface BinaryUpdateState {
  positions: Float32Array
  velocities: Float32Array
  previousPositions: Float32Array
  previousVelocities: Float32Array
  nodeCount: number
  lastUpdateTime: number
  invalidUpdates: number
  pendingUpdate: boolean
  lastThrottledUpdate: number
  changedNodes: Set<number>
  positionChangeThreshold: number
  velocityChangeThreshold: number
}

export const useBinaryUpdateStore = defineStore('binaryUpdate', {
  state: (): BinaryUpdateState => ({
    positions: new Float32Array(0),
    velocities: new Float32Array(0),
    previousPositions: new Float32Array(0),
    previousVelocities: new Float32Array(0),
    nodeCount: 0,
    lastUpdateTime: 0,
    invalidUpdates: 0,
    pendingUpdate: false,
    lastThrottledUpdate: 0,
    changedNodes: new Set(),
    positionChangeThreshold: POSITION_CHANGE_THRESHOLD,
    velocityChangeThreshold: VELOCITY_CHANGE_THRESHOLD
  }),

  getters: {
    getNodePosition: (state) => (index: number): [number, number, number] | undefined => {
      if (index >= 0 && index < state.nodeCount) {
        const baseIndex = index * 3;
        return [
          state.positions[baseIndex],
          state.positions[baseIndex + 1],
          state.positions[baseIndex + 2]
        ];
      }
      return undefined;
    },

    getNodeVelocity: (state) => (index: number): [number, number, number] | undefined => {
      if (index >= 0 && index < state.nodeCount) {
        const baseIndex = index * 3;
        return [
          state.velocities[baseIndex],
          state.velocities[baseIndex + 1],
          state.velocities[baseIndex + 2]
        ];
      }
      return undefined;
    },

    getAllPositions: (state): Float32Array => state.positions,
    getAllVelocities: (state): Float32Array => state.velocities,
    getChangedNodes: (state): Set<number> => state.changedNodes
  },

  actions: {
    _validatePosition(value: number): boolean {
      return !isNaN(value) && isFinite(value) && 
             value >= MIN_VALID_POSITION && value <= MAX_VALID_POSITION;
    },

    _validateVelocity(value: number): boolean {
      return !isNaN(value) && isFinite(value) &&
             value >= MIN_VALID_VELOCITY && value <= MAX_VALID_VELOCITY;
    },

    _clampPosition(value: number): number {
      if (isNaN(value) || !isFinite(value)) return 0;
      return Math.max(MIN_VALID_POSITION, Math.min(MAX_VALID_POSITION, value));
    },

    _clampVelocity(value: number): number {
      if (isNaN(value) || !isFinite(value)) return 0;
      return Math.max(MIN_VALID_VELOCITY, Math.min(MAX_VALID_VELOCITY, value));
    },

    _hasSignificantChange(
      newPos: [number, number, number],
      oldPos: [number, number, number],
      newVel: [number, number, number],
      oldVel: [number, number, number]
    ): boolean {
      return (
        Math.abs(newPos[0] - oldPos[0]) > this.positionChangeThreshold ||
        Math.abs(newPos[1] - oldPos[1]) > this.positionChangeThreshold ||
        Math.abs(newPos[2] - oldPos[2]) > this.positionChangeThreshold ||
        Math.abs(newVel[0] - oldVel[0]) > this.velocityChangeThreshold ||
        Math.abs(newVel[1] - oldVel[1]) > this.velocityChangeThreshold ||
        Math.abs(newVel[2] - oldVel[2]) > this.velocityChangeThreshold
      )
    },

    _validateBuffer(buffer: ArrayBuffer): boolean {
      if (buffer.byteLength % FLOAT32_SIZE !== 0) {
        logError('Buffer not aligned to float32:', {
          byteLength: buffer.byteLength,
          alignment: FLOAT32_SIZE
        });
        return false;
      }

      const floatCount = buffer.byteLength / FLOAT32_SIZE;
      if (floatCount > MAX_ARRAY_SIZE) {
        logError('Buffer exceeds maximum size:', {
          floatCount,
          maxSize: MAX_ARRAY_SIZE
        });
        return false;
      }

      try {
        new Float32Array(buffer);
      } catch (error) {
        logError('Failed to create Float32Array view:', error);
        return false;
      }

      return true;
    },

    updateNodePosition(
      index: number,
      x: number, y: number, z: number,
      vx: number, vy: number, vz: number
    ): void {
      const now = Date.now();
      
      // Throttle updates to 5 FPS
      if (now - this.lastThrottledUpdate < UPDATE_THROTTLE_MS) {
        this.pendingUpdate = true;
        return;
      }

      if (index >= 0 && index < this.nodeCount) {
        const posIndex = index * 3;
        const velIndex = index * 3;

        const oldPos: [number, number, number] = [
          this.previousPositions[posIndex],
          this.previousPositions[posIndex + 1],
          this.previousPositions[posIndex + 2]
        ];
        const oldVel: [number, number, number] = [
          this.previousVelocities[velIndex],
          this.previousVelocities[velIndex + 1],
          this.previousVelocities[velIndex + 2]
        ];

        if (ENABLE_POSITION_VALIDATION) {
          const positionsValid = [x, y, z].every(v => this._validatePosition(v));
          const velocitiesValid = [vx, vy, vz].every(v => this._validateVelocity(v));

          if (!positionsValid || !velocitiesValid) {
            this.invalidUpdates++;
            logWarn('Invalid position/velocity values detected:', {
              index,
              position: [x, y, z],
              velocity: [vx, vy, vz]
            });

            x = this._clampPosition(x);
            y = this._clampPosition(y);
            z = this._clampPosition(z);
            vx = this._clampVelocity(vx);
            vy = this._clampVelocity(vy);
            vz = this._clampVelocity(vz);
          }
        }

        const newPos: [number, number, number] = [x, y, z];
        const newVel: [number, number, number] = [vx, vy, vz];

        if (this._hasSignificantChange(newPos, oldPos, newVel, oldVel)) {
          this.positions[posIndex] = x;
          this.positions[posIndex + 1] = y;
          this.positions[posIndex + 2] = z;

          this.velocities[velIndex] = vx;
          this.velocities[velIndex + 1] = vy;
          this.velocities[velIndex + 2] = vz;

          this.changedNodes.add(index);
        }

        this.lastUpdateTime = now;
        this.lastThrottledUpdate = now;
        this.pendingUpdate = false;
      }
    },

    updateFromBinary(message: BinaryMessage): void {
      const now = Date.now();
      
      // Throttle updates to 5 FPS
      if (now - this.lastThrottledUpdate < UPDATE_THROTTLE_MS) {
        this.pendingUpdate = true;
        return;
      }

      if (!this._validateBuffer(message.data)) {
        return;
      }

      const dataView = new Float32Array(message.data);
      const nodeCount = dataView.length / 6;

      if (nodeCount * BINARY_UPDATE_NODE_SIZE !== message.data.byteLength) {
        logError('Binary message size mismatch:', {
          received: message.data.byteLength,
          expected: nodeCount * BINARY_UPDATE_NODE_SIZE,
          nodeCount
        });
        return;
      }

      if (nodeCount > MAX_ARRAY_SIZE / 6) {
        logError('Excessive node count:', {
          nodeCount,
          maxNodes: MAX_ARRAY_SIZE / 6
        });
        return;
      }

      if (this.nodeCount !== nodeCount) {
        try {
          this.positions = new Float32Array(nodeCount * 3);
          this.velocities = new Float32Array(nodeCount * 3);
          this.previousPositions = new Float32Array(nodeCount * 3);
          this.previousVelocities = new Float32Array(nodeCount * 3);
          this.nodeCount = nodeCount;
        } catch (error) {
          logError('Failed to allocate arrays:', {
            nodeCount,
            error: error instanceof Error ? error.message : String(error)
          });
          return;
        }
      }

      this.previousPositions.set(this.positions);
      this.previousVelocities.set(this.velocities);
      this.changedNodes.clear();

      for (let i = 0; i < nodeCount; i++) {
        const srcOffset = i * 6;
        const posOffset = i * 3;
        const velOffset = i * 3;

        let x = dataView[srcOffset];
        let y = dataView[srcOffset + 1];
        let z = dataView[srcOffset + 2];
        let vx = dataView[srcOffset + 3];
        let vy = dataView[srcOffset + 4];
        let vz = dataView[srcOffset + 5];

        if (ENABLE_POSITION_VALIDATION) {
          const positionsValid = [x, y, z].every(v => this._validatePosition(v));
          const velocitiesValid = [vx, vy, vz].every(v => this._validateVelocity(v));

          if (!positionsValid || !velocitiesValid) {
            this.invalidUpdates++;
            logWarn('Invalid values in binary update:', {
              index: i,
              position: [x, y, z],
              velocity: [vx, vy, vz]
            });

            x = this._clampPosition(x);
            y = this._clampPosition(y);
            z = this._clampPosition(z);
            vx = this._clampVelocity(vx);
            vy = this._clampVelocity(vy);
            vz = this._clampVelocity(vz);
          }
        }

        const oldPos: [number, number, number] = [
          this.previousPositions[posOffset],
          this.previousPositions[posOffset + 1],
          this.previousPositions[posOffset + 2]
        ];
        const oldVel: [number, number, number] = [
          this.previousVelocities[velOffset],
          this.previousVelocities[velOffset + 1],
          this.previousVelocities[velOffset + 2]
        ];
        const newPos: [number, number, number] = [x, y, z];
        const newVel: [number, number, number] = [vx, vy, vz];

        if (this._hasSignificantChange(newPos, oldPos, newVel, oldVel)) {
          this.positions[posOffset] = x;
          this.positions[posOffset + 1] = y;
          this.positions[posOffset + 2] = z;

          this.velocities[velOffset] = vx;
          this.velocities[velOffset + 1] = vy;
          this.velocities[velOffset + 2] = vz;

          this.changedNodes.add(i);
        }
      }

      this.lastUpdateTime = now;
      this.lastThrottledUpdate = now;
      this.pendingUpdate = false;

      logData('Binary update processed:', {
        nodeCount,
        changedNodes: this.changedNodes.size,
        timeSinceLastUpdate: now - this.lastUpdateTime,
        timestamp: new Date().toISOString()
      });
    },

    clear(): void {
      this.positions = new Float32Array(0);
      this.velocities = new Float32Array(0);
      this.previousPositions = new Float32Array(0);
      this.previousVelocities = new Float32Array(0);
      this.nodeCount = 0;
      this.lastUpdateTime = 0;
      this.invalidUpdates = 0;
      this.pendingUpdate = false;
      this.lastThrottledUpdate = 0;
      this.changedNodes.clear();
      this.positionChangeThreshold = POSITION_CHANGE_THRESHOLD;
      this.velocityChangeThreshold = VELOCITY_CHANGE_THRESHOLD;
      
      logData('Binary update store cleared');
    }
  }
})

----
stores/visualization.ts
import { defineStore } from 'pinia'
import type { 
  Node, 
  Edge, 
  GraphNode,
  GraphEdge,
  GraphData,
  FisheyeSettings as CoreFisheyeSettings, 
  PhysicsSettings as CorePhysicsSettings,
  MaterialSettings as CoreMaterialSettings,
  BloomSettings as CoreBloomSettings
} from '../types/core'
import type {
  VisualizationConfig,
  BloomConfig,
  FisheyeConfig
} from '../types/components'
import {
  DEFAULT_VISUALIZATION_CONFIG,
  DEFAULT_BLOOM_CONFIG,
  DEFAULT_FISHEYE_CONFIG
} from '../types/components'
import { logData, logWarn } from '../utils/debug_log'

interface VisualizationState {
  nodes: Node[]
  edges: Edge[]
  graphData: GraphData | null
  selectedNode: null | Node
  metadata: Record<string, any>
  visualConfig: VisualizationConfig
  bloomConfig: BloomConfig
  fisheyeConfig: FisheyeConfig
  initialized: boolean
}

export const useVisualizationStore = defineStore('visualization', {
  state: (): VisualizationState => ({
    nodes: [],
    edges: [],
    graphData: null,
    selectedNode: null,
    metadata: {},
    visualConfig: { ...DEFAULT_VISUALIZATION_CONFIG },
    bloomConfig: { ...DEFAULT_BLOOM_CONFIG },
    fisheyeConfig: { ...DEFAULT_FISHEYE_CONFIG },
    initialized: false
  }),

  getters: {
    getNodeById: (state) => (id: string) => {
      return state.nodes.find(node => node.id === id)
    },

    getEdgesByNodeId: (state) => (nodeId: string) => {
      return state.edges.filter(edge => 
        edge.source === nodeId || edge.target === nodeId
      )
    },

    getGraphData: (state): GraphData | null => state.graphData,
    getVisualizationSettings: (state): VisualizationConfig => state.visualConfig,
    getBloomSettings: (state): BloomConfig => state.bloomConfig,
    getFisheyeSettings: (state): FisheyeConfig => state.fisheyeConfig,
    isInitialized: (state): boolean => state.initialized
  },

  actions: {
    mergeGraphData(serverData: GraphData) {
      logData('Merging server graph data:', {
        serverNodes: serverData.nodes.length,
        serverEdges: serverData.edges.length,
        localNodes: this.nodes.length,
        localEdges: this.edges.length,
        timestamp: new Date().toISOString()
      });

      // Create maps for quick lookups
      const localNodeMap = new Map(this.nodes.map(node => [node.id, node]));
      const serverNodeMap = new Map(serverData.nodes.map(node => [node.id, node]));

      // Merge nodes, preserving local positions for existing nodes
      const mergedNodes = serverData.nodes.map(serverNode => {
        const localNode = localNodeMap.get(serverNode.id);
        if (localNode) {
          // Preserve local position and velocity if they exist
          return {
            ...serverNode,
            position: localNode.position || serverNode.position,
            velocity: localNode.velocity || serverNode.velocity
          };
        }
        return serverNode;
      });

      // Convert edges and update with merged nodes
      const mergedEdges = serverData.edges.map(edge => ({
        ...edge,
        id: `${edge.source}-${edge.target}`
      }));

      // Update store with merged data
      this.setGraphData(mergedNodes, mergedEdges, serverData.metadata);

      logData('Graph data merge complete:', {
        mergedNodes: mergedNodes.length,
        mergedEdges: mergedEdges.length,
        timestamp: new Date().toISOString()
      });
    },

    setGraphData(nodes: Node[], edges: Edge[], metadata: Record<string, any> = {}) {
      logData('Setting graph data:', {
        nodeCount: nodes.length,
        edgeCount: edges.length,
        metadataKeys: Object.keys(metadata),
        timestamp: new Date().toISOString(),
        initialized: this.initialized,
        sampleNodes: nodes.slice(0, 3).map(n => ({
          id: n.id,
          position: n.position,
          hasPosition: !!n.position,
          velocity: n.velocity,
          hasVelocity: !!n.velocity
        }))
      });

      // Validate node positions
      const nodesWithoutPosition = nodes.filter(n => !n.position)
      if (nodesWithoutPosition.length > 0) {
        logWarn('Nodes missing position data:', {
          count: nodesWithoutPosition.length,
          sampleIds: nodesWithoutPosition.slice(0, 3).map(n => n.id),
          timestamp: new Date().toISOString()
        });
      }

      // Convert to graph data structure
      const graphNodes = nodes.map(node => ({
        ...node,
        edges: [],
        weight: node.weight || 1
      })) as GraphNode[]

      // Create node lookup for edge processing
      const nodeLookup = new Map<string, GraphNode>()
      graphNodes.forEach(node => nodeLookup.set(node.id, node))

      logData('Node lookup created:', {
        lookupSize: nodeLookup.size,
        sampleEntries: Array.from(nodeLookup.entries()).slice(0, 3).map(([id, node]) => ({
          id,
          position: node.position,
          hasPosition: !!node.position,
          velocity: node.velocity,
          hasVelocity: !!node.velocity
        }))
      });

      // Track edge connection stats
      let missingSourceCount = 0
      let missingTargetCount = 0
      let validEdgeCount = 0

      // Convert edges and link to nodes
      const graphEdges = edges.map(edge => {
        const sourceNode = nodeLookup.get(edge.source)
        const targetNode = nodeLookup.get(edge.target)
        
        if (!sourceNode || !targetNode) {
          if (!sourceNode) missingSourceCount++
          if (!targetNode) missingTargetCount++
          
          logWarn('Edge references missing node:', {
            edge: `${edge.source}-${edge.target}`,
            hasSource: !!sourceNode,
            hasTarget: !!targetNode,
            timestamp: new Date().toISOString()
          });
          return null
        }

        validEdgeCount++
        const graphEdge: GraphEdge = {
          ...edge,
          sourceNode,
          targetNode,
          directed: edge.directed || false
        }
        sourceNode.edges.push(graphEdge)
        targetNode.edges.push(graphEdge)
        return graphEdge
      }).filter((edge): edge is GraphEdge => edge !== null)

      logData('Edge processing complete:', {
        totalEdges: edges.length,
        validEdges: validEdgeCount,
        missingSourceNodes: missingSourceCount,
        missingTargetNodes: missingTargetCount,
        timestamp: new Date().toISOString()
      });

      logData('Graph data transformation complete:', {
        originalNodes: nodes.length,
        originalEdges: edges.length,
        transformedNodes: graphNodes.length,
        transformedEdges: graphEdges.length,
        nodesWithoutPosition: nodesWithoutPosition.length,
        sampleGraphNode: graphNodes[0] ? {
          id: graphNodes[0].id,
          edgeCount: graphNodes[0].edges.length,
          position: graphNodes[0].position,
          hasPosition: !!graphNodes[0].position,
          velocity: graphNodes[0].velocity,
          hasVelocity: !!graphNodes[0].velocity
        } : null,
        timestamp: new Date().toISOString()
      });

      // Store the data
      this.nodes = nodes
      this.edges = edges
      this.metadata = metadata
      this.graphData = {
        nodes: graphNodes,
        edges: graphEdges,
        metadata
      }
      this.initialized = true

      // Log final state
      logData('Graph data state after update:', {
        storeNodes: this.nodes.length,
        storeEdges: this.edges.length,
        graphDataNodes: this.graphData.nodes.length,
        graphDataEdges: this.graphData.edges.length,
        initialized: this.initialized,
        timestamp: new Date().toISOString()
      });
    },

    updateNode(nodeId: string, updates: Partial<Node>) {
      logData('Updating node:', {
        nodeId,
        updates,
        hasPosition: !!updates.position,
        hasVelocity: !!updates.velocity,
        timestamp: new Date().toISOString()
      });

      const index = this.nodes.findIndex(n => n.id === nodeId)
      if (index !== -1) {
        this.nodes[index] = { ...this.nodes[index], ...updates }
        
        // Update graph data if it exists
        if (this.graphData) {
          const graphNodeIndex = this.graphData.nodes.findIndex(n => n.id === nodeId)
          if (graphNodeIndex !== -1) {
            const graphNode = this.graphData.nodes[graphNodeIndex]
            this.graphData.nodes[graphNodeIndex] = {
              ...graphNode,
              ...updates,
              edges: graphNode.edges // Preserve edges array
            } as GraphNode

            logData('Graph node updated:', {
              nodeId,
              position: updates.position,
              hasPosition: !!updates.position,
              velocity: updates.velocity,
              hasVelocity: !!updates.velocity,
              edgeCount: graphNode.edges.length,
              timestamp: new Date().toISOString()
            });
          }
        }
      } else {
        logWarn('Node not found for update:', {
          nodeId,
          timestamp: new Date().toISOString()
        });
      }
    },

    updateNodePositions(updates: { id: string; position: [number, number, number]; velocity?: [number, number, number] }[]) {
      logData('Batch updating node positions:', {
        updateCount: updates.length,
        timestamp: new Date().toISOString(),
        sampleUpdates: updates.slice(0, 3).map(u => ({
          id: u.id,
          position: u.position,
          hasVelocity: !!u.velocity
        }))
      });

      let updatedCount = 0
      let skippedCount = 0
      let missingPositionCount = 0

      updates.forEach(update => {
        if (!update.position) {
          missingPositionCount++
          return
        }

        const node = this.nodes.find(n => n.id === update.id)
        if (node) {
          // Update position and velocity directly (already scaled)
          node.position = update.position
          if (update.velocity) {
            node.velocity = update.velocity
          }

          // Update graph data if it exists
          if (this.graphData) {
            const graphNode = this.graphData.nodes.find(n => n.id === update.id)
            if (graphNode) {
              graphNode.position = node.position
              if (update.velocity) {
                graphNode.velocity = node.velocity
              }
              updatedCount++
            }
          }
        } else {
          skippedCount++
        }
      })

      logData('Node position updates complete:', {
        totalUpdates: updates.length,
        successfulUpdates: updatedCount,
        skippedUpdates: skippedCount,
        missingPositions: missingPositionCount,
        timestamp: new Date().toISOString()
      });
    },

    updateVisualizationSettings(settings: Partial<VisualizationConfig>) {
      logData('Updating visualization settings:', {
        oldSettings: this.visualConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      });
      this.visualConfig = {
        ...this.visualConfig,
        ...settings
      }
    },

    updateBloomSettings(settings: Partial<BloomConfig>) {
      logData('Updating bloom settings:', {
        oldSettings: this.bloomConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      });
      this.bloomConfig = {
        ...this.bloomConfig,
        ...settings
      }
    },

    updateFisheyeSettings(settings: Partial<FisheyeConfig>) {
      logData('Updating fisheye settings:', {
        oldSettings: this.fisheyeConfig,
        newSettings: settings,
        timestamp: new Date().toISOString()
      });
      
      if ('focusPoint' in settings) {
        const [focus_x, focus_y, focus_z] = settings.focusPoint as [number, number, number]
        this.fisheyeConfig = {
          ...this.fisheyeConfig,
          ...settings,
          focus_x,
          focus_y,
          focus_z
        }
      } else {
        this.fisheyeConfig = {
          ...this.fisheyeConfig,
          ...settings
        }
      }
    },

    clear() {
      logData('Clearing visualization store:', {
        nodeCount: this.nodes.length,
        edgeCount: this.edges.length,
        hasGraphData: !!this.graphData,
        wasInitialized: this.initialized,
        timestamp: new Date().toISOString()
      });
      
      this.nodes = []
      this.edges = []
      this.graphData = null
      this.selectedNode = null
      this.metadata = {}
      this.initialized = false
      
      // Reset settings to defaults
      this.visualConfig = { ...DEFAULT_VISUALIZATION_CONFIG }
      this.bloomConfig = { ...DEFAULT_BLOOM_CONFIG }
      this.fisheyeConfig = { ...DEFAULT_FISHEYE_CONFIG }
    }
  }
})

----
stores/settings.ts
import { defineStore } from 'pinia';
import type { 
  VisualizationConfig, 
  BloomConfig, 
  FisheyeConfig 
} from '../types/components';
import { 
  DEFAULT_VISUALIZATION_CONFIG,
  DEFAULT_BLOOM_CONFIG,
  DEFAULT_FISHEYE_CONFIG
} from '../types/components';

interface SettingsState {
  visualization: VisualizationConfig;
  bloom: BloomConfig;
  fisheye: FisheyeConfig;
  isDirty: boolean;
}

export const useSettingsStore = defineStore('settings', {
  state: (): SettingsState => ({
    visualization: { ...DEFAULT_VISUALIZATION_CONFIG },
    bloom: { ...DEFAULT_BLOOM_CONFIG },
    fisheye: { ...DEFAULT_FISHEYE_CONFIG },
    isDirty: false
  }),

  getters: {
    getVisualizationSettings: (state) => state.visualization,
    getBloomSettings: (state) => state.bloom,
    getFisheyeSettings: (state) => state.fisheye,
    hasUnsavedChanges: (state) => state.isDirty
  },

  actions: {
    updateVisualizationSettings(settings: Partial<VisualizationConfig>) {
      this.visualization = {
        ...this.visualization,
        ...settings
      };
      this.isDirty = true;
    },

    updateBloomSettings(settings: Partial<BloomConfig>) {
      this.bloom = {
        ...this.bloom,
        ...settings
      };
      this.isDirty = true;
    },

    updateFisheyeSettings(settings: Partial<FisheyeConfig>) {
      this.fisheye = {
        ...this.fisheye,
        ...settings
      };
      this.isDirty = true;
    },

    applyServerSettings(settings: {
      visualization?: Partial<VisualizationConfig>;
      bloom?: Partial<BloomConfig>;
      fisheye?: Partial<FisheyeConfig>;
    }) {
      if (settings.visualization) {
        this.visualization = {
          ...this.visualization,
          ...settings.visualization
        };
      }
      if (settings.bloom) {
        this.bloom = {
          ...this.bloom,
          ...settings.bloom
        };
      }
      if (settings.fisheye) {
        this.fisheye = {
          ...this.fisheye,
          ...settings.fisheye
        };
      }
      this.isDirty = false;
    },

    resetToDefaults() {
      this.visualization = { ...DEFAULT_VISUALIZATION_CONFIG };
      this.bloom = { ...DEFAULT_BLOOM_CONFIG };
      this.fisheye = { ...DEFAULT_FISHEYE_CONFIG };
      this.isDirty = true;
    },

    markSaved() {
      this.isDirty = false;
    }
  }
});

----
stores/websocket.ts
import { defineStore } from 'pinia'
import WebsocketService from '../services/websocketService'
import { useVisualizationStore } from './visualization'
import { useBinaryUpdateStore } from './binaryUpdate'
import type { BaseMessage, ErrorMessage, GraphUpdateMessage, BinaryMessage, Edge as WsEdge, SimulationModeMessage, InitialDataMessage } from '../types/websocket'
import type { Node, Edge } from '../types/core'

interface WebSocketState {
  connected: boolean
  error: string | null
  service: WebsocketService | null
  lastMessageTime: number
  messageCount: number
  queueSize: number
  connectionAttempts: number
  lastReconnectTime: number
  gpuEnabled: boolean
  initialDataRequested: boolean
  performanceMetrics: {
    avgMessageProcessingTime: number
    messageProcessingSamples: number[]
    avgPositionUpdateTime: number
    positionUpdateSamples: number[]
    lastPerformanceReset: number
  }
}

const MAX_PERFORMANCE_SAMPLES = 100;
const PERFORMANCE_RESET_INTERVAL = 60000; // Reset metrics every minute

export const useWebSocketStore = defineStore('websocket', {
  state: (): WebSocketState => ({
    connected: false,
    error: null,
    service: null,
    lastMessageTime: 0,
    messageCount: 0,
    queueSize: 0,
    connectionAttempts: 0,
    lastReconnectTime: 0,
    gpuEnabled: false,
    initialDataRequested: false,
    performanceMetrics: {
      avgMessageProcessingTime: 0,
      messageProcessingSamples: [],
      avgPositionUpdateTime: 0,
      positionUpdateSamples: [],
      lastPerformanceReset: Date.now()
    }
  }),

  getters: {
    isConnected: (state) => state.connected,
    hasError: (state) => state.error !== null,
    connectionHealth: (state) => {
      if (!state.connected) return 'disconnected'
      if (state.error) return 'error'
      if (state.connectionAttempts > 0) return 'unstable'
      return 'healthy'
    },
    performanceStatus: (state) => {
      const { avgMessageProcessingTime, avgPositionUpdateTime } = state.performanceMetrics
      if (avgMessageProcessingTime > 100 || avgPositionUpdateTime > 16) return 'poor'
      if (avgMessageProcessingTime > 50 || avgPositionUpdateTime > 8) return 'fair'
      return 'good'
    },
    isGPUEnabled: (state) => state.gpuEnabled
  },

  actions: {
    async initialize() {
      console.debug('[WebSocketStore] Initializing websocket store')
      if (this.service) {
        console.log('[WebSocketStore] WebSocket service already initialized')
        return
      }

      const visualizationStore = useVisualizationStore()
      const binaryUpdateStore = useBinaryUpdateStore()

      this.service = new WebsocketService()
      
      this._setupEventHandlers(visualizationStore, binaryUpdateStore)
      
      try {
        console.debug('[WebSocketStore] Attempting to connect websocket')
        await this.service.connect()
      } catch (error) {
        this._handleConnectionError(error)
        throw error
      }
    },

    _setupEventHandlers(visualizationStore: any, binaryUpdateStore: any) {
      if (!this.service) return

      this.service.on('open', () => {
        console.debug('[WebSocketStore] WebSocket connected, connection state:', {
          connected: this.connected,
          initialDataRequested: this.initialDataRequested,
          connectionAttempts: this.connectionAttempts
        })
        this.connected = true
        this.error = null
        this.connectionAttempts = 0
        if (!this.initialDataRequested) {
          this.requestInitialData()
        }
      })

      this.service.on('close', () => {
        console.debug('[WebSocketStore] WebSocket closed')
        this.connected = false
        this._handleDisconnect()
      })

      this.service.on('error', (error: ErrorMessage) => {
        this._handleError(error)
      })

      this.service.on('maxReconnectAttemptsReached', () => {
        this._handleMaxReconnectAttempts()
      })

      this.service.on('initialData', (message: InitialDataMessage) => {
        const startTime = performance.now()
        console.debug('[WebSocketStore] Received initial data message:', {
          type: message.type,
          hasGraphData: !!message.graphData,
          hasSettings: !!message.settings,
          timestamp: new Date().toISOString()
        })
        
        try {
          this._handleGraphUpdate(message, visualizationStore)
          if (message.settings) {
            visualizationStore.updateVisualizationSettings(message.settings)
          }
        } catch (error) {
          console.error('[WebSocketStore] Error processing initial data:', error)
        }

        this._updateMessageProcessingMetrics(performance.now() - startTime)
      })

      this.service.on('graphUpdate', (message: GraphUpdateMessage) => {
        const startTime = performance.now()
        console.debug('[WebSocketStore] Received graph update message:', {
          type: message.type,
          hasGraphData: !!message.graphData,
          timestamp: new Date().toISOString()
        })
        
        try {
          this._handleGraphUpdate(message, visualizationStore)
        } catch (error) {
          console.error('[WebSocketStore] Error processing graph update:', error)
        }

        this._updateMessageProcessingMetrics(performance.now() - startTime)
      })

      this.service.on('gpuPositions', (message: BinaryMessage) => {
        const startTime = performance.now()
        
        try {
          console.debug('[WebSocketStore] Processing GPU positions update:', {
            dataSize: message.data.byteLength,
            nodeCount: message.nodeCount,
            timestamp: new Date().toISOString()
          })
          binaryUpdateStore.updateFromBinary(message)
        } catch (error) {
          console.error('[WebSocketStore] Error processing position update:', error)
        }

        this._updatePositionUpdateMetrics(performance.now() - startTime)
      })

      // Handle simulation mode changes
      this.service.on('simulationModeSet', (mode: string) => {
        console.debug('[WebSocketStore] Setting simulation mode:', mode)
        visualizationStore.setSimulationMode(mode)
      })

      // Handle all messages to catch GPU state updates
      this.service.on('message', (message: BaseMessage) => {
        console.debug('[WebSocketStore] Received message:', {
          type: message.type,
          timestamp: new Date().toISOString()
        })
        
        if (message.type === 'gpuState' && 'enabled' in message) {
          this.gpuEnabled = message.enabled
          console.debug(`[WebSocketStore] GPU acceleration ${message.enabled ? 'enabled' : 'disabled'}`)
        }
      })
    },

    _handleGraphUpdate(message: GraphUpdateMessage | InitialDataMessage, visualizationStore: any) {
      console.debug('[WebSocketStore] Processing graph update:', {
        nodeCount: message.graphData?.nodes?.length || 0,
        edgeCount: message.graphData?.edges?.length || 0,
        hasMetadata: !!message.graphData?.metadata,
        timestamp: new Date().toISOString()
      })

      if (!message.graphData) {
        console.warn('[WebSocketStore] No graph data found in message')
        return
      }

      console.debug('[WebSocketStore] Graph data details:', {
        nodes: message.graphData.nodes?.map(n => ({ id: n.id, hasPosition: !!n.position })) || [],
        edges: message.graphData.edges?.map(e => ({ source: e.source, target: e.target })) || [],
        metadata: message.graphData.metadata
      })

      const edges: Edge[] = message.graphData.edges.map((edge: WsEdge) => ({
        ...edge,
        id: `${edge.source}-${edge.target}`
      }))

      visualizationStore.setGraphData(
        message.graphData.nodes as Node[],
        edges,
        message.graphData.metadata
      )
    },

    _handleConnectionError(error: unknown) {
      console.error('[WebSocketStore] Connection error:', error)
      this.error = error instanceof Error ? error.message : 'Unknown connection error'
      this.connectionAttempts++
      this.lastReconnectTime = Date.now()
    },

    _handleError(error: ErrorMessage) {
      this.error = error.message || 'Unknown error'
      if (error.code) {
        console.error(`[WebSocketStore] WebSocket error [${error.code}]:`, this.error)
      } else {
        console.error('[WebSocketStore] WebSocket error:', this.error)
      }
      if (error.details) {
        console.debug('[WebSocketStore] Error details:', error.details)
      }
    },

    _handleDisconnect() {
      const timeSinceLastReconnect = Date.now() - this.lastReconnectTime
      
      if (timeSinceLastReconnect > 60000) { // Reset counter if more than 1 minute since last reconnect
        this.connectionAttempts = 0
      }
      
      this.connectionAttempts++
      console.debug('[WebSocketStore] Handling disconnect:', {
        connectionAttempts: this.connectionAttempts,
        timeSinceLastReconnect,
        timestamp: new Date().toISOString()
      })
    },

    _handleMaxReconnectAttempts() {
      this.error = 'Maximum reconnection attempts reached. Please refresh the page.'
      console.error('[WebSocketStore] Max reconnection attempts reached')
    },

    _updateMessageProcessingMetrics(processingTime: number) {
      this._updateMetrics('message', processingTime)
    },

    _updatePositionUpdateMetrics(processingTime: number) {
      this._updateMetrics('position', processingTime)
    },

    _updateMetrics(type: 'message' | 'position', processingTime: number) {
      const metrics = this.performanceMetrics
      const now = Date.now()

      // Reset metrics if needed
      if (now - metrics.lastPerformanceReset > PERFORMANCE_RESET_INTERVAL) {
        metrics.messageProcessingSamples = []
        metrics.positionUpdateSamples = []
        metrics.lastPerformanceReset = now
      }

      if (type === 'message') {
        metrics.messageProcessingSamples.push(processingTime)
        if (metrics.messageProcessingSamples.length > MAX_PERFORMANCE_SAMPLES) {
          metrics.messageProcessingSamples.shift()
        }
        metrics.avgMessageProcessingTime = 
          metrics.messageProcessingSamples.reduce((a, b) => a + b, 0) / 
          metrics.messageProcessingSamples.length
      } else {
        metrics.positionUpdateSamples.push(processingTime)
        if (metrics.positionUpdateSamples.length > MAX_PERFORMANCE_SAMPLES) {
          metrics.positionUpdateSamples.shift()
        }
        metrics.avgPositionUpdateTime = 
          metrics.positionUpdateSamples.reduce((a, b) => a + b, 0) / 
          metrics.positionUpdateSamples.length
      }
    },

    send(data: any) {
      if (!this.service) {
        console.error('[WebSocketStore] Cannot send message: WebSocket service not initialized')
        return
      }
      console.debug('[WebSocketStore] Sending message:', {
        type: data.type,
        timestamp: new Date().toISOString()
      })
      this.messageCount++
      this.lastMessageTime = Date.now()
      this.service.send(data)
    },

    sendBinary(data: ArrayBuffer) {
      if (!this.service) {
        console.error('[WebSocketStore] Cannot send binary data: WebSocket service not initialized')
        return
      }
      console.debug('[WebSocketStore] Sending binary data:', {
        size: data.byteLength,
        timestamp: new Date().toISOString()
      })
      this.messageCount++
      this.lastMessageTime = Date.now()
      this.service.sendBinary(data)
    },

    requestInitialData() {
      console.debug('[WebSocketStore] Requesting initial graph data')
      this.initialDataRequested = true
      this.send({ type: 'initialData' })
    },

    async reconnect() {
      console.debug('[WebSocketStore] Attempting reconnection')
      // Reset initialDataRequested before cleanup
      this.initialDataRequested = false
      if (this.service) {
        this.service.cleanup()
        this.service = null
      }
      await this.initialize()
    },

    cleanup() {
      console.debug('[WebSocketStore] Cleaning up websocket store')
      if (this.service) {
        this.service.cleanup()
        this.service = null
      }
      this.connected = false
      this.error = null
      this.lastMessageTime = 0
      this.messageCount = 0
      this.queueSize = 0
      this.connectionAttempts = 0
      this.lastReconnectTime = 0
      this.gpuEnabled = false
      // Reset initialDataRequested to ensure we request data on reconnect
      this.initialDataRequested = false
      this.performanceMetrics = {
        avgMessageProcessingTime: 0,
        messageProcessingSamples: [],
        avgPositionUpdateTime: 0,
        positionUpdateSamples: [],
        lastPerformanceReset: Date.now()
      }
    }
  }
})

--END--