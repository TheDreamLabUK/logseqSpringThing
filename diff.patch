diff --git a/client/components/settings/FPSControl.tsx b/client/components/settings/FPSControl.tsx
new file mode 100644
index 00000000..65cb4870
--- /dev/null
+++ b/client/components/settings/FPSControl.tsx
@@ -0,0 +1,39 @@
+import React from 'react';
+import { Select, FormControl, InputLabel, MenuItem } from '@mui/material';
+import { useSettings } from '../../state/settings';
+
+const FPS_OPTIONS = [1, 30, 60, 90];
+
+export const FPSControl: React.FC = () => {
+  const { settings, updateSettings } = useSettings();
+
+  const handleChange = async (event: any) => {
+    const newRate = event.target.value;
+    try {
+      await updateSettings('websocket', {
+        updateRate: newRate
+      });
+    } catch (error) {
+      console.error('Failed to update FPS:', error);
+    }
+  };
+
+  return (
+    <FormControl fullWidth>
+      <InputLabel id="fps-select-label">Frame Rate</InputLabel>
+      <Select
+        labelId="fps-select-label"
+        id="fps-select"
+        value={settings.websocket.updateRate}
+        label="Frame Rate"
+        onChange={handleChange}
+      >
+        {FPS_OPTIONS.map((fps) => (
+          <MenuItem key={fps} value={fps}>
+            {fps} FPS
+          </MenuItem>
+        ))}
+      </Select>
+    </FormControl>
+  );
+};
diff --git a/client/core/api.ts b/client/core/api.ts
new file mode 100644
index 00000000..6d49105c
--- /dev/null
+++ b/client/core/api.ts
@@ -0,0 +1,64 @@
+import { API_BASE, API_PATHS, API_ENDPOINTS, SETTINGS_CATEGORIES } from './constants';
+
+// Helper function to build API URLs
+export function buildApiUrl(path: string): string {
+    // Handle both endpoint constants and dynamic paths
+    if (path.startsWith('/api/')) {
+        return `${API_BASE}${path}`;
+    }
+    return `${API_BASE}/api/${path}`;
+}
+
+// Helper function to build settings URL
+export function buildSettingsUrl(category: keyof typeof SETTINGS_CATEGORIES, setting?: string): string {
+    // Get snake_case category from enum
+    const categorySnake = SETTINGS_CATEGORIES[category];
+    if (!categorySnake) {
+        throw new Error(`Invalid settings category: ${category}`);
+    }
+    
+    // Convert setting to snake_case if provided
+    const settingSnake = setting?.replace(/-/g, '_');
+    
+    const base = settingSnake 
+        ? `${API_ENDPOINTS.SETTINGS}/${categorySnake}/${settingSnake}`
+        : `${API_ENDPOINTS.SETTINGS}/${categorySnake}`;
+    return base;
+}
+
+// Helper function to build graph URL
+export function buildGraphUrl(type: 'data' | 'update' | 'paginated', params?: Record<string, string>): string {
+    let endpoint: string;
+    switch (type) {
+        case 'data':
+            endpoint = API_ENDPOINTS.GRAPH_DATA;
+            break;
+        case 'update':
+            endpoint = API_ENDPOINTS.GRAPH_UPDATE;
+            break;
+        case 'paginated':
+            endpoint = API_ENDPOINTS.GRAPH_PAGINATED;
+            break;
+        default:
+            throw new Error(`Invalid graph endpoint type: ${type}`);
+    }
+    
+    if (!params) return endpoint;
+    
+    const queryString = Object.entries(params)
+        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
+        .join('&');
+    return `${endpoint}?${queryString}`;
+}
+
+// Helper function to build files URL
+export function buildFilesUrl(path: string): string {
+    return `${API_ENDPOINTS.FILES}/${path}`;
+}
+
+// Helper function to build WebSocket URL
+export function buildWsUrl(): string {
+    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
+    const host = window.location.host;
+    return `${protocol}//${host}/${API_PATHS.WEBSOCKET}`;
+}
diff --git a/client/core/constants.ts b/client/core/constants.ts
index b44570a9..2f02600f 100644
--- a/client/core/constants.ts
+++ b/client/core/constants.ts
@@ -3,15 +3,61 @@
  */
 
 // Environment detection
-export const IS_PRODUCTION = window.location.hostname === 'www.visionflow.info';
+export const IS_PRODUCTION = ['www.visionflow.info', 'visionflow.info'].includes(window.location.hostname);
 export const IS_DEVELOPMENT = !IS_PRODUCTION;
 
+// API configuration
+export const API_BASE = '';  // Empty string means use relative URLs
+
+// API paths
+export const API_PATHS = {
+    SETTINGS: 'settings',
+    WEBSOCKET: 'wss',
+    GRAPH: 'graph',
+    FILES: 'files'
+};
+
+// API endpoints
+export const API_ENDPOINTS = {
+    GRAPH_DATA: '/api/graph/data',
+    GRAPH_UPDATE: '/api/graph/update',
+    GRAPH_PAGINATED: '/api/graph/data/paginated',
+    SETTINGS: '/api/settings',
+    FILES: '/api/files'
+};
+
+// Settings categories matching server's snake_case
+export const SETTINGS_CATEGORIES = {
+    // System settings
+    NETWORK: 'system.network',
+    WEBSOCKET: 'system.websocket',
+    SECURITY: 'system.security',
+    DEBUG: 'system.debug',
+    
+    // Visualization settings
+    ANIMATIONS: 'visualization.animations',
+    AR: 'visualization.ar',
+    AUDIO: 'visualization.audio',
+    BLOOM: 'visualization.bloom',
+    EDGES: 'visualization.edges',
+    HOLOGRAM: 'visualization.hologram',
+    LABELS: 'visualization.labels',
+    NODES: 'visualization.nodes',
+    PHYSICS: 'visualization.physics',
+    RENDERING: 'visualization.rendering',
+    
+    // Default settings
+    DEFAULT: 'default'
+};
+
 // WebSocket URLs
-export const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/wss`;
+export const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/${API_PATHS.WEBSOCKET}`;
 
 // WebSocket configuration
 export const WS_RECONNECT_INTERVAL = 30000; // Match server's HEARTBEAT_INTERVAL
 export const WS_MESSAGE_QUEUE_SIZE = 1000;
+export const WS_HEARTBEAT_INTERVAL = 30000;  // 30 seconds - match server
+export const WS_HEARTBEAT_TIMEOUT = 60000;   // 60 seconds - match server
 
 // Binary protocol configuration
 export const BINARY_VERSION = 1;
@@ -39,50 +85,10 @@ export const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300
 export const BACKGROUND_COLOR = 0x212121;  // Material Design Grey 900
 export const LABEL_COLOR = 0xFFFFFF;  // White
 
-// Default settings
-export const DEFAULT_VISUALIZATION_SETTINGS = {
-  // Node appearance
-  nodeSize: NODE_SIZE,
-  nodeColor: '#4CAF50',
-  nodeOpacity: 0.7,
-  nodeHighlightColor: '#ff4444',
-  
-  // Edge appearance
-  edgeWidth: EDGE_RADIUS * 2,
-  edgeColor: '#E0E0E0',
-  edgeOpacity: 0.7,
-  
-  // Visual effects
-  enableBloom: true,
-  bloomIntensity: 1.5,
-  bloomThreshold: 0.3,
-  bloomRadius: 0.75,
-  
-  // Performance
-  maxFps: 60,
-  updateThrottle: THROTTLE_INTERVAL,
-
-  // Labels
-  showLabels: true,
-  labelSize: 1.0,
-  labelColor: '#FFFFFF',
-
-  // XR specific
-  xrControllerVibration: true,
-  xrControllerHapticIntensity: 1.0
-};
-
-// Default bloom settings
-export const DEFAULT_BLOOM_SETTINGS = {
-  threshold: DEFAULT_VISUALIZATION_SETTINGS.bloomThreshold,
-  strength: DEFAULT_VISUALIZATION_SETTINGS.bloomIntensity,
-  radius: DEFAULT_VISUALIZATION_SETTINGS.bloomRadius,
-};
-
 // Debug configuration
 export const DEBUG = {
-  NETWORK_PANEL: {
-    MAX_MESSAGES: 50,
-    ENABLED: IS_DEVELOPMENT
-  }
+    NETWORK_PANEL: {
+        MAX_MESSAGES: 50,
+        ENABLED: IS_DEVELOPMENT
+    }
 };
diff --git a/client/core/logger.ts b/client/core/logger.ts
index bfa40358..1e9544c3 100644
--- a/client/core/logger.ts
+++ b/client/core/logger.ts
@@ -1,6 +1,51 @@
-export const logger = {
-    info: (message: string, ...args: any[]) => console.log(message, ...args),
-    error: (message: string, ...args: any[]) => console.error(message, ...args),
-    warn: (message: string, ...args: any[]) => console.warn(message, ...args),
-    debug: (message: string, ...args: any[]) => console.debug(message, ...args),
-};
+let debugEnabled = false;
+let logFullJson = false;
+
+export interface Logger {
+    debug: (...args: any[]) => void;
+    log: (...args: any[]) => void;
+    info: (...args: any[]) => void;
+    warn: (...args: any[]) => void;
+    error: (...args: any[]) => void;
+}
+
+export function setDebugEnabled(enabled: boolean, fullJson: boolean = false): void {
+    debugEnabled = enabled;
+    logFullJson = fullJson;
+}
+
+export function createLogger(context: string): Logger {
+    const prefix = `[${context}]`;
+    
+    const formatArgs = (args: any[]): any[] => {
+        if (logFullJson) {
+            return args.map(arg => 
+                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
+            );
+        }
+        return args;
+    };
+    
+    return {
+        debug: (...args: any[]): void => {
+            if (debugEnabled) {
+                console.debug(prefix, ...formatArgs(args));
+            }
+        },
+        log: (...args: any[]): void => {
+            console.log(prefix, ...formatArgs(args));
+        },
+        info: (...args: any[]): void => {
+            console.info(prefix, ...formatArgs(args));
+        },
+        warn: (...args: any[]): void => {
+            console.warn(prefix, ...formatArgs(args));
+        },
+        error: (...args: any[]): void => {
+            console.error(prefix, ...formatArgs(args));
+        }
+    };
+}
+
+// Create core logger instance
+export const logger = createLogger('core');
diff --git a/client/core/types.ts b/client/core/types.ts
index 4bf4a0e9..ade41d3b 100644
--- a/client/core/types.ts
+++ b/client/core/types.ts
@@ -6,9 +6,17 @@ export interface Vector3 {
   z: number;
 }
 
+export interface NodeMetadata {
+  name?: string;
+  lastModified?: number;
+  links?: string[];
+  references?: string[];
+}
+
 export interface NodeData {
   position: Vector3;
   velocity: Vector3;
+  metadata?: NodeMetadata;
 }
 
 export interface Node {
@@ -84,6 +92,7 @@ export interface ARSettings {
   rotationThreshold: number;
   showPlaneOverlay: boolean;
   snapToFloor: boolean;
+  interactionRadius: number;
 }
 
 export interface AudioSettings {
@@ -118,10 +127,47 @@ export interface EdgeSettings {
   widthRange: [number, number];
 }
 
+export interface HologramSettings {
+  xrQuality: 'low' | 'medium' | 'high';
+  desktopQuality: 'low' | 'medium' | 'high';
+  ringCount: number;
+  ringColor: string;
+  ringOpacity: number;
+  ringSizes: number[];
+  ringRotationSpeed: number;
+  enableBuckminster: boolean;
+  buckminsterScale: number;
+  buckminsterOpacity: number;
+  enableGeodesic: boolean;
+  geodesicScale: number;
+  geodesicOpacity: number;
+  enableTriangleSphere: boolean;
+  triangleSphereScale: number;
+  triangleSphereOpacity: number;
+  globalRotationSpeed: number;
+}
+
 export interface LabelSettings {
   desktopFontSize: number;
   enableLabels: boolean;
   textColor: string;
+  textOutlineColor: string;
+  textOutlineWidth: number;
+  textResolution: number;
+  textPadding: number;
+  billboardMode: 'camera' | 'up';
+}
+
+export interface NodeSettings {
+  baseColor: string;
+  baseSize: number;
+  sizeRange: [number, number];
+  enableMetadataShape: boolean;
+  colorRangeAge: [string, string];
+  colorRangeLinks: [string, string];
+  metalness: number;
+  roughness: number;
+  opacity: number;
 }
 
 export interface NetworkSettings {
@@ -164,30 +210,13 @@ export interface SecuritySettings {
 }
 
 export interface ServerDebugSettings {
+  enabled: boolean;
   enableDataDebug: boolean;
   enableWebsocketDebug: boolean;
-  enabled: boolean;
   logBinaryHeaders: boolean;
   logFullJson: boolean;
 }
 
-export interface NodeSettings {
-  baseColor: string;
-  baseSize: number;
-  clearcoat: number;
-  enableHoverEffect: boolean;
-  enableInstancing: boolean;
-  highlightColor: string;
-  highlightDuration: number;
-  hoverScale: number;
-  materialType: string;
-  metalness: number;
-  opacity: number;
-  roughness: number;
-  sizeByConnections: boolean;
-  sizeRange: [number, number];
-}
-
 export interface PhysicsSettings {
   attractionStrength: number;
   boundsSize: number;
@@ -211,18 +240,18 @@ export interface RenderingSettings {
   environmentIntensity: number;
 }
 
-export interface WebsocketSettings {
-  binaryChunkSize: number;
-  compressionEnabled: boolean;
-  compressionThreshold: number;
-  heartbeatInterval: number;
-  heartbeatTimeout: number;
-  maxConnections: number;
-  maxMessageSize: number;
-  reconnectAttempts: number;
-  reconnectDelay: number;
-  updateRate: number;
-  url: string; // Added url property for WebSocket endpoint configuration
+export interface WebSocketSettings {
+  url: string;                   // WebSocket server URL
+  heartbeatInterval: number;     // Ping interval in seconds (default: 30)
+  heartbeatTimeout: number;      // Connection timeout in seconds (default: 60)
+  reconnectAttempts: number;     // Max reconnection attempts (default: 3)
+  reconnectDelay: number;        // Delay between reconnects in ms (default: 5000)
+  binaryChunkSize: number;       // Size of binary chunks
+  compressionEnabled: boolean;   // Enable/disable compression
+  compressionThreshold: number;  // Compression threshold
+  maxConnections: number;        // Maximum connections
+  maxMessageSize: number;        // Maximum message size
+  updateRate: number;           // Update rate in Hz
 }
 
 export interface Settings {
@@ -233,6 +262,7 @@ export interface Settings {
   clientDebug: ClientDebugSettings;
   default: DefaultSettings;
   edges: EdgeSettings;
+  hologram: HologramSettings;
   labels: LabelSettings;
   network: NetworkSettings;
   nodes: NodeSettings;
@@ -240,93 +270,33 @@ export interface Settings {
   rendering: RenderingSettings;
   security: SecuritySettings;
   serverDebug: ServerDebugSettings;
-  websocket: WebsocketSettings;
+  websocket: WebSocketSettings;
 }
 
 export type SettingCategory = keyof Settings;
 export type SettingKey<T extends SettingCategory> = keyof Settings[T];
 export type SettingValue = string | number | boolean | number[] | string[];
 
-// WebSocket specific error types
-export enum WebSocketErrorType {
-  CONNECTION_FAILED = 'CONNECTION_FAILED',
-  CONNECTION_LOST = 'CONNECTION_LOST',
-  CONNECTION_ERROR = 'CONNECTION_ERROR', // Added CONNECTION_ERROR type
-  MAX_RETRIES_EXCEEDED = 'MAX_RETRIES_EXCEEDED',
-  MESSAGE_PARSE_ERROR = 'MESSAGE_PARSE_ERROR',
-  SEND_FAILED = 'SEND_FAILED',
-  INVALID_MESSAGE = 'INVALID_MESSAGE',
-  TIMEOUT = 'TIMEOUT'
-}
-
-export interface WebSocketError extends Error {
-  type: WebSocketErrorType;
-  code?: number;
-  details?: any;
-}
-
-// WebSocket connection status
-export enum WebSocketStatus {
-  CONNECTING = 'CONNECTING',
-  CONNECTED = 'CONNECTED',
-  DISCONNECTED = 'DISCONNECTED',
-  RECONNECTING = 'RECONNECTING',
-  FAILED = 'FAILED'
-}
-
 // WebSocket message types
 export type MessageType = 
-  | 'initialData'
-  | 'binaryPositionUpdate'
-  | 'requestInitialData'
-  | 'enableBinaryUpdates'
-  | 'ping'
-  | 'pong'
-  | 'settingsUpdated'
-  | 'graphUpdated'
-  | 'connectionStatus'
-  | 'updatePositions'
-  | 'simulationModeSet';
-
-// Handler types
-export type MessageHandler = (data: any) => void;
-export type ErrorHandler = (error: WebSocketError) => void;
-export type ConnectionHandler = (status: WebSocketStatus, details?: any) => void;
+  | 'binaryPositionUpdate'  // Real-time position/velocity data
+  | 'ping'                  // Connection health check
+  | 'pong'                 // Connection health response
+  | 'connectionStatus'     // Connection status updates
+  | 'enableBinaryUpdates'; // Enable/disable binary updates
 
 // Base WebSocket message interface
 export interface BaseWebSocketMessage {
   type: MessageType;
 }
 
-export interface InitialDataMessage extends BaseWebSocketMessage {
-  type: 'initialData';
-  data: {
-    nodes: Node[];
-    edges: Edge[];
-  };
-}
-
+// Binary position update message (server -> client)
 export interface BinaryPositionUpdateMessage extends BaseWebSocketMessage {
   type: 'binaryPositionUpdate';
-  data: {
-    nodes: {
-      nodeId: string;
-      data: NodeData;
-    }[];
-  };
-}
-
-export interface RequestInitialDataMessage extends BaseWebSocketMessage {
-  type: 'requestInitialData';
-}
-
-export interface EnableBinaryUpdatesMessage extends BaseWebSocketMessage {
-  type: 'enableBinaryUpdates';
-  data: {
-    enabled: boolean;
-  };
+  data: ArrayBuffer;  // Raw binary data (24 bytes per node: 6 floats x 4 bytes)
 }
 
+// Connection health messages
 export interface PingMessage extends BaseWebSocketMessage {
   type: 'ping';
   timestamp: number;
@@ -337,20 +307,25 @@ export interface PongMessage extends BaseWebSocketMessage {
   timestamp: number;
 }
 
-export interface ConnectionStatusMessage extends BaseWebSocketMessage {
-  type: 'connectionStatus';
-  status: WebSocketStatus;
-  details?: any;
-}
-
 export type WebSocketMessage =
-  | InitialDataMessage
   | BinaryPositionUpdateMessage
-  | RequestInitialDataMessage
-  | EnableBinaryUpdatesMessage
   | PingMessage
-  | PongMessage
-  | ConnectionStatusMessage;
+  | PongMessage;
+
+// WebSocket error types
+export enum WebSocketErrorType {
+  CONNECTION_ERROR = 'CONNECTION_ERROR',       // Failed to establish connection
+  CONNECTION_LOST = 'CONNECTION_LOST',         // Connection was lost
+  TIMEOUT = 'TIMEOUT',                        // Connection timed out
+  BINARY_FORMAT_ERROR = 'BINARY_FORMAT_ERROR', // Invalid binary data format
+}
+
+export interface WebSocketError {
+  type: WebSocketErrorType;
+  message: string;
+  code?: number;
+  details?: any;
+}
 
 // Logger interface
 export interface Logger {
diff --git a/client/index.html b/client/index.html
index 439cb90e..e441f70c 100644
--- a/client/index.html
+++ b/client/index.html
@@ -5,81 +5,119 @@
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>LogseqXR Graph Visualization</title>
   <style>
-    * {
+    body {
       margin: 0;
       padding: 0;
-      box-sizing: border-box;
-    }
-
-    body {
       overflow: hidden;
       font-family: Arial, sans-serif;
-      background-color: #000;
-      color: #fff;
+      background: #212121;  /* Match scene background */
+      color: #ffffff;
     }
 
-    #canvas-container {
-      position: fixed;
-      top: 0;
-      left: 0;
+    #scene-container {
+      position: absolute;
       width: 100%;
       height: 100%;
+      background: transparent;
     }
 
-    .loading-overlay {
+    #control-panel {
       position: fixed;
       top: 0;
-      left: 0;
-      width: 100%;
-      height: 100%;
-      background: rgba(0, 0, 0, 0.9);
+      right: 0;
+      height: 100vh;
+      background: rgba(33, 33, 33, 0.95);  /* Match scene background */
+      border-left: 1px solid rgba(255, 255, 255, 0.1);
+      padding: 15px;
+      z-index: 1000;
+      min-width: 300px;
+      overflow-y: auto;
+      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
+    }
+
+    .control-panel-header {
       display: flex;
-      justify-content: center;
+      justify-content: space-between;
       align-items: center;
-      z-index: 2000;
+      margin-bottom: 15px;
+      padding-bottom: 10px;
+      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
     }
 
-    .loading-overlay .spinner {
-      width: 50px;
-      height: 50px;
-      border: 3px solid rgba(255, 255, 255, 0.1);
-      border-radius: 50%;
-      border-top-color: #4a90e2;
-      animation: spin 1s ease-in-out infinite;
+    .control-panel-header h3 {
+      margin: 0;
+      font-size: 1.2em;
+      color: #ffffff;
     }
 
-    @keyframes spin {
-      to { transform: rotate(360deg); }
+    .connection-status {
+      display: inline-block;
+      padding: 4px 8px;
+      border-radius: 4px;
+      font-size: 0.9em;
     }
 
-    .error-message {
-      position: fixed;
-      top: 20px;
-      right: 20px;
-      background: rgba(255, 59, 48, 0.9);
-      color: white;
-      padding: 12px 20px;
-      border-radius: 6px;
-      font-size: 14px;
-      z-index: 2001;
-      animation: fadeIn 0.3s ease;
+    .connection-status.connected {
+      background: rgba(76, 175, 80, 0.2);
+      color: #4CAF50;
+    }
+
+    .connection-status.disconnected {
+      background: rgba(244, 67, 54, 0.2);
+      color: #F44336;
     }
 
-    @keyframes fadeIn {
-      from { opacity: 0; transform: translateY(-10px); }
-      to { opacity: 1; transform: translateY(0); }
+    .settings-group {
+      margin-bottom: 20px;
+      padding: 10px;
+      border-radius: 4px;
+      background: rgba(255, 255, 255, 0.05);
+    }
+
+    .settings-group h4 {
+      margin: 0 0 10px 0;
+      color: #ffffff;
+      font-size: 1em;
+    }
+
+    .setting-item {
+      margin-bottom: 10px;
+    }
+
+    .setting-item label {
+      display: block;
+      margin-bottom: 5px;
+      color: rgba(255, 255, 255, 0.8);
+    }
+
+    .setting-item input[type="text"],
+    .setting-item input[type="number"],
+    .setting-item select {
+      width: 100%;
+      padding: 6px;
+      border: 1px solid rgba(255, 255, 255, 0.1);
+      border-radius: 4px;
+      background: rgba(255, 255, 255, 0.1);
+      color: #ffffff;
+    }
+
+    .setting-item input[type="checkbox"] {
+      margin-right: 8px;
+    }
+
+    .setting-item input:focus,
+    .setting-item select:focus {
+      outline: none;
+      border-color: rgba(255, 255, 255, 0.3);
+      background: rgba(255, 255, 255, 0.15);
     }
   </style>
 </head>
 <body>
-  <div class="loading-overlay">
-    <div class="spinner"></div>
-  </div>
-  <div id="canvas-container">
+  <div id="scene-container">
     <canvas id="main-canvas"></canvas>
   </div>
-  <div id="settings-panel" class="control-panel">
-    <button class="toggle-button" aria-label="Toggle Settings Panel">⚙</button>
+  <div id="control-panel">
     <div class="control-panel-header">
       <h3>Settings</h3>
       <div class="connection-status">
@@ -91,8 +129,8 @@
       <!-- Settings sections will be dynamically populated by ControlPanel.ts -->
     </div>
     <div class="settings-actions">
-      <button class="secondary-button" id="reset-settings">Reset</button>
-      <button class="primary-button" id="save-settings">Save</button>
+      <button id="reset-settings">Reset</button>
+      <button id="save-settings">Save</button>
     </div>
   </div>
   <script type="module" src="/index.ts"></script>
diff --git a/client/index.ts b/client/index.ts
index 3818e7cd..3afea4f2 100644
--- a/client/index.ts
+++ b/client/index.ts
@@ -1,29 +1,20 @@
-/**
- * LogseqXR Application Entry Point
- */
-
 import { platformManager } from './platform/platformManager';
-import { Settings, SettingCategory, SettingKey, SettingValueType } from './types/settings';
 import { settingsManager } from './state/settings';
-import { graphDataManager } from './state/graphData';
-import { WebSocketService } from './websocket/websocketService';
+import { setDebugEnabled } from './core/logger';
+import { createLogger } from './core/logger';
 import { SceneManager } from './rendering/scene';
 import { NodeManager } from './rendering/nodes';
-import { TextRenderer } from './rendering/textRenderer';
+import { WebSocketService } from './websocket/websocketService';
+import { graphDataManager } from './state/graphData';
 import { XRSessionManager } from './xr/xrSessionManager';
-import { XRInteraction } from './xr/xrInteraction';
-import { createLogger, setDebugEnabled } from './utils/logger';
 import { ControlPanel } from './ui/ControlPanel';
 
 const logger = createLogger('Application');
 
 class Application {
-    private webSocket!: WebSocketService;
-    private sceneManager!: SceneManager;
-    private nodeManager!: NodeManager;
-    private textRenderer!: TextRenderer;
+    private sceneManager: SceneManager | null = null;
+    private nodeManager: NodeManager | null = null;
     private xrManager: XRSessionManager | null = null;
-    private xrInteraction: XRInteraction | null = null;
 
     constructor() {
         this.initializeApplication();
@@ -31,139 +22,97 @@ class Application {
 
     private async initializeApplication(): Promise<void> {
         try {
-            // Initialize platform manager
             await platformManager.initialize();
-
-            // Initialize settings
             await settingsManager.initialize();
-            
-            // Update logger debug state from settings
+
             const settings = settingsManager.getCurrentSettings();
-            setDebugEnabled(settings.clientDebug.enabled);
-            logger.info('Debug logging ' + (settings.clientDebug.enabled ? 'enabled' : 'disabled'));
+            setDebugEnabled(settings.system.debug.enabled);
+            logger.info(`Debug logging ${settings.system.debug.enabled ? 'enabled' : 'disabled'}`);
 
-            // Initialize scene first so we can render nodes when data arrives
             this.initializeScene();
 
             try {
-                // Load initial graph data from REST endpoint
                 await graphDataManager.loadInitialGraphData();
-            } catch (graphError) {
-                logger.error('Failed to load graph data:', graphError);
-                // Continue initialization even if graph data fails
-            }
-
-            try {
-                // Initialize WebSocket for real-time updates
-                this.webSocket = new WebSocketService();
-
-                // Setup WebSocket event handler for binary position updates
-                this.webSocket.on('binaryPositionUpdate', (data: any['data']) => {
-                    if (data && data.nodes) {
-                        // Convert nodes data to ArrayBuffer for position updates
-                        const buffer = new ArrayBuffer(data.nodes.length * 24); // 6 floats per node
-                        const floatArray = new Float32Array(buffer);
-                        
-                        data.nodes.forEach((node: { data: { position: any; velocity: any } }, index: number) => {
-                            const baseIndex = index * 6;
-                            const pos = node.data.position;
-                            const vel = node.data.velocity;
-                            
-                            // Position
-                            floatArray[baseIndex] = pos.x;
-                            floatArray[baseIndex + 1] = pos.y;
-                            floatArray[baseIndex + 2] = pos.z;
-                            // Velocity
-                            floatArray[baseIndex + 3] = vel.x;
-                            floatArray[baseIndex + 4] = vel.y;
-                            floatArray[baseIndex + 5] = vel.z;
+                const webSocket = WebSocketService.getInstance();
+                webSocket.onBinaryMessage((nodes: { position: [number, number, number]; velocity: [number, number, number] }[]) => {
+                    const float32Array = new Float32Array(nodes.length * 6);
+                    nodes.forEach((node, i) => {
+                        const baseIndex = i * 6;
+                        float32Array[baseIndex] = node.position[0];
+                        float32Array[baseIndex + 1] = node.position[1];
+                        float32Array[baseIndex + 2] = node.position[2];
+                        float32Array[baseIndex + 3] = node.velocity[0];
+                        float32Array[baseIndex + 4] = node.velocity[1];
+                        float32Array[baseIndex + 5] = node.velocity[2];
+                    });
+                    graphDataManager.updatePositions(float32Array.buffer);
+
+                    if (this.nodeManager) {
+                        const positionsArray = new Float32Array(nodes.length * 3);
+                        nodes.forEach((node, i) => {
+                            const baseIndex = i * 3;
+                            positionsArray[baseIndex] = node.position[0];
+                            positionsArray[baseIndex + 1] = node.position[1];
+                            positionsArray[baseIndex + 2] = node.position[2];
                         });
-
-                        // Update graph data and visual representation
-                        graphDataManager.updatePositions(buffer);
-                        this.nodeManager.updatePositions(floatArray);
+                        this.nodeManager.updatePositions(positionsArray);
                     }
                 });
-            } catch (wsError) {
-                logger.error('Failed to initialize WebSocket:', wsError);
-                // Continue initialization even if WebSocket fails
+            } catch (error) {
+                logger.error('Failed to initialize data services:', error);
+                this.showError('Failed to initialize data services');
             }
 
             try {
-                // Initialize XR if supported
                 await this.initializeXR();
             } catch (xrError) {
                 logger.error('Failed to initialize XR:', xrError);
-                // Continue initialization even if XR fails
             }
 
-            // Initialize UI components
             const controlPanelContainer = document.getElementById('control-panel');
             if (!controlPanelContainer) {
                 logger.warn('Control panel container not found, skipping UI initialization');
             } else {
                 new ControlPanel(controlPanelContainer);
-                // Setup UI event listeners
                 this.setupUIEventListeners();
             }
 
-            // Subscribe to graph data updates
             graphDataManager.subscribe(() => {
-                // Hide loading overlay after initial data is loaded
                 this.hideLoadingOverlay();
             });
 
             logger.log('Application initialized successfully');
-            // Always hide loading overlay after initialization
             this.hideLoadingOverlay();
+
         } catch (error) {
             logger.error('Failed to initialize application:', error);
             this.showError('Failed to initialize application');
-            // Still try to hide loading overlay
             this.hideLoadingOverlay();
         }
     }
 
     private initializeScene(): void {
-        // Get canvas element
-        const container = document.getElementById('canvas-container');
+        const container = document.getElementById('scene-container');
         if (!container) {
-            throw new Error('Canvas container not found');
+            throw new Error('Scene container not found');
         }
 
-        // Create canvas
         const canvas = document.createElement('canvas');
         container.appendChild(canvas);
 
-        // Initialize scene manager
         this.sceneManager = SceneManager.getInstance(canvas);
-
-        // Initialize node manager
         this.nodeManager = NodeManager.getInstance();
 
-        // Add node meshes to scene
         const nodeMeshes = this.nodeManager.getAllNodeMeshes();
-        nodeMeshes.forEach(mesh => this.sceneManager.add(mesh));
-
-        // Initialize text renderer
-        this.textRenderer = new TextRenderer(this.sceneManager.getCamera());
+        nodeMeshes.forEach(mesh => this.sceneManager?.add(mesh));
 
-        // Start rendering
         this.sceneManager.start();
         logger.log('Scene initialized with node meshes');
     }
 
     private async initializeXR(): Promise<void> {
         if (platformManager.getCapabilities().xrSupported) {
-            // Initialize XR manager
-            this.xrManager = XRSessionManager.getInstance(this.sceneManager);
-
-            // Initialize XR interaction
-            if (this.xrManager && this.nodeManager) {
-                this.xrInteraction = XRInteraction.getInstance(this.xrManager, this.nodeManager);
-            }
-
-            // Setup XR button
+            this.xrManager = XRSessionManager.getInstance(this.sceneManager!);
             const xrButton = document.getElementById('xr-button');
             if (xrButton) {
                 xrButton.style.display = 'block';
@@ -173,98 +122,31 @@ class Application {
     }
 
     private setupUIEventListeners(): void {
-        // Settings panel save button
         const saveButton = document.getElementById('save-settings');
         if (saveButton) {
             saveButton.addEventListener('click', () => this.saveSettings());
         }
-
-        // Settings inputs
         this.setupSettingsInputListeners();
     }
 
     private setupSettingsInputListeners(): void {
-        // Node appearance settings
-        this.setupSettingInput<'nodes', 'baseSize'>('nodes', 'baseSize');
-        this.setupSettingInput<'nodes', 'baseColor'>('nodes', 'baseColor');
-        this.setupSettingInput<'nodes', 'opacity'>('nodes', 'opacity');
-
-        // Edge appearance settings
-        this.setupSettingInput<'edges', 'color'>('edges', 'color');
-        this.setupSettingInput<'edges', 'opacity'>('edges', 'opacity');
-        this.setupSettingInput<'edges', 'enableArrows'>('edges', 'enableArrows');
-
-        // Visual effects settings
-        this.setupSettingInput<'bloom', 'edgeBloomStrength'>('bloom', 'edgeBloomStrength');
-
-        // Physics settings
-        this.setupSettingInput<'physics', 'enabled'>('physics', 'enabled');
-        this.setupSettingInput<'physics', 'springStrength'>('physics', 'springStrength');
-    }
-
-    private setupSettingInput<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K
-    ): void {
-        const input = document.getElementById(`${String(category)}-${String(setting)}`) as HTMLInputElement;
-        if (input) {
-            input.addEventListener('change', async (event) => {
-                const currentValue = (event.target as HTMLInputElement).value;
-
-                try {
-                    const response = await fetch(`/api/visualization/settings/${String(category)}/${String(setting)}`, {
-                        method: 'PUT',
-                        headers: {
-                            'Content-Type': 'application/json',
-                        },
-                        body: JSON.stringify({ value: currentValue }),
-                    });
-
-                    if (!response.ok) {
-                        throw new Error(`HTTP error! status: ${response.status}`);
-                    }
-
-                    await settingsManager.updateSetting(
-                        category,
-                        setting,
-                        this.parseSettingValue<T, K>(currentValue, category, setting)
-                    );
-                } catch (error) {
-                    logger.error(`Failed to update setting ${String(category)}.${String(setting)}:`, error);
-                    this.showError(`Failed to update ${String(category)} ${String(setting)}`);
-                }
-            });
-        }
-    }
-
-    private parseSettingValue<T extends SettingCategory, K extends SettingKey<T>>(
-        value: string,
-        category: T,
-        setting: K
-    ): SettingValueType<T, K> {
-        const currentSettings = settingsManager.getCurrentSettings();
-        const currentValue = currentSettings[category][setting];
-        
-        switch (typeof currentValue) {
-            case 'number':
-                return Number(value) as SettingValueType<T, K>;
-            case 'boolean':
-                return (value === 'true') as SettingValueType<T, K>;
-            default:
-                return value as SettingValueType<T, K>;
-        }
+        // Add any settings input listeners here
     }
 
     private async saveSettings(): Promise<void> {
         try {
             const currentSettings = settingsManager.getCurrentSettings();
-            const categories = ['nodes', 'edges', 'rendering', 'physics', 'labels', 'bloom', 'clientDebug'] as const;
-            
-            for (const category of categories) {
-                const categorySettings = currentSettings[category];
-                for (const [setting, value] of Object.entries(categorySettings)) {
+            const visualizationSettings = currentSettings.visualization;
+
+            for (const [category, settings] of Object.entries(visualizationSettings)) {
+                if (typeof settings !== 'object' || !settings) continue;
+
+                for (const [setting, value] of Object.entries(settings)) {
+                    if (typeof value === 'object' && value !== null) continue;
+                    if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean' && !Array.isArray(value)) continue;
+
                     try {
-                        const response = await fetch(`/api/visualization/settings/${String(category)}/${String(setting)}`, {
+                        const response = await fetch(`/api/settings/${String(category)}/${String(setting)}`, {
                             method: 'PUT',
                             headers: {
                                 'Content-Type': 'application/json'
@@ -276,11 +158,8 @@ class Application {
                             throw new Error(`Failed to update setting: ${response.statusText}`);
                         }
 
-                        await settingsManager.updateSetting(
-                            category,
-                            setting as keyof Settings[typeof category],
-                            value as SettingValueType<typeof category, keyof Settings[typeof category]>
-                        );
+                        const path = `visualization.${category}.${setting}`;
+                        await settingsManager.updateSetting(path, value);
                     } catch (error) {
                         logger.error(`Failed to update setting ${String(category)}.${String(setting)}:`, error);
                     }
@@ -308,69 +187,62 @@ class Application {
     }
 
     private hideLoadingOverlay(): void {
-        const loadingOverlay = document.getElementById('loading-overlay');
-        if (loadingOverlay) {
-            loadingOverlay.style.opacity = '0';
+        const overlay = document.querySelector('.loading-overlay');
+        if (overlay instanceof HTMLElement) {
+            overlay.style.opacity = '0';
             setTimeout(() => {
-                loadingOverlay.style.display = 'none';
+                overlay.style.display = 'none';
             }, 500);
         }
     }
 
     private showError(message: string): void {
-        const errorDiv = document.createElement('div');
-        errorDiv.style.cssText = `
-            position: fixed;
-            top: 20px;
-            left: 50%;
-            transform: translateX(-50%);
-            background-color: rgba(255, 0, 0, 0.8);
-            color: white;
-            padding: 15px;
-            border-radius: 5px;
-            z-index: 1000;
-            text-align: center;
-            font-family: Arial, sans-serif;
-            font-size: 14px;
-            max-width: 80%;
-            word-wrap: break-word;
-            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
-        `;
-        errorDiv.textContent = message;
-        document.body.appendChild(errorDiv);
-        setTimeout(() => {
-            errorDiv.style.opacity = '0';
-            errorDiv.style.transition = 'opacity 0.5s ease-out';
-            setTimeout(() => errorDiv.remove(), 500);
-        }, 5000);
+        const overlay = document.querySelector('.loading-overlay');
+        if (overlay instanceof HTMLElement) {
+            const spinner = overlay.querySelector('.spinner');
+            if (spinner) {
+                spinner.remove();
+            }
+
+            const error = document.createElement('div');
+            error.className = 'error-message';
+            error.textContent = message;
+            overlay.appendChild(error);
+
+            overlay.style.display = 'flex';
+            overlay.style.opacity = '1';
+        }
     }
 
-    dispose(): void {
-        // Dispose of managers in reverse order of initialization
-        settingsManager.dispose();
-        this.xrInteraction?.dispose();
-        this.xrManager?.dispose();
-        this.textRenderer.dispose();
-        this.nodeManager.dispose();
-        this.sceneManager.dispose();
-
-        // Stop rendering
-        this.sceneManager.stop();
-
-        // Close WebSocket connection if it exists
-        if (this.webSocket) {
-            this.webSocket.dispose();
+    public dispose(): void {
+        if (this.sceneManager) {
+            SceneManager.cleanup();
         }
+        
+        const webSocket = WebSocketService.getInstance();
+        if (webSocket) {
+            webSocket.dispose();
+        }
+        
+        graphDataManager.clear();
+        
+        if (this.xrManager) {
+            this.xrManager.dispose();
+        }
+        
+        const container = document.getElementById('scene-container');
+        if (container) {
+            container.innerHTML = '';
+        }
+        
+        logger.log('Application disposed');
     }
 }
 
-// Create application instance
 const app = new Application();
 
-// Handle window unload
 window.addEventListener('unload', () => {
     app.dispose();
 });
 
-// Log application start
 console.info('LogseqXR application starting...');
diff --git a/client/rendering/EnhancedNodeManager.ts b/client/rendering/EnhancedNodeManager.ts
new file mode 100644
index 00000000..8e54ba7d
--- /dev/null
+++ b/client/rendering/EnhancedNodeManager.ts
@@ -0,0 +1,142 @@
+import {
+    Scene,
+    PerspectiveCamera,
+    InstancedMesh,
+    Matrix4,
+    Vector3,
+    Mesh,
+    Object3D,
+    Quaternion,
+    WebGLRenderer
+} from 'three';
+import { Node } from '../core/types';
+import { Settings } from '../types/settings';
+import { MetadataVisualizer } from './MetadataVisualizer';
+import { HologramManager } from './HologramManager';
+import { XRHandWithHaptics } from '../types/xr';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+
+export class EnhancedNodeManager {
+    private readonly nodeInstances: InstancedMesh;
+    private readonly metadataVisualizer: MetadataVisualizer;
+    private readonly hologramManager: HologramManager;
+    private readonly nodeDataMap = new Map<string, Matrix4>();
+    private readonly quaternion = new Quaternion();
+    private readonly camera: PerspectiveCamera;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly materialFactory: MaterialFactory;
+
+    constructor(
+        private readonly scene: Scene,
+        renderer: WebGLRenderer,
+        private readonly settings: Settings
+    ) {
+        // Get the camera from the scene
+        const camera = scene.children.find(child => child instanceof PerspectiveCamera) as PerspectiveCamera;
+        if (!camera) {
+            throw new Error('No PerspectiveCamera found in scene');
+        }
+        this.camera = camera;
+
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.materialFactory = MaterialFactory.getInstance();
+
+        this.metadataVisualizer = new MetadataVisualizer(this.camera, this.scene, this.settings);
+        this.hologramManager = new HologramManager(scene, renderer, settings);
+        scene.add(this.hologramManager.getGroup());
+
+        const geometry = this.geometryFactory.getNodeGeometry(this.settings.xr.quality);
+        const material = this.materialFactory.getNodeMaterial(settings);
+
+        this.nodeInstances = new InstancedMesh(geometry, material, 1000);
+        this.nodeInstances.count = 0;
+        scene.add(this.nodeInstances);
+    }
+
+    handleSettingsUpdate(settings: Settings) {
+        this.materialFactory.updateMaterial('node-basic', settings);
+    }
+
+    updateNodes(nodes: Node[]) {
+        this.nodeInstances.count = nodes.length;
+
+        nodes.forEach((node, index) => {
+            const metadata = {
+                id: node.id,
+                name: node.data.metadata?.name || '',
+                commitAge: this.calculateCommitAge(node.data.metadata?.lastModified || Date.now()),
+                hyperlinkCount: node.data.metadata?.links?.length || 0,
+                importance: this.calculateImportance(node),
+                position: {
+                    x: node.data.position.x,
+                    y: node.data.position.y,
+                    z: node.data.position.z
+                }
+            };
+
+            const matrix = new Matrix4();
+
+            if (this.settings.visualization.nodes.enableMetadataShape) {
+                const nodeMesh = this.metadataVisualizer.createNodeMesh(metadata);
+                nodeMesh.position.set(metadata.position.x, metadata.position.y, metadata.position.z);
+                this.scene.add(nodeMesh);
+            } else {
+                const scale = this.calculateNodeScale(metadata.importance);
+                const position = new Vector3(metadata.position.x, metadata.position.y, metadata.position.z);
+                matrix.compose(position, this.quaternion, new Vector3(scale, scale, scale));
+                this.nodeInstances.setMatrixAt(index, matrix);
+            }
+
+            this.nodeDataMap.set(node.id, matrix);
+        });
+
+        this.nodeInstances.instanceMatrix.needsUpdate = true;
+    }
+
+    private calculateCommitAge(timestamp: number): number {
+        const now = Date.now();
+        return (now - timestamp) / (1000 * 60 * 60 * 24); // Convert to days
+    }
+
+    private calculateImportance(node: Node): number {
+        const linkFactor = node.data.metadata?.links ? node.data.metadata.links.length / 20 : 0;
+        const referenceFactor = node.data.metadata?.references ? node.data.metadata.references.length / 10 : 0;
+        return Math.min(linkFactor + referenceFactor, 1);
+    }
+
+    private calculateNodeScale(importance: number): number {
+        const [min, max] = this.settings.visualization.nodes.sizeRange;
+        return min + (max - min) * importance;
+    }
+
+    update(deltaTime: number) {
+        this.hologramManager.update(deltaTime);
+
+        if (this.settings.visualization.animations.enableNodeAnimations) {
+            this.nodeInstances.instanceMatrix.needsUpdate = true;
+            this.scene.traverse(child => {
+                if (child instanceof Mesh) {
+                    child.rotateY(0.001 * deltaTime);
+                }
+            });
+        }
+    }
+
+    handleHandInteraction(hand: XRHandWithHaptics) {
+        const position = new Vector3();
+        const indexTip = hand.hand.joints['index-finger-tip'] as Object3D | undefined;
+        if (indexTip) {
+            position.setFromMatrixPosition(indexTip.matrixWorld);
+            this.hologramManager.handleInteraction(position);
+        }
+    }
+
+    dispose() {
+        this.nodeInstances.geometry.dispose();
+        this.nodeInstances.material.dispose();
+        this.metadataVisualizer.dispose();
+        this.scene.remove(this.nodeInstances);
+        this.scene.remove(this.hologramManager.getGroup());
+    }
+}
diff --git a/client/rendering/HologramManager.ts b/client/rendering/HologramManager.ts
new file mode 100644
index 00000000..f192fb97
--- /dev/null
+++ b/client/rendering/HologramManager.ts
@@ -0,0 +1,142 @@
+import {
+    Scene,
+    Group,
+    Mesh,
+    Vector3,
+    WebGLRenderer
+} from 'three';
+import { Settings } from '../types/settings';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { HologramShaderMaterial } from './materials/HologramShaderMaterial';
+
+export class HologramManager {
+    private readonly group = new Group();
+    private isXRMode = false;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly materialFactory: MaterialFactory;
+
+    constructor(
+        private readonly scene: Scene,
+        _renderer: WebGLRenderer,  // Used by subclasses
+        private settings: Settings
+    ) {
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.materialFactory = MaterialFactory.getInstance();
+        this.createHolograms();
+        this.scene.add(this.group);
+    }
+
+    private createHolograms() {
+        while (this.group.children.length > 0) {
+            const child = this.group.children[0];
+            this.group.remove(child);
+            if (child instanceof Mesh) {
+                child.geometry.dispose();
+                child.material.dispose();
+            }
+        }
+
+        const quality = this.isXRMode ? 'high' : this.settings.xr.quality;
+        const material = this.materialFactory.getHologramMaterial(this.settings);
+
+        for (let i = 0; i < this.settings.visualization.hologram.ringCount; i++) {
+            const ring = new Mesh(
+                this.geometryFactory.getHologramGeometry('ring', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.ringSizes[i] || 20;
+            ring.scale.set(scale, scale, scale);
+            ring.rotateX(Math.PI / 2 * i);
+            ring.rotateY(Math.PI / 4 * i);
+            ring.userData.rotationSpeed = this.settings.visualization.hologram.ringRotationSpeed * (i + 1);
+            this.group.add(ring);
+        }
+
+        if (this.settings.visualization.hologram.enableBuckminster) {
+            const mesh = new Mesh(
+                this.geometryFactory.getHologramGeometry('buckminster', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.buckminsterScale;
+            mesh.scale.set(scale, scale, scale);
+            (mesh.material as HologramShaderMaterial).uniforms.opacity.value = this.settings.visualization.hologram.buckminsterOpacity;
+            this.group.add(mesh);
+        }
+
+        if (this.settings.visualization.hologram.enableGeodesic) {
+            const mesh = new Mesh(
+                this.geometryFactory.getHologramGeometry('geodesic', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.geodesicScale;
+            mesh.scale.set(scale, scale, scale);
+            (mesh.material as HologramShaderMaterial).uniforms.opacity.value = this.settings.visualization.hologram.geodesicOpacity;
+            this.group.add(mesh);
+        }
+
+        if (this.settings.visualization.hologram.enableTriangleSphere) {
+            const mesh = new Mesh(
+                this.geometryFactory.getHologramGeometry('triangleSphere', quality),
+                material.clone()
+            );
+            const scale = this.settings.visualization.hologram.triangleSphereScale;
+            mesh.scale.set(scale, scale, scale);
+            (mesh.material as HologramShaderMaterial).uniforms.opacity.value = this.settings.visualization.hologram.triangleSphereOpacity;
+            this.group.add(mesh);
+        }
+    }
+
+    setXRMode(enabled: boolean) {
+        this.isXRMode = enabled;
+        this.group.traverse(child => {
+            if (child instanceof Mesh && child.material instanceof HologramShaderMaterial) {
+                child.material.defines = { USE_AR: '' };
+                child.material.needsUpdate = true;
+            }
+        });
+        this.createHolograms();
+    }
+
+    handleInteraction(position: Vector3) {
+        this.group.traverse(child => {
+            if (child instanceof Mesh && child.material instanceof HologramShaderMaterial) {
+                const distance = position.distanceTo(child.position);
+                if (distance < 0.5) {
+                    child.material.uniforms.pulseIntensity.value = 0.4;
+                    setTimeout(() => {
+                        if (child.material instanceof HologramShaderMaterial) {
+                            child.material.uniforms.pulseIntensity.value = 0.2;
+                        }
+                    }, 500);
+                }
+            }
+        });
+    }
+
+    update(deltaTime: number) {
+        this.group.traverse(child => {
+            if (child instanceof Mesh) {
+                child.rotateY((child.userData.rotationSpeed || this.settings.visualization.hologram.globalRotationSpeed) * deltaTime);
+                if (child.material instanceof HologramShaderMaterial) {
+                    child.material.uniforms.time.value += deltaTime;
+                }
+            }
+        });
+    }
+
+    updateSettings(newSettings: Settings) {
+        this.settings = newSettings;
+        this.materialFactory.updateMaterial('hologram', this.settings);
+        this.createHolograms();
+    }
+
+    getGroup() {
+        return this.group;
+    }
+
+    dispose() {
+        // Geometries and materials are managed by the factories
+        this.scene.remove(this.group);
+    }
+}
diff --git a/client/rendering/MetadataVisualizer.ts b/client/rendering/MetadataVisualizer.ts
new file mode 100644
index 00000000..7d63881b
--- /dev/null
+++ b/client/rendering/MetadataVisualizer.ts
@@ -0,0 +1,154 @@
+import { 
+    Color, 
+    Matrix4, 
+    Mesh, 
+    PerspectiveCamera, 
+    Scene, 
+    Vector3, 
+    Material,
+    MeshBasicMaterial,
+    Quaternion
+} from 'three';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { Metadata } from '../types/metadata';
+import { Settings } from '../types/settings';
+import { defaultSettings } from '../state/defaultSettings';
+
+export class MetadataVisualizer {
+    private readonly camera: PerspectiveCamera;
+    private readonly scene: Scene;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly materialFactory: MaterialFactory;
+    private settings: Settings;
+    private nodes: Map<string, Mesh> = new Map();
+
+    constructor(camera: PerspectiveCamera, scene: Scene, settings: Settings = defaultSettings) {
+        this.camera = camera;
+        this.scene = scene;
+        this.settings = settings;
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.materialFactory = MaterialFactory.getInstance();
+    }
+
+    public createNodeMesh(metadata: Metadata): Mesh {
+        const geometry = this.geometryFactory.getNodeGeometry(this.settings.xr.quality);
+        const material = this.materialFactory.getMetadataMaterial();
+        
+        const mesh = new Mesh(geometry, material);
+        mesh.position.set(
+            metadata.position?.x || 0,
+            metadata.position?.y || 0,
+            metadata.position?.z || 0
+        );
+        
+        this.nodes.set(metadata.id, mesh);
+        this.scene.add(mesh);
+        
+        return mesh;
+    }
+
+    public dispose(): void {
+        this.nodes.forEach(mesh => {
+            this.scene.remove(mesh);
+            mesh.geometry.dispose();
+            if (Array.isArray(mesh.material)) {
+                mesh.material.forEach(m => m.dispose());
+            } else {
+                mesh.material.dispose();
+            }
+        });
+        this.nodes.clear();
+    }
+
+    public updateNodeMetadata(
+        mesh: Mesh,
+        _age: number,
+        linkCount: number,
+        material: Material
+    ): void {
+        // Calculate color based on link count
+        if (material instanceof MeshBasicMaterial) {
+            // Simple color interpolation based on link count
+            const intensity = Math.min(linkCount / 10, 1); // Cap at 10 links
+            
+            // Convert RGB values to hex
+            const red = Math.floor(intensity * 255);
+            const green = Math.floor((1 - intensity) * 255);
+            const blue = 0;
+            const hexColor = (red << 16) | (green << 8) | blue;
+            
+            // Create and assign color
+            const newColor = new Color(hexColor);
+            material.color = newColor;
+        }
+
+        // Update mesh orientation to face camera
+        const meshPosition = mesh.position;
+        const cameraPosition = this.camera.position;
+
+        // Calculate direction from mesh to camera
+        const direction = new Vector3()
+            .subVectors(cameraPosition, meshPosition)
+            .normalize();
+
+        // Calculate up vector (world up)
+        const up = new Vector3(0, 1, 0);
+
+        // Calculate right vector
+        const right = new Vector3()
+            .crossVectors(up, direction)
+            .normalize();
+
+        // Recalculate up vector to ensure orthogonality
+        up.crossVectors(direction, right).normalize();
+
+        // Create rotation matrix
+        const rotationMatrix = new Matrix4();
+        rotationMatrix.elements = [
+            right.x, up.x, direction.x, 0,
+            right.y, up.y, direction.y, 0,
+            right.z, up.z, direction.z, 0,
+            0, 0, 0, 1
+        ];
+
+        // Create quaternion from direction
+        const quaternion = new Quaternion();
+        const m = rotationMatrix.elements;
+        const trace = m[0] + m[5] + m[10];
+
+        if (trace > 0) {
+            const s = 0.5 / Math.sqrt(trace + 1.0);
+            quaternion.w = 0.25 / s;
+            quaternion.x = (m[6] - m[9]) * s;
+            quaternion.y = (m[8] - m[2]) * s;
+            quaternion.z = (m[1] - m[4]) * s;
+        } else {
+            if (m[0] > m[5] && m[0] > m[10]) {
+                const s = 2.0 * Math.sqrt(1.0 + m[0] - m[5] - m[10]);
+                quaternion.w = (m[6] - m[9]) / s;
+                quaternion.x = 0.25 * s;
+                quaternion.y = (m[1] + m[4]) / s;
+                quaternion.z = (m[8] + m[2]) / s;
+            } else if (m[5] > m[10]) {
+                const s = 2.0 * Math.sqrt(1.0 + m[5] - m[0] - m[10]);
+                quaternion.w = (m[8] - m[2]) / s;
+                quaternion.x = (m[1] + m[4]) / s;
+                quaternion.y = 0.25 * s;
+                quaternion.z = (m[6] + m[9]) / s;
+            } else {
+                const s = 2.0 * Math.sqrt(1.0 + m[10] - m[0] - m[5]);
+                quaternion.w = (m[1] - m[4]) / s;
+                quaternion.x = (m[8] + m[2]) / s;
+                quaternion.y = (m[6] + m[9]) / s;
+                quaternion.z = 0.25 * s;
+            }
+        }
+
+        // Apply rotation
+        mesh.quaternion.x = quaternion.x;
+        mesh.quaternion.y = quaternion.y;
+        mesh.quaternion.z = quaternion.z;
+        mesh.quaternion.w = quaternion.w;
+    }
+}
diff --git a/client/rendering/factories/GeometryFactory.ts b/client/rendering/factories/GeometryFactory.ts
new file mode 100644
index 00000000..07b329db
--- /dev/null
+++ b/client/rendering/factories/GeometryFactory.ts
@@ -0,0 +1,71 @@
+import { BufferGeometry, SphereGeometry } from 'three';
+
+export class GeometryFactory {
+    private static instance: GeometryFactory;
+    private geometryCache = new Map<string, BufferGeometry>();
+
+    private constructor() {}
+
+    static getInstance(): GeometryFactory {
+        if (!GeometryFactory.instance) {
+            GeometryFactory.instance = new GeometryFactory();
+        }
+        return GeometryFactory.instance;
+    }
+
+    getNodeGeometry(quality: 'low' | 'medium' | 'high'): BufferGeometry {
+        const cacheKey = `node-${quality}`;
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        const segments = {
+            low: 8,
+            medium: 16,
+            high: 32
+        }[quality] || 16;
+
+        const geometry = new SphereGeometry(1, segments, segments);
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    getHologramGeometry(type: string, quality: string): BufferGeometry {
+        const cacheKey = `hologram-${type}-${quality}`;
+        if (this.geometryCache.has(cacheKey)) {
+            return this.geometryCache.get(cacheKey)!;
+        }
+
+        const segments = {
+            low: { ring: 32, sphere: 8 },
+            medium: { ring: 64, sphere: 16 },
+            high: { ring: 128, sphere: 32 }
+        }[quality] || { ring: 64, sphere: 16 };
+
+        let geometry: BufferGeometry;
+        switch (type) {
+            case 'ring':
+                geometry = new SphereGeometry(1, segments.ring, segments.ring);
+                break;
+            case 'buckminster':
+                geometry = new SphereGeometry(1, 20, 20);
+                break;
+            case 'geodesic':
+                geometry = new SphereGeometry(1, 16, 16);
+                break;
+            case 'triangleSphere':
+                geometry = new SphereGeometry(1, segments.sphere, segments.sphere);
+                break;
+            default:
+                geometry = new SphereGeometry(1, segments.sphere, segments.sphere);
+        }
+
+        this.geometryCache.set(cacheKey, geometry);
+        return geometry;
+    }
+
+    dispose(): void {
+        this.geometryCache.forEach(geometry => geometry.dispose());
+        this.geometryCache.clear();
+    }
+}
diff --git a/client/rendering/factories/MaterialFactory.ts b/client/rendering/factories/MaterialFactory.ts
new file mode 100644
index 00000000..d3a588dd
--- /dev/null
+++ b/client/rendering/factories/MaterialFactory.ts
@@ -0,0 +1,111 @@
+import { Color, DoubleSide, Material, MeshBasicMaterial, MeshPhongMaterial } from 'three';
+import { Settings } from '../../types/settings';
+import { HologramShaderMaterial } from '../materials/HologramShaderMaterial';
+
+export class MaterialFactory {
+    private static instance: MaterialFactory;
+    private materialCache = new Map<string, Material>();
+
+    private constructor() {}
+
+    static getInstance(): MaterialFactory {
+        if (!MaterialFactory.instance) {
+            MaterialFactory.instance = new MaterialFactory();
+        }
+        return MaterialFactory.instance;
+    }
+
+    getNodeMaterial(settings: Settings): Material {
+        const cacheKey = 'node-basic';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshBasicMaterial({
+            color: settings.visualization.nodes.baseColor,
+            transparent: true,
+            opacity: settings.visualization.nodes.opacity
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    getPhongNodeMaterial(): Material {
+        const cacheKey = 'node-phong';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshPhongMaterial({
+            color: 0x4fc3f7,
+            shininess: 30,
+            specular: 0x004ba0,
+            transparent: true,
+            opacity: 0.9,
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    getMetadataMaterial(): Material {
+        const cacheKey = 'metadata';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey)!;
+        }
+
+        const material = new MeshBasicMaterial({
+            color: new Color('#00ff00'),
+            transparent: true,
+            opacity: 0.8,
+            side: DoubleSide
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    getHologramMaterial(settings: Settings): HologramShaderMaterial {
+        const cacheKey = 'hologram';
+        if (this.materialCache.has(cacheKey)) {
+            return this.materialCache.get(cacheKey) as HologramShaderMaterial;
+        }
+
+        const material = new HologramShaderMaterial({
+            uniforms: {
+                color: { value: new Color(settings.visualization.hologram.ringColor) },
+                opacity: { value: settings.visualization.hologram.ringOpacity },
+                time: { value: 0 },
+                pulseSpeed: { value: 1.0 },
+                pulseIntensity: { value: 0.2 }
+            }
+        });
+
+        this.materialCache.set(cacheKey, material);
+        return material;
+    }
+
+    updateMaterial(type: string, settings: Settings): void {
+        const material = this.materialCache.get(type);
+        if (!material) return;
+
+        switch (type) {
+            case 'node-basic':
+            case 'node-phong':
+                (material as MeshBasicMaterial | MeshPhongMaterial).color.set(settings.visualization.nodes.baseColor);
+                material.opacity = settings.visualization.nodes.opacity;
+                break;
+            case 'hologram':
+                const hologramMaterial = material as HologramShaderMaterial;
+                hologramMaterial.uniforms.color.value = new Color(settings.visualization.hologram.ringColor);
+                hologramMaterial.uniforms.opacity.value = settings.visualization.hologram.ringOpacity;
+                break;
+        }
+    }
+
+    dispose(): void {
+        this.materialCache.forEach(material => material.dispose());
+        this.materialCache.clear();
+    }
+}
diff --git a/client/rendering/materials/HologramShaderMaterial.ts b/client/rendering/materials/HologramShaderMaterial.ts
new file mode 100644
index 00000000..9234aa19
--- /dev/null
+++ b/client/rendering/materials/HologramShaderMaterial.ts
@@ -0,0 +1,79 @@
+import { Color, DoubleSide, Material, MaterialParameters } from 'three';
+
+export interface HologramUniforms {
+    color: { value: Color };
+    opacity: { value: number };
+    time: { value: number };
+    pulseSpeed: { value: number };
+    pulseIntensity: { value: number };
+}
+
+export class HologramShaderMaterial extends Material {
+    uniforms: HologramUniforms;
+    defines: { [key: string]: string | number | boolean };
+    vertexShader: string;
+    fragmentShader: string;
+    transparent: boolean;
+    side: typeof DoubleSide;
+    depthWrite: boolean;
+    needsUpdate: boolean;
+
+    constructor(params: MaterialParameters & { uniforms: HologramUniforms }) {
+        super();
+        this.uniforms = params.uniforms;
+        this.defines = {};
+        this.vertexShader = `
+            varying vec3 vPosition;
+            varying vec2 vUv;
+            void main() {
+                vPosition = position;
+                vUv = uv;
+                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+            }
+        `;
+        this.fragmentShader = `
+            uniform vec3 color;
+            uniform float opacity;
+            uniform float time;
+            uniform float pulseSpeed;
+            uniform float pulseIntensity;
+            varying vec3 vPosition;
+            varying vec2 vUv;
+            
+            void main() {
+                float pulse = sin(time * pulseSpeed) * pulseIntensity + 1.0;
+                float edge = 1.0 - smoothstep(0.4, 0.5, abs(vUv.y - 0.5));
+                vec3 finalColor = color * pulse;
+                float finalOpacity = opacity * edge;
+                
+                #ifdef USE_AR
+                    float depth = gl_FragCoord.z / gl_FragCoord.w;
+                    finalOpacity *= smoothstep(10.0, 0.0, depth);
+                #endif
+                
+                gl_FragColor = vec4(finalColor, finalOpacity);
+            }
+        `;
+        this.transparent = true;
+        this.side = DoubleSide;
+        this.depthWrite = false;
+        this.needsUpdate = true;
+    }
+
+    clone(): this {
+        const material = new HologramShaderMaterial({
+            uniforms: {
+                color: { value: new Color(this.uniforms.color.value) },
+                opacity: { value: this.uniforms.opacity.value },
+                time: { value: this.uniforms.time.value },
+                pulseSpeed: { value: this.uniforms.pulseSpeed.value },
+                pulseIntensity: { value: this.uniforms.pulseIntensity.value }
+            }
+        });
+        return material as this;
+    }
+
+    dispose(): void {
+        super.dispose();
+    }
+}
diff --git a/client/rendering/nodes.ts b/client/rendering/nodes.ts
index f867a8f6..f1cc7b0a 100644
--- a/client/rendering/nodes.ts
+++ b/client/rendering/nodes.ts
@@ -1,17 +1,15 @@
 import * as THREE from 'three';
 import { Node } from '../core/types';
-import { createLogger } from '../utils/logger';
+import { createLogger } from '../core/logger';
 import { settingsManager } from '../state/settings';
 import type { Settings } from '../types/settings';
-import type { NodeSettings, PhysicsSettings } from '../core/types';
+import { GeometryFactory } from './factories/GeometryFactory';
+import { MaterialFactory } from './factories/MaterialFactory';
+import { SettingsObserver } from '../state/SettingsObserver';
 
 const logger = createLogger('NodeManager');
 
-const NODE_SEGMENTS = 32;
-const EDGE_SEGMENTS = 8;
-const BINARY_VERSION = 1.0;
 const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
-const VERSION_OFFSET = 1;    // Skip version float
 
 // Reusable vectors and matrices
 const matrix = new THREE.Matrix4();
@@ -23,33 +21,31 @@ export class NodeRenderer {
     public readonly material: THREE.Material;
     protected currentSettings: Settings;
     public mesh: THREE.Mesh;
+    private readonly materialFactory: MaterialFactory;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly settingsObserver: SettingsObserver;
 
     constructor() {
         this.currentSettings = settingsManager.getCurrentSettings();
-        this.material = new THREE.MeshPhongMaterial({
-            color: 0x4fc3f7,
-            shininess: 30,
-            specular: 0x004ba0,
-            transparent: true,
-            opacity: 0.9,
-        });
+        this.materialFactory = MaterialFactory.getInstance();
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.settingsObserver = SettingsObserver.getInstance();
 
+        this.material = this.materialFactory.getPhongNodeMaterial();
         this.mesh = new THREE.Mesh(
-            new THREE.SphereGeometry(1, NODE_SEGMENTS, NODE_SEGMENTS),
+            this.geometryFactory.getNodeGeometry(this.currentSettings.xr.quality),
             this.material
         );
 
         this.setupSettingsSubscriptions();
     }
 
-    public handleSettingChange(setting: keyof NodeSettings, value: any): void {
+    public handleSettingChange(setting: keyof Settings['visualization']['nodes'], value: any): void {
         try {
             switch (setting) {
                 case 'baseColor':
-                    this.material.color.set(value as string);
-                    break;
                 case 'opacity':
-                    this.material.opacity = value as number;
+                    this.materialFactory.updateMaterial('node-phong', this.currentSettings);
                     break;
                 case 'baseSize':
                     this.mesh.scale.set(value, value, value);
@@ -58,27 +54,30 @@ export class NodeRenderer {
                     // Other settings handled elsewhere
                     break;
             }
-            (this.material as any).needsUpdate = true;
         } catch (error) {
             logger.error(`Error applying node setting change for ${String(setting)}:`, error);
         }
     }
 
-    public handlePhysicsSettingChange(setting: keyof PhysicsSettings, value: any): void {
+    public handlePhysicsSettingChange(setting: keyof Settings['visualization']['physics'], value: any): void {
         // Dummy implementation for now
         logger.debug(`Physics setting change: ${String(setting)} = ${value}`);
     }
 
     private setupSettingsSubscriptions(): void {
-        Object.keys(this.currentSettings.nodes).forEach(setting => {
-            settingsManager.subscribe('nodes', setting as keyof NodeSettings, (value) => {
-                this.handleSettingChange(setting as keyof NodeSettings, value);
+        this.settingsObserver.subscribe('NodeRenderer', (settings) => {
+            this.currentSettings = settings;
+            Object.keys(settings.visualization.nodes).forEach(setting => {
+                this.handleSettingChange(
+                    setting as keyof Settings['visualization']['nodes'],
+                    settings.visualization.nodes[setting as keyof Settings['visualization']['nodes']]
+                );
             });
-        });
-
-        Object.keys(this.currentSettings.physics).forEach(setting => {
-            settingsManager.subscribe('physics', setting as keyof PhysicsSettings, (value) => {
-                this.handlePhysicsSettingChange(setting as keyof PhysicsSettings, value);
+            Object.keys(settings.visualization.physics).forEach(setting => {
+                this.handlePhysicsSettingChange(
+                    setting as keyof Settings['visualization']['physics'],
+                    settings.visualization.physics[setting as keyof Settings['visualization']['physics']]
+                );
             });
         });
     }
@@ -89,78 +88,80 @@ export class NodeManager {
     private currentSettings: Settings;
     private nodeInstances: THREE.InstancedMesh;
     private edgeInstances: THREE.InstancedMesh;
-    private unsubscribers: Array<() => void> = [];
     private nodeRenderer: NodeRenderer;
     private currentNodes: Node[] = [];
     private nodeIndices: Map<string, number> = new Map();
+    private readonly materialFactory: MaterialFactory;
+    private readonly geometryFactory: GeometryFactory;
+    private readonly settingsObserver: SettingsObserver;
 
     private constructor() {
         this.currentSettings = settingsManager.getCurrentSettings();
+        this.materialFactory = MaterialFactory.getInstance();
+        this.geometryFactory = GeometryFactory.getInstance();
+        this.settingsObserver = SettingsObserver.getInstance();
         this.nodeRenderer = new NodeRenderer();
 
-        const nodeGeometry = new THREE.SphereGeometry(1, NODE_SEGMENTS, NODE_SEGMENTS);
-        const edgeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, EDGE_SEGMENTS);
-        edgeGeometry.rotateX(Math.PI / 2);
-
         this.nodeInstances = new THREE.InstancedMesh(
-            nodeGeometry,
+            this.geometryFactory.getNodeGeometry(this.currentSettings.xr.quality),
             this.nodeRenderer.material,
             10000
         );
 
         this.edgeInstances = new THREE.InstancedMesh(
-            edgeGeometry,
-            this.createEdgeMaterial(),
+            this.geometryFactory.getHologramGeometry('ring', this.currentSettings.xr.quality),
+            this.materialFactory.getMetadataMaterial(),
             30000
         );
 
         this.setupSettingsSubscriptions();
     }
 
-    private createEdgeMaterial(): THREE.Material {
-        return new THREE.MeshBasicMaterial({
-            transparent: true,
-            opacity: this.currentSettings.edges.opacity,
-            color: this.currentSettings.nodes.baseColor,
+    private setupSettingsSubscriptions(): void {
+        this.settingsObserver.subscribe('NodeManager', (settings) => {
+            this.currentSettings = settings;
+            this.materialFactory.updateMaterial('metadata', settings);
         });
     }
 
-    public updatePositions(floatArray: Float32Array): void {
-        try {
-            const version = floatArray[0];
-            if (version !== BINARY_VERSION) {
-                logger.warn(`Received binary data version ${version}, expected ${BINARY_VERSION}`);
-                return;
-            }
-
-            const nodeCount = Math.floor((floatArray.length - VERSION_OFFSET) / FLOATS_PER_NODE);
-            if (nodeCount > this.currentNodes.length) {
-                logger.warn(`Received more nodes than currently tracked: ${nodeCount} > ${this.currentNodes.length}`);
-                return;
-            }
-
-            for (let i = 0; i < nodeCount; i++) {
-                const baseIndex = VERSION_OFFSET + (i * FLOATS_PER_NODE);
-                position.set(
-                    floatArray[baseIndex],
-                    floatArray[baseIndex + 1],
-                    floatArray[baseIndex + 2]
-                );
-
-                matrix.compose(position, quaternion, scale);
-                this.nodeInstances.setMatrixAt(i, matrix);
-
-                const node = this.currentNodes[i];
-                if (node) {
-                    node.data.position.x = floatArray[baseIndex];
-                    node.data.position.y = floatArray[baseIndex + 1];
-                    node.data.position.z = floatArray[baseIndex + 2];
-                }
-            }
+    public static getInstance(): NodeManager {
+        if (!NodeManager.instance) {
+            NodeManager.instance = new NodeManager();
+        }
+        return NodeManager.instance;
+    }
 
-            this.nodeInstances.instanceMatrix.needsUpdate = true;
-        } catch (error) {
-            logger.error('Error updating positions:', error);
+    public updatePositions(positions: Float32Array): void {
+        if (!this.nodeInstances) return;
+
+        const count = Math.min(positions.length / FLOATS_PER_NODE, this.nodeInstances.count);
+        
+        for (let i = 0; i < count; i++) {
+            const baseIndex = i * FLOATS_PER_NODE;
+            
+            // Update position
+            position.set(
+                positions[baseIndex],
+                positions[baseIndex + 1],
+                positions[baseIndex + 2]
+            );
+            
+            // Set initial scale based on settings
+            const baseSize = this.currentSettings.visualization.nodes.baseSize || 1;
+            scale.set(baseSize, baseSize, baseSize);
+            
+            // Update instance matrix
+            matrix.compose(position, quaternion, scale);
+            this.nodeInstances.setMatrixAt(i, matrix);
+        }
+        
+        this.nodeInstances.instanceMatrix.needsUpdate = true;
+        
+        // Force a render update
+        if (this.currentSettings.visualization.animations.enableNodeAnimations) {
+            requestAnimationFrame(() => {
+                this.nodeInstances.instanceMatrix.needsUpdate = true;
+            });
         }
     }
 
@@ -188,57 +189,50 @@ export class NodeManager {
 
         const node = this.currentNodes[index];
         if (node) {
-            node.data.position = { x: newPosition.x, y: newPosition.y, z: newPosition.z };
+            node.data.position = {
+                x: newPosition.x,
+                y: newPosition.y,
+                z: newPosition.z
+            };
+
+            matrix.compose(newPosition, quaternion, scale);
+            this.nodeInstances.setMatrixAt(index, matrix);
+            this.nodeInstances.instanceMatrix.needsUpdate = true;
         }
-
-        matrix.compose(newPosition, quaternion, scale);
-        this.nodeInstances.setMatrixAt(index, matrix);
-        this.nodeInstances.instanceMatrix.needsUpdate = true;
     }
 
-    private setupSettingsSubscriptions(): void {
-        Object.keys(this.currentSettings.nodes).forEach(setting => {
-            const unsubscribe = settingsManager.subscribe('nodes', setting as keyof NodeSettings, (value) => {
-                this.nodeRenderer.handleSettingChange(setting as keyof NodeSettings, value);
-            });
-            this.unsubscribers.push(unsubscribe);
-        });
-
-        Object.keys(this.currentSettings.physics).forEach(setting => {
-            const unsubscribe = settingsManager.subscribe('physics', setting as keyof PhysicsSettings, (value) => {
-                this.nodeRenderer.handlePhysicsSettingChange(setting as keyof PhysicsSettings, value);
-            });
-            this.unsubscribers.push(unsubscribe);
-        });
+    public getCurrentNodes(): Node[] {
+        return [...this.currentNodes];
     }
 
-    public static getInstance(): NodeManager {
-        if (!NodeManager.instance) {
-            NodeManager.instance = new NodeManager();
-        }
-        return NodeManager.instance;
+    public updateNodes(nodes: Node[]): void {
+        this.currentNodes = nodes;
+        const positions = new Float32Array(nodes.length * FLOATS_PER_NODE);
+        
+        nodes.forEach((node, index) => {
+            const baseIndex = index * FLOATS_PER_NODE;
+            positions[baseIndex] = node.data.position.x;
+            positions[baseIndex + 1] = node.data.position.y;
+            positions[baseIndex + 2] = node.data.position.z;
+            // Velocity components (if needed)
+            positions[baseIndex + 3] = 0;
+            positions[baseIndex + 4] = 0;
+            positions[baseIndex + 5] = 0;
+            
+            this.nodeIndices.set(node.id, index);
+        });
+        
+        this.updatePositions(positions);
     }
 
     public dispose(): void {
         if (this.nodeInstances) {
-            if (this.nodeInstances.geometry) {
-                this.nodeInstances.geometry.dispose();
-            }
-            if (this.nodeInstances.material instanceof THREE.Material) {
-                this.nodeInstances.material.dispose();
-            }
-            this.nodeInstances.dispose();
+            this.nodeInstances.geometry.dispose();
+            this.nodeInstances.material.dispose();
         }
         if (this.edgeInstances) {
-            if (this.edgeInstances.geometry) {
-                this.edgeInstances.geometry.dispose();
-            }
-            if (this.edgeInstances.material instanceof THREE.Material) {
-                this.edgeInstances.material.dispose();
-            }
-            this.edgeInstances.dispose();
+            this.edgeInstances.geometry.dispose();
+            this.edgeInstances.material.dispose();
         }
-        this.unsubscribers.forEach(unsubscribe => unsubscribe());
-        this.unsubscribers = [];
     }
 }
diff --git a/client/rendering/scene.ts b/client/rendering/scene.ts
index a9db7807..4cdf6343 100644
--- a/client/rendering/scene.ts
+++ b/client/rendering/scene.ts
@@ -2,7 +2,7 @@
  * Three.js scene management with simplified setup
  */
 
-import * as THREE from 'three';
+import { Scene, PerspectiveCamera, WebGLRenderer, Color, AmbientLight, DirectionalLight, GridHelper, Vector2, Material, Mesh, Object3D } from 'three';
 import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
 import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
 import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
@@ -18,9 +18,9 @@ export class SceneManager {
   private static instance: SceneManager;
   
   // Three.js core components
-  private scene: THREE.Scene;
-  private camera: THREE.PerspectiveCamera;
-  private renderer: THREE.WebGLRenderer;
+  private scene: Scene;
+  private camera: PerspectiveCamera;
+  private renderer: WebGLRenderer;
   private controls: OrbitControls;
   
   // Post-processing
@@ -35,12 +35,12 @@ export class SceneManager {
     logger.log('Initializing SceneManager');
     
     // Create scene
-    this.scene = new THREE.Scene();
-    this.scene.background = new THREE.Color(BACKGROUND_COLOR);
+    this.scene = new Scene();
+    this.scene.background = new Color(BACKGROUND_COLOR);
     // Removed fog to ensure graph visibility
 
     // Create camera
-    this.camera = new THREE.PerspectiveCamera(
+    this.camera = new PerspectiveCamera(
       75,
       window.innerWidth / window.innerHeight,
       0.1,
@@ -50,7 +50,7 @@ export class SceneManager {
     this.camera.lookAt(0, 0, 0);
 
     // Create renderer
-    this.renderer = new THREE.WebGLRenderer({
+    this.renderer = new WebGLRenderer({
       canvas,
       antialias: true,
       alpha: true,
@@ -73,7 +73,7 @@ export class SceneManager {
     this.composer.addPass(renderPass);
 
     this.bloomPass = new UnrealBloomPass(
-      new THREE.Vector2(window.innerWidth, window.innerHeight),
+      new Vector2(window.innerWidth, window.innerHeight),
       1.5,  // Strength
       0.75, // Radius
       0.3   // Threshold
@@ -96,17 +96,24 @@ export class SceneManager {
     return SceneManager.instance;
   }
 
+  static cleanup(): void {
+    if (SceneManager.instance) {
+      SceneManager.instance.dispose();
+      SceneManager.instance = null as any;
+    }
+  }
+
   private setupLighting(): void {
-    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
+    const ambientLight = new AmbientLight(0xffffff, 0.6);
     this.scene.add(ambientLight);
 
-    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
+    const directionalLight = new DirectionalLight(0xffffff, 0.8);
     directionalLight.position.set(1, 1, 1).normalize();
     this.scene.add(directionalLight);
 
     // Add smaller grid helper
-    const gridHelper = new THREE.GridHelper(50, 50); // Reduced grid size
-    if (gridHelper.material instanceof THREE.Material) {
+    const gridHelper = new GridHelper(50, 50); // Reduced grid size
+    if (gridHelper.material instanceof Material) {
       gridHelper.material.transparent = true;
       gridHelper.material.opacity = 0.1;
     }
@@ -149,15 +156,15 @@ export class SceneManager {
   }
 
   // Public getters
-  getScene(): THREE.Scene {
+  getScene(): Scene {
     return this.scene;
   }
 
-  getCamera(): THREE.PerspectiveCamera {
+  getCamera(): PerspectiveCamera {
     return this.camera;
   }
 
-  getRenderer(): THREE.WebGLRenderer {
+  getRenderer(): WebGLRenderer {
     return this.renderer;
   }
 
@@ -166,28 +173,80 @@ export class SceneManager {
   }
 
   // Scene management methods
-  add(object: THREE.Object3D): void {
+  add(object: Object3D): void {
     this.scene.add(object);
   }
 
-  remove(object: THREE.Object3D): void {
+  remove(object: Object3D): void {
     this.scene.remove(object);
   }
 
   dispose(): void {
     this.stop();
     
-    window.removeEventListener('resize', this.handleResize.bind(this));
-
-    this.renderer.dispose();
-    this.scene.traverse((object) => {
-      if (object instanceof THREE.Mesh) {
-        object.geometry.dispose();
-        if (object.material instanceof THREE.Material) {
-          object.material.dispose();
-        }
+    // Remove event listeners
+    const boundResize = this.handleResize.bind(this);
+    window.removeEventListener('resize', boundResize);
+
+    // Dispose of post-processing
+    if (this.composer) {
+      // Dispose of render targets
+      this.composer.renderTarget1.dispose();
+      this.composer.renderTarget2.dispose();
+      
+      // Clear passes
+      this.composer.passes.length = 0;
+    }
+
+    // Dispose of bloom pass resources
+    if (this.bloomPass) {
+      // Dispose of any textures or materials used by the bloom pass
+      if ((this.bloomPass as any).renderTargetsHorizontal) {
+        (this.bloomPass as any).renderTargetsHorizontal.forEach((target: any) => {
+          if (target && target.dispose) target.dispose();
+        });
       }
-    });
+      if ((this.bloomPass as any).renderTargetsVertical) {
+        (this.bloomPass as any).renderTargetsVertical.forEach((target: any) => {
+          if (target && target.dispose) target.dispose();
+        });
+      }
+      if ((this.bloomPass as any).materialHorizontal) {
+        (this.bloomPass as any).materialHorizontal.dispose();
+      }
+      if ((this.bloomPass as any).materialVertical) {
+        (this.bloomPass as any).materialVertical.dispose();
+      }
+    }
+
+    // Dispose of controls
+    if (this.controls) {
+      this.controls.dispose();
+    }
+
+    // Dispose of renderer and materials
+    if (this.renderer) {
+      this.renderer.dispose();
+      this.renderer.domElement.remove();
+      (this.renderer.domElement as any).width = 0;
+      (this.renderer.domElement as any).height = 0;
+    }
+
+    // Dispose of scene objects
+    if (this.scene) {
+      this.scene.traverse((object) => {
+        if (object instanceof Mesh) {
+          if (object.geometry) object.geometry.dispose();
+          if (object.material) {
+            if (Array.isArray(object.material)) {
+              object.material.forEach(material => material.dispose());
+            } else {
+              object.material.dispose();
+            }
+          }
+        }
+      });
+    }
 
     logger.log('Scene manager disposed');
   }
diff --git a/client/rendering/textRenderer.ts b/client/rendering/textRenderer.ts
index db7df964..0afbcc79 100644
--- a/client/rendering/textRenderer.ts
+++ b/client/rendering/textRenderer.ts
@@ -1,6 +1,6 @@
-import type { LabelSettings } from '../core/types';
+import type { Settings, LabelSettings } from '../types/settings';
 import { settingsManager } from '../state/settings';
-import { createLogger } from '../utils/logger';
+import { createLogger } from '../core/logger';
 import * as THREE from 'three';
 
 const logger = createLogger('TextRenderer');
@@ -19,7 +19,7 @@ export class TextRenderer {
     private unsubscribers: Array<() => void> = [];
     private projMatrix: THREE.Matrix4;
     private viewMatrix: THREE.Matrix4;
-    private currentSettings: LabelSettings;
+    private currentSettings: Settings;
 
     constructor(camera: THREE.Camera) {
         this.camera = camera;
@@ -27,13 +27,14 @@ export class TextRenderer {
         this.labelStates = new Map();
         this.projMatrix = new THREE.Matrix4();
         this.viewMatrix = new THREE.Matrix4();
-        this.currentSettings = settingsManager.getCurrentSettings().labels;
+        this.currentSettings = settingsManager.getCurrentSettings();
         this.setupSettingsSubscriptions();
     }
 
     private setupSettingsSubscriptions(): void {
-        Object.keys(this.currentSettings).forEach(setting => {
-            const unsubscribe = settingsManager.subscribe('labels', setting as keyof LabelSettings, (value) => {
+        Object.keys(this.currentSettings.visualization.labels).forEach(setting => {
+            const path = `visualization.labels.${setting}`;
+            const unsubscribe = settingsManager.subscribe(path, (value) => {
                 this.handleSettingChange(setting as keyof LabelSettings, value);
             });
             this.unsubscribers.push(unsubscribe);
@@ -183,7 +184,7 @@ export class TextRenderer {
             // (e.g., using HTML elements, sprites, or geometry)
 
             // Update visibility
-            labelGroup.visible = this.currentSettings.enableLabels && state.visible;
+            labelGroup.visible = this.currentSettings.visualization.labels.enableLabels && state.visible;
 
             // Update bounding box for culling
             state.boundingBox = labelGroup;
diff --git a/client/state/SettingsObserver.ts b/client/state/SettingsObserver.ts
new file mode 100644
index 00000000..bd18ab55
--- /dev/null
+++ b/client/state/SettingsObserver.ts
@@ -0,0 +1,42 @@
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+
+const logger = createLogger('SettingsObserver');
+
+export type SettingsChangeCallback = (settings: Settings) => void;
+
+export class SettingsObserver {
+    private static instance: SettingsObserver;
+    private observers = new Map<string, SettingsChangeCallback>();
+
+    private constructor() {}
+
+    static getInstance(): SettingsObserver {
+        if (!SettingsObserver.instance) {
+            SettingsObserver.instance = new SettingsObserver();
+        }
+        return SettingsObserver.instance;
+    }
+
+    subscribe(id: string, callback: SettingsChangeCallback): () => void {
+        logger.debug(`Subscribing observer: ${id}`);
+        this.observers.set(id, callback);
+        return () => this.unsubscribe(id);
+    }
+
+    unsubscribe(id: string): void {
+        logger.debug(`Unsubscribing observer: ${id}`);
+        this.observers.delete(id);
+    }
+
+    notifyAll(settings: Settings): void {
+        logger.debug(`Notifying ${this.observers.size} observers of settings change`);
+        this.observers.forEach((callback, id) => {
+            try {
+                callback(settings);
+            } catch (error) {
+                logger.error(`Error in settings observer ${id}:`, error);
+            }
+        });
+    }
+}
diff --git a/client/state/SettingsStore.ts b/client/state/SettingsStore.ts
new file mode 100644
index 00000000..f45b9393
--- /dev/null
+++ b/client/state/SettingsStore.ts
@@ -0,0 +1,252 @@
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+import { defaultSettings } from './defaultSettings';
+
+const logger = createLogger('SettingsStore');
+
+export interface SettingsStoreOptions {
+    autoSave?: boolean;
+    syncInterval?: number;
+}
+
+const defaultSettingsStoreOptions: Required<SettingsStoreOptions> = {
+    autoSave: true,
+    syncInterval: 5000
+};
+
+export type SettingsChangeCallback = (path: string, value: unknown) => void;
+
+export class SettingsStore {
+    private static instance: SettingsStore | null = null;
+    private settings: Settings;
+    private initialized: boolean = false;
+    private pendingChanges: Set<string> = new Set();
+    private subscribers: Map<string, Set<SettingsChangeCallback>> = new Map();
+    private syncTimer: number | null = null;
+
+    private constructor(
+        private readonly options: SettingsStoreOptions = defaultSettingsStoreOptions
+    ) {
+        // Initialize with default settings
+        this.settings = { ...defaultSettings };
+    }
+
+    public static getInstance(options?: SettingsStoreOptions): SettingsStore {
+        if (!SettingsStore.instance) {
+            SettingsStore.instance = new SettingsStore(options);
+        }
+        return SettingsStore.instance;
+    }
+
+    public async initialize(): Promise<void> {
+        if (this.initialized) {
+            return;
+        }
+
+        try {
+            // Try to fetch settings from API
+            try {
+                const response = await fetch('/api/settings');
+                if (response.ok) {
+                    const flatSettings = await response.json();
+                    this.settings = this.unflattenSettings(flatSettings);
+                    logger.info('Settings loaded from API');
+                } else {
+                    // If API fails, use default settings
+                    logger.warn('Failed to fetch settings from API, using defaults');
+                    this.settings = defaultSettings;
+                }
+            } catch (error) {
+                // If fetch fails completely, use default settings
+                logger.warn('API not available, using default settings:', error);
+                this.settings = defaultSettings;
+            }
+
+            this.initialized = true;
+            logger.info('SettingsStore initialized');
+
+            if (this.options.autoSave) {
+                this.syncTimer = window.setInterval(
+                    () => this.syncPendingChanges(),
+                    this.options.syncInterval
+                ) as unknown as number;
+            }
+        } catch (error) {
+            logger.error('Failed to initialize SettingsStore:', error);
+            // Even if something goes wrong, initialize with defaults
+            this.settings = defaultSettings;
+            this.initialized = true;
+        }
+    }
+
+    private async syncPendingChanges(): Promise<void> {
+        if (!this.initialized || this.pendingChanges.size === 0) {
+            return;
+        }
+
+        const updates = Array.from(this.pendingChanges).map(async (path) => {
+            const value = this.get(path);
+            const url = `/api/settings/${path}`;
+
+            try {
+                const response = await fetch(url, {
+                    method: 'PUT',
+                    headers: { 'Content-Type': 'application/json' },
+                    body: JSON.stringify(value)
+                });
+
+                if (!response.ok) {
+                    throw new Error(`Failed to update setting ${path}: ${response.statusText}`);
+                }
+
+                return path;
+            } catch (error) {
+                logger.error(`Failed to sync setting ${path}:`, error);
+                throw error;
+            }
+        });
+
+        try {
+            await Promise.all(updates);
+            this.pendingChanges.clear();
+            logger.info('Settings synced successfully');
+        } catch (error) {
+            logger.error('Failed to sync some settings:', error);
+            throw error;
+        }
+    }
+
+    public get(path: string): unknown {
+        if (!this.initialized) {
+            logger.warn('Attempting to access settings before initialization');
+            return undefined;
+        }
+        
+        if (!path) {
+            return this.settings;
+        }
+        
+        try {
+            return path.split('.').reduce((obj: any, key) => {
+                if (obj === null || obj === undefined) {
+                    throw new Error(`Invalid path: ${path}`);
+                }
+                return obj[key];
+            }, this.settings);
+        } catch (error) {
+            logger.error(`Error accessing setting at path ${path}:`, error);
+            return undefined;
+        }
+    }
+
+    public set(path: string, value: unknown): void {
+        if (!this.initialized) {
+            logger.error('Attempting to set settings before initialization');
+            throw new Error('SettingsStore not initialized');
+        }
+
+        try {
+            const parts = path.split('.');
+            const lastKey = parts.pop()!;
+            const target = parts.reduce((obj: any, key) => {
+                if (!(key in obj)) {
+                    obj[key] = {};
+                }
+                return obj[key];
+            }, this.settings);
+
+            if (!target || typeof target !== 'object') {
+                throw new Error(`Invalid settings path: ${path}`);
+            }
+
+            target[lastKey] = value;
+            this.pendingChanges.add(path);
+            this.notifySubscribers(path, value);
+        } catch (error) {
+            logger.error(`Error setting value at path ${path}:`, error);
+            throw error;
+        }
+    }
+
+    private unflattenSettings(flatSettings: Record<string, unknown>): Settings {
+        const result: any = {};
+        
+        for (const [path, value] of Object.entries(flatSettings)) {
+            const parts = path.split('.');
+            let current = result;
+            
+            for (let i = 0; i < parts.length - 1; i++) {
+                const part = parts[i];
+                if (!(part in current)) {
+                    current[part] = {};
+                }
+                current = current[part];
+            }
+            
+            current[parts[parts.length - 1]] = value;
+        }
+        
+        return result as Settings;
+    }
+
+    public subscribe(path: string, callback: SettingsChangeCallback): () => void {
+        if (!this.initialized) {
+            logger.warn('Attempting to subscribe before initialization');
+            throw new Error('SettingsStore not initialized');
+        }
+
+        try {
+            if (!this.subscribers.has(path)) {
+                this.subscribers.set(path, new Set());
+            }
+            const pathSubscribers = this.subscribers.get(path)!;
+            pathSubscribers.add(callback);
+
+            // Immediately notify subscriber with current value
+            const currentValue = this.get(path);
+            if (currentValue !== undefined) {
+                try {
+                    callback(path, currentValue);
+                } catch (error) {
+                    logger.error(`Error in initial callback for ${path}:`, error);
+                }
+            }
+
+            return () => {
+                const pathSubscribers = this.subscribers.get(path);
+                if (pathSubscribers) {
+                    pathSubscribers.delete(callback);
+                    if (pathSubscribers.size === 0) {
+                        this.subscribers.delete(path);
+                    }
+                }
+            };
+        } catch (error) {
+            logger.error(`Error setting up subscription for ${path}:`, error);
+            throw error;
+        }
+    }
+
+    private notifySubscribers(path: string, value: unknown): void {
+        const subscribers = this.subscribers.get(path);
+        if (subscribers) {
+            subscribers.forEach(callback => {
+                try {
+                    callback(path, value);
+                } catch (error) {
+                    logger.error(`Error in settings subscriber for ${path}:`, error);
+                }
+            });
+        }
+    }
+
+    public dispose(): void {
+        if (this.syncTimer !== null) {
+            window.clearInterval(this.syncTimer);
+            this.syncTimer = null;
+        }
+        this.subscribers.clear();
+        this.pendingChanges.clear();
+        this.initialized = false;
+    }
+}
diff --git a/client/state/defaultSettings.ts b/client/state/defaultSettings.ts
index 28254b77..a59d4e3b 100644
--- a/client/state/defaultSettings.ts
+++ b/client/state/defaultSettings.ts
@@ -1,171 +1,185 @@
-import type { Settings } from '../types/settings';
+import { Settings, VisualizationSettings } from '../types/settings';
+import { NODE_COLOR, NODE_SIZE, EDGE_RADIUS, LABEL_COLOR } from '../core/constants';
 
-export const defaultSettings: Settings = {
+// Export visualization defaults separately for reuse
+export const defaultVisualizationSettings: VisualizationSettings = {
     animations: {
         enableMotionBlur: false,
-        enableNodeAnimations: false,
-        motionBlurStrength: 0.4,
+        enableNodeAnimations: true,
+        motionBlurStrength: 0.5,
         selectionWaveEnabled: false,
         pulseEnabled: false,
         rippleEnabled: false,
         edgeAnimationEnabled: false,
         flowParticlesEnabled: false
     },
-    ar: {
-        dragThreshold: 0.04,
-        enableHandTracking: true,
-        enableHaptics: true,
-        enableLightEstimation: true,
-        enablePassthroughPortal: false,
-        enablePlaneDetection: true,
-        enableSceneUnderstanding: true,
-        gestureSsmoothing: 0.5,
-        handMeshColor: "#FFD700",
-        handMeshEnabled: true,
-        handMeshOpacity: 0.3,
-        handPointSize: 0.01,
-        handRayColor: "#FFD700",
-        handRayEnabled: true,
-        handRayWidth: 0.002,
-        hapticIntensity: 0.7,
-        passthroughBrightness: 1.0,
-        passthroughContrast: 1.0,
-        passthroughOpacity: 0.8,
-        pinchThreshold: 0.015,
-        planeColor: "#808080",
-        planeOpacity: 0.5,
-        portalEdgeColor: "#00FF00",
-        portalEdgeWidth: 0.02,
-        portalSize: 2.0,
-        roomScale: true,
-        rotationThreshold: 0.08,
-        showPlaneOverlay: true,
-        snapToFloor: true
-    },
-    audio: {
-        enableSpatialAudio: false,
-        enableInteractionSounds: false,
-        enableAmbientSounds: false
-    },
     bloom: {
-        edgeBloomStrength: 0.3,
-        enabled: false,
-        environmentBloomStrength: 0.5,
-        nodeBloomStrength: 0.2,
-        radius: 0.5,
-        strength: 1.8
-    },
-    clientDebug: {
-        enableDataDebug: false,
-        enableWebsocketDebug: false,
-        enabled: false,
-        logBinaryHeaders: false,
-        logFullJson: false
+        enabled: true,
+        strength: 0.5,
+        radius: 1,
+        edgeBloomStrength: 0.5,
+        nodeBloomStrength: 0.5,
+        environmentBloomStrength: 0.5
     },
     edges: {
-        arrowSize: 0.2,
-        baseWidth: 2,
-        color: "#917f18",
-        enableArrows: false,
-        opacity: 0.6,
-        widthRange: [1, 3]
+        arrowSize: 3,
+        baseWidth: EDGE_RADIUS * 2,
+        color: '#ffffff',
+        enableArrows: true,
+        opacity: 0.8,
+        widthRange: [1, 5]
+    },
+    hologram: {
+        ringCount: 3,
+        ringColor: '#00FFFF',
+        ringOpacity: 0.5,
+        ringSizes: [1.0, 1.5, 2.0],
+        ringRotationSpeed: 0.1,
+        enableBuckminster: true,
+        buckminsterScale: 1.0,
+        buckminsterOpacity: 0.3,
+        enableGeodesic: true,
+        geodesicScale: 1.2,
+        geodesicOpacity: 0.4,
+        enableTriangleSphere: true,
+        triangleSphereScale: 1.1,
+        triangleSphereOpacity: 0.35,
+        globalRotationSpeed: 0.05
     },
     labels: {
-        desktopFontSize: 48,
         enableLabels: true,
-        textColor: "#FFFFFF"
-    },
-    network: {
-        bindAddress: "0.0.0.0",
-        domain: "localhost",
-        enableHttp2: false,
-        enableRateLimiting: true,
-        enableTls: false,
-        maxRequestSize: 10485760,
-        minTlsVersion: "",
-        port: 3001,
-        rateLimitRequests: 100,
-        rateLimitWindow: 60,
-        tunnelId: "dummy"
-    },
-    default: {
-        apiClientTimeout: 30,
-        enableMetrics: true,
-        enableRequestLogging: true,
-        logFormat: "json",
-        logLevel: "debug",
-        maxConcurrentRequests: 5,
-        maxPayloadSize: 5242880,
-        maxRetries: 3,
-        metricsPort: 9090,
-        retryDelay: 5
-    },
-    security: {
-        allowedOrigins: [],
-        auditLogPath: "/app/logs/audit.log",
-        cookieHttponly: true,
-        cookieSamesite: "Strict",
-        cookieSecure: true,
-        csrfTokenTimeout: 3600,
-        enableAuditLogging: true,
-        enableRequestValidation: true,
-        sessionTimeout: 3600
-    },
-    serverDebug: {
-        enableDataDebug: false,
-        enableWebsocketDebug: false,
-        enabled: true,
-        logBinaryHeaders: false,
-        logFullJson: false
+        textColor: LABEL_COLOR.toString(16),
+        textOutlineColor: '#000000',
+        textOutlineWidth: 0.1,
+        textResolution: 512,
+        textPadding: 16,
+        desktopFontSize: 48,
+        billboardMode: 'camera'
     },
     nodes: {
-        baseColor: "#c3ab6f",
-        baseSize: 1,
-        clearcoat: 0.5,
-        enableHoverEffect: false,
-        enableInstancing: false,
-        highlightColor: "#822626",
-        highlightDuration: 300,
-        hoverScale: 1.2,
-        materialType: "basic",
-        metalness: 0.3,
-        opacity: 0.4,
-        roughness: 0.35,
-        sizeByConnections: true,
-        sizeRange: [1, 10]
+        baseColor: NODE_COLOR.toString(16),
+        baseSize: NODE_SIZE,
+        sizeRange: [0.5, 2.0],
+        enableMetadataShape: true,
+        colorRangeAge: ['#ff0000', '#00ff00'],
+        colorRangeLinks: ['#0000ff', '#ff00ff'],
+        metalness: 0.5,
+        roughness: 0.2,
+        opacity: 0.8
     },
     physics: {
-        attractionStrength: 0.015,
-        boundsSize: 12,
-        collisionRadius: 0.25,
-        damping: 0.88,
+        enabled: true,
+        attractionStrength: 0.1,
+        repulsionStrength: 0.1,
+        springStrength: 0.1,
+        damping: 0.5,
+        iterations: 1,
+        maxVelocity: 10,
+        collisionRadius: 1,
         enableBounds: true,
-        enabled: false,
-        iterations: 500,
-        maxVelocity: 2.5,
-        repulsionStrength: 1500,
-        springStrength: 0.018
+        boundsSize: 100
     },
     rendering: {
-        ambientLightIntensity: 0.7,
-        backgroundColor: "#000000",
-        directionalLightIntensity: 1,
-        enableAmbientOcclusion: false,
+        ambientLightIntensity: 0.5,
+        directionalLightIntensity: 0.8,
+        environmentIntensity: 1,
+        backgroundColor: '#000000',
+        enableAmbientOcclusion: true,
         enableAntialiasing: true,
-        enableShadows: false,
-        environmentIntensity: 1.2
+        enableShadows: true
+    }
+};
+
+// Main settings object with all defaults
+export const defaultSettings: Settings = {
+    visualization: defaultVisualizationSettings,
+    xr: {
+        mode: 'immersive-ar',
+        roomScale: true,
+        spaceType: 'local-floor',
+        quality: 'medium',
+        input: {
+            enableHandTracking: true,
+            enableHaptics: true,
+            hapticIntensity: 0.5,
+            dragThreshold: 0.02,
+            pinchThreshold: 0.7,
+            rotationThreshold: 0.1,
+            interactionRadius: 0.5
+        },
+        visuals: {
+            handMeshEnabled: true,
+            handMeshColor: '#ffffff',
+            handMeshOpacity: 0.5,
+            handPointSize: 5,
+            handRayEnabled: true,
+            handRayColor: '#00ff00',
+            handRayWidth: 2,
+            gestureSsmoothing: 0.5
+        },
+        environment: {
+            enableLightEstimation: true,
+            enablePlaneDetection: true,
+            enableSceneUnderstanding: true,
+            planeColor: '#808080',
+            planeOpacity: 0.5,
+            showPlaneOverlay: true,
+            snapToFloor: true
+        },
+        passthrough: {
+            enabled: false,
+            opacity: 1,
+            brightness: 1,
+            contrast: 1,
+            portalSize: 2,
+            portalEdgeColor: '#ffffff',
+            portalEdgeWidth: 2
+        }
     },
-    websocket: {
-        binaryChunkSize: 65536,
-        compressionEnabled: true,
-        compressionThreshold: 1024,
-        heartbeatInterval: 15000,
-        heartbeatTimeout: 60000,
-        maxConnections: 1000,
-        maxMessageSize: 100485760,
-        reconnectAttempts: 3,
-        reconnectDelay: 5000,
-        updateRate: 90,
-        url: '/wss'  // Default WebSocket endpoint
+    system: {
+        network: {
+            bindAddress: '127.0.0.1',
+            domain: 'localhost',
+            port: 3000,
+            enableHttp2: true,
+            enableTls: false,
+            minTlsVersion: 'TLS1.2',
+            maxRequestSize: 10485760,
+            enableRateLimiting: true,
+            rateLimitRequests: 100,
+            rateLimitWindow: 60,
+            tunnelId: ''
+        },
+        websocket: {
+            url: 'ws://localhost:3000/ws',
+            heartbeatInterval: 15000,
+            heartbeatTimeout: 60000,
+            reconnectAttempts: 3,
+            reconnectDelay: 5000,
+            binaryChunkSize: 65536,
+            compressionEnabled: true,
+            compressionThreshold: 1024,
+            maxConnections: 1000,
+            maxMessageSize: 100485760,
+            updateRate: 30
+        },
+        security: {
+            allowedOrigins: ['http://localhost:3000'],
+            auditLogPath: './audit.log',
+            cookieHttponly: true,
+            cookieSamesite: 'Lax',
+            cookieSecure: false,
+            csrfTokenTimeout: 3600,
+            enableAuditLogging: true,
+            enableRequestValidation: true,
+            sessionTimeout: 86400
+        },
+        debug: {
+            enabled: false,
+            enableDataDebug: false,
+            enableWebsocketDebug: false,
+            logBinaryHeaders: false,
+            logFullJson: false
+        }
     }
 };
diff --git a/client/state/graphData.ts b/client/state/graphData.ts
index 7b1762e6..3a97c0a1 100644
--- a/client/state/graphData.ts
+++ b/client/state/graphData.ts
@@ -4,11 +4,12 @@
 
 import { GraphData, Node, Edge } from '../core/types';
 import { createLogger } from '../core/utils';
+import { buildApiUrl } from '../core/api';
 
 const logger = createLogger('GraphDataManager');
 
 // Constants
-const THROTTLE_INTERVAL = 16;  // ~60fps max
+const THROTTLE_INTERVAL = 16;  // ~60fps
 const BINARY_VERSION = 1.0;
 const NODE_POSITION_SIZE = 24;  // 6 floats * 4 bytes
 const BINARY_HEADER_SIZE = 4;   // 1 float * 4 bytes
@@ -54,7 +55,7 @@ export class GraphDataManager {
 
       // First, update the graph data from the backend
       try {
-        const updateResponse = await fetch('/api/graph/update', {
+        const updateResponse = await fetch(buildApiUrl('graph/update'), {
           method: 'POST',
         });
 
@@ -71,9 +72,6 @@ export class GraphDataManager {
       // Then load the first page
       await this.loadNextPage();
       
-      // Start binary updates only after initial data is loaded
-      this.setupBinaryUpdates();
-
       // Notify listeners of initial data
       this.notifyUpdateListeners();
 
@@ -93,7 +91,7 @@ export class GraphDataManager {
 
     try {
       this.loadingNodes = true;
-      const response = await fetch(`/api/graph/data/paginated?page=${this.currentPage}&pageSize=${this.pageSize}`);
+      const response = await fetch(buildApiUrl(`graph/data/paginated?page=${this.currentPage}&pageSize=${this.pageSize}`));
       
       if (!response.ok) {
         throw new Error(`Failed to fetch graph data: ${response.status} ${response.statusText}`);
@@ -103,8 +101,8 @@ export class GraphDataManager {
       logger.debug('Received graph data:', {
         nodesCount: data.nodes?.length || 0,
         edgesCount: data.edges?.length || 0,
-        totalPages: data.total_pages,
-        currentPage: this.currentPage,
+        totalPages: data.totalPages,
+        currentPage: data.currentPage,
         metadata: data.metadata
       });
       
@@ -122,8 +120,8 @@ export class GraphDataManager {
       }
 
       // Update pagination state
-      this.currentPage++;
-      this.hasMorePages = this.currentPage < data.totalPages;
+      this.currentPage = data.currentPage;
+      this.hasMorePages = data.currentPage < data.totalPages;
 
       // Notify listeners of updated data
       this.notifyUpdateListeners();
@@ -137,89 +135,81 @@ export class GraphDataManager {
     }
   }
 
-  private setupBinaryUpdates(): void {
-    // Only start binary updates after initial data is loaded
-    if (this.nodes.size > 0) {
-      this.binaryUpdatesEnabled = true;
-      logger.log('Binary updates enabled');
-    }
-  }
-
-  public async loadMoreIfNeeded(): Promise<void> {
-    if (this.hasMorePages && !this.loadingNodes) {
-      await this.loadNextPage();
-    }
-  }
-
   /**
    * Initialize or update the graph data
    */
   updateGraphData(data: any): void {
-    logger.log('Received graph data update');
-
-    // Clear existing data
-    this.nodes.clear();
-    this.edges.clear();
-
-    // Store nodes in Map for O(1) access
+    // Update nodes
     if (data.nodes && Array.isArray(data.nodes)) {
-      data.nodes.forEach((node: any) => {
-        // Convert position array to object if needed
-        let position;
-        if (Array.isArray(node.position)) {
-          position = {
-            x: node.position[0] || 0,
-            y: node.position[1] || 0,
-            z: node.position[2] || 0
-          };
-        } else {
-          position = node.position || { x: 0, y: 0, z: 0 };
+      data.nodes.forEach((node: Node) => {
+        // Preserve existing position if available, otherwise use server position or generate random
+        const existingNode = this.nodes.get(node.id);
+        if (!existingNode) {
+          // If server didn't provide position, generate random position
+          if (!node.data?.position) {
+            node.data = node.data || {};
+            node.data.position = {
+              x: (Math.random() - 0.5) * 100,  // Increased spread
+              y: (Math.random() - 0.5) * 100,
+              z: (Math.random() - 0.5) * 100
+            };
+          }
+          // Initialize velocity if not present
+          if (!node.data.velocity) {
+            node.data.velocity = { x: 0, y: 0, z: 0 };
+          }
         }
-
-        logger.log(`Processing node ${node.id} with position:`, position);
-
-        this.nodes.set(node.id, {
-          ...node,
-          position,
-          label: node.label || node.id
-        });
+        this.nodes.set(node.id, node);
       });
+    }
 
-      // Store edges in Map
-      if (Array.isArray(data.edges)) {
-        data.edges.forEach((edge: Edge) => {
-          const edgeId = this.createEdgeId(edge.source, edge.target);
-          this.edges.set(edgeId, edge);
-        });
-      }
-
-      // Update metadata
-      this.metadata = data.metadata || {};
+    // Update edges
+    if (data.edges && Array.isArray(data.edges)) {
+      data.edges.forEach((edge: Edge) => {
+        const edgeId = this.createEdgeId(edge.source, edge.target);
+        this.edges.set(edgeId, edge);
+      });
+    }
 
-      // Notify listeners
-      this.notifyUpdateListeners();
-      logger.log(`Updated graph data: ${this.nodes.size} nodes, ${this.edges.size} edges`);
+    // Update metadata
+    if (data.metadata) {
+      this.metadata = { ...this.metadata, ...data.metadata };
+    }
 
-      // Enable binary updates after initial data is received
-      if (!this.binaryUpdatesEnabled) {
-        this.enableBinaryUpdates();
-      }
-    } else {
-      logger.warn('Invalid graph data format received');
+    // Enable binary updates if we have nodes and it's not already enabled
+    if (this.nodes.size > 0 && !this.binaryUpdatesEnabled) {
+      this.setupBinaryUpdates();
     }
+
+    // Notify listeners of updates
+    this.notifyUpdateListeners();
   }
 
   /**
-   * Enable binary position updates
+   * Setup binary position updates
    */
-  private enableBinaryUpdates(): void {
-    // Send message to server to enable binary updates
-    if (window.ws && window.ws.readyState === WebSocket.OPEN) {
-      window.ws.send(JSON.stringify({ type: 'enableBinaryUpdates' }));
-      this.binaryUpdatesEnabled = true;
-      logger.log('Enabled binary updates');
-    } else {
-      logger.warn('WebSocket not ready, cannot enable binary updates');
+  private setupBinaryUpdates(): void {
+    this.binaryUpdatesEnabled = true;
+    // Initialize positions for existing nodes if needed
+    this.nodes.forEach(node => {
+      if (!node.data?.position) {
+        node.data = node.data || {};
+        node.data.position = {
+          x: (Math.random() - 0.5) * 100,
+          y: (Math.random() - 0.5) * 100,
+          z: (Math.random() - 0.5) * 100
+        };
+      }
+      if (!node.data.velocity) {
+        node.data.velocity = { x: 0, y: 0, z: 0 };
+      }
+    });
+    logger.log('Binary updates enabled');
+  }
+
+  public async loadMoreIfNeeded(): Promise<void> {
+    if (this.hasMorePages && !this.loadingNodes) {
+      await this.loadNextPage();
     }
   }
 
@@ -331,6 +321,20 @@ export class GraphDataManager {
       }
     });
   }
+
+  public setBinaryUpdatesEnabled(enabled: boolean): void {
+    this.binaryUpdatesEnabled = enabled;
+    logger.info(`Binary updates ${enabled ? 'enabled' : 'disabled'}`);
+    
+    // Notify listeners of state change
+    this.updateListeners.forEach(listener => {
+      listener({
+        nodes: Array.from(this.nodes.values()),
+        edges: Array.from(this.edges.values()),
+        metadata: { ...this.metadata, binaryUpdatesEnabled: enabled }
+      });
+    });
+  }
 }
 
 // Export a singleton instance
diff --git a/client/state/settings.ts b/client/state/settings.ts
index b82780f6..64730c45 100644
--- a/client/state/settings.ts
+++ b/client/state/settings.ts
@@ -1,19 +1,25 @@
-import { Settings, SettingsManager as ISettingsManager, SettingCategory, SettingKey, SettingValueType } from '../types/settings';
-import { createLogger } from '../utils/logger';
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+import { SettingsStore } from './SettingsStore';
+import { defaultSettings } from './defaultSettings';
+import {
+    SettingsCategory,
+    SettingsPath,
+    SettingValue,
+    getSettingValue,
+    setSettingValue,
+    isValidSettingPath
+} from '../types/settings/utils';
 
 const logger = createLogger('SettingsManager');
 
-type Subscriber<T extends SettingCategory, K extends SettingKey<T>> = {
-    callback: (value: SettingValueType<T, K>) => void;
-};
-
-class SettingsManager implements ISettingsManager {
-    private settings: Settings;
-    private subscribers: Map<string, Array<Subscriber<any, any>>> = new Map();
+export class SettingsManager {
+    private store: SettingsStore;
     private initialized: boolean = false;
+    private settings: Settings = { ...defaultSettings };
 
-    constructor(defaultSettings: Settings) {
-        this.settings = { ...defaultSettings };
+    constructor() {
+        this.store = SettingsStore.getInstance({ autoSave: true });
     }
 
     public async initialize(): Promise<void> {
@@ -21,323 +27,134 @@ class SettingsManager implements ISettingsManager {
             return;
         }
 
-        const maxRetries = 3;
-        const retryDelay = 1000; // 1 second
-
         try {
-            const categories = Object.keys(this.settings) as SettingCategory[];
-            
-            for (const category of categories) {
-                let retries = 0;
-                while (retries < maxRetries) {
-                    try {
-                        const response = await fetch(`/api/visualization/settings/${category}`);
-                        
-                        if (response.ok) {
-                            const data = await response.json();
-                            if (this.settings[category]) {
-                                this.settings[category] = { ...this.settings[category], ...data };
-                                logger.info(`Loaded settings for category ${category}`);
-                                break; // Success, exit retry loop
-                            }
-                        } else if (response.status === 404) {
-                            logger.info(`Settings endpoint for ${category} not found, using defaults`);
-                            break; // 404 is expected for some categories, exit retry loop
-                        } else {
-                            throw new Error(`Failed to fetch ${category} settings: ${response.statusText}`);
-                        }
-                    } catch (error) {
-                        retries++;
-                        if (retries === maxRetries) {
-                            logger.error(`Failed to load ${category} settings after ${maxRetries} attempts:`, error);
-                            logger.info(`Using default values for ${category} settings`);
-                        } else {
-                            logger.warn(`Retry ${retries}/${maxRetries} for ${category} settings`);
-                            await new Promise(resolve => setTimeout(resolve, retryDelay));
-                        }
-                    }
-                }
-            }
-            
+            await this.store.initialize();
             this.initialized = true;
-            logger.info('Settings initialization complete');
+            logger.info('Settings manager initialized');
         } catch (error) {
-            logger.error('Failed to initialize settings:', error);
-            throw error;
+            // Log error but continue with default settings
+            logger.error('Failed to initialize settings manager:', error);
+            logger.info('Continuing with default settings');
+            this.initialized = true;
         }
     }
 
     public getCurrentSettings(): Settings {
+        // Always return settings, which will be defaults if initialization failed
         return this.settings;
     }
 
-    public getDefaultSettings(): Settings {
-        return this.settings;
-    }
+    public async updateSetting(path: SettingsPath, value: SettingValue): Promise<void> {
+        if (!isValidSettingPath(path)) {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
 
-    public async updateSetting<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValueType<T, K>
-    ): Promise<void> {
         try {
-            if (!(category in this.settings)) {
-                throw new Error(`Invalid category: ${category}`);
+            setSettingValue(this.settings, path, value);
+            if (this.initialized) {
+                await this.store.set(path, value);
+            } else {
+                logger.warn(`Setting ${path} updated in memory only - store not initialized`);
             }
-
-            const categorySettings = this.settings[category];
-            if (!(String(setting) in categorySettings)) {
-                throw new Error(`Invalid setting: ${String(setting)} in category ${category}`);
-            }
-
-            // Update the setting
-            (this.settings[category] as any)[setting] = value;
-
-            // Notify subscribers
-            const key = `${category}.${String(setting)}`;
-            const subscribers = this.subscribers.get(key) || [];
-            subscribers.forEach(sub => {
-                try {
-                    sub.callback(value);
-                } catch (error) {
-                    logger.error(`Error in subscriber callback for ${key}:`, error);
-                }
-            });
-
-            // Save settings to backend
-            await this.saveSettings(category, setting, value);
-
+            logger.debug(`Updated setting ${path} to ${value}`);
         } catch (error) {
-            logger.error(`Error updating setting ${category}.${String(setting)}:`, error);
+            logger.error(`Failed to update setting ${path}:`, error);
             throw error;
         }
     }
 
-    private async saveSettings<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValueType<T, K>
-    ): Promise<void> {
+    public get(path: SettingsPath): SettingValue {
+        if (!isValidSettingPath(path)) {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
+        
         try {
-            const response = await fetch(`/api/visualization/settings/${category}/${String(setting)}`, {
-                method: 'PUT',
-                headers: {
-                    'Content-Type': 'application/json',
-                },
-                body: JSON.stringify({ value }),
-            });
+            return getSettingValue(this.settings, path);
+        } catch (error) {
+            logger.error(`Error getting setting at path ${path}:`, error);
+            // Return default value for this path if available
+            return getSettingValue(defaultSettings, path);
+        }
+    }
 
-            if (!response.ok) {
-                throw new Error(`Failed to save setting: ${response.statusText}`);
+    public getCategory(category: SettingsCategory): Settings[typeof category] {
+        if (!(category in this.settings)) {
+            logger.warn(`Category ${category} not found, using defaults`);
+            return defaultSettings[category];
+        }
+        return this.settings[category];
+    }
+
+    public subscribe(path: SettingsPath, callback: (value: SettingValue) => void): () => void {
+        if (!isValidSettingPath(path)) {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
+
+        try {
+            // Get current value for immediate notification
+            const currentValue = this.get(path);
+            try {
+                callback(currentValue);
+            } catch (error) {
+                logger.error(`Error in initial settings callback for ${path}:`, error);
+            }
+
+            // Set up subscription if store is initialized
+            if (this.initialized) {
+                return this.store.subscribe(path, (_, value) => {
+                    try {
+                        callback(value as SettingValue);
+                    } catch (error) {
+                        logger.error(`Error in settings subscriber for ${path}:`, error);
+                    }
+                });
+            } else {
+                logger.warn(`Subscription for ${path} not set up - store not initialized`);
+                return () => {}; // Return no-op cleanup function
             }
         } catch (error) {
-            logger.error(`Error saving setting ${category}.${String(setting)}:`, error);
+            logger.error(`Error setting up subscription for ${path}:`, error);
             throw error;
         }
     }
 
-    public subscribe<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        callback: (value: SettingValueType<T, K>) => void
-    ): () => void {
-        const key = `${category}.${String(setting)}`;
-        if (!this.subscribers.has(key)) {
-            this.subscribers.set(key, []);
-        }
-
-        const subscriber = { callback };
-        this.subscribers.get(key)!.push(subscriber);
+    public onSettingChange(path: SettingsPath, callback: (value: SettingValue) => void): () => void {
+        return this.subscribe(path, callback);
+    }
 
-        return () => {
-            const subscribers = this.subscribers.get(key);
-            if (subscribers) {
-                const index = subscribers.indexOf(subscriber);
-                if (index !== -1) {
-                    subscribers.splice(index, 1);
+    public async batchUpdate(updates: Array<{ path: SettingsPath; value: SettingValue }>): Promise<void> {
+        try {
+            // Validate all paths first
+            for (const { path } of updates) {
+                if (!isValidSettingPath(path)) {
+                    throw new Error(`Invalid settings path: ${path}`);
                 }
             }
-        };
+
+            // Apply updates to local settings first
+            for (const { path, value } of updates) {
+                setSettingValue(this.settings, path, value);
+            }
+
+            // Then sync with store if initialized
+            if (this.initialized) {
+                await Promise.all(
+                    updates.map(({ path, value }) => this.store.set(path, value))
+                );
+            } else {
+                logger.warn('Settings updated in memory only - store not initialized');
+            }
+        } catch (error) {
+            logger.error('Failed to apply batch updates:', error);
+            throw error;
+        }
     }
 
     public dispose(): void {
-        this.subscribers.clear();
+        this.store.dispose();
+        this.initialized = false;
     }
 }
 
-// Default settings that match settings.toml structure
-export const defaultSettings: Settings = {
-  animations: {
-    enableMotionBlur: false,
-    enableNodeAnimations: false,
-    motionBlurStrength: 0.4,
-    selectionWaveEnabled: false,
-    pulseEnabled: false,
-    rippleEnabled: false,
-    edgeAnimationEnabled: false,
-    flowParticlesEnabled: false
-  },
-  ar: {
-    dragThreshold: 0.04,
-    enableHandTracking: true,
-    enableHaptics: true,
-    enableLightEstimation: true,
-    enablePassthroughPortal: false,
-    enablePlaneDetection: true,
-    enableSceneUnderstanding: true,
-    gestureSsmoothing: 0.9,
-    handMeshColor: '#FFD700',
-    handMeshEnabled: true,
-    handMeshOpacity: 0.3,
-    handPointSize: 0.01,
-    handRayColor: '#FFD700',
-    handRayEnabled: true,
-    handRayWidth: 0.002,
-    hapticIntensity: 0.7,
-    passthroughBrightness: 1,
-    passthroughContrast: 1,
-    passthroughOpacity: 1,
-    pinchThreshold: 0.015,
-    planeColor: '#4A90E2',
-    planeOpacity: 0.3,
-    portalEdgeColor: '#FFD700',
-    portalEdgeWidth: 0.02,
-    portalSize: 1,
-    roomScale: true,
-    rotationThreshold: 0.08,
-    showPlaneOverlay: true,
-    snapToFloor: true
-  },
-  audio: {
-    enableAmbientSounds: false,
-    enableInteractionSounds: false,
-    enableSpatialAudio: false
-  },
-  bloom: {
-    edgeBloomStrength: 0.3,
-    enabled: false,
-    environmentBloomStrength: 0.5,
-    nodeBloomStrength: 0.2,
-    radius: 0.5,
-    strength: 1.8
-  },
-  clientDebug: {
-    enabled: true,
-    enableWebsocketDebug: true,
-    enableDataDebug: true,
-    logBinaryHeaders: true,
-    logFullJson: true
-  },
-  default: {
-    apiClientTimeout: 30,
-    enableMetrics: true,
-    enableRequestLogging: true,
-    logFormat: 'json',
-    logLevel: 'debug',
-    maxConcurrentRequests: 5,
-    maxPayloadSize: 5242880,
-    maxRetries: 3,
-    metricsPort: 9090,
-    retryDelay: 5
-  },
-  edges: {
-    arrowSize: 0.15,
-    baseWidth: 2,
-    color: '#917f18',
-    enableArrows: false,
-    opacity: 0.6,
-    widthRange: [1, 3]
-  },
-  labels: {
-    desktopFontSize: 48,
-    enableLabels: true,
-    textColor: '#FFFFFF'
-  },
-  network: {
-    bindAddress: '0.0.0.0',
-    domain: 'localhost',
-    enableHttp2: false,
-    enableRateLimiting: true,
-    enableTls: false,
-    maxRequestSize: 10485760,
-    minTlsVersion: '',
-    port: 3001,
-    rateLimitRequests: 100,
-    rateLimitWindow: 60,
-    tunnelId: 'dummy'
-  },
-  nodes: {
-    baseColor: '#4CAF50',
-    baseSize: 2.5,
-    clearcoat: 1,
-    enableHoverEffect: true,
-    enableInstancing: true,
-    highlightColor: '#ff4444',
-    highlightDuration: 500,
-    hoverScale: 1.2,
-    materialType: 'phong',
-    metalness: 0.5,
-    opacity: 0.7,
-    roughness: 0.5,
-    sizeByConnections: true,
-    sizeRange: [0.15, 0.4]
-  },
-  physics: {
-    attractionStrength: 0.1,
-    boundsSize: 100,
-    collisionRadius: 1,
-    damping: 0.8,
-    enableBounds: true,
-    enabled: true,
-    iterations: 1,
-    maxVelocity: 10,
-    repulsionStrength: 0.2,
-    springStrength: 0.1
-  },
-  rendering: {
-    ambientLightIntensity: 0.5,
-    backgroundColor: '#212121',
-    directionalLightIntensity: 0.8,
-    enableAmbientOcclusion: true,
-    enableAntialiasing: true,
-    enableShadows: true,
-    environmentIntensity: 1
-  },
-  security: {
-    allowedOrigins: ['*'],
-    auditLogPath: '',
-    cookieHttponly: true,
-    cookieSamesite: 'Strict',
-    cookieSecure: true,
-    csrfTokenTimeout: 3600,
-    enableAuditLogging: true,
-    enableRequestValidation: true,
-    sessionTimeout: 86400
-  },
-  serverDebug: {
-    enabled: true,
-    enableWebsocketDebug: true,
-    enableDataDebug: true,
-    logBinaryHeaders: true,
-    logFullJson: true
-  },
-  websocket: {
-    binaryChunkSize: 1000,
-    compressionEnabled: true,
-    compressionThreshold: 1024,
-    heartbeatInterval: 15000,
-    heartbeatTimeout: 60000,
-    maxConnections: 1000,
-    maxMessageSize: 1048576,
-    reconnectAttempts: 3,
-    reconnectDelay: 5000,
-    updateRate: 60,
-    url: '/wss'  // Default WebSocket endpoint
-  }
-};
-
-// Re-export Settings interface
-export type { Settings } from '../types/settings';
-
-// Initialize settings from settings.toml
-export const settingsManager = new SettingsManager(defaultSettings);
+// Export singleton instance
+export const settingsManager = new SettingsManager();
diff --git a/client/types/gestures.ts b/client/types/gestures.ts
new file mode 100644
index 00000000..0d4d166a
--- /dev/null
+++ b/client/types/gestures.ts
@@ -0,0 +1,7 @@
+export enum HandGestureType {
+    None = 'none',
+    Pinch = 'pinch',
+    Grab = 'grab',
+    Point = 'point',
+    Wave = 'wave'
+}
diff --git a/client/types/metadata.ts b/client/types/metadata.ts
new file mode 100644
index 00000000..af6e3e78
--- /dev/null
+++ b/client/types/metadata.ts
@@ -0,0 +1,15 @@
+export interface NodeMetadata {
+    id: string;              // Unique identifier
+    name: string;
+    commitAge: number;        // Age in days
+    hyperlinkCount: number;   // Number of hyperlinks
+    importance: number;       // Normalized importance (0-1)
+    position: {
+        x: number;
+        y: number;
+        z: number;
+    };
+}
+
+// Alias for backward compatibility and clarity
+export type Metadata = NodeMetadata;
diff --git a/client/types/settings.ts b/client/types/settings.ts
index 3943bda9..e7ad3821 100644
--- a/client/types/settings.ts
+++ b/client/types/settings.ts
@@ -1,22 +1,227 @@
-import { Settings, SettingCategory, SettingKey } from '../core/types';
-export type { Settings, SettingCategory, SettingKey };
-
-// Helper type to get the value type for a specific setting
-export type SettingValueType<T extends SettingCategory, K extends SettingKey<T>> = Settings[T][K];
-
-export interface SettingsManager {
-    getCurrentSettings(): Settings;
-    getDefaultSettings(): Settings;
-    initialize(): Promise<void>;
-    updateSetting<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValueType<T, K>
-    ): Promise<void>;
-    subscribe<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        callback: (value: SettingValueType<T, K>) => void
-    ): () => void;
-    dispose(): void;
+import { XRSessionMode } from './xr';
+
+// Core visualization settings
+export interface VisualizationSettings {
+    animations: AnimationSettings;
+    bloom: BloomSettings;
+    edges: EdgeSettings;
+    hologram: HologramSettings;
+    labels: LabelSettings;
+    nodes: NodeSettings;
+    physics: PhysicsSettings;
+    rendering: RenderingSettings;
+}
+
+// XR-specific settings
+export interface XRSettings {
+    // Session settings
+    mode: XRSessionMode;
+    roomScale: boolean;
+    spaceType: XRReferenceSpaceType;
+    quality: 'low' | 'medium' | 'high';
+
+    // Input and interaction
+    input: {
+        enableHandTracking: boolean;
+        enableHaptics: boolean;
+        hapticIntensity: number;
+        dragThreshold: number;
+        pinchThreshold: number;
+        rotationThreshold: number;
+        interactionRadius: number;
+    };
+
+    // Visual settings
+    visuals: {
+        handMeshEnabled: boolean;
+        handMeshColor: string;
+        handMeshOpacity: number;
+        handPointSize: number;
+        handRayEnabled: boolean;
+        handRayColor: string;
+        handRayWidth: number;
+        gestureSsmoothing: number;
+    };
+
+    // Environment settings
+    environment: {
+        enableLightEstimation: boolean;
+        enablePlaneDetection: boolean;
+        enableSceneUnderstanding: boolean;
+        planeColor: string;
+        planeOpacity: number;
+        showPlaneOverlay: boolean;
+        snapToFloor: boolean;
+    };
+
+    // Passthrough settings
+    passthrough: {
+        enabled: boolean;
+        opacity: number;
+        brightness: number;
+        contrast: number;
+        portalSize: number;
+        portalEdgeColor: string;
+        portalEdgeWidth: number;
+    };
+}
+
+// System settings
+export interface SystemSettings {
+    network: NetworkSettings;
+    websocket: WebSocketSettings;
+    security: SecuritySettings;
+    debug: DebugSettings;
+}
+
+// Component settings interfaces
+export interface AnimationSettings {
+    enableMotionBlur: boolean;
+    enableNodeAnimations: boolean;
+    motionBlurStrength: number;
+    selectionWaveEnabled: boolean;
+    pulseEnabled: boolean;
+    rippleEnabled: boolean;
+    edgeAnimationEnabled: boolean;
+    flowParticlesEnabled: boolean;
+}
+
+export interface BloomSettings {
+    enabled: boolean;
+    strength: number;
+    radius: number;
+    edgeBloomStrength: number;
+    nodeBloomStrength: number;
+    environmentBloomStrength: number;
+}
+
+export interface EdgeSettings {
+    arrowSize: number;
+    baseWidth: number;
+    color: string;
+    enableArrows: boolean;
+    opacity: number;
+    widthRange: [number, number];
+}
+
+export interface HologramSettings {
+    ringCount: number;
+    ringColor: string;
+    ringOpacity: number;
+    ringSizes: number[];
+    ringRotationSpeed: number;
+    enableBuckminster: boolean;
+    buckminsterScale: number;
+    buckminsterOpacity: number;
+    enableGeodesic: boolean;
+    geodesicScale: number;
+    geodesicOpacity: number;
+    enableTriangleSphere: boolean;
+    triangleSphereScale: number;
+    triangleSphereOpacity: number;
+    globalRotationSpeed: number;
+}
+
+export interface LabelSettings {
+    enableLabels: boolean;
+    textColor: string;
+    textOutlineColor: string;
+    textOutlineWidth: number;
+    textResolution: number;
+    textPadding: number;
+    desktopFontSize: number;
+    billboardMode: 'camera' | 'up';
+}
+
+export interface NodeSettings {
+    baseColor: string;
+    baseSize: number;
+    sizeRange: [number, number];
+    enableMetadataShape: boolean;
+    colorRangeAge: [string, string];
+    colorRangeLinks: [string, string];
+    metalness: number;
+    roughness: number;
+    opacity: number;
+}
+
+export interface PhysicsSettings {
+    enabled: boolean;
+    attractionStrength: number;
+    repulsionStrength: number;
+    springStrength: number;
+    damping: number;
+    iterations: number;
+    maxVelocity: number;
+    collisionRadius: number;
+    enableBounds: boolean;
+    boundsSize: number;
+}
+
+export interface RenderingSettings {
+    ambientLightIntensity: number;
+    directionalLightIntensity: number;
+    environmentIntensity: number;
+    backgroundColor: string;
+    enableAmbientOcclusion: boolean;
+    enableAntialiasing: boolean;
+    enableShadows: boolean;
+}
+
+export interface NetworkSettings {
+    bindAddress: string;
+    domain: string;
+    port: number;
+    enableHttp2: boolean;
+    enableTls: boolean;
+    minTlsVersion: string;
+    maxRequestSize: number;
+    enableRateLimiting: boolean;
+    rateLimitRequests: number;
+    rateLimitWindow: number;
+    tunnelId: string;
 }
+
+export interface WebSocketSettings {
+    url: string;
+    heartbeatInterval: number;
+    heartbeatTimeout: number;
+    reconnectAttempts: number;
+    reconnectDelay: number;
+    binaryChunkSize: number;
+    compressionEnabled: boolean;
+    compressionThreshold: number;
+    maxConnections: number;
+    maxMessageSize: number;
+    updateRate: number;
+}
+
+export interface SecuritySettings {
+    allowedOrigins: string[];
+    auditLogPath: string;
+    cookieHttponly: boolean;
+    cookieSamesite: string;
+    cookieSecure: boolean;
+    csrfTokenTimeout: number;
+    enableAuditLogging: boolean;
+    enableRequestValidation: boolean;
+    sessionTimeout: number;
+}
+
+export interface DebugSettings {
+    enabled: boolean;
+    enableDataDebug: boolean;
+    enableWebsocketDebug: boolean;
+    logBinaryHeaders: boolean;
+    logFullJson: boolean;
+}
+
+// Main settings interface
+export interface Settings {
+    visualization: VisualizationSettings;
+    xr: XRSettings;
+    system: SystemSettings;
+}
+
+export * from './settings/base';
+export * from './settings/utils';
diff --git a/client/types/settings/base.ts b/client/types/settings/base.ts
new file mode 100644
index 00000000..11379a15
--- /dev/null
+++ b/client/types/settings/base.ts
@@ -0,0 +1,151 @@
+// Base types for settings
+export interface BaseSettings {
+    visualization: {
+        animations: {
+            enableMotionBlur: boolean;
+            enableNodeAnimations: boolean;
+            motionBlurStrength: number;
+            selectionWaveEnabled: boolean;
+            pulseEnabled: boolean;
+            rippleEnabled: boolean;
+            edgeAnimationEnabled: boolean;
+            flowParticlesEnabled: boolean;
+        };
+        bloom: {
+            enabled: boolean;
+            strength: number;
+            radius: number;
+            edgeBloomStrength: number;
+            nodeBloomStrength: number;
+            environmentBloomStrength: number;
+        };
+        edges: {
+            arrowSize: number;
+            baseWidth: number;
+            color: string;
+            enableArrows: boolean;
+            opacity: number;
+            widthRange: [number, number];
+        };
+        hologram: {
+            ringCount: number;
+            ringColor: string;
+            ringOpacity: number;
+            ringSizes: [number, number, number];
+            ringRotationSpeed: number;
+            enableBuckminster: boolean;
+            buckminsterScale: number;
+            buckminsterOpacity: number;
+            enableGeodesic: boolean;
+            geodesicScale: number;
+            geodesicOpacity: number;
+            enableTriangleSphere: boolean;
+            triangleSphereScale: number;
+            triangleSphereOpacity: number;
+            globalRotationSpeed: number;
+        };
+        labels: {
+            enableLabels: boolean;
+            textColor: string;
+            fontSize: number;
+            fontFamily: string;
+            strokeWidth: number;
+            strokeColor: string;
+            backgroundColor: string;
+            backgroundOpacity: number;
+            maxLength: number;
+            minDistance: number;
+            maxDistance: number;
+        };
+        nodes: {
+            baseSize: number;
+            sizeRange: [number, number];
+            color: string;
+            opacity: number;
+            outlineWidth: number;
+            outlineColor: string;
+            enableGlow: boolean;
+            glowStrength: number;
+            glowColor: string;
+            enablePulse: boolean;
+            pulseSpeed: number;
+            pulseStrength: number;
+        };
+        physics: {
+            enabled: boolean;
+            gravity: number;
+            springLength: number;
+            springStrength: number;
+            damping: number;
+            repulsion: number;
+            timeStep: number;
+            maxVelocity: number;
+            minVelocity: number;
+            maxIterations: number;
+        };
+    };
+    xr: {
+        mode: 'immersive-ar' | 'immersive-vr';
+        roomScale: boolean;
+        quality: 'low' | 'medium' | 'high';
+        input: {
+            handTracking: boolean;
+            controllerModel: string;
+            hapticFeedback: boolean;
+            gestureThreshold: number;
+            pinchThreshold: number;
+            grabThreshold: number;
+        };
+        visuals: {
+            shadowQuality: 'none' | 'low' | 'medium' | 'high';
+            antiAliasing: boolean;
+            foveatedRendering: boolean;
+            foveationLevel: number;
+            resolution: number;
+        };
+        environment: {
+            skybox: boolean;
+            skyboxColor: string;
+            groundPlane: boolean;
+            groundColor: string;
+            fog: boolean;
+            fogColor: string;
+            fogDensity: number;
+        };
+        passthrough: {
+            enabled: boolean;
+            opacity: number;
+            brightness: number;
+            contrast: number;
+            saturation: number;
+            blendMode: 'alpha-blend' | 'additive' | 'multiply';
+        };
+    };
+    system: {
+        debug: {
+            enabled: boolean;
+            logLevel: 'error' | 'warn' | 'info' | 'debug' | 'trace';
+            showStats: boolean;
+            showFPS: boolean;
+            showMemory: boolean;
+            logFullJson: boolean;
+        };
+        network: {
+            websocketUrl: string;
+            reconnectInterval: number;
+            maxReconnectAttempts: number;
+            heartbeatInterval: number;
+            compressionEnabled: boolean;
+            batchUpdates: boolean;
+            batchInterval: number;
+        };
+        security: {
+            enableEncryption: boolean;
+            encryptionAlgorithm: string;
+            encryptionKeySize: number;
+            enableAuthentication: boolean;
+            authenticationMethod: string;
+            tokenExpiration: number;
+        };
+    };
+}
diff --git a/client/types/settings/utils.ts b/client/types/settings/utils.ts
new file mode 100644
index 00000000..f168a033
--- /dev/null
+++ b/client/types/settings/utils.ts
@@ -0,0 +1,171 @@
+import { Settings } from '../settings';
+import { defaultSettings } from '../../state/defaultSettings';
+
+// Type for top-level settings categories
+export type SettingsCategory = keyof Settings;
+
+// Type for all possible paths in settings
+export type SettingsPath = string;
+
+// Type guard to check if a string is a valid settings category
+export function isSettingsCategory(key: string): key is SettingsCategory {
+    return key in defaultSettings;
+}
+
+// Type guard to check if a path exists in settings
+export function isValidSettingPath(path: string): boolean {
+    if (!path) {
+        return false;
+    }
+
+    try {
+        const parts = path.split('.');
+        if (parts.length === 0) {
+            return false;
+        }
+
+        let current: any = defaultSettings;
+        for (const part of parts) {
+            if (!part || typeof part !== 'string' || !(part in current)) {
+                return false;
+            }
+            current = current[part];
+        }
+        
+        return true;
+    } catch (error: unknown) {
+        return false;
+    }
+}
+
+// Get value from settings using path
+export function getSettingValue(settings: Settings, path: string): any {
+    if (!settings || typeof settings !== 'object') {
+        throw new Error('Invalid settings object');
+    }
+    if (!path) {
+        throw new Error('Path cannot be empty');
+    }
+    
+    try {
+        return path.split('.').reduce((obj: any, key) => {
+            if (obj === null || obj === undefined) {
+                throw new Error(`Invalid path: ${path}`);
+            }
+            return obj[key];
+        }, settings);
+    } catch (error: unknown) {
+        const message = error instanceof Error ? error.message : 'Unknown error';
+        throw new Error(`Failed to get setting value at path ${path}: ${message}`);
+    }
+}
+
+// Set value in settings using path
+export function setSettingValue(settings: Settings, path: string, value: any): void {
+    if (!settings || typeof settings !== 'object') {
+        throw new Error('Invalid settings object');
+    }
+    if (!path) {
+        throw new Error('Path cannot be empty');
+    }
+    
+    try {
+        const parts = path.split('.');
+        const lastKey = parts.pop();
+        if (!lastKey) {
+            throw new Error('Invalid path format');
+        }
+        
+        const target = parts.reduce((obj: any, key) => {
+            if (!(key in obj)) {
+                obj[key] = {};
+            }
+            return obj[key];
+        }, settings);
+
+        if (!target || typeof target !== 'object') {
+            throw new Error(`Invalid path: ${path}`);
+        }
+
+        target[lastKey] = value;
+    } catch (error: unknown) {
+        const message = error instanceof Error ? error.message : 'Unknown error';
+        throw new Error(`Failed to set setting value at path ${path}: ${message}`);
+    }
+}
+
+// Get the parent category of a setting path
+export function getSettingCategory(path: string): SettingsCategory | undefined {
+    if (!path) {
+        return undefined;
+    }
+    const category = path.split('.')[0];
+    return isSettingsCategory(category) ? category : undefined;
+}
+
+// Get subcategory path (everything after the main category)
+export function getSettingSubPath(path: string): string | undefined {
+    if (!path) {
+        return undefined;
+    }
+    const parts = path.split('.');
+    return parts.length > 1 ? parts.slice(1).join('.') : undefined;
+}
+
+// Helper to check if a value is a nested settings object
+export function isSettingsObject(value: any): boolean {
+    return value !== null && typeof value === 'object' && !Array.isArray(value);
+}
+
+// Helper to get all paths in a settings object
+export function getAllSettingPaths(
+    obj: any,
+    parentPath: string = '',
+    paths: string[] = []
+): string[] {
+    if (!isSettingsObject(obj)) {
+        return paths;
+    }
+
+    for (const key in obj) {
+        const currentPath = parentPath ? `${parentPath}.${key}` : key;
+        if (isSettingsObject(obj[key])) {
+            getAllSettingPaths(obj[key], currentPath, paths);
+        } else {
+            paths.push(currentPath);
+        }
+    }
+    return paths;
+}
+
+// Type helper for settings values
+export type SettingValue = string | number | boolean | string[] | number[];
+
+// Helper to get the appropriate input type for a setting
+export function getSettingInputType(value: SettingValue): string {
+    if (value === null || value === undefined) {
+        return 'text';
+    }
+    if (typeof value === 'boolean') return 'checkbox';
+    if (typeof value === 'number') return 'number';
+    if (typeof value === 'string' && value.startsWith('#')) return 'color';
+    if (Array.isArray(value)) return 'select';
+    return 'text';
+}
+
+// Helper to format setting names for display
+export function formatSettingName(setting: string): string {
+    if (!setting) return '';
+    return setting
+        .split(/(?=[A-Z])|_/)
+        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
+        .join(' ');
+}
+
+// Helper to get step value for number inputs
+export function getStepValue(key: string): string {
+    if (!key) return '1';
+    return key.toLowerCase().match(/strength|opacity|intensity|threshold|scale/)
+        ? '0.1'
+        : '1';
+}
diff --git a/client/types/settings/xr.ts b/client/types/settings/xr.ts
new file mode 100644
index 00000000..fa89f8de
--- /dev/null
+++ b/client/types/settings/xr.ts
@@ -0,0 +1,103 @@
+import { XRSessionMode } from '../xr';
+
+export interface XRSettings {
+    // Session Settings
+    mode: XRSessionMode;
+    roomScale: boolean;
+    spaceType: XRReferenceSpaceType;
+    
+    // Hand Tracking
+    enableHandTracking: boolean;
+    handMeshEnabled: boolean;
+    handMeshColor: string;
+    handMeshOpacity: number;
+    handPointSize: number;
+    handRayEnabled: boolean;
+    handRayColor: string;
+    handRayWidth: number;
+    gestureSsmoothing: number;
+    
+    // Interaction
+    enableHaptics: boolean;
+    hapticIntensity: number;
+    dragThreshold: number;
+    pinchThreshold: number;
+    rotationThreshold: number;
+    interactionRadius: number;
+    
+    // Scene Understanding
+    enableLightEstimation: boolean;
+    enablePlaneDetection: boolean;
+    enableSceneUnderstanding: boolean;
+    planeColor: string;
+    planeOpacity: number;
+    showPlaneOverlay: boolean;
+    snapToFloor: boolean;
+    
+    // Passthrough
+    enablePassthroughPortal: boolean;
+    passthroughOpacity: number;
+    passthroughBrightness: number;
+    passthroughContrast: number;
+    portalSize: number;
+    portalEdgeColor: string;
+    portalEdgeWidth: number;
+    
+    // Quality Settings
+    quality: 'low' | 'medium' | 'high';
+}
+
+// Platform-specific XR settings
+export interface QuestXRSettings extends XRSettings {
+    enableHandMeshes: boolean;
+    enableControllerModel: boolean;
+    controllerProfile: string;
+}
+
+export interface WebXRSettings extends XRSettings {
+    fallbackToInline: boolean;
+    requireFeatures: string[];
+    optionalFeatures: string[];
+}
+
+// Default XR settings
+export const defaultXRSettings: XRSettings = {
+    mode: 'immersive-ar',
+    roomScale: true,
+    spaceType: 'local-floor',
+    
+    enableHandTracking: true,
+    handMeshEnabled: true,
+    handMeshColor: '#ffffff',
+    handMeshOpacity: 0.5,
+    handPointSize: 5,
+    handRayEnabled: true,
+    handRayColor: '#00ff00',
+    handRayWidth: 2,
+    gestureSsmoothing: 0.5,
+    
+    enableHaptics: true,
+    hapticIntensity: 0.5,
+    dragThreshold: 0.02,
+    pinchThreshold: 0.7,
+    rotationThreshold: 0.1,
+    interactionRadius: 0.5,
+    
+    enableLightEstimation: true,
+    enablePlaneDetection: true,
+    enableSceneUnderstanding: true,
+    planeColor: '#808080',
+    planeOpacity: 0.5,
+    showPlaneOverlay: true,
+    snapToFloor: true,
+    
+    enablePassthroughPortal: false,
+    passthroughOpacity: 1,
+    passthroughBrightness: 1,
+    passthroughContrast: 1,
+    portalSize: 2,
+    portalEdgeColor: '#ffffff',
+    portalEdgeWidth: 2,
+    
+    quality: 'medium'
+};
diff --git a/client/types/websocket.ts b/client/types/websocket.ts
new file mode 100644
index 00000000..2c9bceff
--- /dev/null
+++ b/client/types/websocket.ts
@@ -0,0 +1,36 @@
+// WebSocket types for graph synchronization
+
+export enum ConnectionState {
+    DISCONNECTED = 'DISCONNECTED',
+    CONNECTING = 'CONNECTING',
+    CONNECTED = 'CONNECTED',
+    RECONNECTING = 'RECONNECTING'
+}
+
+export enum MessageType {
+    PING = 'ping',                          // Connection health check
+    PONG = 'pong'                           // Connection health response
+}
+
+// Connection health messages
+export interface PingMessage {
+    type: MessageType.PING;
+    timestamp: number;
+}
+
+export interface PongMessage {
+    type: MessageType.PONG;
+    timestamp: number;
+}
+
+export type WebSocketMessage = PingMessage | PongMessage;
+
+// WebSocket settings loaded via REST API
+export interface WebSocketSettings {
+    url: string;                   // WebSocket server URL
+    heartbeatInterval: number;     // Ping interval in seconds (default: 30)
+    heartbeatTimeout: number;      // Connection timeout in seconds (default: 3600)
+    reconnectAttempts: number;     // Max reconnection attempts (default: 3)
+    reconnectDelay: number;        // Delay between reconnects in ms (default: 5000)
+    updateRate: number;            // Update rate in Hz
+}
diff --git a/client/types/xr.ts b/client/types/xr.ts
new file mode 100644
index 00000000..c398b021
--- /dev/null
+++ b/client/types/xr.ts
@@ -0,0 +1,99 @@
+import * as THREE from 'three';
+import { Platform } from '../core/types';
+
+// Core XR Types
+export type XRSessionMode = 'inline' | 'immersive-vr' | 'immersive-ar';
+
+export interface XRSessionConfig {
+    mode: XRSessionMode;
+    features: {
+        required?: string[];
+        optional?: string[];
+    };
+    spaceType: XRReferenceSpaceType;
+}
+
+// Input and Interaction Types
+export interface HapticActuator {
+    pulse: (intensity: number, duration: number) => Promise<boolean>;
+}
+
+export interface WorldObject3D extends THREE.Object3D {
+    getWorldPosition(target: THREE.Vector3): THREE.Vector3;
+}
+
+export interface XRControllerState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    hapticActuator?: HapticActuator;
+    platform: Platform;
+}
+
+export interface XRHandJointState {
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+    radius?: number;
+}
+
+export interface XRHandState {
+    position: THREE.Vector3;
+    joints: Map<XRHandJoint, XRHandJointState>;
+    pinchStrength: number;
+    gripStrength: number;
+    platform: Platform;
+}
+
+export interface XRHandWithHaptics extends THREE.Group {
+    hapticActuators?: HapticActuator[];
+    hand: {
+        joints: {
+            [key in XRHandJoint]?: WorldObject3D;
+        };
+    };
+    pinchStrength: number;
+    gripStrength: number;
+    userData: {
+        hapticActuator?: HapticActuator;
+        platform: Platform;
+    };
+}
+
+// Input Configuration
+export interface XRInputConfig {
+    controllers: boolean;
+    hands: boolean;
+    haptics: boolean;
+}
+
+// Event Types
+export interface XRControllerEvent {
+    controller: XRSpace;
+    inputSource: XRInputSource;
+    hapticActuator?: HapticActuator;
+}
+
+export interface XRHandEvent {
+    hand: XRHandWithHaptics;
+    inputSource: XRInputSource;
+}
+
+export interface XRInteractionState {
+    pinching: boolean;
+    pinchStrength: number;
+    gripping: boolean;
+    gripStrength: number;
+    position: THREE.Vector3;
+    rotation: THREE.Quaternion;
+}
+
+// Platform-specific Types
+export interface QuestHandTracking extends XRHandState {
+    confidence: number;
+    gestureId?: number;
+}
+
+export interface QuestControllerTracking extends XRControllerState {
+    thumbstick: THREE.Vector2;
+    trigger: number;
+    grip: number;
+}
diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
index 72e7bc09..a65b7747 100644
--- a/client/ui/ControlPanel.css
+++ b/client/ui/ControlPanel.css
@@ -121,6 +121,32 @@
     border-color: rgba(231, 76, 60, 0.6);
 }
 
+.randomize-button-container {
+    padding: 16px;
+    margin-bottom: 16px;
+    border-bottom: 1px solid #ccc;
+}
+
+.randomize-button {
+    width: 100%;
+    padding: 12px;
+    font-size: 16px;
+    color: white;
+    background-color: #2196f3;
+    border: none;
+    border-radius: 4px;
+    cursor: pointer;
+    transition: background-color 0.3s ease;
+}
+
+.randomize-button:hover {
+    background-color: #1976d2;
+}
+
+.randomize-button:active {
+    background-color: #0d47a1;
+}
+
 /* Scrollbar styles */
 .control-panel::-webkit-scrollbar {
     width: 8px;
diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
index 93c33bcd..590a29a6 100644
--- a/client/ui/ControlPanel.ts
+++ b/client/ui/ControlPanel.ts
@@ -1,169 +1,271 @@
-/**
- * Control panel for visualization settings
- */
-
-import { Settings, SettingCategory, SettingKey, SettingValueType } from '../types/settings';
-import { settingsManager } from '../state/settings';
-import { createLogger } from '../utils/logger';
+import { Settings } from '../types/settings';
+import { createLogger } from '../core/logger';
+import { SettingsStore } from '../state/SettingsStore';
+import './ControlPanel.css';
 
 const logger = createLogger('ControlPanel');
 
 export class ControlPanel {
     private container: HTMLElement;
-    private currentSettings: Settings;
+    private settings: Settings;
     private unsubscribers: Array<() => void> = [];
+    private settingsStore: SettingsStore;
 
     constructor(container: HTMLElement) {
         this.container = container;
-        this.currentSettings = settingsManager.getCurrentSettings();
-        this.setupUI();
+        this.settingsStore = SettingsStore.getInstance();
+        this.settings = {} as Settings;
+        this.initializePanel();
     }
 
-    private async setupUI(): Promise<void> {
+    private async initializePanel(): Promise<void> {
         try {
-            Object.entries(this.currentSettings).forEach(([categoryName, settings]) => {
-                const category = categoryName as SettingCategory;
-                const categoryContainer = document.createElement('div');
-                categoryContainer.classList.add('settings-category');
-                
-                const categoryTitle = document.createElement('h3');
-                categoryTitle.textContent = this.formatDisplayName(category);
-                categoryContainer.appendChild(categoryTitle);
-
-                Object.entries(settings).forEach(([settingName, value]) => {
-                    const setting = settingName as SettingKey<typeof category>;
-                    this.createSettingControl(
-                        category,
-                        setting,
-                        value as SettingValueType<typeof category, typeof setting>,
-                        categoryContainer
-                    );
-                });
-
-                this.container.appendChild(categoryContainer);
-            });
-
+            await this.settingsStore.initialize();
+            this.settings = this.settingsStore.get('') as Settings;
+            this.createPanelElements();
+            this.setupSettingsSubscriptions();
         } catch (error) {
-            logger.error('Error setting up UI:', error);
+            logger.error('Failed to initialize control panel:', error);
         }
     }
 
-    private formatDisplayName(name: string): string {
-        return name
-            .replace(/([A-Z])/g, ' $1') // Add space before capital letters
-            .replace(/^./, str => str.toUpperCase()); // Capitalize first letter
+    private createPanelElements(): void {
+        // Clear existing content
+        this.container.innerHTML = '';
+
+        // Create settings sections
+        const flatSettings = this.flattenSettings(this.settings);
+        const groupedSettings = this.groupSettingsByCategory(flatSettings);
+
+        for (const [category, settings] of Object.entries(groupedSettings)) {
+            const section = this.createSection(category);
+            
+            for (const [path, value] of Object.entries(settings)) {
+                const control = this.createSettingControl(path, value);
+                if (control) {
+                    section.appendChild(control);
+                }
+            }
+            
+            this.container.appendChild(section);
+        }
     }
 
-    private createSettingControl<T extends SettingCategory, K extends SettingKey<T>>(
-        category: T,
-        setting: K,
-        value: SettingValueType<T, K>,
-        container: HTMLElement
-    ): void {
-        const controlContainer = document.createElement('div');
-        controlContainer.classList.add('setting-control');
+    private flattenSettings(obj: unknown, prefix: string = ''): Record<string, unknown> {
+        const result: Record<string, unknown> = {};
+        
+        if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
+            for (const [key, value] of Object.entries(obj)) {
+                const newKey = prefix ? `${prefix}.${key}` : key;
+                
+                if (value && typeof value === 'object' && !Array.isArray(value)) {
+                    Object.assign(result, this.flattenSettings(value, newKey));
+                } else {
+                    result[newKey] = value;
+                }
+            }
+        }
+        
+        return result;
+    }
 
+    private groupSettingsByCategory(flatSettings: Record<string, unknown>): Record<string, Record<string, unknown>> {
+        const result: Record<string, Record<string, unknown>> = {};
+        
+        for (const [path, value] of Object.entries(flatSettings)) {
+            const category = path.split('.')[0];
+            if (!result[category]) {
+                result[category] = {};
+            }
+            result[category][path] = value;
+        }
+        
+        return result;
+    }
+
+    private createSection(category: string): HTMLElement {
+        const section = document.createElement('div');
+        section.className = 'settings-section';
+        
+        const header = document.createElement('h2');
+        header.textContent = this.formatCategoryName(category);
+        section.appendChild(header);
+        
+        return section;
+    }
+
+    private createSettingControl(path: string, value: unknown): HTMLElement | null {
+        const container = document.createElement('div');
+        container.className = 'setting-control';
+        
         const label = document.createElement('label');
-        label.textContent = this.formatDisplayName(String(setting));
-        controlContainer.appendChild(label);
+        label.textContent = this.formatSettingName(path.split('.').pop()!);
+        container.appendChild(label);
+        
+        const control = this.createInputElement(path, value);
+        if (!control) {
+            return null;
+        }
+        
+        container.appendChild(control);
+        return container;
+    }
 
-        if (Array.isArray(value)) {
-            // Handle array values (e.g., widthRange, sizeRange)
-            const arrayContainer = document.createElement('div');
-            arrayContainer.classList.add('array-control');
-            
-            value.forEach((item, index) => {
-                const itemInput = document.createElement('input');
-                itemInput.type = 'number';
-                itemInput.value = String(item);
-                itemInput.step = '0.1';
-                itemInput.onchange = async (event) => {
-                    const target = event.target as HTMLInputElement;
-                    const newArray = [...value];
-                    newArray[index] = parseFloat(target.value);
-                    try {
-                        await settingsManager.updateSetting(category, setting, newArray as SettingValueType<T, K>);
-                    } catch (error) {
-                        logger.error(`Error updating array setting ${category}.${String(setting)}:`, error);
-                        target.value = String(item);
-                    }
-                };
-                arrayContainer.appendChild(itemInput);
-            });
-            
-            controlContainer.appendChild(arrayContainer);
-        } else if (typeof value === 'object' && value !== null) {
-            // Handle nested objects
-            logger.warn(`Nested object setting not supported in UI: ${category}.${String(setting)}`);
-            return;
-        } else {
-            let input: HTMLInputElement;
-            
-            switch (typeof value) {
-                case 'boolean':
-                    input = document.createElement('input');
-                    input.type = 'checkbox';
-                    input.checked = value as boolean;
-                    break;
+    private createInputElement(path: string, value: unknown): HTMLElement | null {
+        const type = this.getInputType(value);
+        if (!type) {
+            return null;
+        }
 
-                case 'number':
-                    input = document.createElement('input');
-                    input.type = 'number';
-                    input.value = String(value);
-                    input.step = '0.1';
-                    break;
+        let input: HTMLElement;
+        
+        switch (type) {
+            case 'checkbox':
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'checkbox';
+                (input as HTMLInputElement).checked = value as boolean;
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, target.checked);
+                };
+                break;
 
-                case 'string':
-                    input = document.createElement('input');
-                    if (value.startsWith('#')) {
-                        input.type = 'color';
-                    } else {
-                        input.type = 'text';
-                    }
-                    input.value = value;
-                    break;
+            case 'number':
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'number';
+                (input as HTMLInputElement).value = String(value);
+                (input as HTMLInputElement).step = this.getStepValue(path);
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, parseFloat(target.value));
+                };
+                break;
 
-                default:
-                    logger.warn(`Unsupported setting type for ${category}.${String(setting)}`);
-                    return;
-            }
+            case 'color':
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'color';
+                (input as HTMLInputElement).value = value as string;
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, target.value);
+                };
+                break;
 
-            input.onchange = async (event) => {
-                const target = event.target as HTMLInputElement;
-                let newValue: SettingValueType<T, K>;
-
-                switch (target.type) {
-                    case 'checkbox':
-                        newValue = target.checked as SettingValueType<T, K>;
-                        break;
-                    case 'number':
-                        newValue = parseFloat(target.value) as SettingValueType<T, K>;
-                        break;
-                    default:
-                        newValue = target.value as SettingValueType<T, K>;
+            case 'select':
+                input = document.createElement('select');
+                if (Array.isArray(value)) {
+                    value.forEach(option => {
+                        const opt = document.createElement('option');
+                        opt.value = String(option);
+                        opt.textContent = String(option);
+                        input.appendChild(opt);
+                    });
                 }
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLSelectElement;
+                    this.settingsStore.set(path, target.value);
+                };
+                break;
+
+            default:
+                input = document.createElement('input');
+                (input as HTMLInputElement).type = 'text';
+                (input as HTMLInputElement).value = String(value);
+                input.onchange = (e: Event) => {
+                    const target = e.target as HTMLInputElement;
+                    this.settingsStore.set(path, target.value);
+                };
+        }
 
-                try {
-                    await settingsManager.updateSetting(category, setting, newValue);
-                } catch (error) {
-                    logger.error(`Error updating setting ${category}.${String(setting)}:`, error);
-                    // Revert the UI to the previous value
-                    if (target.type === 'checkbox') {
-                        target.checked = value as boolean;
-                    } else {
-                        target.value = String(value);
-                    }
+        input.id = `setting-${path}`;
+        return input;
+    }
+
+    private getInputType(value: unknown): string | null {
+        switch (typeof value) {
+            case 'boolean':
+                return 'checkbox';
+            case 'number':
+                return 'number';
+            case 'string':
+                if (value.match(/^#[0-9a-f]{6}$/i)) {
+                    return 'color';
+                }
+                return 'text';
+            case 'object':
+                if (Array.isArray(value)) {
+                    return 'select';
                 }
-            };
+                return null;
+            default:
+                return null;
+        }
+    }
 
-            controlContainer.appendChild(input);
+    private getStepValue(path: string): string {
+        if (path.includes('opacity') || path.includes('strength')) {
+            return '0.1';
         }
+        return '1';
+    }
+
+    private formatCategoryName(category: string): string {
+        return category
+            .split(/(?=[A-Z])/)
+            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
+            .join(' ');
+    }
 
-        container.appendChild(controlContainer);
+    private formatSettingName(setting: string): string {
+        return setting
+            .split(/(?=[A-Z])/)
+            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
+            .join(' ');
+    }
+
+    private setupSettingsSubscriptions(): void {
+        // Clear existing subscriptions
+        this.unsubscribers.forEach(unsub => unsub());
+        this.unsubscribers = [];
+
+        const flatSettings = this.flattenSettings(this.settings);
+        for (const path of Object.keys(flatSettings)) {
+            const unsubscribe = this.settingsStore.subscribe(path, (_: string, value: unknown) => {
+                this.updateSettingElement(path, value);
+            });
+            this.unsubscribers.push(unsubscribe);
+        }
+    }
+
+    private updateSettingElement(path: string, value: unknown): void {
+        const element = document.getElementById(`setting-${path}`);
+        if (!element) {
+            logger.warn(`No element found for setting: ${path}`);
+            return;
+        }
+
+        if (element instanceof HTMLInputElement) {
+            switch (element.type) {
+                case 'checkbox':
+                    element.checked = value as boolean;
+                    break;
+                case 'number':
+                    element.value = String(value);
+                    break;
+                case 'color':
+                    element.value = value as string;
+                    break;
+                default:
+                    element.value = String(value);
+            }
+        } else if (element instanceof HTMLSelectElement) {
+            element.value = String(value);
+        }
     }
 
     public dispose(): void {
-        this.unsubscribers.forEach(unsubscribe => unsubscribe());
+        this.unsubscribers.forEach(unsub => unsub());
         this.unsubscribers = [];
+        this.container.innerHTML = '';
     }
 }
diff --git a/client/utils/logger.ts b/client/utils/logger.ts
deleted file mode 100644
index 6200007d..00000000
--- a/client/utils/logger.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-export interface Logger {
-    log: (message: string, ...args: any[]) => void;
-    error: (message: string, ...args: any[]) => void;
-    warn: (message: string, ...args: any[]) => void;
-    info: (message: string, ...args: any[]) => void;
-    debug: (message: string, ...args: any[]) => void;
-}
-
-// Track debug state
-let debugEnabled = true; // Start with debug enabled
-
-export function setDebugEnabled(enabled: boolean): void {
-    debugEnabled = enabled;
-}
-
-export function createLogger(context: string): Logger {
-    const prefix = `[${context}]`;
-
-    return {
-        // Always log errors and warnings
-        log: (message: string, ...args: any[]) => console.log(`${prefix} ${message}`, ...args),
-        error: (message: string, ...args: any[]) => console.error(`${prefix} ${message}`, ...args),
-        warn: (message: string, ...args: any[]) => console.warn(`${prefix} ${message}`, ...args),
-        
-        // Debug and info respect debug state
-        info: (message: string, ...args: any[]) => {
-            if (debugEnabled) {
-                console.info(`${prefix} ${message}`, ...args);
-            }
-        },
-        debug: (message: string, ...args: any[]) => {
-            if (debugEnabled) {
-                console.debug(`${prefix} ${message}`, ...args);
-            }
-        }
-    };
-}
diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
index 2a2d0656..825d04d3 100644
--- a/client/websocket/websocketService.ts
+++ b/client/websocket/websocketService.ts
@@ -1,586 +1,383 @@
-/**
- * WebSocket service for real-time communication
- */
-
-import {
-  MessageType,
-  MessageHandler,
-  ErrorHandler,
-  ConnectionHandler,
-  WebSocketStatus,
-  WebSocketError as CoreWebSocketError,
-  WebSocketErrorType as CoreWebSocketErrorType
-} from '../core/types';
-import { WS_MESSAGE_QUEUE_SIZE } from '../core/constants';
-import { createLogger } from '../utils/logger';
-import { settingsManager } from '../state/settings';
+import { createLogger } from '../core/logger';
+import { buildWsUrl } from '../core/api';
+import { 
+    WS_HEARTBEAT_INTERVAL,
+    WS_HEARTBEAT_TIMEOUT,
+    BINARY_VERSION,
+    FLOATS_PER_NODE 
+} from '../core/constants';
 
 const logger = createLogger('WebSocketService');
 
-// WebSocket error class
-export class WebSocketError extends Error implements CoreWebSocketError {
-  constructor(
-    public readonly type: CoreWebSocketErrorType,
-    public readonly originalError?: Error,
-    public readonly code?: number,
-    public readonly details?: any
-  ) {
-    super(originalError?.message || type);
-    this.name = 'WebSocketError';
-  }
+interface WebSocketError {
+    error: string;
 }
 
-export class WebSocketService {
-  private ws: WebSocket | null = null;
-  private reconnectTimeout: NodeJS.Timeout | null = null;
-  private messageQueue: Array<string> = [];
-  private isConnected = false;
-  private isConnecting = false;
-  private reconnectAttempts = 0;
-  private messageHandlers: Map<MessageType, MessageHandler[]> = new Map();
-  private errorHandlers: ErrorHandler[] = [];
-  private connectionHandlers: ConnectionHandler[] = [];
-  private settings: {
-    compressionEnabled: boolean;
-    compressionThreshold: number;
-    heartbeatInterval: number;
-    heartbeatTimeout: number;
-    reconnectAttempts: number;
-    reconnectDelay: number;
-  };
-  private heartbeatTimer: NodeJS.Timeout | null = null;
-  private lastPongTime: number = 0;
-
-  constructor() {
-    // Default settings, will be updated from settingsManager
-    this.settings = {
-      compressionEnabled: true,
-      compressionThreshold: 1024,
-      heartbeatInterval: 30000, // 30 seconds - match server's HEARTBEAT_INTERVAL
-      heartbeatTimeout: 60000,  // 60 seconds - match server's CLIENT_TIMEOUT
-      reconnectAttempts: 3,
-      reconnectDelay: 5000
-    };
+enum ConnectionState {
+    DISCONNECTED = 'disconnected',
+    CONNECTING = 'connecting',
+    CONNECTED = 'connected',
+    RECONNECTING = 'reconnecting',
+    FAILED = 'failed'
+}
 
-    // Get debug settings from settings manager
-    const settings = settingsManager.getCurrentSettings();
-    const debugEnabled = settings.clientDebug.enabled;
-    const websocketDebug = settings.clientDebug.enableWebsocketDebug;
-    
-    if (debugEnabled && websocketDebug) {
-      logger.info('WebSocket debug logging enabled');
-    }
+// Simple interface matching server's binary format
+interface NodeData {
+    position: [number, number, number];
+    velocity: [number, number, number];
+}
 
-    // Update WebSocket settings from server settings
-    if (settings.websocket) {
-      this.settings = {
-        ...this.settings,
-        compressionEnabled: settings.websocket.compressionEnabled,
-        compressionThreshold: settings.websocket.compressionThreshold,
-        heartbeatInterval: settings.websocket.heartbeatInterval * 1000, // Convert to ms
-        heartbeatTimeout: settings.websocket.heartbeatTimeout * 1000,   // Convert to ms
-        reconnectAttempts: settings.websocket.reconnectAttempts,
-        reconnectDelay: settings.websocket.reconnectDelay
-      };
-    }
+interface NodeUpdate {
+    id: string;
+    position: {
+        x: number;
+        y: number;
+        z: number;
+    };
+}
 
-    this.connect();
-  }
+type BinaryMessageCallback = (nodes: NodeData[]) => void;
 
-  private startHeartbeat(): void {
-    if (this.heartbeatTimer) {
-      clearInterval(this.heartbeatTimer);
-      this.heartbeatTimer = null;
+export class WebSocketService {
+    private static instance: WebSocketService | null = null;
+    private ws: WebSocket | null = null;
+    private binaryMessageCallback: BinaryMessageCallback | null = null;
+    private reconnectTimeout: number | null = null;
+    private connectionMonitorHandle: number | null = null;
+    private connectionState: ConnectionState = ConnectionState.DISCONNECTED;
+    private reconnectAttempts: number = 0;
+    private lastPongTime: number = 0;
+    private readonly maxReconnectAttempts: number = 5;
+    private readonly initialReconnectDelay: number = 5000; // 5 seconds
+    private readonly maxReconnectDelay: number = 60000; // 60 seconds
+    private readonly heartbeatTimeout: number = WS_HEARTBEAT_TIMEOUT;
+
+    private constructor() {
+        this.setupWebSocket();
     }
 
-    // Reset last pong time when starting heartbeat
-    this.lastPongTime = Date.now();
-
-    this.heartbeatTimer = setInterval(() => {
-      if (this.isConnected) {
-        // Check if we haven't received a pong in too long
-        const timeSinceLastPong = Date.now() - this.lastPongTime;
-        if (timeSinceLastPong > this.settings.heartbeatTimeout) {
-          logger.warn('WebSocket heartbeat timeout', {
-            timeSinceLastPong,
-            heartbeatTimeout: this.settings.heartbeatTimeout
-          });
-          this.handleConnectionFailure(new WebSocketError(
-            CoreWebSocketErrorType.TIMEOUT,
-            new Error('Heartbeat timeout'),
-            1001,
-            { timeSinceLastPong }
-          ));
-          return;
-        }
-
-        // Send ping with timestamp
-        const pingMessage = {
-          type: 'ping',
-          timestamp: Date.now()
-        };
+    private getReconnectDelay(): number {
+        // Exponential backoff with max delay
+        const delay = Math.min(
+            this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts),
+            this.maxReconnectDelay
+        );
+        // Add some jitter
+        return delay + (Math.random() * 1000);
+    }
 
-        try {
-          this.send(JSON.stringify(pingMessage));
-          logger.debug('Sent ping', { timestamp: pingMessage.timestamp });
-        } catch (error) {
-          logger.error('Failed to send ping:', error);
-        }
-      }
-    }, this.settings.heartbeatInterval);
-
-    logger.debug('Started heartbeat timer', {
-      interval: this.settings.heartbeatInterval,
-      timeout: this.settings.heartbeatTimeout
-    });
-  }
-
-  private connect(): void {
-    try {
-      // Get WebSocket URL from settings
-      const wsUrl = settingsManager.getCurrentSettings().websocket?.url || '/wss';
-      const url = new URL(wsUrl, window.location.href);
-      url.protocol = url.protocol.replace('http', 'ws');
-      const fullUrl = url.toString();
-
-      logger.info('Connecting to WebSocket:', { url: fullUrl });
-
-      // Create WebSocket connection
-      logger.info('Creating WebSocket connection to:', { url: fullUrl });
-      this.ws = new WebSocket(fullUrl);
-      this.isConnected = false;
-      this.isConnecting = true;
-
-      // Log initial state
-      if (this.ws) {
-        logger.debug('WebSocket initial state:', {
-          readyState: this.ws.readyState,
-          connecting: this.ws.readyState === WebSocket.CONNECTING,
-          protocol: this.ws.protocol,
-          extensions: this.ws.extensions,
-          timestamp: new Date().toISOString(),
-          binaryType: this.ws.binaryType,
-          bufferedAmount: this.ws.bufferedAmount
-        });
-      }
-
-      // Setup event handlers
-      this.ws.onopen = () => {
-        logger.info('WebSocket connected:', {
-          url: fullUrl,
-          protocol: this.ws?.protocol,
-          extensions: this.ws?.extensions,
-          binaryType: this.ws?.binaryType
-        });
-        this.isConnected = true;
-        this.isConnecting = false;
-        this.reconnectAttempts = 0;
-        
-        // Request initial data immediately after connection
-        try {
-          const initialRequest = {
-            type: 'requestInitialData'
-          };
-          this.send(JSON.stringify(initialRequest));
-          logger.info('Sent initial data request', { type: initialRequest.type });
-
-          // Enable binary updates
-          const enableBinary = {
-            type: 'enableBinaryUpdates',
-            data: { enabled: true }
-          };
-          this.send(JSON.stringify(enableBinary));
-          logger.info('Enabled binary updates', { type: enableBinary.type, enabled: true });
-        } catch (error) {
-          logger.error('Failed to send initialization messages:', error);
+    private startConnectionMonitor(): void {
+        // Clear any existing monitor
+        if (this.connectionMonitorHandle !== null) {
+            window.clearInterval(this.connectionMonitorHandle);
         }
 
-        this.startHeartbeat();
-        this.notifyConnectionHandlers();
+        // Monitor connection health every heartbeat interval
+        this.connectionMonitorHandle = window.setInterval(() => {
+            if (this.connectionState !== ConnectionState.CONNECTED || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
+                this.stopConnectionMonitor();
+                return;
+            }
 
-        // Log connection details
-        if (this.ws) {
-          logger.debug('Connection established:', {
-            readyState: this.ws.readyState,
-            protocol: this.ws.protocol,
-            extensions: this.ws.extensions,
-            timestamp: new Date().toISOString()
-          });
-        }
-      };
+            const timeSinceLastPong = Date.now() - this.lastPongTime;
+            if (timeSinceLastPong > this.heartbeatTimeout) {
+                logger.warn('WebSocket heartbeat timeout, closing connection');
+                this.ws.close();
+                this.stopConnectionMonitor();
+            }
+        }, WS_HEARTBEAT_INTERVAL);
+    }
 
-      this.ws.onclose = (event) => {
-        const wasConnected = this.isConnected;
-        this.isConnected = false;
-        this.isConnecting = false;
-        
-        if (this.heartbeatTimer) {
-          clearInterval(this.heartbeatTimer);
-          this.heartbeatTimer = null;
+    private stopConnectionMonitor(): void {
+        if (this.connectionMonitorHandle !== null) {
+            window.clearInterval(this.connectionMonitorHandle);
+            this.connectionMonitorHandle = null;
         }
+    }
 
-        // Log close details
-        logger.debug('WebSocket closed:', {
-          code: event.code,
-          reason: event.reason,
-          wasClean: event.wasClean,
-          wasConnected,
-          attempts: this.reconnectAttempts,
-          timestamp: new Date().toISOString()
-        });
-
-        // Only attempt reconnect if we were previously connected
-        // or if we're still within our reconnect attempts
-        if (wasConnected || this.reconnectAttempts < this.settings.reconnectAttempts) {
-          logger.warn('WebSocket closed, attempting reconnect', {
-            code: event.code,
-            reason: event.reason,
-            wasClean: event.wasClean,
-            attempt: this.reconnectAttempts + 1,
-            maxAttempts: this.settings.reconnectAttempts
-          });
-          
-          setTimeout(() => {
-            if (!this.isConnected && !this.isConnecting) {
-              this.reconnectAttempts++;
-              this.connect();
-            }
-          }, this.settings.reconnectDelay);
-        } else {
-          logger.error('WebSocket connection failed', {
-            code: event.code,
-            reason: event.reason,
-            wasClean: event.wasClean,
-            attempts: this.reconnectAttempts
-          });
-          
-          this.handleConnectionFailure(new WebSocketError(
-            CoreWebSocketErrorType.CONNECTION_LOST,
-            new Error(event.reason || 'Connection closed'),
-            event.code
-          ));
-        }
-      };
-
-      this.ws.onerror = (event) => {
-        logger.error('WebSocket error:', {
-          event,
-          readyState: this.ws?.readyState,
-          timestamp: new Date().toISOString()
-        });
-        // Don't handle error here, let onclose handle it
-        // This prevents duplicate error handling
-      };
-
-      this.ws.onmessage = (event) => {
-        const settings = settingsManager.getCurrentSettings();
-        const debugEnabled = settings.clientDebug.enabled;
-        const websocketDebug = settings.clientDebug.enableWebsocketDebug;
-
-        if (debugEnabled && websocketDebug) {
-          logger.debug('Received message:', {
-            type: typeof event.data,
-            isBinary: event.data instanceof ArrayBuffer,
-            size: event.data.length,
-            readyState: this.ws?.readyState,
-            timestamp: new Date().toISOString()
-          });
+    private setupWebSocket(): void {
+        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
+            logger.warn('Maximum reconnection attempts reached, WebSocket disabled');
+            this.connectionState = ConnectionState.FAILED;
+            return;
         }
 
         try {
-          if (typeof event.data === 'string') {
-            const message = JSON.parse(event.data);
-            this.handleJsonMessage(message);
-          } else if (event.data instanceof ArrayBuffer) {
-            this.handleBinaryMessage(event.data);
-          } else {
-            throw new Error('Unsupported message format');
-          }
+            const wsUrl = buildWsUrl();
+
+            this.connectionState = ConnectionState.CONNECTING;
+            logger.info('WebSocket connecting...');
+
+            this.ws = new WebSocket(wsUrl);
+            this.ws.binaryType = 'arraybuffer';
+
+            this.ws.onopen = (): void => {
+                logger.info('WebSocket connected');
+                this.connectionState = ConnectionState.CONNECTED;
+                this.reconnectAttempts = 0;
+                this.lastPongTime = Date.now();
+                this.startConnectionMonitor();
+
+                // Send initial protocol messages
+                this.sendMessage({ type: 'requestInitialData' });
+                this.sendMessage({ type: 'enableBinaryUpdates' });
+            };
+
+            this.ws.onmessage = async (event: MessageEvent): Promise<void> => {
+                try {
+                    // Update last pong time for any successful message
+                    this.lastPongTime = Date.now();
+
+                    if (this.connectionState !== ConnectionState.CONNECTED || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
+                        logger.warn('WebSocket not connected, ignoring message');
+                        return;
+                    }
+
+                    // Handle text messages (errors from server)
+                    if (typeof event.data === 'string') {
+                        try {
+                            const message = JSON.parse(event.data) as WebSocketError;
+                            if (message.error) {
+                                logger.error('[Server Error]', message.error);
+                                return;
+                            }
+                        } catch (e) {
+                            logger.warn('Received non-JSON text message:', event.data);
+                            return;
+                        }
+                    }
+
+                    // Handle binary position/velocity updates
+                    if (event.data instanceof ArrayBuffer && this.binaryMessageCallback) {
+                        // Validate data length (4 bytes version + 24 bytes per node)
+                        if ((event.data.byteLength - 4) % 24 !== 0) {
+                            logger.error('Invalid binary message length:', event.data.byteLength);
+                            return;
+                        }
+
+                        const dataView = new DataView(event.data);
+                        const version = dataView.getInt32(0, true); // true for little-endian
+                        if (version !== BINARY_VERSION) {
+                            logger.error('Invalid binary version:', version);
+                            return;
+                        }
+
+                        const float32Array = new Float32Array(event.data, 4); // Skip version header
+                        const nodeCount = float32Array.length / FLOATS_PER_NODE;
+                        const nodes: NodeData[] = [];
+
+                        for (let i = 0; i < nodeCount; i++) {
+                            const baseIndex = i * FLOATS_PER_NODE;
+                            
+                            // Validate float values
+                            const values = float32Array.slice(baseIndex, baseIndex + FLOATS_PER_NODE);
+                            if (!values.every(v => Number.isFinite(v))) {
+                                logger.error('Invalid float values in node data at index:', i);
+                                continue;
+                            }
+
+                            nodes.push({
+                                position: [
+                                    values[0],
+                                    values[1],
+                                    values[2]
+                                ],
+                                velocity: [
+                                    values[3],
+                                    values[4],
+                                    values[5]
+                                ]
+                            });
+                        }
+
+                        if (nodes.length > 0) {
+                            await Promise.resolve().then(() => {
+                                if (this.binaryMessageCallback) {
+                                    this.binaryMessageCallback(nodes);
+                                }
+                            });
+                        } else {
+                            logger.warn('No valid nodes in binary message');
+                        }
+                    }
+                } catch (error) {
+                    logger.error('Error processing WebSocket message:', error);
+                    if (error instanceof Error) {
+                        logger.error('Error details:', {
+                            name: error.name,
+                            message: error.message,
+                            stack: error.stack
+                        });
+                    }
+                }
+            };
+
+            this.ws.onerror = (event: Event): void => {
+                logger.error('WebSocket error:', event);
+                this.connectionState = ConnectionState.FAILED;
+            };
+
+            this.ws.onclose = (event: CloseEvent): void => {
+                const wasConnected = this.connectionState === ConnectionState.CONNECTED;
+                this.connectionState = ConnectionState.DISCONNECTED;
+                this.binaryMessageCallback = null;
+                this.stopConnectionMonitor();
+                
+                // Clear any existing reconnect timeout
+                if (this.reconnectTimeout !== null) {
+                    window.clearTimeout(this.reconnectTimeout);
+                }
+                
+                // Only attempt to reconnect if:
+                // 1. The close wasn't intentional (code !== 1000)
+                // 2. We haven't exceeded max attempts
+                // 3. We were previously connected (to avoid retry spam on initial failure)
+                if (event.code !== 1000 && 
+                    this.reconnectAttempts < this.maxReconnectAttempts &&
+                    (wasConnected || this.reconnectAttempts === 0)) {
+                    
+                    this.reconnectAttempts++;
+                    const delay = this.getReconnectDelay();
+                    
+                    logger.info(
+                        `WebSocket connection closed (${event.code}), attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms`
+                    );
+                    
+                    this.connectionState = ConnectionState.RECONNECTING;
+                    
+                    this.reconnectTimeout = window.setTimeout(() => {
+                        this.reconnectTimeout = null;
+                        this.setupWebSocket();
+                    }, delay);
+                } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
+                    logger.warn('Maximum reconnection attempts reached, WebSocket disabled');
+                    this.connectionState = ConnectionState.FAILED;
+                } else {
+                    logger.info(`WebSocket connection closed: ${event.code} ${event.reason}`);
+                }
+            };
         } catch (error) {
-          logger.error('Error handling message:', error);
-          this.notifyErrorHandlers(new WebSocketError(
-            CoreWebSocketErrorType.MESSAGE_PARSE_ERROR,
-            error instanceof Error ? error : new Error('Failed to parse message'),
-            1007
-          ));
-        }
-      };
-
-    } catch (error) {
-      logger.error('Failed to create WebSocket:', error);
-      this.handleConnectionFailure(new WebSocketError(
-        CoreWebSocketErrorType.CONNECTION_ERROR,
-        error instanceof Error ? error : new Error('Failed to create WebSocket'),
-        1006
-      ));
-    }
-  }
-
-  private handleBinaryMessage(data: ArrayBuffer): void {
-    const settings = settingsManager.getCurrentSettings();
-    const debugEnabled = settings.clientDebug.enabled;
-    const websocketDebug = settings.clientDebug.enableWebsocketDebug;
-
-    try {
-      // First 4 bytes are the header containing version
-      const headerView = new DataView(data, 0, 4);
-      const version = headerView.getInt32(0, true); // true for little-endian
-
-      if (debugEnabled && websocketDebug) {
-        logger.debug('Handling binary message:', {
-          size: data.byteLength,
-          version,
-          readyState: this.ws?.readyState,
-          timestamp: new Date().toISOString(),
-          floatCount: (data.byteLength - 4) / 4, // Each float is 4 bytes
-          expectedFloats: Math.floor((data.byteLength - 4) / 24) * 6 // 6 floats per node
-        });
-      }
-
-      // Log the first few floats for debugging
-      if (debugEnabled && websocketDebug && settings.clientDebug.logBinaryHeaders) {
-        const floatArray = new Float32Array(data, 4); // Skip 4-byte header
-        logger.debug('Binary data preview:', {
-          firstNode: {
-            position: {
-              x: floatArray[0],
-              y: floatArray[1],
-              z: floatArray[2]
-            },
-            velocity: {
-              x: floatArray[3],
-              y: floatArray[4],
-              z: floatArray[5]
-            }
-          }
-        });
-      }
-
-      // Process binary data
-      const floatArray = new Float32Array(data, 4); // Skip 4-byte version header
-      const nodeCount = Math.floor(floatArray.length / 6); // 6 floats per node (pos + vel)
-      
-      // Notify handlers with binary position update
-      const handlers = this.messageHandlers.get('binaryPositionUpdate' as MessageType);
-      if (handlers) {
-        const nodes = Array(nodeCount).fill(null).map((_, i) => ({
-          data: {
-            position: {
-              x: floatArray[i * 6],
-              y: floatArray[i * 6 + 1],
-              z: floatArray[i * 6 + 2]
-            },
-            velocity: {
-              x: floatArray[i * 6 + 3],
-              y: floatArray[i * 6 + 4],
-              z: floatArray[i * 6 + 5]
+            logger.error('Failed to setup WebSocket:', error);
+            this.connectionState = ConnectionState.FAILED;
+            
+            // Attempt to reconnect if we haven't exceeded max attempts
+            if (this.reconnectAttempts < this.maxReconnectAttempts) {
+                this.reconnectAttempts++;
+                const delay = this.getReconnectDelay();
+                
+                logger.info(
+                    `WebSocket setup failed, attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms`
+                );
+                
+                this.connectionState = ConnectionState.RECONNECTING;
+                
+                this.reconnectTimeout = window.setTimeout(() => {
+                    this.reconnectTimeout = null;
+                    this.setupWebSocket();
+                }, delay);
             }
-          }
-        }));
-
-        handlers.forEach(handler => {
-          try {
-            handler({ type: 'binaryPositionUpdate', data: { nodes } });
-          } catch (error) {
-            logger.error('Error in binary message handler:', error);
-          }
-        });
-      }
-    } catch (error) {
-      logger.error('Error parsing binary message:', {
-        error,
-        size: data.byteLength,
-        readyState: this.ws?.readyState,
-        timestamp: new Date().toISOString()
-      });
-      this.notifyErrorHandlers(new WebSocketError(
-        CoreWebSocketErrorType.MESSAGE_PARSE_ERROR,
-        error instanceof Error ? error : new Error('Failed to parse binary message'),
-        1007
-      ));
-    }
-  }
-
-  private handleConnectionFailure(error: WebSocketError): void {
-    const settings = settingsManager.getCurrentSettings();
-    const debugEnabled = settings.clientDebug.enabled;
-    const websocketDebug = settings.clientDebug.enableWebsocketDebug;
-
-    if (debugEnabled && websocketDebug) {
-      logger.warn('Handling connection failure:', {
-        reconnectCount: this.reconnectAttempts,
-        maxAttempts: this.settings.reconnectAttempts,
-        error: error.message,
-        readyState: this.ws?.readyState,
-        timestamp: new Date().toISOString()
-      });
+        }
     }
 
-    this.notifyErrorHandlers(error);
-  }
-
-  private handleJsonMessage(message: any): void {
-    const settings = settingsManager.getCurrentSettings();
-    const debugEnabled = settings.clientDebug.enabled;
-    const websocketDebug = settings.clientDebug.enableWebsocketDebug;
+    public static getInstance(): WebSocketService {
+        if (!WebSocketService.instance) {
+            WebSocketService.instance = new WebSocketService();
+        }
+        return WebSocketService.instance;
+    }
 
-    if (debugEnabled && websocketDebug) {
-      logger.debug('Handling JSON message:', {
-        type: message?.type,
-        readyState: this.ws?.readyState,
-        timestamp: new Date().toISOString()
-      });
+    public onBinaryMessage(callback: BinaryMessageCallback): void {
+        this.binaryMessageCallback = callback;
     }
 
-    if (!message || !message.type) {
-      if (debugEnabled && websocketDebug) {
-        logger.warn('Invalid message format:', message);
-      }
-      this.notifyErrorHandlers(new WebSocketError(
-        CoreWebSocketErrorType.INVALID_MESSAGE,
-        new Error('Invalid message format: missing type'),
-        1003
-      ));
-      return;
+    public getConnectionStatus(): ConnectionState {
+        return this.connectionState;
     }
 
-    // Convert snake_case to camelCase if needed
-    const processedMessage = typeof message === 'object' ? 
-      Object.keys(message).reduce((acc: any, key: string) => {
-        acc[key.replace(/_([a-z])/g, g => g[1].toUpperCase())] = message[key];
-        return acc;
-      }, {}) : message;
-
-    // Handle pong messages for heartbeat
-    if (processedMessage.type === 'pong') {
-      this.lastPongTime = Date.now();
-      const latency = this.lastPongTime - processedMessage.timestamp;
-      if (debugEnabled && websocketDebug) {
-        logger.debug('Received pong:', {
-          timestamp: processedMessage.timestamp,
-          latency,
-          lastPongTime: this.lastPongTime
-        });
-      }
-      return;
+    private sendMessage(message: any): void {
+        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
+            try {
+                this.ws.send(JSON.stringify(message));
+            } catch (error) {
+                logger.error('Error sending message:', error);
+            }
+        }
     }
 
-    // Notify message handlers
-    const handlers = this.messageHandlers.get(processedMessage.type as MessageType);
-    if (handlers) {
-      handlers.forEach(handler => {
+    public sendNodeUpdates(updates: NodeUpdate[]): void {
+        if (this.connectionState !== ConnectionState.CONNECTED || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
+            logger.warn('WebSocket not connected, cannot send node updates');
+            return;
+        }
+
         try {
-          handler(processedMessage);
+            // Validate updates
+            if (!Array.isArray(updates) || updates.length === 0) {
+                logger.warn('Invalid node updates: empty or not an array');
+                return;
+            }
+
+            // Validate each update
+            const validUpdates = updates.filter(update => {
+                if (!update.position || typeof update.position !== 'object') {
+                    logger.warn('Invalid node update: missing or invalid position', update);
+                    return false;
+                }
+
+                const { x, y, z } = update.position;
+                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
+                    logger.warn('Invalid node update: non-finite position values', update);
+                    return false;
+                }
+
+                return true;
+            });
+
+            if (validUpdates.length === 0) {
+                logger.warn('No valid updates to send');
+                return;
+            }
+
+            // Create binary message with version header
+            const float32Array = new Float32Array(1 + validUpdates.length * 3); // Version + positions
+            float32Array[0] = BINARY_VERSION;
+            
+            validUpdates.forEach((update, index) => {
+                const baseIndex = 1 + index * 3; // Skip version header
+                float32Array[baseIndex] = update.position.x;
+                float32Array[baseIndex + 1] = update.position.y;
+                float32Array[baseIndex + 2] = update.position.z;
+            });
+
+            this.ws.send(float32Array.buffer);
+            logger.debug(`Sent ${validUpdates.length} node updates`);
         } catch (error) {
-          logger.error('Error in message handler:', error);
-          this.notifyErrorHandlers(new WebSocketError(
-            CoreWebSocketErrorType.MESSAGE_PARSE_ERROR,
-            error instanceof Error ? error : new Error('Error in message handler'),
-            1011
-          ));
-        }
-      });
-    }
-  }
-
-  private notifyErrorHandlers(error: CoreWebSocketError): void {
-    this.errorHandlers.forEach(handler => {
-      try {
-        handler(error);
-      } catch (handlerError) {
-        logger.error('Error in error handler:', handlerError);
-      }
-    });
-  }
-
-  private notifyConnectionHandlers(): void {
-    this.connectionHandlers.forEach(handler => {
-      try {
-        handler(WebSocketStatus.CONNECTED);
-      } catch (error) {
-        logger.error('Error in connection handler:', error);
-      }
-    });
-  }
-
-  public send(data: string): void {
-    const settings = settingsManager.getCurrentSettings();
-    const debugEnabled = settings.clientDebug.enabled;
-    const websocketDebug = settings.clientDebug.enableWebsocketDebug;
-
-    if (!this.isConnected) {
-      if (this.messageQueue.length < WS_MESSAGE_QUEUE_SIZE) {
-        if (debugEnabled && websocketDebug) {
-          logger.debug('Queuing message:', {
-            queueLength: this.messageQueue.length,
-            readyState: this.ws?.readyState,
-            timestamp: new Date().toISOString()
-          });
+            logger.error('Error sending node updates:', error);
+            if (error instanceof Error) {
+                logger.error('Error details:', {
+                    name: error.name,
+                    message: error.message,
+                    stack: error.stack
+                });
+            }
         }
-        this.messageQueue.push(data);
-      } else {
-        logger.warn('Message queue full, dropping message');
-      }
-      return;
     }
 
-    try {
-      if (debugEnabled && websocketDebug) {
-        logger.debug('Sending message:', {
-          size: data.length,
-          readyState: this.ws?.readyState,
-          timestamp: new Date().toISOString()
-        });
-      }
-      this.ws?.send(data);
-    } catch (error) {
-      logger.error('Error sending message:', error);
-      this.notifyErrorHandlers(new WebSocketError(
-        CoreWebSocketErrorType.SEND_FAILED,
-        error instanceof Error ? error : new Error('Failed to send message'),
-        1011
-      ));
-      this.handleConnectionFailure(new WebSocketError(
-        CoreWebSocketErrorType.CONNECTION_LOST,
-        error instanceof Error ? error : new Error('Connection lost after send failure'),
-        1006
-      ));
-    }
-  }
-
-  // Alias for backward compatibility
-  public on = this.onMessage;
-
-  public onMessage(type: MessageType, handler: MessageHandler): void {
-    const handlers = this.messageHandlers.get(type) || [];
-    handlers.push(handler);
-    this.messageHandlers.set(type, handlers);
-  }
-
-  public onError(handler: ErrorHandler): void {
-    this.errorHandlers.push(handler);
-  }
-
-  public onConnectionChange(handler: ConnectionHandler): void {
-    this.connectionHandlers.push(handler);
-    handler(
-      this.isConnected ? WebSocketStatus.CONNECTED : WebSocketStatus.DISCONNECTED,
-      undefined
-    );
-  }
-
-  // Alias for backward compatibility
-  public dispose = this.disconnect;
-
-  public disconnect(): void {
-    if (this.ws) {
-      this.ws.close();
-    }
-    if (this.heartbeatTimer) {
-      clearInterval(this.heartbeatTimer);
-    }
-    if (this.reconnectTimeout) {
-      clearTimeout(this.reconnectTimeout);
+    public dispose(): void {
+        if (this.reconnectTimeout !== null) {
+            window.clearTimeout(this.reconnectTimeout);
+            this.reconnectTimeout = null;
+        }
+        
+        this.stopConnectionMonitor();
+        
+        if (this.ws) {
+            this.ws.close();
+            this.ws = null;
+        }
+        
+        this.binaryMessageCallback = null;
+        this.connectionState = ConnectionState.DISCONNECTED;
+        WebSocketService.instance = null;
     }
-  }
 }
diff --git a/client/xr/xrInteraction.ts b/client/xr/xrInteraction.ts
index ba325d0f..e9e5aa15 100644
--- a/client/xr/xrInteraction.ts
+++ b/client/xr/xrInteraction.ts
@@ -1,8 +1,25 @@
 import * as THREE from 'three';
-import { XRHandWithHaptics } from './xrTypes';
 import { NodeManager } from '../rendering/nodes';
 import { XRSessionManager } from './xrSessionManager';
-import { Settings } from '../core/types';
+import { Platform, Node } from '../core/types';
+import { Settings } from '../types/settings';
+import { XRHandWithHaptics } from '../types/xr';
+import { platformManager } from '../platform/platformManager';
+import { createLogger } from '../core/logger';
+import { SettingsStore } from '../state/SettingsStore';
+import { defaultSettings } from '../state/defaultSettings';
+import { HandGestureType } from '../types/gestures';
+import { WebSocketService } from '../websocket/websocketService';
+
+const logger = createLogger('XRInteraction');
+
+interface HapticActuator {
+    pulse: (intensity: number, duration: number) => Promise<boolean>;
+}
+
+interface WorldObject3D extends THREE.Object3D {
+    getWorldPosition(target: THREE.Vector3): THREE.Vector3;
+}
 
 export class XRInteraction {
     private static instance: XRInteraction | null = null;
@@ -12,196 +29,95 @@ export class XRInteraction {
     private lastInteractorPosition = new THREE.Vector3();
     private hands: XRHandWithHaptics[] = [];
     private settings: Settings;
+    private settingsStore: SettingsStore;
+    private selectedNodeId: string | null = null;
+    private worldPosition = new THREE.Vector3();
+    private websocketService: WebSocketService;
+    private handGestureStates: Map<number, HandGestureType> = new Map();
+    private updateBatch: Map<string, THREE.Vector3> = new Map();
+    private batchUpdateTimeout: NodeJS.Timeout | null = null;
+    private settingsUnsubscribers: Array<() => void> = [];
 
     private constructor(xrManager: XRSessionManager, nodeManager: NodeManager) {
         this.xrManager = xrManager;
         this.nodeManager = nodeManager;
-        
-        this.settings = {
-            animations: { 
-                enableMotionBlur: false, 
-                enableNodeAnimations: false, 
-                motionBlurStrength: 0.4, 
-                selectionWaveEnabled: false, 
-                pulseEnabled: false, 
-                rippleEnabled: false, 
-                edgeAnimationEnabled: false, 
-                flowParticlesEnabled: false 
-            },
-            ar: {
-                dragThreshold: 0.04,
-                enableHandTracking: true,
-                enableHaptics: true,
-                enableLightEstimation: true,
-                enablePassthroughPortal: false,
-                enablePlaneDetection: true,
-                enableSceneUnderstanding: true,
-                gestureSsmoothing: 0.9,
-                handMeshColor: '#FFD700',
-                handMeshEnabled: true,
-                handMeshOpacity: 0.3,
-                handPointSize: 0.01,
-                handRayColor: '#FFD700',
-                handRayEnabled: true,
-                handRayWidth: 0.002,
-                hapticIntensity: 0.7,
-                passthroughBrightness: 1,
-                passthroughContrast: 1,
-                passthroughOpacity: 1,
-                pinchThreshold: 0.015,
-                planeColor: '#4A90E2',
-                planeOpacity: 0.3,
-                portalEdgeColor: '#FFD700',
-                portalEdgeWidth: 0.02,
-                portalSize: 1,
-                roomScale: true,
-                rotationThreshold: 0.08,
-                showPlaneOverlay: true,
-                snapToFloor: true
-            },
-            audio: { 
-                enableAmbientSounds: false, 
-                enableInteractionSounds: false, 
-                enableSpatialAudio: false 
-            },
-            bloom: { 
-                edgeBloomStrength: 0.3, 
-                enabled: false, 
-                environmentBloomStrength: 0.5, 
-                nodeBloomStrength: 0.2, 
-                radius: 0.5, 
-                strength: 1.8 
-            },
-            clientDebug: { 
-                enableDataDebug: false, 
-                enableWebsocketDebug: false, 
-                enabled: false, 
-                logBinaryHeaders: false, 
-                logFullJson: false 
-            },
-            edges: {
-                arrowSize: 0.15, 
-                baseWidth: 2, 
-                color: '#917f18', 
-                enableArrows: false, 
-                opacity: 1, 
-                widthRange: [1, 4] 
-            },
-            labels: {
-                desktopFontSize: 12, 
-                enableLabels: true, 
-                textColor: '#FFFFFF' 
-            },
-            network: {
-                bindAddress: '0.0.0.0',
-                domain: 'localhost',
-                enableHttp2: false,
-                enableRateLimiting: true,
-                enableTls: false,
-                maxRequestSize: 10485760,
-                minTlsVersion: '',
-                port: 3001,
-                rateLimitRequests: 100,
-                rateLimitWindow: 60,
-                tunnelId: 'dummy'
-            },
-            nodes: { 
-                baseColor: '#4A90E2', 
-                baseSize: 1, 
-                clearcoat: 0.5, 
-                enableHoverEffect: true, 
-                enableInstancing: true, 
-                highlightColor: '#FFD700', 
-                highlightDuration: 500, 
-                hoverScale: 1.2, 
-                materialType: 'standard', 
-                metalness: 0.5, 
-                opacity: 1, 
-                roughness: 0.5, 
-                sizeByConnections: false, 
-                sizeRange: [0.5, 2] 
-            },
-            physics: { 
-                attractionStrength: 0.1, 
-                boundsSize: 100, 
-                collisionRadius: 1, 
-                damping: 0.5, 
-                enableBounds: true, 
-                enabled: true, 
-                iterations: 1, 
-                maxVelocity: 10, 
-                repulsionStrength: 0.2, 
-                springStrength: 0.1 
-            },
-            rendering: { 
-                ambientLightIntensity: 0.5, 
-                backgroundColor: '#000000', 
-                directionalLightIntensity: 1, 
-                enableAmbientOcclusion: true, 
-                enableAntialiasing: true, 
-                enableShadows: true, 
-                environmentIntensity: 1 
-            },
-            websocket: {
-                binaryChunkSize: 65536,
-                compressionEnabled: true,
-                compressionThreshold: 1024,
-                heartbeatInterval: 15000,
-                heartbeatTimeout: 60000,
-                maxConnections: 1000,
-                maxMessageSize: 100485760,
-                reconnectAttempts: 3,
-                reconnectDelay: 5000,
-                updateRate: 90,
-                url: '/wss'  // Default WebSocket endpoint
-            },
-            default: {
-                apiClientTimeout: 30,
-                enableMetrics: true,
-                enableRequestLogging: true,
-                logFormat: "json",
-                logLevel: "debug",
-                maxConcurrentRequests: 5,
-                maxPayloadSize: 5242880,
-                maxRetries: 3,
-                metricsPort: 9090,
-                retryDelay: 5
-            },
-            security: {
-                allowedOrigins: [],
-                auditLogPath: "/app/logs/audit.log",
-                cookieHttponly: true,
-                cookieSamesite: "Strict",
-                cookieSecure: true,
-                csrfTokenTimeout: 3600,
-                enableAuditLogging: true,
-                enableRequestValidation: true,
-                sessionTimeout: 3600
-            },
-            serverDebug: {
-                enableDataDebug: false,
-                enableWebsocketDebug: false,
-                enabled: true,
-                logBinaryHeaders: false,
-                logFullJson: false
-            }
-        };
+        this.settingsStore = SettingsStore.getInstance();
+        this.settings = defaultSettings;
+        this.websocketService = WebSocketService.getInstance();
         
         this.setupXRControllers();
         this.setupHandTracking();
+        this.setupPlatformListeners();
+        this.setupSettingsSubscription();
     }
 
-    public static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
-        if (!XRInteraction.instance) {
-            XRInteraction.instance = new XRInteraction(xrManager, nodeManager);
+    private setupPlatformListeners(): void {
+        platformManager.on('platformChange', (platform: Platform) => {
+            logger.info(`Platform changed to ${platform}`);
+            this.updateXRFeatures();
+        });
+    }
+
+    private updateXRFeatures(): void {
+        const platform = platformManager.getPlatform();
+        const capabilities = platformManager.getCapabilities();
+
+        // Update hand tracking based on platform capabilities
+        if (capabilities.handTracking) {
+            this.setupHandTracking();
+        } else {
+            this.disableHandTracking();
         }
-        return XRInteraction.instance;
+
+        // Update haptics based on platform capabilities
+        this.controllers.forEach(controller => {
+            if (controller.userData) {
+                controller.userData.platform = platform;
+            }
+        });
+
+        this.hands.forEach(hand => {
+            if (hand.userData) {
+                hand.userData.platform = platform;
+            }
+        });
+    }
+
+    private disableHandTracking(): void {
+        this.hands.forEach(hand => {
+            if (hand.parent) {
+                hand.parent.remove(hand);
+            }
+        });
+        this.hands = [];
+    }
+
+    private setupSettingsSubscription(): void {
+        // Clear any existing subscriptions
+        this.settingsUnsubscribers.forEach(unsub => unsub());
+        this.settingsUnsubscribers = [];
+
+        // Subscribe to XR input settings
+        [
+            'hapticIntensity',
+            'dragThreshold',
+            'pinchThreshold',
+            'rotationThreshold',
+            'interactionRadius'
+        ].forEach(setting => {
+            const unsubscribe = this.settingsStore.subscribe(`xr.input.${setting}`, () => {
+                // Handle setting change
+                this.updateXRFeatures();
+            });
+            this.settingsUnsubscribers.push(unsubscribe);
+        });
     }
 
     private setupXRControllers(): void {
         this.xrManager.onControllerAdded((controller: THREE.Group) => {
+            controller.userData.platform = platformManager.getPlatform();
             this.controllers.push(controller);
-            if (controller.userData.hapticActuator) {
+            if (controller.userData.hapticActuator && this.settings.xr.input.enableHaptics) {
                 this.triggerHapticFeedback(controller, 0.5, 50);
             }
         });
@@ -215,25 +131,85 @@ export class XRInteraction {
     }
 
     private setupHandTracking(): void {
-        if (!this.settings.ar.enableHandTracking) return;
+        if (!platformManager.getCapabilities().handTracking) {
+            logger.info('Hand tracking not supported on this platform');
+            return;
+        }
+        // Hand tracking is now handled internally
+        // No need to register with XRSessionManager
+    }
 
-        // Hand tracking is handled by the XRSessionManager directly
-        this.hands = [];
+    private flushPositionUpdates(): void {
+        if (this.updateBatch.size === 0) return;
+
+        const updates = Array.from(this.updateBatch.entries()).map(([id, position]) => ({
+            id,
+            position: { x: position.x, y: position.y, z: position.z }
+        }));
+
+        // Update each node position individually
+        updates.forEach(update => {
+            const newPosition = new THREE.Vector3(update.position.x, update.position.y, update.position.z);
+            this.nodeManager.updateNodePosition(update.id, newPosition);
+        });
+
+        this.websocketService.sendNodeUpdates(updates);
+        this.updateBatch.clear();
+    }
+
+    private queuePositionUpdate(nodeId: string, position: THREE.Vector3): void {
+        this.updateBatch.set(nodeId, position.clone());
+        
+        if (this.batchUpdateTimeout) {
+            clearTimeout(this.batchUpdateTimeout);
+        }
+
+        this.batchUpdateTimeout = setTimeout(() => {
+            this.flushPositionUpdates();
+            this.batchUpdateTimeout = null;
+        }, 16); // ~60fps
+    }
+
+    private async triggerHapticFeedback(controller: THREE.Group, intensity: number, duration: number): Promise<void> {
+        if (!this.settings.xr.input.enableHaptics) return;
+
+        const hapticActuator = controller.userData.hapticActuator as HapticActuator;
+        if (hapticActuator) {
+            try {
+                await hapticActuator.pulse(
+                    intensity * this.settings.xr.input.hapticIntensity,
+                    duration
+                );
+            } catch (error) {
+                logger.warn('Failed to trigger haptic feedback:', error);
+            }
+        }
+    }
+
+    public static getInstance(xrManager: XRSessionManager, nodeManager: NodeManager): XRInteraction {
+        if (!XRInteraction.instance) {
+            XRInteraction.instance = new XRInteraction(xrManager, nodeManager);
+        }
+        return XRInteraction.instance;
     }
 
     public update(): void {
-        if (!this.settings.ar.enableHandTracking) return;
+        if (!this.settings.xr.input.enableHandTracking && !this.controllers.length) {
+            return;
+        }
 
         // Update hand interactions
         this.hands.forEach(hand => {
-            if (hand.pinchStrength > this.settings.ar.pinchThreshold) {
+            if (hand.pinchStrength > this.settings.xr.input.pinchThreshold) {
                 this.handlePinchGesture(hand);
             }
         });
 
         // Update controller interactions
         this.controllers.forEach(controller => {
-            this.handleControllerInteraction(controller);
+            if (controller.userData.isSelecting) {
+                this.handleControllerInteraction(controller);
+            }
         });
     }
 
@@ -241,70 +217,94 @@ export class XRInteraction {
         const indexTip = hand.hand.joints['index-finger-tip'];
         if (!indexTip) return;
 
-        const position = new THREE.Vector3();
-        position.setFromMatrixPosition(indexTip.matrixWorld);
+        try {
+            (indexTip as WorldObject3D).getWorldPosition(this.worldPosition);
 
-        // Calculate movement delta
-        const delta = position.clone().sub(this.lastInteractorPosition);
-        
-        // Update node position based on hand movement
-        if (delta.length() > this.settings.ar.dragThreshold) {
-            // Get all nodes and update their positions
-            const nodes = this.nodeManager.getAllNodeMeshes();
-            nodes.forEach(nodeMesh => {
-                const currentPos = this.nodeManager.getNodePosition(nodeMesh.userData.nodeId);
-                const newPos = currentPos.add(delta);
-                this.nodeManager.updateNodePosition(nodeMesh.userData.nodeId, newPos);
-            });
+            if (this.lastInteractorPosition.distanceTo(this.worldPosition) > this.settings.xr.input.dragThreshold) {
+                if (!this.selectedNodeId) {
+                    this.selectedNodeId = this.findClosestNode(this.worldPosition);
+                }
 
-            if (this.settings.ar.enableHaptics) {
-                this.triggerHapticFeedback(hand, this.settings.ar.hapticIntensity, 50);
+                if (this.selectedNodeId) {
+                    this.queuePositionUpdate(this.selectedNodeId, this.worldPosition);
+                    this.lastInteractorPosition.copy(this.worldPosition);
+
+                    if (hand.userData.hapticActuator && this.settings.xr.input.enableHaptics) {
+                        this.triggerHapticFeedback(hand, 0.3, 30);
+                    }
+                }
             }
+        } catch (error) {
+            logger.error('Error handling pinch gesture:', error);
         }
-
-        this.lastInteractorPosition.copy(position);
     }
 
     private handleControllerInteraction(controller: THREE.Group): void {
-        const position = new THREE.Vector3();
-        position.setFromMatrixPosition(controller.matrixWorld);
+        try {
+            (controller as WorldObject3D).getWorldPosition(this.worldPosition);
 
-        // Calculate movement delta
-        const delta = position.clone().sub(this.lastInteractorPosition);
-        
-        // Update node position based on controller movement
-        if (delta.length() > this.settings.ar.dragThreshold) {
-            // Get all nodes and update their positions
-            const nodes = this.nodeManager.getAllNodeMeshes();
-            nodes.forEach(nodeMesh => {
-                const currentPos = this.nodeManager.getNodePosition(nodeMesh.userData.nodeId);
-                const newPos = currentPos.add(delta);
-                this.nodeManager.updateNodePosition(nodeMesh.userData.nodeId, newPos);
-            });
+            if (this.lastInteractorPosition.distanceTo(this.worldPosition) > this.settings.xr.input.dragThreshold) {
+                if (!this.selectedNodeId) {
+                    this.selectedNodeId = this.findClosestNode(this.worldPosition);
+                }
 
-            if (this.settings.ar.enableHaptics && controller.userData.hapticActuator) {
-                this.triggerHapticFeedback(controller, this.settings.ar.hapticIntensity, 50);
+                if (this.selectedNodeId) {
+                    this.queuePositionUpdate(this.selectedNodeId, this.worldPosition);
+                    this.lastInteractorPosition.copy(this.worldPosition);
+
+                    if (controller.userData.hapticActuator && this.settings.xr.input.enableHaptics) {
+                        this.triggerHapticFeedback(controller, 0.3, 30);
+                    }
+                }
             }
+        } catch (error) {
+            logger.error('Error handling controller interaction:', error);
         }
-
-        this.lastInteractorPosition.copy(position);
     }
 
-    private triggerHapticFeedback(device: THREE.Group | XRHandWithHaptics, intensity: number, duration: number): void {
-        if (!this.settings.ar.enableHaptics) return;
+    private findClosestNode(position: THREE.Vector3): string | null {
+        const nodes = this.nodeManager.getCurrentNodes() as Array<Node>;
+        let closestNode: Node | null = null;
+        let closestDistance = Infinity;
 
-        if ('hapticActuators' in device) {
-            device.hapticActuators.forEach(actuator => {
-                actuator.pulse(intensity, duration);
-            });
-        } else if (device.userData.hapticActuator) {
-            device.userData.hapticActuator.pulse(intensity, duration);
+        for (const node of nodes as Array<Node>) {
+            if (!node || !node.data || !node.data.position) continue;
+            
+            const nodePos = new THREE.Vector3(
+                node.data.position.x,
+                node.data.position.y,
+                node.data.position.z
+            );
+            const distance = position.distanceTo(nodePos);
+            if (distance < closestDistance && distance < (this.settings.xr.input.interactionRadius || 0.5)) {
+                closestDistance = distance;
+                closestNode = node;
+            }
         }
+
+        return closestNode?.id || null;
     }
 
     public dispose(): void {
+        // Clean up subscriptions
+        this.settingsUnsubscribers.forEach(unsub => unsub());
+        this.settingsUnsubscribers = [];
+
+        if (this.batchUpdateTimeout) {
+            clearTimeout(this.batchUpdateTimeout);
+            this.batchUpdateTimeout = null;
+        }
+
+        // Flush any remaining updates
+        this.flushPositionUpdates();
+
+        // Clear data structures
         this.controllers = [];
         this.hands = [];
+        this.handGestureStates.clear();
+        this.updateBatch.clear();
+        this.lastInteractorPosition.set(0, 0, 0);
+        this.selectedNodeId = null;
         XRInteraction.instance = null;
     }
 }
diff --git a/client/xr/xrTypes.ts b/client/xr/xrTypes.ts
deleted file mode 100644
index 556eb0af..00000000
--- a/client/xr/xrTypes.ts
+++ /dev/null
@@ -1,25 +0,0 @@
-import * as THREE from 'three';
-
-export interface XRHandWithHaptics {
-    hand: {
-        joints: {
-            [key: string]: THREE.Object3D;
-        };
-    };
-    hapticActuators: any[];
-    pinchStrength: number;
-    gripStrength: number;
-}
-
-export interface XRControllerState {
-    position: THREE.Vector3;
-    rotation: THREE.Quaternion;
-    hapticActuator?: any;
-}
-
-export interface XRHandState {
-    position: THREE.Vector3;
-    joints: Map<string, THREE.Object3D>;
-    pinchStrength: number;
-    gripStrength: number;
-}
diff --git a/diff.patch b/diff.patch
new file mode 100644
index 00000000..1c69717e
diff --git a/docs/network.md b/docs/network.md
index d0322552..a02f174e 100644
--- a/docs/network.md
+++ b/docs/network.md
@@ -3,11 +3,11 @@ This document outlines the networking architecture and data flow for the LogseqX
 
 1. Overall Architecture
 
-The application follows a client-server model, with the server responsible for data storage, processing, and settings management, while the client handles visualization and user interaction. Communication occurs through REST API calls for initial setup and settings management, and WebSockets for real-time position updates. The application integrates with RAGFlow as a separate service for advanced data processing.
+The application follows a client-server model, with the server responsible for data storage, processing, and settings management, while the client handles visualization and user interaction. Communication occurs through REST API calls for initial setup and settings management, and WebSockets for real-time position updates. 
 
 2. Server-Side (Rust)
 
-Data Storage: Graph data (nodes, edges, metadata) is stored on the server, potentially in a database or file system. Settings are stored in settings.toml and are updated in real-time.
+Data Storage: Graph data (nodes, edges, metadata) is stored on the server, in a file system. Settings are stored in settings.toml and are updated in real-time in groups of settings only when those settings are updated.
 
 REST API (actix-web): The server exposes a REST API for:
 
@@ -15,49 +15,45 @@ Graph Data: /api/graph/data (full graph) and /api/graph/data/paginated (paginate
 
 Settings: 
 - GET /api/visualization/settings/{category} (get all settings for a category)
+- PUT /api/visualization/settings/{category} (update all settings for a category)
 - GET /api/visualization/settings/{category}/{setting} (get individual setting)
 - PUT /api/visualization/settings/{category}/{setting} (update individual setting)
+- PUT /api/visualization/settings/websocket/update-rate (update WebSocket frame rate)
+
+Settings Management:
+- Centralized settings management through SettingsManager
+- Real-time updates with async RwLock for thread safety
+- Automatic persistence to settings.toml
+- Category-based organization (animations, ar, audio, etc.)
+- WebSocket settings controlled via dedicated endpoints
+- Settings changes trigger immediate effect across all components
 
 Other API endpoints: /api/files/fetch, /api/chat/*, /api/perplexity.
 
 WebSocket Handling (actix-web-actors): 
 - Binary Protocol (/wss endpoint): 
-  - Uses a compressed binary protocol for efficient real-time position and velocity updates
-  - Includes version checking (BINARY_VERSION) for protocol compatibility
+  - Uses a binary protocol for efficient real-time position and velocity updates
+  - Bi directional during node interaction events at the client
   - Optimized format with 6 floats per node (position + velocity)
-  - 4-byte binary header for version information
 - WebSocket Control API (/api/visualization/settings/):
   - REST-based control plane for WebSocket configuration
-  - Manages compression settings, heartbeat intervals, and protocol versions
+  - Manages settings, ping pong
   - Allows runtime updates to WebSocket behavior without connection disruption
   - Separates control logic from high-frequency data updates
 - Connection Management:
-  - Message queuing with configurable queue size
+  - Configurable update rate (framerate)
   - Robust reconnection logic with configurable attempts and delays
   - Connection status tracking and notifications
 - Heartbeat:
   - Configurable ping/pong intervals
-  - Timestamp-based health monitoring
   - Automatic reconnection on timeout
-- Compression:
-  - Configurable compression thresholds
-  - Optimized for position/velocity data
 - Error Handling:
   - Comprehensive error types and status codes
   - Detailed error reporting and logging
   - Graceful failure recovery
 
-RAGFlow Integration:
-- Network Integration: Joins the RAGFlow Docker network (docker_ragflow)
-- Service Discovery: Uses Docker network aliases for service communication
-- Optional Connectivity: Gracefully handles RAGFlow availability
-- Health Checks: Monitors RAGFlow service health without direct dependencies
-
 Security:
-- TLS Implementation: Uses rustls (>=0.23.5) for secure communication
-- Certificate Management: Handles TLS certificates through rustls-pemfile
-- WebSocket Security: Implements secure WebSocket connections with TLS
-- Network Isolation: Services run in isolated Docker networks
+- Handled by cloudflared tunnel and docker
 
 Port Configuration:
 - Nginx Frontend: Listens on port 4000 for external connections
@@ -79,11 +75,6 @@ Port Configuration:
   - Graph Endpoints (/graph):
     - 30s connect timeout matching heartbeat interval
     - No-store cache control
-  - Security Headers:
-    - Content-Security-Policy with WebSocket support
-    - Strict-Transport-Security (HSTS)
-    - X-Frame-Options, X-XSS-Protection
-    - Referrer-Policy and other security headers
 - Health Checks: 
   - Regular HTTP and WebSocket endpoint monitoring
   - 10-second interval checks with 5-second timeout
@@ -91,35 +82,34 @@ Port Configuration:
 
 3. Client-Side (TypeScript)
 
+API Configuration:
+- Centralized API URL management through buildApiUrl helper
+- Environment-aware URL handling for development and production
+- Consistent path resolution across all components
+- WebSocket URL management through buildWsUrl helper
+
 Initialization:
 - The client loads initial graph data from /api/graph/data/paginated using pagination
 - The client loads all visualization settings from /api/visualization/settings/{category}
+- All API paths are built using buildApiUrl helper for consistency
 - WebSocket initialization follows a two-step process:
   1. Control Setup (/api/visualization/settings/websocket):
      - Load WebSocket configuration settings
-     - Configure compression and heartbeat parameters
      - Set up error handling and reconnection policies
   2. Binary Connection (/wss):
-     - Establish WebSocket connection for real-time updates
+     - Establish WebSocket connection using buildWsUrl helper
      - Use binary protocol for position/velocity data
      - Handle heartbeat and connection lifecycle
 
 REST API Interaction:
 - Initial Graph Data: Retrieving the initial graph data using pagination
 - Settings: Loading category settings, getting/updating individual settings
-- RAGFlow Services: Communicating with RAGFlow when available
+- All API requests use relative paths through buildApiUrl helper
+- Environment-aware URL handling for development and production
 
-WebSocket Connection: 
-- Establishes compressed WebSocket connection for real-time updates
+WebSocket Connection and it's REST management system: 
+- Establishes WebSocket connection for real-time updates
 - Implements reconnection logic with configurable attempts (default: 3)
-- Configurable settings for:
-  - Compression threshold
-  - Heartbeat interval (default: 15s)
-  - Heartbeat timeout (default: 60s)
-  - Reconnect delay (default: 5s)
-- Message queuing with size limits
-- Binary message handling with version verification
-- Comprehensive error handling and status notifications
 
 4. Docker Networking
 
@@ -173,55 +163,120 @@ Health Check System:
 - Container Health: Docker healthcheck monitors service availability
 - Backend Health: Rust service monitors internal state and dependencies
 - Frontend Health: Nginx monitors backend connectivity
-- RAGFlow Health: Periodic checks for RAGFlow service availability
 - Metrics: Health status exposed through container metrics
 
-5. Data Flow Diagrams
-
-[Previous diagram content remains unchanged]
-
-6. Key Improvements
-
-WebSocket Enhancements:
-- Compression support for efficient data transfer
-- Robust connection management with health monitoring
-- Better error handling and recovery
-- Configurable heartbeat intervals
-- Message queuing with size limits
-- Binary protocol version verification
-
-RAGFlow Integration:
-- Clean separation of services
-- Network-level integration
-- Graceful handling of service availability
-- Clear error messaging
-
-Settings Management:
-- Real-time updates
-- Immediate persistence
-- Efficient broadcast mechanism
-- Better error handling
-
-7. Remaining Considerations
-
-Performance Optimization:
-- Fine-tune WebSocket compression thresholds
-- Optimize binary message format
-- Monitor network bandwidth usage
-- GPU resource utilization monitoring
-
-Error Handling:
-- Implement comprehensive error recovery
-- Better user feedback
-- Logging and monitoring
-- Connection failure analysis
-
-Security:
-- Network isolation
-- Access control
-- Data validation
-- Regular security audits
-- Dependency vulnerability monitoring
-- TLS configuration management
-
-This briefing document provides a comprehensive overview of the LogseqXR networking architecture, including its integration with RAGFlow and enhanced WebSocket capabilities. Regular monitoring and optimization of these systems will ensure optimal performance and reliability.
+Clear Protocol Definition:
+Exact message types (binary updates, ping/pong)
+Simplified Configuration:
+Clear separation between REST and WebSocket responsibilities
+Performance Focus:
+Direct binary transmission
+No JSON overhead
+Efficient TypedArray usage
+Clear Client Flow:
+Step-by-step initialization process
+Explicit data flow patterns
+Error handling and performance considerations
+
+[ARCH_MODEL]
+{system: distributed_graph_vis}
+|> docker[nginx:4000 <-> rust:3001]  // Cloudflared tunnel routing
+|> persistence[settings.toml <-> RwLock]  // Thread-safe config
+
+[DATA_FLOW]
+client::websocket -> /wss
+|> socket_flow_handler
+-> socket_flow_messages{BinaryNodeData}
+-> gpu_compute{CUDA/WGSL} || cpu_fallback
+<- binary_position_updates
+
+client::http -> /api/visualization/settings/*
+|> visualization_handler
+-> case_conversion{snake <-> camel}
+-> settings_manager{RwLock}
+<- type_converted_responses
+
+[CORE_PATTERNS]
+Bidirectional case normalization:
+client{camelCase} <-> server{snake_case}
+
+Thread-safe state:
+Arc for {Settings, GraphData}
+
+Type coercion:
+value.is_{type} -> conversion_strategy
+
+Error propagation:
+Result<T, Box> with context
+
+Binary optimization:
+websocket{binary_messages} for positions
+http{json} for settings
+
+[CLIENT_ARCHITECTURE]
+Settings:
+defaultSettings -> SettingsStore -> SettingsManager
+|> type_safety{SettingsPath, SettingValue}
+|> validation{isValidSettingPath}
+|> persistence{localStorage, API sync}
+
+API:
+constants{API_PATHS} -> buildApiUrl
+|> environment{IS_PRODUCTION}
+|> retry_logic{maxRetries, retryDelay}
+
+Logging:
+Logger -> settings.debug
+|> context{namespace}
+|> formatting{JSON, pretty-print}
+|> levels{debug, info, warn, error}
+
+[SERVER_ARCHITECTURE]
+Handlers:
+visualization_handler -> settings{RwLock}
+|> routes{GET, PUT}
+|> case_conversion
+|> validation
+|> persistence
+
+State:
+Settings -> RwLock
+|> thread_safety
+|> concurrent_access
+|> atomic_updates
+
+File System:
+settings.toml -> TOML serialization
+|> permissions
+|> validation
+|> error_handling
+
+[NETWORK_TOPOLOGY]
+client -> cloudflared[tunnel_id]
+-> nginx:4000{
+/api/* -> rust:3001
+/wss -> rust:3001{binary_protocol}
+/* -> static_files
+}
+
+[STATE_MANAGEMENT]
+Settings:
+toml -> struct -> RwLock -> handlers
+|> validation
+|> conversion
+|> persistence
+
+Websocket:
+connection -> binary protocol -> position updates
+|> compression
+|> chunking
+|> error_handling
+
+[OPTIMIZATION_STRATEGIES]
+GPU acceleration with fallback
+Binary websocket protocol
+Connection pooling
+Static file caching
+Type-specific serialization
+
+This architecture enables real-time 3D graph visualization with efficient state management, data flow optimization, and robust error handling across all system components.
\ No newline at end of file
diff --git a/package.json b/package.json
index 1d57ab46..2b8e369c 100755
--- a/package.json
+++ b/package.json
@@ -16,14 +16,16 @@
     "@react-three/drei": "^9.120.4",
     "@react-three/fiber": "^8.17.10",
     "d3-force-3d": "^3.0.5",
+    "lodash": "^4.17.21",
     "pako": "^2.1.0",
-    "three": "0.170.0",
+    "three": "0.171.0",
     "troika-three-text": "^0.52.2"
   },
   "devDependencies": {
     "@types/d3-force": "^3.0.10",
+    "@types/lodash": "^4.17.13",
     "@types/node": "^22.10.0",
-    "@types/three": "0.170.0",
+    "@types/three": "0.171.0",
     "@typescript-eslint/eslint-plugin": "^8.16.0",
     "@typescript-eslint/parser": "^8.16.0",
     "eslint": "^8.57.0",
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 27b656ec..4d12aa91 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -10,32 +10,38 @@ importers:
     dependencies:
       '@react-three/drei':
         specifier: ^9.120.4
-        version: 9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(@types/react@19.0.1)(@types/three@0.170.0)(react@18.3.1)(three@0.170.0)(use-sync-external-store@1.2.2(react@18.3.1))
+        version: 9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(@types/react@19.0.1)(@types/three@0.171.0)(react@18.3.1)(three@0.171.0)(use-sync-external-store@1.2.2(react@18.3.1))
       '@react-three/fiber':
         specifier: ^8.17.10
-        version: 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)
+        version: 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)
       d3-force-3d:
         specifier: ^3.0.5
         version: 3.0.5
+      lodash:
+        specifier: ^4.17.21
+        version: 4.17.21
       pako:
         specifier: ^2.1.0
         version: 2.1.0
       three:
-        specifier: 0.170.0
-        version: 0.170.0
+        specifier: 0.171.0
+        version: 0.171.0
       troika-three-text:
         specifier: ^0.52.2
-        version: 0.52.2(three@0.170.0)
+        version: 0.52.2(three@0.171.0)
     devDependencies:
       '@types/d3-force':
         specifier: ^3.0.10
         version: 3.0.10
+      '@types/lodash':
+        specifier: ^4.17.13
+        version: 4.17.13
       '@types/node':
         specifier: ^22.10.0
         version: 22.10.2
       '@types/three':
-        specifier: 0.170.0
-        version: 0.170.0
+        specifier: 0.171.0
+        version: 0.171.0
       '@typescript-eslint/eslint-plugin':
         specifier: ^8.16.0
         version: 8.18.0(@typescript-eslint/parser@8.18.0(eslint@8.57.1)(typescript@5.4.5))(eslint@8.57.1)(typescript@5.4.5)
@@ -448,6 +454,9 @@ packages:
   '@types/estree@1.0.6':
     resolution: {integrity: sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==}
 
+  '@types/lodash@4.17.13':
+    resolution: {integrity: sha512-lfx+dftrEZcdBPczf9d0Qv0x+j/rfNCMuC6OcfXmO8gkfeNAY88PgKUbvG56whcN23gc27yenwF6oJZXGFpYxg==}
+
   '@types/node@22.10.2':
     resolution: {integrity: sha512-Xxr6BBRCAOQixvonOye19wnzyDiUtTeqldOOmj3CkeblonbccA12PFwlufvRdrpjXxqnmUaeiU5EOA+7s5diUQ==}
 
@@ -468,8 +477,8 @@ packages:
   '@types/stats.js@0.17.3':
     resolution: {integrity: sha512-pXNfAD3KHOdif9EQXZ9deK82HVNaXP5ZIF5RP2QG6OQFNTaY2YIetfrE9t528vEreGQvEPRDDc8muaoYeK0SxQ==}
 
-  '@types/three@0.170.0':
-    resolution: {integrity: sha512-CUm2uckq+zkCY7ZbFpviRttY+6f9fvwm6YqSqPfA5K22s9w7R4VnA3rzJse8kHVvuzLcTx+CjNCs2NYe0QFAyg==}
+  '@types/three@0.171.0':
+    resolution: {integrity: sha512-oLuT1SAsT+CUg/wxUTFHo0K3NtJLnx9sJhZWQJp/0uXqFpzSk1hRHmvWvpaAWSfvx2db0lVKZ5/wV0I0isD2mQ==}
 
   '@types/webxr@0.5.20':
     resolution: {integrity: sha512-JGpU6qiIJQKUuVSKx1GtQnHJGxRjtfGIhzO2ilq43VZZS//f1h1Sgexbdk+Lq+7569a6EYhOWrUpIruR/1Enmg==}
@@ -879,6 +888,9 @@ packages:
   lodash.merge@4.6.2:
     resolution: {integrity: sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==}
 
+  lodash@4.17.21:
+    resolution: {integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==}
+
   loose-envify@1.4.0:
     resolution: {integrity: sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==}
     hasBin: true
@@ -1115,8 +1127,8 @@ packages:
     peerDependencies:
       three: '>=0.128.0'
 
-  three@0.170.0:
-    resolution: {integrity: sha512-FQK+LEpYc0fBD+J8g6oSEyyNzjp+Q7Ks1C568WWaoMRLW+TkNNWmenWeGgJjV105Gd+p/2ql1ZcjYvNiPZBhuQ==}
+  three@0.171.0:
+    resolution: {integrity: sha512-Y/lAXPaKZPcEdkKjh0JOAHVv8OOnv/NDJqm0wjfCzyQmfKxV7zvkwsnBgPBKTzJHToSOhRGQAGbPJObT59B/PQ==}
 
   to-regex-range@5.0.1:
     resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
@@ -1405,10 +1417,10 @@ snapshots:
 
   '@mediapipe/tasks-vision@0.10.17': {}
 
-  '@monogrid/gainmap-js@3.1.0(three@0.170.0)':
+  '@monogrid/gainmap-js@3.1.0(three@0.171.0)':
     dependencies:
       promise-worker-transferable: 1.0.4
-      three: 0.170.0
+      three: 0.171.0
 
   '@nodelib/fs.scandir@2.1.5':
     dependencies:
@@ -1443,42 +1455,42 @@ snapshots:
       '@react-spring/types': 9.7.5
       react: 18.3.1
 
-  '@react-spring/three@9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(react@18.3.1)(three@0.170.0)':
+  '@react-spring/three@9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(react@18.3.1)(three@0.171.0)':
     dependencies:
       '@react-spring/animated': 9.7.5(react@18.3.1)
       '@react-spring/core': 9.7.5(react@18.3.1)
       '@react-spring/shared': 9.7.5(react@18.3.1)
       '@react-spring/types': 9.7.5
-      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)
+      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)
       react: 18.3.1
-      three: 0.170.0
+      three: 0.171.0
 
   '@react-spring/types@9.7.5': {}
 
-  '@react-three/drei@9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(@types/react@19.0.1)(@types/three@0.170.0)(react@18.3.1)(three@0.170.0)(use-sync-external-store@1.2.2(react@18.3.1))':
+  '@react-three/drei@9.120.4(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(@types/react@19.0.1)(@types/three@0.171.0)(react@18.3.1)(three@0.171.0)(use-sync-external-store@1.2.2(react@18.3.1))':
     dependencies:
       '@babel/runtime': 7.26.0
       '@mediapipe/tasks-vision': 0.10.17
-      '@monogrid/gainmap-js': 3.1.0(three@0.170.0)
-      '@react-spring/three': 9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0))(react@18.3.1)(three@0.170.0)
-      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)
+      '@monogrid/gainmap-js': 3.1.0(three@0.171.0)
+      '@react-spring/three': 9.7.5(@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0))(react@18.3.1)(three@0.171.0)
+      '@react-three/fiber': 8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)
       '@use-gesture/react': 10.3.1(react@18.3.1)
-      camera-controls: 2.9.0(three@0.170.0)
+      camera-controls: 2.9.0(three@0.171.0)
       cross-env: 7.0.3
       detect-gpu: 5.0.61
       glsl-noise: 0.0.0
       hls.js: 1.5.17
-      maath: 0.10.8(@types/three@0.170.0)(three@0.170.0)
-      meshline: 3.3.1(three@0.170.0)
+      maath: 0.10.8(@types/three@0.171.0)(three@0.171.0)
+      meshline: 3.3.1(three@0.171.0)
       react: 18.3.1
       react-composer: 5.0.3(react@18.3.1)
-      stats-gl: 2.4.2(@types/three@0.170.0)(three@0.170.0)
+      stats-gl: 2.4.2(@types/three@0.171.0)(three@0.171.0)
       stats.js: 0.17.0
       suspend-react: 0.1.3(react@18.3.1)
-      three: 0.170.0
-      three-mesh-bvh: 0.7.8(three@0.170.0)
-      three-stdlib: 2.35.2(three@0.170.0)
-      troika-three-text: 0.52.2(three@0.170.0)
+      three: 0.171.0
+      three-mesh-bvh: 0.7.8(three@0.171.0)
+      three-stdlib: 2.35.2(three@0.171.0)
+      troika-three-text: 0.52.2(three@0.171.0)
       tunnel-rat: 0.1.2(@types/react@19.0.1)(react@18.3.1)
       utility-types: 3.11.0
       uuid: 9.0.1
@@ -1489,7 +1501,7 @@ snapshots:
       - immer
       - use-sync-external-store
 
-  '@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.170.0)':
+  '@react-three/fiber@8.17.10(@types/react@19.0.1)(react@18.3.1)(three@0.171.0)':
     dependencies:
       '@babel/runtime': 7.26.0
       '@types/debounce': 1.2.4
@@ -1503,7 +1515,7 @@ snapshots:
       react-reconciler: 0.27.0(react@18.3.1)
       scheduler: 0.21.0
       suspend-react: 0.1.3(react@18.3.1)
-      three: 0.170.0
+      three: 0.171.0
       zustand: 3.7.2(react@18.3.1)
     transitivePeerDependencies:
       - '@types/react'
@@ -1575,6 +1587,8 @@ snapshots:
 
   '@types/estree@1.0.6': {}
 
+  '@types/lodash@4.17.13': {}
+
   '@types/node@22.10.2':
     dependencies:
       undici-types: 6.20.0
@@ -1595,7 +1609,7 @@ snapshots:
 
   '@types/stats.js@0.17.3': {}
 
-  '@types/three@0.170.0':
+  '@types/three@0.171.0':
     dependencies:
       '@tweenjs/tween.js': 23.1.3
       '@types/stats.js': 0.17.3
@@ -1745,9 +1759,9 @@ snapshots:
 
   callsites@3.1.0: {}
 
-  camera-controls@2.9.0(three@0.170.0):
+  camera-controls@2.9.0(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
   chalk@4.1.2:
     dependencies:
@@ -2059,20 +2073,22 @@ snapshots:
 
   lodash.merge@4.6.2: {}
 
+  lodash@4.17.21: {}
+
   loose-envify@1.4.0:
     dependencies:
       js-tokens: 4.0.0
 
-  maath@0.10.8(@types/three@0.170.0)(three@0.170.0):
+  maath@0.10.8(@types/three@0.171.0)(three@0.171.0):
     dependencies:
-      '@types/three': 0.170.0
-      three: 0.170.0
+      '@types/three': 0.171.0
+      three: 0.171.0
 
   merge2@1.4.1: {}
 
-  meshline@3.3.1(three@0.170.0):
+  meshline@3.3.1(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
   meshoptimizer@0.18.1: {}
 
@@ -2240,10 +2256,10 @@ snapshots:
 
   source-map@0.6.1: {}
 
-  stats-gl@2.4.2(@types/three@0.170.0)(three@0.170.0):
+  stats-gl@2.4.2(@types/three@0.171.0)(three@0.171.0):
     dependencies:
-      '@types/three': 0.170.0
-      three: 0.170.0
+      '@types/three': 0.171.0
+      three: 0.171.0
 
   stats.js@0.17.0: {}
 
@@ -2270,11 +2286,11 @@ snapshots:
 
   text-table@0.2.0: {}
 
-  three-mesh-bvh@0.7.8(three@0.170.0):
+  three-mesh-bvh@0.7.8(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
-  three-stdlib@2.35.2(three@0.170.0):
+  three-stdlib@2.35.2(three@0.171.0):
     dependencies:
       '@types/draco3d': 1.4.10
       '@types/offscreencanvas': 2019.7.3
@@ -2282,25 +2298,25 @@ snapshots:
       draco3d: 1.5.7
       fflate: 0.6.10
       potpack: 1.0.2
-      three: 0.170.0
+      three: 0.171.0
 
-  three@0.170.0: {}
+  three@0.171.0: {}
 
   to-regex-range@5.0.1:
     dependencies:
       is-number: 7.0.0
 
-  troika-three-text@0.52.2(three@0.170.0):
+  troika-three-text@0.52.2(three@0.171.0):
     dependencies:
       bidi-js: 1.0.3
-      three: 0.170.0
-      troika-three-utils: 0.52.0(three@0.170.0)
+      three: 0.171.0
+      troika-three-utils: 0.52.0(three@0.171.0)
       troika-worker-utils: 0.52.0
       webgl-sdf-generator: 1.1.1
 
-  troika-three-utils@0.52.0(three@0.170.0):
+  troika-three-utils@0.52.0(three@0.171.0):
     dependencies:
-      three: 0.170.0
+      three: 0.171.0
 
   troika-worker-utils@0.52.0: {}
 
diff --git a/scripts/launch-docker.sh b/scripts/launch-docker.sh
index 783c0b89..53b1b906 100755
--- a/scripts/launch-docker.sh
+++ b/scripts/launch-docker.sh
@@ -160,8 +160,9 @@ verify_client_structure() {
         "$PROJECT_ROOT/client/state/defaultSettings.ts"
         "$PROJECT_ROOT/client/xr/xrSessionManager.ts"
         "$PROJECT_ROOT/client/xr/xrInteraction.ts"
-        "$PROJECT_ROOT/client/xr/xrTypes.ts"
         "$PROJECT_ROOT/client/platform/platformManager.ts"
+        "$PROJECT_ROOT/client/types/gestures.ts"
+        "$PROJECT_ROOT/client/types/xr.ts"
         "$PROJECT_ROOT/client/tsconfig.json"
     )
     
@@ -260,14 +261,24 @@ check_application_readiness() {
             status_msg="HTTP endpoint not ready"
         fi
 
-        # Check WebSocket endpoint
-        if [ "$ready" = true ]; then
-            log "${YELLOW}Testing WebSocket connection...${NC}"
-            if ! timeout 5 websocat "ws://localhost:4000/wss" > /dev/null 2>&1 <<< '{"type":"ping"}'; then
-                ready=false
-                status_msg="WebSocket endpoint not ready"
-            fi
-        fi
+        # Temporarily skip WebSocket checks for debugging
+        # First check WebSocket control setup
+        #if [ "$ready" = true ]; then
+        #    log "${YELLOW}Testing WebSocket control setup...${NC}"
+        #    if ! timeout 5 curl -s http://localhost:4000/api/visualization/settings/websocket >/dev/null; then
+        #        ready=false
+        #        status_msg="WebSocket control setup not ready"
+        #    fi
+        #fi
+
+        # Then check WebSocket binary protocol endpoint
+        #if [ "$ready" = true ]; then
+        #    log "${YELLOW}Testing WebSocket binary connection...${NC}"
+        #    if ! timeout 5 websocat "ws://localhost:4000/wss" --binary > /dev/null 2>&1; then
+        #        ready=false
+        #        status_msg="WebSocket binary endpoint not ready"
+        #    fi
+        #fi
 
         # Optional RAGFlow connectivity check
         if [ "$ready" = true ]; then
diff --git a/scripts/start.sh b/scripts/start.sh
index 7b16871c..d3e04f3d 100755
--- a/scripts/start.sh
+++ b/scripts/start.sh
@@ -6,79 +6,66 @@ log() {
     echo "[$(date "+%Y-%m-%d %H:%M:%S")] $1"
 }
 
-# Function to check if a service is healthy
+# Function to check if a port is available
+check_port_available() {
+    local port=$1
+    local max_retries=10
+    local wait=1
+
+    log "Checking if port $port is available..."
+    
+    for ((i=1; i<=max_retries; i++)); do
+        if timeout 1 bash -c "cat < /dev/null > /dev/tcp/0.0.0.0/$port" 2>/dev/null; then
+            log "Port $port is available"
+            return 0
+        fi
+        if [ $i -lt $max_retries ]; then
+            log "Port $port not ready, attempt $i of $max_retries..."
+            sleep $wait
+        fi
+    done
+
+    log "Error: Port $port is not available after $max_retries attempts"
+    return 1
+}
+
+# Function to check service health
 check_service_health() {
     local port=$1
     local endpoint=${2:-"/"}
-    local websocket=${3:-false}
     local retries=30
     local wait=2
 
     log "Checking health for service on port $port..."
     
     while [ $retries -gt 0 ]; do
-        # Check if port is open
-        if ! timeout 1 bash -c "cat < /dev/null > /dev/tcp/0.0.0.0/$port" 2>/dev/null; then
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Error: Port $port is not available"
-                return 1
-            fi
-            log "Port $port not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-            continue
-        fi
-
-        # Check HTTP endpoint
-        if ! curl -s -f --max-time 5 "http://localhost:$port$endpoint" > /dev/null; then
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Error: Service health check failed on port $port"
-                return 1
-            fi
-            log "Service not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-            continue
-        fi
-
-        # Check WebSocket endpoint if required
-        if [ "$websocket" = true ] && ! curl -s -f --max-time 5 -N -H "Connection: Upgrade" -H "Upgrade: websocket" "http://localhost:$port/wss" > /dev/null; then
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Error: WebSocket health check failed on port $port"
-                return 1
-            fi
-            log "WebSocket not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-            continue
+        if curl -s -f --max-time 5 "http://localhost:$port$endpoint" > /dev/null; then
+            log "Service on port $port is healthy"
+            return 0
         fi
-
-        log "Service on port $port is healthy"
-        return 0
+        
+        retries=$((retries-1))
+        if [ $retries -eq 0 ]; then
+            log "Error: Service health check failed on port $port"
+            return 1
+        }
+        log "Service not ready, retrying in $wait seconds... ($retries attempts left)"
+        sleep $wait
     done
 
     return 1
 }
 
-# Function to check RAGFlow connectivity with retries
+# Function to check RAGFlow connectivity
 check_ragflow() {
     log "Checking RAGFlow connectivity..."
-    local retries=5
-    local wait=10
-    while [ $retries -gt 0 ]; do
-        if curl -s -f --max-time 5 "http://ragflow-server/v1/" > /dev/null; then
-            log "RAGFlow server is reachable"
-            return 0
-        else
-            retries=$((retries-1))
-            if [ $retries -eq 0 ]; then
-                log "Warning: Cannot reach RAGFlow server after multiple attempts"
-                return 1
-            fi
-            log "RAGFlow not ready, retrying in $wait seconds... ($retries attempts left)"
-            sleep $wait
-        fi
-    done
+    if curl -s -f --max-time 5 "http://ragflow-server/v1/" > /dev/null; then
+        log "RAGFlow server is reachable"
+        return 0
+    else
+        log "Warning: RAGFlow server not available - some features may be limited"
+        return 1
+    fi
 }
 
 # Function to verify production build
@@ -91,33 +78,9 @@ verify_build() {
         return 1
     fi
     
-    if [ ! -r "/app/data/public/dist" ]; then
-        log "Error: Production build directory is not readable"
-        return 1
-    fi
-    
-    # Check required files exist
-    local required_files=(
-        "index.html"
-        "assets"
-    )
-    
-    for file in "${required_files[@]}"; do
-        if [ ! -e "/app/data/public/dist/$file" ]; then
-            log "Error: Required file/directory '$file' not found in build directory"
-            return 1
-        fi
-    done
-    
-    # Check directory is not empty
-    if [ -z "$(ls -A /app/data/public/dist)" ]; then
-        log "Error: Production build directory is empty"
-        return 1
-    fi
-    
-    # Check permissions
+    # Check index.html exists and is readable
     if [ ! -r "/app/data/public/dist/index.html" ]; then
-        log "Error: index.html is not readable"
+        log "Error: index.html not found or not readable"
         return 1
     fi
     
@@ -162,14 +125,12 @@ setup_runtime() {
 
     # Verify GPU is available
     if ! command -v nvidia-smi &> /dev/null; then
-        log "Error: nvidia-smi not found. GPU support is required."
-        return 1
-    fi
-
-    # Check GPU is accessible
-    if ! nvidia-smi &> /dev/null; then
-        log "Error: Cannot access NVIDIA GPU. Check device is properly passed to container."
-        return 1
+        log "Warning: nvidia-smi not found. GPU support may be limited."
+    else
+        # Check GPU is accessible
+        if ! nvidia-smi &> /dev/null; then
+            log "Warning: Cannot access NVIDIA GPU. Some features may be limited."
+        fi
     fi
 
     log "Runtime environment configured successfully"
@@ -218,10 +179,8 @@ main() {
         exit 1
     fi
 
-    # Check RAGFlow availability (optional)
-    if ! check_ragflow; then
-        log "Warning: RAGFlow server not available - some features may be limited"
-    fi
+    # Check RAGFlow connectivity
+    check_ragflow
 
     # Verify production build
     if ! verify_build; then
@@ -229,24 +188,54 @@ main() {
         exit 1
     fi
 
-    # Start nginx (it needs to bind to port 4000)
-    log "Starting nginx..."
-    nginx -t && nginx
-    if [ $? -ne 0 ]; then
-        log "Failed to start nginx"
+    # Check if backend port is available
+    if ! check_port_available 3001; then
+        log "Failed to verify backend port 3001 is available"
         exit 1
     fi
 
-    # Basic nginx HTTP check (not WebSocket since that requires webxr to be running)
-    if ! curl -s -f --max-time 5 "http://localhost:4000/" > /dev/null; then
-        log "Failed to verify nginx is running"
+    # Start webxr binary with output logging
+    log "Starting webxr..."
+    /app/webxr > /tmp/webxr.log 2>&1 &
+    RUST_PID=$!
+
+    # Give webxr time to initialize
+    sleep 5
+
+    # Check if process is still running
+    if ! kill -0 $RUST_PID 2>/dev/null; then
+        log "Error: webxr process failed to start"
+        cat /tmp/webxr.log
         exit 1
     fi
+
+    # Check backend health
+    if ! check_service_health 3001 "/api/health"; then
+        log "Error: Backend health check failed"
+        cat /tmp/webxr.log
+        kill $RUST_PID
+        exit 1
+    fi
+    log "Backend is healthy"
+
+    # Start nginx
+    log "Starting nginx..."
+    nginx -t || { log "nginx config test failed"; kill $RUST_PID; exit 1; }
+    nginx || { log "Failed to start nginx"; kill $RUST_PID; exit 1; }
     log "nginx started successfully"
 
-    # Execute the webxr binary as the main process (which will enable WebSocket endpoints)
-    log "Executing webxr..."
-    exec /app/webxr
+    # Check frontend health
+    if ! check_service_health 4000 "/"; then
+        log "Error: Frontend health check failed"
+        cat /tmp/webxr.log
+        kill $RUST_PID
+        nginx -s quit
+        exit 1
+    fi
+    log "Frontend is healthy"
+
+    # Wait for webxr process
+    wait $RUST_PID
 }
 
 # Execute main function
diff --git a/scripts/test_all_endpoints.sh b/scripts/test_all_endpoints.sh
new file mode 100755
index 00000000..31277668
--- /dev/null
+++ b/scripts/test_all_endpoints.sh
@@ -0,0 +1,223 @@
+#!/bin/bash
+
+# Enable error reporting and strict mode
+set -euo pipefail
+IFS=$'\n\t'
+
+# Color setup using tput
+if [ -t 1 ]; then
+    RED=$(tput setaf 1)
+    GREEN=$(tput setaf 2)
+    YELLOW=$(tput setaf 3)
+    BLUE=$(tput setaf 4)
+    BOLD=$(tput bold)
+    NC=$(tput sgr0)
+else
+    RED=""
+    GREEN=""
+    YELLOW=""
+    BLUE=""
+    BOLD=""
+    NC=""
+fi
+
+# Configuration
+CONTAINER_NAME="logseq-xr-webxr"
+BACKEND_PORT=3001
+NGINX_PORT=4000
+PUBLIC_DOMAIN="www.visionflow.info"
+TIMEOUT=5
+WEBSOCKET_TIMEOUT=10
+
+# Test environments
+declare -A ENDPOINTS=(
+    ["internal"]="http://localhost:$BACKEND_PORT"
+    ["docker"]="http://localhost:$NGINX_PORT"
+    ["production"]="https://$PUBLIC_DOMAIN"
+)
+
+# Function to log messages with timestamp
+log() {
+    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
+    printf "%s[%s]%s %s\n" "${BOLD}" "${timestamp}" "${NC}" "$1"
+}
+
+# Function to log success
+log_success() {
+    log "${GREEN}✓ $1${NC}"
+}
+
+# Function to log error
+log_error() {
+    log "${RED}✗ $1${NC}"
+}
+
+# Function to log info
+log_info() {
+    log "${BLUE}$1${NC}"
+}
+
+# Function to log header
+log_header() {
+    printf "\n%s%s===%s %s %s===%s\n" "${BOLD}" "${YELLOW}" "${NC}" "$1" "${YELLOW}" "${NC}"
+}
+
+# Function to pretty print JSON
+pretty_json() {
+    if command -v jq >/dev/null 2>&1; then
+        echo "$1" | jq '.'
+    else
+        echo "$1"
+    fi
+}
+
+# Function to test endpoint and show response
+test_endpoint() {
+    local url="$1"
+    local description="$2"
+    local method="${3:-GET}"
+    local data="${4:-}"
+    local extra_opts="${5:-}"
+    local show_raw="${6:-false}"
+    
+    log_info "Testing $method $description..."
+    log_info "URL: $url"
+    
+    local curl_opts="-X $method -m $TIMEOUT -s -w '\n%{http_code}'"
+    [[ "$url" == https://* ]] && curl_opts="$curl_opts -k"
+    [[ -n "$data" ]] && curl_opts="$curl_opts -H 'Content-Type: application/json' -d '$data'"
+    [[ -n "$extra_opts" ]] && curl_opts="$curl_opts $extra_opts"
+    
+    # Execute curl command
+    local response
+    local http_code
+    eval "response=\$(curl $curl_opts '$url' 2>&1)"
+    http_code=$(echo "$response" | tail -n1)
+    response=$(echo "$response" | sed \$d)  # Remove the last line (status code)
+    
+    if [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
+        log_success "$description successful (HTTP $http_code)"
+        if [ "$show_raw" = true ]; then
+            log_info "Raw Response:"
+            printf "%s\n" "$response"
+            log_info "Pretty Response:"
+            pretty_json "$response"
+        else
+            log_info "Response Summary:"
+            pretty_json "$response" | head -n 20
+            local lines=$(echo "$response" | wc -l)
+            if [ "$lines" -gt 20 ]; then
+                log_info "... (${lines} lines total, showing first 20)"
+            fi
+        fi
+        return 0
+    else
+        log_error "$description failed (HTTP $http_code)"
+        log_info "Response: $response"
+        return 1
+    fi
+}
+
+# Function to test WebSocket connection
+test_websocket() {
+    local url="$1"
+    local description="$2"
+    
+    log_info "Testing WebSocket: $description"
+    log_info "URL: $url"
+    
+    # Use websocat to test WebSocket connection if available
+    if command -v websocat >/dev/null 2>&1; then
+        timeout $WEBSOCKET_TIMEOUT websocat --no-close "$url" 2>&1 || {
+            log_error "WebSocket connection failed"
+            return 1
+        }
+        log_success "WebSocket connection successful"
+        return 0
+    else
+        # Fallback to curl for basic connection test
+        if curl --include \
+            --no-buffer \
+            --header "Connection: Upgrade" \
+            --header "Upgrade: websocket" \
+            --header "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" \
+            --header "Sec-WebSocket-Version: 13" \
+            -s "$url" 2>&1 | grep -q "101 Switching Protocols"; then
+            log_success "WebSocket handshake successful"
+            return 0
+        else
+            log_error "WebSocket handshake failed"
+            return 1
+        fi
+    fi
+}
+
+# Function to test environment
+test_environment() {
+    local env="$1"
+    local base_url="${ENDPOINTS[$env]}"
+    local failed=0
+    
+    log_header "Testing $env environment ($base_url)"
+    
+    # Test paginated endpoint with raw output
+    test_endpoint "$base_url/api/graph/data/paginated?page=0&page_size=10" "$env paginated graph data" "GET" "" "" true || ((failed++))
+    
+    # Test other endpoints
+    test_endpoint "$base_url/api/graph/data" "$env graph data" || ((failed++))
+    
+    # Test settings endpoints
+    test_endpoint "$base_url/api/settings/visualization" "$env visualization settings" || ((failed++))
+    test_endpoint "$base_url/api/settings/visualization/animations/enable_motion_blur" "$env enable motion blur setting" || ((failed++))
+    test_endpoint "$base_url/api/settings/visualization/bloom/enabled" "$env bloom enabled setting" || ((failed++))
+    
+    # Test updating a setting
+    test_endpoint "$base_url/api/settings/visualization/animations/enable_motion_blur" "$env update enable motion blur setting" "PUT" '{"value": true}' || ((failed++))
+    
+    # Test saving settings
+    test_endpoint "$base_url/api/settings/save" "$env save settings" "PUT" || ((failed++))
+    
+    # Test WebSocket endpoints
+    local ws_protocol="ws"
+    [[ "$base_url" == https://* ]] && ws_protocol="wss"
+    local ws_base_url="${base_url/http:/$ws_protocol:}"
+    local ws_base_url="${ws_base_url/https:/$ws_protocol:}"
+    
+    test_websocket "$ws_base_url/wss" "$env WebSocket Binary Protocol" || ((failed++))
+    
+    return $failed
+}
+
+# Main execution
+main() {
+    log_header "Starting endpoint tests..."
+    local total_failed=0
+    
+    # Test each environment
+    for env in "${!ENDPOINTS[@]}"; do
+        test_environment "$env"
+        local env_failed=$?
+        ((total_failed += env_failed))
+        
+        # Print environment summary
+        echo
+        log_info "Environment $env: $([ $env_failed -eq 0 ] && echo "PASS" || echo "FAIL ($env_failed failed)")"
+    done
+    
+    # Print final summary
+    echo
+    log_header "Test Summary:"
+    if [ $total_failed -eq 0 ]; then
+        log_success "All tests passed successfully!"
+        exit 0
+    else
+        log_error "${total_failed} tests failed"
+        exit 1
+    fi
+}
+
+# Make script executable
+chmod +x "$0"
+
+# Run main function
+main
diff --git a/scripts/test_endpoints.sh b/scripts/test_endpoints.sh
index 9d48f2fb..e6bfd395 100755
--- a/scripts/test_endpoints.sh
+++ b/scripts/test_endpoints.sh
@@ -1,252 +1,208 @@
 #!/bin/bash
 
-# Enable error reporting
-set -e
+# Enable error reporting and strict mode
+set -euo pipefail
+IFS=$'\n\t'
 
-# Color codes for output
-RED='\033[0;31m'
-GREEN='\033[0;32m'
-YELLOW='\033[1;33m'
-BLUE='\033[0;34m'
-NC='\033[0m'
+# Color setup using tput
+if [ -t 1 ]; then
+    RED=$(tput setaf 1)
+    GREEN=$(tput setaf 2)
+    YELLOW=$(tput setaf 3)
+    BLUE=$(tput setaf 4)
+    BOLD=$(tput bold)
+    NC=$(tput sgr0)
+else
+    RED=""
+    GREEN=""
+    YELLOW=""
+    BLUE=""
+    BOLD=""
+    NC=""
+fi
 
 # Configuration
 CONTAINER_NAME="logseq-xr-webxr"
 BACKEND_PORT=3001
 NGINX_PORT=4000
 PUBLIC_DOMAIN="www.visionflow.info"
-RAGFLOW_NETWORK="docker_ragflow"
 TIMEOUT=5
+WEBSOCKET_TIMEOUT=10
 
-# Function to log messages
+# Test environments
+declare -A ENDPOINTS=(
+    ["internal"]="http://localhost:$BACKEND_PORT"
+    ["docker"]="http://localhost:$NGINX_PORT"
+    ["production"]="https://$PUBLIC_DOMAIN"
+)
+
+# REST endpoints to test
+declare -a REST_ENDPOINTS=(
+    # Settings API
+    "/api/settings"
+    "/api/settings/visualization.nodes.baseSize"
+    "/api/settings/visualization.edges.color"
+    "/api/settings/xr.mode"
+    
+    # Graph endpoints
+    "/api/graph/data"
+    "/api/graph/data/paginated?page=0&page_size=10"
+)
+
+# Function to log messages with timestamp
 log() {
-    printf "[%s] %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$1"
+    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
+    printf "%s[%s]%s %s\n" "${BOLD}" "${timestamp}" "${NC}" "$1"
 }
 
-# Function to safely execute docker commands with timeout
-docker_exec() {
-    timeout $TIMEOUT docker exec "$CONTAINER_NAME" $@ 2>&1 || echo "Command timed out after ${TIMEOUT}s"
+# Function to log success
+log_success() {
+    log "${GREEN}✓ $1${NC}"
 }
 
-# Function to check if port is open
-check_port() {
-    local host="$1"
-    local port="$2"
-    timeout $TIMEOUT bash -c "echo > /dev/tcp/$host/$port" 2>/dev/null
-    return $?
+# Function to log error
+log_error() {
+    log "${RED}✗ $1${NC}"
 }
 
-# Function to test endpoint and show response
-test_endpoint() {
+# Function to log info
+log_info() {
+    log "${BLUE}$1${NC}"
+}
+
+# Function to log header
+log_header() {
+    printf "\n%s%s===%s %s %s===%s\n" "${BOLD}" "${YELLOW}" "${NC}" "$1" "${YELLOW}" "${NC}"
+}
+
+# Function to test WebSocket connection
+test_websocket() {
     local url="$1"
     local description="$2"
-    local extra_opts="${3:-}"
-    local expected_content="${4:-}"
-    
-    log "${BLUE}Testing $description...${NC}"
-    log "URL: $url"
     
-    # First check if port is open
-    local port=$(echo "$url" | sed -n 's/.*:\([0-9]\+\).*/\1/p')
-    local host=$(echo "$url" | sed -n 's/.*\/\/\([^:\/]*\).*/\1/p')
+    log_info "Testing WebSocket: $description"
+    log_info "URL: $url"
     
-    if [ -n "$port" ] && ! check_port "$host" "$port"; then
-        log "${RED}✗ Port $port is not open on $host${NC}"
-        return 1
-    fi
-    
-    # Then try the request
-    local response
-    if [[ -n "$extra_opts" ]]; then
-        response=$(curl -v -m $TIMEOUT -s $extra_opts "$url" 2>&1)
-    else
-        response=$(curl -v -m $TIMEOUT -s "$url" 2>&1)
-    fi
-    local status=$?
-    
-    if [ $status -eq 0 ]; then
-        log "${GREEN}✓ $description successful${NC}"
-        log "Response: $response"
-        
-        # Check for expected content if provided
-        if [ -n "$expected_content" ] && ! echo "$response" | grep -q "$expected_content"; then
-            log "${RED}✗ Expected content not found: $expected_content${NC}"
+    # Use websocat to test WebSocket connection if available
+    if command -v websocat >/dev/null 2>&1; then
+        timeout $WEBSOCKET_TIMEOUT websocat --no-close "$url" 2>&1 || {
+            log_error "WebSocket connection failed"
             return 1
-        fi
-        
+        }
+        log_success "WebSocket connection successful"
         return 0
     else
-        log "${RED}✗ $description failed (status: $status)${NC}"
-        log "Response: $response"
-        return 1
+        # Fallback to curl for basic connection test
+        if curl --include \
+            --no-buffer \
+            --header "Connection: Upgrade" \
+            --header "Upgrade: websocket" \
+            --header "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" \
+            --header "Sec-WebSocket-Version: 13" \
+            -s "$url" 2>&1 | grep -q "101 Switching Protocols"; then
+            log_success "WebSocket handshake successful"
+            return 0
+        else
+            log_error "WebSocket handshake failed"
+            return 1
+        fi
     fi
 }
 
-# Function to check Nginx logs
-check_nginx_logs() {
-    log "${BLUE}Checking Nginx logs...${NC}"
-    docker_exec tail -n 50 /var/log/nginx/error.log || true
-    docker_exec tail -n 50 /var/log/nginx/access.log || true
-}
-
-# Function to check static files
-check_static_files() {
-    log "${BLUE}Checking static files in container...${NC}"
-    docker_exec ls -la /app/client || true
-    docker_exec cat /app/client/index.html || true
-}
-
-# Function to test backend health
-test_backend() {
-    log "\n${BLUE}=== Testing Internal Backend (Port $BACKEND_PORT) ===${NC}"
-    local failed=0
+# Function to test REST endpoint
+test_rest_endpoint() {
+    local url="$1"
+    local description="$2"
+    local method="${3:-GET}"
+    local data="${4:-}"
+    local extra_opts="${5:-}"
     
-    # Check if container is running
-    if ! docker ps | grep -q "$CONTAINER_NAME"; then
-        log "${RED}Container $CONTAINER_NAME is not running${NC}"
-        docker ps
-        return 1
-    fi
+    log_info "Testing $method $description..."
+    log_info "URL: $url"
     
-    # Test internal endpoints
-    local response=$(docker_exec curl -s "http://localhost:$BACKEND_PORT/api/graph/data")
-    if [ $? -eq 0 ] && [ -n "$response" ]; then
-        log "${GREEN}✓ Backend /api/graph/data accessible${NC}"
-        log "Response: $response"
-    else
-        log "${RED}✗ Backend /api/graph/data failed${NC}"
-        ((failed++))
-    fi
+    local curl_opts="-X $method -m $TIMEOUT -s -w '%{http_code}'"
+    [[ "$url" == https://* ]] && curl_opts="$curl_opts -k"
+    [[ -n "$data" ]] && curl_opts="$curl_opts -H 'Content-Type: application/json' -d '$data'"
+    [[ -n "$extra_opts" ]] && curl_opts="$curl_opts $extra_opts"
     
-    response=$(docker_exec curl -s "http://localhost:$BACKEND_PORT/api/graph/data/paginated?page=0&page_size=10")
-    if [ $? -eq 0 ] && [ -n "$response" ]; then
-        log "${GREEN}✓ Backend /api/graph/data/paginated accessible${NC}"
-        log "Response: $response"
-    else
-        log "${RED}✗ Backend /api/graph/data/paginated failed${NC}"
-        ((failed++))
-    fi
+    local response
+    local http_code
     
-    return $failed
-}
-
-# Function to test nginx
-test_nginx() {
-    log "\n${BLUE}=== Testing Nginx Proxy (Port $NGINX_PORT) ===${NC}"
-    local failed=0
+    # Execute curl command
+    eval "response=\$(curl $curl_opts '$url' 2>&1)"
+    http_code=${response: -3}
+    response=${response:0:${#response}-3}
     
-    # Check if nginx is running
-    if ! docker_exec pgrep nginx > /dev/null; then
-        log "${RED}Nginx is not running in container${NC}"
+    if [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
+        log_success "$description successful (HTTP $http_code)"
+        log_info "Response: $response"
+        return 0
+    else
+        log_error "$description failed (HTTP $http_code)"
+        log_info "Response: $response"
         return 1
     fi
-    
-    # Check nginx config
-    log "Checking Nginx configuration..."
-    docker_exec nginx -t || true
-    
-    # Check static files
-    check_static_files
-    
-    # Test static file serving
-    test_endpoint "http://localhost:$NGINX_PORT/" "Nginx static files" "" "<!DOCTYPE html>" || ((failed++))
-    test_endpoint "http://localhost:$NGINX_PORT/index.html" "Nginx index.html" "" "<!DOCTYPE html>" || ((failed++))
-    
-    # Test API endpoint
-    test_endpoint "http://localhost:$NGINX_PORT/api/graph/data" "Nginx API proxy" || ((failed++))
-    
-    # Check logs if there were failures
-    if [ $failed -gt 0 ]; then
-        check_nginx_logs
-    fi
-    
-    return $failed
 }
 
-# Function to test network
-test_network() {
-    log "\n${BLUE}=== Testing RAGFlow Network ===${NC}"
+# Function to test all endpoints for a given environment
+test_environment() {
+    local env="$1"
+    local base_url="${ENDPOINTS[$env]}"
     local failed=0
     
-    # Get container IP
-    local ip=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$CONTAINER_NAME")
-    if [ -z "$ip" ]; then
-        log "${RED}Failed to get container IP${NC}"
-        return 1
-    fi
-    log "Container IP: $ip"
+    log_header "Testing $env environment ($base_url)"
     
-    # Test network connectivity
-    test_endpoint "http://$ip:$NGINX_PORT/api/graph/data" "Network API connectivity" || ((failed++))
-    test_endpoint "http://$ip:$NGINX_PORT/" "Network static files" "" "<!DOCTYPE html>" || ((failed++))
-    
-    # Test DNS resolution
-    local dns_response=$(docker run --rm --network "$RAGFLOW_NETWORK" alpine nslookup webxr-client)
-    if [ $? -eq 0 ]; then
-        log "${GREEN}✓ DNS resolution working${NC}"
-        log "DNS Response: $dns_response"
-    else
-        log "${RED}✗ DNS resolution failed${NC}"
-        log "DNS Response: $dns_response"
-        ((failed++))
-    fi
-    
-    return $failed
-}
-
-# Function to test public URL
-test_public() {
-    log "\n${BLUE}=== Testing Public URL ===${NC}"
-    local failed=0
+    # Test REST endpoints
+    for endpoint in "${REST_ENDPOINTS[@]}"; do
+        test_rest_endpoint "$base_url$endpoint" "$env $endpoint" || ((failed++))
+        
+        # Test PUT for settings endpoints
+        if [[ "$endpoint" == "/api/settings"* ]]; then
+            test_rest_endpoint "$base_url$endpoint" "$env $endpoint (PUT)" "PUT" '{"value": 30}' || ((failed++))
+        fi
+    done
     
-    # Test HTTPS endpoint
-    test_endpoint "https://$PUBLIC_DOMAIN/api/graph/data" "Public API" "-k" || ((failed++))
+    # Test WebSocket endpoints
+    local ws_protocol="ws"
+    [[ "$base_url" == https://* ]] && ws_protocol="wss"
+    local ws_base_url="${base_url/http:/$ws_protocol:}"
+    local ws_base_url="${ws_base_url/https:/$ws_protocol:}"
     
-    # Test static files
-    test_endpoint "https://$PUBLIC_DOMAIN/" "Public static files" "-k" "<!DOCTYPE html>" || ((failed++))
-    test_endpoint "https://$PUBLIC_DOMAIN/index.html" "Public index.html" "-k" "<!DOCTYPE html>" || ((failed++))
+    test_websocket "$ws_base_url/wss" "$env WebSocket Binary Protocol" || ((failed++))
     
     return $failed
 }
 
 # Main execution
 main() {
-    log "${YELLOW}Starting comprehensive endpoint tests...${NC}"
+    log_header "Starting comprehensive endpoint tests across all environments..."
     local total_failed=0
     
-    # Run tests in order
-    test_backend
-    local backend_failed=$?
-    ((total_failed += backend_failed))
-    
-    test_nginx
-    local nginx_failed=$?
-    ((total_failed += nginx_failed))
-    
-    test_network
-    local network_failed=$?
-    ((total_failed += network_failed))
-    
-    test_public
-    local public_failed=$?
-    ((total_failed += public_failed))
+    # Test each environment
+    for env in "${!ENDPOINTS[@]}"; do
+        test_environment "$env"
+        local env_failed=$?
+        ((total_failed += env_failed))
+        
+        # Print environment summary
+        echo
+        log_info "Environment $env: $([ $env_failed -eq 0 ] && echo "PASS" || echo "FAIL ($env_failed failed)")"
+    done
     
-    # Print summary
+    # Print final summary
     echo
-    log "${YELLOW}Test Summary:${NC}"
-    echo "Backend Tests: $([ $backend_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($backend_failed failed)${NC}")"
-    echo "Nginx Tests: $([ $nginx_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($nginx_failed failed)${NC}")"
-    echo "Network Tests: $([ $network_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($network_failed failed)${NC}")"
-    echo "Public URL Tests: $([ $public_failed -eq 0 ] && echo "${GREEN}PASS${NC}" || echo "${RED}FAIL ($public_failed failed)${NC}")"
-    
+    log_header "Test Summary:"
     if [ $total_failed -eq 0 ]; then
-        log "${GREEN}All tests passed successfully!${NC}"
+        log_success "All tests passed successfully!"
         exit 0
     else
-        log "${RED}${total_failed} tests failed${NC}"
+        log_error "${total_failed} tests failed"
         exit 1
     fi
 }
 
+# Make script executable
+chmod +x "$0"
+
 # Run main function
 main
diff --git a/settings.toml b/settings.toml
index ae7a394b..11bc9242 100644
--- a/settings.toml
+++ b/settings.toml
@@ -1,4 +1,4 @@
-[animations]
+[visualization.animations]
 enable_motion_blur = false
 enable_node_animations = false
 motion_blur_strength = 0.4
@@ -8,43 +8,7 @@ ripple_enabled = false
 edge_animation_enabled = false
 flow_particles_enabled = false
 
-[ar]
-drag_threshold = 0.04
-enable_hand_tracking = true
-enable_haptics = true
-enable_light_estimation = true
-enable_passthrough_portal = false
-enable_plane_detection = true
-enable_scene_understanding = true
-gesture_smoothing = 0.9
-hand_mesh_color = "#FFD700"
-hand_mesh_enabled = true
-hand_mesh_opacity = 0.3
-hand_point_size = 0.01
-hand_ray_color = "#FFD700"
-hand_ray_enabled = true
-hand_ray_width = 0.002
-haptic_intensity = 0.7
-passthrough_brightness = 1
-passthrough_contrast = 1
-passthrough_opacity = 1
-pinch_threshold = 0.015
-plane_color = "#4A90E2"
-plane_opacity = 0.3
-portal_edge_color = "#FFD700"
-portal_edge_width = 0.02
-portal_size = 1
-room_scale = true
-rotation_threshold = 0.08
-show_plane_overlay = true
-snap_to_floor = true
-
-[audio]
-enable_ambient_sounds = false
-enable_interaction_sounds = false
-enable_spatial_audio = false
-
-[bloom]
+[visualization.bloom]
 edge_bloom_strength = 0.3
 enabled = false
 environment_bloom_strength = 0.5
@@ -52,55 +16,45 @@ node_bloom_strength = 0.2
 radius = 0.5
 strength = 1.8
 
-[client_debug]
-enable_data_debug = true
-enable_websocket_debug = true
-enabled = true
-log_binary_headers = true
-log_full_json = true
-
-[default]
-api_client_timeout = 30
-enable_metrics = true
-enable_request_logging = true
-log_format = "json"
-log_level = "debug"
-max_concurrent_requests = 5
-max_payload_size = 5242880
-max_retries = 3
-metrics_port = 9090
-retry_delay = 5
-
-[edges]
+[visualization.edges]
 arrow_size = 0.15
 base_width = 2
 color = "#917f18"
 enable_arrows = false
 opacity = 0.6
-width_range = [
-    1,
-    3,
-]
+width_range = [1, 3]
+
+[visualization.hologram]
+xr_quality = "medium"
+desktop_quality = "high"
+ring_count = 3
+ring_color = "#00FFFF"
+ring_opacity = 0.5
+ring_sizes = [1.0, 1.5, 2.0]
+ring_rotation_speed = 0.1
+enable_buckminster = true
+buckminster_scale = 1.0
+buckminster_opacity = 0.3
+enable_geodesic = true
+geodesic_scale = 1.2
+geodesic_opacity = 0.4
+enable_triangle_sphere = true
+triangle_sphere_scale = 1.1
+triangle_sphere_opacity = 0.35
+global_rotation_speed = 0.05
 
-[labels]
+[visualization.labels]
 desktop_font_size = 48
 enable_labels = true
 text_color = "#FFFFFF"
+text_rendering_mode = "sdf"
+text_resolution = 64
+text_padding = 4
+text_outline_width = 0.4
+text_outline_color = "#000000"
+billboard_mode = "camera"
 
-[network]
-bind_address = "0.0.0.0"
-domain = "localhost"
-enable_http2 = false
-enable_rate_limiting = true
-enable_tls = false
-max_request_size = 10485760
-min_tls_version = ""
-port = 3001
-rate_limit_requests = 100
-rate_limit_window = 60
-tunnel_id = "dummy"
-
-[nodes]
+[visualization.nodes]
 base_color = "#c3ab6f"
 base_size = 1
 clearcoat = 1
@@ -114,12 +68,15 @@ metalness = 0.3
 opacity = 0.4
 roughness = 0.35
 size_by_connections = true
-size_range = [
-    1,
-    5,
-]
+size_range = [1, 5]
+use_metadata_size = true
+use_metadata_shape = true
+use_metadata_color = true
+shape_age_ranges = [7, 30, 90, 365]
+hyperlink_color_min = "#c3ab6f"
+hyperlink_color_max = "#822626"
 
-[physics]
+[visualization.physics]
 attraction_strength = 0.015
 bounds_size = 12
 collision_radius = 0.25
@@ -131,7 +88,7 @@ max_velocity = 2.5
 repulsion_strength = 1500
 spring_strength = 0.018
 
-[rendering]
+[visualization.rendering]
 ambient_light_intensity = 0.7
 background_color = "#000000"
 directional_light_intensity = 1
@@ -140,32 +97,88 @@ enable_antialiasing = true
 enable_shadows = false
 environment_intensity = 1.2
 
-[security]
-allowed_origins = []
-audit_log_path = "/app/logs/audit.log"
-cookie_httponly = true
-cookie_samesite = "Strict"
-cookie_secure = true
-csrf_token_timeout = 3600
-enable_audit_logging = true
-enable_request_validation = true
-session_timeout = 3600
+[xr]
+mode = "immersive-ar"
+room_scale = true
+space_type = "local-floor"
+quality = "medium"
+
+[xr.input]
+enable_hand_tracking = true
+enable_haptics = true
+haptic_intensity = 0.7
+drag_threshold = 0.04
+pinch_threshold = 0.015
+rotation_threshold = 0.08
+interaction_radius = 0.5
 
-[server_debug]
-enable_data_debug = true
-enable_websocket_debug = true
-enabled = true
-log_binary_headers = true
-log_full_json = true
+[xr.visuals]
+hand_mesh_enabled = true
+hand_mesh_color = "#FFD700"
+hand_mesh_opacity = 0.3
+hand_point_size = 0.01
+hand_ray_enabled = true
+hand_ray_color = "#FFD700"
+hand_ray_width = 0.002
+gesture_smoothing = 0.9
+
+[xr.environment]
+enable_light_estimation = true
+enable_plane_detection = true
+enable_scene_understanding = true
+plane_color = "#4A90E2"
+plane_opacity = 0.3
+show_plane_overlay = true
+snap_to_floor = true
 
-[websocket]
+[xr.passthrough]
+enabled = false
+opacity = 1.0
+brightness = 1.0
+contrast = 1.0
+portal_size = 1.0
+portal_edge_color = "#FFD700"
+portal_edge_width = 0.02
+
+[system.network]
+bind_address = "0.0.0.0"
+domain = "localhost"
+enable_http2 = false
+enable_rate_limiting = true
+enable_tls = false
+max_request_size = 10485760
+min_tls_version = ""
+port = 3001
+rate_limit_requests = 100
+rate_limit_window = 60
+tunnel_id = "dummy"
+
+[system.websocket]
 binary_chunk_size = 65536
-compression_enabled = true
+compression_enabled = false
 compression_threshold = 1024
 heartbeat_interval = 15000
 heartbeat_timeout = 60000
-max_connections = 1000
+max_connections = 100
 max_message_size = 100485760
 reconnect_attempts = 3
 reconnect_delay = 5000
-update_rate = 90
+update_rate = 1
+
+[system.security]
+allowed_origins = ["*"]
+audit_log_path = "/app/logs/audit.log"
+cookie_httponly = true
+cookie_samesite = "Strict"
+cookie_secure = true
+csrf_token_timeout = 3600
+enable_audit_logging = true
+enable_request_validation = true
+session_timeout = 3600
+
+[system.debug]
+enabled = false
+enable_data_debug = false
+enable_websocket_debug = false
+log_binary_headers = false
+log_full_json = false
diff --git a/src/app_state.rs b/src/app_state.rs
index 713c8493..20a0e38f 100755
--- a/src/app_state.rs
+++ b/src/app_state.rs
@@ -1,10 +1,11 @@
 use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
 use tokio::sync::RwLock;
+use log::{info, warn};
 
 use crate::config::Settings;
 use crate::models::metadata::MetadataStore;
 use crate::services::graph_service::GraphService;
-use crate::services::file_service::RealGitHubService;
+use crate::services::file_service::{FileService, RealGitHubService};
 use crate::services::github_service::RealGitHubPRService;
 use crate::services::perplexity_service::PerplexityService;
 use crate::services::ragflow_service::RAGFlowService;
@@ -12,7 +13,7 @@ use crate::utils::gpu_compute::GPUCompute;
 
 #[derive(Clone)]
 pub struct AppState {
-    pub graph_service: GraphService,
+    pub graph_service: Arc<GraphService>,
     pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
     pub settings: Arc<RwLock<Settings>>,
     pub metadata: Arc<RwLock<MetadataStore>>,
@@ -25,7 +26,7 @@ pub struct AppState {
 }
 
 impl AppState {
-    pub fn new(
+    pub async fn new(
         settings: Arc<RwLock<Settings>>,
         github_service: Arc<RealGitHubService>,
         perplexity_service: Option<Arc<PerplexityService>>,
@@ -34,11 +35,26 @@ impl AppState {
         ragflow_conversation_id: String,
         github_pr_service: Arc<RealGitHubPRService>,
     ) -> Self {
+        // Load metadata first
+        let metadata_store = match FileService::load_or_create_metadata() {
+            Ok(metadata) => {
+                info!("Loaded metadata with {} entries", metadata.len());
+                metadata
+            },
+            Err(e) => {
+                warn!("Failed to load metadata: {}, starting with empty store", e);
+                MetadataStore::new()
+            }
+        };
+
+        // Initialize graph service with metadata
+        let graph_service = Arc::new(GraphService::new_with_metadata(&metadata_store).await);
+
         Self {
-            graph_service: GraphService::new(),
+            graph_service,
             gpu_compute,
             settings,
-            metadata: Arc::new(RwLock::new(MetadataStore::new())),
+            metadata: Arc::new(RwLock::new(metadata_store)),
             github_service,
             perplexity_service,
             ragflow_service,
diff --git a/src/config.rs b/src/config.rs
index 0bbb9530..caea0c69 100755
--- a/src/config.rs
+++ b/src/config.rs
@@ -6,7 +6,32 @@ use std::path::PathBuf;
 #[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "snake_case")]
 pub struct Settings {
-    // UI/Rendering settings from settings.toml
+    // Core visualization settings
+    #[serde(default)]
+    pub visualization: VisualizationSettings,
+
+    // XR-specific settings
+    #[serde(default)]
+    pub xr: XRSettings,
+
+    // System settings
+    #[serde(default)]
+    pub system: SystemSettings,
+
+    // Service settings from .env (server-side only)
+    #[serde(default)]
+    pub github: GitHubSettings,
+    #[serde(default)]
+    pub ragflow: RagFlowSettings,
+    #[serde(default)]
+    pub perplexity: PerplexitySettings,
+    #[serde(default)]
+    pub openai: OpenAISettings,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+pub struct VisualizationSettings {
     #[serde(default)]
     pub animations: AnimationSettings,
     #[serde(default)]
@@ -16,37 +41,100 @@ pub struct Settings {
     #[serde(default)]
     pub bloom: BloomSettings,
     #[serde(default)]
-    pub client_debug: DebugSettings,
-    #[serde(default)]
-    pub default: DefaultSettings,
-    #[serde(default)]
     pub edges: EdgeSettings,
     #[serde(default)]
-    pub labels: LabelSettings,
+    pub hologram: HologramSettings,
     #[serde(default)]
-    pub network: NetworkSettings,
+    pub labels: LabelSettings,
     #[serde(default)]
     pub nodes: NodeSettings,
     #[serde(default)]
     pub physics: PhysicsSettings,
     #[serde(default)]
     pub rendering: RenderingSettings,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+pub struct XRSettings {
     #[serde(default)]
-    pub security: SecuritySettings,
+    pub mode: String,
     #[serde(default)]
-    pub server_debug: DebugSettings,
+    pub room_scale: bool,
     #[serde(default)]
-    pub websocket: WebSocketSettings,
-    
-    // Service settings from .env (server-side only)
+    pub space_type: String,
     #[serde(default)]
-    pub github: GitHubSettings,
+    pub quality: String,
     #[serde(default)]
-    pub ragflow: RagFlowSettings,
+    pub input: XRInputSettings,
     #[serde(default)]
-    pub perplexity: PerplexitySettings,
+    pub visuals: XRVisualSettings,
     #[serde(default)]
-    pub openai: OpenAISettings,
+    pub environment: XREnvironmentSettings,
+    #[serde(default)]
+    pub passthrough: XRPassthroughSettings,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XRInputSettings {
+    pub enable_hand_tracking: bool,
+    pub enable_haptics: bool,
+    pub haptic_intensity: f32,
+    pub drag_threshold: f32,
+    pub pinch_threshold: f32,
+    pub rotation_threshold: f32,
+    pub interaction_radius: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XRVisualSettings {
+    pub hand_mesh_enabled: bool,
+    pub hand_mesh_color: String,
+    pub hand_mesh_opacity: f32,
+    pub hand_point_size: f32,
+    pub hand_ray_enabled: bool,
+    pub hand_ray_color: String,
+    pub hand_ray_width: f32,
+    pub gesture_smoothing: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XREnvironmentSettings {
+    pub enable_light_estimation: bool,
+    pub enable_plane_detection: bool,
+    pub enable_scene_understanding: bool,
+    pub plane_color: String,
+    pub plane_opacity: f32,
+    pub show_plane_overlay: bool,
+    pub snap_to_floor: bool,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone, Default)]
+#[serde(rename_all = "snake_case")]
+pub struct XRPassthroughSettings {
+    pub enabled: bool,
+    pub opacity: f32,
+    pub brightness: f32,
+    pub contrast: f32,
+    pub portal_size: f32,
+    pub portal_edge_color: String,
+    pub portal_edge_width: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+pub struct SystemSettings {
+    #[serde(default)]
+    pub network: NetworkSettings,
+    #[serde(default)]
+    pub websocket: WebSocketSettings,
+    #[serde(default)]
+    pub security: SecuritySettings,
+    #[serde(default)]
+    pub debug: DebugSettings,
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
@@ -283,6 +371,7 @@ pub struct ARSettings {
     pub hand_ray_enabled: bool,
     pub hand_ray_width: f32,
     pub haptic_intensity: f32,
+    pub interaction_radius: f32,
     pub passthrough_brightness: f32,
     pub passthrough_contrast: f32,
     pub passthrough_opacity: f32,
@@ -308,7 +397,7 @@ impl Default for ARSettings {
             enable_passthrough_portal: false,
             enable_plane_detection: true,
             enable_scene_understanding: true,
-            gesture_smoothing: 0.5,
+            gesture_smoothing: 0.9,
             hand_mesh_color: "#FFD700".to_string(),
             hand_mesh_enabled: true,
             hand_mesh_opacity: 0.3,
@@ -317,15 +406,16 @@ impl Default for ARSettings {
             hand_ray_enabled: true,
             hand_ray_width: 0.002,
             haptic_intensity: 0.7,
+            interaction_radius: 0.5,
             passthrough_brightness: 1.0,
             passthrough_contrast: 1.0,
-            passthrough_opacity: 0.8,
+            passthrough_opacity: 1.0,
             pinch_threshold: 0.015,
-            plane_color: "#808080".to_string(),
-            plane_opacity: 0.5,
-            portal_edge_color: "#00FF00".to_string(),
+            plane_color: "#4A90E2".to_string(),
+            plane_opacity: 0.3,
+            portal_edge_color: "#FFD700".to_string(),
             portal_edge_width: 0.02,
-            portal_size: 2.0,
+            portal_size: 1.0,
             room_scale: true,
             rotation_threshold: 0.08,
             show_plane_overlay: true,
@@ -382,6 +472,8 @@ impl Default for BloomSettings {
 #[serde(rename_all = "snake_case")]
 #[serde(default)]
 pub struct EdgeSettings {
+    pub arrow_size: f32,
+    pub base_width: f32,
     pub color: String,
     pub enable_arrows: bool,
     pub opacity: f32,
@@ -391,6 +483,8 @@ pub struct EdgeSettings {
 impl Default for EdgeSettings {
     fn default() -> Self {
         Self {
+            arrow_size: 0.2,
+            base_width: 2.0,
             color: "#917f18".to_string(),
             enable_arrows: false,
             opacity: 0.6,
@@ -406,6 +500,12 @@ pub struct LabelSettings {
     pub desktop_font_size: u32,
     pub enable_labels: bool,
     pub text_color: String,
+    pub text_rendering_mode: String,
+    pub text_resolution: u32,
+    pub text_padding: u32,
+    pub text_outline_width: f32,
+    pub text_outline_color: String,
+    pub billboard_mode: String,
 }
 
 impl Default for LabelSettings {
@@ -414,6 +514,12 @@ impl Default for LabelSettings {
             desktop_font_size: 48,
             enable_labels: true,
             text_color: "#FFFFFF".to_string(),
+            text_rendering_mode: "sdf".to_string(),
+            text_resolution: 64,
+            text_padding: 4,
+            text_outline_width: 0.4,
+            text_outline_color: "#000000".to_string(),
+            billboard_mode: "camera".to_string(),
         }
     }
 }
@@ -424,6 +530,7 @@ impl Default for LabelSettings {
 pub struct NodeSettings {
     pub base_color: String,
     pub base_size: f32,
+    pub clearcoat: f32,
     pub enable_hover_effect: bool,
     pub enable_instancing: bool,
     pub highlight_color: String,
@@ -435,6 +542,12 @@ pub struct NodeSettings {
     pub roughness: f32,
     pub size_by_connections: bool,
     pub size_range: Vec<f32>,
+    pub use_metadata_size: bool,
+    pub use_metadata_shape: bool,
+    pub use_metadata_color: bool,
+    pub shape_age_ranges: Vec<u32>,
+    pub hyperlink_color_min: String,
+    pub hyperlink_color_max: String,
 }
 
 impl Default for NodeSettings {
@@ -442,6 +555,7 @@ impl Default for NodeSettings {
         Self {
             base_color: "#c3ab6f".to_string(),
             base_size: 1.0,
+            clearcoat: 0.5,
             enable_hover_effect: false,
             enable_instancing: false,
             highlight_color: "#822626".to_string(),
@@ -452,7 +566,13 @@ impl Default for NodeSettings {
             opacity: 0.4,
             roughness: 0.35,
             size_by_connections: true,
-            size_range: vec![1.0, 10.0],
+            size_range: vec![1.0, 5.0],
+            use_metadata_size: true,
+            use_metadata_shape: true,
+            use_metadata_color: true,
+            shape_age_ranges: vec![7, 30, 90, 365],
+            hyperlink_color_min: "#c3ab6f".to_string(),
+            hyperlink_color_max: "#822626".to_string(),
         }
     }
 }
@@ -548,6 +668,56 @@ impl Default for SecuritySettings {
     }
 }
 
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+#[serde(default)]
+pub struct HologramSettings {
+    pub xr_quality: String,
+    pub desktop_quality: String,
+    pub ring_count: u32,
+    pub ring_color: String,
+    pub ring_opacity: f32,
+    pub ring_sizes: Vec<f32>,
+    pub ring_rotation_speed: f32,
+    pub enable_buckminster: bool,
+    pub buckminster_scale: f32,
+    pub buckminster_opacity: f32,
+    pub enable_geodesic: bool,
+    pub geodesic_scale: f32,
+    pub geodesic_opacity: f32,
+    pub enable_triangle_sphere: bool,
+    pub triangle_sphere_scale: f32,
+    pub triangle_sphere_opacity: f32,
+    pub global_rotation_speed: f32,
+}
+
+impl Default for HologramSettings {
+    fn default() -> Self {
+        Self {
+            xr_quality: "medium".to_string(),
+            desktop_quality: "high".to_string(),
+            ring_count: 3,
+            ring_color: "#00FFFF".to_string(),
+            ring_opacity: 0.5,
+            ring_sizes: vec![1.0, 1.5, 2.0],
+            ring_rotation_speed: 0.1,
+            enable_buckminster: true,
+            buckminster_scale: 1.0,
+            buckminster_opacity: 0.3,
+            enable_geodesic: true,
+            geodesic_scale: 1.2,
+            geodesic_opacity: 0.4,
+            enable_triangle_sphere: true,
+            triangle_sphere_scale: 1.1,
+            triangle_sphere_opacity: 0.35,
+            global_rotation_speed: 0.05,
+        }
+    }
+}
+
+// Note: Connection keep-alive is handled by WebSocket protocol-level ping/pong frames
+// automatically by the actix-web-actors framework on the server and browser WebSocket API
+// on the client. No custom heartbeat implementation is needed.
 #[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "snake_case")]
 #[serde(default)]
@@ -555,8 +725,6 @@ pub struct WebSocketSettings {
     pub binary_chunk_size: usize,
     pub compression_enabled: bool,
     pub compression_threshold: usize,
-    pub heartbeat_interval: u64,
-    pub heartbeat_timeout: u64,
     pub max_connections: usize,
     pub max_message_size: usize,
     pub reconnect_attempts: u32,
@@ -570,8 +738,6 @@ impl Default for WebSocketSettings {
             binary_chunk_size: 65536,
             compression_enabled: true,
             compression_threshold: 1024,
-            heartbeat_interval: 15000,
-            heartbeat_timeout: 60000,
             max_connections: 1000,
             max_message_size: 100485760,
             reconnect_attempts: 3,
@@ -584,17 +750,25 @@ impl Default for WebSocketSettings {
 impl Settings {
     pub fn new() -> Result<Self, ConfigError> {
         debug!("Initializing settings");
-        
+
         // Load .env file first
         dotenvy::dotenv().ok();
-        
-        // Use environment variable or default to /app/settings.toml
+
+        // Use environment variable or try multiple paths
         let settings_path = std::env::var("SETTINGS_FILE_PATH")
             .map(PathBuf::from)
-            .unwrap_or_else(|_| PathBuf::from("/app/settings.toml"));
-        
+            .unwrap_or_else(|_| {
+                // Try current directory first, then /app/settings.toml
+                let current_dir_path = PathBuf::from("settings.toml");
+                if current_dir_path.exists() {
+                    current_dir_path
+                } else {
+                    PathBuf::from("/app/settings.toml")
+                }
+            });
+
         debug!("Loading settings from: {:?}", settings_path);
-        
+
         let builder = ConfigBuilder::<config::builder::DefaultState>::default();
         let config = builder
             .add_source(File::from(settings_path))
@@ -616,25 +790,25 @@ impl Settings {
                 return Err(e);
             }
         };
-        
+
         debug!("Checking for environment variables");
-        
+
         // Network settings from environment variables
-        if let Ok(domain) = std::env::var("DOMAIN") {
-            settings.network.domain = domain;
-        }
-        if let Ok(port) = std::env::var("PORT") {
-            settings.network.port = port.parse().unwrap_or(4000);
-        }
-        if let Ok(bind_address) = std::env::var("BIND_ADDRESS") {
-            settings.network.bind_address = bind_address;
-        }
-        if let Ok(tunnel_id) = std::env::var("TUNNEL_ID") {
-            settings.network.tunnel_id = tunnel_id;
-        }
-        if let Ok(enable_http2) = std::env::var("HTTP2_ENABLED") {
-            settings.network.enable_http2 = enable_http2.parse().unwrap_or(true);
-        }
+            if let Ok(domain) = std::env::var("DOMAIN") {
+                settings.system.network.domain = domain;
+            }
+            if let Ok(port) = std::env::var("PORT") {
+                settings.system.network.port = port.parse().unwrap_or(4000);
+            }
+            if let Ok(bind_address) = std::env::var("BIND_ADDRESS") {
+                settings.system.network.bind_address = bind_address;
+            }
+            if let Ok(tunnel_id) = std::env::var("TUNNEL_ID") {
+                settings.system.network.tunnel_id = tunnel_id;
+            }
+            if let Ok(enable_http2) = std::env::var("HTTP2_ENABLED") {
+                settings.system.network.enable_http2 = enable_http2.parse().unwrap_or(true);
+            }
 
         // GitHub settings from environment variables
         if let Ok(token) = std::env::var("GITHUB_TOKEN") {
@@ -738,27 +912,149 @@ impl Settings {
 }
 
 impl Default for Settings {
+    fn default() -> Self {
+        Self {
+            visualization: VisualizationSettings {
+                animations: AnimationSettings::default(),
+                ar: ARSettings::default(),
+                audio: AudioSettings::default(),
+                bloom: BloomSettings::default(),
+                edges: EdgeSettings::default(),
+                hologram: HologramSettings::default(),
+                labels: LabelSettings::default(),
+                nodes: NodeSettings::default(),
+                physics: PhysicsSettings::default(),
+                rendering: RenderingSettings::default(),
+            },
+            xr: XRSettings {
+                mode: "immersive-ar".to_string(),
+                room_scale: true,
+                space_type: "local-floor".to_string(),
+                quality: "medium".to_string(),
+                input: XRInputSettings {
+                    enable_hand_tracking: true,
+                    enable_haptics: true,
+                    haptic_intensity: 0.7,
+                    drag_threshold: 0.04,
+                    pinch_threshold: 0.015,
+                    rotation_threshold: 0.08,
+                    interaction_radius: 0.5,
+                },
+                visuals: XRVisualSettings {
+                    hand_mesh_enabled: true,
+                    hand_mesh_color: "#FFD700".to_string(),
+                    hand_mesh_opacity: 0.3,
+                    hand_point_size: 0.01,
+                    hand_ray_enabled: true,
+                    hand_ray_color: "#FFD700".to_string(),
+                    hand_ray_width: 0.002,
+                    gesture_smoothing: 0.9,
+                },
+                environment: XREnvironmentSettings {
+                    enable_light_estimation: true,
+                    enable_plane_detection: true,
+                    enable_scene_understanding: true,
+                    plane_color: "#4A90E2".to_string(),
+                    plane_opacity: 0.3,
+                    show_plane_overlay: true,
+                    snap_to_floor: true,
+                },
+                passthrough: XRPassthroughSettings {
+                    enabled: false,
+                    opacity: 1.0,
+                    brightness: 1.0,
+                    contrast: 1.0,
+                    portal_size: 1.0,
+                    portal_edge_color: "#FFD700".to_string(),
+                    portal_edge_width: 0.02,
+                },
+            },
+            system: SystemSettings {
+                network: NetworkSettings::default(),
+                websocket: WebSocketSettings::default(),
+                security: SecuritySettings::default(),
+                debug: DebugSettings::default(),
+            },
+            github: GitHubSettings::default(),
+            ragflow: RagFlowSettings::default(),
+            perplexity: PerplexitySettings::default(),
+            openai: OpenAISettings::default(),
+        }
+    }
+}
+
+impl Default for VisualizationSettings {
     fn default() -> Self {
         Self {
             animations: AnimationSettings::default(),
             ar: ARSettings::default(),
             audio: AudioSettings::default(),
             bloom: BloomSettings::default(),
-            client_debug: DebugSettings::default(),
-            default: DefaultSettings::default(),
             edges: EdgeSettings::default(),
+            hologram: HologramSettings::default(),
             labels: LabelSettings::default(),
             nodes: NodeSettings::default(),
             physics: PhysicsSettings::default(),
             rendering: RenderingSettings::default(),
-            security: SecuritySettings::default(),
-            server_debug: DebugSettings::default(),
-            websocket: WebSocketSettings::default(),
+        }
+    }
+}
+
+impl Default for XRSettings {
+    fn default() -> Self {
+        Self {
+            mode: "immersive-ar".to_string(),
+            room_scale: true,
+            space_type: "local-floor".to_string(),
+            quality: "medium".to_string(),
+            input: XRInputSettings {
+                enable_hand_tracking: true,
+                enable_haptics: true,
+                haptic_intensity: 0.7,
+                drag_threshold: 0.04,
+                pinch_threshold: 0.015,
+                rotation_threshold: 0.08,
+                interaction_radius: 0.5,
+            },
+            visuals: XRVisualSettings {
+                hand_mesh_enabled: true,
+                hand_mesh_color: "#FFD700".to_string(),
+                hand_mesh_opacity: 0.3,
+                hand_point_size: 0.01,
+                hand_ray_enabled: true,
+                hand_ray_color: "#FFD700".to_string(),
+                hand_ray_width: 0.002,
+                gesture_smoothing: 0.9,
+            },
+            environment: XREnvironmentSettings {
+                enable_light_estimation: true,
+                enable_plane_detection: true,
+                enable_scene_understanding: true,
+                plane_color: "#4A90E2".to_string(),
+                plane_opacity: 0.3,
+                show_plane_overlay: true,
+                snap_to_floor: true,
+            },
+            passthrough: XRPassthroughSettings {
+                enabled: false,
+                opacity: 1.0,
+                brightness: 1.0,
+                contrast: 1.0,
+                portal_size: 1.0,
+                portal_edge_color: "#FFD700".to_string(),
+                portal_edge_width: 0.02,
+            },
+        }
+    }
+}
+
+impl Default for SystemSettings {
+    fn default() -> Self {
+        Self {
             network: NetworkSettings::default(),
-            github: GitHubSettings::default(),
-            ragflow: RagFlowSettings::default(),
-            perplexity: PerplexitySettings::default(),
-            openai: OpenAISettings::default(),
+            websocket: WebSocketSettings::default(),
+            security: SecuritySettings::default(),
+            debug: DebugSettings::default(),
         }
     }
 }
diff --git a/src/handlers/file_handler.rs b/src/handlers/file_handler.rs
index 586fd2aa..ab9e1f97 100755
--- a/src/handlers/file_handler.rs
+++ b/src/handlers/file_handler.rs
@@ -1,4 +1,4 @@
-use actix_web::{web, Error as ActixError, HttpResponse};
+use actix_web::{web::{self, ServiceConfig}, Error as ActixError, HttpResponse};
 use serde_json::json;
 use log::{info, debug, error};
 
@@ -152,6 +152,13 @@ pub async fn refresh_graph(state: web::Data<AppState>) -> HttpResponse {
     }
 }
 
+pub fn config(cfg: &mut ServiceConfig) {
+    cfg.service(web::resource("/fetch").to(fetch_and_process_files))
+       .service(web::resource("/content/{file_name}").to(get_file_content))
+       .service(web::resource("/refresh").to(refresh_graph))
+       .service(web::resource("/update").to(update_graph));
+}
+
 pub async fn update_graph(state: web::Data<AppState>) -> Result<HttpResponse, ActixError> {
     // Load metadata from file
     let metadata_store = match FileService::load_or_create_metadata() {
diff --git a/src/handlers/graph_handler.rs b/src/handlers/graph_handler.rs
index 7ab98ccd..258501fa 100755
--- a/src/handlers/graph_handler.rs
+++ b/src/handlers/graph_handler.rs
@@ -1,4 +1,4 @@
-use actix_web::{web, HttpResponse, Responder};
+use actix_web::{web::{self, ServiceConfig}, HttpResponse, Responder};
 use crate::AppState;
 use serde::{Serialize, Deserialize};
 use log::{info, debug, error, warn};
@@ -177,6 +177,15 @@ pub async fn refresh_graph(state: web::Data<AppState>) -> impl Responder {
 }
 
 // Fetch new metadata and rebuild graph
+pub fn config(cfg: &mut ServiceConfig) {
+    cfg.service(web::resource("/data").to(get_graph_data))
+       .service(web::resource("/data/paginated").to(get_paginated_graph_data))
+       .service(
+           web::resource("/update")
+               .route(web::post().to(update_graph))
+       );
+}
+
 pub async fn update_graph(state: web::Data<AppState>) -> impl Responder {
     info!("Received request to update graph");
     
diff --git a/src/handlers/mod.rs b/src/handlers/mod.rs
index 1316eebf..d47d5a95 100755
--- a/src/handlers/mod.rs
+++ b/src/handlers/mod.rs
@@ -2,5 +2,5 @@ pub mod file_handler;
 pub mod graph_handler;
 pub mod perplexity_handler;
 pub mod ragflow_handler;
+pub mod settings;
 pub mod socket_flow_handler;
-pub mod visualization_handler;
diff --git a/src/handlers/settings/common.rs b/src/handlers/settings/common.rs
new file mode 100644
index 00000000..e9b7abe8
--- /dev/null
+++ b/src/handlers/settings/common.rs
@@ -0,0 +1,295 @@
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use std::collections::HashMap;
+use log::{error, debug};
+use crate::config::Settings;
+use crate::utils::case_conversion::to_snake_case;
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SettingResponse {
+    pub category: String,
+    pub setting: String,
+    pub value: Value,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CategorySettingsResponse {
+    pub category: String,
+    pub settings: HashMap<String, Value>,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CategorySettingsUpdate {
+    pub settings: HashMap<String, Value>,
+}
+
+pub fn get_category_settings_value(settings: &Settings, category: &str) -> Result<Value, String> {
+    debug!("Getting settings for category: {}", category);
+    let category_snake = to_snake_case(category);
+    
+    match category_snake.as_str() {
+        "animations" => serde_json::to_value(&settings.visualization.animations)
+            .map_err(|e| format!("Failed to serialize animations settings: {}", e)),
+        "ar" => serde_json::to_value(&settings.visualization.ar)
+            .map_err(|e| format!("Failed to serialize ar settings: {}", e)),
+        "audio" => serde_json::to_value(&settings.visualization.audio)
+            .map_err(|e| format!("Failed to serialize audio settings: {}", e)),
+        "bloom" => serde_json::to_value(&settings.visualization.bloom)
+            .map_err(|e| format!("Failed to serialize bloom settings: {}", e)),
+        "edges" => serde_json::to_value(&settings.visualization.edges)
+            .map_err(|e| format!("Failed to serialize edges settings: {}", e)),
+        "hologram" => serde_json::to_value(&settings.visualization.hologram)
+            .map_err(|e| format!("Failed to serialize hologram settings: {}", e)),
+        "labels" => serde_json::to_value(&settings.visualization.labels)
+            .map_err(|e| format!("Failed to serialize labels settings: {}", e)),
+        "nodes" => serde_json::to_value(&settings.visualization.nodes)
+            .map_err(|e| format!("Failed to serialize nodes settings: {}", e)),
+        "physics" => serde_json::to_value(&settings.visualization.physics)
+            .map_err(|e| format!("Failed to serialize physics settings: {}", e)),
+        "rendering" => serde_json::to_value(&settings.visualization.rendering)
+            .map_err(|e| format!("Failed to serialize rendering settings: {}", e)),
+        "network" => serde_json::to_value(&settings.system.network)
+            .map_err(|e| format!("Failed to serialize network settings: {}", e)),
+        "websocket" => serde_json::to_value(&settings.system.websocket)
+            .map_err(|e| format!("Failed to serialize websocket settings: {}", e)),
+        "security" => serde_json::to_value(&settings.system.security)
+            .map_err(|e| format!("Failed to serialize security settings: {}", e)),
+        "client_debug" | "server_debug" => serde_json::to_value(&settings.system.debug)
+            .map_err(|e| format!("Failed to serialize debug settings: {}", e)),
+        _ => Err(format!("Invalid category: {}", category)),
+    }
+}
+
+pub fn get_setting_value(settings: &Settings, category: &str, setting: &str) -> Result<Value, String> {
+    debug!("Getting setting value for {}.{}", category, setting);
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    let category_value = get_category_settings_value(settings, &category_snake)?;
+    
+    match category_value.get(&setting_snake) {
+        Some(v) => {
+            debug!("Found value for {}.{}", category_snake, setting_snake);
+            Ok(v.clone())
+        },
+        None => {
+            error!("Setting '{}' not found in {}", setting_snake, category);
+            Err(format!("Setting '{}' not found in {}", setting, category))
+        }
+    }
+}
+
+pub fn update_setting_value(settings: &mut Settings, category: &str, setting: &str, value: &Value) -> Result<(), String> {
+    debug!("Updating setting {}.{}", category, setting);
+    
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    // Get current value to determine type
+    let current_value = get_setting_value(settings, &category_snake, &setting_snake)?;
+    
+    // Convert value based on the current value's type
+    let converted_value = if current_value.is_boolean() {
+        if value.is_boolean() {
+            value.clone()
+        } else if value.is_string() {
+            Value::Bool(value.as_str().unwrap_or("false").to_lowercase() == "true")
+        } else if value.is_number() {
+            Value::Bool(value.as_i64().unwrap_or(0) != 0)
+        } else {
+            value.clone()
+        }
+    } else if current_value.is_number() {
+        if value.is_number() {
+            value.clone()
+        } else if value.is_string() {
+            if let Ok(num) = value.as_str().unwrap_or("0").trim().parse::<f64>() {
+                Value::Number(serde_json::Number::from_f64(num).unwrap_or_else(|| serde_json::Number::from(0)))
+            } else {
+                value.clone()
+            }
+        } else if value.is_boolean() {
+            Value::Number(serde_json::Number::from(if value.as_bool().unwrap_or(false) { 1 } else { 0 }))
+        } else {
+            value.clone()
+        }
+    } else {
+        value.clone()
+    };
+
+    // Update the appropriate category
+    match category_snake.as_str() {
+        "animations" => {
+            let animations = settings.visualization.animations.clone();
+            let value_map = serde_json::to_value(&animations)
+                .map_err(|e| format!("Failed to serialize animations: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.animations = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update animations: {}", e))?;
+            }
+        },
+        "ar" => {
+            let ar = settings.visualization.ar.clone();
+            let value_map = serde_json::to_value(&ar)
+                .map_err(|e| format!("Failed to serialize ar settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.ar = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update ar settings: {}", e))?;
+            }
+        },
+        "audio" => {
+            let audio = settings.visualization.audio.clone();
+            let value_map = serde_json::to_value(&audio)
+                .map_err(|e| format!("Failed to serialize audio settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.audio = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update audio settings: {}", e))?;
+            }
+        },
+        "bloom" => {
+            let bloom = settings.visualization.bloom.clone();
+            let value_map = serde_json::to_value(&bloom)
+                .map_err(|e| format!("Failed to serialize bloom settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.bloom = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update bloom settings: {}", e))?;
+            }
+        },
+        "edges" => {
+            let edges = settings.visualization.edges.clone();
+            let value_map = serde_json::to_value(&edges)
+                .map_err(|e| format!("Failed to serialize edges settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.edges = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update edges settings: {}", e))?;
+            }
+        },
+        "hologram" => {
+            let hologram = settings.visualization.hologram.clone();
+            let value_map = serde_json::to_value(&hologram)
+                .map_err(|e| format!("Failed to serialize hologram settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.hologram = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update hologram settings: {}", e))?;
+            }
+        },
+        "labels" => {
+            let labels = settings.visualization.labels.clone();
+            let value_map = serde_json::to_value(&labels)
+                .map_err(|e| format!("Failed to serialize labels settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.labels = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update labels settings: {}", e))?;
+            }
+        },
+        "nodes" => {
+            let nodes = settings.visualization.nodes.clone();
+            let value_map = serde_json::to_value(&nodes)
+                .map_err(|e| format!("Failed to serialize nodes settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.nodes = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update nodes settings: {}", e))?;
+            }
+        },
+        "physics" => {
+            let physics = settings.visualization.physics.clone();
+            let value_map = serde_json::to_value(&physics)
+                .map_err(|e| format!("Failed to serialize physics settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.physics = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update physics settings: {}", e))?;
+            }
+        },
+        "rendering" => {
+            let rendering = settings.visualization.rendering.clone();
+            let value_map = serde_json::to_value(&rendering)
+                .map_err(|e| format!("Failed to serialize rendering settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.visualization.rendering = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update rendering settings: {}", e))?;
+            }
+        },
+        "network" => {
+            let network = settings.system.network.clone();
+            let value_map = serde_json::to_value(&network)
+                .map_err(|e| format!("Failed to serialize network settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.system.network = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update network settings: {}", e))?;
+            }
+        },
+        "websocket" => {
+            let websocket = settings.system.websocket.clone();
+            let value_map = serde_json::to_value(&websocket)
+                .map_err(|e| format!("Failed to serialize websocket settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.system.websocket = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update websocket settings: {}", e))?;
+            }
+        },
+        "security" => {
+            let security = settings.system.security.clone();
+            let value_map = serde_json::to_value(&security)
+                .map_err(|e| format!("Failed to serialize security settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.system.security = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update security settings: {}", e))?;
+            }
+        },
+        "client_debug" | "server_debug" => {
+            let debug = settings.system.debug.clone();
+            let value_map = serde_json::to_value(&debug)
+                .map_err(|e| format!("Failed to serialize debug settings: {}", e))?;
+            if let Some(mut obj) = value_map.as_object().cloned() {
+                obj.insert(setting_snake.clone(), converted_value);
+                settings.system.debug = serde_json::from_value(Value::Object(obj))
+                    .map_err(|e| format!("Failed to update debug settings: {}", e))?;
+            }
+        },
+        _ => return Err(format!("Invalid category: {}", category)),
+    };
+    
+    debug!("Successfully updated setting {}.{}", category_snake, setting_snake);
+    Ok(())
+}
+
+pub fn set_field_value<T>(obj: &mut T, field: &str, value: Value) -> Result<(), String> 
+where
+    T: serde::Serialize + serde::de::DeserializeOwned,
+{
+    let map = serde_json::to_value(&*obj)
+        .map_err(|e| format!("Failed to serialize object: {}", e))?
+        .as_object()
+        .ok_or_else(|| "Failed to convert object to map".to_string())?
+        .clone();
+
+    let mut updated_map = map.clone();
+    updated_map.insert(field.to_string(), value);
+
+    *obj = serde_json::from_value(Value::Object(updated_map))
+        .map_err(|e| format!("Failed to deserialize updated object: {}", e))?;
+
+    Ok(())
+}
diff --git a/src/handlers/settings/mod.rs b/src/handlers/settings/mod.rs
new file mode 100644
index 00000000..2f232207
--- /dev/null
+++ b/src/handlers/settings/mod.rs
@@ -0,0 +1,212 @@
+use actix_web::{web, get, put, HttpResponse};
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use log::debug;
+use serde::{Serialize, Deserialize};
+use serde_json::Value;
+use std::collections::HashMap;
+use crate::config::Settings;
+use crate::utils::case_conversion::to_snake_case;
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SettingResponse {
+    pub category: String,
+    pub setting: String,
+    pub value: Value,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CategorySettingsResponse {
+    pub category: String,
+    pub settings: HashMap<String, Value>,
+    pub success: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub error: Option<String>,
+}
+
+// Helper function to get all settings
+fn get_all_settings(settings: &Settings) -> Value {
+    debug!("Getting all settings");
+    serde_json::to_value(settings).unwrap_or_default()
+}
+
+// Helper function to get setting value from settings object
+fn get_setting_value(settings: &Settings, category: &str, setting: &str) -> Result<Value, String> {
+    debug!("Getting setting value for {}.{}", category, setting);
+    
+    // Convert kebab-case to snake_case
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    // Convert settings to Value for easier access
+    let settings_value = serde_json::to_value(&settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    // Get category object
+    let category_value = settings_value.get(&category_snake)
+        .ok_or_else(|| format!("Category '{}' not found", category))?;
+    
+    // Get setting value
+    let setting_value = category_value.get(&setting_snake)
+        .ok_or_else(|| format!("Setting '{}' not found in category '{}'", setting, category))?;
+    
+    Ok(setting_value.clone())
+}
+
+// Helper function to update setting value in settings object
+fn update_setting_value(settings: &mut Settings, category: &str, setting: &str, value: &Value) -> Result<(), String> {
+    debug!("Updating setting value for {}.{}", category, setting);
+    
+    // Convert kebab-case to snake_case
+    let category_snake = to_snake_case(category);
+    let setting_snake = to_snake_case(setting);
+    
+    // Convert settings to Value for manipulation
+    let mut settings_value = serde_json::to_value(&*settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    // Get category object
+    let category_value = settings_value.get_mut(&category_snake)
+        .ok_or_else(|| format!("Category '{}' not found", category))?;
+    
+    // Update setting value
+    if let Some(obj) = category_value.as_object_mut() {
+        obj.insert(setting_snake.clone(), value.clone());
+        
+        // Convert back to Settings
+        *settings = serde_json::from_value(settings_value)
+            .map_err(|e| format!("Failed to deserialize settings: {}", e))?;
+        Ok(())
+    } else {
+        Err(format!("Category '{}' is not an object", category))
+    }
+}
+
+// Helper function to get all settings for a category
+fn get_category_settings(settings: &Settings, category: &str) -> Result<Value, String> {
+    debug!("Getting settings for category: {}", category);
+    
+    // Convert kebab-case to snake_case
+    let category_snake = to_snake_case(category);
+    
+    // Convert settings to Value
+    let settings_value = serde_json::to_value(&settings)
+        .map_err(|e| format!("Failed to serialize settings: {}", e))?;
+    
+    // Get category object
+    settings_value.get(&category_snake)
+        .ok_or_else(|| format!("Category '{}' not found", category))
+        .map(|v| v.clone())
+}
+
+// GET /api/settings
+#[get("")]
+async fn get_all_settings_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+) -> HttpResponse {
+    let settings_guard = settings.read().await;
+    let settings_value = get_all_settings(&settings_guard);
+    HttpResponse::Ok().json(settings_value)
+}
+
+// GET /api/settings/{category}/{setting}
+#[get("/{category}/{setting}")]
+async fn get_setting_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    let settings_guard = settings.read().await;
+    
+    match get_setting_value(&settings_guard, &category, &setting) {
+        Ok(value) => HttpResponse::Ok().json(SettingResponse {
+            category,
+            setting,
+            value,
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category,
+            setting,
+            value: Value::Null,
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+// PUT /api/settings/{category}/{setting}
+#[put("/{category}/{setting}")]
+async fn update_setting_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+    value: web::Json<Value>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    let mut settings_guard = settings.write().await;
+    
+    match update_setting_value(&mut settings_guard, &category, &setting, &value) {
+        Ok(_) => HttpResponse::Ok().json(SettingResponse {
+            category,
+            setting,
+            value: value.into_inner(),
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category,
+            setting,
+            value: value.into_inner(),
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+// GET /api/settings/{category}
+#[get("/{category}")]
+async fn get_category_settings_handler(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<String>,
+) -> HttpResponse {
+    let category = path.into_inner();
+    let settings_guard = settings.read().await;
+    
+    match get_category_settings(&settings_guard, &category) {
+        Ok(value) => {
+            let settings_map = value.as_object()
+                .map(|m| m.iter().map(|(k, v)| (k.clone(), v.clone())).collect())
+                .unwrap_or_default();
+            
+            HttpResponse::Ok().json(CategorySettingsResponse {
+                category: category.clone(),
+                settings: settings_map,
+                success: true,
+                error: None,
+            })
+        },
+        Err(e) => HttpResponse::BadRequest().json(CategorySettingsResponse {
+            category: category.clone(),
+            settings: HashMap::new(),
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+// Register all settings handlers
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(
+        web::scope("/settings")
+            .service(get_all_settings_handler)
+            .service(get_setting_handler)
+            .service(update_setting_handler)
+            .service(get_category_settings_handler)
+    );
+}
diff --git a/src/handlers/settings/visualization.rs b/src/handlers/settings/visualization.rs
new file mode 100644
index 00000000..a6977d5e
--- /dev/null
+++ b/src/handlers/settings/visualization.rs
@@ -0,0 +1,216 @@
+use actix_web::{get, put, web, HttpResponse};
+use serde_json::Value;
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use std::collections::HashMap;
+use log::{error, debug};
+
+use crate::config::Settings;
+use super::common::{SettingResponse, CategorySettingsResponse, CategorySettingsUpdate, get_setting_value, update_setting_value};
+
+// List of categories that make up visualization settings
+const VISUALIZATION_CATEGORIES: [&str; 10] = [
+    "animations",
+    "ar",
+    "audio",
+    "bloom",
+    "edges",
+    "hologram",
+    "labels",
+    "nodes",
+    "physics",
+    "rendering"
+];
+
+#[get("/visualization")]
+async fn get_visualization_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+) -> HttpResponse {
+    debug!("Getting all visualization settings");
+    
+    let settings_guard = settings.read().await;
+    let mut combined_settings = HashMap::new();
+    
+    // Process each category from root level settings
+    for category in VISUALIZATION_CATEGORIES.iter() {
+        debug!("Processing category: {}", category);
+        let category_value = match *category {
+            "animations" => serde_json::to_value(&settings_guard.visualization.animations),
+            "ar" => serde_json::to_value(&settings_guard.visualization.ar),
+            "audio" => serde_json::to_value(&settings_guard.visualization.audio),
+            "bloom" => serde_json::to_value(&settings_guard.visualization.bloom),
+            "edges" => serde_json::to_value(&settings_guard.visualization.edges),
+            "hologram" => serde_json::to_value(&settings_guard.visualization.hologram),
+            "labels" => serde_json::to_value(&settings_guard.visualization.labels),
+            "nodes" => serde_json::to_value(&settings_guard.visualization.nodes),
+            "physics" => serde_json::to_value(&settings_guard.visualization.physics),
+            "rendering" => serde_json::to_value(&settings_guard.visualization.rendering),
+            _ => continue,
+        };
+
+        if let Ok(value) = category_value {
+            if let Some(map) = value.as_object() {
+                for (key, value) in map {
+                    let combined_key = format!("{}_{}", category, key);
+                    debug!("Adding setting: {}", combined_key);
+                    combined_settings.insert(combined_key, value.clone());
+                }
+            }
+        } else {
+            error!("Failed to serialize {} settings", category);
+        }
+    }
+
+    debug!("Returning {} combined settings", combined_settings.len());
+    HttpResponse::Ok().json(CategorySettingsResponse {
+        category: "visualization".to_string(),
+        settings: combined_settings,
+        success: true,
+        error: None,
+    })
+}
+
+#[put("/visualization")]
+async fn update_visualization_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    update: web::Json<CategorySettingsUpdate>,
+) -> HttpResponse {
+    debug!("Updating visualization settings");
+    let mut settings_guard = settings.write().await;
+    let mut success = true;
+    let mut error_msg = None;
+
+    for (key, value) in update.settings.iter() {
+        // Split the key into category and setting
+        let parts: Vec<&str> = key.split('_').collect();
+        if parts.len() < 2 {
+            error!("Invalid setting key format: {}", key);
+            success = false;
+            error_msg = Some(format!("Invalid setting key format: {}", key));
+            break;
+        }
+
+        let category = parts[0];
+        let setting = parts[1..].join("_");
+
+        if !VISUALIZATION_CATEGORIES.contains(&category) {
+            error!("Invalid category: {}", category);
+            success = false;
+            error_msg = Some(format!("Invalid category: {}", category));
+            break;
+        }
+
+        debug!("Updating setting {}.{}", category, setting);
+        if let Err(e) = update_setting_value(&mut settings_guard, category, &setting, value) {
+            error!("Failed to update setting {}.{}: {}", category, setting, e);
+            success = false;
+            error_msg = Some(e);
+            break;
+        }
+    }
+
+    HttpResponse::Ok().json(CategorySettingsResponse {
+        category: "visualization".to_string(),
+        settings: update.settings.clone(),
+        success,
+        error: error_msg,
+    })
+}
+
+#[get("/visualization/{category}/{setting}")]
+async fn get_visualization_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    debug!("Getting visualization setting: {}.{}", category, setting);
+
+    if !VISUALIZATION_CATEGORIES.contains(&category.as_str()) {
+        error!("Invalid category: {}", category);
+        return HttpResponse::BadRequest().json(SettingResponse {
+            category: "visualization".to_string(),
+            setting: format!("{}.{}", category, setting),
+            value: Value::Null,
+            success: false,
+            error: Some(format!("Invalid category: {}", category)),
+        });
+    }
+
+    let settings_guard = settings.read().await;
+
+    match get_setting_value(&settings_guard, &category, &setting) {
+        Ok(value) => {
+            debug!("Successfully retrieved setting value");
+            HttpResponse::Ok().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value,
+                success: true,
+                error: None,
+            })
+        },
+        Err(e) => {
+            error!("Failed to get setting value: {}", e);
+            HttpResponse::BadRequest().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value: Value::Null,
+                success: false,
+                error: Some(e),
+            })
+        }
+    }
+}
+
+#[put("/visualization/{category}/{setting}")]
+async fn update_visualization_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<(String, String)>,
+    value: web::Json<Value>,
+) -> HttpResponse {
+    let (category, setting) = path.into_inner();
+    debug!("Updating visualization setting: {}.{}", category, setting);
+
+    if !VISUALIZATION_CATEGORIES.contains(&category.as_str()) {
+        error!("Invalid category: {}", category);
+        return HttpResponse::BadRequest().json(SettingResponse {
+            category: "visualization".to_string(),
+            setting: format!("{}.{}", category, setting),
+            value: value.into_inner(),
+            success: false,
+            error: Some(format!("Invalid category: {}", category)),
+        });
+    }
+
+    let mut settings_guard = settings.write().await;
+
+    match update_setting_value(&mut settings_guard, &category, &setting, &value) {
+        Ok(_) => {
+            debug!("Successfully updated setting value");
+            HttpResponse::Ok().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value: value.into_inner(),
+                success: true,
+                error: None,
+            })
+        },
+        Err(e) => {
+            error!("Failed to update setting value: {}", e);
+            HttpResponse::BadRequest().json(SettingResponse {
+                category: "visualization".to_string(),
+                setting: format!("{}.{}", category, setting),
+                value: value.into_inner(),
+                success: false,
+                error: Some(e),
+            })
+        }
+    }
+}
+
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(get_visualization_settings)
+       .service(update_visualization_settings)
+       .service(get_visualization_setting)
+       .service(update_visualization_setting);
+}
diff --git a/src/handlers/settings/websocket.rs b/src/handlers/settings/websocket.rs
new file mode 100644
index 00000000..ffafab2f
--- /dev/null
+++ b/src/handlers/settings/websocket.rs
@@ -0,0 +1,76 @@
+use actix_web::{get, put, web, HttpResponse};
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use std::sync::Arc;
+use tokio::sync::RwLock;
+
+use crate::config::Settings;
+use super::common::{SettingResponse, get_setting_value, update_setting_value};
+
+// Note: Connection keep-alive is handled by WebSocket protocol-level ping/pong frames
+// automatically by the actix-web-actors framework on the server and browser WebSocket API
+// on the client. No custom heartbeat implementation is needed.
+#[derive(Debug, Serialize, Deserialize)]
+pub struct WebSocketSettings {
+    pub reconnect_attempts: u32,
+    pub reconnect_delay: u64,
+    pub update_rate: u32,
+}
+
+#[get("/{setting}")]
+async fn get_websocket_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<String>,
+) -> HttpResponse {
+    let setting = path.into_inner();
+    let settings = settings.read().await;
+    
+    match get_setting_value(&settings, "websocket", &setting) {
+        Ok(value) => HttpResponse::Ok().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting: setting.clone(),
+            value,
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting,
+            value: Value::Null,
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+#[put("/{setting}")]
+async fn update_websocket_setting(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    path: web::Path<String>,
+    value: web::Json<Value>,
+) -> HttpResponse {
+    let setting = path.into_inner();
+    let mut settings = settings.write().await;
+    
+    match update_setting_value(&mut settings, "websocket", &setting, &value) {
+        Ok(_) => HttpResponse::Ok().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting: setting.clone(),
+            value: value.into_inner(),
+            success: true,
+            error: None,
+        }),
+        Err(e) => HttpResponse::BadRequest().json(SettingResponse {
+            category: "websocket".to_string(),
+            setting,
+            value: value.into_inner(),
+            success: false,
+            error: Some(e),
+        }),
+    }
+}
+
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(get_websocket_setting)
+       .service(update_websocket_setting);
+}
diff --git a/src/handlers/socket_flow_handler.rs b/src/handlers/socket_flow_handler.rs
index 897b75e6..37bac3d6 100644
--- a/src/handlers/socket_flow_handler.rs
+++ b/src/handlers/socket_flow_handler.rs
@@ -1,457 +1,357 @@
-use actix::{Actor, StreamHandler, ActorContext, AsyncContext, Handler, Message as ActixMessage, ActorFutureExt};
+use std::sync::Arc;
+use actix::prelude::*;
 use actix_web::{web, Error, HttpRequest, HttpResponse};
 use actix_web_actors::ws;
-use log::{error, warn, info};
-use std::sync::Arc;
-use std::time::{Duration, Instant};
 use tokio::sync::RwLock;
+use log::{info, debug, error, warn};
+use serde::{Deserialize, Serialize};
+use serde_json::json;
+use std::time::{Duration, Instant};
 
 use crate::app_state::AppState;
-use crate::utils::socket_flow_messages::{BinaryNodeData, Message};
+use crate::config::Settings;
 use crate::utils::socket_flow_constants::{
-    HEARTBEAT_INTERVAL as HEARTBEAT_INTERVAL_SECS,
-    MAX_CLIENT_TIMEOUT as MAX_CLIENT_TIMEOUT_SECS,
+    BINARY_PROTOCOL_VERSION,
+    HEARTBEAT_INTERVAL,
+    MAX_CLIENT_TIMEOUT,
+    FLOATS_PER_NODE,
+    VERSION_HEADER_SIZE,
+    NODE_DATA_SIZE,
+    MAX_CONNECTIONS,
+    MAX_MESSAGE_SIZE,
 };
 
-// Convert seconds to Duration
-const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(HEARTBEAT_INTERVAL_SECS);
-const MAX_CLIENT_TIMEOUT: Duration = Duration::from_secs(MAX_CLIENT_TIMEOUT_SECS);
-
-#[derive(Debug)]
-enum WebSocketResponse {
-    Text(String),
-    Binary(Vec<u8>),
-    None,
-}
-
-#[derive(ActixMessage)]
-#[rtype(result = "()")]
-struct SendMessage(String);
-
-#[derive(ActixMessage)]
-#[rtype(result = "()")]
-struct UpdateNodeOrder(Vec<String>);
-
-impl Handler<UpdateNodeOrder> for SocketFlowServer {
-    type Result = ();
-
-    fn handle(&mut self, msg: UpdateNodeOrder, _: &mut Self::Context) {
-        self.node_order = msg.0;
-    }
+#[derive(Debug, Serialize, Deserialize)]
+pub struct WebSocketSettings {
+    pub update_rate: u32,
 }
 
-#[derive(Clone)]
 pub struct SocketFlowServer {
     app_state: Arc<AppState>,
+    settings: Arc<RwLock<Settings>>,
+    connection_alive: bool,
+    update_handle: Option<SpawnHandle>,
+    heartbeat_handle: Option<SpawnHandle>,
     last_heartbeat: Instant,
-    node_order: Vec<String>, // Store node IDs in order for binary updates
-    settings: Arc<RwLock<crate::config::Settings>>,
 }
 
 impl Actor for SocketFlowServer {
     type Context = ws::WebsocketContext<Self>;
 
     fn started(&mut self, ctx: &mut Self::Context) {
-        info!("[WS] WebSocket connection established");
-        if let Ok(settings) = self.settings.try_read() {
-            if settings.server_debug.enabled {
-                info!("[WS] Debug mode enabled");
-                info!("[WS] WebSocket settings: {:?}", settings.websocket);
-            }
-        }
+        info!("[WebSocket] Client connected");
+        
+        // Initialize connection
         self.app_state.increment_connections();
         let current = self.app_state.active_connections.load(std::sync::atomic::Ordering::Relaxed);
-        info!("[WS] Active connections: {}", current);
-        self.heartbeat(ctx);
+        info!("[WebSocket] Active connections: {}", current);
+        
+        // Start heartbeat and position updates
+        self.start_heartbeat(ctx);
         self.start_position_updates(ctx);
     }
 
-    fn stopped(&mut self, _ctx: &mut Self::Context) {
-        info!("[WS] WebSocket connection closed");
+    fn stopped(&mut self, ctx: &mut Self::Context) {
+        info!("[WebSocket] Client disconnected");
+        
+        // Cancel heartbeat
+        if let Some(handle) = self.heartbeat_handle.take() {
+            ctx.cancel_future(handle);
+        }
+        
+        // Cancel position updates
+        if let Some(handle) = self.update_handle.take() {
+            ctx.cancel_future(handle);
+        }
+        
+        // Decrement connection count
         self.app_state.decrement_connections();
         let current = self.app_state.active_connections.load(std::sync::atomic::Ordering::Relaxed);
-        info!("[WS] Remaining active connections: {}", current);
+        info!("[WebSocket] Remaining active connections: {}", current);
     }
 }
 
-impl Handler<SendMessage> for SocketFlowServer {
-    type Result = ();
-
-    fn handle(&mut self, msg: SendMessage, ctx: &mut Self::Context) {
-        if let Ok(settings) = self.settings.try_read() {
-            if settings.server_debug.enabled {
-                info!("[WS] Sending message: {}", msg.0);
-            }
+impl SocketFlowServer {
+    pub fn new(app_state: Arc<AppState>, settings: Arc<RwLock<Settings>>) -> Self {
+        Self {
+            app_state,
+            settings,
+            connection_alive: true,
+            update_handle: None,
+            heartbeat_handle: None,
+            last_heartbeat: Instant::now(),
         }
-        ctx.text(msg.0);
     }
-}
 
-impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer {
-    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
-        match msg {
-            Ok(ws::Message::Ping(msg)) => {
-                if let Ok(settings) = self.settings.try_read() {
-                    if settings.server_debug.enable_websocket_debug {
-                        info!("[WS] Received ping message");
-                    }
-                }
-                self.last_heartbeat = Instant::now();
-                ctx.pong(&msg);
-            }
-            Ok(ws::Message::Pong(_)) => {
-                if let Ok(settings) = self.settings.try_read() {
-                    if settings.server_debug.enable_websocket_debug {
-                        info!("[WS] Received pong message");
-                    }
-                }
-                self.last_heartbeat = Instant::now();
-            }
-            Ok(ws::Message::Text(text)) => {
-                if let Ok(settings) = self.settings.try_read() {
-                    if settings.server_debug.enabled {
-                        info!("[WS] Received text message: {}", text);
-                    }
-                }
-                match serde_json::from_str::<Message>(&text) {
-                    Ok(message) => {
-                        let this = self.clone();
-                        let settings = self.settings.clone();
-                        let fut = async move {
-                            this.handle_message(message).await
-                        };
-                        ctx.spawn(actix::fut::wrap_future(fut).map(move |response, _, ctx: &mut ws::WebsocketContext<SocketFlowServer>| {
-                            match response {
-                                WebSocketResponse::Text(text) => {
-                                    if let Ok(settings) = settings.try_read() {
-                                        if settings.server_debug.enabled {
-                                            info!("[WS] Sending text response: {}", text);
-                                        }
-                                    }
-                                    ctx.text(text);
-                                }
-                                WebSocketResponse::Binary(data) => {
-                                    if let Ok(settings) = settings.try_read() {
-                                        if settings.server_debug.enabled {
-                                            info!("[WS] Sending binary response: {} bytes", data.len());
-                                        }
-                                    }
-                                    ctx.binary(data);
-                                }
-                                WebSocketResponse::None => {
-                                    if let Ok(settings) = settings.try_read() {
-                                        if settings.server_debug.enabled {
-                                            info!("[WS] No response to send");
-                                        }
-                                    }
-                                }
-                            }
-                        }));
-                    }
-                    Err(e) => error!("[WS] Failed to parse message: {}", e),
-                }
-            }
-            Ok(ws::Message::Binary(data)) => {
-                let settings = self.settings.clone();
-                let fut = async move {
-                    let settings = settings.read().await;
-                    let debug_enabled = settings.server_debug.enabled;
-                    if debug_enabled {
-                        info!("[WS] Received binary message of size: {}", data.len());
-                        if settings.server_debug.log_binary_headers {
-                            info!("[WS] Binary message first 32 bytes: {:?}", &data.get(..32.min(data.len())));
-                        }
-                    }
-                    // Process binary message
-                };
-                ctx.spawn(actix::fut::wrap_future(fut));
-            }
-            Ok(ws::Message::Close(reason)) => {
-                info!("[WS] WebSocket closing with reason: {:?}", reason);
-                ctx.close(reason);
-                ctx.stop();
-            }
-            Err(e) => {
-                error!("[WS] WebSocket protocol error: {}", e);
+    fn start_heartbeat(&mut self, ctx: &mut <Self as Actor>::Context) {
+        // Cancel existing heartbeat if any
+        if let Some(handle) = self.heartbeat_handle.take() {
+            ctx.cancel_future(handle);
+        }
+
+        // Start heartbeat interval
+        let handle = ctx.run_interval(Duration::from_secs(HEARTBEAT_INTERVAL), |actor, ctx| {
+            if Instant::now().duration_since(actor.last_heartbeat) > Duration::from_secs(MAX_CLIENT_TIMEOUT) {
+                warn!("[WebSocket] Client heartbeat timeout - last heartbeat: {:?} ago", 
+                    Instant::now().duration_since(actor.last_heartbeat));
+                actor.connection_alive = false;
                 ctx.stop();
+                return;
             }
-            _ => (),
-        }
-    }
-}
 
-impl SocketFlowServer {
-    const POSITION_UPDATE_INTERVAL: Duration = Duration::from_millis(16); // ~60fps
+            // Send ping with timestamp for latency tracking
+            let timestamp = Instant::now().elapsed().as_millis().to_string();
+            debug!("[WebSocket] Sending ping with timestamp: {}", timestamp);
+            ctx.ping(timestamp.as_bytes());
+        });
 
-    pub fn new(app_state: Arc<AppState>, settings: Arc<RwLock<crate::config::Settings>>) -> Self {
-        Self {
-            app_state,
-            last_heartbeat: Instant::now(),
-            node_order: Vec::new(),
-            settings,
-        }
+        self.heartbeat_handle = Some(handle);
     }
 
-    fn start_position_updates(&self, ctx: &mut ws::WebsocketContext<Self>) {
+    fn start_position_updates(&mut self, ctx: &mut <Self as Actor>::Context) {
+        // Cancel existing interval if any
+        if let Some(handle) = self.update_handle.take() {
+            ctx.cancel_future(handle);
+        }
+
+        // Clone Arc references for the interval closure
         let app_state = self.app_state.clone();
         let settings = self.settings.clone();
 
-        ctx.run_interval(Self::POSITION_UPDATE_INTERVAL, {
-            let app_state = app_state.clone();
-            let settings = settings.clone();
-            move |_, ctx| {
-                let app_state_inner = app_state.clone();
-                let settings_inner = settings.clone();
-                let fut = async move {
-                    let graph = app_state_inner.graph_service.graph_data.read().await;
-                    let binary_nodes: Vec<BinaryNodeData> = graph.nodes.iter()
-                        .map(|node| BinaryNodeData::from_node_data(&node.data))
-                        .collect();
+        // Spawn a future to get the current update rate
+        let fut = async move {
+            let settings = settings.read().await;
+            settings.system.websocket.update_rate
+        };
+
+        // Convert to actix future and handle it
+        let fut = fut.into_actor(self);
+        ctx.spawn(fut.map(|update_rate, actor, ctx| {
+            // Calculate update interval based on rate
+            let update_interval = Duration::from_millis((1000.0 / update_rate as f64) as u64);
+            
+            // Set up new interval
+            let handle = ctx.run_interval(update_interval, move |actor, ctx| {
+                if !actor.connection_alive {
+                    ctx.stop();
+                    return;
+                }
 
+                // Get current node positions and velocities
+                let app_state_clone = app_state.clone();
+                
+                // Spawn a future to get positions
+                let fut = async move {
+                    let nodes = app_state_clone.graph_service.get_node_positions().await;
+                    
                     // Create binary message
-                    let version: i32 = 1;
-                    let mut buffer = Vec::with_capacity(4 + binary_nodes.len() * std::mem::size_of::<BinaryNodeData>());
+                    let mut buffer = Vec::with_capacity(VERSION_HEADER_SIZE + nodes.len() * NODE_DATA_SIZE);
                     
-                    // Write version header (4 bytes)
-                    buffer.extend_from_slice(&version.to_le_bytes());
+                    // Write version header
+                    buffer.extend_from_slice(&BINARY_PROTOCOL_VERSION.to_le_bytes());
                     
                     // Write node data
-                    let node_count = binary_nodes.len();
-                    for node in &binary_nodes {
-                        buffer.extend_from_slice(&node.position[0].to_le_bytes());
-                        buffer.extend_from_slice(&node.position[1].to_le_bytes());
-                        buffer.extend_from_slice(&node.position[2].to_le_bytes());
-                        buffer.extend_from_slice(&node.velocity[0].to_le_bytes());
-                        buffer.extend_from_slice(&node.velocity[1].to_le_bytes());
-                        buffer.extend_from_slice(&node.velocity[2].to_le_bytes());
+                    for node in nodes {
+                        // Position (x, y, z)
+                        buffer.extend_from_slice(&node.data.position[0].to_le_bytes());
+                        buffer.extend_from_slice(&node.data.position[1].to_le_bytes());
+                        buffer.extend_from_slice(&node.data.position[2].to_le_bytes());
+                        
+                        // Velocity (x, y, z)
+                        buffer.extend_from_slice(&node.data.velocity[0].to_le_bytes());
+                        buffer.extend_from_slice(&node.data.velocity[1].to_le_bytes());
+                        buffer.extend_from_slice(&node.data.velocity[2].to_le_bytes());
                     }
-
-                    if let Ok(settings) = settings_inner.try_read() {
-                        if settings.server_debug.enabled && settings.server_debug.log_binary_headers {
-                            info!("[WS] Sending position update: {} nodes, {} bytes", 
-                                node_count, buffer.len());
-                        }
-                    }
-
+                    
                     buffer
                 };
-
-                ctx.spawn(actix::fut::wrap_future(fut).map(|buffer, _, ctx: &mut ws::WebsocketContext<SocketFlowServer>| {
+                
+                // Convert the future to an actix future and handle it
+                let fut = fut.into_actor(actor);
+                ctx.spawn(fut.map(|buffer, _actor, ctx| {
                     ctx.binary(buffer);
                 }));
-            }
-        });
-    }
+            });
 
-    fn heartbeat(&self, ctx: &mut ws::WebsocketContext<Self>) {
-        let settings = self.settings.clone();
-        ctx.run_interval(HEARTBEAT_INTERVAL, move |act, ctx| {
-            if let Ok(settings_guard) = settings.try_read() {
-                let time_since_last = Instant::now().duration_since(act.last_heartbeat);
-                let heartbeat_timeout = Duration::from_millis(settings_guard.websocket.heartbeat_timeout);
-                
-                if settings_guard.server_debug.enable_websocket_debug {
-                    info!("[WS] Heartbeat check - Time since last: {:?}", time_since_last);
-                }
-                
-                if time_since_last > heartbeat_timeout {
-                    warn!("[WS] Client heartbeat timeout - last heartbeat: {:?} ago", time_since_last);
-                    if time_since_last > MAX_CLIENT_TIMEOUT {
-                        warn!("[WS] Client exceeded maximum timeout, closing connection");
-                        ctx.stop();
-                        return;
-                    }
-                }
-                
-                // Send ping with timestamp for latency tracking
-                let timestamp = Instant::now().elapsed().as_millis().to_string();
-                if settings_guard.server_debug.enable_websocket_debug {
-                    info!("[WS] Sending ping with timestamp: {}", timestamp);
-                }
-                ctx.ping(timestamp.as_bytes());
-            } else {
-                error!("[WS] Failed to acquire settings lock in heartbeat");
-            }
-        });
+            actor.update_handle = Some(handle);
+        }));
     }
+}
 
-    async fn handle_message(&self, message: Message) -> WebSocketResponse {
-        let settings = self.settings.read().await;
-        let debug_enabled = settings.server_debug.enabled;
-        let log_binary = debug_enabled && settings.server_debug.log_binary_headers;
-        let log_json = debug_enabled && settings.server_debug.log_full_json;
-        
-        match message {
-            Message::BinaryPositionUpdate { nodes } => {
-                if log_binary {
-                    info!("[WS] Binary position update with {} nodes", nodes.len());
-                }
-                WebSocketResponse::None
-            },
-            Message::UpdatePositions(update_msg) => {
-                if log_json {
-                    info!("[WS] Update positions message: {:?}", update_msg);
-                }
-                WebSocketResponse::None
-            },
-            Message::InitialData { graph } => {
-                if log_json {
-                    info!("[WS] Initial data message with graph: {:?}", graph);
-                }
-                WebSocketResponse::None
-            },
-            Message::SimulationModeSet { mode } => {
-                info!("[WS] Simulation mode set to: {}", mode);
-                WebSocketResponse::None
-            },
-            Message::RequestInitialData => {
-                info!("[WS] Received request for initial data");
-                let graph = self.app_state.graph_service.graph_data.read().await;
-                let initial_data = Message::InitialData { 
-                    graph: (*graph).clone() 
-                };
-                
-                match serde_json::to_string(&initial_data) {
-                    Ok(message) => {
-                        if log_json {
-                            info!("[WS] Full JSON message: {}", message);
-                        }
-                        WebSocketResponse::Text(message)
-                    }
-                    Err(e) => {
-                        error!("[WS] Failed to serialize initial data: {}", e);
-                        WebSocketResponse::None
-                    }
+impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer {
+    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut <Self as Actor>::Context) {
+        if !self.connection_alive {
+            ctx.stop();
+            return;
+        }
+
+        match msg {
+            Ok(ws::Message::Binary(bin)) => {
+                // Validate message size
+                if bin.len() > MAX_MESSAGE_SIZE {
+                    error!("[WebSocket] Message too large: {} bytes", bin.len());
+                    ctx.text(json!({
+                        "error": format!("Message exceeds maximum size of {} bytes", MAX_MESSAGE_SIZE)
+                    }).to_string());
+                    return;
                 }
-            },
-            Message::EnableBinaryUpdates => {
-                info!("[WS] Binary updates enabled");
-                let graph = self.app_state.graph_service.graph_data.read().await;
-                let binary_nodes: Vec<BinaryNodeData> = graph.nodes.iter()
-                    .map(|node| BinaryNodeData::from_node_data(&node.data))
-                    .collect();
 
-                // Create binary message
-                let version: i32 = 1; // Protocol version
-                let mut buffer = Vec::with_capacity(4 + binary_nodes.len() * std::mem::size_of::<BinaryNodeData>());
-                
-                // Write version header (4 bytes)
-                buffer.extend_from_slice(&version.to_le_bytes());
-                
-                // Write node data
-                let node_count = binary_nodes.len();
-                for node in &binary_nodes {
-                    // Write position (12 bytes)
-                    buffer.extend_from_slice(&node.position[0].to_le_bytes());
-                    buffer.extend_from_slice(&node.position[1].to_le_bytes());
-                    buffer.extend_from_slice(&node.position[2].to_le_bytes());
-                    
-                    // Write velocity (12 bytes)
-                    buffer.extend_from_slice(&node.velocity[0].to_le_bytes());
-                    buffer.extend_from_slice(&node.velocity[1].to_le_bytes());
-                    buffer.extend_from_slice(&node.velocity[2].to_le_bytes());
+                // Validate binary message structure
+                if bin.len() < VERSION_HEADER_SIZE || 
+                   (bin.len() - VERSION_HEADER_SIZE) % NODE_DATA_SIZE != 0 {
+                    error!("[WebSocket] Malformed binary message: length {} is invalid", bin.len());
+                    ctx.text(json!({
+                        "error": "Malformed binary message: invalid length"
+                    }).to_string());
+                    return;
                 }
 
-                if log_binary {
-                    info!("[WS] Sending binary update: {} nodes, {} bytes", 
-                        node_count, buffer.len());
-                    info!("[WS] Binary header: version={}", version);
+                // Read version header
+                let version = i32::from_le_bytes(bin[..VERSION_HEADER_SIZE].try_into().unwrap());
+                if version != BINARY_PROTOCOL_VERSION {
+                    error!("[WebSocket] Invalid protocol version: {}", version);
+                    ctx.text(json!({
+                        "error": format!("Invalid protocol version: {}", version)
+                    }).to_string());
+                    return;
                 }
 
-                WebSocketResponse::Binary(buffer)
-            },
-            Message::SetSimulationMode { mode } => {
-                info!("[WS] Setting simulation mode to: {}", mode);
-                match serde_json::to_string(&Message::SimulationModeSet { mode }) {
-                    Ok(message) => {
-                        if log_json {
-                            info!("[WS] Full JSON message: {}", message);
+                // Process node data
+                let node_count = (bin.len() - VERSION_HEADER_SIZE) / NODE_DATA_SIZE;
+                let mut positions = Vec::with_capacity(node_count);
+                
+                for i in 0..node_count {
+                    let offset = VERSION_HEADER_SIZE + i * NODE_DATA_SIZE;
+                    let mut position = [0.0f32; 3];
+                    
+                    for j in 0..3 {
+                        let start = offset + j * std::mem::size_of::<f32>();
+                        let end = start + std::mem::size_of::<f32>();
+                        
+                        match bin[start..end].try_into() {
+                            Ok(bytes) => {
+                                position[j] = f32::from_le_bytes(bytes);
+                                if !position[j].is_finite() {
+                                    error!("[WebSocket] Invalid float value at position {}, component {}: {}", 
+                                        i, j, position[j]);
+                                    ctx.text(json!({
+                                        "error": format!("Invalid float value at position {}, component {}", i, j)
+                                    }).to_string());
+                                    return;
+                                }
+                            },
+                            Err(e) => {
+                                error!("[WebSocket] Failed to convert bytes to float at position {}, component {}: {}", 
+                                    i, j, e);
+                                ctx.text(json!({
+                                    "error": format!("Failed to convert bytes to float at position {}, component {}", i, j)
+                                }).to_string());
+                                return;
+                            }
                         }
-                        WebSocketResponse::Text(message)
-                    }
-                    Err(e) => {
-                        error!("[WS] Failed to serialize simulation mode: {}", e);
-                        WebSocketResponse::None
                     }
+
+                    positions.push(position);
                 }
+
+                debug!("[WebSocket] Successfully processed {} node position updates", positions.len());
+            }
+            Ok(ws::Message::Close(reason)) => {
+                info!("[WebSocket] Client disconnected: {:?}", reason);
+                self.connection_alive = false;
+                ctx.close(reason);
+                ctx.stop();
+            }
+            Ok(ws::Message::Ping(msg)) => {
+                debug!("[WebSocket] Received ping");
+                self.last_heartbeat = Instant::now();
+                ctx.pong(&msg);
             },
-            Message::Ping => {
-                info!("[WS] Received ping");
-                WebSocketResponse::Text("pong".to_string())
+            Ok(ws::Message::Pong(_)) => {
+                debug!("[WebSocket] Received pong");
+                self.last_heartbeat = Instant::now();
             },
-            Message::Pong => {
-                info!("[WS] Received pong");
-                WebSocketResponse::None
+            Err(e) => {
+                error!("[WebSocket] Protocol error: {}", e);
+                self.connection_alive = false;
+                ctx.stop();
             }
+            _ => ()
         }
     }
 }
 
-pub async fn ws_handler(
+pub async fn socket_flow_handler(
     req: HttpRequest,
     stream: web::Payload,
     app_state: web::Data<AppState>,
-    settings: web::Data<Arc<RwLock<crate::config::Settings>>>,
+    settings: web::Data<Arc<RwLock<Settings>>>,
 ) -> Result<HttpResponse, Error> {
-    info!("[WS] New WebSocket connection request from {:?}", req.peer_addr());
-    
     // Enhanced connection debugging
-    if let Ok(settings_guard) = settings.get_ref().try_read() {
-        if settings_guard.server_debug.enabled {
-            info!("[WS] WebSocket connection details:");
-            info!("[WS] Headers: {:?}", req.headers());
-            info!("[WS] URI: {:?}", req.uri());
-            info!("[WS] Method: {:?}", req.method());
-            info!("[WS] Version: {:?}", req.version());
-            if let Some(origin) = req.headers().get("origin") {
-                info!("[WS] Origin: {:?}", origin);
-            }
-            if let Some(protocols) = req.headers().get("sec-websocket-protocol") {
-                info!("[WS] Protocols: {:?}", protocols);
-            }
-            if let Some(upgrade) = req.headers().get("upgrade") {
-                info!("[WS] Upgrade header: {:?}", upgrade);
-            }
-            if let Some(connection) = req.headers().get("connection") {
-                info!("[WS] Connection header: {:?}", connection);
-            }
-            if let Some(key) = req.headers().get("sec-websocket-key") {
-                info!("[WS] WebSocket key: {:?}", key);
-            }
-            if let Some(version) = req.headers().get("sec-websocket-version") {
-                info!("[WS] WebSocket version: {:?}", version);
-            }
-            info!("[WS] Current active connections: {}", app_state.active_connections.load(std::sync::atomic::Ordering::Relaxed));
-        }
-    }
-
+    info!("[WebSocket] New connection request from {:?}", req.peer_addr());
+    debug!("[WebSocket] Headers: {:?}", req.headers());
+    debug!("[WebSocket] URI: {:?}", req.uri());
+    
     // Check connection limits
-    let settings_guard = settings.get_ref().try_read().map_err(|_| {
-        error!("[WS] Failed to acquire settings lock");
-        actix_web::error::ErrorServiceUnavailable("Internal server error")
-    })?;
-    let max_connections = settings_guard.websocket.max_connections;
     let current_connections = app_state.active_connections.load(std::sync::atomic::Ordering::Relaxed);
-    
-    if current_connections >= max_connections {
-        error!("[WS] Connection limit reached: {}/{}", current_connections, max_connections);
-        return Ok(HttpResponse::ServiceUnavailable().finish());
+    if current_connections >= MAX_CONNECTIONS {
+        error!("[WebSocket] Connection limit reached: {}/{}", current_connections, MAX_CONNECTIONS);
+        return Ok(HttpResponse::ServiceUnavailable().json(json!({
+            "error": "Connection limit reached"
+        })));
     }
 
-    let socket_server = SocketFlowServer::new(
+    let server = SocketFlowServer::new(
         app_state.into_inner(),
         settings.get_ref().clone()
     );
     
-    info!("[WS] Starting WebSocket connection");
-    match ws::start(socket_server, &req, stream) {
+    info!("[WebSocket] Starting connection");
+    match ws::start(server, &req, stream) {
         Ok(response) => {
-            info!("[WS] WebSocket connection successfully established");
+            info!("[WebSocket] Connection established successfully");
             Ok(response)
         }
         Err(e) => {
-            error!("[WS] Failed to establish WebSocket connection: {}", e);
+            error!("[WebSocket] Failed to establish connection: {}", e);
             Err(e)
         }
     }
 }
+
+pub async fn get_websocket_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>
+) -> Result<HttpResponse, Error> {
+    let settings = settings.read().await;
+    let ws_settings = WebSocketSettings {
+        update_rate: settings.system.websocket.update_rate,
+    };
+    
+    Ok(HttpResponse::Ok().json(ws_settings))
+}
+
+const MAX_UPDATE_RATE: u32 = 120; // Maximum updates per second
+
+pub async fn update_websocket_settings(
+    settings: web::Data<Arc<RwLock<Settings>>>,
+    new_settings: web::Json<WebSocketSettings>
+) -> Result<HttpResponse, Error> {
+    // Validate update rate
+    if new_settings.update_rate == 0 {
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": "Update rate must be greater than 0"
+        })));
+    }
+
+    if new_settings.update_rate > MAX_UPDATE_RATE {
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": format!("Update rate cannot exceed {} updates per second", MAX_UPDATE_RATE)
+        })));
+    }
+
+    let mut settings = settings.write().await;
+    settings.system.websocket.update_rate = new_settings.update_rate;
+    debug!("[WebSocket] Updated update rate to: {}", new_settings.update_rate);
+    
+    Ok(HttpResponse::Ok().json(new_settings.0))
+}
diff --git a/src/handlers/visualization_handler.rs b/src/handlers/visualization_handler.rs
deleted file mode 100755
index 892b4304..00000000
--- a/src/handlers/visualization_handler.rs
+++ /dev/null
@@ -1,387 +0,0 @@
-use crate::config::Settings;
-use actix_web::{web, HttpResponse};
-use log::{error, info, debug};
-use serde::{Deserialize, Serialize};
-use serde_json::Value;
-use std::collections::HashMap;
-use std::fs;
-use std::path::PathBuf;
-use std::sync::Arc;
-use tokio::sync::RwLock;
-use crate::utils::case_conversion::to_snake_case;
-
-#[derive(Debug, Serialize, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct SettingResponse {
-    pub category: String,
-    pub setting: String,
-    pub value: Value,
-    pub success: bool,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    pub error: Option<String>,
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct CategorySettingsResponse {
-    pub category: String,
-    pub settings: HashMap<String, Value>,
-    pub success: bool,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    pub error: Option<String>,
-}
-
-// Request/Response structures for individual settings
-#[derive(Debug, Serialize, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct SettingValue {
-    pub value: Value,
-}
-
-// Helper function to get setting value from settings object
-fn get_setting_value(settings: &Settings, category: &str, setting: &str) -> Result<Value, String> {
-    debug!("Attempting to get setting value for category: {}, setting: {}", category, setting);
-    
-    // Convert kebab-case URL parameters to appropriate cases
-    let category_snake = to_snake_case(category);
-    let setting_snake = to_snake_case(setting);
-    debug!("Converted category '{}' to snake_case: '{}'", category, category_snake);
-    debug!("Converted setting '{}' to snake_case: '{}'", setting, setting_snake);
-    
-    // Convert settings to Value for easier access
-    let settings_value = match serde_json::to_value(&settings) {
-        Ok(v) => {
-            debug!("Successfully serialized settings to JSON");
-            v
-        },
-        Err(e) => {
-            error!("Failed to serialize settings to JSON: {}", e);
-            return Err(format!("Failed to serialize settings: {}", e));
-        }
-    };
-    
-    debug!("Settings JSON structure: {}", settings_value);
-    
-    // Get category object using snake_case for internal lookup
-    let category_value = match settings_value.get(&category_snake) {
-        Some(v) => {
-            debug!("Found category '{}' in settings", category_snake);
-            v
-        },
-        None => {
-            error!("Category '{}' not found in settings", category_snake);
-            return Err(format!("Category '{}' not found", category));
-        }
-    };
-    
-    // Get setting value using snake_case for internal lookup
-    let setting_value = match category_value.get(&setting_snake) {
-        Some(v) => {
-            debug!("Found setting '{}' in category '{}'", setting_snake, category_snake);
-            v
-        },
-        None => {
-            error!("Setting '{}' not found in category '{}'", setting_snake, category_snake);
-            return Err(format!("Setting '{}' not found in category '{}'", setting, category));
-        }
-    };
-    
-    debug!("Found setting value: {:?}", setting_value);
-    Ok(setting_value.clone())
-}
-
-// Helper function to update setting value in settings object
-fn update_setting_value(settings: &mut Settings, category: &str, setting: &str, value: &Value) -> Result<(), String> {
-    debug!("Attempting to update setting value for category: {}, setting: {}", category, setting);
-    
-    // Convert kebab-case URL parameters to snake_case for internal lookup
-    let category_snake = to_snake_case(category);
-    let setting_snake = to_snake_case(setting);
-    debug!("Converted category '{}' to snake_case: '{}'", category, category_snake);
-    debug!("Converted setting '{}' to snake_case: '{}'", setting, setting_snake);
-    
-    // Convert settings to Value for manipulation, using a reference to avoid moving
-    let mut settings_value = match serde_json::to_value(&*settings) {
-        Ok(v) => {
-            debug!("Successfully serialized settings to JSON");
-            v
-        },
-        Err(e) => {
-            error!("Failed to serialize settings to JSON: {}", e);
-            return Err(format!("Failed to serialize settings: {}", e));
-        }
-    };
-    
-    debug!("Settings JSON structure: {}", settings_value);
-    
-    // Get category object
-    let category_value = match settings_value.get_mut(&category_snake) {
-        Some(v) => {
-            debug!("Found category '{}' in settings", category_snake);
-            v
-        },
-        None => {
-            error!("Category '{}' not found in settings", category_snake);
-            return Err(format!("Category '{}' not found", category));
-        }
-    };
-    
-    // Update setting value
-    if let Some(obj) = category_value.as_object_mut() {
-        obj.insert(setting_snake.to_string(), value.clone());
-        debug!("Updated setting value successfully");
-        
-        // Convert back to Settings
-        match serde_json::from_value(settings_value) {
-            Ok(new_settings) => {
-                debug!("Successfully converted updated JSON back to Settings");
-                *settings = new_settings;
-                Ok(())
-            },
-            Err(e) => {
-                error!("Failed to convert JSON back to Settings: {}", e);
-                Err(format!("Failed to deserialize settings: {}", e))
-            }
-        }
-    } else {
-        error!("Category '{}' is not an object", category_snake);
-        Err(format!("Category '{}' is not an object", category))
-    }
-}
-
-// Helper function to get all settings for a category
-fn get_category_settings_value(settings: &Settings, category: &str) -> Result<Value, String> {
-    debug!("Getting settings for category: {}", category);
-    let value = match category {
-        "nodes" => serde_json::to_value(&settings.nodes)
-            .map_err(|e| format!("Failed to serialize node settings: {}", e))?,
-        "edges" => serde_json::to_value(&settings.edges)
-            .map_err(|e| format!("Failed to serialize edge settings: {}", e))?,
-        "rendering" => serde_json::to_value(&settings.rendering)
-            .map_err(|e| format!("Failed to serialize rendering settings: {}", e))?,
-        "labels" => serde_json::to_value(&settings.labels)
-            .map_err(|e| format!("Failed to serialize labels settings: {}", e))?,
-        "bloom" => serde_json::to_value(&settings.bloom)
-            .map_err(|e| format!("Failed to serialize bloom settings: {}", e))?,
-        "animations" => serde_json::to_value(&settings.animations)
-            .map_err(|e| format!("Failed to serialize animations settings: {}", e))?,
-        "ar" => serde_json::to_value(&settings.ar)
-            .map_err(|e| format!("Failed to serialize ar settings: {}", e))?,
-        "audio" => serde_json::to_value(&settings.audio)
-            .map_err(|e| format!("Failed to serialize audio settings: {}", e))?,
-        "physics" => serde_json::to_value(&settings.physics)
-            .map_err(|e| format!("Failed to serialize physics settings: {}", e))?,
-        "clientDebug" => serde_json::to_value(&settings.client_debug)
-            .map_err(|e| format!("Failed to serialize client debug settings: {}", e))?,
-        "serverDebug" => serde_json::to_value(&settings.server_debug)
-            .map_err(|e| format!("Failed to serialize server debug settings: {}", e))?,
-        "security" => serde_json::to_value(&settings.security)
-            .map_err(|e| format!("Failed to serialize security settings: {}", e))?,
-        "websocket" => serde_json::to_value(&settings.websocket)
-            .map_err(|e| format!("Failed to serialize websocket settings: {}", e))?,
-        "network" => serde_json::to_value(&settings.network)
-            .map_err(|e| format!("Failed to serialize network settings: {}", e))?,
-        "default" => serde_json::to_value(&settings.default)
-            .map_err(|e| format!("Failed to serialize default settings: {}", e))?,
-        "github" => serde_json::to_value(&settings.github)
-            .map_err(|e| format!("Failed to serialize github settings: {}", e))?,
-        _ => return Err(format!("Invalid category: {}", category)),
-    };
-    debug!("Successfully retrieved settings for category: {}", category);
-    Ok(value)
-}
-
-// GET /api/visualization/settings/{category}/{setting}
-pub async fn get_setting(
-    settings: web::Data<Arc<RwLock<Settings>>>,
-    path: web::Path<(String, String)>,
-) -> HttpResponse {
-    let (category, setting) = path.into_inner();
-    info!("Getting setting for category: {}, setting: {}", category, setting);
-    
-    let settings_guard = match settings.read().await {
-        guard => {
-            debug!("Successfully acquired settings read lock");
-            guard
-        }
-    };
-
-    match get_setting_value(&*settings_guard, &category, &setting) {
-        Ok(value) => {
-            debug!("Successfully retrieved setting value: {:?}", value);
-            HttpResponse::Ok().json(SettingResponse {
-                category,
-                setting,
-                value,
-                success: true,
-                error: None,
-            })
-        },
-        Err(e) => {
-            error!("Failed to get setting value: {}", e);
-            HttpResponse::BadRequest().json(SettingResponse {
-                category,
-                setting,
-                value: Value::Null,
-                success: false,
-                error: Some(e),
-            })
-        }
-    }
-}
-
-// PUT /api/visualization/settings/{category}/{setting}
-pub async fn update_setting(
-    settings: web::Data<Arc<RwLock<Settings>>>,
-    path: web::Path<(String, String)>,
-    value: web::Json<Value>,
-) -> HttpResponse {
-    let (category, setting) = path.into_inner();
-    info!("Updating setting for category: {}, setting: {}", category, setting);
-    
-    let mut settings_guard = match settings.write().await {
-        guard => {
-            debug!("Successfully acquired settings write lock");
-            guard
-        }
-    };
-
-    match update_setting_value(&mut *settings_guard, &category, &setting, &value) {
-        Ok(_) => {
-            if let Err(e) = save_settings_to_file(&*settings_guard) {
-                error!("Failed to save settings to file: {}", e);
-                return HttpResponse::InternalServerError().json(SettingResponse {
-                    category,
-                    setting,
-                    value: value.into_inner(),
-                    success: false,
-                    error: Some("Failed to persist settings".to_string()),
-                });
-            }
-            HttpResponse::Ok().json(SettingResponse {
-                category,
-                setting,
-                value: value.into_inner(),
-                success: true,
-                error: None,
-            })
-        },
-        Err(e) => {
-            error!("Failed to update setting value: {}", e);
-            HttpResponse::BadRequest().json(SettingResponse {
-                category,
-                setting,
-                value: value.into_inner(),
-                success: false,
-                error: Some(e),
-            })
-        }
-    }
-}
-
-// GET /api/visualization/settings/{category}
-pub async fn get_category_settings(
-    settings: web::Data<Arc<RwLock<Settings>>>,
-    path: web::Path<String>,
-) -> HttpResponse {
-    let settings_read = settings.read().await;
-    let debug_enabled = settings_read.server_debug.enabled;
-    let log_json = debug_enabled && settings_read.server_debug.log_full_json;
-    
-    let category = path.into_inner();
-    match get_category_settings_value(&settings_read, &category) {
-        Ok(value) => {
-            if log_json {
-                debug!("Category '{}' settings: {}", category, serde_json::to_string_pretty(&value).unwrap_or_default());
-            }
-            let settings_map: HashMap<String, Value> = value.as_object()
-                .map(|m| m.iter().map(|(k, v)| (k.clone(), v.clone())).collect())
-                .unwrap_or_default();
-            
-            HttpResponse::Ok().json(CategorySettingsResponse {
-                category: category.clone(),
-                settings: settings_map,
-                success: true,
-                error: None,
-            })
-        },
-        Err(e) => {
-            error!("Failed to get category settings for '{}': {}", category, e);
-            HttpResponse::NotFound().json(CategorySettingsResponse {
-                category: category.clone(),
-                settings: HashMap::new(),
-                success: false,
-                error: Some(e),
-            })
-        }
-    }
-}
-
-// Register the handlers with the Actix web app
-pub fn config(cfg: &mut web::ServiceConfig) {
-    cfg.route("/settings/{category}/{setting}", web::get().to(get_setting))
-       .route("/settings/{category}/{setting}", web::put().to(update_setting))
-       .route("/settings/{category}", web::get().to(get_category_settings));
-}
-
-fn save_settings_to_file(settings: &Settings) -> std::io::Result<()> {
-    debug!("Attempting to save settings to file");
-    
-    // Use absolute path from environment or default to /app/settings.toml
-    let settings_path = std::env::var("SETTINGS_FILE_PATH")
-        .map(PathBuf::from)
-        .unwrap_or_else(|_| PathBuf::from("/app/settings.toml"));
-    
-    info!("Attempting to save settings to: {:?}", settings_path);
-    
-    // Ensure parent directory exists and is writable
-    if let Some(parent) = settings_path.parent() {
-        match fs::create_dir_all(parent) {
-            Ok(_) => debug!("Created parent directories: {:?}", parent),
-            Err(e) => {
-                error!("Failed to create parent directories: {}", e);
-                return Err(e);
-            }
-        }
-    }
-    
-    // Check if file exists and is writable
-    if settings_path.exists() {
-        match fs::metadata(&settings_path) {
-            Ok(metadata) => {
-                if metadata.permissions().readonly() {
-                    error!("Settings file is read-only: {:?}", settings_path);
-                    return Err(std::io::Error::new(
-                        std::io::ErrorKind::PermissionDenied,
-                        "Settings file is read-only"
-                    ));
-                }
-            }
-            Err(e) => {
-                error!("Failed to check settings file permissions: {}", e);
-                return Err(e);
-            }
-        }
-    }
-    
-    // Convert settings to TOML
-    let toml_string = match toml::to_string_pretty(&settings) {
-        Ok(s) => s,
-        Err(e) => {
-            error!("Failed to serialize settings to TOML: {}", e);
-            return Err(std::io::Error::new(std::io::ErrorKind::Other, e));
-        }
-    };
-    
-    // Write to settings.toml
-    match fs::write(&settings_path, toml_string) {
-        Ok(_) => {
-            info!("Settings saved successfully to: {:?}", settings_path);
-            Ok(())
-        }
-        Err(e) => {
-            error!("Failed to write settings file: {}", e);
-            Err(e)
-        }
-    }
-}
diff --git a/src/lib.rs b/src/lib.rs
index f70de587..4f93a713 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -18,7 +18,7 @@ pub use crate::utils::debug_logging::init_debug_settings;
 pub use crate::utils::gpu_compute::GPUCompute;
 
 // Re-export socket flow handler
-pub use crate::handlers::socket_flow_handler::{SocketFlowServer, ws_handler};
+pub use crate::handlers::socket_flow_handler::{SocketFlowServer, socket_flow_handler};
 
 // Public re-exports
 pub use app_state::AppState;
@@ -38,4 +38,4 @@ pub use handlers::file_handler;
 pub use handlers::graph_handler;
 pub use handlers::perplexity_handler;
 pub use handlers::ragflow_handler;
-pub use handlers::visualization_handler;
+pub use handlers::settings;
diff --git a/src/main.rs b/src/main.rs
index ccfedd78..3862c3f5 100755
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,15 +1,12 @@
-#[macro_use]
-extern crate log;
+use log::{debug, info};
+use env_logger;
 
 use webxr::{
     AppState, Settings,
-    init_debug_settings,
-    file_handler, graph_handler, visualization_handler,
-    handlers::socket_flow_handler,
+    file_handler, graph_handler,
+    handlers::{socket_flow_handler, settings},
     RealGitHubService,
-    RealGitHubPRService, GPUCompute, GraphData,
-    log_data, log_warn,
-    services::file_service::FileService,
+    RealGitHubPRService,
 };
 
 use actix_web::{web, App, HttpServer, middleware};
@@ -18,24 +15,13 @@ use actix_files::Files;
 use std::sync::Arc;
 use tokio::sync::RwLock;
 use dotenvy::dotenv;
-
-// Handler configuration functions
-fn configure_file_handler(cfg: &mut web::ServiceConfig) {
-    cfg.service(web::resource("/fetch").to(file_handler::fetch_and_process_files))
-       .service(web::resource("/content/{file_name}").to(file_handler::get_file_content))
-       .service(web::resource("/refresh").to(file_handler::refresh_graph))
-       .service(web::resource("/update").to(file_handler::update_graph));
-}
-
-fn configure_graph_handler(cfg: &mut web::ServiceConfig) {
-    cfg.service(web::resource("/data").to(graph_handler::get_graph_data))
-       .service(web::resource("/data/paginated").to(graph_handler::get_paginated_graph_data))
-       .service(web::resource("/update").to(graph_handler::update_graph));
-}
+use std::env;
 
 #[actix_web::main]
 async fn main() -> std::io::Result<()> {
     dotenv().ok();
+    env_logger::init();
+    info!("Starting LogseqXR server");
 
     // Load settings first to get the log level
     let settings = match Settings::new() {
@@ -49,121 +35,76 @@ async fn main() -> std::io::Result<()> {
         }
     };
 
-    // Create web::Data instances first
-    let settings_data = web::Data::new(settings.clone());
-
-    // Initialize services
-    let settings_read = settings.read().await;
-    let github_service: Arc<RealGitHubService> = match RealGitHubService::new(
-        (*settings_read).github.token.clone(),
-        (*settings_read).github.owner.clone(),
-        (*settings_read).github.repo.clone(),
-        (*settings_read).github.base_path.clone(),
+    // Load environment variables
+    let github_token = env::var("GITHUB_TOKEN")
+        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, format!("GITHUB_TOKEN not set: {}", e)))?;
+    let github_owner = env::var("GITHUB_OWNER")
+        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, format!("GITHUB_OWNER not set: {}", e)))?;
+    let github_repo = env::var("GITHUB_REPO")
+        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, format!("GITHUB_REPO not set: {}", e)))?;
+    let github_base_path = env::var("GITHUB_BASE_PATH").unwrap_or_else(|_| String::from(""));
+
+    // Initialize GitHub services
+    let github_service = Arc::new(RealGitHubService::new(
+        github_token.clone(),
+        github_owner.clone(),
+        github_repo.clone(),
+        github_base_path.clone(),
         settings.clone(),
-    ) {
-        Ok(service) => Arc::new(service),
-        Err(e) => return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
-    };
-
-    let github_pr_service: Arc<RealGitHubPRService> = match RealGitHubPRService::new(
-        (*settings_read).github.token.clone(),
-        (*settings_read).github.owner.clone(),
-        (*settings_read).github.repo.clone(),
-        (*settings_read).github.base_path.clone()
-    ) {
-        Ok(service) => Arc::new(service),
-        Err(e) => return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
-    };
-    drop(settings_read);
-
-    // Initialize GPU compute
-    log_data!("Initializing GPU compute...");
-    let gpu_compute = match GPUCompute::new(&GraphData::default()).await {
-        Ok(gpu) => {
-            log_data!("GPU initialization successful");
-            Some(gpu)
-        }
-        Err(e) => {
-            log_warn!("Failed to initialize GPU: {}. Falling back to CPU computations.", e);
-            None
-        }
-    };
-
-    // Initialize app state
-    let app_state = web::Data::new(AppState::new(
+    ).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize GitHub service: {}", e)))?);
+
+    let github_pr_service = Arc::new(RealGitHubPRService::new(
+        github_token,
+        github_owner,
+        github_repo,
+        github_base_path,
+    ).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize GitHub PR service: {}", e)))?);
+    
+    // Optional services
+    let perplexity_service = None; // Initialize if needed
+    let ragflow_service = None; // Initialize if needed
+    let gpu_compute = None; // Initialize if needed
+    
+    // Create AppState with initialized services
+    let app_state: web::Data<AppState> = web::Data::new(AppState::new(
         settings.clone(),
-        github_service.clone(),
-        None,
-        None,
+        github_service,
+        perplexity_service,
+        ragflow_service,
         gpu_compute,
-        "default_conversation".to_string(),
-        github_pr_service.clone(),
-    ));
-
-    // Initialize debug settings
-    let (debug_enabled, websocket_debug, data_debug) = {
-        let settings_read = settings.read().await;
-        let debug_settings = (
-            (*settings_read).server_debug.enabled,
-            (*settings_read).server_debug.enable_websocket_debug,
-            (*settings_read).server_debug.enable_data_debug,
-        );
-        debug_settings
-    };
-
-    // Initialize our debug logging system
-    init_debug_settings(debug_enabled, websocket_debug, data_debug);
+        String::from("default"), // ragflow_conversation_id
+        github_pr_service,
+    ).await);
 
-    // Initialize local storage and fetch files from GitHub
-    info!("Initializing local storage and fetching files from GitHub...");
-    if let Err(e) = FileService::initialize_local_storage(&*github_service, settings.clone()).await {
-        error!("Failed to initialize local storage: {}", e);
-        return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize local storage: {}", e)));
-    }
-    info!("Local storage initialization complete");
-
-    // Start the server
-    let bind_address = {
-        let settings_read = settings.read().await;
-        format!("{}:{}", (*settings_read).network.bind_address, (*settings_read).network.port)
-    };
-
-    log_data!("Starting HTTP server on {}", bind_address);
+    // Use PORT env var with fallback to 3001 as specified in docs
+    let port = env::var("PORT").unwrap_or_else(|_| "3001".to_string());
+    let bind_addr = format!("0.0.0.0:{}", port);
+    info!("Binding to {}", bind_addr);
 
+    // Configure app with services
     HttpServer::new(move || {
-        // Configure CORS
-        let cors = Cors::default()
-            .allow_any_origin()
-            .allow_any_method()
-            .allow_any_header()
-            .max_age(3600)
-            .supports_credentials();
-
         App::new()
+            .wrap(Cors::default()
+                .allow_any_origin()
+                .allow_any_method()
+                .allow_any_header()
+                .max_age(3600))
             .wrap(middleware::Logger::default())
-            .wrap(cors)
-            .wrap(middleware::Compress::default())
-            .app_data(settings_data.clone())
             .app_data(app_state.clone())
-            .app_data(web::Data::new(github_service.clone()))
-            .app_data(web::Data::new(github_pr_service.clone()))
             .service(
                 web::scope("/api")
-                    .service(web::scope("/files").configure(configure_file_handler))
-                    .service(web::scope("/graph").configure(configure_graph_handler))
-                    .service(web::scope("/visualization").configure(visualization_handler::config))
+                    .service(web::scope("/files").configure(file_handler::config))
+                    .service(web::scope("/graph").configure(graph_handler::config))
+                    .configure(settings::config)
             )
             .service(
                 web::resource("/wss")
                     .app_data(web::PayloadConfig::new(1 << 25))  // 32MB max payload
-                    .to(socket_flow_handler::ws_handler)
+                    .route(web::get().to(socket_flow_handler::socket_flow_handler))
             )
-            .service(Files::new("/", "/app/client").index_file("index.html"))
+            .service(Files::new("/", "data/public/dist").index_file("index.html"))
     })
-    .bind(&bind_address)?
+    .bind(bind_addr)?
     .run()
-    .await?;
-
-    log_data!("HTTP server stopped");
-    Ok(())
+    .await
 }
diff --git a/src/services/file_service.rs b/src/services/file_service.rs
index 9127c3f0..6e828244 100755
--- a/src/services/file_service.rs
+++ b/src/services/file_service.rs
@@ -167,7 +167,7 @@ impl GitHubService for RealGitHubService {
         };
 
         let settings = self.settings.read().await;
-        let debug_enabled = settings.server_debug.enabled;
+        let debug_enabled = settings.system.debug.enabled;
         
         let mut markdown_files = Vec::new();
         
diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
index 89cabe49..d26dbfd2 100755
--- a/src/services/graph_service.rs
+++ b/src/services/graph_service.rs
@@ -2,7 +2,7 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use std::collections::{HashMap, HashSet};
 use actix_web::web;
-use log::{info, warn};
+use log::{info, warn, error};
 use rand::Rng;
 use serde_json;
 
@@ -14,6 +14,7 @@ use crate::app_state::AppState;
 use crate::utils::gpu_compute::GPUCompute;
 use crate::models::simulation_params::{SimulationParams, SimulationPhase, SimulationMode};
 use crate::models::pagination::PaginatedGraphData;
+use crate::services::file_service::FileService;
 
 #[derive(Clone)]
 pub struct GraphService {
@@ -29,7 +30,7 @@ impl GraphService {
         // Start simulation loop
         let graph_data = graph_service.graph_data.clone();
         tokio::spawn(async move {
-            let mut params = SimulationParams {
+            let params = SimulationParams {
                 iterations: 1,  // One iteration per frame
                 spring_length: 100.0,  // Default spring length
                 spring_strength: 0.1,  // Gentler forces for continuous updates
@@ -42,17 +43,82 @@ impl GraphService {
             };
 
             loop {
-                // Update positions
-                let mut graph = graph_data.write().await;
-                if let Err(e) = Self::calculate_layout_cpu(
-                    &mut graph,
-                    params.iterations,
-                    params.spring_strength,
-                    params.damping
-                ) {
-                    warn!("[Graph] Error updating positions: {}", e);
+                // Calculate forces with minimal lock time
+                let forces = {
+                    let graph = graph_data.read().await;
+                    Self::calculate_forces(&graph, params.spring_strength)
+                };
+
+                if let Some(forces) = forces {
+                    // Apply forces with minimal lock time
+                    let mut graph = graph_data.write().await;
+                    if let Err(e) = Self::apply_forces(
+                        &mut graph,
+                        &forces,
+                        params.damping
+                    ) {
+                        warn!("[Graph] Error applying forces: {}", e);
+                    }
+                }
+
+                // Sleep for ~16ms (60fps)
+                tokio::time::sleep(tokio::time::Duration::from_millis(16)).await;
+            }
+        });
+
+        graph_service
+    }
+
+    pub async fn new_with_metadata(metadata: &MetadataStore) -> Self {
+        // Create graph service with initial graph from metadata
+        let mut graph = match Self::build_graph_from_metadata(metadata).await {
+            Ok(g) => g,
+            Err(e) => {
+                warn!("Failed to build graph from metadata: {}, starting with empty graph", e);
+                GraphData::new()
+            }
+        };
+
+        // Initialize positions
+        Self::initialize_random_positions(&mut graph);
+
+        let graph_service = Self {
+            graph_data: Arc::new(RwLock::new(graph)),
+        };
+
+        // Start simulation loop
+        let graph_data = graph_service.graph_data.clone();
+        tokio::spawn(async move {
+            let params = SimulationParams {
+                iterations: 1,  // One iteration per frame
+                spring_length: 100.0,  // Default spring length
+                spring_strength: 0.1,  // Gentler forces for continuous updates
+                repulsion: 50.0,  // Reduced repulsion
+                attraction: 0.5,  // Reduced attraction
+                damping: 0.8,  // More damping for stability
+                time_step: 0.016,  // 60fps
+                phase: SimulationPhase::Dynamic,
+                mode: SimulationMode::Local,  // Use CPU for continuous updates
+            };
+
+            loop {
+                // Calculate forces with minimal lock time
+                let forces = {
+                    let graph = graph_data.read().await;
+                    Self::calculate_forces(&graph, params.spring_strength)
+                };
+
+                if let Some(forces) = forces {
+                    // Apply forces with minimal lock time
+                    let mut graph = graph_data.write().await;
+                    if let Err(e) = Self::apply_forces(
+                        &mut graph,
+                        &forces,
+                        params.damping
+                    ) {
+                        warn!("[Graph] Error applying forces: {}", e);
+                    }
                 }
-                drop(graph); // Release lock
 
                 // Sleep for ~16ms (60fps)
                 tokio::time::sleep(tokio::time::Duration::from_millis(16)).await;
@@ -62,70 +128,60 @@ impl GraphService {
         graph_service
     }
 
-    pub async fn build_graph_from_metadata(metadata: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
+    pub async fn build_graph_from_metadata(metadata_store: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
         let mut graph = GraphData::new();
         let mut edge_map = HashMap::new();
 
+        info!("Building graph from {} metadata entries", metadata_store.len());
+
         // First pass: Create nodes from files in metadata
         let mut valid_nodes = HashSet::new();
-        for file_name in metadata.keys() {
-            let node_id = file_name.trim_end_matches(".md").to_string();
-            valid_nodes.insert(node_id);
-        }
-
-        // Create nodes for all valid node IDs
-        for node_id in &valid_nodes {
+        for (file_path, metadata) in metadata_store.iter() {
+            // Create node for file
+            let node_id = file_path.clone();
             let mut node = Node::new(node_id.clone());
             
-            // Get metadata for this node
-            if let Some(metadata) = metadata.get(&format!("{}.md", node_id)) {
-                node.size = Some(metadata.node_size as f32);
-                node.file_size = metadata.file_size as u64;
-                node.label = node_id.clone(); // Set label to node ID (filename without .md)
-                
-                // Add metadata fields to node's metadata map
-                node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
-                node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
-                node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
-            }
+            // Set node properties from metadata
+            node.label = node_id.clone();
+            node.size = Some(metadata.node_size as f32);
+            node.file_size = metadata.file_size as u64;
+            
+            // Add metadata fields
+            node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
+            node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
+            node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
             
+            // Add node to graph
             graph.nodes.push(node);
+            valid_nodes.insert(node_id);
         }
 
-        // Store metadata in graph
-        graph.metadata = metadata.clone();
-
-        // Second pass: Create edges from topic counts
-        for (source_file, metadata) in metadata.iter() {
-            let source_id = source_file.trim_end_matches(".md").to_string();
-            
-            for (target_file, count) in &metadata.topic_counts {
-                let target_id = target_file.trim_end_matches(".md").to_string();
-                
-                // Only create edge if both nodes exist and they're different
-                if source_id != target_id && valid_nodes.contains(&target_id) {
-                    let edge_key = if source_id < target_id {
-                        (source_id.clone(), target_id.clone())
-                    } else {
-                        (target_id.clone(), source_id.clone())
-                    };
-
-                    edge_map.entry(edge_key)
-                        .and_modify(|weight| *weight += *count as f32)
-                        .or_insert(*count as f32);
+        // Second pass: Create edges from hyperlinks
+        for (file_path, metadata) in metadata_store.iter() {
+            // Process hyperlinks
+            if metadata.hyperlink_count > 0 {
+                // Add edges for each hyperlink
+                for (target_file, count) in &metadata.topic_counts {
+                    // Only create edge if both nodes exist and they're different
+                    if file_path != target_file && valid_nodes.contains(target_file) {
+                        let edge_key = if file_path < target_file {
+                            (file_path.clone(), target_file.clone())
+                        } else {
+                            (target_file.clone(), file_path.clone())
+                        };
+
+                        edge_map.entry(edge_key)
+                            .and_modify(|weight| *weight += *count as f32)
+                            .or_insert(*count as f32);
+                    }
                 }
             }
         }
 
-        // Convert edge map to edges
-        graph.edges = edge_map.into_iter()
-            .map(|((source, target), weight)| {
-                Edge::new(source, target, weight)
-            })
-            .collect();
-
-        // Initialize random positions
-        Self::initialize_random_positions(&mut graph);
+        // Create edges from the edge map
+        for ((source, target), weight) in edge_map {
+            graph.edges.push(Edge::new(source, target, weight));
+        }
 
         info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
         Ok(graph)
@@ -254,97 +310,100 @@ impl GraphService {
             },
             None => {
                 warn!("GPU not available. Falling back to CPU-based layout calculation.");
-                Self::calculate_layout_cpu(graph, params.iterations, params.spring_strength, params.damping)?;
+                // Calculate forces first
+                if let Some(forces) = Self::calculate_forces(graph, params.spring_strength) {
+                    // Then apply them
+                    Self::apply_forces(graph, &forces, params.damping)?;
+                }
                 Ok(())
             }
         }
     }
 
-    fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+    fn calculate_forces(graph: &GraphData, spring_strength: f32) -> Option<Vec<(f32, f32, f32)>> {
         let repulsion_strength = spring_strength * 10000.0;
+        let mut forces = vec![(0.0, 0.0, 0.0); graph.nodes.len()];
         
-        for _ in 0..iterations {
-            // Calculate forces between nodes
-            let mut forces = vec![(0.0, 0.0, 0.0); graph.nodes.len()];
-            
-            // Calculate repulsion forces
-            for i in 0..graph.nodes.len() {
-                for j in i+1..graph.nodes.len() {
-                    let dx = graph.nodes[j].x() - graph.nodes[i].x();
-                    let dy = graph.nodes[j].y() - graph.nodes[i].y();
-                    let dz = graph.nodes[j].z() - graph.nodes[i].z();
+        // Calculate repulsion forces
+        for i in 0..graph.nodes.len() {
+            for j in i+1..graph.nodes.len() {
+                let dx = graph.nodes[j].x() - graph.nodes[i].x();
+                let dy = graph.nodes[j].y() - graph.nodes[i].y();
+                let dz = graph.nodes[j].z() - graph.nodes[i].z();
+                
+                let distance = (dx * dx + dy * dy + dz * dz).sqrt();
+                if distance > 0.0 {
+                    let force = repulsion_strength / (distance * distance);
                     
-                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
-                    if distance > 0.0 {
-                        let force = repulsion_strength / (distance * distance);
-                        
-                        let fx = dx * force / distance;
-                        let fy = dy * force / distance;
-                        let fz = dz * force / distance;
-                        
-                        forces[i].0 -= fx;
-                        forces[i].1 -= fy;
-                        forces[i].2 -= fz;
-                        
-                        forces[j].0 += fx;
-                        forces[j].1 += fy;
-                        forces[j].2 += fz;
-                    }
+                    let fx = dx * force / distance;
+                    let fy = dy * force / distance;
+                    let fz = dz * force / distance;
+                    
+                    forces[i].0 -= fx;
+                    forces[i].1 -= fy;
+                    forces[i].2 -= fz;
+                    
+                    forces[j].0 += fx;
+                    forces[j].1 += fy;
+                    forces[j].2 += fz;
                 }
             }
+        }
 
-            // Calculate spring forces along edges
-            for edge in &graph.edges {
-                // Find indices of source and target nodes
-                let source_idx = graph.nodes.iter().position(|n| n.id == edge.source);
-                let target_idx = graph.nodes.iter().position(|n| n.id == edge.target);
+        // Calculate spring forces along edges
+        for edge in &graph.edges {
+            // Find indices of source and target nodes
+            let source_idx = graph.nodes.iter().position(|n| n.id == edge.source);
+            let target_idx = graph.nodes.iter().position(|n| n.id == edge.target);
+            
+            if let (Some(si), Some(ti)) = (source_idx, target_idx) {
+                let source = &graph.nodes[si];
+                let target = &graph.nodes[ti];
+                
+                let dx = target.x() - source.x();
+                let dy = target.y() - source.y();
+                let dz = target.z() - source.z();
                 
-                if let (Some(si), Some(ti)) = (source_idx, target_idx) {
-                    let source = &graph.nodes[si];
-                    let target = &graph.nodes[ti];
+                let distance = (dx * dx + dy * dy + dz * dz).sqrt();
+                if distance > 0.0 {
+                    // Scale force by edge weight
+                    let force = spring_strength * (distance - 30.0) * edge.weight;
                     
-                    let dx = target.x() - source.x();
-                    let dy = target.y() - source.y();
-                    let dz = target.z() - source.z();
+                    let fx = dx * force / distance;
+                    let fy = dy * force / distance;
+                    let fz = dz * force / distance;
                     
-                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
-                    if distance > 0.0 {
-                        // Scale force by edge weight
-                        let force = spring_strength * (distance - 30.0) * edge.weight;
-                        
-                        let fx = dx * force / distance;
-                        let fy = dy * force / distance;
-                        let fz = dz * force / distance;
-                        
-                        forces[si].0 += fx;
-                        forces[si].1 += fy;
-                        forces[si].2 += fz;
-                        
-                        forces[ti].0 -= fx;
-                        forces[ti].1 -= fy;
-                        forces[ti].2 -= fz;
-                    }
+                    forces[si].0 += fx;
+                    forces[si].1 += fy;
+                    forces[si].2 += fz;
+                    
+                    forces[ti].0 -= fx;
+                    forces[ti].1 -= fy;
+                    forces[ti].2 -= fz;
                 }
             }
+        }
+        
+        Some(forces)
+    }
+
+    fn apply_forces(graph: &mut GraphData, forces: &[(f32, f32, f32)], damping: f32) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+        for (i, node) in graph.nodes.iter_mut().enumerate() {
+            let vx = node.vx() + forces[i].0;
+            let vy = node.vy() + forces[i].1;
+            let vz = node.vz() + forces[i].2;
             
-            // Apply forces and update positions
-            for (i, node) in graph.nodes.iter_mut().enumerate() {
-                let vx = node.vx() + forces[i].0;
-                let vy = node.vy() + forces[i].1;
-                let vz = node.vz() + forces[i].2;
-                
-                let x = node.x() + vx;
-                let y = node.y() + vy;
-                let z = node.z() + vz;
-                
-                node.set_vx(vx * damping);
-                node.set_vy(vy * damping);
-                node.set_vz(vz * damping);
-                
-                node.set_x(x);
-                node.set_y(y);
-                node.set_z(z);
-            }
+            let x = node.x() + vx;
+            let y = node.y() + vy;
+            let z = node.z() + vz;
+            
+            node.set_vx(vx * damping);
+            node.set_vy(vy * damping);
+            node.set_vz(vz * damping);
+            
+            node.set_x(x);
+            node.set_y(y);
+            node.set_z(z);
         }
         Ok(())
     }
@@ -392,4 +451,35 @@ impl GraphService {
             current_page: page as u32,
         })
     }
+
+    pub async fn get_node_positions(&self) -> Vec<Node> {
+        let graph = self.graph_data.read().await;
+        graph.nodes.clone()
+    }
+
+    pub async fn update_graph(&self) -> Result<GraphData, String> {
+        info!("Updating graph data");
+
+        // Load or create metadata
+        let metadata_store = match FileService::load_or_create_metadata() {
+            Ok(store) => store,
+            Err(e) => {
+                error!("Failed to load metadata: {}", e);
+                return Err(format!("Failed to load metadata: {}", e));
+            }
+        };
+
+        info!("Loaded metadata with {} entries", metadata_store.len());
+
+        // Build graph from metadata
+        let graph = match Self::build_graph_from_metadata(&metadata_store).await {
+            Ok(g) => g,
+            Err(e) => {
+                error!("Failed to build graph: {}", e);
+                return Err(format!("Failed to build graph: {}", e));
+            }
+        };
+
+        Ok(graph)
+    }
 }
diff --git a/src/types/metadata.ts b/src/types/metadata.ts
new file mode 100644
index 00000000..3564f050
--- /dev/null
+++ b/src/types/metadata.ts
@@ -0,0 +1,45 @@
+export interface NodeMetadata {
+    name: string;
+    commitAge: number;        // Age in days
+    hyperlinkCount: number;   // Number of hyperlinks
+    importance: number;       // Normalized importance (0-1)
+    position: {
+        x: number;
+        y: number;
+        z: number;
+    };
+}
+
+export interface HologramSettings {
+    enabled: boolean;
+    desktopQuality: 'low' | 'medium' | 'high';
+    xrQuality: 'low' | 'medium';
+    ringCount: number;
+    ringSizes: number[];
+    ringOpacity: number;
+    ringColor: string;
+    ringRotationSpeed: number;
+    enableBuckminster: boolean;
+    buckminsterScale: number;
+    buckminsterOpacity: number;
+    enableGeodesic: boolean;
+    geodesicScale: number;
+    geodesicOpacity: number;
+    enableTriangleSphere: boolean;
+    triangleSphereScale: number;
+    triangleSphereOpacity: number;
+    globalRotationSpeed: number;
+    wireframeThickness: number;
+}
+
+export interface LabelSettings {
+    textRenderingMode: 'sdf' | 'bitmap';
+    textResolution: number;
+    textPadding: number;
+    textOutlineWidth: number;
+    textOutlineColor: string;
+    billboardMode: 'camera' | 'vertical';
+    desktopFontSize: number;
+    enableLabels: boolean;
+    textColor: string;
+}
diff --git a/src/types/xr.ts b/src/types/xr.ts
new file mode 100644
index 00000000..5942600a
--- /dev/null
+++ b/src/types/xr.ts
@@ -0,0 +1,25 @@
+export type XRHandedness = 'left' | 'right' | 'none';
+
+export interface XRHandJoint {
+    position: THREE.BufferAttribute;
+    orientation: THREE.BufferAttribute;
+    radius: number;
+}
+
+export interface XRHand extends THREE.Object3D {
+    joints: {
+        [key: string]: XRHandJoint;
+    };
+}
+
+export interface XRInteractionState {
+    isHolding: boolean;
+    selectedObject: THREE.Object3D | null;
+    interactionDistance: number;
+    lastPinchTime: number;
+}
+
+export interface XRControllerState {
+    left: XRInteractionState;
+    right: XRInteractionState;
+}
diff --git a/src/utils/socket_flow_constants.rs b/src/utils/socket_flow_constants.rs
index 37912967..e84f166e 100644
--- a/src/utils/socket_flow_constants.rs
+++ b/src/utils/socket_flow_constants.rs
@@ -1,24 +1,16 @@
-// Node and graph constants
-pub const NODE_SIZE: f32 = 1.0;
-pub const EDGE_WIDTH: f32 = 0.1;
-pub const MIN_DISTANCE: f32 = 2.0;
-pub const MAX_DISTANCE: f32 = 10.0;
+// WebSocket protocol version
+pub const BINARY_PROTOCOL_VERSION: i32 = 1;
 
-// WebSocket constants - matching nginx configuration
-pub const HEARTBEAT_INTERVAL: u64 = 30; // seconds - matches nginx proxy_connect_timeout
-pub const CLIENT_TIMEOUT: u64 = 60; // seconds - double heartbeat interval for safety
-pub const MAX_CLIENT_TIMEOUT: u64 = 3600; // seconds - matches nginx proxy_read_timeout
-pub const MAX_MESSAGE_SIZE: usize = 100 * 1024 * 1024; // 100MB
-pub const BINARY_CHUNK_SIZE: usize = 64 * 1024; // 64KB
+// WebSocket timing constants (in seconds)
+pub const HEARTBEAT_INTERVAL: u64 = 30;  // Match Cloudflared interval
+pub const MAX_CLIENT_TIMEOUT: u64 = 60;  // Match Cloudflared timeout
 
-// Update rate constants
-pub const POSITION_UPDATE_RATE: u32 = 5; // Hz (matching client's MAX_UPDATES_PER_SECOND)
-pub const METADATA_UPDATE_RATE: u32 = 1; // Hz
+// Binary protocol constants
+pub const FLOATS_PER_NODE: usize = 6;  // x, y, z, vx, vy, vz
+pub const VERSION_HEADER_SIZE: usize = std::mem::size_of::<i32>();
+pub const FLOAT_SIZE: usize = std::mem::size_of::<f32>();
+pub const NODE_DATA_SIZE: usize = FLOAT_SIZE * FLOATS_PER_NODE;
 
-// Binary message constants
-pub const NODE_POSITION_SIZE: usize = 24; // 6 f32s (x,y,z,vx,vy,vz) * 4 bytes
-pub const BINARY_HEADER_SIZE: usize = 4; // 1 f32 for header
-
-// Compression constants
-pub const COMPRESSION_THRESHOLD: usize = 1024; // 1KB
-pub const ENABLE_COMPRESSION: bool = true;
+// Connection limits
+pub const MAX_CONNECTIONS: usize = 100;
+pub const MAX_MESSAGE_SIZE: usize = 32 * 1024 * 1024;  // 32MB
diff --git a/src/utils/socket_flow_messages.rs b/src/utils/socket_flow_messages.rs
index 78df04db..84d76f76 100644
--- a/src/utils/socket_flow_messages.rs
+++ b/src/utils/socket_flow_messages.rs
@@ -105,11 +105,12 @@ impl Node {
     pub fn set_vz(&mut self, val: f32) { self.data.velocity[2] = val; }
 }
 
+// Simple binary format for position/velocity updates
 #[repr(C)]
-#[derive(Debug, Clone, Copy, Pod, Zeroable, Serialize, Deserialize)]
+#[derive(Debug, Clone, Copy, Pod, Zeroable)]
 pub struct BinaryNodeData {
-    pub position: [f32; 3],  // x, y, z
-    pub velocity: [f32; 3],  // vx, vy, vz
+    pub position: [f32; 3],  // x, y, z as f32
+    pub velocity: [f32; 3],  // vx, vy, vz as f32
 }
 
 // Implement DeviceRepr for BinaryNodeData
@@ -127,26 +128,15 @@ impl BinaryNodeData {
     }
 }
 
+// Simple message types for control messages
 #[derive(Debug, Serialize, Deserialize)]
-#[serde(rename_all = "camelCase")]
-pub struct UpdatePositionsMessage {
-    pub nodes: Vec<BinaryNodeData>,
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-#[serde(tag = "type", content = "data")]
-#[serde(rename_all = "kebab-case")]
+#[serde(tag = "type")]
 pub enum Message {
-    UpdatePositions(UpdatePositionsMessage),
-    InitialData { graph: GraphData },
-    BinaryPositionUpdate { nodes: Vec<BinaryNodeData> },
-    SimulationModeSet { mode: String },
-    RequestInitialData,
-    EnableBinaryUpdates,
-    SetSimulationMode { mode: String },
-    Ping,
-    Pong,
+    #[serde(rename = "ping")]
+    Ping { timestamp: u64 },
+    
+    #[serde(rename = "pong")]
+    Pong { timestamp: u64 },
 }
 
 // Forward declarations to avoid circular dependencies
-use crate::models::graph::GraphData;
diff --git a/src/visualization/HologramManager.ts b/src/visualization/HologramManager.ts
new file mode 100644
index 00000000..f1f68e00
--- /dev/null
+++ b/src/visualization/HologramManager.ts
@@ -0,0 +1,210 @@
+import * as THREE from 'three';
+import { HologramSettings } from '../types/metadata';
+import { XRHandedness } from '../types/xr';
+
+export class HologramManager {
+    private readonly hologramGroup: THREE.Group;
+    private readonly geometryCache: Map<string, THREE.BufferGeometry>;
+    private readonly materialCache: Map<string, THREE.Material>;
+    private isXRMode: boolean = false;
+
+    constructor(
+        private readonly scene: THREE.Scene,
+        private readonly camera: THREE.PerspectiveCamera,
+        private settings: HologramSettings
+    ) {
+        this.hologramGroup = new THREE.Group();
+        this.geometryCache = new Map();
+        this.materialCache = new Map();
+        this.scene.add(this.hologramGroup);
+        
+        // Initialize geometries based on quality setting
+        this.initializeGeometries();
+        this.createHolographicStructures();
+    }
+
+    private initializeGeometries(): void {
+        const quality = this.isXRMode ? this.settings.xrQuality : this.settings.desktopQuality;
+        const segments = {
+            low: { ring: 32, sphere: 8 },
+            medium: { ring: 64, sphere: 16 },
+            high: { ring: 128, sphere: 32 }
+        }[quality] || segments.medium;
+
+        // Create and cache geometries
+        this.geometryCache.set('ring', new THREE.TorusGeometry(1, 0.02, segments.ring, segments.ring * 2));
+        this.geometryCache.set('buckminster', new THREE.IcosahedronGeometry(1, quality === 'high' ? 2 : 1));
+        this.geometryCache.set('geodesic', new THREE.IcosahedronGeometry(1, quality === 'low' ? 1 : 2));
+        this.geometryCache.set('triangleSphere', new THREE.SphereGeometry(1, segments.sphere, segments.sphere));
+
+        // Create hologram material
+        const hologramMaterial = new THREE.ShaderMaterial({
+            uniforms: {
+                color: { value: new THREE.Color(this.settings.ringColor) },
+                opacity: { value: this.settings.ringOpacity },
+                time: { value: 0 },
+                pulseSpeed: { value: 1.0 },
+                pulseIntensity: { value: 0.2 }
+            },
+            vertexShader: `
+                varying vec3 vPosition;
+                varying vec2 vUv;
+                void main() {
+                    vPosition = position;
+                    vUv = uv;
+                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+                }
+            `,
+            fragmentShader: `
+                uniform vec3 color;
+                uniform float opacity;
+                uniform float time;
+                uniform float pulseSpeed;
+                uniform float pulseIntensity;
+                varying vec3 vPosition;
+                varying vec2 vUv;
+                
+                void main() {
+                    float pulse = sin(time * pulseSpeed) * pulseIntensity + 1.0;
+                    float edge = 1.0 - smoothstep(0.4, 0.5, abs(vUv.y - 0.5));
+                    vec3 finalColor = color * pulse;
+                    float finalOpacity = opacity * edge;
+                    
+                    #ifdef USE_AR
+                        // Adjust opacity based on distance to camera for AR
+                        float depth = gl_FragCoord.z / gl_FragCoord.w;
+                        finalOpacity *= smoothstep(10.0, 0.0, depth);
+                    #endif
+                    
+                    gl_FragColor = vec4(finalColor, finalOpacity);
+                }
+            `,
+            transparent: true,
+            side: THREE.DoubleSide,
+            depthWrite: false
+        });
+
+        this.materialCache.set('hologram', hologramMaterial);
+    }
+
+    private createHolographicStructures(): void {
+        // Clear existing structures
+        while (this.hologramGroup.children.length > 0) {
+            const child = this.hologramGroup.children[0];
+            this.hologramGroup.remove(child);
+        }
+
+        // Create rings
+        const ringGeometry = this.geometryCache.get('ring')!;
+        const material = this.materialCache.get('hologram')!.clone();
+
+        for (let i = 0; i < this.settings.ringCount; i++) {
+            const ring = new THREE.Mesh(ringGeometry, material.clone());
+            ring.scale.setScalar(this.settings.ringSizes[i] || 20);
+            ring.rotation.x = Math.PI / 2 * i;
+            ring.rotation.y = Math.PI / 4 * i;
+            ring.userData.rotationSpeed = this.settings.ringRotationSpeed * (i + 1);
+            this.hologramGroup.add(ring);
+        }
+
+        // Create geometric structures based on settings
+        if (this.settings.enableBuckminster) {
+            const geometry = this.geometryCache.get('buckminster')!;
+            const mesh = new THREE.Mesh(geometry, material.clone());
+            mesh.scale.setScalar(this.settings.buckminsterScale);
+            mesh.material.uniforms.opacity.value = this.settings.buckminsterOpacity;
+            this.hologramGroup.add(mesh);
+        }
+
+        if (this.settings.enableGeodesic) {
+            const geometry = this.geometryCache.get('geodesic')!;
+            const mesh = new THREE.Mesh(geometry, material.clone());
+            mesh.scale.setScalar(this.settings.geodesicScale);
+            mesh.material.uniforms.opacity.value = this.settings.geodesicOpacity;
+            this.hologramGroup.add(mesh);
+        }
+
+        if (this.settings.enableTriangleSphere) {
+            const geometry = this.geometryCache.get('triangleSphere')!;
+            const mesh = new THREE.Mesh(geometry, material.clone());
+            mesh.scale.setScalar(this.settings.triangleSphereScale);
+            mesh.material.uniforms.opacity.value = this.settings.triangleSphereOpacity;
+            this.hologramGroup.add(mesh);
+        }
+    }
+
+    public setXRMode(enabled: boolean): void {
+        this.isXRMode = enabled;
+        if (enabled) {
+            // Optimize for XR
+            this.hologramGroup.children.forEach(child => {
+                if (child instanceof THREE.Mesh) {
+                    child.material.defines = { USE_AR: '' };
+                    child.material.needsUpdate = true;
+                }
+            });
+        }
+        // Recreate geometries with appropriate quality
+        this.initializeGeometries();
+        this.createHolographicStructures();
+    }
+
+    public update(deltaTime: number): void {
+        // Update hologram animations
+        this.hologramGroup.children.forEach(child => {
+            if (child instanceof THREE.Mesh) {
+                child.rotation.y += (child.userData.rotationSpeed || this.settings.globalRotationSpeed) * deltaTime;
+                if (child.material instanceof THREE.ShaderMaterial) {
+                    child.material.uniforms.time.value += deltaTime;
+                }
+            }
+        });
+    }
+
+    public handleHandInteraction(hand: THREE.XRHand, handedness: XRHandedness): void {
+        if (!this.isXRMode) return;
+
+        // Get index finger tip position
+        const indexTip = hand.joints['index-finger-tip'];
+        if (!indexTip) return;
+
+        // Convert joint position to world space
+        const fingerPosition = new THREE.Vector3()
+            .fromBufferAttribute(indexTip.position as THREE.BufferAttribute, 0)
+            .applyMatrix4(hand.matrixWorld);
+
+        // Check interaction with hologram elements
+        this.hologramGroup.children.forEach(child => {
+            if (child instanceof THREE.Mesh) {
+                const distance = fingerPosition.distanceTo(child.position);
+                if (distance < 0.1) { // 10cm interaction radius
+                    // Increase pulse intensity temporarily
+                    if (child.material instanceof THREE.ShaderMaterial) {
+                        child.material.uniforms.pulseIntensity.value = 0.4;
+                        setTimeout(() => {
+                            child.material.uniforms.pulseIntensity.value = 0.2;
+                        }, 500);
+                    }
+                }
+            }
+        });
+    }
+
+    public updateSettings(settings: Partial<HologramSettings>): void {
+        Object.assign(this.settings, settings);
+        this.createHolographicStructures();
+    }
+
+    public dispose(): void {
+        // Dispose geometries
+        this.geometryCache.forEach(geometry => geometry.dispose());
+        this.geometryCache.clear();
+
+        // Dispose materials
+        this.materialCache.forEach(material => material.dispose());
+        this.materialCache.clear();
+
+        // Remove from scene
+        this.scene.remove(this.hologramGroup);
+    }
+}
diff --git a/src/visualization/MetadataVisualizer.ts b/src/visualization/MetadataVisualizer.ts
new file mode 100644
index 00000000..7b885aa6
--- /dev/null
+++ b/src/visualization/MetadataVisualizer.ts
@@ -0,0 +1,163 @@
+import * as THREE from 'three';
+import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
+import { FontLoader, Font } from 'three/examples/jsm/loaders/FontLoader.js';
+import { NodeMetadata } from '../types/metadata';
+
+export class MetadataVisualizer {
+    private readonly geometries = {
+        SPHERE: new THREE.SphereGeometry(1, 32, 32),
+        ICOSAHEDRON: new THREE.IcosahedronGeometry(1),
+        OCTAHEDRON: new THREE.OctahedronGeometry(1)
+    };
+
+    private font: Font | null = null;
+    private fontLoader: FontLoader;
+    private readonly fontPath = '/fonts/helvetiker_regular.typeface.json';
+    private readonly labelScale = 0.1;
+    private readonly labelHeight = 0.1;
+    private readonly labelGroup: THREE.Group;
+
+    constructor(
+        private readonly camera: THREE.Camera,
+        private readonly settings: any
+    ) {
+        this.fontLoader = new FontLoader();
+        this.loadFont();
+        this.labelGroup = new THREE.Group();
+    }
+
+    private async loadFont(): Promise<void> {
+        try {
+            this.font = await this.fontLoader.loadAsync(this.fontPath);
+        } catch (error) {
+            console.error('Failed to load font:', error);
+        }
+    }
+
+    public async createTextMesh(text: string): Promise<THREE.Mesh | null> {
+        if (!this.font) {
+            console.warn('Font not loaded yet');
+            return null;
+        }
+
+        const geometry = new TextGeometry(text, {
+            font: this.font,
+            size: 1,
+            height: this.labelHeight,
+            curveSegments: 4,
+            bevelEnabled: false
+        });
+
+        const material = new THREE.MeshBasicMaterial({
+            color: 0xffffff,
+            transparent: true,
+            opacity: 0.8
+        });
+
+        const mesh = new THREE.Mesh(geometry, material);
+        mesh.scale.set(this.labelScale, this.labelScale, this.labelScale);
+
+        // Center the text
+        geometry.computeBoundingBox();
+        const textWidth = geometry.boundingBox!.max.x - geometry.boundingBox!.min.x;
+        mesh.position.x = -textWidth * this.labelScale / 2;
+
+        return mesh;
+    }
+
+    public createNodeVisual(metadata: NodeMetadata): THREE.Mesh {
+        const geometry = this.getGeometryFromAge(metadata.commitAge);
+        const material = this.createMaterialFromHyperlinks(metadata.hyperlinkCount);
+        const mesh = new THREE.Mesh(geometry, material);
+
+        const scale = this.calculateScale(metadata.importance);
+        mesh.scale.set(scale, scale, scale);
+
+        mesh.position.set(
+            metadata.position.x,
+            metadata.position.y,
+            metadata.position.z
+        );
+
+        return mesh;
+    }
+
+    private getGeometryFromAge(age: number): THREE.BufferGeometry {
+        if (age < 7) return this.geometries.SPHERE;
+        if (age < 30) return this.geometries.ICOSAHEDRON;
+        return this.geometries.OCTAHEDRON;
+    }
+
+    private createMaterialFromHyperlinks(count: number): THREE.Material {
+        const hue = Math.min(count / 10, 1) * 0.3; // 0 to 0.3 range
+        const color = new THREE.Color().setHSL(hue, 0.7, 0.5);
+
+        return new THREE.MeshPhongMaterial({
+            color: color,
+            shininess: 30,
+            transparent: true,
+            opacity: 0.9
+        });
+    }
+
+    private calculateScale(importance: number): number {
+        const [min, max] = this.settings.nodes.sizeRange;
+        return min + (max - min) * Math.min(importance, 1);
+    }
+
+    public async createMetadataLabel(metadata: NodeMetadata): Promise<THREE.Group> {
+        const group = new THREE.Group();
+
+        // Create text for name
+        const nameMesh = await this.createTextMesh(metadata.name);
+        if (nameMesh) {
+            nameMesh.position.y = 1.2;
+            group.add(nameMesh);
+        }
+
+        // Create text for commit age
+        const ageMesh = await this.createTextMesh(`${Math.round(metadata.commitAge)} days`);
+        if (ageMesh) {
+            ageMesh.position.y = 0.8;
+            group.add(ageMesh);
+        }
+
+        // Create text for hyperlink count
+        const linksMesh = await this.createTextMesh(`${metadata.hyperlinkCount} links`);
+        if (linksMesh) {
+            linksMesh.position.y = 0.4;
+            group.add(linksMesh);
+        }
+
+        // Billboard behavior
+        if (this.settings.labels?.billboard_mode === 'camera') {
+            group.onBeforeRender = () => {
+                group.quaternion.copy(this.camera.quaternion);
+            };
+        } else {
+            // Vertical billboard - only rotate around Y
+            group.onBeforeRender = () => {
+                const cameraPos = this.camera.position.clone();
+                cameraPos.y = group.position.y;
+                group.lookAt(cameraPos);
+            };
+        }
+
+        return group;
+    }
+
+    public dispose(): void {
+        // Clean up geometries
+        Object.values(this.geometries).forEach(geometry => geometry.dispose());
+        
+        // Clean up label group
+        this.labelGroup.traverse(child => {
+            if (child instanceof THREE.Mesh) {
+                child.geometry.dispose();
+                if (child.material instanceof THREE.Material) {
+                    child.material.dispose();
+                }
+            }
+        });
+    }
+}
diff --git a/src/visualization/VisualizationController.ts b/src/visualization/VisualizationController.ts
new file mode 100644
index 00000000..042beb90
--- /dev/null
+++ b/src/visualization/VisualizationController.ts
@@ -0,0 +1,123 @@
+import * as THREE from 'three';
+import { MetadataVisualizer } from './MetadataVisualizer';
+import { HologramManager } from './HologramManager';
+import { NodeMetadata, HologramSettings } from '../types/metadata';
+import { XRHandedness, XRHand } from '../types/xr';
+
+export class VisualizationController {
+    private readonly scene: THREE.Scene;
+    private readonly camera: THREE.PerspectiveCamera;
+    private readonly renderer: THREE.WebGLRenderer;
+    private readonly metadataVisualizer: MetadataVisualizer;
+    private readonly hologramManager: HologramManager;
+    private clock: THREE.Clock;
+    private isXRSession: boolean = false;
+
+    constructor(container: HTMLElement, settings: any) {
+        // Initialize Three.js basics
+        this.scene = new THREE.Scene();
+        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
+        this.renderer = new THREE.WebGLRenderer({
+            antialias: true,
+            alpha: true,
+            logarithmicDepthBuffer: true
+        });
+        this.renderer.setPixelRatio(window.devicePixelRatio);
+        this.renderer.setSize(window.innerWidth, window.innerHeight);
+        this.renderer.xr.enabled = true;
+        container.appendChild(this.renderer.domElement);
+
+        // Initialize managers
+        this.metadataVisualizer = new MetadataVisualizer(this.scene, this.camera, settings);
+        this.hologramManager = new HologramManager(this.scene, this.camera, settings.hologram);
+        this.clock = new THREE.Clock();
+
+        // Set up XR session change handling
+        this.renderer.xr.addEventListener('sessionstart', () => {
+            this.isXRSession = true;
+            this.hologramManager.setXRMode(true);
+        });
+
+        this.renderer.xr.addEventListener('sessionend', () => {
+            this.isXRSession = false;
+            this.hologramManager.setXRMode(false);
+        });
+
+        // Set up window resize handling
+        window.addEventListener('resize', this.onWindowResize.bind(this));
+    }
+
+    private onWindowResize(): void {
+        this.camera.aspect = window.innerWidth / window.innerHeight;
+        this.camera.updateProjectionMatrix();
+        this.renderer.setSize(window.innerWidth, window.innerHeight);
+    }
+
+    public updateNodes(nodes: NodeMetadata[]): void {
+        // Clear existing nodes
+        this.scene.children
+            .filter(child => child.userData.isNode)
+            .forEach(node => this.scene.remove(node));
+
+        // Create new nodes
+        nodes.forEach(metadata => {
+            const nodeMesh = this.metadataVisualizer.createNodeVisual(metadata);
+            nodeMesh.userData.isNode = true;
+            nodeMesh.position.set(
+                metadata.position.x,
+                metadata.position.y,
+                metadata.position.z
+            );
+            this.scene.add(nodeMesh);
+        });
+    }
+
+    public updateHologramSettings(settings: Partial<HologramSettings>): void {
+        this.hologramManager.updateSettings(settings);
+    }
+
+    public handleHandInput(hand: XRHand, handedness: XRHandedness): void {
+        if (this.isXRSession) {
+            this.hologramManager.handleHandInteraction(hand, handedness);
+        }
+    }
+
+    public animate(): void {
+        const render = () => {
+            const delta = this.clock.getDelta();
+            
+            // Update hologram animations
+            this.hologramManager.update(delta);
+
+            // Render scene
+            this.renderer.render(this.scene, this.camera);
+        };
+
+        this.renderer.setAnimationLoop(render);
+    }
+
+    public dispose(): void {
+        // Clean up event listeners
+        window.removeEventListener('resize', this.onWindowResize.bind(this));
+
+        // Dispose managers
+        this.metadataVisualizer.dispose();
+        this.hologramManager.dispose();
+
+        // Stop animation loop
+        this.renderer.setAnimationLoop(null);
+
+        // Dispose Three.js resources
+        this.renderer.dispose();
+        this.scene.traverse((object) => {
+            if (object instanceof THREE.Mesh) {
+                object.geometry.dispose();
+                if (Array.isArray(object.material)) {
+                    object.material.forEach(material => material.dispose());
+                } else {
+                    object.material.dispose();
+                }
+            }
+        });
+    }
+}
diff --git a/vite.config.ts b/vite.config.ts
index 60c74e1d..acbfa598 100644
--- a/vite.config.ts
+++ b/vite.config.ts
@@ -14,13 +14,7 @@ export default defineConfig(({ mode, command }) => {
       outDir: resolve(__dirname, 'data/public/dist'),
       emptyOutDir: true,
       sourcemap: !isProd,
-      minify: isProd ? 'terser' : false,
-      terserOptions: {
-        compress: {
-          drop_console: isProd,
-          drop_debugger: isProd
-        }
-      },
+      minify: false,
       rollupOptions: {
         input: {
           main: resolve(__dirname, 'client/index.html')
@@ -41,14 +35,21 @@ export default defineConfig(({ mode, command }) => {
             return `assets/[name][extname]`;
           },
           chunkFileNames: 'assets/js/[name]-[hash].js',
-          entryFileNames: 'assets/js/[name]-[hash].js'
+          entryFileNames: 'assets/js/[name]-[hash].js',
+          manualChunks: {
+            'three': ['three'],
+            'lodash': ['lodash'],
+            'react-three': ['@react-three/drei', '@react-three/fiber']
+          }
         }
       }
     },
 
     resolve: {
       alias: {
-        '@': resolve(__dirname, './client')
+        '@': resolve(__dirname, './client'),
+        'three': resolve(__dirname, 'node_modules/three'),
+        'lodash': resolve(__dirname, 'node_modules/lodash')
       }
     },
 
@@ -68,7 +69,7 @@ export default defineConfig(({ mode, command }) => {
     },
 
     optimizeDeps: {
-      include: ['three']
+      include: ['three', '@react-three/drei', '@react-three/fiber', 'lodash']
     },
 
     define: {
