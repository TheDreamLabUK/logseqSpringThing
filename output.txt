The following text represents a project with code. The structure of the text consists of sections beginning with ----, followed by a single line containing the file path and file name, and then a variable number of lines containing the file contents. The text representing the project ends when the symbols --END-- are encountered. Any further text beyond --END-- is meant to be interpreted as instructions using the aforementioned project as context.
----
app.js
// data/public/js/app.js

import { createApp } from 'vue';
import ControlPanel from './components/ControlPanel.vue';
import ChatManager from './components/chatManager.vue';
import { WebXRVisualization } from './components/visualization/core.js';
import WebsocketService from './services/websocketService.js';
import { GraphDataManager } from './services/graphDataManager.js';
import { isGPUAvailable, initGPU } from './gpuUtils.js';
import { enableSpacemouse } from './services/spacemouse.js';

export class App {
    constructor() {
        console.log('App constructor called');
        this.websocketService = null;
        this.graphDataManager = null;
        this.visualization = null;
        this.gpuAvailable = false;
        this.gpuUtils = null;
        this.xrActive = false;
        this.vueApp = null;
        
        // Add debug info to DOM
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
            debugInfo.innerHTML += '<div>App constructor called</div>';
        }
    }

    async start() {
        console.log('Starting application');
        try {
            await this.initializeApp();
            console.log('Application started successfully');
        } catch (error) {
            console.error('Failed to start application:', error);
            throw error;
        }
    }

    async initializeApp() {
        console.log('Initializing Application - Step 1: Services');

        // Initialize Services
        try {
            // Create WebsocketService but don't connect yet (it auto-connects in constructor)
            this.websocketService = new WebsocketService();
            console.log('WebsocketService initialized successfully');
        } catch (error) {
            console.error('Failed to initialize WebsocketService:', error);
            throw error; // Propagate error since WebsocketService is critical
        }

        if (this.websocketService) {
            this.graphDataManager = new GraphDataManager(this.websocketService);
            console.log('GraphDataManager initialized successfully');
        } else {
            throw new Error('Cannot initialize GraphDataManager: WebsocketService is not available');
        }
        
        console.log('Initializing Application - Step 2: Visualization');
        try {
            // Add container check
            const container = document.getElementById('scene-container');
            if (!container) {
                console.error('Scene container not found, creating it');
                const newContainer = document.createElement('div');
                newContainer.id = 'scene-container';
                document.body.appendChild(newContainer);
            }

            this.visualization = new WebXRVisualization(this.graphDataManager);
            console.log('WebXRVisualization initialized successfully');
        } catch (error) {
            console.error('Failed to initialize WebXRVisualization:', error);
            console.error('Error stack:', error.stack);
            throw error; // Propagate error since visualization is critical
        }

        console.log('Initializing Application - Step 3: GPU');
        // Initialize GPU if available
        this.gpuAvailable = isGPUAvailable();
        if (this.gpuAvailable) {
            this.gpuUtils = initGPU();
            console.log('GPU acceleration initialized');
        } else {
            console.warn('GPU acceleration not available, using CPU fallback');
        }

        console.log('Initializing Application - Step 4: Three.js');
        // Initialize Three.js first
        if (this.visualization) {
            await this.visualization.initThreeJS();
        } else {
            throw new Error('Visualization not initialized, cannot call initThreeJS');
        }

        console.log('Initializing Application - Step 5: Vue App');
        // Initialize Vue App with ChatManager and ControlPanel after Three.js
        await this.initVueApp();

        console.log('Initializing Application - Step 6: Event Listeners');
        // Setup Event Listeners
        this.setupEventListeners();
    }

    async initVueApp() {
        try {
            console.log('Initializing Vue application');
            
            // Store websocketService reference for closure
            const websocketService = this.websocketService;
            
            // Create Vue app instance
            const app = createApp({
                components: {
                    ControlPanel,
                    ChatManager
                },
                setup() {
                    return {
                        websocketService,
                        enableSpacemouse // Make enableSpacemouse available to components
                    };
                },
                template: `
                    <div>
                        <ControlPanel 
                            :websocket-service="websocketService"
                            :enable-spacemouse="enableSpacemouse"
                            @control-change="handleControlChange"
                        />
                        <ChatManager 
                            :websocket-service="websocketService"
                        />
                    </div>
                `,
                methods: {
                    handleControlChange(change) {
                        console.log('Control changed:', change);
                        // Handle control changes here if needed
                    }
                }
            });

            // Mount the app
            const appContainer = document.getElementById('app');
            if (!appContainer) {
                console.error('App container not found, creating it');
                const newContainer = document.createElement('div');
                newContainer.id = 'app';
                document.body.appendChild(newContainer);
            }

            this.vueApp = app.mount('#app');
            console.log('Vue application initialized successfully');
        } catch (error) {
            console.error('Failed to initialize Vue application:', error);
            console.error('Error stack:', error.stack);
            throw error;
        }
    }

    setupEventListeners() {
        if (this.websocketService) {
            // Setup websocket event listeners
            this.websocketService.on('connect', () => {
                console.log('WebSocket connected');
            });

            this.websocketService.on('disconnect', () => {
                console.log('WebSocket disconnected');
            });

            // Add other event listeners as needed
        }
    }
}

----
index.js
import { createApp } from 'vue';
import WebsocketService from './services/websocketService.js';
import { WebXRVisualization } from './components/visualization/core.js';
import ControlPanel from './components/ControlPanel.vue';

class App {
    constructor() {
        // Initialize WebSocket service first
        this.websocketService = new WebsocketService();
        
        // Initialize visualization with the websocket service as the graph data manager
        this.visualization = new WebXRVisualization(this.websocketService);
        this.vueApp = null;

        // Set up graph data handling
        this.websocketService.on('graphUpdate', ({ graphData }) => {
            console.log('Received graph update:', graphData);
            if (this.visualization) {
                this.visualization.updateVisualization(graphData);
            }
        });
    }

    async start() {
        try {
            // Initialize WebSocket connection
            await this.websocketService.connect();
            
            // Initialize visualization
            const container = document.getElementById('scene-container');
            if (!container) {
                throw new Error("Could not find 'scene-container' element");
            }
            await this.visualization.initThreeJS(container);
            
            // Create Vue application
            const websocketService = this.websocketService;
            const visualization = this.visualization;
            
            this.vueApp = createApp({
                components: {
                    ControlPanel
                },
                setup() {
                    return {
                        websocketService,
                        handleControlChange(change) {
                            console.log('Control changed:', change);
                            visualization.updateSettings(change);
                        }
                    };
                },
                template: `
                    <div class="app-wrapper">
                        <ControlPanel 
                            :websocket-service="websocketService"
                            @control-change="handleControlChange"
                        />
                    </div>
                `
            });

            // Mount the application
            const appContainer = document.getElementById('app');
            if (!appContainer) {
                throw new Error("Could not find 'app' element");
            }
            this.vueApp.mount(appContainer);

            // Update connection status
            this.websocketService.on('connect', () => {
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    statusEl.textContent = 'Connected';
                    statusEl.className = 'connected';
                }
            });

            this.websocketService.on('disconnect', () => {
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'disconnected';
                }
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                if (this.visualization) {
                    this.visualization.onWindowResize();
                }
            });

            // Request initial data
            this.websocketService.send({ type: 'getInitialData' });

        } catch (error) {
            console.error('Failed to start application:', error);
            throw error;
        }
    }

    stop() {
        if (this.visualization) {
            this.visualization.dispose();
        }
        if (this.websocketService) {
            this.websocketService.disconnect();
        }
        if (this.vueApp) {
            this.vueApp.unmount();
        }
    }
}

// Initialize application when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    const app = new App();
    app.start().catch(error => {
        console.error('Failed to start application:', error);
    });

    // Handle cleanup on page unload
    window.addEventListener('beforeunload', () => {
        app.stop();
    });
});

export { App };

----
gpuUtils.js
// public/js/gpuUtils.js

/**
 * Checks if the GPU is available for acceleration.
 * @returns {boolean} True if GPU is available, false otherwise.
 */
export function isGPUAvailable() {
  try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      return !!gl;
  } catch (e) {
      console.error('GPU availability check failed:', e);
      return false;
  }
}

/**
* Initializes GPU computation utilities.
* @returns {object} An object containing GPU-related methods.
*/
export function initGPU() {
  // Placeholder for GPU computation initialization
  console.log('Initializing GPU utilities.');

  // Implement GPU-related initializations here, such as setting up compute shaders
  // For this example, we'll return an empty object
  return {
      compute: (data) => {
          // Implement GPU computation logic here
          console.log('Performing GPU computation with data:', data);
      }
  };
}

/**
* Performs computations on the GPU.
* @param {object} gpu - The GPU utilities object.
* @param {object} data - The data to compute.
* @returns {boolean} True if computation was successful, false otherwise.
*/
export function computeOnGPU(gpu, data) {
  if (gpu && typeof gpu.compute === 'function') {
      gpu.compute(data);
      return true;
  } else {
      console.warn('GPU compute function is not available.');
      return false;
  }
}

----
xr/xrSetup.js
import * as THREE from 'three';
import { XRButton } from 'three/examples/jsm/webxr/XRButton.js';
import { initXRInteraction, handleXRInput } from './xrInteraction.js';

// Constants
const MOVEMENT_SPEED = 0.05;
const XR_SPRITE_SCALE = 0.5;

/**
 * Initializes the WebXR session for immersive experiences.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 * @param {THREE.Scene} scene - The Three.js scene.
 * @param {THREE.PerspectiveCamera} camera - The Three.js camera.
 * @param {EffectsManager} effectsManager - The effects manager instance.
 */
export function initXRSession(renderer, scene, camera, effectsManager) {
    if (!scene || !camera) {
        console.error('Scene or camera not provided to initXRSession');
        return;
    }

    // Store original sprite scales for restoration
    const originalScales = new WeakMap();

    // Initialize hand tracking with enhanced features
    const xrInteraction = initXRInteraction(scene, camera, renderer);

    // Configure renderer for XR with optimized settings
    renderer.xr.enabled = true;
    renderer.xr.setFramebufferScaleFactor(1.0); // Optimize resolution
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.alpha = true;

    /**
     * Handles sprite scaling and visibility for XR
     * @param {boolean} enteringXR - Whether entering or exiting XR
     */
    function handleXRSprites(enteringXR) {
        scene.traverse((object) => {
            if (object.isSprite) {
                if (enteringXR) {
                    // Store original scale
                    originalScales.set(object, object.scale.clone());
                    
                    // Scale for XR
                    object.scale.multiplyScalar(XR_SPRITE_SCALE);
                    object.layers.enableAll();
                    
                    // Optimize sprite texture
                    if (object.material.map) {
                        object.material.map.generateMipmaps = false;
                        object.material.map.minFilter = THREE.LinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                } else {
                    // Restore original scale
                    const originalScale = originalScales.get(object);
                    if (originalScale) {
                        object.scale.copy(originalScale);
                    }
                    
                    // Reset texture settings
                    if (object.material.map) {
                        object.material.map.generateMipmaps = true;
                        object.material.map.minFilter = THREE.LinearMipmapLinearFilter;
                        object.material.map.needsUpdate = true;
                    }
                }
            }
        });
    }

    /**
     * Creates XR session configuration
     * @param {string} mode - XR session mode
     * @returns {Object} Session configuration
     */
    function createSessionConfig(mode) {
        return {
            mode: mode,
            sessionInit: {
                optionalFeatures: [
                    'dom-overlay',
                    'local-floor',
                    'bounded-floor',
                    'hand-tracking',
                    'layers',
                    mode === 'immersive-ar' ? 'passthrough' : null
                ].filter(Boolean),
                domOverlay: { root: document.body }
            },
            onSessionStarted: (session) => {
                console.log(`${mode} session started`);
                handleXRSprites(true);
                
                session.addEventListener('end', () => {
                    console.log(`${mode} session ended`);
                    handleXRSprites(false);
                    window.dispatchEvent(new CustomEvent('xrsessionend'));
                });

                // Request reference space with fallback
                requestReferenceSpace(session, renderer);
                
                window.dispatchEvent(new CustomEvent('xrsessionstart'));
            },
            onSessionEnded: () => {
                console.log(`${mode} session cleanup`);
                handleXRSprites(false);
                
                // Clear any cached resources
                originalScales.clear();
                
                // Force renderer reset
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };
    }

    if ('xr' in navigator) {
        // Check for AR support first
        navigator.xr.isSessionSupported('immersive-ar')
            .then(arSupported => {
                if (arSupported) {
                    const xrButton = XRButton.createButton(renderer, createSessionConfig('immersive-ar'));
                    document.body.appendChild(xrButton);
                } else {
                    // Fall back to VR if AR is not supported
                    return navigator.xr.isSessionSupported('immersive-vr')
                        .then(vrSupported => {
                            if (vrSupported) {
                                const xrButton = XRButton.createButton(renderer, createSessionConfig('immersive-vr'));
                                document.body.appendChild(xrButton);
                            } else {
                                console.warn('Neither AR nor VR is supported');
                            }
                        });
                }
            })
            .catch(err => {
                console.error('Error checking XR session support:', err);
            });

        // Add session event listeners
        renderer.xr.addEventListener('sessionstart', (event) => {
            console.log('XR session started');
            const session = event.target.getSession();
            requestReferenceSpace(session, renderer);
        });

        renderer.xr.addEventListener('sessionend', () => {
            console.log('XR session ended');
            // Force a renderer reset
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    } else {
        console.warn('WebXR not supported in this browser.');
    }

    // Handle window resizes
    window.addEventListener('resize', () => {
        if (!renderer.xr.isPresenting) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });

    return xrInteraction;
}

/**
 * Request reference space with fallback options
 * @param {XRSession} session - The XR session
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer
 */
async function requestReferenceSpace(session, renderer) {
    try {
        const refSpace = await session.requestReferenceSpace('local-floor');
        console.log('Got local-floor reference space');
        renderer.xr.setReferenceSpace(refSpace);
    } catch (err) {
        console.warn('Failed to get local-floor reference space:', err);
        try {
            const refSpace = await session.requestReferenceSpace('local');
            console.log('Falling back to local reference space');
            renderer.xr.setReferenceSpace(refSpace);
        } catch (err) {
            console.error('Failed to get any reference space:', err);
        }
    }
}

/**
 * Updates camera position based on XR pose with error handling
 * @param {XRFrame} frame - The XR frame
 * @param {XRReferenceSpace} refSpace - The XR reference space
 * @param {THREE.Camera} camera - The Three.js camera
 */
function updateCameraFromXRPose(frame, refSpace, camera) {
    if (!frame || !refSpace || !camera) return;

    try {
        const pose = frame.getViewerPose(refSpace);
        if (pose) {
            const view = pose.views[0];
            if (view) {
                const position = new THREE.Vector3(
                    view.transform.position.x,
                    view.transform.position.y,
                    view.transform.position.z
                );
                camera.position.copy(position);
            }
        }
    } catch (error) {
        console.error('Error updating camera from XR pose:', error);
    }
}

/**
 * Handles the XR session's rendering loop with error recovery
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer
 * @param {THREE.Scene} scene - The Three.js scene
 * @param {THREE.Camera} camera - The Three.js camera
 * @param {Object} xrInteraction - The XR interaction instance
 * @param {EffectsManager} effectsManager - The effects manager instance
 */
export function handleXRSession(renderer, scene, camera, xrInteraction, effectsManager) {
    if (!renderer || !scene || !camera) {
        console.error('Required parameters missing in handleXRSession');
        return;
    }

    let frameCount = 0;
    const MAX_ERRORS = 5;
    let errorCount = 0;

    renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
            try {
                frameCount++;
                const session = renderer.xr.getSession();
                const refSpace = renderer.xr.getReferenceSpace();

                if (session && refSpace) {
                    updateCameraFromXRPose(frame, refSpace, camera);

                    // Update hand tracking and interactions
                    if (xrInteraction) {
                        xrInteraction.update();
                        handleXRInput(frame, refSpace);
                    }

                    // Handle input sources
                    for (const source of session.inputSources) {
                        if (source?.gamepad?.handedness === 'left') {
                            handleGamepadInput(source.gamepad, camera);
                        }
                    }

                    // Reset error count on successful frames
                    if (frameCount % 60 === 0) {
                        errorCount = 0;
                    }
                }
            } catch (error) {
                console.error('Error in XR frame:', error);
                errorCount++;
                
                // End session if too many errors occur
                if (errorCount >= MAX_ERRORS) {
                    console.error('Too many XR errors, ending session');
                    renderer.xr.getSession()?.end();
                    return;
                }
            }
        }
        
        // Render the scene using the effects manager
        if (effectsManager) {
            effectsManager.animate();
            effectsManager.render();
        } else {
            // Fallback to direct rendering if effects manager is not available
            renderer.render(scene, camera);
        }
    });
}

/**
 * Handles gamepad input in XR with improved movement
 * @param {Gamepad} gamepad - The XR gamepad
 * @param {THREE.Camera} camera - The Three.js camera
 */
function handleGamepadInput(gamepad, camera) {
    if (!gamepad || !camera || !camera.parent) return;

    try {
        if (gamepad.axes.length >= 2) {
            const [x, y] = gamepad.axes;
            const deadzone = 0.1;

            if (Math.abs(x) > deadzone || Math.abs(y) > deadzone) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), forward);

                const movement = new THREE.Vector3();
                movement.addScaledVector(right, x * MOVEMENT_SPEED);
                movement.addScaledVector(forward, -y * MOVEMENT_SPEED);

                const userGroup = camera.parent;
                userGroup.position.add(movement);
            }
        }
    } catch (error) {
        console.error('Error handling gamepad input:', error);
    }
}

/**
 * Updates the XR frame with error handling
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer
 * @param {THREE.Scene} scene - The Three.js scene
 * @param {THREE.Camera} camera - The Three.js camera
 * @param {Object} xrInteraction - The XR interaction instance
 * @param {EffectsManager} effectsManager - The effects manager instance
 */
export function updateXRFrame(renderer, scene, camera, xrInteraction, effectsManager) {
    if (renderer.xr.isPresenting) {
        try {
            const session = renderer.xr.getSession();
            if (session && xrInteraction) {
                xrInteraction.update();
            }
        } catch (error) {
            console.error('Error updating XR frame:', error);
        }
    }
    
    // Use effects manager for rendering if available
    if (effectsManager) {
        effectsManager.animate();
        effectsManager.render();
    } else {
        renderer.render(scene, camera);
    }
}

----
xr/xrInteraction.js
import * as THREE from 'three';
import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory.js';

// Constants for interaction
const PINCH_THRESHOLD = 0.015;
const GRAB_THRESHOLD = 0.08;
const PINCH_STRENGTH_THRESHOLD = 0.7;
const LABEL_SIZE = { width: 256, height: 128 };
const LABEL_SCALE = { x: 0.5, y: 0.25, z: 1 };

// Resource pools
const materialPool = new Map();
const geometryPool = new Map();
const texturePool = new Map();

// Hand tracking setup
const handModelFactory = new XRHandModelFactory();
const hands = { left: null, right: null };
const grabStates = {
    left: { grabbedObject: null, pinching: false },
    right: { grabbedObject: null, pinching: false }
};
const pinchIndicators = { left: null, right: null };
const interactableObjects = new Set();

// XR Label Manager Class
export class XRLabelManager {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.labels = new Map();
        this.labelCanvas = document.createElement('canvas');
        this.labelContext = this.labelCanvas.getContext('2d', {
            alpha: true,
            desynchronized: true
        });
        
        // Set canvas size to power of 2
        this.labelCanvas.width = LABEL_SIZE.width;
        this.labelCanvas.height = LABEL_SIZE.height;
    }

    /**
     * Get or create a texture for label
     * @param {string} text - Label text
     * @returns {THREE.Texture} The texture
     */
    getTexture(text) {
        if (texturePool.has(text)) {
            return texturePool.get(text);
        }

        // Clear canvas
        this.labelContext.clearRect(0, 0, LABEL_SIZE.width, LABEL_SIZE.height);
        
        // Draw background
        this.labelContext.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.labelContext.fillRect(0, 0, LABEL_SIZE.width, LABEL_SIZE.height);
        
        // Draw text
        this.labelContext.fillStyle = '#ffffff';
        this.labelContext.font = '24px Arial';
        this.labelContext.textBaseline = 'middle';
        this.labelContext.fillText(text, 10, LABEL_SIZE.height / 2);

        const texture = new THREE.CanvasTexture(this.labelCanvas);
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        
        texturePool.set(text, texture);
        return texture;
    }

    /**
     * Get or create a material for label
     * @param {THREE.Texture} texture - The label texture
     * @returns {THREE.SpriteMaterial} The material
     */
    getMaterial(texture) {
        const key = texture.uuid;
        if (materialPool.has(key)) {
            return materialPool.get(key);
        }

        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthWrite: false,
            sizeAttenuation: true
        });

        materialPool.set(key, material);
        return material;
    }

    createLabel(text, position) {
        try {
            const texture = this.getTexture(text);
            const material = this.getMaterial(texture);
            const sprite = new THREE.Sprite(material);
            
            sprite.position.copy(position);
            sprite.scale.set(LABEL_SCALE.x, LABEL_SCALE.y, LABEL_SCALE.z);
            
            this.scene.add(sprite);
            this.labels.set(text, sprite);
            
            return sprite;
        } catch (error) {
            console.error('Error creating label:', error);
            return null;
        }
    }

    updateLabel(text, position) {
        const label = this.labels.get(text);
        if (label) {
            label.position.copy(position);
            label.lookAt(this.camera.position);
        }
    }

    removeLabel(text) {
        const label = this.labels.get(text);
        if (label) {
            this.scene.remove(label);
            
            // Return material and texture to pools
            if (label.material) {
                const texture = label.material.map;
                if (texture) {
                    texturePool.delete(text);
                    texture.dispose();
                }
                materialPool.delete(label.material.uuid);
                label.material.dispose();
            }
            
            this.labels.delete(text);
        }
    }

    updateAll() {
        const cameraPosition = this.camera.position;
        this.labels.forEach(label => {
            label.lookAt(cameraPosition);
        });
    }

    dispose() {
        // Dispose of all labels
        this.labels.forEach((label, text) => {
            this.removeLabel(text);
        });

        // Clear pools
        texturePool.forEach(texture => texture.dispose());
        materialPool.forEach(material => material.dispose());
        
        texturePool.clear();
        materialPool.clear();
        
        // Clear canvas
        this.labelContext.clearRect(0, 0, LABEL_SIZE.width, LABEL_SIZE.height);
        this.labelCanvas.width = 1;
        this.labelCanvas.height = 1;
    }
}

// Detect pinch with strength
function isPinching(hand) {
    try {
        const indexTip = hand.joints['index-finger-tip'];
        const thumbTip = hand.joints['thumb-tip'];

        if (indexTip && thumbTip) {
            const distance = indexTip.position.distanceTo(thumbTip.position);
            const strength = Math.max(0, 1 - (distance / PINCH_THRESHOLD));
            return { isPinched: distance < PINCH_THRESHOLD, strength };
        }
    } catch (error) {
        console.error('Error detecting pinch:', error);
    }
    return { isPinched: false, strength: 0 };
}

// Get or create geometry for pinch indicator
function getPinchIndicatorGeometry() {
    const key = 'pinchIndicator';
    if (geometryPool.has(key)) {
        return geometryPool.get(key);
    }

    const geometry = new THREE.SphereGeometry(0.01, 8, 8);
    geometryPool.set(key, geometry);
    return geometry;
}

// Get or create material for pinch indicator
function getPinchIndicatorMaterial() {
    const key = 'pinchIndicator';
    if (materialPool.has(key)) {
        return materialPool.get(key);
    }

    const material = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5,
        depthWrite: false
    });
    materialPool.set(key, material);
    return material;
}

// Create visual feedback sphere for pinch state
function createPinchIndicator() {
    const geometry = getPinchIndicatorGeometry();
    const material = getPinchIndicatorMaterial();
    return new THREE.Mesh(geometry, material);
}

// Update pinch indicator position and appearance
function updatePinchIndicator(hand, indicator) {
    if (!hand?.joints || !indicator) return;

    try {
        const indexTip = hand.joints['index-finger-tip'];
        const thumbTip = hand.joints['thumb-tip'];
        
        if (indexTip && thumbTip) {
            indicator.position.copy(indexTip.position).lerp(thumbTip.position, 0.5);
            const { strength } = isPinching(hand);
            indicator.material.opacity = strength * 0.8;
            indicator.scale.setScalar(1 - (strength * 0.5));
        }
    } catch (error) {
        console.error('Error updating pinch indicator:', error);
    }
}

// Initialize XR interaction
export function initXRInteraction(scene, camera, renderer, onSelect) {
    const xrLabelManager = new XRLabelManager(scene, camera);
    
    // Create default interactable object geometry and material
    const interactableGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    geometryPool.set('interactable', interactableGeometry);
    
    const interactableMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.7,
        metalness: 0.3
    });
    materialPool.set('interactable', interactableMaterial);

    // Create interactable object function
    const createInteractableObject = (position) => {
        const geometry = geometryPool.get('interactable');
        const material = materialPool.get('interactable').clone(); // Clone material for individual control
        
        const object = new THREE.Mesh(geometry, material);
        object.position.copy(position);
        object.userData.interactable = true;
        scene.add(object);
        interactableObjects.add(object);
        return object;
    };

    // Create default objects
    createInteractableObject(new THREE.Vector3(0, 1.5, -1));
    createInteractableObject(new THREE.Vector3(0.2, 1.5, -1));
    createInteractableObject(new THREE.Vector3(-0.2, 1.5, -1));

    // Initialize pinch indicators
    pinchIndicators.left = createPinchIndicator();
    pinchIndicators.right = createPinchIndicator();
    scene.add(pinchIndicators.left);
    scene.add(pinchIndicators.right);

    // Set up hand tracking
    renderer.xr.addEventListener('sessionstart', () => {
        try {
            const session = renderer.xr.getSession();
            
            hands.left = renderer.xr.getHand(0);
            hands.right = renderer.xr.getHand(1);
            
            // Add hand models
            for (const [handedness, hand] of Object.entries(hands)) {
                if (hand) {
                    const handModel = handModelFactory.createHandModel(hand, 'mesh');
                    hand.add(handModel);
                    scene.add(hand);
                }
            }
        } catch (error) {
            console.error('Error setting up hand tracking:', error);
        }
    });

    // Create update function
    const update = () => {
        try {
            // Update both hands
            for (const [handedness, hand] of Object.entries(hands)) {
                if (hand?.joints) {
                    const grabState = grabStates[handedness];
                    const { isPinched, strength } = isPinching(hand);
                    
                    updatePinchIndicator(hand, pinchIndicators[handedness]);

                    if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                        if (!grabState.grabbedObject) {
                            const indexTip = hand.joints['index-finger-tip'];
                            
                            for (const object of interactableObjects) {
                                const distance = indexTip.position.distanceTo(object.position);
                                if (distance < GRAB_THRESHOLD && !object.userData.isGrabbed) {
                                    grabState.grabbedObject = object;
                                    object.userData.isGrabbed = true;
                                    object.material.emissive.setHex(0x222222);
                                    break;
                                }
                            }
                        } else if (grabState.grabbedObject) {
                            const indexTip = hand.joints['index-finger-tip'];
                            grabState.grabbedObject.position.copy(indexTip.position);
                        }
                        grabState.pinching = true;
                    } else if (grabState.pinching) {
                        if (grabState.grabbedObject) {
                            grabState.grabbedObject.userData.isGrabbed = false;
                            grabState.grabbedObject.material.emissive.setHex(0x000000);
                            grabState.grabbedObject = null;
                        }
                        grabState.pinching = false;
                    }
                }
            }

            // Update labels if in XR
            if (renderer.xr.isPresenting) {
                xrLabelManager.updateAll();
            }
        } catch (error) {
            console.error('Error in XR update:', error);
        }
    };

    // Create cleanup function
    const cleanup = () => {
        try {
            // Dispose of all pooled resources
            geometryPool.forEach(geometry => geometry.dispose());
            materialPool.forEach(material => material.dispose());
            
            // Clear pools
            geometryPool.clear();
            materialPool.clear();
            
            // Dispose of pinch indicators
            Object.values(pinchIndicators).forEach(indicator => {
                if (indicator) {
                    if (indicator.geometry) indicator.geometry.dispose();
                    if (indicator.material) indicator.material.dispose();
                    scene.remove(indicator);
                }
            });
            
            // Dispose of hand models
            Object.values(hands).forEach(hand => {
                if (hand) {
                    scene.remove(hand);
                }
            });
            
            // Clear interactable objects
            interactableObjects.clear();
            
            // Dispose of label manager
            xrLabelManager.dispose();
        } catch (error) {
            console.error('Error cleaning up XR resources:', error);
        }
    };

    return {
        hands: Object.values(hands),
        controllers: [],
        xrLabelManager,
        update,
        cleanup,
        addInteractableObject: (object) => {
            object.userData.interactable = true;
            interactableObjects.add(object);
        },
        removeInteractableObject: (object) => {
            interactableObjects.delete(object);
        }
    };
}

// Handle XR input
export function handleXRInput(frame, referenceSpace) {
    try {
        // Update both hands
        for (const [handedness, hand] of Object.entries(hands)) {
            if (hand?.joints) {
                const grabState = grabStates[handedness];
                const { isPinched, strength } = isPinching(hand);
                
                updatePinchIndicator(hand, pinchIndicators[handedness]);

                if (isPinched && strength > PINCH_STRENGTH_THRESHOLD) {
                    if (!grabState.grabbedObject) {
                        const indexTip = hand.joints['index-finger-tip'];
                        
                        for (const object of interactableObjects) {
                            const distance = indexTip.position.distanceTo(object.position);
                            if (distance < GRAB_THRESHOLD && !object.userData.isGrabbed) {
                                grabState.grabbedObject = object;
                                object.userData.isGrabbed = true;
                                object.material.emissive.setHex(0x222222);
                                break;
                            }
                        }
                    } else if (grabState.grabbedObject) {
                        const indexTip = hand.joints['index-finger-tip'];
                        grabState.grabbedObject.position.copy(indexTip.position);
                    }
                    grabState.pinching = true;
                } else if (grabState.pinching) {
                    if (grabState.grabbedObject) {
                        grabState.grabbedObject.userData.isGrabbed = false;
                        grabState.grabbedObject.material.emissive.setHex(0x000000);
                        grabState.grabbedObject = null;
                    }
                    grabState.pinching = false;
                }
            }
        }
    } catch (error) {
        console.error('Error handling XR input:', error);
    }
}

----
services/spacemouse.js
// Spacemouse HID interface

const SPACEMOUSE_VENDOR_ID = 0x256F; // 3Dconnexion vendor ID
const SPACEMOUSE_PRODUCT_ID = 0xC635; // SpaceMouse Compact product ID (may vary for different models)

let spacemouseDevice = null;

async function requestHIDAccess() {
    try {
        const devices = await navigator.hid.requestDevice({
            filters: [{ vendorId: SPACEMOUSE_VENDOR_ID, productId: SPACEMOUSE_PRODUCT_ID }]
        });
        if (devices.length > 0) {
            spacemouseDevice = devices[0];
            await spacemouseDevice.open();
            console.log('HID device opened:', spacemouseDevice.productName);
            spacemouseDevice.addEventListener('inputreport', handleHIDInput);
        }
    } catch (error) {
        console.error('HID access denied:', error);
    }
}

function handleHIDInput(event) {
    const { data } = event;
    
    // Parse the input data
    const x = data.getInt16(1, true);
    const y = data.getInt16(3, true);
    const z = data.getInt16(5, true);

    // Normalize values (adjust as needed based on your Spacemouse model)
    const normalizedX = x / 350;
    const normalizedY = y / 350;
    const normalizedZ = z / 350;

    // Emit an event with the normalized values
    const spacemouseEvent = new CustomEvent('spacemouse-move', {
        detail: { x: normalizedX, y: normalizedY, z: normalizedZ }
    });
    window.dispatchEvent(spacemouseEvent);
}

// Function to be called when the "Enable Spacemouse" button is clicked
function enableSpacemouse() {
    if (navigator.hid) {
        requestHIDAccess();
    } else {
        console.error('WebHID is not supported in this browser');
        alert('WebHID is not supported in this browser. Please use a compatible browser like Chrome or Edge.');
    }
}

// Export the function to be used in Vue components
export { enableSpacemouse };
----
services/visualizationSettings.js
// Manages visualization settings received from the server
export class VisualizationSettings {
    constructor() {
        // Default values matching settings.toml
        this.settings = {
            // Node colors
            nodeColor: '#FFA500',             // Base orange
            nodeColorNew: '#FFD700',          // Bright gold for very recent files
            nodeColorRecent: '#FFA500',       // Orange for recent files
            nodeColorMedium: '#DAA520',       // Goldenrod for medium-age files
            nodeColorOld: '#CD853F',          // Peru/bronze for old files
            nodeColorCore: '#FFB90F',         // Dark golden for core nodes
            nodeColorSecondary: '#FFC125',    // Golden yellow for secondary nodes
            nodeColorDefault: '#FFD700',      // Gold for default nodes
            
            // Edge settings
            edgeColor: '#FFD700',             // Golden
            edgeOpacity: 0.4,
            edgeWeightNormalization: 12.0,
            edgeMinWidth: 1.5,
            edgeMaxWidth: 6.0,
            
            // Node sizes and dimensions (in meters)
            minNodeSize: 0.15,                // 15cm minimum node size
            maxNodeSize: 0.4,                 // 40cm maximum node size
            nodeAgeMaxDays: 30,
            
            // Hologram settings
            hologramColor: '#FFC125',         // Deep golden yellow
            hologramScale: 6.0,
            hologramOpacity: 0.15,
            
            // Material settings
            material: {
                metalness: 0.3,
                roughness: 0.5,
                clearcoat: 0.8,
                clearcoatRoughness: 0.1,
                opacity: 0.95,
                emissiveMinIntensity: 0.0,
                emissiveMaxIntensity: 0.3
            },
            
            // Force-directed layout settings
            iterations: 300,
            spring_strength: 0.015,
            repulsion_strength: 1200.0,
            attraction_strength: 0.012,
            damping: 0.85,
            
            // Environment settings
            fogDensity: 0.001,
            
            // Label settings
            labelFontSize: 42,
            labelFontFamily: 'Arial',
            labelPadding: 24,
            labelVerticalOffset: 2.5,
            labelCloseOffset: 0.25,
            labelBackgroundColor: 'rgba(0, 0, 0, 0.85)',
            labelTextColor: 'white',
            labelInfoTextColor: 'lightgray',
            labelXRFontSize: 28,
            
            // Geometry settings
            geometryMinSegments: 24,
            geometryMaxSegments: 48,
            geometrySegmentPerHyperlink: 0.6,
            
            // Interaction settings
            clickEmissiveBoost: 2.5,
            clickFeedbackDuration: 250,
            
            // Bloom settings
            nodeBloomStrength: 0.8,
            nodeBloomRadius: 0.3,
            nodeBloomThreshold: 0.2,
            edgeBloomStrength: 0.6,
            edgeBloomRadius: 0.4,
            edgeBloomThreshold: 0.1,
            environmentBloomStrength: 0.7,
            environmentBloomRadius: 0.3,
            environmentBloomThreshold: 0.1,

            // Fisheye settings
            fisheye: {
                enabled: false,
                strength: 0.5,
                radius: 100.0,
                focusX: 0.0,
                focusY: 0.0,
                focusZ: 0.0
            }
        };

        // Bind the WebSocket message handler
        this.handleServerSettings = this.handleServerSettings.bind(this);
        window.addEventListener('serverSettings', this.handleServerSettings);

        console.log('Visualization settings initialized with defaults from settings.toml');
    }

    handleServerSettings(event) {
        console.log('Received server settings:', event.detail);
        const serverSettings = event.detail;
        
        // Deep merge settings with server values
        this.settings = this.deepMerge(this.settings, {
            ...serverSettings.visualization,
            material: serverSettings.visualization?.material,
            fisheye: serverSettings.fisheye,
            ...serverSettings.bloom
        });

        console.log('Updated settings with server values');

        // Dispatch event to notify components of updated settings
        window.dispatchEvent(new CustomEvent('visualizationSettingsUpdated', {
            detail: this.settings
        }));
    }

    // Deep merge helper function
    deepMerge(target, source) {
        const result = { ...target };
        
        if (source) {
            Object.keys(source).forEach(key => {
                if (source[key] instanceof Object && !Array.isArray(source[key])) {
                    if (key in target) {
                        result[key] = this.deepMerge(target[key], source[key]);
                    } else {
                        result[key] = { ...source[key] };
                    }
                } else if (source[key] !== undefined) {
                    result[key] = source[key];
                }
            });
        }
        
        return result;
    }

    getSettings() {
        return this.settings;
    }

    getNodeSettings() {
        return {
            color: this.settings.nodeColor,
            colorNew: this.settings.nodeColorNew,
            colorRecent: this.settings.nodeColorRecent,
            colorMedium: this.settings.nodeColorMedium,
            colorOld: this.settings.nodeColorOld,
            colorCore: this.settings.nodeColorCore,
            colorSecondary: this.settings.nodeColorSecondary,
            colorDefault: this.settings.nodeColorDefault,
            minNodeSize: this.settings.minNodeSize,
            maxNodeSize: this.settings.maxNodeSize,
            material: this.settings.material,
            ageMaxDays: this.settings.nodeAgeMaxDays,
            geometryMinSegments: this.settings.geometryMinSegments,
            geometryMaxSegments: this.settings.geometryMaxSegments,
            geometrySegmentPerHyperlink: this.settings.geometrySegmentPerHyperlink,
            clickEmissiveBoost: this.settings.clickEmissiveBoost,
            clickFeedbackDuration: this.settings.clickFeedbackDuration
        };
    }

    getEdgeSettings() {
        return {
            color: this.settings.edgeColor,
            opacity: this.settings.edgeOpacity,
            weightNormalization: this.settings.edgeWeightNormalization,
            minWidth: this.settings.edgeMinWidth,
            maxWidth: this.settings.edgeMaxWidth,
            bloomStrength: this.settings.edgeBloomStrength,
            bloomRadius: this.settings.edgeBloomRadius,
            bloomThreshold: this.settings.edgeBloomThreshold
        };
    }

    getLabelSettings() {
        return {
            fontSize: this.settings.labelFontSize,
            fontFamily: this.settings.labelFontFamily,
            padding: this.settings.labelPadding,
            verticalOffset: this.settings.labelVerticalOffset,
            closeOffset: this.settings.labelCloseOffset,
            backgroundColor: this.settings.labelBackgroundColor,
            textColor: this.settings.labelTextColor,
            infoTextColor: this.settings.labelInfoTextColor,
            xrFontSize: this.settings.labelXRFontSize
        };
    }

    getHologramSettings() {
        return {
            color: this.settings.hologramColor,
            scale: this.settings.hologramScale,
            opacity: this.settings.hologramOpacity
        };
    }

    getLayoutSettings() {
        return {
            iterations: this.settings.iterations,
            spring_strength: this.settings.spring_strength,
            repulsion_strength: this.settings.repulsion_strength,
            attraction_strength: this.settings.attraction_strength,
            damping: this.settings.damping
        };
    }

    getEnvironmentSettings() {
        return {
            fogDensity: this.settings.fogDensity,
            bloomStrength: this.settings.environmentBloomStrength,
            bloomRadius: this.settings.environmentBloomRadius,
            bloomThreshold: this.settings.environmentBloomThreshold
        };
    }

    getFisheyeSettings() {
        return this.settings.fisheye;
    }

    getBloomSettings() {
        return {
            nodeBloomStrength: this.settings.nodeBloomStrength,
            nodeBloomRadius: this.settings.nodeBloomRadius,
            nodeBloomThreshold: this.settings.nodeBloomThreshold,
            edgeBloomStrength: this.settings.edgeBloomStrength,
            edgeBloomRadius: this.settings.edgeBloomRadius,
            edgeBloomThreshold: this.settings.edgeBloomThreshold,
            environmentBloomStrength: this.settings.environmentBloomStrength,
            environmentBloomRadius: this.settings.environmentBloomRadius,
            environmentBloomThreshold: this.settings.environmentBloomThreshold
        };
    }
}

// Create and export a singleton instance
export const visualizationSettings = new VisualizationSettings();

----
services/graphDataManager.js
// public/js/services/graphDataManager.js

/**
 * GraphDataManager handles the management and updating of graph data received from the server.
 */
export class GraphDataManager {
    websocketService = null;
    graphData = null;
    forceDirectedParams = {
        iterations: 250,
        spring_strength: 0.1,
        repulsion_strength: 1000,
        attraction_strength: 0.01,
        damping: 0.8,
        time_step: 0.5  // Add default time_step
    };
    pendingRecalculation = false;
    initialLayoutDone = false;

    /**
     * Creates a new GraphDataManager instance.
     * @param {WebsocketService} websocketService - The WebSocket service instance.
     */
    constructor(websocketService) {
        this.websocketService = websocketService;
        console.log('GraphDataManager initialized');
        
        // Use arrow functions for event handlers to preserve this context
        this.websocketService.on('graphUpdate', this.handleGraphUpdate);
        this.websocketService.on('gpuPositions', this.handleGPUPositions);
    }

    requestInitialData = () => {
        console.log('Requesting initial data');
        this.websocketService.send({ type: 'getInitialData' });
    }

    handleGPUPositions = (update) => {
        if (!this.graphData || !this.graphData.nodes) {
            console.error('Cannot apply GPU position update: No graph data exists');
            return;
        }

        const { positions } = update;
        console.log('Received GPU position update:', positions);
        
        // Transform position array into node objects
        const updatedNodes = this.graphData.nodes.map((node, index) => {
            if (positions[index]) {
                const pos = positions[index];
                if (Array.isArray(pos) && pos.length >= 6) {
                    return {
                        ...node,
                        x: pos[0],
                        y: pos[1],
                        z: pos[2],
                        vx: pos[3],
                        vy: pos[4],
                        vz: pos[5]
                    };
                }
            }
            return node;
        });

        // Update the graph data with the new nodes
        this.graphData = {
            ...this.graphData,
            nodes: updatedNodes
        };

        // Notify visualization of position updates with structured data
        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
            detail: {
                nodes: this.graphData.nodes,
                edges: this.graphData.edges,
                metadata: this.graphData.metadata
            }
        }));
    }

    handleGraphUpdate = (data) => {
        console.log('Received graph update:', data);
        if (!data || !data.graphData) {
            console.error('Invalid graph update data received:', data);
            return;
        }
        this.updateGraphData(data.graphData);
    }

    updateGraphData = (newData) => {
        console.log('Updating graph data with:', newData);
        
        if (!newData) {
            console.error('Received null or undefined graph data');
            return;
        }

        // Preserve metadata if it exists in newData
        const metadata = newData.metadata || {};
        console.log('Received metadata:', metadata);

        // Handle the case where newData already has nodes and edges arrays
        if (Array.isArray(newData.nodes) && Array.isArray(newData.edges)) {
            // Integrate new positions with existing velocities and metadata
            const nodes = newData.nodes.map(node => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === node.id);
                const nodeMetadata = metadata[`${node.id}.md`] || {};
                
                // Keep existing velocities if available, otherwise initialize to 0
                const vx = existingNode?.vx || 0;
                const vy = existingNode?.vy || 0;
                const vz = existingNode?.vz || 0;

                // Use new position if valid, otherwise keep existing or initialize to 0
                const x = (typeof node.x === 'number' && !isNaN(node.x)) ? node.x : 
                         (existingNode?.x || 0);
                const y = (typeof node.y === 'number' && !isNaN(node.y)) ? node.y :
                         (existingNode?.y || 0);
                const z = (typeof node.z === 'number' && !isNaN(node.z)) ? node.z :
                         (existingNode?.z || 0);

                return {
                    ...node,
                    x, y, z,
                    vx, vy, vz,
                    metadata: nodeMetadata
                };
            });

            this.graphData = {
                nodes,
                edges: newData.edges,
                metadata
            };
        }
        // Handle the case where we need to construct nodes from edges
        else if (Array.isArray(newData.edges)) {
            const nodeSet = new Set();
            newData.edges.forEach(edge => {
                nodeSet.add(edge.source);
                nodeSet.add(edge.target);
            });

            const nodes = Array.from(nodeSet).map(id => {
                const existingNode = this.graphData?.nodes?.find(n => n.id === id);
                const nodeMetadata = metadata[`${id}.md`] || {};
                
                return {
                    id,
                    label: id,
                    // Preserve existing position and velocity if available
                    x: existingNode?.x || 0,
                    y: existingNode?.y || 0,
                    z: existingNode?.z || 0,
                    vx: existingNode?.vx || 0,
                    vy: existingNode?.vy || 0,
                    vz: existingNode?.vz || 0,
                    metadata: nodeMetadata
                };
            });

            this.graphData = {
                nodes,
                edges: newData.edges.map(e => ({
                    source: e.source,
                    target: e.target,
                    weight: e.weight,
                    hyperlinks: e.hyperlinks
                })),
                metadata
            };
        } else {
            console.error('Received invalid graph data:', newData);
            return;
        }

        console.log(`Graph data updated: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
        console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
        
        // Dispatch an event to notify that the graph data has been updated with structured data
        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
            detail: {
                nodes: this.graphData.nodes,
                edges: this.graphData.edges,
                metadata: this.graphData.metadata
            }
        }));

        // If there was a pending recalculation, do it now
        if (this.pendingRecalculation) {
            console.log('Processing pending layout recalculation');
            this.pendingRecalculation = false;
            this.recalculateLayout();
        }

        // If this is the first time we've received graph data, mark it as initial layout
        if (!this.initialLayoutDone) {
            console.log('Performing initial layout calculation');
            this.initialLayoutDone = true;
            this.recalculateLayout(true);
        }
    }

    getGraphData = () => {
        if (this.graphData) {
            console.log(`Returning graph data: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
            console.log('Metadata entries:', Object.keys(this.graphData.metadata).length);
        } else {
            console.warn('Graph data is null');
        }
        return {
            nodes: this.graphData?.nodes || [],
            edges: this.graphData?.edges || [],
            metadata: this.graphData?.metadata || {}
        };
    }

    isGraphDataValid = () => {
        return this.graphData && 
               Array.isArray(this.graphData.nodes) && 
               Array.isArray(this.graphData.edges) &&
               this.graphData.nodes.length > 0;
    }

    updateForceDirectedParams = (name, value) => {
        console.log(`Updating force-directed parameter: ${name} = ${value}`);
        
        // Convert from forceDirected prefixed names to server parameter names
        const paramMap = {
            'forceDirectedIterations': 'iterations',
            'forceDirectedSpring': 'spring_strength',
            'forceDirectedRepulsion': 'repulsion_strength',
            'forceDirectedAttraction': 'attraction_strength',
            'forceDirectedDamping': 'damping'
        };

        const serverParamName = paramMap[name] || name;
        if (this.forceDirectedParams.hasOwnProperty(serverParamName)) {
            this.forceDirectedParams[serverParamName] = value;
            console.log('Force-directed parameters updated:', this.forceDirectedParams);
            
            // Only recalculate if we have valid graph data, otherwise mark as pending
            if (this.isGraphDataValid()) {
                this.recalculateLayout();
            } else {
                console.log('Marking layout recalculation as pending until graph data is available');
                this.pendingRecalculation = true;
            }
        } else {
            console.warn(`Unknown force-directed parameter: ${name}`);
        }
    }

    recalculateLayout = (isInitial = false) => {
        console.log('Requesting server layout recalculation with parameters:', this.forceDirectedParams);
        if (this.isGraphDataValid()) {
            // Create binary data with multiplexed header
            const buffer = new ArrayBuffer(this.graphData.nodes.length * 24 + 4);
            const view = new Float32Array(buffer);
            
            // Pack is_initial_layout and time_step into a single float32:
            // Integer part (0 or 1) = is_initial_layout
            // Decimal part = time_step
            // Example: 0.5 = not initial layout (0) with time_step of 0.5
            //         1.5 = is initial layout (1) with time_step of 0.5
            view[0] = isInitial ? (1 + this.forceDirectedParams.time_step) : this.forceDirectedParams.time_step;

            // Fill position data
            this.graphData.nodes.forEach((node, index) => {
                const offset = index * 6 + 1; // +1 to skip the header
                // Position
                view[offset] = node.x;
                view[offset + 1] = node.y;
                view[offset + 2] = node.z;
                // Velocity
                view[offset + 3] = node.vx || 0;
                view[offset + 4] = node.vy || 0;
                view[offset + 5] = node.vz || 0;
            });

            // Send binary data directly
            this.websocketService.send(buffer);
            
            window.dispatchEvent(new CustomEvent('layoutRecalculationRequested', {
                detail: this.forceDirectedParams
            }));
        } else {
            console.error('Cannot recalculate layout: Invalid graph data');
            this.pendingRecalculation = true;
        }
    }
}

----
services/websocketService.js
// Secure WebSocket service with improved error handling and security measures
export default class WebsocketService {
    // Event emitter implementation
    _events = new Map();

    // Rate limiting configuration
    messageQueue = [];
    messageRateLimit = 50; // messages per second
    messageTimeWindow = 1000; // 1 second
    lastMessageTime = 0;
    
    // Security configuration
    maxMessageSize = 1024 * 1024; // 1MB limit
    maxAudioSize = 5 * 1024 * 1024; // 5MB limit
    maxQueueSize = 100;
    validMessageTypes = new Set([
        'getInitialData',
        'graphUpdate',
        'audioData',
        'answer',
        'error',
        'ragflowResponse',
        'openaiResponse',
        'simulationModeSet',
        'fisheye_settings_updated',  // Use underscore format consistently
        'completion',                // Add completion message type
        'position_update_complete',   // Add position update completion type
        'graphData',                // Add server-sent message types
        'visualSettings',
        'materialSettings',
        'physicsSettings',
        'bloomSettings',
        'fisheyeSettings',
        'updateSettings',           // Add new settings update type
        'settings_updated'          // Add confirmation response type
    ]);

    // WebSocket configuration
    socket = null;
    reconnectAttempts = 0;
    maxRetries = 3;
    retryDelay = 5000;
    
    // Audio configuration
    audioContext = null;
    audioQueue = [];
    isPlaying = false;
    audioInitialized = false;

    constructor() {
        // Initialize connection
        this.connect();
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => this.cleanup());
    }

    // Event emitter methods
    on = (event, callback) => {
        if (!this._events.has(event)) {
            this._events.set(event, []);
        }
        this._events.get(event).push(callback);
    }

    off = (event, callback) => {
        if (!this._events.has(event)) return;
        const callbacks = this._events.get(event);
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
            callbacks.splice(index, 1);
        }
    }

    emit = (event, ...args) => {
        if (!this._events.has(event)) return;
        const callbacks = this._events.get(event);
        callbacks.forEach(callback => {
            try {
                callback(...args);
            } catch (error) {
                console.error(`Error in event listener for ${event}:`, error);
            }
        });
    }

    // Secure WebSocket URL generation
    getWebSocketUrl = () => {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.hostname;
        const port = window.location.port ? `:${window.location.port}` : '';
        const url = `${protocol}//${host}${port}/ws`;
        console.log('Generated WebSocket URL:', url);
        return url;
    }

    // Establish secure WebSocket connection
    connect = () => {
        const url = this.getWebSocketUrl();
        console.log('Attempting to connect to WebSocket at:', url);
        
        try {
            this.socket = new WebSocket(url);
            this.socket.binaryType = 'arraybuffer';  // Set binary type for position updates

            this.socket.onopen = () => {
                console.log('WebSocket connection established');
                this.reconnectAttempts = 0;
                this.emit('open');
                
                // Update connection status indicator
                const statusElement = document.getElementById('connection-status');
                if (statusElement) {
                    statusElement.textContent = 'Connected';
                    statusElement.className = 'connected';
                }
                
                // Request initial graph data and settings
                console.log('Requesting initial data');
                this.send({ type: 'getInitialData' });
                this.processQueuedMessages();
            };

            this.socket.onclose = (event) => {
                console.log('WebSocket connection closed:', event);
                
                // Update connection status indicator
                const statusElement = document.getElementById('connection-status');
                if (statusElement) {
                    statusElement.textContent = 'Disconnected';
                    statusElement.className = 'disconnected';
                }
                
                this.emit('close');
                this.reconnect();
            };

            this.socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.emit('error', error);
            };

            this.socket.onmessage = this.handleMessage;
            
        } catch (error) {
            console.error('Error creating WebSocket connection:', error);
            this.emit('error', error);
        }
    }

    handleMessage = async (event) => {
        try {
            // Handle binary data (position updates)
            if (event.data instanceof ArrayBuffer) {
                // Log received buffer size
                console.log(`Received binary data of size: ${event.data.byteLength} bytes`);
                
                // Convert ArrayBuffer to Float32Array for position updates
                const positions = new Float32Array(event.data);
                const positionUpdates = [];
                
                // Extract header (first float32)
                const header = positions[0];
                const isInitialLayout = header >= 1.0;
                const timeStep = header % 1.0;
                console.log(`Received position update: isInitial=${isInitialLayout}, timeStep=${timeStep}`);
                
                // Process position data (skip header)
                for (let i = 1; i < positions.length; i += 6) {  // Start from 1 to skip header
                    if (i + 5 < positions.length) {  // Ensure we have complete node data
                        positionUpdates.push([
                            positions[i],     // x
                            positions[i + 1], // y
                            positions[i + 2], // z
                            positions[i + 3], // vx
                            positions[i + 4], // vy
                            positions[i + 5]  // vz
                        ]);
                    }
                }

                console.log(`Processed ${positionUpdates.length} node position updates`);

                // Emit the gpuPositions event with the updates
                this.emit('gpuPositions', { positions: positionUpdates });

                // Also dispatch the event for backward compatibility
                window.dispatchEvent(new CustomEvent('binaryPositionUpdate', {
                    detail: positionUpdates
                }));
                return;
            }

            // Handle JSON messages
            let data;
            try {
                data = JSON.parse(event.data);
            } catch (error) {
                console.error('Failed to parse JSON message:', error);
                console.error('Raw message:', event.data);
                this.emit('error', { 
                    type: 'parse_error', 
                    message: 'Invalid JSON message received',
                    details: error.message
                });
                return;
            }

            // Validate message size
            if (event.data.length > this.maxMessageSize) {
                console.error('Message exceeds size limit');
                this.emit('error', { 
                    type: 'size_error', 
                    message: 'Message size exceeds limit'
                });
                return;
            }

            // Validate message type
            if (!data.type || !this.validMessageTypes.has(data.type)) {
                console.error('Invalid message type:', data.type);
                this.emit('error', { 
                    type: 'validation_error', 
                    message: 'Invalid message type'
                });
                return;
            }

            // Process the validated message
            this.handleServerMessage(data);

        } catch (error) {
            console.error('Error processing WebSocket message:', error);
            console.error('Error stack:', error.stack);
            this.emit('error', { 
                type: 'processing_error', 
                message: error.message
            });
        }
    }

    reconnect = () => {
        if (this.reconnectAttempts < this.maxRetries) {
            this.reconnectAttempts++;
            console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxRetries}) in ${this.retryDelay / 1000} seconds...`);
            setTimeout(() => this.connect(), this.retryDelay);
        } else {
            console.error('Max reconnection attempts reached. Please refresh the page or check your connection.');
            this.emit('maxReconnectAttemptsReached');
        }
    }

    send = (data) => {
        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            if (data instanceof ArrayBuffer) {
                // Log binary data size before sending
                console.log(`Sending binary data of size: ${data.byteLength} bytes`);
                this.socket.send(data);
            } else {
                // Send JSON data
                console.log('Sending WebSocket message:', data);
                try {
                    this.socket.send(JSON.stringify(data));
                } catch (error) {
                    console.error('Error sending WebSocket message:', error);
                    this.emit('error', { type: 'send_error', message: error.message });
                }
            }
        } else {
            console.warn('WebSocket not open. Queuing message...');
            this.queueMessage(data);
        }
    }

    queueMessage = (data) => {
        if (this.messageQueue.length >= this.maxQueueSize) {
            console.warn('Message queue full. Dropping message:', data);
            return;
        }
        this.messageQueue.push(data);
    }

    processQueuedMessages = () => {
        const now = Date.now();
        const messagesToSend = [];
        let messageCount = 0;
        for (const message of this.messageQueue) {
            if (messageCount < this.messageRateLimit && now - this.lastMessageTime >= this.messageTimeWindow / this.messageRateLimit) {
                messagesToSend.push(message);
                this.lastMessageTime = now;
                messageCount++;
            } else {
                break; // Stop if rate limit is reached
            }
        }
        this.messageQueue.splice(0, messagesToSend.length);
        messagesToSend.forEach(message => this.send(message));
    }

    // Helper function to handle graph data consistently
    handleGraphData = (data) => {
        const graphData = {
            nodes: Array.isArray(data.nodes) ? data.nodes : 
                   Array.isArray(data.graph_data?.nodes) ? data.graph_data.nodes : [],
            edges: Array.isArray(data.edges) ? data.edges : 
                   Array.isArray(data.graph_data?.edges) ? data.graph_data.edges : [],
            metadata: data.metadata || data.graph_data?.metadata || {}
        };
        
        console.log('Emitting graph update with structured data:', graphData);
        // Emit both events to ensure compatibility
        this.emit('graphUpdate', { graphData });
        window.dispatchEvent(new CustomEvent('graphDataUpdated', {
            detail: graphData
        }));
    }

    handleServerMessage = (data) => {
        console.log('Handling server message:', data);
        
        // Validate message type
        if (!this.validMessageTypes.has(data.type)) {
            console.warn('Received message with invalid type:', data.type);
            return;
        }
        
        // First emit the raw message for any listeners that need it
        this.emit('message', data);
        
        // Then handle specific message types
        switch (data.type) {
            case 'graphData':
            case 'graphUpdate':
                this.handleGraphData(data);
                break;

            case 'getInitialData':
            case 'serverSettings':
                console.log('Received settings from server:', data.settings);
                this.emit('serverSettings', data.settings);
                break;

            case 'audioData':
                this.handleAudioData(data.audio_data);
                break;
                
            case 'answer':
                this.emit('ragflowAnswer', data.answer);
                break;
                
            case 'error':
                console.error('Server error:', data.message);
                this.emit('error', { type: 'server_error', message: data.message });
                break;
                
            case 'ragflowResponse':
                this.handleRagflowResponse(data);
                break;
                
            case 'openaiResponse':
                this.emit('openaiResponse', data.response);
                break;
                
            case 'simulationModeSet':
                console.log('Simulation mode set:', data.mode);
                this.emit('simulationModeSet', data.mode);
                break;

            case 'fisheye_settings_updated':
                console.log('Fisheye settings updated:', data);
                const settings = {
                    enabled: data.fisheye_enabled,
                    strength: data.fisheye_strength,
                    focusPoint: [
                        data.fisheye_focus_x,
                        data.fisheye_focus_y,
                        data.fisheye_focus_z
                    ],
                    radius: data.fisheye_radius
                };
                window.dispatchEvent(new CustomEvent('fisheyeSettingsUpdated', {
                    detail: settings
                }));
                break;

            case 'settings_updated':
                console.log('Settings successfully updated:', data.settings);
                this.emit('serverSettings', data.settings);
                window.dispatchEvent(new CustomEvent('settingsUpdated', {
                    detail: data.settings
                }));
                break;

            case 'completion':
                console.log('Received completion message:', data.message);
                this.emit('completion', data.message);
                break;

            case 'position_update_complete':
                console.log('Position update completed:', data.status);
                this.emit('positionUpdateComplete', data.status);
                break;

            // Settings update messages
            case 'visualSettings':
            case 'materialSettings':
            case 'physicsSettings':
            case 'bloomSettings':
            case 'fisheyeSettings':
                this.emit('serverSettings', {
                    [data.type.replace('Settings', '')]: data.settings
                });
                break;
                
            default:
                console.warn('Unhandled message type:', data.type);
                break;
        }
    }

    handleRagflowResponse = (data) => {
        console.log('Handling RAGFlow response:', data);
        this.emit('ragflowAnswer', data.answer);
        if (data.audio) {
            const audioBlob = this.base64ToBlob(data.audio, 'audio/wav');
            this.handleAudioData(audioBlob);
        } else {
            console.warn('No audio data in RAGFlow response');
        }
    }

    base64ToBlob = (base64, mimeType) => {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
    }

    handleAudioData = async (audioBlob) => {
        if (!this.audioContext) {
            console.warn('AudioContext not initialized. Waiting for user interaction...');
            return;
        }

        try {
            console.log('Audio Blob size:', audioBlob.size);
            console.log('Audio Blob type:', audioBlob.type);
            const arrayBuffer = await audioBlob.arrayBuffer();
            console.log('ArrayBuffer size:', arrayBuffer.byteLength);
            const audioBuffer = await this.decodeWavData(arrayBuffer);
            this.audioQueue.push(audioBuffer);
            if (!this.isPlaying) {
                this.playNextAudio();
            }
        } catch (error) {
            console.error('Error processing audio data:', error);
            this.emit('error', { type: 'audio_processing_error', message: error.message });
        }
    }

    decodeWavData = async (wavData) => {
        return new Promise((resolve, reject) => {
            console.log('WAV data size:', wavData.byteLength);
            const dataView = new DataView(wavData.slice(0, 16));
            const header = new TextDecoder().decode(dataView);
            console.log('Header:', header);
            if (header !== 'RIFF') {
                console.error('Invalid WAV header:', header);
                return reject(new Error(`Invalid WAV header: ${header}`));
            }

            this.audioContext.decodeAudioData(
                wavData,
                (buffer) => {
                    console.log('Audio successfully decoded:', buffer);
                    resolve(buffer);
                },
                (error) => {
                    console.error('Error in decodeAudioData:', error);
                    reject(new Error(`Error decoding WAV data: ${error}`));
                }
            );
        });
    }

    playNextAudio = () => {
        if (this.audioQueue.length === 0) {
            this.isPlaying = false;
            return;
        }

        this.isPlaying = true;
        const audioBuffer = this.audioQueue.shift();
        const source = this.audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(this.audioContext.destination);
        source.onended = () => this.playNextAudio();
        source.start();
    }

    initAudio = () => {
        if (this.audioInitialized) {
            console.log('Audio already initialized');
            return;
        }

        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.audioInitialized = true;
            console.log('AudioContext initialized');

            // Process any queued audio data
            if (this.audioQueue.length > 0 && !this.isPlaying) {
                this.playNextAudio();
            }
        } catch (error) {
            console.error('Failed to initialize AudioContext:', error);
            this.emit('error', { type: 'audio_init_error', message: error.message });
        }
    }

    setSimulationMode = (mode) => {
        this.send({
            type: 'setSimulationMode',
            mode: mode
        });
    }

    sendChatMessage = ({ message, useOpenAI }) => {
        this.send({
            type: 'chatMessage',
            message,
            use_openai: useOpenAI
        });
    }

    updateFisheyeSettings = (settings) => {
        console.log('Updating fisheye settings:', settings);
        const focus_point = settings.focusPoint || [0, 0, 0];
        this.send({
            type: 'updateFisheyeSettings',
            enabled: settings.enabled,
            strength: settings.strength,
            focus_point: focus_point,
            radius: settings.radius || 100.0
        });
    }

    updateSettings = (settings) => {
        console.log('Sending settings update:', settings);
        this.send({
            type: 'updateSettings',
            settings
        });
    }

    cleanup = () => {
        if (this.socket) {
            this.socket.close();
        }
        if (this.audioContext) {
            this.audioContext.close();
        }
    }
}

----
components/VRControlPanel.js
import * as THREE from 'three';

export class VRControlPanel {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.panel = new THREE.Group();
        this.controls = new Map();
        this.initPanel();
    }

    initPanel() {
        // Create a background panel
        const panelGeometry = new THREE.PlaneGeometry(1, 1.5);
        const panelMaterial = new THREE.MeshBasicMaterial({ color: 0x202020, transparent: true, opacity: 0.7 });
        const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
        this.panel.add(panelMesh);

        // Position the panel in front of the camera
        this.panel.position.set(0, 0, -2);
        this.panel.lookAt(this.camera.position);

        this.scene.add(this.panel);
    }

    createSlider(name, min, max, value, y) {
        const sliderGroup = new THREE.Group();
        sliderGroup.name = name;

        // Create slider track
        const trackGeometry = new THREE.PlaneGeometry(0.8, 0.05);
        const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x505050 });
        const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
        sliderGroup.add(trackMesh);

        // Create slider handle
        const handleGeometry = new THREE.SphereGeometry(0.03);
        const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
        handleMesh.position.x = this.mapValue(value, min, max, -0.4, 0.4);
        sliderGroup.add(handleMesh);

        // Create label
        const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
        const labelMaterial = new THREE.MeshBasicMaterial({ map: this.createTextTexture(name) });
        const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
        labelMesh.position.set(-0.6, 0, 0);
        sliderGroup.add(labelMesh);

        sliderGroup.position.set(0, y, 0.01);
        this.panel.add(sliderGroup);
        this.controls.set(name, { group: sliderGroup, min, max, value });
    }

    createColorPicker(name, value, y) {
        const pickerGroup = new THREE.Group();
        pickerGroup.name = name;

        // Create color swatch
        const swatchGeometry = new THREE.PlaneGeometry(0.1, 0.1);
        const swatchMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(value) });
        const swatchMesh = new THREE.Mesh(swatchGeometry, swatchMaterial);
        pickerGroup.add(swatchMesh);

        // Create label
        const labelGeometry = new THREE.PlaneGeometry(0.4, 0.1);
        const labelMaterial = new THREE.MeshBasicMaterial({ map: this.createTextTexture(name) });
        const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
        labelMesh.position.set(-0.3, 0, 0);
        pickerGroup.add(labelMesh);

        pickerGroup.position.set(0, y, 0.01);
        this.panel.add(pickerGroup);
        this.controls.set(name, { group: pickerGroup, value });
    }

    createTextTexture(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        context.font = '48px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 128, 32);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    mapValue(value, inMin, inMax, outMin, outMax) {
        return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    }

    updateControl(name, value) {
        const control = this.controls.get(name);
        if (control) {
            if (control.min !== undefined && control.max !== undefined) {
                // It's a slider
                const handle = control.group.children[1];
                handle.position.x = this.mapValue(value, control.min, control.max, -0.4, 0.4);
            } else {
                // It's a color picker
                const swatch = control.group.children[0];
                swatch.material.color.set(value);
            }
            control.value = value;
        }
    }

    handleInteraction(intersection) {
        const controlName = intersection.object.parent.name;
        const control = this.controls.get(controlName);
        if (control) {
            if (control.min !== undefined && control.max !== undefined) {
                // It's a slider
                const newValue = this.mapValue(intersection.point.x, -0.4, 0.4, control.min, control.max);
                this.updateControl(controlName, newValue);
                return { name: controlName, value: newValue };
            } else {
                // It's a color picker
                // For simplicity, we'll just cycle through a few preset colors
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
                const currentIndex = colors.indexOf(control.value);
                const newValue = colors[(currentIndex + 1) % colors.length];
                this.updateControl(controlName, newValue);
                return { name: controlName, value: '#' + newValue.toString(16).padStart(6, '0') };
            }
        }
        return null;
    }
}

----
components/ControlPanel.vue
<!-- Previous template and style sections remain the same -->

<script>
import { defineComponent, ref, reactive, onMounted } from 'vue';

export default defineComponent({
    name: 'ControlPanel',
    props: {
        websocketService: {
            type: Object,
            required: true
        }
    },
    setup(props, { emit }) {
        // Panel state
        const isHidden = ref(false);
        const audioInitialized = ref(false);
        const simulationMode = ref('remote');

        // Collapsed state for groups
        const collapsedGroups = reactive({
            audio: true,
            nodeAppearance: true,
            edgeAppearance: true,
            bloom: true,
            physics: true,
            environment: true,
            fisheye: true
        });

        // Node appearance controls
        const nodeColors = reactive([
            { name: 'nodeColor', label: 'Base Node Color', value: '#1A0B31' },
            { name: 'nodeColorNew', label: 'New Nodes', value: '#00ff88' },
            { name: 'nodeColorRecent', label: 'Recent Nodes', value: '#4444ff' },
            { name: 'nodeColorMedium', label: 'Medium Age', value: '#ffaa00' },
            { name: 'nodeColorOld', label: 'Old Nodes', value: '#ff4444' },
            { name: 'nodeColorCore', label: 'Core Nodes', value: '#ffa500' },
            { name: 'nodeColorSecondary', label: 'Secondary Nodes', value: '#00ffff' }
        ]);

        const materialProperties = reactive([
            { name: 'nodeMaterialMetalness', label: 'Metalness', value: 0.2, min: 0, max: 1, step: 0.1 },
            { name: 'nodeMaterialRoughness', label: 'Roughness', value: 0.2, min: 0, max: 1, step: 0.1 },
            { name: 'nodeMaterialClearcoat', label: 'Clearcoat', value: 0.3, min: 0, max: 1, step: 0.1 },
            { name: 'nodeMaterialClearcoatRoughness', label: 'Clearcoat Roughness', value: 0.2, min: 0, max: 1, step: 0.1 },
            { name: 'nodeMaterialOpacity', label: 'Opacity', value: 0.9, min: 0, max: 1, step: 0.1 },
            { name: 'nodeEmissiveMin', label: 'Min Emissive', value: 0.3, min: 0, max: 1, step: 0.1 },
            { name: 'nodeEmissiveMax', label: 'Max Emissive', value: 1.0, min: 0, max: 2, step: 0.1 }
        ]);

        const sizeControls = reactive([
            { name: 'minNodeSize', label: 'Minimum Size', value: 0.1, min: 0.05, max: 0.5, step: 0.05 },
            { name: 'maxNodeSize', label: 'Maximum Size', value: 0.3, min: 0.1, max: 1.0, step: 0.1 }
        ]);

        // Edge appearance controls
        const edgeControls = reactive([
            { name: 'edgeColor', label: 'Edge Color', value: '#ff0000', type: 'color' },
            { name: 'edgeOpacity', label: 'Opacity', value: 0.3, min: 0, max: 1, step: 0.1 },
            { name: 'edgeWeightNorm', label: 'Weight Normalization', value: 10.0, min: 1, max: 20, step: 0.5 },
            { name: 'edgeMinWidth', label: 'Minimum Width', value: 1.0, min: 0.5, max: 5, step: 0.5 },
            { name: 'edgeMaxWidth', label: 'Maximum Width', value: 5.0, min: 1, max: 10, step: 0.5 }
        ]);

        // Bloom effect controls
        const bloomControls = reactive({
            nodes: {
                label: 'Node Bloom',
                controls: [
                    { name: 'nodeBloomStrength', label: 'Strength', value: 0.1, min: 0, max: 2, step: 0.1 },
                    { name: 'nodeBloomRadius', label: 'Radius', value: 0.1, min: 0, max: 1, step: 0.1 },
                    { name: 'nodeBloomThreshold', label: 'Threshold', value: 0.0, min: 0, max: 1, step: 0.1 }
                ]
            },
            edges: {
                label: 'Edge Bloom',
                controls: [
                    { name: 'edgeBloomStrength', label: 'Strength', value: 0.2, min: 0, max: 2, step: 0.1 },
                    { name: 'edgeBloomRadius', label: 'Radius', value: 0.3, min: 0, max: 1, step: 0.1 },
                    { name: 'edgeBloomThreshold', label: 'Threshold', value: 0.0, min: 0, max: 1, step: 0.1 }
                ]
            },
            environment: {
                label: 'Environment Bloom',
                controls: [
                    { name: 'envBloomStrength', label: 'Strength', value: 0.5, min: 0, max: 2, step: 0.1 },
                    { name: 'envBloomRadius', label: 'Radius', value: 0.1, min: 0, max: 1, step: 0.1 },
                    { name: 'envBloomThreshold', label: 'Threshold', value: 0.0, min: 0, max: 1, step: 0.1 }
                ]
            }
        });

        // Physics simulation controls
        const physicsControls = reactive([
            { name: 'iterations', label: 'Iterations', value: 250, min: 100, max: 500, step: 10 },
            { name: 'springStrength', label: 'Spring Strength', value: 0.01, min: 0.001, max: 0.1, step: 0.001 },
            { name: 'repulsionStrength', label: 'Repulsion', value: 1000.0, min: 100, max: 2000, step: 100 },
            { name: 'attractionStrength', label: 'Attraction', value: 0.01, min: 0.001, max: 0.1, step: 0.001 },
            { name: 'damping', label: 'Damping', value: 0.8, min: 0.1, max: 1.0, step: 0.1 }
        ]);

        // Environment controls
        const hologramControls = reactive([
            { name: 'hologramColor', label: 'Color', value: '#FFD700', type: 'color' },
            { name: 'hologramScale', label: 'Scale', value: 5, min: 1, max: 10, step: 1 },
            { name: 'hologramOpacity', label: 'Opacity', value: 0.1, min: 0, max: 1, step: 0.05 }
        ]);

        const fogDensity = ref(0.002);

        // Fisheye controls
        const fisheyeEnabled = ref(false);
        const fisheyeControls = reactive([
            { name: 'fisheyeStrength', label: 'Strength', value: 0.5, min: 0, max: 1, step: 0.1 },
            { name: 'fisheyeRadius', label: 'Radius', value: 100.0, min: 10, max: 200, step: 10 },
            { name: 'fisheyeFocusX', label: 'Focus X', value: 0.0, min: -100, max: 100, step: 1 },
            { name: 'fisheyeFocusY', label: 'Focus Y', value: 0.0, min: -100, max: 100, step: 1 },
            { name: 'fisheyeFocusZ', label: 'Focus Z', value: 0.0, min: -100, max: 100, step: 1 }
        ]);

        // Methods
        const togglePanel = () => {
            isHidden.value = !isHidden.value;
        };

        const toggleGroup = (group) => {
            collapsedGroups[group] = !collapsedGroups[group];
        };

        const initializeAudio = async () => {
            if (props.websocketService) {
                try {
                    await props.websocketService.initAudio();
                    audioInitialized.value = true;
                    console.log('Audio system initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize audio:', error);
                    audioInitialized.value = false;
                }
            }
        };

        const setSimulationMode = () => {
            if (props.websocketService) {
                props.websocketService.setSimulationMode(simulationMode.value);
            }
        };

        const emitChange = (name, value) => {
            emit('control-change', { name, value });
            if (props.websocketService) {
                props.websocketService.send({
                    type: 'settingUpdate',
                    setting: name,
                    value: value
                });
            }
        };

        const saveSettings = () => {
            if (props.websocketService) {
                const settings = {
                    visualization: {
                        node_color: nodeColors.find(c => c.name === 'nodeColor')?.value,
                        node_color_new: nodeColors.find(c => c.name === 'nodeColorNew')?.value,
                        node_color_recent: nodeColors.find(c => c.name === 'nodeColorRecent')?.value,
                        node_color_medium: nodeColors.find(c => c.name === 'nodeColorMedium')?.value,
                        node_color_old: nodeColors.find(c => c.name === 'nodeColorOld')?.value,
                        node_color_core: nodeColors.find(c => c.name === 'nodeColorCore')?.value,
                        node_color_secondary: nodeColors.find(c => c.name === 'nodeColorSecondary')?.value,
                        edge_color: edgeControls.find(c => c.name === 'edgeColor')?.value,
                        edge_opacity: edgeControls.find(c => c.name === 'edgeOpacity')?.value || 0.4,
                        edge_weight_normalization: edgeControls.find(c => c.name === 'edgeWeightNorm')?.value || 12.0,
                        edge_min_width: edgeControls.find(c => c.name === 'edgeMinWidth')?.value || 1.5,
                        edge_max_width: edgeControls.find(c => c.name === 'edgeMaxWidth')?.value || 6.0,
                        node_material_metalness: materialProperties.find(p => p.name === 'nodeMaterialMetalness')?.value || 0.3,
                        node_material_roughness: materialProperties.find(p => p.name === 'nodeMaterialRoughness')?.value || 0.5,
                        node_material_clearcoat: materialProperties.find(p => p.name === 'nodeMaterialClearcoat')?.value || 0.8,
                        node_material_clearcoat_roughness: materialProperties.find(p => p.name === 'nodeMaterialClearcoatRoughness')?.value || 0.1,
                        node_material_opacity: materialProperties.find(p => p.name === 'nodeMaterialOpacity')?.value || 0.95,
                        node_emissive_min_intensity: materialProperties.find(p => p.name === 'nodeEmissiveMin')?.value || 0.0,
                        node_emissive_max_intensity: materialProperties.find(p => p.name === 'nodeEmissiveMax')?.value || 0.3,
                        min_node_size: sizeControls.find(s => s.name === 'minNodeSize')?.value || 0.15,
                        max_node_size: sizeControls.find(s => s.name === 'maxNodeSize')?.value || 0.4,
                        force_directed_iterations: physicsControls.find(p => p.name === 'iterations')?.value || 300,
                        force_directed_spring: physicsControls.find(p => p.name === 'springStrength')?.value || 0.015,
                        force_directed_repulsion: physicsControls.find(p => p.name === 'repulsionStrength')?.value || 1200.0,
                        force_directed_attraction: physicsControls.find(p => p.name === 'attractionStrength')?.value || 0.012,
                        force_directed_damping: physicsControls.find(p => p.name === 'damping')?.value || 0.85,
                        hologram_color: hologramControls.find(h => h.name === 'hologramColor')?.value || '#FFC125',
                        hologram_scale: hologramControls.find(h => h.name === 'hologramScale')?.value || 6.0,
                        hologram_opacity: hologramControls.find(h => h.name === 'hologramOpacity')?.value || 0.15,
                        fog_density: fogDensity.value || 0.001
                    },
                    bloom: {
                        node_bloom_strength: bloomControls.nodes.controls.find(c => c.name === 'nodeBloomStrength')?.value || 0.8,
                        node_bloom_radius: bloomControls.nodes.controls.find(c => c.name === 'nodeBloomRadius')?.value || 0.3,
                        node_bloom_threshold: bloomControls.nodes.controls.find(c => c.name === 'nodeBloomThreshold')?.value || 0.2,
                        edge_bloom_strength: bloomControls.edges.controls.find(c => c.name === 'edgeBloomStrength')?.value || 0.6,
                        edge_bloom_radius: bloomControls.edges.controls.find(c => c.name === 'edgeBloomRadius')?.value || 0.4,
                        edge_bloom_threshold: bloomControls.edges.controls.find(c => c.name === 'edgeBloomThreshold')?.value || 0.1,
                        environment_bloom_strength: bloomControls.environment.controls.find(c => c.name === 'envBloomStrength')?.value || 0.7,
                        environment_bloom_radius: bloomControls.environment.controls.find(c => c.name === 'envBloomRadius')?.value || 0.3,
                        environment_bloom_threshold: bloomControls.environment.controls.find(c => c.name === 'envBloomThreshold')?.value || 0.1
                    },
                    fisheye: {
                        enabled: fisheyeEnabled.value,
                        strength: fisheyeControls.find(c => c.name === 'fisheyeStrength')?.value || 0.5,
                        radius: fisheyeControls.find(c => c.name === 'fisheyeRadius')?.value || 100.0,
                        focus_x: fisheyeControls.find(c => c.name === 'fisheyeFocusX')?.value || 0.0,
                        focus_y: fisheyeControls.find(c => c.name === 'fisheyeFocusY')?.value || 0.0,
                        focus_z: fisheyeControls.find(c => c.name === 'fisheyeFocusZ')?.value || 0.0
                    }
                };

                console.log('Saving settings to TOML:', settings);
                
                props.websocketService.send({
                    type: 'saveSettings',
                    settings
                });
            }
        };

        // Initialize settings from server
        onMounted(() => {
            if (props.websocketService) {
                props.websocketService.on('serverSettings', (settings) => {
                    console.log('Received server settings:', settings);

                    // Helper function to update reactive values
                    const updateValue = (obj, path, value) => {
                        if (!value) return;
                        const target = path.split('.').reduce((acc, key) => acc?.[key], obj);
                        if (target && 'value' in target) {
                            target.value = value;
                        }
                    };

                    // Update visualization settings
                    if (settings.visualization) {
                        // Update node colors - no need for hex conversion
                        nodeColors.forEach(color => {
                            const settingName = color.name
                                .replace(/([A-Z])/g, '_$1')
                                .toLowerCase();
                            updateValue(nodeColors, color.name, settings.visualization[settingName]);
                        });

                        // Update material properties
                        materialProperties.forEach(prop => {
                            const settingName = prop.name
                                .replace(/([A-Z])/g, '_$1')
                                .toLowerCase();
                            updateValue(materialProperties, prop.name, settings.visualization[settingName]);
                        });

                        // Update other controls
                        updateValue(sizeControls, 'minNodeSize', settings.visualization.min_node_size);
                        updateValue(sizeControls, 'maxNodeSize', settings.visualization.max_node_size);
                        updateValue(edgeControls, 'edgeColor', settings.visualization.edge_color);
                        updateValue(hologramControls, 'hologramColor', settings.visualization.hologram_color);
                        fogDensity.value = settings.visualization.fog_density ?? fogDensity.value;
                    }

                    // Update bloom settings
                    if (settings.bloom) {
                        Object.entries(bloomControls).forEach(([group, config]) => {
                            config.controls.forEach(control => {
                                const settingName = control.name
                                    .replace(/([A-Z])/g, '_$1')
                                    .toLowerCase();
                                updateValue(bloomControls[group].controls, control.name, settings.bloom[settingName]);
                            });
                        });
                    }

                    // Update fisheye settings
                    if (settings.fisheye) {
                        fisheyeEnabled.value = settings.fisheye.enabled ?? fisheyeEnabled.value;
                        fisheyeControls.forEach(control => {
                            const settingName = control.name
                                .replace(/([A-Z])/g, '_$1')
                                .toLowerCase();
                            updateValue(fisheyeControls, control.name, settings.fisheye[settingName]);
                        });
                    }
                });
            }
        });

        return {
            isHidden,
            audioInitialized,
            simulationMode,
            collapsedGroups,
            nodeColors,
            nodeMaterialMetalness,
            minNodeSize,
            edgeControls,
            bloomControls,
            physicsControls,
            hologramControls,
            fogDensity,
            fisheyeEnabled,
            fisheyeControls,
            togglePanel,
            toggleGroup,
            initializeAudio,
            setSimulationMode,
            emitChange,
            saveSettings
        };
    }
});
</script>

<style scoped>
#control-panel {
    position: fixed;
    top: 20px;
    right: 0;
    width: 300px;
    max-height: 90vh;
    background-color: rgba(20, 20, 20, 0.9);
    color: #ffffff;
    border-radius: 10px 0 0 10px;
    overflow-y: auto;
    z-index: 1000;
    transition: transform 0.3s ease-in-out;
    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
}

#control-panel.hidden {
    transform: translateX(calc(100% - 40px));
}

.toggle-button {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%) rotate(-90deg);
    transform-origin: left center;
    background-color: rgba(20, 20, 20, 0.9);
    color: #ffffff;
    border: none;
    padding: 8px 16px;
    cursor: pointer;
    border-radius: 5px 5px 0 0;
    font-size: 0.9em;
    white-space: nowrap;
}

.panel-content {
    padding: 20px;
}

.control-group {
    margin-bottom: 16px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    overflow: hidden;
}

.group-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: rgba(255, 255, 255, 0.1);
    cursor: pointer;
}

.group-header h3 {
    margin: 0;
    font-size: 1em;
    font-weight: 500;
}

.group-content {
    padding: 12px;
}

.control-item {
    margin-bottom: 12px;
}

.control-item label {
    display: block;
    margin-bottom: 4px;
    font-size: 0.9em;
    color: #cccccc;
}

.control-item input[type="range"] {
    width: 100%;
    height: 6px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    -webkit-appearance: none;
}

.control-item input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background-color: #ffffff;
    border-radius: 50%;
    cursor: pointer;
}

.control-item input[type="color"] {
    width: 100%;
    height: 30px;
    border: none;
    border-radius: 4px;
    background-color: transparent;
}

.range-value {
    float: right;
    font-size: 0.8em;
    color: #999999;
}

.save-button {
    width: 100%;
    padding: 12px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
}

.save-button:hover {
    background-color: #45a049;
}

select {
    width: 100%;
    padding: 8px;
    background-color: rgba(255, 255, 255, 0.1);
    color: #ffffff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

select option {
    background-color: #1a1a1a;
    color: #ffffff;
}

/* Add new styles for sub-groups */
.sub-group {
    margin: 10px 0;
    padding: 10px;
    background-color: rgba(255, 255, 255, 0.03);
    border-radius: 4px;
}

.sub-group h4 {
    margin: 0 0 10px 0;
    font-size: 0.9em;
    color: #aaa;
}

/* Audio status styles */
.audio-status {
    text-align: center;
    padding: 10px;
}

.status-indicator {
    padding: 5px 10px;
    border-radius: 3px;
    font-size: 0.9em;
}

.status-indicator.enabled {
    background-color: rgba(40, 167, 69, 0.2);
    color: #28a745;
}

/* Save button styling */
.save-button {
    width: 100%;
    padding: 12px;
    margin-top: 20px;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
}

.save-button:hover {
    background-color: #218838;
}
</style>

----
components/interface.js
// public/js/components/interface.js

/**
 * Interface class manages UI elements like error messages and information panels.
 */
export class Interface {
  /**
   * Creates a new Interface instance.
   * @param {Document} document - The DOM document.
   */
  constructor(document) {
      this.document = document;
      this.createUI();
      this.setupEventListeners();
  }

  /**
   * Creates necessary UI elements and appends them to the DOM.
   */
  createUI() {
      // Create Node Information Panel
      this.createNodeInfoPanel();
  }

  /**
   * Creates a panel to display information about selected nodes.
   */
  createNodeInfoPanel() {
      const infoPanel = this.document.createElement('div');
      infoPanel.id = 'node-info-panel';
      infoPanel.style.position = 'absolute';
      infoPanel.style.top = '20px';
      infoPanel.style.left = '20px';
      infoPanel.style.width = '300px';
      infoPanel.style.maxHeight = '40vh';
      infoPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      infoPanel.style.color = 'white';
      infoPanel.style.padding = '15px';
      infoPanel.style.borderRadius = '8px';
      infoPanel.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
      infoPanel.style.overflowY = 'auto';
      infoPanel.style.display = 'none'; // Hidden by default
      this.document.body.appendChild(infoPanel);

      this.nodeInfoPanel = infoPanel;
  }

  /**
   * Sets up event listeners for custom events.
   */
  setupEventListeners() {
      // Listen for node selection events
      window.addEventListener('nodeSelected', (event) => {
          const nodeInfo = event.detail;
          this.updateNodeInfoPanel(nodeInfo);
      });
  }

  /**
   * Displays an error message on the screen.
   * @param {string} message - The error message to display.
   */
  displayErrorMessage(message) {
      const errorContainer = this.document.createElement('div');
      errorContainer.style.position = 'fixed';
      errorContainer.style.top = '50%';
      errorContainer.style.left = '50%';
      errorContainer.style.transform = 'translate(-50%, -50%)';
      errorContainer.style.backgroundColor = 'rgba(255, 0, 0, 0.85)';
      errorContainer.style.color = 'white';
      errorContainer.style.padding = '20px';
      errorContainer.style.borderRadius = '8px';
      errorContainer.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.3)';
      errorContainer.style.zIndex = '1000';
      errorContainer.textContent = message;

      this.document.body.appendChild(errorContainer);

      // Remove the error message after 5 seconds
      setTimeout(() => {
          if (this.document.body.contains(errorContainer)) {
              this.document.body.removeChild(errorContainer);
          }
      }, 5000);
  }

  /**
   * Updates the Node Information Panel with details of the selected node.
   * @param {object} node - The node object containing its details.
   */
  updateNodeInfoPanel(node) {
      if (!node) {
          this.nodeInfoPanel.style.display = 'none';
          return;
      }

      this.nodeInfoPanel.innerHTML = `
          <h3>Node Information</h3>
          <p><strong>ID:</strong> ${node.id}</p>
          <p><strong>Name:</strong> ${node.name}</p>
          <!-- Add more node properties as needed -->
      `;
      this.nodeInfoPanel.style.display = 'block';
  }
}

----
components/chatManager.vue
<script>
import { defineComponent, ref, onUpdated, onBeforeUnmount } from 'vue';

export default defineComponent({
    name: 'ChatManager',
    props: {
        websocketService: {
            type: Object,
            required: true
        }
    },
    data() {
        return {
            chatInput: '',
            chatMessages: [],
            useOpenAI: false
        };
    },
    methods: {
        sendMessage() {
            if (this.chatInput.trim()) {
                this.websocketService.sendChatMessage({
                    message: this.chatInput,
                    useOpenAI: this.useOpenAI
                });
                this.chatMessages.push({ sender: 'You', message: this.chatInput });
                this.chatInput = '';
            }
        },
        toggleTTS() {
            this.websocketService.toggleTTS(this.useOpenAI);
            console.log(`TTS method set to: ${this.useOpenAI ? 'OpenAI' : 'Sonata'}`);
        },
        handleRagflowAnswer(answer) {
            if (!this.useOpenAI && typeof answer === 'string') {
                this.chatMessages.push({ sender: 'AI', message: answer });
            }
        },
        handleOpenAIResponse(response) {
            // Only show text responses when not using OpenAI TTS
            if (!this.useOpenAI && typeof response === 'string') {
                this.chatMessages.push({ sender: 'AI', message: response });
            }
        }
    },
    mounted() {
        if (this.websocketService) {
            this.websocketService.on('ragflowAnswer', this.handleRagflowAnswer);
            this.websocketService.on('openaiResponse', this.handleOpenAIResponse);
        } else {
            console.error('WebSocketService is undefined');
        }
    },
    beforeUnmount() {
        if (this.websocketService) {
            this.websocketService.off('ragflowAnswer', this.handleRagflowAnswer);
            this.websocketService.off('openaiResponse', this.handleOpenAIResponse);
        }
    },
    setup() {
        const chatMessagesRef = ref(null);

        const scrollToBottom = () => {
            if (chatMessagesRef.value) {
                chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight;
            }
        };

        onUpdated(() => {
            scrollToBottom();
        });

        return {
            chatMessagesRef
        };
    }
});
</script>

<template>
    <div class="chat-container">
        <div class="chat-messages" ref="chatMessagesRef" :class="{ 'hide-messages': useOpenAI }">
            <div v-for="(msg, index) in chatMessages" :key="index" class="message">
                <strong>{{ msg.sender }}:</strong> {{ msg.message }}
            </div>
        </div>
        <div class="chat-input">
            <label class="tts-toggle">
                <input type="checkbox" v-model="useOpenAI" @change="toggleTTS">
                Use OpenAI TTS
            </label>
            <input 
                v-model="chatInput" 
                @keyup.enter="sendMessage" 
                placeholder="Type your message..."
            >
            <button @click="sendMessage">Send</button>
        </div>
    </div>
</template>

<style scoped>
.chat-container {
    display: flex;
    flex-direction: column;
    height: 400px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin: 10px;
}

.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    background: #f9f9f9;
    transition: height 0.3s ease;
}

.chat-messages.hide-messages {
    height: 0;
    padding: 0;
    overflow: hidden;
}

.message {
    margin: 5px 0;
    padding: 5px;
    border-radius: 4px;
    background: white;
}

.chat-input {
    display: flex;
    padding: 10px;
    background: white;
    border-top: 1px solid #ccc;
    align-items: center;
}

.chat-input input {
    flex-grow: 1;
    margin: 0 10px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.chat-input button {
    padding: 5px 15px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.chat-input button:hover {
    background: #0056b3;
}

.tts-toggle {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9em;
}
</style>

----
components/visualization/effects.js
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { LAYERS } from './layerManager.js';
import { visualizationSettings } from '../../services/visualizationSettings.js';

export class EffectsManager {
    constructor(scene, camera, renderer, settings = {}) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Store original renderer settings
        this.originalClearColor = this.renderer.getClearColor(new THREE.Color());
        this.originalClearAlpha = this.renderer.getClearAlpha();
        this.originalAutoClear = this.renderer.autoClear;
        
        // Composers for each layer
        this.composers = new Map();
        this.finalComposer = null;
        this.baseComposer = null;
        
        // Create hologram group
        this.hologramGroup = new THREE.Group();
        this.scene.add(this.hologramGroup);
        
        // Get settings
        this.bloomSettings = visualizationSettings.getBloomSettings();
        this.hologramSettings = visualizationSettings.getHologramSettings();
        
        // Bind settings update handler
        this.handleSettingsUpdate = this.handleSettingsUpdate.bind(this);
        window.addEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);

        // XR-specific properties
        this.xrRenderTarget = null;
        this.isXRActive = false;
    }
    
    initPostProcessing() {
        if (!this.renderer || !this.renderer.domElement) {
            console.warn('Renderer not ready, deferring post-processing initialization');
            return;
        }

        // Configure renderer for post-processing
        this.renderer.autoClear = false;
        
        // Create render targets with HDR format
        const renderTarget = new THREE.WebGLRenderTarget(
            window.innerWidth,
            window.innerHeight,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: THREE.HalfFloatType,
                encoding: THREE.sRGBEncoding,
                stencilBuffer: false,
                depthBuffer: true
            }
        );

        // Create XR-compatible render target
        this.xrRenderTarget = renderTarget.clone();
        
        // Create base composer for scene
        this.baseComposer = new EffectComposer(this.renderer, renderTarget.clone());
        const basePass = new RenderPass(this.scene, this.camera);
        basePass.clear = true;
        this.baseComposer.addPass(basePass);
        
        // Create bloom composers for each layer
        const layers = [
            {
                layer: LAYERS.BLOOM,
                settings: {
                    strength: this.bloomSettings.nodeBloomStrength * 1.2,
                    radius: this.bloomSettings.nodeBloomRadius,
                    threshold: this.bloomSettings.nodeBloomThreshold * 0.8
                }
            },
            {
                layer: LAYERS.HOLOGRAM,
                settings: {
                    strength: this.bloomSettings.environmentBloomStrength * 1.5,
                    radius: this.bloomSettings.environmentBloomRadius * 1.2,
                    threshold: this.bloomSettings.environmentBloomThreshold * 0.7
                }
            },
            {
                layer: LAYERS.EDGE,
                settings: {
                    strength: this.bloomSettings.edgeBloomStrength * 1.3,
                    radius: this.bloomSettings.edgeBloomRadius,
                    threshold: this.bloomSettings.edgeBloomThreshold * 0.9
                }
            }
        ];
        
        // Create composers for each layer
        layers.forEach(({ layer, settings }) => {
            const composer = new EffectComposer(this.renderer, renderTarget.clone());
            composer.renderToScreen = false;
            
            const renderPass = new RenderPass(this.scene, this.camera);
            renderPass.clear = true;
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                settings.strength,
                settings.radius,
                settings.threshold
            );
            
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            
            this.composers.set(layer, composer);
        });

        // Create final composer
        this.finalComposer = new EffectComposer(this.renderer, renderTarget.clone());
        
        // Add custom shader pass to combine base scene and bloom layers
        const finalPass = new ShaderPass(
            new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: this.baseComposer.renderTarget2.texture },
                    bloomTexture0: { value: this.composers.get(LAYERS.BLOOM).renderTarget2.texture },
                    bloomTexture1: { value: this.composers.get(LAYERS.HOLOGRAM).renderTarget2.texture },
                    bloomTexture2: { value: this.composers.get(LAYERS.EDGE).renderTarget2.texture }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D baseTexture;
                    uniform sampler2D bloomTexture0;
                    uniform sampler2D bloomTexture1;
                    uniform sampler2D bloomTexture2;
                    varying vec2 vUv;

                    void main() {
                        vec4 base = texture2D(baseTexture, vUv);
                        vec4 bloom0 = texture2D(bloomTexture0, vUv);
                        vec4 bloom1 = texture2D(bloomTexture1, vUv);
                        vec4 bloom2 = texture2D(bloomTexture2, vUv);
                        
                        // Start with base scene color
                        vec3 color = base.rgb;
                        
                        // Add bloom layers
                        color += bloom0.rgb;
                        color += bloom1.rgb;
                        color += bloom2.rgb;
                        
                        // HDR tone mapping
                        color = color / (vec3(1.0) + color);
                        
                        // Gamma correction
                        color = pow(color, vec3(1.0 / 2.2));
                        
                        gl_FragColor = vec4(color, base.a);
                    }
                `,
                transparent: true,
                depthWrite: false,
                depthTest: true
            })
        );
        finalPass.clear = false;
        this.finalComposer.addPass(finalPass);

        // Create hologram structure after composers are ready
        this.createHologramStructure();

        // Set up XR session listeners
        this.renderer.xr.addEventListener('sessionstart', () => {
            this.isXRActive = true;
            this.handleXRSessionStart();
        });

        this.renderer.xr.addEventListener('sessionend', () => {
            this.isXRActive = false;
            this.handleXRSessionEnd();
        });
    }

    handleXRSessionStart() {
        // Update render targets for XR
        const session = this.renderer.xr.getSession();
        if (session) {
            const baseLayer = session.renderState.baseLayer;
            const { width, height } = baseLayer.getViewport(session.views[0]);
            
            this.composers.forEach(composer => {
                composer.setSize(width, height);
            });
            this.baseComposer.setSize(width, height);
            this.finalComposer.setSize(width, height);
        }
    }

    handleXRSessionEnd() {
        // Reset to normal rendering
        this.handleResize();
    }

    createHologramStructure() {
        // ... (hologram structure code remains unchanged)
    }

    animate() {
        // ... (animation code remains unchanged)
    }
    
    render() {
        const currentCamera = this.isXRActive ? this.renderer.xr.getCamera() : this.camera;
        
        // Clear everything
        this.renderer.clear(true, true, true);

        // Render base scene
        currentCamera.layers.set(LAYERS.NORMAL_LAYER);
        this.baseComposer.render();

        // Render bloom layers
        this.composers.forEach((composer, layer) => {
            currentCamera.layers.set(layer);
            composer.render();
        });
        
        // Reset camera layers and render final composition
        currentCamera.layers.set(LAYERS.NORMAL_LAYER);
        this.finalComposer.render();
    }
    
    handleResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Resize all composers
        this.composers.forEach(composer => {
            composer.setSize(width, height);
        });
        
        if (this.baseComposer) {
            this.baseComposer.setSize(width, height);
        }
        
        if (this.finalComposer) {
            this.finalComposer.setSize(width, height);
        }
    }
    
    updateBloom(settings) {
        // ... (updateBloom code remains unchanged)
    }
    
    handleSettingsUpdate(event) {
        // ... (handleSettingsUpdate code remains unchanged)
    }
    
    dispose() {
        // Restore original renderer settings
        this.renderer.autoClear = this.originalAutoClear;
        this.renderer.setClearColor(this.originalClearColor, this.originalClearAlpha);
        
        window.removeEventListener('visualizationSettingsUpdated', this.handleSettingsUpdate);
        
        // Dispose all composers
        this.composers.forEach(composer => {
            composer.dispose();
        });
        
        if (this.baseComposer) {
            this.baseComposer.dispose();
        }
        
        if (this.finalComposer) {
            this.finalComposer.dispose();
        }

        // Dispose hologram resources
        this.hologramGroup.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
        this.scene.remove(this.hologramGroup);

        // Dispose XR render target
        if (this.xrRenderTarget) {
            this.xrRenderTarget.dispose();
        }
    }
}

----
components/visualization/layout.js
export class LayoutManager {
    constructor(settings = {}) {
        // Configuration
        this.initialIterations = settings.iterations || 250;
        this.updateIterations = 1;       // Single iteration for smooth continuous updates
        this.targetRadius = 200;
        this.naturalLength = 100;
        this.attraction = settings.attraction_strength || 0.01;
        this.repulsion = settings.repulsion_strength || 1000;
        this.spring = settings.spring_strength || 0.1;
        this.damping = settings.damping || 0.8;
        
        // State
        this.isInitialized = false;
        this.isSimulating = false;
        this.animationFrameId = null;
        this.lastPositions = null;       // Store previous positions for change detection
        this.updateThreshold = 0.001;    // Minimum position change to trigger update
        this.lastUpdateTime = 0;         // Last time positions were sent to server
        this.updateInterval = 16.67;     // Exactly 60fps
        this.positionBuffer = null;
        this.edges = [];                 // Store computed edges
        this.nodeCount = 0;              // Track number of nodes
        this.waitingForInitialData = true; // Wait for initial data before sending updates
    }

    initializePositions(nodes) {
        console.log('Initializing positions for nodes:', nodes);
        this.nodeCount = nodes.length;
        nodes.forEach(node => {
            // Initialize only if positions are invalid
            if (isNaN(node.x) || isNaN(node.y) || isNaN(node.z)) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = this.targetRadius * Math.cbrt(Math.random());
                
                node.x = r * Math.sin(phi) * Math.cos(theta);
                node.y = r * Math.sin(phi) * Math.sin(theta);
                node.z = r * Math.cos(phi);
            }
            // Always ensure velocities are initialized
            if (!node.vx) node.vx = 0;
            if (!node.vy) node.vy = 0;
            if (!node.vz) node.vz = 0;
        });

        // Initialize last positions with velocities
        this.lastPositions = nodes.map(node => ({
            x: node.x,
            y: node.y,
            z: node.z,
            vx: node.vx,
            vy: node.vy,
            vz: node.vz
        }));

        this.isInitialized = true;
        this.waitingForInitialData = false; // Initial data received
        console.log('Position initialization complete');

        // Send initial positions to server
        this.sendPositionUpdates(nodes, true);
    }

    applyForceDirectedLayout(nodes, edges) {
        if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
            console.warn('Invalid nodes array provided to force-directed layout');
            return;
        }

        if (!this.isInitialized || this.waitingForInitialData) {
            console.warn('Layout manager not initialized or waiting for initial data');
            return;
        }

        console.log('Applying force-directed layout to', nodes.length, 'nodes');
        const dt = 0.1;

        // Apply forces based on edges (topic counts)
        edges.forEach(edge => {
            const sourceNode = nodes.find(n => n.id === edge.source);
            const targetNode = nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                // Calculate spring force based on topic counts
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dz = targetNode.z - sourceNode.z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) return;

                // Use edge weight (from topic counts) to scale the force
                const force = (distance - this.naturalLength) * this.spring * (edge.weight || 1);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                // Apply forces to both nodes
                sourceNode.vx += fx * this.attraction;
                sourceNode.vy += fy * this.attraction;
                sourceNode.vz += fz * this.attraction;
                targetNode.vx -= fx * this.attraction;
                targetNode.vy -= fy * this.attraction;
                targetNode.vz -= fz * this.attraction;
            }
        });

        // Apply repulsion between all nodes
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dz = nodes[j].z - nodes[i].z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance === 0) continue;

                const force = this.repulsion / (distance * distance);
                
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                nodes[i].vx -= fx;
                nodes[i].vy -= fy;
                nodes[i].vz -= fz;
                nodes[j].vx += fx;
                nodes[j].vy += fy;
                nodes[j].vz += fz;
            }
        }

        // Update positions and apply damping
        nodes.forEach(node => {
            // Apply current velocity
            node.x += node.vx * dt;
            node.y += node.vy * dt;
            node.z += node.vz * dt;

            // Apply damping
            node.vx *= this.damping;
            node.vy *= this.damping;
            node.vz *= this.damping;

            // Bound checking
            const bound = 500;
            if (Math.abs(node.x) > bound) node.vx *= -0.5;
            if (Math.abs(node.y) > bound) node.vy *= -0.5;
            if (Math.abs(node.z) > bound) node.vz *= -0.5;
        });
    }

    updateFeature(control, value) {
        console.log(`Updating layout feature: ${control} = ${value}`);
        
        // Convert from forceDirected prefixed names to internal parameter names
        const paramMap = {
            'forceDirectedIterations': 'iterations',
            'forceDirectedSpring': 'spring_strength',
            'forceDirectedRepulsion': 'repulsion_strength',
            'forceDirectedAttraction': 'attraction_strength',
            'forceDirectedDamping': 'damping'
        };

        const paramName = paramMap[control] || control;
        switch(paramName) {
            case 'iterations':
                this.initialIterations = value;
                break;
            case 'spring_strength':
                this.spring = value;
                break;
            case 'repulsion_strength':
                this.repulsion = value;
                break;
            case 'attraction_strength':
                this.attraction = value;
                break;
            case 'damping':
                this.damping = value;
                break;
            default:
                console.warn(`Unknown layout parameter: ${control}`);
        }
    }

    updatePhysics(settings) {
        console.log('Updating physics settings:', settings);
        
        // Update all physics parameters at once
        if (settings.iterations !== undefined) {
            this.initialIterations = settings.iterations;
        }
        if (settings.spring_strength !== undefined) {
            this.spring = settings.spring_strength;
        }
        if (settings.repulsion_strength !== undefined) {
            this.repulsion = settings.repulsion_strength;
        }
        if (settings.attraction_strength !== undefined) {
            this.attraction = settings.attraction_strength;
        }
        if (settings.damping !== undefined) {
            this.damping = settings.damping;
        }

        // If simulation is running, apply new settings immediately
        if (this.isSimulating) {
            console.log('Applying new physics settings to running simulation');
        }
    }

    performLayout(graphData) {
        if (!this.isInitialized || !graphData || this.waitingForInitialData) {
            console.warn('Cannot perform layout: not initialized, no graph data, or waiting for initial data');
            return;
        }

        const now = Date.now();
        if (now - this.lastUpdateTime >= this.updateInterval) {
            // Apply force-directed layout
            this.applyForceDirectedLayout(graphData.nodes, graphData.edges);
            
            // Send position updates
            this.sendPositionUpdates(graphData.nodes, false);
            this.lastUpdateTime = now;
        }
    }

    sendPositionUpdates(nodes, isInitialLayout = false) {
        if (!this.lastPositions || !this.isInitialized || nodes.length !== this.nodeCount || this.waitingForInitialData) {
            console.warn('Cannot send position updates: not initialized, node count mismatch, or waiting for initial data');
            return;
        }

        // Create binary buffer for all node positions and velocities (24 bytes per node)
        const buffer = new ArrayBuffer(nodes.length * 24 + 4); // Extra 4 bytes for is_initial_layout flag
        const dataView = new Float32Array(buffer);
        let hasChanges = false;

        // Set is_initial_layout flag (1.0 for true, 0.0 for false)
        dataView[0] = isInitialLayout ? 1.0 : 0.0;

        nodes.forEach((node, index) => {
            const offset = index * 6 + 1; // +1 to account for is_initial_layout flag
            const lastPos = this.lastPositions[index];

            if (!lastPos || 
                Math.abs(node.x - lastPos.x) > this.updateThreshold ||
                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
                Math.abs(node.z - lastPos.z) > this.updateThreshold ||
                Math.abs(node.vx - lastPos.vx) > this.updateThreshold ||
                Math.abs(node.vy - lastPos.vy) > this.updateThreshold ||
                Math.abs(node.vz - lastPos.vz) > this.updateThreshold) {
                
                hasChanges = true;
                
                // Update last position and velocity
                if (lastPos) {
                    lastPos.x = node.x;
                    lastPos.y = node.y;
                    lastPos.z = node.z;
                    lastPos.vx = node.vx;
                    lastPos.vy = node.vy;
                    lastPos.vz = node.vz;
                }

                // Position (vec3<f32>)
                dataView[offset] = node.x;
                dataView[offset + 1] = node.y;
                dataView[offset + 2] = node.z;

                // Velocity (vec3<f32>)
                dataView[offset + 3] = node.vx || 0;
                dataView[offset + 4] = node.vy || 0;
                dataView[offset + 5] = node.vz || 0;
            }
        });

        if (hasChanges || isInitialLayout) {
            // Log the buffer size before sending
            console.log(`Sending position update buffer of size: ${buffer.byteLength} bytes for ${nodes.length} nodes (isInitialLayout: ${isInitialLayout})`);
            
            // Dispatch binary data event
            window.dispatchEvent(new CustomEvent('positionUpdate', {
                detail: buffer
            }));
        }
    }

    startContinuousSimulation(graphData) {
        if (this.isSimulating) return;
        
        console.log('Starting continuous simulation');
        this.isSimulating = true;
        const animate = () => {
            if (!this.isSimulating) return;
            
            // Send position updates at regular intervals
            this.performLayout(graphData);
            this.animationFrameId = requestAnimationFrame(animate);
        };
        
        animate();
    }

    stopSimulation() {
        console.log('Stopping simulation');
        this.isSimulating = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
}

----
components/visualization/nodes.js
import * as THREE from 'three';
import { visualizationSettings } from '../../services/visualizationSettings.js';
import { LAYERS, LAYER_GROUPS, LayerManager } from './layerManager.js';

export class NodeManager {
    constructor(scene, camera, settings = {}) {
        this.scene = scene;
        this.camera = camera;
        this.nodeMeshes = new Map();
        this.nodeLabels = new Map();
        this.edgeMeshes = new Map();
        this.nodeData = new Map();
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        // Get settings from visualization settings service
        const nodeSettings = visualizationSettings.getNodeSettings();
        
        // Physical dimensions in meters
        this.minNodeSize = settings.minNodeSize || nodeSettings.minNodeSize;
        this.maxNodeSize = settings.maxNodeSize || nodeSettings.maxNodeSize;
        
        // Visual settings
        this.labelFontSize = settings.labelFontSize || nodeSettings.labelFontSize;
        this.nodeColor = new THREE.Color(settings.nodeColor || nodeSettings.color);
        this.materialSettings = nodeSettings.material;
        this.ageColors = {
            NEW: new THREE.Color(nodeSettings.colorNew),
            RECENT: new THREE.Color(nodeSettings.colorRecent),
            MEDIUM: new THREE.Color(nodeSettings.colorMedium),
            OLD: new THREE.Color(nodeSettings.colorOld)
        };
        this.maxAge = nodeSettings.ageMaxDays;

        // Edge settings
        const edgeSettings = visualizationSettings.getEdgeSettings();
        this.edgeColor = new THREE.Color(settings.edgeColor || edgeSettings.color);
        this.edgeOpacity = settings.edgeOpacity || edgeSettings.opacity;

        this.handleClick = this.handleClick.bind(this);
        this.xrEnabled = false;
        this.xrLabelManager = null;
    }

    centerNodes(nodes) {
        if (!Array.isArray(nodes) || nodes.length === 0) {
            return nodes;
        }

        // Calculate center of mass
        let centerX = 0, centerY = 0, centerZ = 0;
        nodes.forEach(node => {
            centerX += node.x || 0;
            centerY += node.y || 0;
            centerZ += node.z || 0;
        });
        centerX /= nodes.length;
        centerY /= nodes.length;
        centerZ /= nodes.length;

        // Center nodes around origin
        return nodes.map(node => ({
            ...node,
            x: (node.x || 0) - centerX,
            y: (node.y || 0) - centerY,
            z: (node.z || 0) - centerZ
        }));
    }

    formatFileSize(size) {
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let i = 0;
        while (size >= 1024 && i < units.length - 1) {
            size /= 1024;
            i++;
        }
        return `${size.toFixed(2)} ${units[i]}`;
    }

    formatAge(lastModified) {
        const now = Date.now();
        const age = now - new Date(lastModified).getTime();
        const days = Math.floor(age / (24 * 60 * 60 * 1000));
        
        if (days < 1) return 'Today';
        if (days === 1) return 'Yesterday';
        if (days < 7) return `${days}d ago`;
        if (days < 30) return `${Math.floor(days / 7)}w ago`;
        if (days < 365) return `${Math.floor(days / 30)}m ago`;
        return `${Math.floor(days / 365)}y ago`;
    }

    formatNodeNameToUrl(nodeName) {
        // Get base URL from environment or default to logseq
        const baseUrl = window.location.origin;
        // Convert node name to lowercase and replace spaces with dashes
        const formattedName = nodeName.toLowerCase().replace(/ /g, '-');
        return `${baseUrl}/#/page/${formattedName}`;
    }

    getNodeSize(metadata) {
        // Calculate node size in meters based on metadata
        if (metadata.node_size) {
            const size = parseFloat(metadata.node_size);
            // Normalize size between minNodeSize (0.1m) and maxNodeSize (0.3m)
            return this.minNodeSize + (size * (this.maxNodeSize - this.minNodeSize));
        }
        return this.minNodeSize; // Default to minimum size (10cm)
    }

    calculateNodeColor(metadata) {
        // Use github_last_modified if available, otherwise fall back to last_modified
        const lastModified = metadata.github_last_modified || metadata.last_modified || new Date().toISOString();
        const now = Date.now();
        const age = now - new Date(lastModified).getTime();
        const dayInMs = 24 * 60 * 60 * 1000;
        
        if (age < 3 * dayInMs) return this.ageColors.NEW;        // Less than 3 days old
        if (age < 7 * dayInMs) return this.ageColors.RECENT;     // Less than 7 days old
        if (age < 30 * dayInMs) return this.ageColors.MEDIUM;    // Less than 30 days old
        return this.ageColors.OLD;                               // 30 days or older
    }

    createNodeGeometry(size, hyperlinkCount) {
        // Create a sphere with radius in meters
        // Scale segments based on hyperlink count for performance vs. quality
        const minSegments = visualizationSettings.getNodeSettings().geometryMinSegments;
        const maxSegments = visualizationSettings.getNodeSettings().geometryMaxSegments;
        const segmentPerLink = visualizationSettings.getNodeSettings().geometrySegmentPerHyperlink;
        
        const segments = Math.min(
            maxSegments,
            Math.max(minSegments, Math.floor(hyperlinkCount * segmentPerLink) + minSegments)
        );
        
        return new THREE.SphereGeometry(size, segments, segments);
    }

    createNodeMaterial(color, metadata) {
        const lastModified = metadata.github_last_modified || metadata.last_modified || new Date().toISOString();
        const now = Date.now();
        const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
        
        const normalizedAge = Math.min(ageInDays / this.maxAge, 1);
        const emissiveIntensity = this.materialSettings.emissiveMaxIntensity - 
            (normalizedAge * (this.materialSettings.emissiveMaxIntensity - this.materialSettings.emissiveMinIntensity));

        return new THREE.MeshPhysicalMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: emissiveIntensity,
            metalness: this.materialSettings.metalness,
            roughness: this.materialSettings.roughness,
            transparent: true,
            opacity: this.materialSettings.opacity,
            envMapIntensity: 1.0,
            clearcoat: this.materialSettings.clearcoat,
            clearcoatRoughness: this.materialSettings.clearcoatRoughness,
            toneMapped: false
        });
    }

    createNodeLabel(text, metadata) {
        // Dispose existing texture if any
        const existingLabel = this.nodeLabels.get(text);
        if (existingLabel && existingLabel.material.map) {
            existingLabel.material.map.dispose();
            existingLabel.material.dispose();
        }

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d', {
            alpha: true,
            desynchronized: true // Optimize for performance
        });
        context.font = `${this.labelFontSize}px Arial`;
        
        // Get metadata values
        const fileSize = parseInt(metadata.file_size) || 1;
        const lastModified = metadata.github_last_modified || metadata.last_modified || new Date().toISOString();
        const hyperlinkCount = parseInt(metadata.hyperlink_count) || 0;
        const githubInfo = metadata.github_info || {};
        
        // Measure and create text
        const nameMetrics = context.measureText(text);
        let infoText = `${this.formatFileSize(fileSize)} | ${this.formatAge(lastModified)} | ${hyperlinkCount} links`;
        if (githubInfo.author) {
            infoText += ` | ${githubInfo.author}`;
        }
        if (githubInfo.commit_message) {
            const shortMessage = githubInfo.commit_message.split('\n')[0].slice(0, 30);
            infoText += ` | ${shortMessage}${githubInfo.commit_message.length > 30 ? '...' : ''}`;
        }
        
        const infoMetrics = context.measureText(infoText);
        const textWidth = Math.max(nameMetrics.width, infoMetrics.width);
        
        // Set canvas size to power of 2 for better texture performance
        const canvasWidth = Math.pow(2, Math.ceil(Math.log2(textWidth + 20)));
        const canvasHeight = Math.pow(2, Math.ceil(Math.log2(this.labelFontSize * 2 + 30)));
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Draw background with higher opacity
        context.fillStyle = 'rgba(0, 0, 0, 0.9)'; // Increased opacity for better visibility
        context.fillRect(0, 0, canvas.width, canvas.height);

        // Draw text with enhanced contrast
        context.font = `${this.labelFontSize}px ${visualizationSettings.getLabelSettings().fontFamily}`;
        context.fillStyle = '#ffffff'; // Pure white for better visibility
        context.fillText(text, 10, this.labelFontSize);
        
        context.font = `${this.labelFontSize / 2}px ${visualizationSettings.getLabelSettings().fontFamily}`;
        context.fillStyle = '#cccccc'; // Light gray for info text
        context.fillText(infoText, 10, this.labelFontSize + 20);

        // Create sprite with optimized texture and material settings
        const texture = new THREE.CanvasTexture(canvas);
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.format = THREE.RGBAFormat;
        
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            opacity: 1.0, // Full opacity
            depthWrite: false,
            depthTest: true,
            sizeAttenuation: true,
            toneMapped: false,
            blending: THREE.NormalBlending
        });

        const sprite = new THREE.Sprite(spriteMaterial);
        
        // Scale sprite to maintain readable text size in meters
        const labelScale = visualizationSettings.getLabelSettings().verticalOffset;
        sprite.scale.set(
            (canvas.width / this.labelFontSize) * labelScale * 1.5,
            (canvas.height / this.labelFontSize) * labelScale * 1.5,
            1
        );
        
        // Set label to be visible in all necessary layers
        LayerManager.setLayerGroup(sprite, 'LABEL');

        // Ensure sprite is always facing the camera
        sprite.onBeforeRender = (renderer, scene, camera) => {
            sprite.quaternion.copy(camera.quaternion);
        };

        return sprite;
    }

    handleClick(event, isXR = false, intersectedObject = null) {
        let clickedMesh;

        if (isXR && intersectedObject) {
            // In XR mode, use the passed intersected object directly
            clickedMesh = intersectedObject;
        } else if (!isXR && event) {
            // Regular mouse click handling
            const rect = event.target.getBoundingClientRect();
            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObjects(Array.from(this.nodeMeshes.values()));
            
            if (intersects.length > 0) {
                clickedMesh = intersects[0].object;
            }
        }

        if (clickedMesh) {
            // Find the clicked node
            const nodeId = Array.from(this.nodeMeshes.entries())
                .find(([_, mesh]) => mesh === clickedMesh)?.[0];

            if (nodeId) {
                const nodeData = this.nodeData.get(nodeId);
                if (nodeData) {
                    // Open URL in new tab
                    const url = this.formatNodeNameToUrl(nodeData.label || nodeId);
                    window.open(url, '_blank');

                    // Visual feedback
                    const originalEmissive = clickedMesh.material.emissiveIntensity;
                    clickedMesh.material.emissiveIntensity = 2.0;
                    setTimeout(() => {
                        clickedMesh.material.emissiveIntensity = originalEmissive;
                    }, 200);

                    // Show XR label if in XR mode
                    if (isXR && this.xrLabelManager) {
                        this.xrLabelManager.showLabel(
                            nodeData.label || nodeId,
                            clickedMesh.position,
                            {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                color: '#ffffff',
                                font: '24px Arial'
                            }
                        );
                    }

                    // Trigger haptic feedback in XR mode
                    if (isXR && window.xrSession) {
                        const inputSource = Array.from(window.xrSession.inputSources).find(source => 
                            source.handedness === 'right' || source.handedness === 'left'
                        );
                        if (inputSource?.gamepad?.hapticActuators?.length > 0) {
                            inputSource.gamepad.hapticActuators[0].pulse(0.5, 100);
                        }
                    }
                }
            }
        }
    }

    initClickHandling(renderer) {
        renderer.domElement.addEventListener('click', this.handleClick);
    }

    removeClickHandling(renderer) {
        renderer.domElement.removeEventListener('click', this.handleClick);
    }

    updateNodes(nodes) {
        if (!Array.isArray(nodes)) {
            console.error('updateNodes received invalid nodes:', nodes);
            return;
        }

        console.log(`Updating nodes: ${nodes.length}`);
        
        // Center and scale nodes
        const centeredNodes = this.centerNodes(nodes);
        if (!centeredNodes) return;
        
        const existingNodeIds = new Set(centeredNodes.map(node => node.id));

        // Remove non-existent nodes and properly dispose resources
        this.nodeMeshes.forEach((mesh, nodeId) => {
            if (!existingNodeIds.has(nodeId)) {
                if (mesh.geometry) {
                    mesh.geometry.dispose();
                }
                if (mesh.material) {
                    if (Array.isArray(mesh.material)) {
                        mesh.material.forEach(mat => mat.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
                this.scene.remove(mesh);
                this.nodeMeshes.delete(nodeId);
                this.nodeData.delete(nodeId);

                const label = this.nodeLabels.get(nodeId);
                if (label) {
                    if (label.material.map) {
                        label.material.map.dispose();
                    }
                    label.material.dispose();
                    this.scene.remove(label);
                    this.nodeLabels.delete(nodeId);
                }
            }
        });

        // Update or create nodes
        centeredNodes.forEach(node => {
            if (!node.id || typeof node.x !== 'number' || typeof node.y !== 'number' || typeof node.z !== 'number') {
                console.warn('Invalid node data:', node);
                return;
            }

            // Store node data for click handling
            this.nodeData.set(node.id, node);

            const metadata = node.metadata || {};
            const size = this.getNodeSize(metadata);
            const color = this.calculateNodeColor(metadata);

            let mesh = this.nodeMeshes.get(node.id);

            if (!mesh) {
                const geometry = this.createNodeGeometry(size, metadata.hyperlink_count || 0);
                const material = this.createNodeMaterial(color, metadata);

                mesh = new THREE.Mesh(geometry, material);
                LayerManager.setLayerGroup(mesh, 'BLOOM');
                this.scene.add(mesh);
                this.nodeMeshes.set(node.id, mesh);

                const label = this.createNodeLabel(node.label || node.id, metadata);
                this.scene.add(label);
                this.nodeLabels.set(node.id, label);
            } else {
                // Update existing mesh
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
                
                mesh.geometry = this.createNodeGeometry(size, metadata.hyperlink_count || 0);
                mesh.material = this.createNodeMaterial(color, metadata);
                LayerManager.setLayerGroup(mesh, 'BLOOM');
            }

            mesh.position.set(node.x, node.y, node.z);
            const label = this.nodeLabels.get(node.id);
            if (label) {
                const labelOffset = size * 1.5;
                label.position.set(node.x, node.y + labelOffset, node.z);
            }
        });
    }

    updateEdges(edges) {
        console.log(`Updating edges: ${edges.length}`);
        
        // Create a map of edges with their weights from topic counts
        const edgeWeights = new Map();
        edges.forEach(edge => {
            if (!edge.source || !edge.target_node) {
                console.warn('Invalid edge data:', edge);
                return;
            }

            const edgeKey = `${edge.source}-${edge.target_node}`;
            const weight = edge.weight || 1; // Use provided weight or default to 1
            edgeWeights.set(edgeKey, weight);
        });

        // Remove non-existent edges
        this.edgeMeshes.forEach((line, edgeKey) => {
            if (!edgeWeights.has(edgeKey)) {
                if (line.geometry) {
                    line.geometry.dispose();
                }
                if (line.material) {
                    line.material.dispose();
                }
                this.scene.remove(line);
                this.edgeMeshes.delete(edgeKey);
            }
        });

        // Update or create edges
        edgeWeights.forEach((weight, edgeKey) => {
            const [source, target] = edgeKey.split('-');
            let line = this.edgeMeshes.get(edgeKey);
            const sourceMesh = this.nodeMeshes.get(source);
            const targetMesh = this.nodeMeshes.get(target);

            if (!line && sourceMesh && targetMesh) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const normalizedWeight = Math.min(weight / 10, 1);
                const material = new THREE.LineBasicMaterial({
                    color: this.edgeColor,
                    transparent: true,
                    opacity: this.edgeOpacity * normalizedWeight,
                    linewidth: Math.max(1, Math.min(weight, 5)),
                    toneMapped: false
                });

                line = new THREE.Line(geometry, material);
                LayerManager.setLayerGroup(line, 'EDGE');
                this.scene.add(line);
                this.edgeMeshes.set(edgeKey, line);
            }

            if (line && sourceMesh && targetMesh) {
                const positions = line.geometry.attributes.position.array;
                positions[0] = sourceMesh.position.x;
                positions[1] = sourceMesh.position.y;
                positions[2] = sourceMesh.position.z;
                positions[3] = targetMesh.position.x;
                positions[4] = targetMesh.position.y;
                positions[5] = targetMesh.position.z;
                line.geometry.attributes.position.needsUpdate = true;

                // Update edge appearance based on weight
                const normalizedWeight = Math.min(weight / 10, 1);
                line.material.opacity = this.edgeOpacity * normalizedWeight;
                line.material.linewidth = Math.max(1, Math.min(weight, 5));
            }
        });
    }

    updateLabelOrientations(camera) {
        this.nodeLabels.forEach((label, nodeId) => {
            const mesh = this.nodeMeshes.get(nodeId);
            if (mesh) {
                const size = mesh.geometry.parameters.radius || 
                           mesh.geometry.parameters.width || 
                           this.minNodeSize;
                const labelOffset = size * 1.5; // Increased offset
                label.position.set(
                    mesh.position.x,
                    mesh.position.y + labelOffset,
                    mesh.position.z
                );
                label.lookAt(camera.position);
            }
        });
    }

    updateFeature(control, value) {
        console.log(`Updating feature: ${control} = ${value}`);
        switch (control) {
            // Node features
            case 'nodeColor':
                if (typeof value === 'number' || typeof value === 'string') {
                    this.nodeColor = new THREE.Color(value);
                    this.nodeMeshes.forEach(mesh => {
                        if (mesh.material) {
                            mesh.material.color.copy(this.nodeColor);
                            mesh.material.emissive.copy(this.nodeColor);
                        }
                    });
                }
                break;
            case 'minNodeSize':
                this.minNodeSize = value; // Value in meters
                break;
            case 'maxNodeSize':
                this.maxNodeSize = value; // Value in meters
                break;
            case 'labelFontSize':
                this.labelFontSize = value;
                break;

            // Edge features
            case 'edgeColor':
                if (typeof value === 'number' || typeof value === 'string') {
                    this.edgeColor = new THREE.Color(value);
                    this.edgeMeshes.forEach(line => {
                        if (line.material) {
                            line.material.color.copy(this.edgeColor);
                        }
                    });
                }
                break;
            case 'edgeOpacity':
                this.edgeOpacity = value;
                this.edgeMeshes.forEach(line => {
                    if (line.material) {
                        line.material.opacity = value;
                    }
                });
                break;
        }
    }

    updateMaterial(settings) {
        console.log('Updating node material settings:', settings);
        
        // Update material settings
        this.materialSettings = {
            ...this.materialSettings,
            metalness: settings.metalness ?? this.materialSettings.metalness,
            roughness: settings.roughness ?? this.materialSettings.roughness,
            clearcoat: settings.clearcoat ?? this.materialSettings.clearcoat,
            clearcoatRoughness: settings.clearcoatRoughness ?? this.materialSettings.clearcoatRoughness,
            opacity: settings.opacity ?? this.materialSettings.opacity,
            emissiveMinIntensity: settings.emissiveMinIntensity ?? this.materialSettings.emissiveMinIntensity,
            emissiveMaxIntensity: settings.emissiveMaxIntensity ?? this.materialSettings.emissiveMaxIntensity
        };

        // Update all existing node materials
        this.nodeMeshes.forEach((mesh, nodeId) => {
            const nodeData = this.nodeData.get(nodeId);
            if (nodeData && mesh.material) {
                // Create new material with updated settings
                mesh.material.dispose(); // Dispose old material
                mesh.material = this.createNodeMaterial(mesh.material.color, nodeData.metadata || {});
            }
        });
    }

    updateEdgesForNode(nodeId) {
        this.edgeMeshes.forEach((line, edgeKey) => {
            const [source, target] = edgeKey.split('-');
            if (source === nodeId || target === nodeId) {
                const positions = line.geometry.attributes.position.array;
                const sourceMesh = this.nodeMeshes.get(source);
                const targetMesh = this.nodeMeshes.get(target);

                if (sourceMesh && targetMesh) {
                    positions[0] = sourceMesh.position.x;
                    positions[1] = sourceMesh.position.y;
                    positions[2] = sourceMesh.position.z;
                    positions[3] = targetMesh.position.x;
                    positions[4] = targetMesh.position.y;
                    positions[5] = targetMesh.position.z;
                    line.geometry.attributes.position.needsUpdate = true;
                }
            }
        });
    }

    getNodePositions() {
        return Array.from(this.nodeMeshes.values()).map(mesh => [
            mesh.position.x,
            mesh.position.y,
            mesh.position.z
        ]);
    }

    dispose() {
        // Dispose node resources
        this.nodeMeshes.forEach(mesh => {
            if (mesh.geometry) {
                mesh.geometry.dispose();
            }
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(mat => {
                        if (mat.map) mat.map.dispose();
                        mat.dispose();
                    });
                } else {
                    if (mesh.material.map) mesh.material.map.dispose();
                    mesh.material.dispose();
                }
            }
            if (mesh.parent) {
                mesh.parent.remove(mesh);
            }
        });

        // Dispose label resources
        this.nodeLabels.forEach(label => {
            if (label.material) {
                if (label.material.map) {
                    label.material.map.dispose();
                }
                label.material.dispose();
            }
            if (label.parent) {
                label.parent.remove(label);
            }
        });

        // Dispose edge resources
        this.edgeMeshes.forEach(line => {
            if (line.geometry) {
                line.geometry.dispose();
            }
            if (line.material) {
                if (line.material.map) line.material.map.dispose();
                line.material.dispose();
            }
            if (line.parent) {
                line.parent.remove(line);
            }
        });

        // Clear data maps
        this.nodeMeshes.clear();
        this.nodeLabels.clear();
        this.edgeMeshes.clear();
        this.nodeData.clear();

        // Clean up event listeners
        if (this.renderer) {
            this.removeClickHandling(this.renderer);
        }
    }
}

----
components/visualization/core.js
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { NodeManager } from './nodes.js';
import { EffectsManager } from './effects.js';
import { LayoutManager } from './layout.js';
import { visualizationSettings } from '../../services/visualizationSettings.js';
import { initXRSession, handleXRSession } from '../../xr/xrSetup.js';
import { initXRInteraction, handleXRInput, XRLabelManager } from '../../xr/xrInteraction.js';

// Constants for Spacemouse sensitivity
const TRANSLATION_SPEED = 0.01;
const ROTATION_SPEED = 0.01;
const VR_MOVEMENT_SPEED = 0.05;

function updateNodeDynamics(nodeManager, updates, isInitialLayout, timeStep) {
    if (isInitialLayout) {
        console.log('Applying initial layout positions and velocities');
        nodeManager.resetSimulation();
    }

    nodeManager.updateNodeDynamics(updates);

    if (timeStep > 0) {
        nodeManager.setTimeStep(timeStep);
    }

    if (nodeManager.isInteractive()) {
        nodeManager.updatePhysics(updates);
    }
}

export class WebXRVisualization {
    constructor(graphDataManager) {
        console.log('WebXRVisualization constructor called');
        this.graphDataManager = graphDataManager;

        // Initialize the scene, camera, and renderer
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        
        // Create camera
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.camera.matrixAutoUpdate = true;

        // Create VR camera rig
        this.cameraRig = new THREE.Group();
        this.cameraRig.name = 'cameraRig';
        this.scene.add(this.cameraRig);

        // Create user movement group
        this.userGroup = new THREE.Group();
        this.userGroup.name = 'userGroup';
        this.cameraRig.add(this.userGroup);
        
        // Set initial camera position and add to user group
        this.camera.position.set(0, 1.6, 3); // Set initial position at standing height
        this.userGroup.add(this.camera);
        
        console.log('Camera hierarchy:', {
            camera: this.camera.name || 'camera',
            parent: this.camera.parent?.name || 'none',
            grandparent: this.camera.parent?.parent?.name || 'none'
        });

        // Initialize renderer with XR support
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true,
            logarithmicDepthBuffer: true,
            powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.xr.enabled = true;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Initialize managers with settings from service
        this.nodeManager = new NodeManager(this.scene, this.camera, visualizationSettings.getNodeSettings());
        this.effectsManager = new EffectsManager(
            this.scene,
            this.camera,
            this.renderer,
            visualizationSettings.getEnvironmentSettings()
        );
        this.layoutManager = new LayoutManager(visualizationSettings.getLayoutSettings());

        this.controls = null;
        this.xrControllers = [];
        this.xrHands = [];
        this.xrLabelManager = null;

        this.animationFrameId = null;
        this.lastPositionUpdate = 0;
        this.positionUpdateThreshold = 16;

        this.previousPositions = new Map();
        this.previousTimes = new Map();
        this.lastUpdateTime = performance.now();

        // Bind methods
        this.onWindowResize = this.onWindowResize.bind(this);
        this.animate = this.animate.bind(this);

        // Initialize settings and add event listeners
        this.initializeSettings();
        this.setupEventListeners();

        console.log('WebXRVisualization constructor completed');
    }

    onWindowResize() {
        if (this.camera && this.renderer) {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            if (this.effectsManager) {
                this.effectsManager.handleResize();
            }
        }
    }

    setupEventListeners() {
        window.addEventListener('graphDataUpdated', (event) => {
            if (event.detail && Array.isArray(event.detail.nodes)) {
                this.updateVisualization(event.detail);
            }
        });

        window.addEventListener('visualizationSettingsUpdated', (event) => {
            this.updateSettings(event.detail);
        });

        window.addEventListener('positionUpdate', (event) => {
            if (this.graphDataManager.isGraphDataValid() && this.graphDataManager.websocketService) {
                this.graphDataManager.websocketService.send(event.detail);
            }
        });

        window.addEventListener('binaryPositionUpdate', (event) => {
            this.handleBinaryPositionUpdate(event.detail);
        });
    }

    initializeSettings() {
        console.log('Initializing settings');
        const envSettings = visualizationSettings.getEnvironmentSettings();
        
        // Initialize fog
        this.fogDensity = envSettings.fogDensity;
        this.scene.fog = new THREE.FogExp2(0x000000, this.fogDensity);
        
        // Initialize lighting
        this.ambientLightIntensity = 50;
        this.directionalLightIntensity = 5.0;
        this.directionalLightColor = 0xffffff;
        this.ambientLightColor = 0x404040;
        
        // Add ambient light
        this.ambientLight = new THREE.AmbientLight(this.ambientLightColor, this.ambientLightIntensity);
        this.scene.add(this.ambientLight);

        // Add directional light
        this.directionalLight = new THREE.DirectionalLight(
            this.directionalLightColor,
            this.directionalLightIntensity
        );
        this.directionalLight.position.set(5, 5, 5);
        this.directionalLight.castShadow = true;
        this.scene.add(this.directionalLight);

        // Add point lights for better illumination
        const pointLight1 = new THREE.PointLight(0xffffff, 1, 100);
        pointLight1.position.set(10, 10, 10);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1, 100);
        pointLight2.position.set(-10, -10, -10);
        this.scene.add(pointLight2);
    }

    async initThreeJS() {
        console.log('Initializing Three.js with XR support');
        const container = document.getElementById('scene-container');
        if (!container) {
            console.error("Could not find 'scene-container' element");
            return;
        }

        // Setup renderer with proper stacking context
        this.renderer.domElement.style.position = 'absolute';
        this.renderer.domElement.style.top = '0';
        this.renderer.domElement.style.left = '0';
        this.renderer.domElement.style.zIndex = '0';
        container.appendChild(this.renderer.domElement);

        // Create a separate div for OrbitControls
        const controlsContainer = document.createElement('div');
        controlsContainer.style.position = 'absolute';
        controlsContainer.style.top = '0';
        controlsContainer.style.left = '0';
        controlsContainer.style.width = '100%';
        controlsContainer.style.height = '100%';
        controlsContainer.style.zIndex = '1';
        container.appendChild(controlsContainer);

        // Initialize controls with optimized settings
        this.controls = new OrbitControls(this.camera, controlsContainer);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.1;
        this.controls.rotateSpeed = 0.8;
        this.controls.panSpeed = 0.8;
        this.controls.zoomSpeed = 0.8;

        // Setup pointer events
        const updatePointerEvents = (isInteracting) => {
            if (!this.renderer.xr.isPresenting) {
                this.renderer.domElement.style.pointerEvents = isInteracting ? 'auto' : 'none';
                controlsContainer.style.pointerEvents = isInteracting ? 'auto' : 'none';
            }
        };

        container.addEventListener('mouseenter', () => updatePointerEvents(true));
        container.addEventListener('mouseleave', () => updatePointerEvents(false));
        
        // Initialize click handling
        this.nodeManager.initClickHandling(this.renderer);

        // Initialize XR
        await this.initializeXR();

        // Initialize effects after XR setup
        if (this.effectsManager) {
            this.effectsManager.initPostProcessing();
        }

        // Add resize listener
        window.addEventListener('resize', this.onWindowResize);

        // Start animation loop
        this.animate();
    }

    async initializeXR() {
        // Initialize XR session with effects manager
        await initXRSession(this.renderer, this.scene, this.camera, this.effectsManager);

        // Initialize XR interaction
        const { controllers, hands, xrLabelManager } = await initXRInteraction(
            this.scene,
            this.camera,
            this.renderer,
            (event) => {
                if (event.detail?.intersection?.object) {
                    this.nodeManager.handleClick(null, true, event.detail.intersection.object);
                }
            }
        );

        this.xrControllers = controllers;
        this.xrHands = hands;
        this.xrLabelManager = xrLabelManager;

        // Setup XR event listeners
        this.renderer.xr.addEventListener('sessionstart', () => {
            console.log('XR session started - Disabling OrbitControls');
            this.controls.enabled = false;
            this.renderer.domElement.style.pointerEvents = 'none';
            
            // Reset positions
            this.userGroup.position.set(0, 0, 0);
            this.cameraRig.position.set(0, 0, 0);
            
            // Update effects manager for XR mode
            if (this.effectsManager) {
                this.effectsManager.handleXRSessionStart();
            }
        });

        this.renderer.xr.addEventListener('sessionend', () => {
            console.log('XR session ended - Enabling OrbitControls');
            this.controls.enabled = true;
            
            // Reset positions
            this.camera.position.set(0, 1.6, 3);
            this.userGroup.position.set(0, 0, 0);
            this.cameraRig.position.set(0, 0, 0);
            
            // Update effects manager for desktop mode
            if (this.effectsManager) {
                this.effectsManager.handleXRSessionEnd();
            }
        });
    }

    animate() {
        const renderFrame = (timestamp, frame) => {
            // Update controls if enabled
            if (this.controls && this.controls.enabled) {
                this.controls.update();
            }

            // Update labels
            this.nodeManager.updateLabelOrientations(this.camera);

            // Animate effects
            this.effectsManager.animate();

            // Render scene with effects in both desktop and XR modes
            this.effectsManager.render();
        };

        this.renderer.setAnimationLoop(renderFrame);
    }

    updateVisualization(graphData) {
        if (this.nodeManager && graphData) {
            // Update nodes
            if (Array.isArray(graphData.nodes)) {
                this.nodeManager.updateNodes(graphData.nodes);
            }
            
            // Update edges if available
            if (Array.isArray(graphData.edges)) {
                this.nodeManager.updateEdges(graphData.edges);
            }
        }
    }

    updateSettings(settings) {
        console.log('Updating visualization settings:', settings);
        
        if (settings.visual) {
            // Update visual settings
            const visualSettings = {
                nodeColor: settings.visual.nodeColor,
                edgeColor: settings.visual.edgeColor,
                hologramColor: settings.visual.hologramColor,
                minNodeSize: settings.visual.minNodeSize,
                maxNodeSize: settings.visual.maxNodeSize,
                hologramScale: settings.visual.hologramScale,
                hologramOpacity: settings.visual.hologramOpacity,
                edgeOpacity: settings.visual.edgeOpacity,
                fogDensity: settings.visual.fogDensity
            };
            this.nodeManager.updateFeature(visualSettings);
            
            // Update fog density
            if (this.scene.fog && settings.visual.fogDensity !== undefined) {
                this.scene.fog.density = settings.visual.fogDensity;
            }
        }

        if (settings.material) {
            // Update material settings
            const materialSettings = {
                metalness: settings.material.metalness,
                roughness: settings.material.roughness,
                clearcoat: settings.material.clearcoat,
                clearcoatRoughness: settings.material.clearcoatRoughness,
                opacity: settings.material.opacity,
                emissiveMinIntensity: settings.material.emissiveMin,
                emissiveMaxIntensity: settings.material.emissiveMax
            };
            this.nodeManager.updateMaterial(materialSettings);
        }

        if (settings.physics) {
            // Update physics settings one by one
            const physicsParamMap = {
                iterations: 'forceDirectedIterations',
                spring: 'forceDirectedSpring',
                repulsion: 'forceDirectedRepulsion',
                attraction: 'forceDirectedAttraction',
                damping: 'forceDirectedDamping'
            };

            // Update each physics parameter individually
            Object.entries(settings.physics).forEach(([key, value]) => {
                if (physicsParamMap[key]) {
                    this.layoutManager.updateFeature(physicsParamMap[key], value);
                }
            });
        }

        if (settings.bloom) {
            // Update bloom settings
            const bloomSettings = {
                nodeBloomStrength: settings.bloom.nodeStrength,
                nodeBloomRadius: settings.bloom.nodeRadius,
                nodeBloomThreshold: settings.bloom.nodeThreshold,
                edgeBloomStrength: settings.bloom.edgeStrength,
                edgeBloomRadius: settings.bloom.edgeRadius,
                edgeBloomThreshold: settings.bloom.edgeThreshold,
                environmentBloomStrength: settings.bloom.envStrength,
                environmentBloomRadius: settings.bloom.envRadius,
                environmentBloomThreshold: settings.bloom.envThreshold
            };
            this.effectsManager.updateBloom(bloomSettings);
        }

        if (settings.fisheye) {
            // Update fisheye settings
            const fisheyeSettings = {
                enabled: settings.fisheye.enabled,
                strength: settings.fisheye.strength,
                radius: settings.fisheye.radius,
                focusPoint: [
                    settings.fisheye.focusX,
                    settings.fisheye.focusY,
                    settings.fisheye.focusZ
                ]
            };
            this.effectsManager.updateFisheye(fisheyeSettings);
        }
    }

    handleSpacemouseInput(x, y, z) {
        if (!this.camera || this.renderer.xr.isPresenting) return;

        // Translation
        this.camera.position.x += x * TRANSLATION_SPEED;
        this.camera.position.y += y * TRANSLATION_SPEED;
        this.camera.position.z += z * TRANSLATION_SPEED;

        // Update controls target
        if (this.controls) {
            this.controls.target.copy(this.camera.position).add(
                new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion)
            );
            this.controls.update();
        }
    }

    dispose() {
        console.log('Disposing WebXRVisualization');
        this.renderer.setAnimationLoop(null);

        window.removeEventListener('resize', this.onWindowResize);

        this.nodeManager.dispose();
        this.effectsManager.dispose();
        this.layoutManager.stopSimulation();
        
        if (this.xrLabelManager) {
            this.xrLabelManager.dispose();
        }

        if (this.xrControllers) {
            this.xrControllers.forEach(controller => {
                if (controller) {
                    this.scene.remove(controller);
                }
            });
        }

        if (this.xrHands) {
            this.xrHands.forEach(hand => {
                if (hand) {
                    this.scene.remove(hand);
                }
            });
        }

        this.renderer.dispose();
        if (this.controls) {
            this.controls.dispose();
        }

        console.log('WebXRVisualization disposed');
    }
}

----
components/visualization/textRenderer.js
import * as THREE from 'three';

// SDF font atlas generation
function generateSDFData(text, fontSize, padding) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size to power of 2 for better texture performance
    const size = Math.pow(2, Math.ceil(Math.log2(fontSize * 2 + padding * 2)));
    canvas.width = size;
    canvas.height = size;
    
    // Setup font
    ctx.font = `${fontSize}px Arial`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    
    // Draw text
    ctx.fillStyle = 'white';
    ctx.fillText(text, size/2, size/2);
    
    // Generate SDF
    const imageData = ctx.getImageData(0, 0, size, size);
    const sdf = new Float32Array(size * size);
    
    // Calculate SDF values
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            const alpha = imageData.data[idx + 3] / 255;
            
            // Calculate distance field
            let minDist = Number.MAX_VALUE;
            const maxSearchDist = fontSize / 2;
            
            for (let sy = -maxSearchDist; sy <= maxSearchDist; sy++) {
                for (let sx = -maxSearchDist; sx <= maxSearchDist; sx++) {
                    const sampX = x + sx;
                    const sampY = y + sy;
                    
                    if (sampX >= 0 && sampX < size && sampY >= 0 && sampY < size) {
                        const sampIdx = (sampY * size + sampX) * 4;
                        const sampAlpha = imageData.data[sampIdx + 3] / 255;
                        
                        if (sampAlpha !== alpha) {
                            const dist = Math.sqrt(sx*sx + sy*sy);
                            minDist = Math.min(minDist, dist);
                        }
                    }
                }
            }
            
            // Normalize and store SDF value
            sdf[y * size + x] = alpha === 1 ? minDist / maxSearchDist : -minDist / maxSearchDist;
        }
    }
    
    return {
        data: sdf,
        size: size,
        texture: new THREE.DataTexture(
            sdf,
            size,
            size,
            THREE.RedFormat,
            THREE.FloatType
        )
    };
}

export class TextRenderer {
    constructor() {
        // SDF shader for high-quality text rendering
        this.material = new THREE.ShaderMaterial({
            uniforms: {
                sdfTexture: { value: null },
                color: { value: new THREE.Color(0xffffff) },
                smoothing: { value: 0.25 },
                threshold: { value: 0.5 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D sdfTexture;
                uniform vec3 color;
                uniform float smoothing;
                uniform float threshold;
                varying vec2 vUv;
                
                void main() {
                    float sdf = texture2D(sdfTexture, vUv).r;
                    float alpha = smoothstep(threshold - smoothing, threshold + smoothing, sdf);
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });
    }
    
    createTextSprite(text, options = {}) {
        const {
            fontSize = 32,
            padding = 8,
            color = 0xffffff,
            backgroundColor = 0x000000,
            backgroundOpacity = 0.85
        } = options;
        
        // Generate SDF data
        const sdfData = generateSDFData(text, fontSize, padding);
        
        // Create geometry
        const geometry = new THREE.PlaneGeometry(1, 1);
        
        // Update material with new texture
        const material = this.material.clone();
        material.uniforms.sdfTexture.value = sdfData.texture;
        material.uniforms.color.value = new THREE.Color(color);
        
        // Create mesh
        const mesh = new THREE.Mesh(geometry, material);
        
        // Add background plane if needed
        if (backgroundOpacity > 0) {
            const bgGeometry = new THREE.PlaneGeometry(1.1, 1.1);
            const bgMaterial = new THREE.MeshBasicMaterial({
                color: backgroundColor,
                transparent: true,
                opacity: backgroundOpacity,
                depthWrite: false
            });
            const background = new THREE.Mesh(bgGeometry, bgMaterial);
            background.position.z = -0.001;
            mesh.add(background);
        }
        
        // Scale mesh based on texture size
        const scale = fontSize / sdfData.size;
        mesh.scale.set(sdfData.size * scale, sdfData.size * scale, 1);
        
        return mesh;
    }
    
    dispose() {
        this.material.dispose();
    }
}

----
components/visualization/layerManager.js
// Layer constants for rendering pipeline
export const LAYERS = {
    NORMAL_LAYER: 0,  // Base layer for regular rendering
    BLOOM: 1,        // Layer for node bloom effects
    HOLOGRAM: 2,     // Layer for hologram effects
    EDGE: 3,         // Layer for edge bloom effects
    LABEL: 4         // Layer for labels
};

// Layer groups for optimization
export const LAYER_GROUPS = {
    // Base scene elements (no bloom)
    BASE: [LAYERS.NORMAL_LAYER],
    
    // Elements that should have bloom
    BLOOM: [LAYERS.NORMAL_LAYER, LAYERS.BLOOM],
    
    // Hologram elements
    HOLOGRAM: [LAYERS.NORMAL_LAYER, LAYERS.HOLOGRAM],
    
    // Edge elements
    EDGE: [LAYERS.NORMAL_LAYER, LAYERS.EDGE],
    
    // Label elements (should be visible in all layers)
    LABEL: [
        LAYERS.NORMAL_LAYER,
        LAYERS.BLOOM,
        LAYERS.HOLOGRAM,
        LAYERS.EDGE,
        LAYERS.LABEL
    ]
};

// Helper functions for layer management
export const LayerManager = {
    // Enable multiple layers for an object
    enableLayers(object, layers) {
        if (!Array.isArray(layers)) {
            layers = [layers];
        }
        layers.forEach(layer => object.layers.enable(layer));
    },

    // Set object to specific layer group
    setLayerGroup(object, groupName) {
        const layers = LAYER_GROUPS[groupName];
        if (!layers) {
            console.warn(`Unknown layer group: ${groupName}`);
            return;
        }
        
        // Reset layers
        object.layers.mask = 0;
        
        // Enable all layers in group
        layers.forEach(layer => object.layers.enable(layer));
    },

    // Check if object is in layer
    isInLayer(object, layer) {
        return object.layers.test(new THREE.Layers().set(layer));
    },

    // Get all objects in a specific layer
    getObjectsInLayer(scene, layer) {
        const objects = [];
        scene.traverse(object => {
            if (this.isInLayer(object, layer)) {
                objects.push(object);
            }
        });
        return objects;
    }
};

----
threeJS/threeSetup.js
// public/js/threeJS/threeSetup.js

import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {object} An object containing the scene, camera, and renderer.
 */
export function initThreeScene() {
    // Create the scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    // Create the camera with XR-friendly settings
    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,  // Closer near plane for XR
        1000
    );
    camera.position.set(0, 1.6, 3); // Default height ~1.6m (average human height)

    // Create the renderer with optimized configuration
    const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true, // Enable alpha for AR passthrough
        logarithmicDepthBuffer: true, // Better depth precision for XR
        powerPreference: "high-performance",
        premultipliedAlpha: false,
        stencil: false,
        depth: true,
        preserveDrawingBuffer: false
    });

    // Configure renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Modern color space handling
    renderer.xr.enabled = true; // Enable WebXR
    renderer.shadowMap.enabled = true; // Enable shadows for better visual quality
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for realism

    // Add WebGL context loss handling
    renderer.domElement.addEventListener('webglcontextlost', handleContextLost, false);
    renderer.domElement.addEventListener('webglcontextrestored', handleContextRestored, false);

    // Set up XR-friendly lighting
    setupLighting(scene);

    // Append the renderer to the DOM
    const container = document.getElementById('scene-container');
    if (container) {
        container.appendChild(renderer.domElement);
    } else {
        document.body.appendChild(renderer.domElement);
    }

    // Add ambient light for better visibility in XR
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // Set texture memory hints
    THREE.TextureLoader.prototype.crossOrigin = 'anonymous';
    renderer.info.autoReset = true;
    renderer.info.reset();

    return { scene, camera, renderer };
}

/**
 * Handle WebGL context loss
 * @param {Event} event - The context loss event
 */
function handleContextLost(event) {
    event.preventDefault();
    console.warn('WebGL context lost. Attempting to restore...');
}

/**
 * Handle WebGL context restoration
 */
function handleContextRestored() {
    console.log('WebGL context restored');
    // Force a full scene refresh
    window.dispatchEvent(new Event('webglcontextrestored'));
}

/**
 * Sets up XR-friendly lighting in the scene
 * @param {THREE.Scene} scene - The Three.js scene
 */
function setupLighting(scene) {
    // Main directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    
    // Optimize shadow map settings
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.bias = -0.0001;
    
    scene.add(directionalLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    // Ambient light for overall scene brightness
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
}

/**
 * Creates and configures orbit controls for the camera.
 * @param {THREE.Camera} camera - The Three.js camera.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 * @returns {OrbitControls} The configured orbit controls.
 */
export function createOrbitControls(camera, renderer) {
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // Configure controls for XR compatibility
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI * 0.95; // Prevent camera from going below ground
    controls.minDistance = 1; // Minimum zoom distance
    controls.maxDistance = 50; // Maximum zoom distance
    controls.enablePan = true;
    controls.panSpeed = 0.5;
    controls.rotateSpeed = 0.5;
    controls.zoomSpeed = 0.5;
    
    // Disable controls when in XR mode
    renderer.xr.addEventListener('sessionstart', () => {
        controls.enabled = false;
    });
    
    renderer.xr.addEventListener('sessionend', () => {
        controls.enabled = true;
    });

    return controls;
}

/**
 * Handles window resize events by updating the camera and renderer.
 * @param {THREE.Camera} camera - The Three.js camera.
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer.
 */
export function updateSceneSize(camera, renderer) {
    // Only update if not in XR session
    if (!renderer.xr.isPresenting) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

/**
 * Creates a basic environment for XR scenes
 * @param {THREE.Scene} scene - The Three.js scene
 * @returns {Object} Environment meshes for cleanup
 */
export function createBasicEnvironment(scene) {
    // Add a ground plane for reference and shadows
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x808080,
        roughness: 0.8,
        metalness: 0.2,
        transparent: true,
        opacity: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Add grid helper for spatial reference
    const gridHelper = new THREE.GridHelper(100, 100);
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.2;
    scene.add(gridHelper);

    return {
        ground,
        gridHelper,
        dispose: () => {
            // Cleanup materials and geometries
            groundGeometry.dispose();
            groundMaterial.dispose();
            if (gridHelper.material) {
                gridHelper.material.dispose();
            }
            if (gridHelper.geometry) {
                gridHelper.geometry.dispose();
            }
            // Remove from scene
            scene.remove(ground);
            scene.remove(gridHelper);
        }
    };
}

/**
 * Disposes of Three.js resources
 * @param {THREE.Scene} scene - The Three.js scene
 * @param {THREE.WebGLRenderer} renderer - The Three.js renderer
 * @param {OrbitControls} controls - The orbit controls
 */
export function disposeThreeResources(scene, renderer, controls) {
    // Dispose of scene objects
    scene.traverse((object) => {
        if (object.geometry) {
            object.geometry.dispose();
        }
        
        if (object.material) {
            if (Array.isArray(object.material)) {
                object.material.forEach(material => {
                    if (material.map) material.map.dispose();
                    material.dispose();
                });
            } else {
                if (object.material.map) object.material.map.dispose();
                object.material.dispose();
            }
        }
    });

    // Dispose of renderer
    renderer.dispose();
    renderer.forceContextLoss();
    renderer.domElement.remove();

    // Remove context loss listeners
    renderer.domElement.removeEventListener('webglcontextlost', handleContextLost);
    renderer.domElement.removeEventListener('webglcontextrestored', handleContextRestored);

    // Dispose of controls
    if (controls) {
        controls.dispose();
    }
}

----
threeJS/threeGraph.js
// public/js/threeJS/threeGraph.js

import * as THREE from 'three';
import { visualizationSettings } from '../services/visualizationSettings.js';

/**
 * ForceGraph class manages the creation and updating of nodes and edges in the Three.js scene.
 */
export class ForceGraph {
    /**
     * Creates a new ForceGraph instance.
     * @param {THREE.Scene} scene - The Three.js scene.
     */
    constructor(scene) {
        this.scene = scene;

        // Data structures
        this.nodes = [];
        this.links = [];

        // Meshes
        this.nodeMeshes = new Map();
        this.linkMeshes = new Map();

        // Object pools with pre-allocation
        this.nodeMeshPool = [];
        this.linkMeshPool = [];
        this.geometryPool = new Map(); // Pool for reusing geometries
        this.materialPool = new Map(); // Pool for reusing materials

        // Level of Detail
        this.lod = new THREE.LOD();
        this.scene.add(this.lod);

        // Shared geometry for instancing
        this.sharedNodeGeometry = null;
        this.sharedEdgeGeometry = null;

        // Get settings
        const nodeSettings = visualizationSettings.getNodeSettings();
        const edgeSettings = visualizationSettings.getEdgeSettings();
        
        // Store settings
        this.nodeColors = {
            NEW: new THREE.Color(nodeSettings.colorNew),
            RECENT: new THREE.Color(nodeSettings.colorRecent),
            MEDIUM: new THREE.Color(nodeSettings.colorMedium),
            OLD: new THREE.Color(nodeSettings.colorOld),
            CORE: new THREE.Color(nodeSettings.colorCore),
            SECONDARY: new THREE.Color(nodeSettings.colorSecondary),
            DEFAULT: new THREE.Color(nodeSettings.colorDefault)
        };
        this.edgeColor = new THREE.Color(edgeSettings.color);
        this.edgeOpacity = edgeSettings.opacity;
        this.minNodeSize = nodeSettings.minNodeSize;  // In meters (0.1m = 10cm)
        this.maxNodeSize = nodeSettings.maxNodeSize;  // In meters (0.3m = 30cm)
        this.materialSettings = nodeSettings.material;

        // Initialize shared resources
        this.initSharedResources();
    }

    /**
     * Initialize shared geometries and materials
     */
    initSharedResources() {
        // Create shared node geometry with different LOD levels
        const highDetail = new THREE.SphereGeometry(1, 32, 32);
        const mediumDetail = new THREE.SphereGeometry(1, 16, 16);
        const lowDetail = new THREE.SphereGeometry(1, 8, 8);

        this.geometryPool.set('node-high', highDetail);
        this.geometryPool.set('node-medium', mediumDetail);
        this.geometryPool.set('node-low', lowDetail);

        // Create shared edge geometry
        const edgeGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(6);
        edgeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.geometryPool.set('edge', edgeGeometry);
    }

    /**
     * Get or create a geometry from the pool
     * @param {string} type - The type of geometry
     * @param {number} size - The size for node geometries
     * @returns {THREE.BufferGeometry}
     */
    getGeometry(type, size = 1) {
        const key = `${type}-${size}`;
        if (this.geometryPool.has(key)) {
            return this.geometryPool.get(key);
        }

        let geometry;
        switch (type) {
            case 'node-high':
                geometry = new THREE.SphereGeometry(size, 32, 32);
                break;
            case 'node-medium':
                geometry = new THREE.SphereGeometry(size, 16, 16);
                break;
            case 'node-low':
                geometry = new THREE.SphereGeometry(size, 8, 8);
                break;
            case 'edge':
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
                break;
        }

        this.geometryPool.set(key, geometry);
        return geometry;
    }

    /**
     * Get or create a material from the pool
     * @param {string} type - The type of material
     * @param {object} params - Material parameters
     * @returns {THREE.Material}
     */
    getMaterial(type, params) {
        const key = `${type}-${JSON.stringify(params)}`;
        if (this.materialPool.has(key)) {
            return this.materialPool.get(key);
        }

        let material;
        switch (type) {
            case 'node':
                material = new THREE.MeshPhysicalMaterial({
                    color: params.color,
                    emissive: params.color,
                    emissiveIntensity: params.emissiveIntensity,
                    metalness: this.materialSettings.metalness,
                    roughness: this.materialSettings.roughness,
                    transparent: true,
                    opacity: this.materialSettings.opacity,
                    envMapIntensity: 1.0,
                    clearcoat: this.materialSettings.clearcoat,
                    clearcoatRoughness: this.materialSettings.clearcoatRoughness
                });
                break;
            case 'edge':
                material = new THREE.LineBasicMaterial({
                    color: params.color,
                    opacity: params.opacity,
                    transparent: true,
                    linewidth: params.linewidth || 1
                });
                break;
        }

        this.materialPool.set(key, material);
        return material;
    }

    // Previous methods remain the same until updateNodes...

    /**
     * Updates nodes in the scene based on the graph data.
     */
    updateNodes() {
        const newNodeIds = new Set(this.nodes.map((node) => node.id));

        // Remove nodes that no longer exist
        this.nodeMeshes.forEach((mesh, nodeId) => {
            if (!newNodeIds.has(nodeId)) {
                this.lod.removeLevel(mesh);
                this.nodeMeshes.delete(nodeId);
                
                // Return mesh to pool
                if (mesh.material) {
                    mesh.material.dispose();
                }
                this.nodeMeshPool.push(mesh);
            }
        });

        // Add or update nodes
        this.nodes.forEach((node) => {
            const nodeSize = this.getNodeSize(node);
            const nodeColor = this.getNodeColor(node);
            const distance = node.metadata?.distance || 0;

            if (this.nodeMeshes.has(node.id)) {
                const mesh = this.nodeMeshes.get(node.id);
                mesh.position.set(node.x, node.y, node.z);
                
                // Update material if needed
                const material = this.getMaterial('node', {
                    color: nodeColor,
                    emissiveIntensity: this.calculateEmissiveIntensity(node)
                });
                
                if (mesh.material !== material) {
                    if (mesh.material) mesh.material.dispose();
                    mesh.material = material;
                }

                // Update geometry if size changed
                if (mesh.geometry.parameters.radius !== nodeSize) {
                    const geometry = this.getGeometry('node-high', nodeSize);
                    mesh.geometry = geometry;
                }
            } else {
                // Create LOD levels
                const highDetail = new THREE.Mesh(
                    this.getGeometry('node-high', nodeSize),
                    this.getMaterial('node', {
                        color: nodeColor,
                        emissiveIntensity: this.calculateEmissiveIntensity(node)
                    })
                );
                
                const mediumDetail = new THREE.Mesh(
                    this.getGeometry('node-medium', nodeSize),
                    highDetail.material
                );
                
                const lowDetail = new THREE.Mesh(
                    this.getGeometry('node-low', nodeSize),
                    highDetail.material
                );

                // Create LOD object
                const nodeLOD = new THREE.LOD();
                nodeLOD.addLevel(highDetail, 0);
                nodeLOD.addLevel(mediumDetail, 10);
                nodeLOD.addLevel(lowDetail, 20);
                nodeLOD.position.set(node.x, node.y, node.z);
                
                this.lod.addLevel(nodeLOD, distance);
                this.nodeMeshes.set(node.id, nodeLOD);
            }
        });
    }

    /**
     * Updates edges in the scene based on the graph data.
     */
    updateLinks() {
        const newLinkKeys = new Set(this.links.map((link) => `${link.source}-${link.target}`));

        // Remove edges that no longer exist
        this.linkMeshes.forEach((line, linkKey) => {
            if (!newLinkKeys.has(linkKey)) {
                this.scene.remove(line);
                if (line.material) line.material.dispose();
                this.linkMeshes.delete(linkKey);
                this.linkMeshPool.push(line);
            }
        });

        // Add or update edges
        this.links.forEach((link) => {
            const linkKey = `${link.source}-${link.target}`;
            const weight = link.weight || 1;
            const normalizedWeight = Math.min(weight / 10, 1);

            const sourceMesh = this.nodeMeshes.get(link.source);
            const targetMesh = this.nodeMeshes.get(link.target);
            
            if (!sourceMesh || !targetMesh) return;

            if (this.linkMeshes.has(linkKey)) {
                const line = this.linkMeshes.get(linkKey);
                const positions = line.geometry.attributes.position.array;
                positions[0] = sourceMesh.position.x;
                positions[1] = sourceMesh.position.y;
                positions[2] = sourceMesh.position.z;
                positions[3] = targetMesh.position.x;
                positions[4] = targetMesh.position.y;
                positions[5] = targetMesh.position.z;
                line.geometry.attributes.position.needsUpdate = true;
                
                // Update material if needed
                const material = this.getMaterial('edge', {
                    color: this.edgeColor,
                    opacity: this.edgeOpacity * normalizedWeight,
                    linewidth: Math.max(1, Math.min(weight, 5))
                });
                
                if (line.material !== material) {
                    if (line.material) line.material.dispose();
                    line.material = material;
                }
            } else {
                // Create new edge
                const geometry = this.getGeometry('edge');
                const material = this.getMaterial('edge', {
                    color: this.edgeColor,
                    opacity: this.edgeOpacity * normalizedWeight,
                    linewidth: Math.max(1, Math.min(weight, 5))
                });

                let line;
                if (this.linkMeshPool.length > 0) {
                    line = this.linkMeshPool.pop();
                    line.geometry = geometry;
                    line.material = material;
                } else {
                    line = new THREE.Line(geometry, material);
                }

                const positions = line.geometry.attributes.position.array;
                positions[0] = sourceMesh.position.x;
                positions[1] = sourceMesh.position.y;
                positions[2] = sourceMesh.position.z;
                positions[3] = targetMesh.position.x;
                positions[4] = targetMesh.position.y;
                positions[5] = targetMesh.position.z;
                line.geometry.attributes.position.needsUpdate = true;

                this.scene.add(line);
                this.linkMeshes.set(linkKey, line);
            }
        });
    }

    /**
     * Calculate emissive intensity based on node age
     * @param {object} node - The node object
     * @returns {number} - The emissive intensity
     */
    calculateEmissiveIntensity(node) {
        const lastModified = node.metadata?.github_last_modified || 
                           node.metadata?.last_modified || 
                           new Date().toISOString();
        const now = Date.now();
        const ageInDays = (now - new Date(lastModified).getTime()) / (24 * 60 * 60 * 1000);
        
        // Normalize age to 0-1 range and invert (newer = brighter)
        const normalizedAge = Math.min(ageInDays / 30, 1);
        return this.materialSettings.emissiveMaxIntensity - 
            (normalizedAge * (this.materialSettings.emissiveMaxIntensity - this.materialSettings.emissiveMinIntensity));
    }

    /**
     * Dispose of all resources
     */
    dispose() {
        // Dispose of node resources
        this.nodeMeshes.forEach(mesh => {
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(mat => mat.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
        });

        // Dispose of edge resources
        this.linkMeshes.forEach(line => {
            if (line.geometry) line.geometry.dispose();
            if (line.material) line.material.dispose();
        });

        // Dispose of pooled resources
        this.nodeMeshPool.forEach(mesh => {
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(mat => mat.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
        });

        this.linkMeshPool.forEach(line => {
            if (line.geometry) line.geometry.dispose();
            if (line.material) line.material.dispose();
        });

        // Dispose of shared resources
        this.geometryPool.forEach(geometry => geometry.dispose());
        this.materialPool.forEach(material => material.dispose());

        // Clear all collections
        this.nodeMeshes.clear();
        this.linkMeshes.clear();
        this.nodeMeshPool.length = 0;
        this.linkMeshPool.length = 0;
        this.geometryPool.clear();
        this.materialPool.clear();

        // Remove LOD from scene
        if (this.lod.parent) {
            this.lod.parent.remove(this.lod);
        }
    }
}

--END--