diff --git a/handlers/file_handler.rs b/handlers/file_handler.rs
index 63bb4c90..a65c017d 100755
--- a/handlers/file_handler.rs
+++ b/handlers/file_handler.rs
@@ -1,9 +1,141 @@
 use actix_web::{web, Error as ActixError, HttpResponse};
 use serde_json::json;
 use log::{info, error, debug};
+use std::sync::Arc;
+
 use crate::AppState;
 use crate::services::file_service::FileService;
 use crate::services::graph_service::GraphService;
+use crate::utils::websocket_manager::{BroadcastGraph, BroadcastError};
+
+pub async fn handle_file_upload(
+    state: web::Data<AppState>,
+    file_service: web::Data<FileService>,
+    payload: web::Bytes,
+) -> Result<HttpResponse, ActixError> {
+    debug!("Handling file upload request");
+
+    match file_service.get_ref().process_file_upload(payload).await {
+        Ok(graph_data) => {
+            debug!("File processed successfully, updating graph data");
+            
+            // Update shared graph data
+            {
+                let mut graph = state.graph_data.write().await;
+                *graph = graph_data.clone();
+            }
+
+            // Broadcast update to all connected clients
+            let graph_msg = BroadcastGraph {
+                graph: Arc::new(graph_data)
+            };
+
+            if let Some(addr) = state.websocket_manager.get_addr() {
+                addr.do_send(graph_msg);
+            }
+
+            Ok(HttpResponse::Ok().json(json!({
+                "message": "File processed successfully"
+            })))
+        },
+        Err(e) => {
+            error!("Error processing file: {}", e);
+            
+            // Broadcast error to clients
+            let error_msg = BroadcastError {
+                message: format!("Error processing file: {}", e)
+            };
+
+            if let Some(addr) = state.websocket_manager.get_addr() {
+                addr.do_send(error_msg);
+            }
+
+            Ok(HttpResponse::BadRequest().json(json!({
+                "error": format!("Error processing file: {}", e)
+            })))
+        }
+    }
+}
+
+pub async fn handle_file_list(
+    state: web::Data<AppState>,
+    file_service: web::Data<FileService>,
+) -> Result<HttpResponse, ActixError> {
+    debug!("Handling file list request");
+
+    match file_service.get_ref().list_files().await {
+        Ok(files) => {
+            Ok(HttpResponse::Ok().json(json!({
+                "files": files
+            })))
+        },
+        Err(e) => {
+            error!("Error listing files: {}", e);
+            
+            // Broadcast error to clients
+            let error_msg = BroadcastError {
+                message: format!("Error listing files: {}", e)
+            };
+
+            if let Some(addr) = state.websocket_manager.get_addr() {
+                addr.do_send(error_msg);
+            }
+
+            Ok(HttpResponse::InternalServerError().json(json!({
+                "error": format!("Error listing files: {}", e)
+            })))
+        }
+    }
+}
+
+pub async fn handle_file_load(
+    state: web::Data<AppState>,
+    file_service: web::Data<FileService>,
+    filename: web::Path<String>,
+) -> Result<HttpResponse, ActixError> {
+    debug!("Handling file load request for: {}", filename);
+
+    match file_service.get_ref().load_file(&filename).await {
+        Ok(graph_data) => {
+            debug!("File loaded successfully, updating graph data");
+            
+            // Update shared graph data
+            {
+                let mut graph = state.graph_data.write().await;
+                *graph = graph_data.clone();
+            }
+
+            // Broadcast update to all connected clients
+            let graph_msg = BroadcastGraph {
+                graph: Arc::new(graph_data)
+            };
+
+            if let Some(addr) = state.websocket_manager.get_addr() {
+                addr.do_send(graph_msg);
+            }
+
+            Ok(HttpResponse::Ok().json(json!({
+                "message": "File loaded successfully"
+            })))
+        },
+        Err(e) => {
+            error!("Error loading file: {}", e);
+            
+            // Broadcast error to clients
+            let error_msg = BroadcastError {
+                message: format!("Error loading file: {}", e)
+            };
+
+            if let Some(addr) = state.websocket_manager.get_addr() {
+                addr.do_send(error_msg);
+            }
+
+            Ok(HttpResponse::BadRequest().json(json!({
+                "error": format!("Error loading file: {}", e)
+            })))
+        }
+    }
+}
 
 pub async fn fetch_and_process_files(state: web::Data<AppState>) -> HttpResponse {
     info!("Initiating optimized file fetch and processing");
@@ -59,15 +191,13 @@ pub async fn fetch_and_process_files(state: web::Data<AppState>) -> HttpResponse
                     *graph = graph_data.clone();
                     info!("Graph data structure updated successfully");
 
-                    // Broadcast graph update to connected clients
-                    let broadcast_result = state.websocket_manager.broadcast_message(&json!({
-                        "type": "graphUpdate",
-                        "data": graph_data,
-                    }).to_string()).await;
+                    // Broadcast update to all connected clients
+                    let graph_msg = BroadcastGraph {
+                        graph: Arc::new(graph_data)
+                    };
 
-                    if let Err(e) = broadcast_result {
-                        error!("Failed to broadcast graph update: {}", e);
-                    } else {
+                    if let Some(addr) = state.websocket_manager.get_addr() {
+                        addr.do_send(graph_msg);
                         debug!("Graph update broadcasted successfully");
                     }
 
@@ -132,14 +262,13 @@ pub async fn refresh_graph(state: web::Data<AppState>) -> HttpResponse {
             *graph = graph_data.clone();
             info!("Graph data structure refreshed successfully");
 
-            let broadcast_result = state.websocket_manager.broadcast_message(&json!({
-                "type": "graphUpdate",
-                "data": graph_data,
-            }).to_string()).await;
+            // Broadcast update to all connected clients
+            let graph_msg = BroadcastGraph {
+                graph: Arc::new(graph_data)
+            };
 
-            if let Err(e) = broadcast_result {
-                error!("Failed to broadcast graph update: {}", e);
-            } else {
+            if let Some(addr) = state.websocket_manager.get_addr() {
+                addr.do_send(graph_msg);
                 debug!("Graph update broadcasted successfully");
             }
 
@@ -177,6 +306,15 @@ pub async fn update_graph(state: web::Data<AppState>) -> Result<HttpResponse, Ac
             // Update graph data
             *state.graph_data.write().await = graph.clone();
             
+            // Broadcast update to all connected clients
+            let graph_msg = BroadcastGraph {
+                graph: Arc::new(graph.clone())
+            };
+
+            if let Some(addr) = state.websocket_manager.get_addr() {
+                addr.do_send(graph_msg);
+            }
+            
             Ok(HttpResponse::Ok().json(json!({
                 "status": "success",
                 "message": "Graph updated successfully",
diff --git a/handlers/mod.rs b/handlers/mod.rs
index 420742ce..ef86ee67 100755
--- a/handlers/mod.rs
+++ b/handlers/mod.rs
@@ -7,6 +7,3 @@ pub mod websocket_handlers;
 
 // Re-export WebSocketSession and related types
 pub use websocket_handlers::{WebSocketSession, WebSocketSessionHandler};
-
-// Re-export handlers for easier access
-pub use perplexity_handler::process_files as process_perplexity_files;
diff --git a/handlers/websocket_handlers.rs b/handlers/websocket_handlers.rs
index 67296d14..bb7e3fad 100755
--- a/handlers/websocket_handlers.rs
+++ b/handlers/websocket_handlers.rs
@@ -5,10 +5,12 @@ use actix_web_actors::ws::WebsocketContext;
 use bytestring::ByteString;
 use bytemuck;
 use futures::StreamExt;
-use log::{debug, error, info};
+use log::{debug, error, info, warn};
 use serde_json::json;
 use std::sync::{Arc, Mutex};
 use tokio::time::Duration;
+use actix_web_actors::ws;
+use actix::StreamHandler;
 
 use crate::AppState;
 use crate::models::node::GPUNode;
@@ -16,19 +18,17 @@ use crate::models::simulation_params::{SimulationMode, SimulationParams};
 use crate::models::position_update::NodePositionVelocity;
 use crate::utils::websocket_messages::{
     MessageHandler, OpenAIConnected, OpenAIConnectionFailed, OpenAIMessage, SendBinary, SendText,
+    ServerMessage,
 };
 use crate::utils::websocket_openai::OpenAIWebSocket;
 
-// Constants for timing and performance
 pub const OPENAI_CONNECT_TIMEOUT: Duration = Duration::from_secs(5);
-pub const GPU_UPDATE_INTERVAL: Duration = Duration::from_millis(16); // ~60fps for smooth updates
+pub const GPU_UPDATE_INTERVAL: Duration = Duration::from_millis(16);
 
-// Message type for GPU position updates
 #[derive(Message)]
 #[rtype(result = "()")]
 pub struct GpuUpdate;
 
-/// WebSocket session actor handling client communication
 pub struct WebSocketSession {
     pub state: web::Data<AppState>,
     pub tts_method: String,
@@ -37,34 +37,219 @@ pub struct WebSocketSession {
     pub conversation_id: Option<Arc<Mutex<Option<String>>>>,
 }
 
+impl WebSocketSession {
+    pub fn new(state: web::Data<AppState>) -> Self {
+        Self {
+            state,
+            tts_method: String::from("local"),
+            openai_ws: None,
+            simulation_mode: SimulationMode::Remote,
+            conversation_id: Some(Arc::new(Mutex::new(None))),
+        }
+    }
+
+    // Helper method to validate binary data
+    fn validate_binary_data(&self, data: &[u8]) -> bool {
+        let node_size = std::mem::size_of::<NodePositionVelocity>();
+        if data.len() % node_size != 0 {
+            warn!("Invalid binary data length: {} (not a multiple of {})", data.len(), node_size);
+            return false;
+        }
+        true
+    }
+
+// Helper method to process binary position updates
+    fn process_binary_update(&mut self, data: &[u8]) -> Result<(), String> {
+        if !self.validate_binary_data(data) {
+            return Err("Invalid binary data format".to_string());
+        }
+
+        let positions: Vec<NodePositionVelocity> = bytemuck::cast_slice(data).to_vec();
+        
+        // Log first few positions for debugging
+        if !positions.is_empty() {
+            debug!(
+                "Processing binary update with {} positions. First position: x={}, y={}, z={}, vx={}, vy={}, vz={}",
+                positions.len(),
+                positions[0].x, positions[0].y, positions[0].z,
+                positions[0].vx, positions[0].vy, positions[0].vz
+            );
+        } else {
+            warn!("Received empty positions array");
+            return Ok(());
+        }
+
+        // Update graph data with new positions
+        let state = self.state.clone();
+        let positions = positions.clone(); // Clone for async move
+        
+        actix::spawn(async move {
+            let mut graph_data = state.graph_data.write().await;
+            // Update node positions while preserving other attributes
+            for (i, pos) in positions.iter().enumerate() {
+                if i < graph_data.nodes.len() {
+                    debug!(
+                        "Updating node {}: old pos=({},{},{}), new pos=({},{},{})",
+                        i,
+                        graph_data.nodes[i].x, graph_data.nodes[i].y, graph_data.nodes[i].z,
+                        pos.x, pos.y, pos.z
+                    );
+                    graph_data.nodes[i].x = pos.x;
+                    graph_data.nodes[i].y = pos.y;
+                    graph_data.nodes[i].z = pos.z;
+                    graph_data.nodes[i].vx = pos.vx;
+                    graph_data.nodes[i].vy = pos.vy;
+                    graph_data.nodes[i].vz = pos.vz;
+                }
+            }
+            debug!("Updated {} node positions", positions.len());
+        });
+
+        Ok(())
+    }
+}
+
 impl Actor for WebSocketSession {
     type Context = WebsocketContext<Self>;
 }
 
+impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession {
+    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
+        match msg {
+            Ok(ws::Message::Ping(msg)) => {
+                debug!("Ping received");
+                ctx.pong(&msg);
+            }
+            Ok(ws::Message::Pong(_)) => {
+                debug!("Pong received");
+            }
+            Ok(ws::Message::Text(text)) => {
+                debug!("Text message received: {}", text);
+                if let Ok(value) = serde_json::from_str::<serde_json::Value>(&text) {
+                    match value.get("type").and_then(|t| t.as_str()) {
+                        Some("chat") => {
+                            if let Some(message) = value.get("message").and_then(|m| m.as_str()) {
+                                let use_openai = value.get("useOpenAI")
+                                    .and_then(|o| o.as_bool())
+                                    .unwrap_or(false);
+                                self.handle_chat_message(ctx, message.to_string(), use_openai);
+                            }
+                        }
+                        Some("simulation_mode") => {
+                            if let Some(mode) = value.get("mode").and_then(|m| m.as_str()) {
+                                self.handle_simulation_mode(ctx, mode);
+                            }
+                        }
+                        Some("layout") => {
+                            if let Ok(params) = serde_json::from_value::<SimulationParams>(value["params"].clone()) {
+                                self.handle_layout(ctx, params);
+                            }
+                        }
+                        Some("fisheye") => {
+                            let enabled = value.get("enabled").and_then(|e| e.as_bool()).unwrap_or(false);
+                            let strength = value.get("strength").and_then(|s| s.as_f64()).unwrap_or(1.0) as f32;
+                            let focus_point = value.get("focusPoint")
+                                .and_then(|f| f.as_array())
+                                .and_then(|arr| {
+                                    if arr.len() == 3 {
+                                        Some([
+                                            arr[0].as_f64().unwrap_or(0.0) as f32,
+                                            arr[1].as_f64().unwrap_or(0.0) as f32,
+                                            arr[2].as_f64().unwrap_or(0.0) as f32,
+                                        ])
+                                    } else {
+                                        None
+                                    }
+                                })
+                                .unwrap_or([0.0, 0.0, 0.0]);
+                            let radius = value.get("radius").and_then(|r| r.as_f64()).unwrap_or(1.0) as f32;
+                            self.handle_fisheye_settings(ctx, enabled, strength, focus_point, radius);
+                        }
+                        Some("initial_data") => {
+                            self.handle_initial_data(ctx);
+                        }
+                        _ => {
+                            error!("Unknown message type received");
+                            let error_message = ServerMessage::Error {
+                                message: "Unknown message type".to_string(),
+                                code: Some("UNKNOWN_MESSAGE_TYPE".to_string())
+                            };
+                            if let Ok(error_str) = serde_json::to_string(&error_message) {
+                                ctx.text(ByteString::from(error_str));
+                            }
+                        }
+                    }
+                }
+            }
+            Ok(ws::Message::Binary(bin)) => {
+                debug!("Binary message received: {} bytes", bin.len());
+                match self.process_binary_update(&bin) {
+                    Ok(_) => {
+                        debug!("Binary update processed successfully");
+                    },
+                    Err(e) => {
+                        error!("Failed to process binary update: {}", e);
+                        let error_message = ServerMessage::Error {
+                            message: format!("Binary update processing failed: {}", e),
+                            code: Some("BINARY_UPDATE_ERROR".to_string())
+                        };
+                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+                            ctx.text(ByteString::from(error_str));
+                        }
+                    }
+                }
+            }
+            Ok(ws::Message::Close(reason)) => {
+                debug!("Client disconnected: {:?}", reason);
+                ctx.close(reason);
+                ctx.stop();
+            }
+            Ok(ws::Message::Continuation(_)) => {
+                debug!("Continuation frame received");
+            }
+            Ok(ws::Message::Nop) => {
+                debug!("Nop frame received");
+            }
+            Err(e) => {
+                error!("Error in WebSocket message handling: {}", e);
+                ctx.stop();
+            }
+        }
+    }
+}
+
 impl MessageHandler for WebSocketSession {}
 
-/// Helper function to convert hex color to proper format
-/// Handles various input formats (0x, #, or raw hex) and normalizes to #RRGGBB
 pub fn format_color(color: &str) -> String {
     let color = color.trim_matches('"')
         .trim_start_matches("0x")
         .trim_start_matches('#');
     
-    // Handle rgba format
     if color.starts_with("rgba(") {
         return color.to_string();
     }
     
-    // Handle regular hex colors
     format!("#{}", color)
 }
 
-/// Helper function to convert GPU nodes to binary position updates
-/// Creates efficient binary format for network transfer (24 bytes per node)
 pub fn positions_to_binary(nodes: &[GPUNode]) -> Vec<u8> {
     let mut binary_data = Vec::with_capacity(nodes.len() * std::mem::size_of::<NodePositionVelocity>());
+    
+    // Log first node for debugging
+    if !nodes.is_empty() {
+        debug!(
+            "Converting first node: x={}, y={}, z={}, vx={}, vy={}, vz={}",
+            nodes[0].x, nodes[0].y, nodes[0].z,
+            nodes[0].vx, nodes[0].vy, nodes[0].vz
+        );
+    }
+
     for node in nodes {
-        // Convert to position update format (24 bytes)
+        // Ensure values are not zero unless they should be
+        if node.x == 0.0 && node.y == 0.0 && node.z == 0.0 {
+            warn!("Node position is all zeros - this might indicate an issue");
+        }
+
         let update = NodePositionVelocity {
             x: node.x,
             y: node.y,
@@ -73,9 +258,12 @@ pub fn positions_to_binary(nodes: &[GPUNode]) -> Vec<u8> {
             vy: node.vy,
             vz: node.vz,
         };
-        // Use as_bytes() since NodePositionVelocity is Pod
         binary_data.extend_from_slice(bytemuck::bytes_of(&update));
     }
+
+    // Log binary data size for debugging
+    debug!("Binary data size: {} bytes", binary_data.len());
+    
     binary_data
 }
 
@@ -89,154 +277,129 @@ pub trait WebSocketSessionHandler {
     fn handle_fisheye_settings(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, enabled: bool, strength: f32, focus_point: [f32; 3], radius: f32);
 }
 
-// Handler for GPU position updates
-impl Handler<GpuUpdate> for WebSocketSession {
-    type Result = ResponseActFuture<Self, ()>;
-
-    fn handle(&mut self, _: GpuUpdate, ctx: &mut Self::Context) -> Self::Result {
+// Main WebSocket session handler implementation
+impl WebSocketSessionHandler for WebSocketSession {
+    fn handle_initial_data(&mut self, ctx: &mut WebsocketContext<WebSocketSession>) {
         let state = self.state.clone();
-        let gpu_compute = if let Some(gpu) = &state.gpu_compute {
-            gpu.clone()
-        } else {
-            return Box::pin(futures::future::ready(()).into_actor(self));
-        };
         let ctx_addr = ctx.address();
 
-        Box::pin(async move {
-            let mut gpu = gpu_compute.write().await;
-            if let Err(e) = gpu.step() {
-                error!("GPU compute step failed: {}", e);
-                return;
+        let fut = async move {
+            let graph_data = state.graph_data.read().await;
+            let settings = state.settings.read().await;
+            
+            // Send graph data using ServerMessage enum, ensuring metadata is included
+            let graph_update = ServerMessage::GraphUpdate {
+                graph_data: json!({
+                    "nodes": graph_data.nodes.iter().map(|node| {
+                        json!({
+                            "id": node.id,
+                            "label": node.label,
+                            "position": [node.x, node.y, node.z],
+                            "velocity": [node.vx, node.vy, node.vz],
+                            "size": node.size,
+                            "color": node.color,
+                            "type": node.node_type,
+                            "metadata": node.metadata,
+                            "userData": node.user_data,
+                            "weight": node.weight,
+                            "group": node.group
+                        })
+                    }).collect::<Vec<_>>(),
+                    "edges": graph_data.edges.iter().map(|edge| {
+                        json!({
+                            "source": edge.source,
+                            "target": edge.target,
+                            "weight": edge.weight,
+                            "width": edge.width,
+                            "color": edge.color,
+                            "type": edge.edge_type,
+                            "metadata": edge.metadata,
+                            "userData": edge.user_data,
+                            "directed": edge.directed.unwrap_or(false)
+                        })
+                    }).collect::<Vec<_>>(),
+                    "metadata": &graph_data.metadata
+                })
+            };
+            if let Ok(graph_str) = serde_json::to_string(&graph_update) {
+                ctx_addr.do_send(SendText(graph_str));
             }
 
-            // Send binary position updates to all connected clients
-            if let Ok(nodes) = gpu.get_node_positions().await {
-                let binary_data = positions_to_binary(&nodes);
-
-                if let Ok(sessions) = state.websocket_manager.sessions.lock() {
-                    for session in sessions.iter() {
-                        if session != &ctx_addr {
-                            let _ = session.do_send(SendBinary(binary_data.clone()));
+            let settings_update = ServerMessage::SettingsUpdated {
+                settings: json!({
+                    "visualization": {
+                        "nodeColor": format_color(&settings.visualization.node_color),
+                        "edgeColor": format_color(&settings.visualization.edge_color),
+                        "hologramColor": format_color(&settings.visualization.hologram_color),
+                        "minNodeSize": settings.visualization.min_node_size,
+                        "maxNodeSize": settings.visualization.max_node_size,
+                        "hologramScale": settings.visualization.hologram_scale,
+                        "hologramOpacity": settings.visualization.hologram_opacity,
+                        "edgeOpacity": settings.visualization.edge_opacity,
+                        "fogDensity": settings.visualization.fog_density,
+                        "nodeMaterial": {
+                            "metalness": settings.visualization.node_material_metalness,
+                            "roughness": settings.visualization.node_material_roughness,
+                            "clearcoat": settings.visualization.node_material_clearcoat,
+                            "clearcoatRoughness": settings.visualization.node_material_clearcoat_roughness,
+                            "opacity": settings.visualization.node_material_opacity,
+                            "emissiveMin": settings.visualization.node_emissive_min_intensity,
+                            "emissiveMax": settings.visualization.node_emissive_max_intensity
+                        },
+                        "physics": {
+                            "iterations": settings.visualization.force_directed_iterations,
+                            "spring": settings.visualization.force_directed_spring,
+                            "repulsion": settings.visualization.force_directed_repulsion,
+                            "attraction": settings.visualization.force_directed_attraction,
+                            "damping": settings.visualization.force_directed_damping
+                        },
+                        "bloom": {
+                            "nodeStrength": settings.bloom.node_bloom_strength,
+                            "nodeRadius": settings.bloom.node_bloom_radius,
+                            "nodeThreshold": settings.bloom.node_bloom_threshold,
+                            "edgeStrength": settings.bloom.edge_bloom_strength,
+                            "edgeRadius": settings.bloom.edge_bloom_radius,
+                            "edgeThreshold": settings.bloom.edge_bloom_threshold,
+                            "envStrength": settings.bloom.environment_bloom_strength,
+                            "envRadius": settings.bloom.environment_bloom_radius,
+                            "envThreshold": settings.bloom.environment_bloom_threshold
                         }
+                    },
+                    "fisheye": {
+                        "enabled": settings.fisheye.enabled,
+                        "strength": settings.fisheye.strength,
+                        "radius": settings.fisheye.radius,
+                        "focusPoint": [
+                            settings.fisheye.focus_x,
+                            settings.fisheye.focus_y,
+                            settings.fisheye.focus_z
+                        ]
                     }
-                }
+                })
+            };
+            if let Ok(settings_str) = serde_json::to_string(&settings_update) {
+                ctx_addr.do_send(SendText(settings_str));
             }
-        }
-        .into_actor(self))
-    }
-}
-
-// Handler for text messages
-impl Handler<SendText> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, msg: SendText, ctx: &mut Self::Context) {
-        ctx.text(ByteString::from(msg.0));
-    }
-}
-
-// Handler for binary messages
-impl Handler<SendBinary> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
-        if let Some(gpu_compute) = &self.state.gpu_compute {
-            let gpu = gpu_compute.clone();
-            let bin_data = msg.0.clone();
-            let ctx_addr = ctx.address();
-
-            ctx.spawn(
-                async move {
-                    let gpu_read = gpu.read().await;
-                    let num_nodes = gpu_read.get_num_nodes() as usize;
-                    let expected_size = num_nodes * 24 + 4; // +4 for multiplexed header
-                    drop(gpu_read); // Release the read lock before writing
-
-                    if bin_data.len() != expected_size {
-                        error!("Invalid position data length: expected {}, got {}", 
-                            expected_size, bin_data.len());
-                        let error_message = json!({
-                            "type": "error",
-                            "message": format!("Invalid position data length: expected {}, got {}", 
-                                expected_size, bin_data.len())
-                        });
-                        if let Ok(error_str) = serde_json::to_string(&error_message) {
-                            let msg: SendText = SendText(error_str);
-                            ctx_addr.do_send(msg);
-                        }
-                        return;
-                    }
-
-                    let mut gpu_write = gpu.write().await;
-                    if let Err(e) = gpu_write.update_positions(&bin_data).await {
-                        error!("Failed to update node positions: {}", e);
-                        let error_message = json!({
-                            "type": "error",
-                            "message": format!("Failed to update node positions: {}", e)
-                        });
-                        if let Ok(error_str) = serde_json::to_string(&error_message) {
-                            let msg: SendText = SendText(error_str);
-                            ctx_addr.do_send(msg);
-                        }
-                    } else {
-                        // Convert first byte to f32 for proper comparison
-                        let is_initial = if bin_data.len() >= 4 {
-                            let bytes: [u8; 4] = [bin_data[0], bin_data[1], bin_data[2], bin_data[3]];
-                            let value = f32::from_le_bytes(bytes);
-                            value >= 1.0
-                        } else {
-                            false
-                        };
-
-                        // Send position update completion as JSON
-                        let completion_message = json!({
-                            "type": "position_update_complete",
-                            "status": "success",
-                            "is_initial_layout": is_initial
-                        });
-                        if let Ok(msg_str) = serde_json::to_string(&completion_message) {
-                            let msg: SendText = SendText(msg_str);
-                            ctx_addr.do_send(msg);
-                        }
-                    }
-                }
-                .into_actor(self)
-            );
-        }
-    }
-}
 
-// OpenAI message handlers
-impl Handler<OpenAIMessage> for WebSocketSession {
-    type Result = ();
+            // Send completion
+            let completion = json!({
+                "type": "completion",
+                "message": "Initial data sent"
+            });
+            if let Ok(completion_str) = serde_json::to_string(&completion) {
+                ctx_addr.do_send(SendText(completion_str));
+            }
+        };
 
-    fn handle(&mut self, msg: OpenAIMessage, _ctx: &mut Self::Context) {
-        if let Some(ref ws) = self.openai_ws {
-            ws.do_send(msg);
+        ctx.spawn(fut.into_actor(self));
+        
+        // Set simulation mode to remote and start GPU updates
+        self.simulation_mode = SimulationMode::Remote;
+        if self.state.gpu_compute.is_some() {
+            self.start_gpu_updates(ctx);
         }
     }
-}
 
-impl Handler<OpenAIConnected> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, _: OpenAIConnected, _ctx: &mut Self::Context) {
-        debug!("OpenAI WebSocket connected");
-    }
-}
-
-impl Handler<OpenAIConnectionFailed> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, _: OpenAIConnectionFailed, _ctx: &mut Self::Context) {
-        error!("OpenAI WebSocket connection failed");
-        self.openai_ws = None;
-    }
-}
-
-// Main WebSocket session handler implementation
-impl WebSocketSessionHandler for WebSocketSession {
-    // Start periodic GPU updates at 60fps
     fn start_gpu_updates(&self, ctx: &mut WebsocketContext<WebSocketSession>) {
         let addr = ctx.address();
         ctx.run_interval(GPU_UPDATE_INTERVAL, move |_, _| {
@@ -244,7 +407,6 @@ impl WebSocketSessionHandler for WebSocketSession {
         });
     }
 
-    // Handle chat messages and TTS responses
     fn handle_chat_message(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, message: String, use_openai: bool) {
         let state = self.state.clone();
         let conversation_id = self.conversation_id.clone();
@@ -266,7 +428,7 @@ impl WebSocketSessionHandler for WebSocketSession {
                     }
                 }
             } else {
-                error!("No conversation ID available");
+                error!("Failed to acquire conversation ID");
                 return;
             };
 
@@ -299,10 +461,10 @@ impl WebSocketSessionHandler for WebSocketSession {
                                     debug!("Using local TTS service");
                                     if let Err(e) = state.speech_service.send_message(text).await {
                                         error!("Failed to generate speech: {}", e);
-                                        let error_message = json!({
-                                            "type": "error",
-                                            "message": format!("Failed to generate speech: {}", e)
-                                        });
+                                        let error_message = ServerMessage::Error {
+                                            message: format!("Failed to generate speech: {}", e),
+                                            code: Some("SPEECH_GENERATION_ERROR".to_string())
+                                        };
                                         if let Ok(error_str) = serde_json::to_string(&error_message) {
                                             ctx_addr.do_send(SendText(error_str));
                                         }
@@ -311,10 +473,10 @@ impl WebSocketSessionHandler for WebSocketSession {
                             },
                             Err(e) => {
                                 error!("Error processing RAGFlow response: {}", e);
-                                let error_message = json!({
-                                    "type": "error",
-                                    "message": format!("Error processing RAGFlow response: {}", e)
-                                });
+                                let error_message = ServerMessage::Error {
+                                    message: format!("Error processing RAGFlow response: {}", e),
+                                    code: Some("RAGFLOW_PROCESSING_ERROR".to_string())
+                                };
                                 if let Ok(error_str) = serde_json::to_string(&error_message) {
                                     ctx_addr.do_send(SendText(error_str));
                                 }
@@ -324,10 +486,10 @@ impl WebSocketSessionHandler for WebSocketSession {
                 },
                 Err(e) => {
                     error!("Failed to send message to RAGFlow: {}", e);
-                    let error_message = json!({
-                        "type": "error",
-                        "message": format!("Failed to send message to RAGFlow: {}", e)
-                    });
+                    let error_message = ServerMessage::Error {
+                        message: format!("Failed to send message to RAGFlow: {}", e),
+                        code: Some("RAGFLOW_SEND_ERROR".to_string())
+                    };
                     if let Ok(error_str) = serde_json::to_string(&error_message) {
                         ctx_addr.do_send(SendText(error_str));
                     }
@@ -349,7 +511,6 @@ impl WebSocketSessionHandler for WebSocketSession {
         ctx.spawn(fut.into_actor(self));
     }
 
-    // Handle simulation mode changes
     fn handle_simulation_mode(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, mode: &str) {
         self.simulation_mode = match mode {
             "remote" => {
@@ -374,15 +535,15 @@ impl WebSocketSessionHandler for WebSocketSession {
             }
         };
 
-        let response = json!({
-            "type": "simulation_mode_set",
-            "mode": mode,
-            "gpu_enabled": matches!(self.simulation_mode, SimulationMode::Remote | SimulationMode::GPU)
-        });
-        <Self as MessageHandler>::send_json_response(self, response, ctx);
+        let response = ServerMessage::SimulationModeSet {
+            mode: mode.to_string(),
+            gpu_enabled: matches!(self.simulation_mode, SimulationMode::Remote | SimulationMode::GPU)
+        };
+        if let Ok(response_str) = serde_json::to_string(&response) {
+            ctx.text(ByteString::from(response_str));
+        }
     }
 
-    // Handle layout parameter updates and GPU computation
     fn handle_layout(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, params: SimulationParams) {
         let state = self.state.clone();
         let ctx_addr = ctx.address();
@@ -394,10 +555,10 @@ impl WebSocketSessionHandler for WebSocketSession {
                 
                 if let Err(e) = gpu.update_simulation_params(&params) {
                     error!("Failed to update simulation parameters: {}", e);
-                    let error_message = json!({
-                        "type": "error",
-                        "message": format!("Failed to update simulation parameters: {}", e)
-                    });
+                    let error_message = ServerMessage::Error {
+                        message: format!("Failed to update simulation parameters: {}", e),
+                        code: Some("SIMULATION_PARAMS_ERROR".to_string())
+                    };
                     if let Ok(error_str) = serde_json::to_string(&error_message) {
                         ctx_addr.do_send(SendText(error_str));
                     }
@@ -408,10 +569,10 @@ impl WebSocketSessionHandler for WebSocketSession {
                 for _ in 0..params.iterations {
                     if let Err(e) = gpu.step() {
                         error!("GPU compute step failed: {}", e);
-                        let error_message = json!({
-                            "type": "error",
-                            "message": format!("GPU compute step failed: {}", e)
-                        });
+                        let error_message = ServerMessage::Error {
+                            message: format!("GPU compute step failed: {}", e),
+                            code: Some("GPU_COMPUTE_ERROR".to_string())
+                        };
                         if let Ok(error_str) = serde_json::to_string(&error_message) {
                             ctx_addr.do_send(SendText(error_str));
                         }
@@ -427,10 +588,10 @@ impl WebSocketSessionHandler for WebSocketSession {
                     },
                     Err(e) => {
                         error!("Failed to get GPU node positions: {}", e);
-                        let error_message = json!({
-                            "type": "error",
-                            "message": format!("Failed to get GPU node positions: {}", e)
-                        });
+                        let error_message = ServerMessage::Error {
+                            message: format!("Failed to get GPU node positions: {}", e),
+                            code: Some("GPU_POSITION_ERROR".to_string())
+                        };
                         if let Ok(error_str) = serde_json::to_string(&error_message) {
                             ctx_addr.do_send(SendText(error_str));
                         }
@@ -438,10 +599,10 @@ impl WebSocketSessionHandler for WebSocketSession {
                 }
             } else {
                 error!("GPU compute service not available");
-                let error_message = json!({
-                    "type": "error",
-                    "message": "GPU compute service not available"
-                });
+                let error_message = ServerMessage::Error {
+                    message: "GPU compute service not available".to_string(),
+                    code: Some("GPU_SERVICE_ERROR".to_string())
+                };
                 if let Ok(error_str) = serde_json::to_string(&error_message) {
                     ctx_addr.do_send(SendText(error_str));
                 }
@@ -462,147 +623,132 @@ impl WebSocketSessionHandler for WebSocketSession {
         ctx.spawn(fut.into_actor(self));
     }
 
-    // Handle initial data request - sends full graph data and settings
-    fn handle_initial_data(&mut self, ctx: &mut WebsocketContext<WebSocketSession>) {
-        let state = self.state.clone();
-        let ctx_addr = ctx.address();
-        let weak_addr = ctx.address().downgrade();
-
-        let fut = async move {
-            let graph_data = state.graph_data.read().await;
-            let settings = state.settings.read().await;
-            
-            // Helper function to send a simple JSON message
-            let send_settings = |msg_type: &str, fields: Vec<(&str, serde_json::Value)>| {
-                let mut map = serde_json::Map::new();
-                map.insert("type".to_string(), serde_json::Value::String(msg_type.to_string()));
-                for (key, value) in fields {
-                    map.insert(key.to_string(), value);
-                }
-                if let Ok(response_str) = serde_json::to_string(&serde_json::Value::Object(map)) {
-                    ctx_addr.do_send(SendText(response_str));
-                }
-            };
-
-            // Send graph data
-            send_settings("graphData", vec![
-                ("nodes", serde_json::to_value(&graph_data.nodes).unwrap_or_default()),
-                ("edges", serde_json::to_value(&graph_data.edges).unwrap_or_default())
-            ]);
-
-            // Send basic visualization settings
-            send_settings("visualSettings", vec![
-                ("nodeColor", serde_json::Value::String(format_color(&settings.visualization.node_color))),
-                ("edgeColor", serde_json::Value::String(format_color(&settings.visualization.edge_color))),
-                ("hologramColor", serde_json::Value::String(format_color(&settings.visualization.hologram_color))),
-                ("minNodeSize", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.min_node_size as f64).unwrap())),
-                ("maxNodeSize", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.max_node_size as f64).unwrap())),
-                ("hologramScale", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.hologram_scale as f64).unwrap())),
-                ("hologramOpacity", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.hologram_opacity as f64).unwrap())),
-                ("edgeOpacity", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.edge_opacity as f64).unwrap())),
-                ("fogDensity", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.fog_density as f64).unwrap()))
-            ]);
-
-            // Send material settings
-            send_settings("materialSettings", vec![
-                ("metalness", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.node_material_metalness as f64).unwrap())),
-                ("roughness", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.node_material_roughness as f64).unwrap())),
-                ("clearcoat", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.node_material_clearcoat as f64).unwrap())),
-                ("clearcoatRoughness", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.node_material_clearcoat_roughness as f64).unwrap())),
-                ("opacity", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.node_material_opacity as f64).unwrap())),
-                ("emissiveMin", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.node_emissive_min_intensity as f64).unwrap())),
-                ("emissiveMax", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.node_emissive_max_intensity as f64).unwrap()))
-            ]);
-
-            // Send physics settings
-            send_settings("physicsSettings", vec![
-                ("iterations", serde_json::Value::Number(serde_json::Number::from(settings.visualization.force_directed_iterations))),
-                ("spring", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.force_directed_spring as f64).unwrap())),
-                ("repulsion", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.force_directed_repulsion as f64).unwrap())),
-                ("attraction", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.force_directed_attraction as f64).unwrap())),
-                ("damping", serde_json::Value::Number(serde_json::Number::from_f64(settings.visualization.force_directed_damping as f64).unwrap()))
-            ]);
-
-            // Send bloom settings
-            send_settings("bloomSettings", vec![
-                ("nodeStrength", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.node_bloom_strength as f64).unwrap())),
-                ("nodeRadius", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.node_bloom_radius as f64).unwrap())),
-                ("nodeThreshold", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.node_bloom_threshold as f64).unwrap())),
-                ("edgeStrength", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.edge_bloom_strength as f64).unwrap())),
-                ("edgeRadius", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.edge_bloom_radius as f64).unwrap())),
-                ("edgeThreshold", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.edge_bloom_threshold as f64).unwrap())),
-                ("envStrength", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.environment_bloom_strength as f64).unwrap())),
-                ("envRadius", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.environment_bloom_radius as f64).unwrap())),
-                ("envThreshold", serde_json::Value::Number(serde_json::Number::from_f64(settings.bloom.environment_bloom_threshold as f64).unwrap()))
-            ]);
-
-            // Send fisheye settings
-            send_settings("fisheyeSettings", vec![
-                ("enabled", serde_json::Value::Bool(settings.fisheye.enabled)),
-                ("strength", serde_json::Value::Number(serde_json::Number::from_f64(settings.fisheye.strength as f64).unwrap())),
-                ("radius", serde_json::Value::Number(serde_json::Number::from_f64(settings.fisheye.radius as f64).unwrap())),
-                ("focusX", serde_json::Value::Number(serde_json::Number::from_f64(settings.fisheye.focus_x as f64).unwrap())),
-                ("focusY", serde_json::Value::Number(serde_json::Number::from_f64(settings.fisheye.focus_y as f64).unwrap())),
-                ("focusZ", serde_json::Value::Number(serde_json::Number::from_f64(settings.fisheye.focus_z as f64).unwrap()))
-            ]);
-
-            // Send completion
-            if let Some(addr) = weak_addr.upgrade() {
-                send_settings("completion", vec![
-                    ("message", serde_json::Value::String("Initial data sent".to_string()))
-                ]);
-            }
-        };
-
-        ctx.spawn(fut.into_actor(self));
-    }
-
     fn handle_fisheye_settings(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, enabled: bool, strength: f32, focus_point: [f32; 3], radius: f32) {
         let state = self.state.clone();
         let ctx_addr = ctx.address();
-        let weak_addr = ctx.address().downgrade();
 
         let fut = async move {
             if let Some(gpu_compute) = &state.gpu_compute {
                 let mut gpu = gpu_compute.write().await;
                 gpu.update_fisheye_params(enabled, strength, focus_point, radius);
                 
-                // Send updated fisheye settings
-                let response = json!({
-                    "type": "fisheye_settings_updated",
-                    "enabled": enabled,
-                    "strength": strength,
-                    "focusX": focus_point[0],
-                    "focusY": focus_point[1],
-                    "focusZ": focus_point[2],
-                    "radius": radius
-                });
+                // Send updated fisheye settings using ServerMessage enum
+                let response = ServerMessage::FisheyeSettingsUpdated {
+                    enabled,
+                    strength,
+                    focus_point,
+                    radius,
+                };
                 if let Ok(response_str) = serde_json::to_string(&response) {
                     ctx_addr.do_send(SendText(response_str));
                 }
             } else {
                 error!("GPU compute service not available");
-                let error_message = json!({
-                    "type": "error",
-                    "message": "GPU compute service not available"
-                });
+                let error_message = ServerMessage::Error {
+                    message: "GPU compute service not available".to_string(),
+                    code: Some("GPU_SERVICE_ERROR".to_string())
+                };
                 if let Ok(error_str) = serde_json::to_string(&error_message) {
                     ctx_addr.do_send(SendText(error_str));
                 }
             }
 
             // Send completion
-            if let Some(addr) = weak_addr.upgrade() {
-                let completion = json!({
-                    "type": "completion",
-                    "message": "Fisheye settings updated"
-                });
-                if let Ok(completion_str) = serde_json::to_string(&completion) {
-                    addr.do_send(SendText(completion_str));
-                }
+            let completion = json!({
+                "type": "completion",
+                "message": "Fisheye settings updated"
+            });
+            if let Ok(completion_str) = serde_json::to_string(&completion) {
+                ctx_addr.do_send(SendText(completion_str));
             }
         };
 
         ctx.spawn(fut.into_actor(self));
     }
 }
+
+impl Handler<GpuUpdate> for WebSocketSession {
+    type Result = ResponseActFuture<Self, ()>;
+
+    fn handle(&mut self, _: GpuUpdate, _ctx: &mut Self::Context) -> Self::Result {
+        let state = self.state.clone();
+        let gpu_compute = if let Some(gpu) = &state.gpu_compute {
+            gpu.clone()
+        } else {
+            return Box::pin(futures::future::ready(()).into_actor(self));
+        };
+
+        Box::pin(async move {
+            let mut gpu = gpu_compute.write().await;
+            if let Err(e) = gpu.step() {
+                error!("GPU compute step failed: {}", e);
+                return;
+            }
+
+            match gpu.get_node_positions().await {
+                Ok(nodes) => {
+                    if nodes.is_empty() {
+                        warn!("No nodes returned from GPU compute");
+                        return;
+                    }
+
+                    // Log first node position for debugging
+                    debug!(
+                        "First node position: x={}, y={}, z={}",
+                        nodes[0].x, nodes[0].y, nodes[0].z
+                    );
+
+                    // Let WebSocketManager handle the broadcasting
+                    state.websocket_manager.broadcast_binary(&nodes, false).await;
+                },
+                Err(e) => {
+                    error!("Failed to get node positions: {}", e);
+                }
+            }
+        }
+        .into_actor(self))
+    }
+}
+
+impl Handler<SendText> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, msg: SendText, ctx: &mut Self::Context) {
+        ctx.text(ByteString::from(msg.0));
+    }
+}
+
+impl Handler<SendBinary> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
+        ctx.binary(msg.0);
+    }
+}
+
+impl Handler<OpenAIMessage> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, msg: OpenAIMessage, _ctx: &mut Self::Context) {
+        if let Some(ref ws) = self.openai_ws {
+            ws.do_send(msg);
+        }
+    }
+}
+
+impl Handler<OpenAIConnected> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, _: OpenAIConnected, _ctx: &mut Self::Context) {
+        debug!("OpenAI WebSocket connected");
+    }
+}
+
+impl Handler<OpenAIConnectionFailed> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, _: OpenAIConnectionFailed, _ctx: &mut Self::Context) {
+        error!("OpenAI WebSocket connection failed");
+        self.openai_ws = None;
+    }
+}
diff --git a/main.rs b/main.rs
index 517dce2a..42acd1f5 100755
--- a/main.rs
+++ b/main.rs
@@ -69,9 +69,9 @@ async fn initialize_cached_graph_data(app_state: &web::Data<AppState>) -> std::i
 }
 
 /// Periodic graph update function
-/// Checks for GitHub updates every 5 minutes while preserving node positions
+/// Checks for GitHub updates every 12 hours while preserving node positions
 async fn update_graph_periodically(app_state: web::Data<AppState>) {
-    let mut interval = interval(Duration::from_secs(300)); // 5 minute interval
+    let mut interval = interval(Duration::from_secs(43200)); // 12 hour interval
 
     loop {
         interval.tick().await;
@@ -119,10 +119,11 @@ async fn update_graph_periodically(app_state: web::Data<AppState>) {
                                 node.z = z;
                             }
                         }
-                        *graph = new_graph;
-                        
+                        *graph = new_graph.clone();
+                        drop(graph); // Release the write lock before broadcasting
+
                         // Notify clients of the update
-                        if let Err(e) = app_state.websocket_manager.broadcast_graph_update(&graph).await {
+                        if let Err(e) = app_state.websocket_manager.broadcast_graph_update(&new_graph).await {
                             log::error!("Failed to broadcast graph update: {}", e);
                         }
                     }
@@ -289,13 +290,6 @@ async fn main() -> std::io::Result<()> {
         log::warn!("Failed to initialize from cache: {:?}, proceeding with empty graph", e);
     }
 
-    // Initialize WebSocket manager
-    log::info!("Initializing WebSocket manager...");
-    if let Err(e) = websocket_manager.initialize(&ragflow_service).await {
-        log::error!("Failed to initialize WebSocket manager: {:?}", e);
-        return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize WebSocket manager: {:?}", e)));
-    }
-
     // Start periodic update task
     let update_state = app_state.clone();
     tokio::spawn(async move {
diff --git a/models/edge.rs b/models/edge.rs
index 2e33161c..658ee125 100755
--- a/models/edge.rs
+++ b/models/edge.rs
@@ -5,9 +5,15 @@ use crate::models::node::Node;
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct Edge {
     pub source: String,
-    #[serde(rename = "target_node")]  // Rename for JSON serialization to match client expectations
     pub target: String,
     pub weight: f32,
+    pub width: Option<f32>,
+    pub color: Option<String>,
+    #[serde(rename = "type")]
+    pub edge_type: Option<String>,
+    pub metadata: Option<HashMap<String, String>>,
+    pub user_data: Option<HashMap<String, String>>,
+    pub directed: Option<bool>,
 }
 
 // GPU representation of an edge, must match the shader's Edge struct
@@ -30,6 +36,12 @@ impl Edge {
             source,
             target,
             weight,
+            width: None,
+            color: None,
+            edge_type: None,
+            metadata: None,
+            user_data: None,
+            directed: Some(false),
         }
     }
 
diff --git a/models/node.rs b/models/node.rs
index 74e2815f..5cd29eed 100755
--- a/models/node.rs
+++ b/models/node.rs
@@ -19,6 +19,13 @@ pub struct Node {
     pub vz: f32,
     #[serde(skip)]
     pub file_size: u64, // Used to calculate mass
+    #[serde(rename = "type")]
+    pub node_type: Option<String>,
+    pub size: Option<f32>,
+    pub color: Option<String>,
+    pub weight: Option<f32>,
+    pub group: Option<String>,
+    pub user_data: Option<HashMap<String, String>>,
 }
 
 impl Node {
@@ -34,9 +41,23 @@ impl Node {
             vy: 0.0,
             vz: 0.0,
             file_size: 0,
+            node_type: None,
+            size: None,
+            color: None,
+            weight: None,
+            group: None,
+            user_data: None,
         }
     }
 
+    pub fn position(&self) -> [f32; 3] {
+        [self.x, self.y, self.z]
+    }
+
+    pub fn velocity(&self) -> [f32; 3] {
+        [self.vx, self.vy, self.vz]
+    }
+
     /// Convert file size to quantized mass value (0-255)
     fn calculate_mass(&self) -> u8 {
         // Scale file size logarithmically to 0-255 range
@@ -107,6 +128,12 @@ impl Default for Node {
             vy: 0.0,
             vz: 0.0,
             file_size: 0,
+            node_type: None,
+            size: None,
+            color: None,
+            weight: None,
+            group: None,
+            user_data: None,
         }
     }
 }
diff --git a/models/position_update.rs b/models/position_update.rs
index 17d43ee0..ffe7d4a7 100755
--- a/models/position_update.rs
+++ b/models/position_update.rs
@@ -1,10 +1,9 @@
-use serde::{Serialize, Deserialize};
 use std::collections::HashMap;
+use serde::{Serialize, Deserialize};
 use bytemuck::{Pod, Zeroable};
 
-/// Represents a position and velocity update for a node (24 bytes)
-#[repr(C)]
 #[derive(Debug, Clone, Copy, Pod, Zeroable, Serialize, Deserialize)]
+#[repr(C)]
 pub struct NodePositionVelocity {
     pub x: f32,
     pub y: f32,
@@ -15,114 +14,93 @@ pub struct NodePositionVelocity {
 }
 
 /// Represents a batch of position updates for multiple nodes
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Clone)]
 pub struct PositionUpdate {
     /// Maps node indices to their new positions and velocities
     pub updates: HashMap<usize, NodePositionVelocity>,
-    /// Optional timestamp for synchronization
-    pub timestamp: Option<u64>,
     /// Whether this is an initial layout update
     pub is_initial_layout: bool,
 }
 
 impl PositionUpdate {
-    pub fn new() -> Self {
+    pub fn new(is_initial_layout: bool) -> Self {
         Self {
             updates: HashMap::new(),
-            timestamp: Some(std::time::SystemTime::now()
-                .duration_since(std::time::UNIX_EPOCH)
-                .unwrap()
-                .as_millis() as u64),
-            is_initial_layout: false,
+            is_initial_layout,
         }
     }
 
-    /// Adds a position and velocity update for a node
     pub fn add_update(&mut self, index: usize, x: f32, y: f32, z: f32, vx: f32, vy: f32, vz: f32) {
         self.updates.insert(index, NodePositionVelocity { x, y, z, vx, vy, vz });
     }
 
-    /// Creates a binary representation for network transfer
-    pub fn to_binary(&self) -> Vec<u8> {
-        let mut binary = Vec::with_capacity(4 + self.updates.len() * 24);
-        
-        // Write header (4 bytes)
-        let header_value = if self.is_initial_layout { 1.0f32 } else { 0.0f32 };
-        binary.extend_from_slice(&header_value.to_le_bytes());
-
-        // Write position updates (24 bytes each)
-        let mut updates: Vec<_> = self.updates.iter().collect();
-        updates.sort_by_key(|&(k, _)| k); // Sort by index for consistent order
-        
-        for (_, update) in updates {
-            binary.extend_from_slice(&update.x.to_le_bytes());
-            binary.extend_from_slice(&update.y.to_le_bytes());
-            binary.extend_from_slice(&update.z.to_le_bytes());
-            binary.extend_from_slice(&update.vx.to_le_bytes());
-            binary.extend_from_slice(&update.vy.to_le_bytes());
-            binary.extend_from_slice(&update.vz.to_le_bytes());
-        }
-
-        binary
-    }
-
-    /// Creates a position update from binary data
     pub fn from_binary(data: &[u8], num_nodes: usize) -> Result<Self, String> {
         if data.len() != 4 + num_nodes * 24 {
             return Err(format!("Invalid data length: expected {}, got {}", 
                 4 + num_nodes * 24, data.len()));
         }
 
-        // Read header
-        let mut header_bytes = [0u8; 4];
-        header_bytes.copy_from_slice(&data[0..4]);
-        let header_value = f32::from_le_bytes(header_bytes);
-        let is_initial_layout = header_value >= 1.0;
+        // Read is_initial_layout flag
+        let mut flag_bytes = [0u8; 4];
+        flag_bytes.copy_from_slice(&data[0..4]);
+        let is_initial_layout = f32::from_le_bytes(flag_bytes) >= 1.0;
 
         let mut updates = HashMap::with_capacity(num_nodes);
 
         // Read position updates
         for i in 0..num_nodes {
             let offset = 4 + i * 24;
-            let mut pos = [0u8; 24];
-            pos.copy_from_slice(&data[offset..offset + 24]);
+            
+            let mut x_bytes = [0u8; 4];
+            let mut y_bytes = [0u8; 4];
+            let mut z_bytes = [0u8; 4];
+            let mut vx_bytes = [0u8; 4];
+            let mut vy_bytes = [0u8; 4];
+            let mut vz_bytes = [0u8; 4];
+
+            x_bytes.copy_from_slice(&data[offset..offset + 4]);
+            y_bytes.copy_from_slice(&data[offset + 4..offset + 8]);
+            z_bytes.copy_from_slice(&data[offset + 8..offset + 12]);
+            vx_bytes.copy_from_slice(&data[offset + 12..offset + 16]);
+            vy_bytes.copy_from_slice(&data[offset + 16..offset + 20]);
+            vz_bytes.copy_from_slice(&data[offset + 20..offset + 24]);
 
-            let x = f32::from_le_bytes(pos[0..4].try_into().unwrap());
-            let y = f32::from_le_bytes(pos[4..8].try_into().unwrap());
-            let z = f32::from_le_bytes(pos[8..12].try_into().unwrap());
-            let vx = f32::from_le_bytes(pos[12..16].try_into().unwrap());
-            let vy = f32::from_le_bytes(pos[16..20].try_into().unwrap());
-            let vz = f32::from_le_bytes(pos[20..24].try_into().unwrap());
+            let x = f32::from_le_bytes(x_bytes);
+            let y = f32::from_le_bytes(y_bytes);
+            let z = f32::from_le_bytes(z_bytes);
+            let vx = f32::from_le_bytes(vx_bytes);
+            let vy = f32::from_le_bytes(vy_bytes);
+            let vz = f32::from_le_bytes(vz_bytes);
 
             updates.insert(i, NodePositionVelocity { x, y, z, vx, vy, vz });
         }
 
         Ok(Self {
             updates,
-            timestamp: Some(std::time::SystemTime::now()
-                .duration_since(std::time::UNIX_EPOCH)
-                .unwrap()
-                .as_millis() as u64),
             is_initial_layout,
         })
     }
-}
 
-/// Message types for WebSocket communication
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub enum GraphMessage {
-    /// Complete graph initialization
-    InitialGraph {
-        nodes: Vec<String>,  // Node IDs only
-        edges: Vec<(String, String, f32)>,  // (source, target, weight)
-        metadata: serde_json::Value,
-    },
-    /// Position updates only
-    PositionUpdate(PositionUpdate),
-    /// Parameter updates
-    ParameterUpdate {
-        spring_strength: Option<f32>,
-        damping: Option<f32>,
-        iterations: Option<u32>,
-    },
+    pub fn to_binary(&self) -> Vec<u8> {
+        let mut binary = Vec::with_capacity(4 + self.updates.len() * 24);
+
+        // Write is_initial_layout flag
+        binary.extend_from_slice(&(if self.is_initial_layout { 1.0f32 } else { 0.0f32 }).to_le_bytes());
+
+        // Sort updates by index to ensure consistent order
+        let mut updates: Vec<_> = self.updates.iter().collect();
+        updates.sort_by_key(|&(k, _)| k);
+
+        // Write position updates
+        for (_, update) in updates {
+            binary.extend_from_slice(&update.x.to_le_bytes());
+            binary.extend_from_slice(&update.y.to_le_bytes());
+            binary.extend_from_slice(&update.z.to_le_bytes());
+            binary.extend_from_slice(&update.vx.to_le_bytes());
+            binary.extend_from_slice(&update.vy.to_le_bytes());
+            binary.extend_from_slice(&update.vz.to_le_bytes());
+        }
+
+        binary
+    }
 }
diff --git a/models/simulation_params.rs b/models/simulation_params.rs
index f430edc3..6c8e6ec3 100755
--- a/models/simulation_params.rs
+++ b/models/simulation_params.rs
@@ -20,10 +20,10 @@ pub enum SimulationPhase {
 #[repr(C)]
 pub struct SimulationParams {
     pub iterations: u32,           // Range: 1-500, Default: varies by phase
-    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.01
-    pub repulsion_strength: f32,   // Range: 1.0-10000.0, Default: 1000.0
-    pub attraction_strength: f32,  // Range: 0.001-1.0, Default: 0.01
-    pub damping: f32,             // Range: 0.5-0.95, Default: 0.8
+    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.015
+    pub repulsion_strength: f32,   // Range: 1.0-10000.0, Default: 1200.0
+    pub attraction_strength: f32,  // Range: 0.001-1.0, Default: 0.012
+    pub damping: f32,             // Range: 0.5-0.95, Default: 0.85
     pub is_initial_layout: bool,   // true for initial layout, false for interactive
     pub time_step: f32,           // Animation time step (0.1-1.0)
     pub padding: u32,             // Complete 32-byte alignment
@@ -32,11 +32,11 @@ pub struct SimulationParams {
 impl Default for SimulationParams {
     fn default() -> Self {
         Self {
-            iterations: 5,
-            spring_strength: 0.01,
-            repulsion_strength: 1000.0,
-            attraction_strength: 0.01,
-            damping: 0.8,
+            iterations: 5,                // Default for interactive mode
+            spring_strength: 0.015,       // Increased from 0.01 to match settings.toml
+            repulsion_strength: 1200.0,   // Increased from 1000.0 to match settings.toml
+            attraction_strength: 0.012,   // Increased from 0.01 to match settings.toml
+            damping: 0.85,               // Increased from 0.8 to match settings.toml
             is_initial_layout: false,
             time_step: 0.5,
             padding: 0,
@@ -65,7 +65,7 @@ impl SimulationParams {
             attraction_strength: attraction_strength.clamp(0.001, 1.0),
             damping: damping.clamp(0.5, 0.95),
             is_initial_layout: is_initial,
-            time_step: 0.5,
+            time_step: if is_initial { 0.8 } else { 0.5 }, // Faster initial layout
             padding: 0,
         }
     }
@@ -74,7 +74,11 @@ impl SimulationParams {
     pub fn from_config(config: &crate::config::VisualizationSettings, phase: SimulationPhase) -> Self {
         let is_initial = matches!(phase, SimulationPhase::Initial);
         Self::new(
-            if is_initial { config.force_directed_iterations } else { 5 },
+            if is_initial { 
+                config.force_directed_iterations.max(300) // Ensure enough iterations for initial layout
+            } else { 
+                5 
+            },
             config.force_directed_spring,
             config.force_directed_repulsion,
             config.force_directed_attraction,
@@ -122,6 +126,19 @@ impl SimulationParams {
         self.time_step = time_step.clamp(0.1, 1.0);
         self
     }
+
+    /// Returns true if the parameters are suitable for initial layout
+    pub fn is_initial_phase(&self) -> bool {
+        self.is_initial_layout && self.iterations >= 200
+    }
+
+    /// Returns true if the parameters need adjustment for stability
+    pub fn needs_stability_adjustment(&self) -> bool {
+        self.spring_strength > 0.5 || 
+        self.repulsion_strength > 5000.0 || 
+        self.attraction_strength > 0.5 ||
+        self.damping < 0.7
+    }
 }
 
 // Manual implementations for required GPU traits
@@ -142,10 +159,10 @@ mod tests {
     fn test_simulation_params_default() {
         let params = SimulationParams::default();
         assert_eq!(params.iterations, 5);
-        assert_eq!(params.spring_strength, 0.01);
-        assert_eq!(params.repulsion_strength, 1000.0);
-        assert_eq!(params.attraction_strength, 0.01);
-        assert_eq!(params.damping, 0.8);
+        assert_eq!(params.spring_strength, 0.015);
+        assert_eq!(params.repulsion_strength, 1200.0);
+        assert_eq!(params.attraction_strength, 0.012);
+        assert_eq!(params.damping, 0.85);
         assert!(!params.is_initial_layout);
     }
 
@@ -185,4 +202,22 @@ mod tests {
         assert_eq!(params.damping, 0.7);
         assert_eq!(params.time_step, 0.8);
     }
+
+    #[test]
+    fn test_initial_phase_detection() {
+        let initial_params = SimulationParams::new(300, 0.1, 1000.0, 0.1, 0.8, true);
+        assert!(initial_params.is_initial_phase());
+
+        let interactive_params = SimulationParams::default();
+        assert!(!interactive_params.is_initial_phase());
+    }
+
+    #[test]
+    fn test_stability_detection() {
+        let unstable_params = SimulationParams::new(300, 0.6, 6000.0, 0.6, 0.6, true);
+        assert!(unstable_params.needs_stability_adjustment());
+
+        let stable_params = SimulationParams::default();
+        assert!(!stable_params.needs_stability_adjustment());
+    }
 }
diff --git a/services/file_service.rs b/services/file_service.rs
index 0c6fffac..d5528635 100755
--- a/services/file_service.rs
+++ b/services/file_service.rs
@@ -1,4 +1,5 @@
 use crate::models::metadata::Metadata;
+use crate::models::graph::GraphData;
 use crate::config::Settings;
 use serde::{Deserialize, Serialize};
 use reqwest::Client;
@@ -15,6 +16,7 @@ use tokio::sync::RwLock;
 use std::error::Error as StdError;
 use std::time::Duration;
 use tokio::time::sleep;
+use actix_web::web;
 
 // Constants
 const METADATA_PATH: &str = "data/markdown/metadata.json";
@@ -210,6 +212,97 @@ impl GitHubService for RealGitHubService {
 pub struct FileService;
 
 impl FileService {
+    /// Process uploaded file and return graph data
+    pub async fn process_file_upload(&self, payload: web::Bytes) -> Result<GraphData, Box<dyn StdError + Send + Sync>> {
+        let content = String::from_utf8(payload.to_vec())?;
+        let metadata = Self::load_or_create_metadata()?;
+        let mut graph_data = GraphData::new();
+        
+        // Create a temporary file to process
+        let temp_filename = format!("temp_{}.md", Utc::now().timestamp());
+        let temp_path = format!("{}/{}", MARKDOWN_DIR, temp_filename);
+        fs::write(&temp_path, &content)?;
+
+        // Extract references and create metadata
+        let valid_nodes: Vec<String> = metadata.keys()
+            .map(|name| name.trim_end_matches(".md").to_string())
+            .collect();
+
+        let references = Self::extract_references(&content, &valid_nodes);
+        let topic_counts = Self::convert_references_to_topic_counts(references);
+
+        // Create metadata for the uploaded file
+        let file_size = content.len();
+        let node_size = Self::calculate_node_size(file_size);
+        let file_metadata = Metadata {
+            file_name: temp_filename.clone(),
+            file_size,
+            node_size,
+            hyperlink_count: Self::count_hyperlinks(&content),
+            sha1: Self::calculate_sha1(&content),
+            last_modified: Utc::now(),
+            perplexity_link: String::new(),
+            last_perplexity_process: None,
+            topic_counts,
+        };
+
+        // Update graph data
+        graph_data.metadata.insert(temp_filename, file_metadata);
+
+        // Clean up temporary file
+        if let Err(e) = fs::remove_file(&temp_path) {
+            error!("Failed to remove temporary file: {}", e);
+        }
+
+        Ok(graph_data)
+    }
+
+    /// List available files
+    pub async fn list_files(&self) -> Result<Vec<String>, Box<dyn StdError + Send + Sync>> {
+        let metadata = Self::load_or_create_metadata()?;
+        Ok(metadata.keys().cloned().collect())
+    }
+
+    /// Load a specific file and return graph data
+    pub async fn load_file(&self, filename: &str) -> Result<GraphData, Box<dyn StdError + Send + Sync>> {
+        let file_path = format!("{}/{}", MARKDOWN_DIR, filename);
+        if !Path::new(&file_path).exists() {
+            return Err(format!("File not found: {}", filename).into());
+        }
+
+        let content = fs::read_to_string(&file_path)?;
+        let metadata = Self::load_or_create_metadata()?;
+        let mut graph_data = GraphData::new();
+
+        // Extract references and update metadata
+        let valid_nodes: Vec<String> = metadata.keys()
+            .map(|name| name.trim_end_matches(".md").to_string())
+            .collect();
+
+        let references = Self::extract_references(&content, &valid_nodes);
+        let topic_counts = Self::convert_references_to_topic_counts(references);
+
+        // Update or create metadata for the file
+        let file_size = content.len();
+        let node_size = Self::calculate_node_size(file_size);
+        let file_metadata = Metadata {
+            file_name: filename.to_string(),
+            file_size,
+            node_size,
+            hyperlink_count: Self::count_hyperlinks(&content),
+            sha1: Self::calculate_sha1(&content),
+            last_modified: Utc::now(),
+            perplexity_link: String::new(),
+            last_perplexity_process: None,
+            topic_counts,
+        };
+
+        // Update graph data
+        graph_data.metadata.insert(filename.to_string(), file_metadata);
+        
+        Ok(graph_data)
+    }
+
     /// Load metadata from file or create new if not exists
     pub fn load_or_create_metadata() -> Result<HashMap<String, Metadata>, Box<dyn StdError + Send + Sync>> {
         if Path::new(METADATA_PATH).exists() {
diff --git a/services/speech_service.rs b/services/speech_service.rs
index c9a4a51f..8fbe5cba 100755
--- a/services/speech_service.rs
+++ b/services/speech_service.rs
@@ -161,7 +161,7 @@ impl SpeechService {
                                                                 for item in content {
                                                                     if item["type"] == "audio" {
                                                                         if let Some(audio_data) = item["audio"].as_str() {
-                                                                            // Decode base64 audio data using the new API
+                                                                            // Decode base64 audio data
                                                                             if let Ok(audio_bytes) = BASE64.decode(audio_data) {
                                                                                 // Create a JSON wrapper for the binary data
                                                                                 let audio_message = json!({
diff --git a/utils/force_calculation.wgsl b/utils/force_calculation.wgsl
index 3bae2d6a..afbd010e 100755
--- a/utils/force_calculation.wgsl
+++ b/utils/force_calculation.wgsl
@@ -36,13 +36,31 @@ struct SimulationParams {
 @group(0) @binding(1) var<storage, read> edges_buffer: EdgesBuffer;
 @group(0) @binding(2) var<uniform> params: SimulationParams;
 
-// Physics constants
+// Physics constants - aligned with settings.toml
 const WORKGROUP_SIZE: u32 = 256;
-const MAX_FORCE: f32 = 50.0;
-const MIN_DISTANCE: f32 = 1.0;
-const CENTER_RADIUS: f32 = 50.0;
-const MAX_VELOCITY: f32 = 10.0;
-const NATURAL_LENGTH: f32 = 30.0;
+const MAX_FORCE: f32 = 100.0;          // Increased for stronger forces
+const MIN_DISTANCE: f32 = 5.0;         // Increased minimum distance
+const CENTER_RADIUS: f32 = 250.0;      // Matches target_radius from settings
+const MAX_VELOCITY: f32 = 20.0;        // Increased for faster movement
+const NATURAL_LENGTH: f32 = 120.0;     // Matches natural_length from settings
+const BOUNDARY_LIMIT: f32 = 600.0;     // Matches boundary_limit from settings
+
+// Validation functions
+fn is_valid_float(x: f32) -> bool {
+    return x == x && abs(x) < 1e10;  // Check for NaN and infinity
+}
+
+fn is_valid_float3(v: vec3<f32>) -> bool {
+    return is_valid_float(v.x) && is_valid_float(v.y) && is_valid_float(v.z);
+}
+
+fn clamp_force(force: vec3<f32>) -> vec3<f32> {
+    let magnitude = length(force);
+    if (magnitude > MAX_FORCE) {
+        return (force / magnitude) * MAX_FORCE;
+    }
+    return force;
+}
 
 // Convert quantized mass (0-255 in lower byte) to float (0.0-2.0)
 fn decode_mass(mass_packed: u32) -> f32 {
@@ -68,11 +86,12 @@ fn calculate_spring_force(pos1: vec3<f32>, pos2: vec3<f32>, mass1: f32, mass2: f
         return normalize(displacement) * MAX_FORCE;
     }
     
-    // Combined spring and attraction forces
+    // Combined spring and attraction forces with weight scaling
     let spring_force = params.spring_strength * weight * (distance - NATURAL_LENGTH);
     let attraction_force = params.attraction_strength * weight * distance;
     
-    return normalize(displacement) * (spring_force + attraction_force);
+    let total_force = normalize(displacement) * (spring_force + attraction_force);
+    return clamp_force(total_force);
 }
 
 // Calculate repulsion force between nodes
@@ -84,9 +103,10 @@ fn calculate_repulsion_force(pos1: vec3<f32>, pos2: vec3<f32>, mass1: f32, mass2
         return normalize(displacement) * -MAX_FORCE;
     }
     
-    // Coulomb-like repulsion scaled by masses
-    let force_magnitude = -params.repulsion_strength * mass1 * mass2 / distance_sq;
-    return normalize(displacement) * min(abs(force_magnitude), MAX_FORCE) * sign(force_magnitude);
+    // Coulomb-like repulsion scaled by masses and adjusted for graph size
+    let force_magnitude = -params.repulsion_strength * mass1 * mass2 / max(distance_sq, 0.1);
+    let force = normalize(displacement) * min(abs(force_magnitude), MAX_FORCE) * sign(force_magnitude);
+    return clamp_force(force);
 }
 
 // Calculate center gravity force
@@ -96,8 +116,9 @@ fn calculate_center_force(position: vec3<f32>) -> vec3<f32> {
     
     if (distance > CENTER_RADIUS) {
         // Stronger centering force during initial layout
-        let center_strength = select(0.05, 0.1, params.is_initial_layout == 1u);
-        return normalize(to_center) * center_strength * (distance - CENTER_RADIUS);
+        let center_strength = select(0.1, 0.2, params.is_initial_layout == 1u);
+        let force = normalize(to_center) * center_strength * (distance - CENTER_RADIUS);
+        return clamp_force(force);
     }
     return vec3<f32>(0.0);
 }
@@ -112,6 +133,20 @@ fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
     }
 
     var node = nodes_buffer.nodes[node_id];
+    
+    // Validate input node data
+    if (!is_valid_float3(get_position(node)) || !is_valid_float3(get_velocity(node))) {
+        // Reset invalid node to origin
+        node.x = 0.0;
+        node.y = 0.0;
+        node.z = 0.0;
+        node.vx = 0.0;
+        node.vy = 0.0;
+        node.vz = 0.0;
+        nodes_buffer.nodes[node_id] = node;
+        return;
+    }
+
     var total_force = vec3<f32>(0.0);
     let node_mass = decode_mass(node.mass);
     let node_pos = get_position(node);
@@ -123,17 +158,24 @@ fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
         if (edge.source == node_id || edge.target_idx == node_id) {
             let other_id = select(edge.source, edge.target_idx, edge.source == node_id);
             let other_node = nodes_buffer.nodes[other_id];
+            
+            // Validate other node
+            if (!is_valid_float3(get_position(other_node))) {
+                continue;
+            }
+            
             let other_mass = decode_mass(other_node.mass);
             let other_pos = get_position(other_node);
             
             // Accumulate spring force
-            total_force += calculate_spring_force(
+            let spring_force = calculate_spring_force(
                 node_pos,
                 other_pos,
                 node_mass,
                 other_mass,
                 edge.weight
             );
+            total_force += spring_force;
         }
     }
 
@@ -141,24 +183,33 @@ fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
     for (var i = 0u; i < n_nodes; i = i + 1u) {
         if (i != node_id) {
             let other_node = nodes_buffer.nodes[i];
+            
+            // Validate other node
+            if (!is_valid_float3(get_position(other_node))) {
+                continue;
+            }
+            
             let other_mass = decode_mass(other_node.mass);
             let other_pos = get_position(other_node);
             
-            total_force += calculate_repulsion_force(
+            let repulsion_force = calculate_repulsion_force(
                 node_pos,
                 other_pos,
                 node_mass,
                 other_mass
             );
+            total_force += repulsion_force;
         }
     }
 
     // Add center gravity force
-    total_force += calculate_center_force(node_pos);
+    let center_force = calculate_center_force(node_pos);
+    total_force += center_force;
 
     // Scale forces based on layout phase
     let force_scale = select(1.0, 2.0, params.is_initial_layout == 1u);
     total_force *= force_scale;
+    total_force = clamp_force(total_force);
 
     // Update velocity with damping
     var velocity = get_velocity(node);
@@ -176,17 +227,28 @@ fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
     // Apply position bounds
     let bounded_pos = clamp(
         new_pos,
-        vec3<f32>(-CENTER_RADIUS * 2.0),
-        vec3<f32>(CENTER_RADIUS * 2.0)
+        vec3<f32>(-BOUNDARY_LIMIT),
+        vec3<f32>(BOUNDARY_LIMIT)
     );
 
-    // Update node with new values
-    node.x = bounded_pos.x;
-    node.y = bounded_pos.y;
-    node.z = bounded_pos.z;
-    node.vx = velocity.x;
-    node.vy = velocity.y;
-    node.vz = velocity.z;
+    // Validate final values
+    if (!is_valid_float3(bounded_pos) || !is_valid_float3(velocity)) {
+        // Reset to origin if invalid
+        node.x = 0.0;
+        node.y = 0.0;
+        node.z = 0.0;
+        node.vx = 0.0;
+        node.vy = 0.0;
+        node.vz = 0.0;
+    } else {
+        // Update node with new values
+        node.x = bounded_pos.x;
+        node.y = bounded_pos.y;
+        node.z = bounded_pos.z;
+        node.vx = velocity.x;
+        node.vy = velocity.y;
+        node.vz = velocity.z;
+    }
 
     nodes_buffer.nodes[node_id] = node;
 }
diff --git a/utils/gpu_compute.rs b/utils/gpu_compute.rs
index 428dac19..eb2b5e49 100755
--- a/utils/gpu_compute.rs
+++ b/utils/gpu_compute.rs
@@ -1,23 +1,26 @@
 use wgpu::{Device, Queue, Buffer, BindGroup, ComputePipeline, InstanceDescriptor};
 use wgpu::util::DeviceExt;
 use std::io::Error;
-use log::{debug, info};
+use log::{debug, info, error};  // Removed unused warn import
 use crate::models::graph::GraphData;
 use crate::models::edge::GPUEdge;
 use crate::models::node::GPUNode;
-use crate::models::simulation_params::{SimulationParams, SimulationMode};
-use crate::models::position_update::NodePositionVelocity;
+use crate::models::simulation_params::SimulationParams;  // Removed unused SimulationMode
 use futures::channel::oneshot;
 
 // Constants for buffer management and computation
 const WORKGROUP_SIZE: u32 = 256;
-const INITIAL_BUFFER_SIZE: u64 = 1024 * 1024;  // 1MB initial size
+const INITIAL_BUFFER_SIZE: u64 = 4 * 1024 * 1024;  // Increased to 4MB for larger quantized values
 const BUFFER_ALIGNMENT: u64 = 256;  // Required GPU memory alignment
 const EDGE_SIZE: u64 = 32;  // Size of Edge struct (must match WGSL)
-const NODE_SIZE: u64 = 28;  // Size of Node struct in WGSL (optimized)
+const NODE_SIZE: u64 = 32;  // Increased from 28 to 32 for better alignment with larger values
 const MAX_NODES: u32 = 1_000_000;  // Safety limit for number of nodes
 const MAX_EDGES: u32 = 5_000_000;  // Safety limit for number of edges
 
+// Position update constants
+const POSITION_BUFFER_SIZE: u64 = 32;  // Increased from 24 to 32 for better alignment
+const POSITION_UPDATE_ALIGNMENT: u64 = 16;  // Alignment for position updates
+
 /// Represents adjacency information for graph nodes
 #[repr(C)]
 #[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
@@ -269,7 +272,7 @@ impl GPUCompute {
         // Create dedicated position buffers
         let position_update_buffer = device.create_buffer(&wgpu::BufferDescriptor {
             label: Some("Position Update Buffer"),
-            size: (MAX_NODES as u64) * 24, // 6 floats per node (position + velocity)
+            size: (MAX_NODES as u64) * POSITION_BUFFER_SIZE,  // Increased size per node
             usage: wgpu::BufferUsages::STORAGE 
                 | wgpu::BufferUsages::COPY_DST 
                 | wgpu::BufferUsages::COPY_SRC,
@@ -278,7 +281,7 @@ impl GPUCompute {
 
         let position_staging_buffer = device.create_buffer(&wgpu::BufferDescriptor {
             label: Some("Position Staging Buffer"),
-            size: (MAX_NODES as u64) * 24, // 6 floats per node (position + velocity)
+            size: (MAX_NODES as u64) * POSITION_BUFFER_SIZE,  // Increased size per node
             usage: wgpu::BufferUsages::MAP_READ | wgpu::BufferUsages::COPY_DST,
             mapped_at_creation: false,
         });
@@ -409,6 +412,22 @@ impl GPUCompute {
 
     /// Updates the graph data in GPU buffers
     pub fn update_graph_data(&mut self, graph: &GraphData) -> Result<(), Error> {
+        debug!("Updating GPU graph data: {} nodes, {} edges", 
+            graph.nodes.len(), graph.edges.len());
+
+        // Validate buffer sizes
+        let required_node_size = (graph.nodes.len() as u64) * NODE_SIZE;
+        let required_edge_size = (graph.edges.len() as u64) * EDGE_SIZE;
+
+        if required_node_size > INITIAL_BUFFER_SIZE || required_edge_size > INITIAL_BUFFER_SIZE {
+            error!("Graph data exceeds buffer size limits: nodes={}, edges={}", 
+                required_node_size, required_edge_size);
+            return Err(Error::new(
+                std::io::ErrorKind::InvalidInput,
+                "Graph data exceeds buffer size limits"
+            ));
+        }
+
         let gpu_nodes: Vec<GPUNode> = graph.nodes.iter().map(|node| GPUNode {
             x: node.x,
             y: node.y,
@@ -421,15 +440,28 @@ impl GPUCompute {
             padding: [0; 2],
         }).collect();
 
+        debug!("Created GPU nodes. Sample positions: {:?}", 
+            gpu_nodes.iter().take(3).map(|n| (n.x, n.y, n.z)).collect::<Vec<_>>());
+
         let gpu_edges: Vec<GPUEdge> = graph.edges.iter()
             .map(|edge| edge.to_gpu_edge(&graph.nodes))
             .collect();
 
+        debug!("Created GPU edges. Sample edges: {:?}",
+            gpu_edges.iter().take(3).collect::<Vec<_>>());
+
+        // Write data to GPU buffers with alignment
+        let aligned_node_size = (required_node_size + BUFFER_ALIGNMENT - 1) & !(BUFFER_ALIGNMENT - 1);
+        let aligned_edge_size = (required_edge_size + BUFFER_ALIGNMENT - 1) & !(BUFFER_ALIGNMENT - 1);
+
         self.queue.write_buffer(&self.nodes_buffer, 0, bytemuck::cast_slice(&gpu_nodes));
         self.queue.write_buffer(&self.edges_buffer, 0, bytemuck::cast_slice(&gpu_edges));
         
         self.num_nodes = graph.nodes.len() as u32;
         self.num_edges = graph.edges.len() as u32;
+
+        debug!("GPU buffers updated successfully: aligned_node_size={}, aligned_edge_size={}", 
+            aligned_node_size, aligned_edge_size);
         
         Ok(())
     }
@@ -439,6 +471,8 @@ impl GPUCompute {
         // Verify data length (24 bytes per node - position + velocity, plus 4 bytes for header)
         let expected_size = self.num_nodes as usize * 24 + 4;
         if binary_data.len() != expected_size {
+            error!("Invalid position data length: expected {}, got {}", 
+                expected_size, binary_data.len());
             return Err(Error::new(
                 std::io::ErrorKind::InvalidData,
                 format!("Invalid position data length: expected {}, got {}", 
@@ -452,6 +486,9 @@ impl GPUCompute {
         let header_value = f32::from_le_bytes(header_bytes);
         let is_initial_layout = header_value >= 1.0;
 
+        debug!("Processing position update: {} bytes, initial layout: {}", 
+            binary_data.len(), is_initial_layout);
+
         // Update simulation params
         let mut params = self.simulation_params;
         params.is_initial_layout = is_initial_layout;
@@ -468,6 +505,8 @@ impl GPUCompute {
             &binary_data[4..]
         );
 
+        debug!("Position data written to GPU buffer");
+
         // Run position validation shader
         let mut encoder = self.device.create_command_encoder(
             &wgpu::CommandEncoderDescriptor {
@@ -485,11 +524,11 @@ impl GPUCompute {
 
             compute_pass.set_pipeline(&self.position_pipeline);
             compute_pass.set_bind_group(0, &self.position_bind_group, &[]);
-            compute_pass.dispatch_workgroups(
-                (self.num_nodes + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE, 
-                1, 
-                1
-            );
+            
+            let workgroups = (self.num_nodes + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE;
+            debug!("Dispatching position validation shader: {} workgroups", workgroups);
+            
+            compute_pass.dispatch_workgroups(workgroups, 1, 1);
         }
 
         // Copy validated positions and velocities to node buffer
@@ -502,67 +541,20 @@ impl GPUCompute {
         );
 
         self.queue.submit(Some(encoder.finish()));
+        debug!("Position update complete");
 
         Ok(())
     }
 
-    /// Get current positions in binary format for client updates
-    pub async fn get_position_updates(&self) -> Result<Vec<NodePositionVelocity>, Error> {
-        let mut encoder = self.device.create_command_encoder(
-            &wgpu::CommandEncoderDescriptor {
-                label: Some("Position Readback Encoder"),
-            }
-        );
-
-        // Copy position and velocity data
-        encoder.copy_buffer_to_buffer(
-            &self.nodes_buffer,
-            0,
-            &self.position_staging_buffer,
-            0,
-            (self.num_nodes as u64) * 24, // 24 bytes per node
-        );
-
-        self.queue.submit(Some(encoder.finish()));
-
-        // Map buffer and read positions
-        let buffer_slice = self.position_staging_buffer.slice(..);
-        let (sender, receiver) = futures::channel::oneshot::channel();
-        
-        buffer_slice.map_async(wgpu::MapMode::Read, move |result| {
-            sender.send(result).unwrap();
-        });
-        
-        self.device.poll(wgpu::Maintain::Wait);
-
-        receiver.await.unwrap()
-            .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
-
-        let data = buffer_slice.get_mapped_range();
-        let positions: Vec<NodePositionVelocity> = bytemuck::cast_slice(&data).to_vec();
-        drop(data);
-        self.position_staging_buffer.unmap();
-
-        Ok(positions)
-    }
-
-    /// Updates simulation parameters
-    pub fn update_simulation_params(&mut self, params: &SimulationParams) -> Result<(), Error> {
-        self.simulation_params = *params;
-        self.queue.write_buffer(
-            &self.simulation_params_buffer,
-            0,
-            bytemuck::cast_slice(&[self.simulation_params])
-        );
-        Ok(())
-    }
-
     /// Performs one step of the force-directed layout computation
     pub fn step(&mut self) -> Result<(), Error> {
         let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
             label: Some("Force Compute Encoder"),
         });
 
+        debug!("Starting force computation step: {} nodes, {} edges", 
+            self.num_nodes, self.num_edges);
+
         {
             let mut compute_pass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
                 label: Some("Force Compute Pass"),
@@ -571,25 +563,34 @@ impl GPUCompute {
 
             compute_pass.set_pipeline(&self.force_pipeline);
             compute_pass.set_bind_group(0, &self.force_bind_group, &[]);
-            compute_pass.dispatch_workgroups((self.num_nodes + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE, 1, 1);
+            
+            let workgroups = (self.num_nodes + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE;
+            debug!("Dispatching force computation: {} workgroups", workgroups);
+            
+            compute_pass.dispatch_workgroups(workgroups, 1, 1);
         }
 
         self.queue.submit(Some(encoder.finish()));
+        debug!("Force computation step complete");
+        
         Ok(())
     }
 
     /// Retrieves current node positions from GPU
     pub async fn get_node_positions(&self) -> Result<Vec<GPUNode>, Error> {
+        debug!("Reading node positions from GPU: {} nodes", self.num_nodes);
+
         let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
             label: Some("Node Position Readback"),
         });
 
+        let buffer_size = (self.num_nodes as u64) * std::mem::size_of::<GPUNode>() as u64;
         encoder.copy_buffer_to_buffer(
             &self.nodes_buffer,
             0,
             &self.nodes_staging_buffer,
             0,
-            (self.num_nodes as u64) * std::mem::size_of::<GPUNode>() as u64,
+            buffer_size,
         );
 
         self.queue.submit(Some(encoder.finish()));
@@ -607,11 +608,32 @@ impl GPUCompute {
         drop(data);
         self.nodes_staging_buffer.unmap();
 
+        debug!("Node positions read successfully. Sample positions: {:?}", 
+            nodes.iter().take(3).map(|n| (n.x, n.y, n.z)).collect::<Vec<_>>());
+
         Ok(nodes)
     }
 
+    /// Updates simulation parameters
+    pub fn update_simulation_params(&mut self, params: &SimulationParams) -> Result<(), Error> {
+        debug!("Updating simulation parameters: {:?}", params);
+        
+        self.simulation_params = *params;
+        self.queue.write_buffer(
+            &self.simulation_params_buffer,
+            0,
+            bytemuck::cast_slice(&[self.simulation_params])
+        );
+
+        debug!("Simulation parameters updated successfully");
+        Ok(())
+    }
+
     /// Updates fisheye distortion parameters
     pub fn update_fisheye_params(&mut self, enabled: bool, strength: f32, focus_point: [f32; 3], radius: f32) -> Result<(), Error> {
+        debug!("Updating fisheye parameters: enabled={}, strength={}, focus={:?}, radius={}", 
+            enabled, strength, focus_point, radius);
+
         self.fisheye_params = FisheyeParams {
             enabled: if enabled { 1 } else { 0 },
             strength,
@@ -623,6 +645,8 @@ impl GPUCompute {
             0,
             bytemuck::cast_slice(&[self.fisheye_params])
         );
+
+        debug!("Fisheye parameters updated successfully");
         Ok(())
     }
 }
diff --git a/utils/update_positions.wgsl b/utils/update_positions.wgsl
index 8da700ae..65565702 100755
--- a/utils/update_positions.wgsl
+++ b/utils/update_positions.wgsl
@@ -5,15 +5,31 @@ struct PositionUpdate {
 
 @group(0) @binding(0) var<storage, read_write> position_updates: array<PositionUpdate>;
 
+// Constants
+const MAX_VELOCITY: f32 = 100.0;
+const MAX_POSITION: f32 = 1000.0;  // Maximum distance from origin
+
 // Utility functions
 fn is_valid_float(x: f32) -> bool {
-    return x == x && abs(x) < 1e10;
+    return x == x && abs(x) < 1e10;  // Check for NaN and infinity
 }
 
 fn is_valid_float3(v: vec3<f32>) -> bool {
     return is_valid_float(v.x) && is_valid_float(v.y) && is_valid_float(v.z);
 }
 
+fn clamp_position(pos: vec3<f32>) -> vec3<f32> {
+    return clamp(pos, vec3<f32>(-MAX_POSITION), vec3<f32>(MAX_POSITION));
+}
+
+fn clamp_velocity(vel: vec3<f32>) -> vec3<f32> {
+    let speed = length(vel);
+    if (speed > MAX_VELOCITY) {
+        return (vel / speed) * MAX_VELOCITY;
+    }
+    return vel;
+}
+
 @compute @workgroup_size(256)
 fn update_positions(@builtin(global_invocation_id) global_id: vec3<u32>) {
     let node_id = global_id.x;
@@ -23,19 +39,18 @@ fn update_positions(@builtin(global_invocation_id) global_id: vec3<u32>) {
 
     var update = position_updates[node_id];
     
-    // Validate position and velocity
+    // Validate and clamp position
     if (!is_valid_float3(update.position)) {
         update.position = vec3<f32>(0.0);
+    } else {
+        update.position = clamp_position(update.position);
     }
+    
+    // Validate and clamp velocity
     if (!is_valid_float3(update.velocity)) {
         update.velocity = vec3<f32>(0.0);
-    }
-    
-    // Apply velocity limits
-    let max_velocity = 100.0;
-    let velocity_length = length(update.velocity);
-    if (velocity_length > max_velocity) {
-        update.velocity = update.velocity * (max_velocity / velocity_length);
+    } else {
+        update.velocity = clamp_velocity(update.velocity);
     }
     
     position_updates[node_id] = update;
diff --git a/utils/websocket_manager.rs b/utils/websocket_manager.rs
index ea4b4a3e..a8c77ecd 100755
--- a/utils/websocket_manager.rs
+++ b/utils/websocket_manager.rs
@@ -1,196 +1,276 @@
-use actix_web::{web, Error, HttpRequest, HttpResponse};
-use actix_web_actors::ws;
 use actix::prelude::*;
-use log::{info, error};
-use std::sync::{Mutex, Arc};
+use actix_web_actors::ws;
+use actix_web::{web, Error, HttpRequest, HttpResponse};
+use bytemuck;
+use std::sync::Arc;
+use tokio::sync::Mutex;
 use serde_json::json;
-use actix_web_actors::ws::WebsocketContext;
 
-use crate::AppState;
-use crate::models::simulation_params::SimulationMode;
-use crate::handlers::{WebSocketSession, WebSocketSessionHandler};
-use crate::utils::websocket_messages::{MessageHandler, SendText, ClientMessage};
+use crate::models::node::GPUNode;
+use crate::models::graph::GraphData;
+
+// Constants for binary data
+const FLOAT32_SIZE: usize = std::mem::size_of::<f32>();
+const HEADER_SIZE: usize = FLOAT32_SIZE; // isInitialLayout flag
+const NODE_SIZE: usize = 6 * FLOAT32_SIZE; // x, y, z, vx, vy, vz
 
-/// Manages WebSocket sessions and communication.
 pub struct WebSocketManager {
-    pub sessions: Mutex<Vec<Addr<WebSocketSession>>>,
-    pub conversation_id: Arc<Mutex<Option<String>>>,
+    binary_buffer: Arc<Mutex<Vec<u8>>>,
+    connections: Arc<Mutex<Vec<Addr<WebSocketSession>>>>,
+    addr: Option<Addr<Self>>,
+}
+
+// Message types
+#[derive(Message, Clone)]
+#[rtype(result = "()")]
+pub enum BroadcastMsg {
+    Text(String),
+    Binary(Vec<u8>),
+}
+
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct BroadcastBinary {
+    pub nodes: Arc<Vec<GPUNode>>,
+    pub is_initial: bool,
+}
+
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct BroadcastGraph {
+    pub graph: Arc<GraphData>,
+}
+
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct BroadcastError {
+    pub message: String,
+}
+
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct BroadcastAudio {
+    pub data: Vec<u8>,
 }
 
 impl WebSocketManager {
-    /// Creates a new WebSocketManager instance.
     pub fn new() -> Self {
-        WebSocketManager {
-            sessions: Mutex::new(Vec::new()),
-            conversation_id: Arc::new(Mutex::new(None)),
+        Self {
+            binary_buffer: Arc::new(Mutex::new(Vec::with_capacity(1024 * 1024))), // 1MB initial capacity
+            connections: Arc::new(Mutex::new(Vec::new())),
+            addr: None,
+        }
+    }
+
+    pub fn start(mut self) -> Addr<Self> {
+        let addr = Actor::start(self.clone());
+        self.addr = Some(addr.clone());
+        addr
+    }
+
+    pub fn get_addr(&self) -> Option<Addr<Self>> {
+        self.addr.clone()
+    }
+
+    pub async fn add_connection(&self, addr: Addr<WebSocketSession>) {
+        let mut connections = self.connections.lock().await;
+        connections.push(addr);
+    }
+
+    pub async fn remove_connection(&self, addr: &Addr<WebSocketSession>) {
+        let mut connections = self.connections.lock().await;
+        connections.retain(|x| x != addr);
+    }
+
+    pub async fn broadcast_binary(&self, nodes: &[GPUNode], is_initial: bool) -> Result<(), Box<dyn std::error::Error>> {
+        if let Some(addr) = self.get_addr() {
+            addr.do_send(BroadcastBinary {
+                nodes: Arc::new(nodes.to_vec()),
+                is_initial,
+            });
         }
+        Ok(())
     }
 
-    /// Initializes the WebSocketManager with a conversation ID.
-    pub async fn initialize(&self, ragflow_service: &crate::services::ragflow_service::RAGFlowService) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
-        let conversation_id = ragflow_service.create_conversation("default_user".to_string()).await?;
-        let mut conv_id_lock = self.conversation_id.lock().unwrap();
-        *conv_id_lock = Some(conversation_id.clone());
-        info!("Initialized conversation with ID: {}", conversation_id);
+    pub async fn broadcast_graph_update(&self, graph: &GraphData) -> Result<(), Box<dyn std::error::Error>> {
+        if let Some(addr) = self.get_addr() {
+            addr.do_send(BroadcastGraph {
+                graph: Arc::new(graph.clone()),
+            });
+        }
         Ok(())
     }
 
-    /// Handles incoming WebSocket connection requests.
-    pub async fn handle_websocket(req: HttpRequest, stream: web::Payload, state: web::Data<AppState>) -> Result<HttpResponse, Error> {
-        info!("New WebSocket connection request");
-        let session = WebSocketSession {
-            state: state.clone(),
-            tts_method: "piper".to_string(),
-            openai_ws: None,
-            simulation_mode: SimulationMode::Remote,
-            conversation_id: Some(state.websocket_manager.conversation_id.clone()),
-        };
-        ws::start(session, &req, stream)
-    }
-
-    /// Broadcasts a message to all connected WebSocket sessions.
-    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
-        let sessions = self.sessions.lock().unwrap().clone();
-        for session in sessions {
-            let msg: SendText = SendText(message.to_string());
-            session.do_send(msg);
+    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {
+        if let Some(addr) = self.get_addr() {
+            addr.do_send(BroadcastMsg::Text(message.to_string()));
         }
         Ok(())
     }
 
-    /// Broadcasts graph update to all connected WebSocket sessions.
-    pub async fn broadcast_graph_update(&self, graph_data: &crate::models::graph::GraphData) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
-        let json_data = json!({
-            "type": "graph_update",
-            "graph_data": graph_data
-        });
-        let message = json_data.to_string();
-        self.broadcast_message(&message).await
+    pub async fn handle_websocket(
+        req: HttpRequest,
+        stream: web::Payload,
+        websocket_manager: web::Data<Arc<WebSocketManager>>,
+    ) -> Result<HttpResponse, Error> {
+        let ws = WebSocketSession::new(websocket_manager.get_ref().clone());
+        ws::start(ws, &req, stream)
+    }
+}
+
+impl Clone for WebSocketManager {
+    fn clone(&self) -> Self {
+        Self {
+            binary_buffer: self.binary_buffer.clone(),
+            connections: self.connections.clone(),
+            addr: self.addr.clone(),
+        }
+    }
+}
+
+impl Actor for WebSocketManager {
+    type Context = Context<Self>;
+
+    fn started(&mut self, ctx: &mut Self::Context) {
+        self.addr = Some(ctx.address());
+    }
+}
+
+impl Handler<BroadcastBinary> for WebSocketManager {
+    type Result = ResponseActFuture<Self, ()>;
+
+    fn handle(&mut self, msg: BroadcastBinary, _: &mut Context<Self>) -> Self::Result {
+        let binary_buffer = self.binary_buffer.clone();
+        let connections = self.connections.clone();
+        let nodes = msg.nodes.clone();
+        
+        Box::pin(async move {
+            let mut buffer = binary_buffer.lock().await;
+            let total_size = HEADER_SIZE + nodes.len() * NODE_SIZE;
+            
+            // Create a new buffer with the required capacity
+            let mut new_buffer = Vec::with_capacity(total_size);
+            
+            // Write initial flag
+            let initial_flag: f32 = if msg.is_initial { 1.0 } else { 0.0 };
+            new_buffer.extend_from_slice(bytemuck::bytes_of(&initial_flag));
+
+            // Write node data
+            for node in nodes.iter() {
+                let node_data: [f32; 6] = [
+                    node.x, node.y, node.z,
+                    node.vx, node.vy, node.vz
+                ];
+                new_buffer.extend_from_slice(bytemuck::cast_slice(&node_data));
+            }
+
+            // Replace the buffer content
+            *buffer = new_buffer;
+
+            // Broadcast to all connections
+            let binary_data = buffer.clone();
+            let connections = connections.lock().await;
+            for addr in connections.iter() {
+                addr.do_send(BroadcastMsg::Binary(binary_data.clone()));
+            }
+        }.into_actor(self))
+    }
+}
+
+impl Handler<BroadcastGraph> for WebSocketManager {
+    type Result = ResponseActFuture<Self, ()>;
+
+    fn handle(&mut self, msg: BroadcastGraph, _: &mut Context<Self>) -> Self::Result {
+        let connections = self.connections.clone();
+        let graph = msg.graph.clone();
+        
+        Box::pin(async move {
+            let msg = json!({
+                "type": "graphUpdate",
+                "graphData": &*graph
+            });
+
+            let connections = connections.lock().await;
+            for addr in connections.iter() {
+                addr.do_send(BroadcastMsg::Text(msg.to_string()));
+            }
+        }.into_actor(self))
+    }
+}
+
+impl Handler<BroadcastError> for WebSocketManager {
+    type Result = ResponseActFuture<Self, ()>;
+
+    fn handle(&mut self, msg: BroadcastError, _: &mut Context<Self>) -> Self::Result {
+        let connections = self.connections.clone();
+        let error_msg = msg.message.clone();
+        
+        Box::pin(async move {
+            let msg = json!({
+                "type": "error",
+                "message": error_msg
+            });
+
+            let connections = connections.lock().await;
+            for addr in connections.iter() {
+                addr.do_send(BroadcastMsg::Text(msg.to_string()));
+            }
+        }.into_actor(self))
+    }
+}
+
+impl Handler<BroadcastAudio> for WebSocketManager {
+    type Result = ResponseActFuture<Self, ()>;
+
+    fn handle(&mut self, msg: BroadcastAudio, _: &mut Context<Self>) -> Self::Result {
+        let connections = self.connections.clone();
+        let audio_data = msg.data.clone();
+        
+        Box::pin(async move {
+            let connections = connections.lock().await;
+            for addr in connections.iter() {
+                addr.do_send(BroadcastMsg::Binary(audio_data.clone()));
+            }
+        }.into_actor(self))
+    }
+}
+
+// WebSocket session actor
+pub struct WebSocketSession {
+    manager: WebSocketManager,
+}
+
+impl WebSocketSession {
+    pub fn new(manager: WebSocketManager) -> Self {
+        Self { manager }
+    }
+}
+
+impl Actor for WebSocketSession {
+    type Context = ws::WebsocketContext<Self>;
+}
+
+impl Handler<BroadcastMsg> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, msg: BroadcastMsg, ctx: &mut Self::Context) {
+        match msg {
+            BroadcastMsg::Text(text) => ctx.text(text),
+            BroadcastMsg::Binary(data) => ctx.binary(data),
+        }
     }
 }
 
 impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession {
-    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut WebsocketContext<Self>) {
+    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
         match msg {
-            Ok(ws::Message::Ping(msg)) => {
-                let ctx: &mut WebsocketContext<WebSocketSession> = ctx;
-                ctx.pong(&msg);
-            },
-            Ok(ws::Message::Pong(_)) => (),
-            Ok(ws::Message::Text(text)) => {
-                match serde_json::from_str::<ClientMessage>(&text) {
-                    Ok(client_msg) => match client_msg {
-                        ClientMessage::ChatMessage { message, use_openai } => {
-                            WebSocketSessionHandler::handle_chat_message(self, ctx, message, use_openai);
-                        },
-                        ClientMessage::SetSimulationMode { mode } => {
-                            WebSocketSessionHandler::handle_simulation_mode(self, ctx, &mode);
-                        },
-                        ClientMessage::RecalculateLayout { params } => {
-                            WebSocketSessionHandler::handle_layout(self, ctx, params);
-                        },
-                        ClientMessage::GetInitialData => {
-                            WebSocketSessionHandler::handle_initial_data(self, ctx);
-                        },
-                        ClientMessage::UpdateFisheyeSettings { enabled, strength, focus_point, radius } => {
-                            WebSocketSessionHandler::handle_fisheye_settings(self, ctx, enabled, strength, focus_point, radius);
-                        },
-                        ClientMessage::UpdateSettings { settings } => {
-                            MessageHandler::handle_settings_update(self, settings, ctx);
-                        },
-                        _ => {
-                            error!("Unhandled client message type");
-                            let error_message = json!({
-                                "type": "error",
-                                "message": "Unhandled message type"
-                            });
-                            MessageHandler::send_json_response(self, error_message, ctx);
-                        }
-                    },
-                    Err(e) => {
-                        error!("Failed to parse client message: {}", e);
-                        let error_message = json!({
-                            "type": "error",
-                            "message": format!("Invalid message format: {}", e)
-                        });
-                        MessageHandler::send_json_response(self, error_message, ctx);
-                    }
-                }
-            },
-            Ok(ws::Message::Binary(bin)) => {
-                if let Some(gpu_compute) = &self.state.gpu_compute {
-                    let gpu = gpu_compute.clone();
-                    let bin_data = bin.to_vec();
-                    let ctx_addr = ctx.address();
-
-                    ctx.spawn(
-                        async move {
-                            let gpu_read = gpu.read().await;
-                            let num_nodes = gpu_read.get_num_nodes() as usize;
-                            let expected_size = num_nodes * 24 + 4; // +4 for is_initial_layout flag
-                            drop(gpu_read); // Release the read lock before writing
-
-                            if bin_data.len() != expected_size {
-                                error!("Invalid position data length: expected {}, got {}", 
-                                    expected_size, bin_data.len());
-                                let error_message = json!({
-                                    "type": "error",
-                                    "message": format!("Invalid position data length: expected {}, got {}", 
-                                        expected_size, bin_data.len())
-                                });
-                                if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                    let msg: SendText = SendText(error_str);
-                                    ctx_addr.do_send(msg);
-                                }
-                                return;
-                            }
-
-                            // Read is_initial_layout flag from the first 4 bytes
-                            let is_initial_layout = {
-                                let mut flag_bytes = [0u8; 4];
-                                flag_bytes.copy_from_slice(&bin_data[0..4]);
-                                f32::from_le_bytes(flag_bytes) > 0.5
-                            };
-
-                            // Skip the flag when updating positions
-                            let position_data = &bin_data[4..];
-
-                            let mut gpu_write = gpu.write().await;
-                            if let Err(e) = gpu_write.update_positions(position_data).await {
-                                error!("Failed to update node positions: {}", e);
-                                let error_message = json!({
-                                    "type": "error",
-                                    "message": format!("Failed to update node positions: {}", e)
-                                });
-                                if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                    let msg: SendText = SendText(error_str);
-                                    ctx_addr.do_send(msg);
-                                }
-                            } else {
-                                // Send position update completion as JSON
-                                let completion_message = json!({
-                                    "type": "position_update_complete",
-                                    "status": "success",
-                                    "is_initial_layout": is_initial_layout
-                                });
-                                if let Ok(msg_str) = serde_json::to_string(&completion_message) {
-                                    let msg: SendText = SendText(msg_str);
-                                    ctx_addr.do_send(msg);
-                                }
-                            }
-                        }
-                        .into_actor(self)
-                    );
-                }
-            },
+            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
+            Ok(ws::Message::Text(text)) => ctx.text(text),
+            Ok(ws::Message::Binary(bin)) => ctx.binary(bin),
             Ok(ws::Message::Close(reason)) => {
                 ctx.close(reason);
                 ctx.stop();
-            },
-            Err(e) => {
-                error!("WebSocket error: {}", e);
-                ctx.stop();
-            },
+            }
             _ => (),
         }
     }
diff --git a/utils/websocket_messages.rs b/utils/websocket_messages.rs
index e60a341b..1678fb67 100755
--- a/utils/websocket_messages.rs
+++ b/utils/websocket_messages.rs
@@ -1,187 +1,164 @@
 use actix::prelude::*;
 use serde::{Deserialize, Serialize};
-use serde_json::{json, Value};
-use std::fs;
-use toml;
-use crate::models::simulation_params::SimulationParams;
-use crate::models::position_update::NodePositionVelocity;
-use actix_web_actors::ws;
-use log::{error, debug};
-use bytestring::ByteString;
+use serde_json::Value;
 
-/// GPU-computed node positions and velocities
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct GPUPositionUpdate {
-    pub updates: Vec<NodePositionVelocity>,
-    pub is_initial_layout: bool
-}
-
-impl GPUPositionUpdate {
-    pub fn to_binary(&self) -> Vec<u8> {
-        let mut binary = Vec::with_capacity(4 + self.updates.len() * 24);
-        
-        // Write header (4 bytes)
-        let header_value = if self.is_initial_layout { 1.0f32 } else { 0.0f32 };
-        binary.extend_from_slice(&header_value.to_le_bytes());
-
-        // Write position updates (24 bytes each)
-        for update in &self.updates {
-            binary.extend_from_slice(&update.x.to_le_bytes());
-            binary.extend_from_slice(&update.y.to_le_bytes());
-            binary.extend_from_slice(&update.z.to_le_bytes());
-            binary.extend_from_slice(&update.vx.to_le_bytes());
-            binary.extend_from_slice(&update.vy.to_le_bytes());
-            binary.extend_from_slice(&update.vz.to_le_bytes());
-        }
-
-        binary
-    }
+// Constants for binary protocol
+pub const POSITION_SCALE: f32 = 10000.0;  // Increased to match client
+pub const VELOCITY_SCALE: f32 = 20000.0;  // Increased to match client
+pub const BINARY_HEADER_SIZE: usize = 4;  // Float32 for initial layout flag
+pub const BINARY_NODE_SIZE: usize = 24;   // 6 float32s per node (position + velocity)
 
-    pub fn from_binary(data: &[u8], num_nodes: usize) -> Result<Self, String> {
-        if data.len() != 4 + num_nodes * 24 {
-            return Err(format!("Invalid data length: expected {}, got {}", 
-                4 + num_nodes * 24, data.len()));
-        }
+// Maximum valid values for validation
+pub const MAX_VALID_POSITION: f32 = 1000.0;
+pub const MAX_VALID_VELOCITY: f32 = 50.0;
 
-        // Read header
-        let mut header_bytes = [0u8; 4];
-        header_bytes.copy_from_slice(&data[0..4]);
-        let header_value = f32::from_le_bytes(header_bytes);
-        let is_initial_layout = header_value >= 1.0;
+/// Trait for handling WebSocket messages
+pub trait MessageHandler {}
 
-        let mut updates = Vec::with_capacity(num_nodes);
-
-        // Read position updates
-        for i in 0..num_nodes {
-            let offset = 4 + i * 24;
-            let mut pos = [0u8; 24];
-            pos.copy_from_slice(&data[offset..offset + 24]);
-
-            let x = f32::from_le_bytes(pos[0..4].try_into().unwrap());
-            let y = f32::from_le_bytes(pos[4..8].try_into().unwrap());
-            let z = f32::from_le_bytes(pos[8..12].try_into().unwrap());
-            let vx = f32::from_le_bytes(pos[12..16].try_into().unwrap());
-            let vy = f32::from_le_bytes(pos[16..20].try_into().unwrap());
-            let vz = f32::from_le_bytes(pos[20..24].try_into().unwrap());
-
-            updates.push(NodePositionVelocity { x, y, z, vx, vy, vz });
-        }
-
-        Ok(Self {
-            updates,
-            is_initial_layout
-        })
-    }
-}
-
-/// Message for sending text data
+/// Message types for WebSocket communication
 #[derive(Message)]
 #[rtype(result = "()")]
 pub struct SendText(pub String);
 
-/// Message for sending binary data
 #[derive(Message)]
 #[rtype(result = "()")]
 pub struct SendBinary(pub Vec<u8>);
 
-/// Message for OpenAI text-to-speech
 #[derive(Message)]
 #[rtype(result = "()")]
 pub struct OpenAIMessage(pub String);
 
-/// Message indicating OpenAI connection success
 #[derive(Message)]
 #[rtype(result = "()")]
 pub struct OpenAIConnected;
 
-/// Message indicating OpenAI connection failure
 #[derive(Message)]
 #[rtype(result = "()")]
 pub struct OpenAIConnectionFailed;
 
-/// Represents messages sent from the client.
-#[derive(Serialize, Deserialize, Debug)]
-#[serde(tag = "type")]
-pub enum ClientMessage {
-    #[serde(rename = "setTtsMethod")]
-    SetTTSMethod { method: String },
+/// Helper function to validate position values
+pub fn validate_position(x: f32, y: f32, z: f32) -> bool {
+    x.abs() <= MAX_VALID_POSITION && 
+    y.abs() <= MAX_VALID_POSITION && 
+    z.abs() <= MAX_VALID_POSITION
+}
+
+/// Helper function to validate velocity values
+pub fn validate_velocity(vx: f32, vy: f32, vz: f32) -> bool {
+    vx.abs() <= MAX_VALID_VELOCITY && 
+    vy.abs() <= MAX_VALID_VELOCITY && 
+    vz.abs() <= MAX_VALID_VELOCITY
+}
+
+/// Helper function to quantize position for network transmission
+pub fn quantize_position(pos: f32) -> i32 {
+    (pos * POSITION_SCALE).round() as i32
+}
+
+/// Helper function to quantize velocity for network transmission
+pub fn quantize_velocity(vel: f32) -> i32 {
+    (vel * VELOCITY_SCALE).round() as i32
+}
+
+/// Helper function to dequantize position from network transmission
+pub fn dequantize_position(pos: i32) -> f32 {
+    pos as f32 / POSITION_SCALE
+}
+
+/// Helper function to dequantize velocity from network transmission
+pub fn dequantize_velocity(vel: i32) -> f32 {
+    vel as f32 / VELOCITY_SCALE
+}
+
+/// Helper function to create binary position update message
+pub fn create_binary_update(positions: &[(f32, f32, f32, f32, f32, f32)], is_initial: bool) -> Vec<u8> {
+    let mut binary_data = Vec::with_capacity(BINARY_HEADER_SIZE + positions.len() * BINARY_NODE_SIZE);
     
-    #[serde(rename = "chatMessage")]
-    ChatMessage { 
-        message: String, 
-        use_openai: bool 
-    },
+    // Add initial layout flag
+    let flag = if is_initial { 1.0f32 } else { 0.0f32 };
+    binary_data.extend_from_slice(&flag.to_le_bytes());
     
-    #[serde(rename = "getInitialData")]
-    GetInitialData,
+    // Add quantized positions and velocities
+    for &(x, y, z, vx, vy, vz) in positions {
+        // Validate values before quantizing
+        if !validate_position(x, y, z) || !validate_velocity(vx, vy, vz) {
+            continue;
+        }
+        
+        // Quantize and add position
+        binary_data.extend_from_slice(&quantize_position(x).to_le_bytes());
+        binary_data.extend_from_slice(&quantize_position(y).to_le_bytes());
+        binary_data.extend_from_slice(&quantize_position(z).to_le_bytes());
+        
+        // Quantize and add velocity
+        binary_data.extend_from_slice(&quantize_velocity(vx).to_le_bytes());
+        binary_data.extend_from_slice(&quantize_velocity(vy).to_le_bytes());
+        binary_data.extend_from_slice(&quantize_velocity(vz).to_le_bytes());
+    }
     
-    #[serde(rename = "setSimulationMode")]
-    SetSimulationMode { mode: String },
+    binary_data
+}
+
+/// Helper function to parse binary position update message
+pub fn parse_binary_update(data: &[u8]) -> Option<(bool, Vec<(f32, f32, f32, f32, f32, f32)>)> {
+    if data.len() < BINARY_HEADER_SIZE {
+        return None;
+    }
     
-    #[serde(rename = "recalculateLayout")]
-    RecalculateLayout { params: SimulationParams },
+    // Read initial layout flag
+    let mut flag_bytes = [0u8; 4];
+    flag_bytes.copy_from_slice(&data[0..4]);
+    let is_initial = f32::from_le_bytes(flag_bytes) >= 1.0;
     
-    #[serde(rename = "ragflowQuery")]
-    RagflowQuery {
-        message: String,
-        quote: Option<bool>,
-        doc_ids: Option<Vec<String>>
-    },
+    // Calculate number of positions
+    let num_positions = (data.len() - BINARY_HEADER_SIZE) / BINARY_NODE_SIZE;
+    let mut positions = Vec::with_capacity(num_positions);
     
-    #[serde(rename = "openaiQuery")]
-    OpenAIQuery { message: String },
-
-    #[serde(rename = "updateFisheyeSettings")]
-    UpdateFisheyeSettings {
-        enabled: bool,
-        strength: f32,
-        focus_point: [f32; 3],
-        radius: f32,
-    },
-
-    #[serde(rename = "updateSettings")]
-    UpdateSettings {
-        settings: Value
+    // Parse positions and velocities
+    let mut offset = BINARY_HEADER_SIZE;
+    while offset + BINARY_NODE_SIZE <= data.len() {
+        let mut buf = [0i32; 6];
+        for i in 0..6 {
+            let mut bytes = [0u8; 4];
+            bytes.copy_from_slice(&data[offset + i * 4..offset + (i + 1) * 4]);
+            buf[i] = i32::from_le_bytes(bytes);
+        }
+        
+        let x = dequantize_position(buf[0]);
+        let y = dequantize_position(buf[1]);
+        let z = dequantize_position(buf[2]);
+        let vx = dequantize_velocity(buf[3]);
+        let vy = dequantize_velocity(buf[4]);
+        let vz = dequantize_velocity(buf[5]);
+        
+        // Validate dequantized values
+        if validate_position(x, y, z) && validate_velocity(vx, vy, vz) {
+            positions.push((x, y, z, vx, vy, vz));
+        }
+        
+        offset += BINARY_NODE_SIZE;
     }
+    
+    Some((is_initial, positions))
 }
 
-/// Represents messages sent from the server to the client.
-#[derive(Serialize, Deserialize, Debug)]
+/// Server message types for WebSocket communication
+#[derive(Serialize, Debug)]
 #[serde(tag = "type")]
 pub enum ServerMessage {
-    #[serde(rename = "audioData")]
-    AudioData {
-        audio_data: String // base64 encoded audio
-    },
-    
-    #[serde(rename = "ragflowResponse")]
-    RagflowResponse {
-        answer: String
-    },
-    
-    #[serde(rename = "openaiResponse")]
-    OpenAIResponse {
-        response: String,
-        audio: Option<String> // base64 encoded audio
-    },
-    
-    #[serde(rename = "error")]
-    Error {
-        message: String,
-        code: Option<String>
-    },
-    
     #[serde(rename = "graphUpdate")]
     GraphUpdate {
-        graph_data: Value
+        graph_data: Value,
+    },
+    #[serde(rename = "settingsUpdated")]
+    SettingsUpdated {
+        settings: Value,
     },
-    
     #[serde(rename = "simulationModeSet")]
     SimulationModeSet {
         mode: String,
-        gpu_enabled: bool
+        gpu_enabled: bool,
     },
-
     #[serde(rename = "fisheyeSettingsUpdated")]
     FisheyeSettingsUpdated {
         enabled: bool,
@@ -189,103 +166,33 @@ pub enum ServerMessage {
         focus_point: [f32; 3],
         radius: f32,
     },
-
-    #[serde(rename = "gpuPositions")]
-    GPUPositions(GPUPositionUpdate),
-
-    #[serde(rename = "settings_updated")]
-    SettingsUpdated {
-        settings: Value
-    }
+    #[serde(rename = "error")]
+    Error {
+        message: String,
+        code: Option<String>,
+    },
 }
 
-pub trait MessageHandler: Actor<Context = ws::WebsocketContext<Self>> {
-    fn send_json_response(&self, response: Value, ctx: &mut ws::WebsocketContext<Self>) {
-        match serde_json::to_string(&response) {
-            Ok(json_string) => {
-                debug!("Sending JSON response: {}", json_string);
-                ctx.text(ByteString::from(json_string));
-            },
-            Err(e) => {
-                error!("Failed to serialize JSON response: {}", e);
-                let error_message = json!({
-                    "type": "error",
-                    "message": format!("Failed to serialize response: {}", e),
-                    "code": "SERIALIZATION_ERROR"
-                });
-                if let Ok(error_string) = serde_json::to_string(&error_message) {
-                    ctx.text(ByteString::from(error_string));
-                }
-            }
-        }
-    }
-
-    fn send_server_message(&self, message: ServerMessage, ctx: &mut ws::WebsocketContext<Self>) {
-        match serde_json::to_value(message) {
-            Ok(value) => self.send_json_response(value, ctx),
-            Err(e) => {
-                error!("Failed to serialize ServerMessage: {}", e);
-                let error_message = json!({
-                    "type": "error",
-                    "message": "Internal server error",
-                    "code": "SERIALIZATION_ERROR"
-                });
-                self.send_json_response(error_message, ctx);
-            }
-        }
-    }
-
-    fn handle_fisheye_update(&self, settings: ClientMessage, gpu_compute: &mut crate::utils::gpu_compute::GPUCompute, ctx: &mut ws::WebsocketContext<Self>) {
-        if let ClientMessage::UpdateFisheyeSettings { enabled, strength, focus_point, radius } = settings {
-            match gpu_compute.update_fisheye_params(enabled, strength, focus_point, radius) {
-                Ok(_) => {
-                    // Send confirmation back to client
-                    self.send_server_message(
-                        ServerMessage::FisheyeSettingsUpdated {
-                            enabled,
-                            strength,
-                            focus_point,
-                            radius,
-                        },
-                        ctx
-                    );
-                },
-                Err(e) => {
-                    error!("Failed to update fisheye settings: {}", e);
-                    self.send_server_message(
-                        ServerMessage::Error {
-                            message: format!("Failed to update fisheye settings: {}", e),
-                            code: Some("FISHEYE_UPDATE_ERROR".to_string()),
-                        },
-                        ctx
-                    );
-                }
-            }
-        }
-    }
-
-    fn handle_settings_update(&self, settings: Value, ctx: &mut ws::WebsocketContext<Self>) {
-        // Write to settings.toml
-        if let Err(e) = fs::write("settings.toml", toml::to_string_pretty(&settings).unwrap()) {
-            error!("Failed to write settings.toml: {}", e);
-            self.send_server_message(
-                ServerMessage::Error {
-                    message: format!("Failed to save settings: {}", e),
-                    code: Some("SETTINGS_WRITE_ERROR".to_string()),
-                },
-                ctx
-            );
-            return;
-        }
-
-        // Send confirmation back to client
-        self.send_server_message(
-            ServerMessage::SettingsUpdated {
-                settings
-            },
-            ctx
-        );
-    }
+/// Client message types for WebSocket communication
+#[derive(Deserialize, Debug)]
+#[serde(tag = "type")]
+pub enum ClientMessage {
+    #[serde(rename = "updateNodePosition")]
+    UpdateNodePosition {
+        node_id: String,
+        position: [f32; 3],
+    },
+    #[serde(rename = "setSimulationMode")]
+    SetSimulationMode {
+        mode: String,
+    },
+    #[serde(rename = "updateFisheyeSettings")]
+    UpdateFisheyeSettings {
+        enabled: bool,
+        strength: f32,
+        focus_point: [f32; 3],
+        radius: f32,
+    },
 }
 
 #[cfg(test)]
@@ -293,89 +200,49 @@ mod tests {
     use super::*;
 
     #[test]
-    fn test_client_message_serialization() {
-        let message = ClientMessage::ChatMessage {
-            message: "Hello".to_string(),
-            use_openai: true
-        };
-        let serialized = serde_json::to_string(&message).unwrap();
-        assert!(serialized.contains("chatMessage"));
-        assert!(serialized.contains("Hello"));
-
-        let fisheye_message = ClientMessage::UpdateFisheyeSettings {
-            enabled: true,
-            strength: 0.5,
-            focus_point: [0.0, 0.0, 0.0],
-            radius: 100.0,
-        };
-        let serialized = serde_json::to_string(&fisheye_message).unwrap();
-        assert!(serialized.contains("updateFisheyeSettings"));
-        assert!(serialized.contains("strength"));
-
-        let settings_message = ClientMessage::UpdateSettings {
-            settings: json!({
-                "visualization": {
-                    "node_color": "#FFA500"
-                }
-            })
-        };
-        let serialized = serde_json::to_string(&settings_message).unwrap();
-        assert!(serialized.contains("updateSettings"));
-        assert!(serialized.contains("visualization"));
+    fn test_position_quantization() {
+        let pos = 123.456;
+        let quantized = quantize_position(pos);
+        let dequantized = dequantize_position(quantized);
+        assert!((pos - dequantized).abs() < 0.001);
     }
 
     #[test]
-    fn test_server_message_serialization() {
-        let message = ServerMessage::RagflowResponse {
-            answer: "Test answer".to_string()
-        };
-        let serialized = serde_json::to_string(&message).unwrap();
-        assert!(serialized.contains("ragflowResponse"));
-        assert!(serialized.contains("Test answer"));
+    fn test_velocity_quantization() {
+        let vel = 1.2345;
+        let quantized = quantize_velocity(vel);
+        let dequantized = dequantize_velocity(quantized);
+        assert!((vel - dequantized).abs() < 0.0001);
+    }
 
-        let fisheye_message = ServerMessage::FisheyeSettingsUpdated {
-            enabled: true,
-            strength: 0.5,
-            focus_point: [0.0, 0.0, 0.0],
-            radius: 100.0,
-        };
+    #[test]
+    fn test_binary_update_roundtrip() {
+        let positions = vec![
+            (1.0, 2.0, 3.0, 0.1, 0.2, 0.3),
+            (-1.0, -2.0, -3.0, -0.1, -0.2, -0.3),
+        ];
+        let binary = create_binary_update(&positions, true);
+        let parsed = parse_binary_update(&binary).unwrap();
         
-        let json = serde_json::to_string(&fisheye_message).unwrap();
-        assert!(json.contains("\"type\":\"fisheye_settings_updated\""));
-        assert!(json.contains("\"enabled\":true"));
-        assert!(json.contains("\"strength\":0.5"));
-        assert!(json.contains("\"focus_point\":[0.0,0.0,0.0]"));
-        assert!(json.contains("\"radius\":100.0"));
-
-        let settings_message = ServerMessage::SettingsUpdated {
-            settings: json!({
-                "visualization": {
-                    "node_color": "#FFA500"
-                }
-            })
-        };
-        let json = serde_json::to_string(&settings_message).unwrap();
-        assert!(json.contains("\"type\":\"settings_updated\""));
-        assert!(json.contains("visualization"));
+        assert!(parsed.0); // is_initial
+        assert_eq!(parsed.1.len(), positions.len());
+        
+        for (orig, parsed) in positions.iter().zip(parsed.1.iter()) {
+            assert!((orig.0 - parsed.0).abs() < 0.001);
+            assert!((orig.1 - parsed.1).abs() < 0.001);
+            assert!((orig.2 - parsed.2).abs() < 0.001);
+            assert!((orig.3 - parsed.3).abs() < 0.0001);
+            assert!((orig.4 - parsed.4).abs() < 0.0001);
+            assert!((orig.5 - parsed.5).abs() < 0.0001);
+        }
     }
 
     #[test]
-    fn test_gpu_position_update_binary() {
-        let update = GPUPositionUpdate {
-            updates: vec![
-                NodePositionVelocity { x: 1.0, y: 2.0, z: 3.0, vx: 0.1, vy: 0.2, vz: 0.3 },
-                NodePositionVelocity { x: 4.0, y: 5.0, z: 6.0, vx: 0.4, vy: 0.5, vz: 0.6 },
-            ],
-            is_initial_layout: true
-        };
-
-        let binary = update.to_binary();
-        assert_eq!(binary.len(), 52); // 4 bytes header + 2 * 24 bytes data
-
-        let decoded = GPUPositionUpdate::from_binary(&binary, 2).unwrap();
-        assert_eq!(decoded.updates.len(), 2);
-        assert_eq!(decoded.is_initial_layout, true);
-        assert_eq!(decoded.updates[0].x, 1.0);
-        assert_eq!(decoded.updates[1].vz, 0.6);
+    fn test_validation() {
+        assert!(validate_position(100.0, -100.0, 500.0));
+        assert!(!validate_position(2000.0, 0.0, 0.0));
+        
+        assert!(validate_velocity(10.0, -10.0, 20.0));
+        assert!(!validate_velocity(100.0, 0.0, 0.0));
     }
 }
